00:00:20.020 --> 00:00:26.393
UIKit應用基於協議與值的編程

00:00:30.030 --> 00:00:32.031
大家下午好 歡迎大家的到來

00:00:32.766 --> 00:00:35.836
我叫Alex 我和Jacob
今天將會跟大家談一下

00:00:36.270 --> 00:00:38.705
如何使用值類型和協議

00:00:38.972 --> 00:00:40.073
來提高應用的性能

00:00:40.507 --> 00:00:41.708
我們今天的重點是

00:00:41.775 --> 00:00:44.011
一個叫做局部推理的東西

00:00:45.579 --> 00:00:49.016
局部推理的意思是
當你看眼前的代碼時

00:00:49.683 --> 00:00:52.386
你不必考慮其他代碼

00:00:52.452 --> 00:00:53.720
與那個函數如何互動

00:00:54.454 --> 00:00:56.256
你之前可能有過這種感覺

00:00:56.957 --> 00:00:58.892
而這就是那種感覺的一個稱呼

00:00:59.826 --> 00:01:03.297
比如 也許你剛加入一個新團隊

00:01:03.497 --> 00:01:06.700
你要看大量的代碼
但是環境很少

00:01:07.301 --> 00:01:10.003
你能明白那一個函數正在
實現什麼功能嗎？

00:01:10.838 --> 00:01:13.440
所以瞭解這個信息是非常重要的

00:01:13.540 --> 00:01:15.442
因爲這樣維護起來更容易

00:01:15.742 --> 00:01:16.844
寫起代碼來更容易

00:01:17.077 --> 00:01:18.278
測試起來更容易

00:01:18.712 --> 00:01:20.747
首次參與編碼也更容易

00:01:22.216 --> 00:01:24.518
所以我們要談一下
局部推理會如何

00:01:25.419 --> 00:01:26.954
在模型視圖控制器設計範例環境下

00:01:27.254 --> 00:01:30.457
改善我們的UIKit應用

00:01:31.158 --> 00:01:34.595
就是Cocoa所使用的模型存儲數據

00:01:35.395 --> 00:01:36.730
視圖呈現數據

00:01:37.364 --> 00:01:39.600
控制器在兩者之間協調

00:01:41.201 --> 00:01:43.770
我們需要一個真實的應用
來驗證我們的答案

00:01:45.138 --> 00:01:48.642
不幸的是在Apple中我們實際上
有一個問題需要解決

00:01:51.812 --> 00:01:53.514
我要跟你們說個祕密

00:01:53.580 --> 00:01:55.983
關於我們每年
是如何準備 WWDC 的

00:01:57.484 --> 00:01:58.886
工程師都有夢想

00:01:59.453 --> 00:02:02.823
他們要呈現他們所夢想的東西

00:02:03.056 --> 00:02:06.827
無論用什麼方式 我們要了解
這些夢想 並把它們記錄下來

00:02:07.394 --> 00:02:11.498
但我們注意到許多工程師實際上
在工作時

00:02:11.565 --> 00:02:12.966
就不再記得他們的夢想了

00:02:13.033 --> 00:02:14.067
他們忘了自己的夢想

00:02:14.701 --> 00:02:16.904
所以我和Jacob開發了
這款很棒的應用

00:02:17.271 --> 00:02:18.305
可讓你們記起自己的夢想

00:02:19.006 --> 00:02:20.974
該應用就叫Lucid Dreams

00:02:22.509 --> 00:02:25.879
我要展示去年人們的一些夢想

00:02:27.281 --> 00:02:29.483
有些人夢想成爲麒麟

00:02:30.851 --> 00:02:31.952
這是認真的

00:02:34.988 --> 00:02:37.758
很奇怪的是 有些人

00:02:39.193 --> 00:02:42.596
仍然被工作壓力問題所束縛

00:02:44.765 --> 00:02:48.435
他們更想離開辦公室去騎車

00:02:50.370 --> 00:02:54.074
有些工程師甚至夢想成爲Crusty

00:03:02.216 --> 00:03:04.551
那就是我們應用的靈感

00:03:04.618 --> 00:03:07.421
由於我們將在演講中使用這個應用

00:03:07.487 --> 00:03:08.956
我想快速給你們展示一個演示

00:03:09.456 --> 00:03:11.725
這樣你就能明白這個應用是做什麼的

00:03:13.026 --> 00:03:15.629
如果我們啓動應用
你會注意到它會把我們帶到

00:03:15.696 --> 00:03:17.564
我們現有的夢想列表中

00:03:18.699 --> 00:03:21.101
如果你輕觸其中一個夢想
你可以編輯它

00:03:22.569 --> 00:03:24.738
並且在頂部可以看到預覽

00:03:25.305 --> 00:03:28.041
可以向下滾動並添加一些特效

00:03:28.242 --> 00:03:30.377
比如激光束和雨

00:03:31.945 --> 00:03:36.450
然後往回滾動到原來的位置
你可以看到夢想的預覽

00:03:36.683 --> 00:03:40.888
麒麟有激光束、雨和噴火特效

00:03:42.556 --> 00:03:44.391
編輯完成後

00:03:44.458 --> 00:03:46.426
返回夢想列表

00:03:48.061 --> 00:03:49.530
這就是這個應用

00:03:50.764 --> 00:03:54.701
我們要認真努力地思考
如何寫出更優秀的代碼

00:03:55.235 --> 00:03:58.438
所以我們去年參加了一些
很不錯的Swift演講

00:03:59.706 --> 00:04:02.042
這些演講的主題是值類型
和麪向協議的編程

00:04:02.109 --> 00:04:03.877
的好處

00:04:04.444 --> 00:04:06.213
這些想法非常強大

00:04:06.413 --> 00:04:08.148
我們想要利用它們

00:04:08.215 --> 00:04:11.618
因爲它們可以幫助改善
應用中的局部推理

00:04:12.419 --> 00:04:15.122
所以我們用這種不一樣的思考
方式寫出了這個應用

00:04:15.989 --> 00:04:19.560
現在你可能覺得有些想法很陌生
沒有關係

00:04:19.927 --> 00:04:22.262
我們首次嘗試這些技術時

00:04:22.329 --> 00:04:24.164
我們也覺得很陌生

00:04:24.464 --> 00:04:26.233
所以不要擔心 繼續聽我們講

00:04:30.337 --> 00:04:32.539
我們會快速地談一下模型層中

00:04:32.606 --> 00:04:34.241
值類型的好處

00:04:34.808 --> 00:04:37.911
去年已經談過了
所以我們要快速回顧一下

00:04:39.246 --> 00:04:41.582
然後我們重點講如何
在視圖控制器層

00:04:41.648 --> 00:04:43.350
使用值類型

00:04:43.750 --> 00:04:48.655
因爲我們認爲絕大部分人認爲
他們不會利用值類型

00:04:49.089 --> 00:04:51.491
即使它們有一些切實的好處

00:04:52.860 --> 00:04:56.163
在演講中 我會演示如何使用
值類型和協議

00:04:56.230 --> 00:04:57.831
使代碼變得可測試

00:04:59.233 --> 00:05:02.970
你剛剛看到了這個很棒的應用
我知道你想測試

00:05:03.036 --> 00:05:04.838
我們已經發布了示例應用

00:05:04.905 --> 00:05:08.242
你可以自己下載 查看代碼

00:05:08.308 --> 00:05:09.643
並記錄你自己的夢想

00:05:12.446 --> 00:05:15.148
好了 現在 是時候談模型層了

00:05:16.416 --> 00:05:17.384
那麼夢想是什麼？

00:05:19.419 --> 00:05:21.054
夢想是模型類型

00:05:21.121 --> 00:05:23.690
會在應用中呈現夢想

00:05:24.825 --> 00:05:28.762
夢想可以是描述、
創造物和一組特效

00:05:28.829 --> 00:05:30.430
正如你剛纔在UI上看到的一樣

00:05:31.365 --> 00:05:33.333
我想展示夢想類型的一個版本

00:05:33.400 --> 00:05:36.403
是我們去年在應用的第一個版本中使用的

00:05:37.171 --> 00:05:39.239
最開始我們的夢想類型是一個類

00:05:40.274 --> 00:05:42.576
類有引用語義

00:05:42.910 --> 00:05:46.346
意思就是引用同一個實例會共享存儲

00:05:46.413 --> 00:05:47.848
這樣的共享很含蓄

00:05:48.749 --> 00:05:50.317
這爲什麼會是個問題呢？

00:05:52.352 --> 00:05:56.156
嗯 假如某人嘗試修改
dream2的描述

00:05:57.558 --> 00:06:00.594
如果我們關注dream1
我們會非常吃驚

00:06:00.827 --> 00:06:03.997
因爲變量的值在我們的控制下
發生了變更

00:06:06.500 --> 00:06:08.669
這非常影響局部推理

00:06:10.237 --> 00:06:13.340
而且我們自己的應用
即使通過了測試

00:06:13.407 --> 00:06:14.908
恰有這種漏洞

00:06:15.542 --> 00:06:16.543
爲什麼會這樣呢？

00:06:19.580 --> 00:06:22.015
這個圖表顯示了應用

00:06:22.082 --> 00:06:24.117
第一個版本中的關係

00:06:24.952 --> 00:06:27.955
有些關係可以同時兼具明顯和含蓄

00:06:28.255 --> 00:06:30.257
有些關係既可以是單向的
又可以是雙向的

00:06:30.858 --> 00:06:33.026
有些關係甚至既可靜態又可動態

00:06:34.595 --> 00:06:37.297
所以這些關係可以變得
非常非常複雜

00:06:39.499 --> 00:06:40.968
那麼當我們嘗試測試它自己的

00:06:41.034 --> 00:06:43.971
夢想類型時發生了什麼呢？

00:06:45.572 --> 00:06:49.510
嗯 即使你創建一個能自己
支持自己的夢

00:06:50.377 --> 00:06:53.113
也不會在應用中反映實際情況

00:06:53.180 --> 00:06:55.983
因爲實際存在更多的依賴性

00:07:00.921 --> 00:07:02.222
這樣很不好

00:07:06.727 --> 00:07:09.763
我們可以通過使夢想類型成爲
有值語義

00:07:09.830 --> 00:07:11.231
的結構來解決這個問題

00:07:12.466 --> 00:07:15.102
意思是每個變量都有獨立的存儲

00:07:15.235 --> 00:07:17.404
改變其中一個變量的值

00:07:17.471 --> 00:07:19.673
不會影響其他變量的值

00:07:20.040 --> 00:07:22.876
如果我們修改dream2的描述

00:07:23.844 --> 00:07:26.980
我們只能修改dream2的描述
不會影響dream1的描述

00:07:28.048 --> 00:07:31.318
這就確保夢想不會涉及

00:07:31.385 --> 00:07:34.054
我們之前所看到的複雜關係

00:07:37.024 --> 00:07:40.260
這也證明瞭我們有局部推理的能力

00:07:40.627 --> 00:07:45.165
因爲沒有代碼能改變在我們的
控制下正在使用的值

00:07:46.800 --> 00:07:49.269
接下來講使用值類型

00:07:49.336 --> 00:07:53.240
我們剛看到了我們是如何在模型層
中利用值類型的

00:07:54.007 --> 00:07:57.811
而且在模型層使用值類型實際上
是沒有任何爭議的

00:07:58.745 --> 00:08:02.082
但你們就不想
在我們應用的其他部分

00:08:02.149 --> 00:08:03.951
利用我們剛剛看到的這種好處嗎？

00:08:05.552 --> 00:08:07.621
實際上可能會很吸睛

00:08:07.855 --> 00:08:11.725
我想引用一句話
是我最近在因特網上看到的

00:08:12.359 --> 00:08:15.762
說“只在簡單的
模型類型上使用值”

00:08:17.297 --> 00:08:18.966
聽起來一點兒都不勵志

00:08:19.733 --> 00:08:22.903
但我們會相信從因特網上
看到的所有東西嗎？

00:08:24.204 --> 00:08:27.241
答案是不會 如果你不瞭解的話

00:08:30.010 --> 00:08:31.678
那麼 在接下來的演講中

00:08:31.745 --> 00:08:34.214
我們主要談如何在應用複雜的

00:08:34.347 --> 00:08:36.582
模型數據中使用值

00:08:37.751 --> 00:08:40.020
同時我們將證明因特網上的
那種說法是錯誤的

00:08:44.691 --> 00:08:45.626
好的

00:08:46.126 --> 00:08:49.396
讓我們邀請Jacob上臺
講一下視圖層

00:08:56.937 --> 00:08:57.905
謝謝Alex

00:09:00.574 --> 00:09:04.111
我真的很樂於跟你們講我們是如何
與視圖一起

00:09:04.278 --> 00:09:05.279
使用基於協議的編程

00:09:06.813 --> 00:09:09.750
我們在應用的表視圖單元上花了
很多時間

00:09:10.817 --> 00:09:14.021
我們對它們的佈局進行了精心設計
我們想要實現

00:09:14.087 --> 00:09:17.724
完全顯示出
人們所夢想的麒麟

00:09:19.459 --> 00:09:21.728
當開始開發應用時
我們寫了這些佈局

00:09:21.795 --> 00:09:24.198
作爲UITableViewCell
抽象子類

00:09:25.065 --> 00:09:28.535
比如 這個簡單佈局 我們把它叫做
DecoratingLayoutCell

00:09:29.236 --> 00:09:31.171
它左側顯示了一點兒裝飾

00:09:31.538 --> 00:09:33.540
右側有大塊的內容

00:09:35.375 --> 00:09:38.145
然後 我們做了一個佈局單元
的具體子類

00:09:38.245 --> 00:09:40.781
添加具體邏輯 比如顯示夢想

00:09:42.015 --> 00:09:44.251
我們做了這種分離 因爲我們想

00:09:44.318 --> 00:09:46.520
在不同的地方重新使用佈局

00:09:47.521 --> 00:09:48.989
但隨着開發的繼續

00:09:49.056 --> 00:09:51.124
我們發現越來越不好用了

00:09:51.625 --> 00:09:53.861
它能幫助我們在不同的單元
重新使用佈局

00:09:54.628 --> 00:09:56.830
但很難在表視圖外使用

00:09:57.998 --> 00:09:59.466
比如 我們有個詳細視圖

00:09:59.700 --> 00:10:01.735
顯示夢想的更多信息

00:10:01.802 --> 00:10:04.037
但我們不能在那兒重新使用
佈局單元

00:10:05.405 --> 00:10:07.508
我們想找到更好的方式來構造

00:10:07.574 --> 00:10:10.477
以便我們能在表視圖單元上
使用佈局

00:10:10.978 --> 00:10:12.913
同時也能在普通UI視圖中
使用佈局

00:10:14.047 --> 00:10:15.949
我們還想在應用中
添加SpriteKit

00:10:16.016 --> 00:10:17.784
顯示那些很酷的粒子特效

00:10:17.918 --> 00:10:21.088
並且我們也想在SpriteKit
節點中使用佈局

00:10:22.356 --> 00:10:25.859
這就是我們的目標 我們用從
Swift學到的東西來實現這個目標

00:10:26.994 --> 00:10:29.329
雖然我要具體地講佈局

00:10:29.663 --> 00:10:30.731
我想讓你們記住一點

00:10:30.831 --> 00:10:33.233
這些技術可以在整個應用中使用

00:10:33.967 --> 00:10:35.369
好了 我們開始吧

00:10:37.604 --> 00:10:40.073
這是我們以前的佈局單元

00:10:40.407 --> 00:10:42.843
有兩個視圖

00:10:43.243 --> 00:10:46.947
但這個佈局邏輯實際上不需要
被困在單元內

00:10:47.147 --> 00:10:50.450
只需要一些數學和幾何學
就能算出一組框架

00:10:51.985 --> 00:10:55.189
讓我們從不讓單元只是作爲
普通結構開始吧

00:10:56.223 --> 00:10:57.658
它仍會有兩個視圖

00:10:58.725 --> 00:11:01.361
我們可以把所有佈局邏輯
放在一個方法中

00:11:01.428 --> 00:11:03.330
可以調用方法 顯示佈局

00:11:04.731 --> 00:11:06.266
只做了這樣小小的變更

00:11:06.333 --> 00:11:08.635
我們就擁有了非常獨立的代碼

00:11:08.902 --> 00:11:11.405
這些代碼知道如何實現佈局
僅此而已

00:11:13.574 --> 00:11:17.344
然後 我們可以更新夢想單元
使用新結構來展示它的子單元

00:11:18.512 --> 00:11:20.380
好消息是我們現能在UIView子類中

00:11:20.447 --> 00:11:22.049
使用獨立代碼了

00:11:23.217 --> 00:11:26.119
現在 這個佈局邏輯已經跟
表視圖單元不掛鉤了

00:11:26.286 --> 00:11:27.855
我們可在任何UIView中使用

00:11:29.923 --> 00:11:31.925
還有一個好處

00:11:32.025 --> 00:11:34.528
我們能獨立使用佈局

00:11:34.828 --> 00:11:37.798
可以非常方便地做單元測試

00:11:37.965 --> 00:11:39.533
我們只需要創建一些視圖

00:11:40.501 --> 00:11:41.835
並把它們添加到佈局中

00:11:43.036 --> 00:11:45.038
然後在一個已知的矩形中
展示出來

00:11:46.006 --> 00:11:47.441
再然後 我們只需要驗證

00:11:47.508 --> 00:11:49.643
結果展示的框架是否正是
我們所期待的框架

00:11:50.244 --> 00:11:52.279
我們的測試不必創建表視圖

00:11:52.479 --> 00:11:54.882
或等待正確的視圖佈局
回調函數起作用

00:11:54.948 --> 00:11:57.684
只需要通知佈局開始運行
然後驗證輸出

00:11:58.919 --> 00:12:01.255
這是我們得到的其中一個好處

00:12:01.822 --> 00:12:04.491
新佈局的結構很小、很緊湊

00:12:04.992 --> 00:12:08.095
這種變更使它更容易對這個代碼
進行局部推理

00:12:08.929 --> 00:12:11.164
如果我們想了解對佈局的測試

00:12:11.431 --> 00:12:14.268
我們只需要瞭解那個
獨立的小結構

00:12:15.035 --> 00:12:17.304
我們不想考慮 哪組視圖

00:12:17.371 --> 00:12:18.872
它可能會使用或覆蓋

00:12:21.441 --> 00:12:24.444
好的 現在讓我們返回
DecoratingLayout代碼

00:12:26.446 --> 00:12:29.116
現在 這個代碼只知道
如何顯示視圖

00:12:29.216 --> 00:12:31.051
但就像我剛纔所說的
我們也想用這個

00:12:31.118 --> 00:12:32.519
支持SpriteKit

00:12:34.288 --> 00:12:36.423
所以 我們不想複製這個代碼

00:12:36.490 --> 00:12:38.725
但SKNode並非UIView子類

00:12:39.293 --> 00:12:41.862
所以這裏沒有可用的通用超類

00:12:42.529 --> 00:12:45.165
那麼我們如何把這兩者結合到
一個單一佈局中呢？

00:12:46.834 --> 00:12:49.169
由於我們的佈局在這些子類中
所實現的唯一功能

00:12:49.236 --> 00:12:50.504
是設置它們的框架

00:12:50.771 --> 00:12:53.473
這是我們需要的唯一功能

00:12:53.807 --> 00:12:56.310
我們可以通過協議
來實現這個需求

00:12:57.678 --> 00:12:58.979
我們要做一個協議

00:12:59.046 --> 00:13:01.415
這個協議只有一個單一框架屬性

00:13:01.849 --> 00:13:04.852
這樣還不流暢
我們要稍微改進一下

00:13:06.086 --> 00:13:09.022
然後 我們使用這個協議
作爲子類的類型

00:13:09.656 --> 00:13:11.225
而不是把它們做成視圖

00:13:13.727 --> 00:13:15.996
最後 我們可以使用追溯模型

00:13:16.230 --> 00:13:19.333
使UIView和
SKNode遵守新協議

00:13:20.567 --> 00:13:23.237
現在 我們有一個能在兩種類型中
使用的佈局了

00:13:23.303 --> 00:13:25.939
這是使用協議 的好處之一

00:13:26.006 --> 00:13:28.075
並非爲實現多態的超類

00:13:28.775 --> 00:13:30.711
我們可以使用協議把這個功能添加

00:13:30.811 --> 00:13:33.213
到不相關的類型
並在兩種類型中使用

00:13:34.815 --> 00:13:38.252
現在 我們的佈局
不再依賴於UIKit了

00:13:38.785 --> 00:13:40.254
我們能做的另一件事是

00:13:40.320 --> 00:13:43.590
把同樣的體系帶到AppKit中
並支持展示NS視圖

00:13:43.657 --> 00:13:44.758
非常簡單

00:13:44.825 --> 00:13:46.159
我覺得這很酷

00:13:48.328 --> 00:13:49.563
我們已經很接近了

00:13:49.630 --> 00:13:51.965
但仍然還有要改進的東西

00:13:53.233 --> 00:13:55.736
當我們在視圖中使用
DecoratingLayout時

00:13:55.802 --> 00:13:58.705
我們想把所有內容添加爲子視圖

00:13:59.339 --> 00:14:01.942
類似地 當我們在SpriteKit
場景中使用它時

00:14:02.042 --> 00:14:04.411
我們把內容添加爲子節點

00:14:05.279 --> 00:14:08.949
但現在 內容和裝飾可以是
有框架的任何類型

00:14:10.083 --> 00:14:13.754
意思是 比如
我們的內容可以是個UIView

00:14:14.021 --> 00:14:15.756
而裝飾是一個SKNode

00:14:16.790 --> 00:14:20.861
但相反 我們想讓佈局
只有一組UI視圖

00:14:20.928 --> 00:14:22.629
或只有一組SK節點
作爲其子佈局

00:14:24.264 --> 00:14:27.367
那樣 我們就能把它們添加到
相應的父佈局中

00:14:28.402 --> 00:14:31.071
現在Swift有一種方式
就是用泛型表達

00:14:32.339 --> 00:14:34.708
我們可以把佈局更新爲通用類型

00:14:34.942 --> 00:14:36.743
類型參數叫child

00:14:38.145 --> 00:14:40.113
然後我們可以使內容

00:14:40.180 --> 00:14:42.616
和裝飾屬性使用child
作爲它們的類型

00:14:43.417 --> 00:14:45.419
這就正好提供了我們想要的結果

00:14:45.552 --> 00:14:48.055
我們可以強制它們是同一種
具體類型

00:14:48.155 --> 00:14:49.756
這樣我們的
DecoratingLayout

00:14:49.823 --> 00:14:52.926
就只能有UI視圖或只包含
SK節點的視圖

00:14:53.493 --> 00:14:56.196
因此 泛型是一個很棒的工具
可使我們對代碼中的類型

00:14:56.263 --> 00:14:57.664
擁有更多的控制

00:14:58.632 --> 00:15:00.234
泛型的另一個好處是

00:15:00.300 --> 00:15:03.504
編譯器能獲得關於代碼功能的更多信息

00:15:03.904 --> 00:15:05.272
因此可以進行更多優化

00:15:06.106 --> 00:15:08.008
你可以從瞭解Swift的性能演講中

00:15:08.075 --> 00:15:10.143
更詳細地瞭解這些信息

00:15:10.377 --> 00:15:12.446
那是場不錯的演講
可以瞭解Swift如何運作

00:15:12.513 --> 00:15:14.548
以及如何寫出迅捷的Swift代碼

00:15:16.884 --> 00:15:19.987
好了 我們現有一個不錯的
DecoratingLayout實現

00:15:20.721 --> 00:15:23.023
但是我們的應用還包含許多其他佈局

00:15:23.557 --> 00:15:24.958
比如這個級聯佈局

00:15:25.792 --> 00:15:29.396
這個佈局類似於我們剛看到的
DecoratingLayout

00:15:30.197 --> 00:15:31.899
右側都顯示一大塊區域

00:15:32.332 --> 00:15:34.101
左側有詳細的裝飾區

00:15:35.002 --> 00:15:38.038
我們不想粘貼複製代碼
來創建這個新佈局

00:15:38.105 --> 00:15:39.706
那樣可能會失去一個創建兩者

00:15:39.773 --> 00:15:42.409
都能使用的共享抽象的好機會

00:15:43.343 --> 00:15:44.978
我們要如何共享這個代碼呢？

00:15:45.913 --> 00:15:49.283
你們之前幾乎都用過的一個
共享代碼的工具是繼承

00:15:49.616 --> 00:15:51.952
但如果用繼承
你的確是有了代碼

00:15:52.019 --> 00:15:53.787
但是請不要嘗試
讀取這個代碼

00:15:53.854 --> 00:15:56.790
而且你還要考慮超類
可能會有什麼功能

00:15:57.424 --> 00:16:00.294
以及子類想要變更或覆蓋什麼

00:16:00.561 --> 00:16:02.930
除了只考慮你正在用的代碼

00:16:03.030 --> 00:16:05.566
你還要考慮把
分散在應用中的

00:16:05.632 --> 00:16:07.067
大量代碼結合在一起

00:16:07.167 --> 00:16:08.936
而這只是冰山一角

00:16:09.336 --> 00:16:12.005
很多時候你還要從框架類繼承

00:16:12.072 --> 00:16:13.607
如UIView或視圖控制器

00:16:14.107 --> 00:16:16.276
還有大量數量級的代碼

00:16:17.244 --> 00:16:18.679
所以 繼承是另一個

00:16:18.745 --> 00:16:21.782
要使用局部推理的地方

00:16:24.852 --> 00:16:27.788
但我們可以通過合成
更好地共享代碼

00:16:28.956 --> 00:16:32.626
合成是一個簡單的想法
只是把一些小片段結合在一起

00:16:32.693 --> 00:16:33.961
構建一個較大的片段

00:16:34.561 --> 00:16:38.198
但是當合成時
你可以瞭解那些獨立的片段

00:16:39.166 --> 00:16:40.934
你還可以強制封裝

00:16:41.001 --> 00:16:43.470
而不需要擔心子類或超類

00:16:43.837 --> 00:16:45.572
在抽象中產生漏洞

00:16:46.807 --> 00:16:48.442
但合成也不是個新功能

00:16:49.142 --> 00:16:52.513
你以前可能在Objective-C
或其他語言中用過

00:16:53.714 --> 00:16:55.816
以前我們實現佈局的其中
一種方式是

00:16:55.883 --> 00:16:57.551
把視圖組合到一起

00:16:58.318 --> 00:16:59.786
你可能會寫一個UIView

00:16:59.853 --> 00:17:01.788
執行級聯佈局行爲

00:17:02.322 --> 00:17:05.492
再寫另一個UIView
執行裝飾佈局行爲

00:17:05.858 --> 00:17:09.229
然後你可能會將這兩者作爲
子視圖添加到表視圖單元中

00:17:09.963 --> 00:17:11.565
但是有一個大問題

00:17:12.266 --> 00:17:13.901
就是類實例的消耗很大

00:17:14.434 --> 00:17:17.237
當你創建另一個對象時
你會有一個額外的堆式分配

00:17:17.471 --> 00:17:19.138
這比視圖更糟糕

00:17:19.806 --> 00:17:22.009
因爲需要做很多工作來支持視圖

00:17:22.075 --> 00:17:24.511
使視圖能實現像繪製
和事件處理這樣的功能

00:17:25.412 --> 00:17:28.882
正因爲如此 我們非常努力地
嘗試把視圖數量最小化

00:17:29.950 --> 00:17:31.852
所以創建一個不能繪製的視圖

00:17:31.952 --> 00:17:34.621
並且只作爲佈局抽象
是一種很大的浪費

00:17:35.389 --> 00:17:38.392
這也是爲什麼合成視圖方案
不太好的原因

00:17:39.526 --> 00:17:42.095
但通過Swift 我們得到了一個
好得多的方式進行合成

00:17:42.162 --> 00:17:43.664
就是用值類型

00:17:45.232 --> 00:17:47.901
結構是輕量級的 因此
我們可以使用多個結構

00:17:47.968 --> 00:17:51.471
而不需要付出像類和視圖
那麼多的消耗

00:17:52.673 --> 00:17:55.909
因爲結構有值語義
所以就更好了

00:17:56.877 --> 00:17:59.246
使用值類型會有更好的封裝

00:17:59.813 --> 00:18:02.316
可以同時使用這些片段
來進行合成

00:18:02.549 --> 00:18:06.453
而不需要擔心別人修改
你正在使用的代碼

00:18:07.921 --> 00:18:09.690
那麼 讓我們在佈局中應用吧

00:18:11.024 --> 00:18:13.760
嗯 我們可以這樣寫出
佈局中的級聯部分

00:18:14.294 --> 00:18:16.296
使用所列出的子佈局的一個數組

00:18:17.631 --> 00:18:20.634
然後 我們想用
DecoratingLayout構成佈局

00:18:20.934 --> 00:18:22.436
獲得最終效果

00:18:23.837 --> 00:18:26.440
但是還有另外一個
小東西需要改變

00:18:26.507 --> 00:18:28.542
這些佈局只能有UI視圖

00:18:28.609 --> 00:18:30.344
或SK節點的的子佈局

00:18:31.211 --> 00:18:34.681
讓我們推廣一下 這樣我們可以使用
佈局並把它們合成到一起

00:18:37.184 --> 00:18:40.787
我們爲子佈局使用的佈局協議
需要一個框架屬性

00:18:41.355 --> 00:18:43.290
永遠不需給那屬性調用getter

00:18:43.357 --> 00:18:45.492
我們永遠只需要給它設置新值

00:18:45.926 --> 00:18:48.762
我們並不關心子佈局是否有框架

00:18:48.829 --> 00:18:50.731
我們只想使子佈局

00:18:50.797 --> 00:18:52.699
在指定矩形中展示自己

00:18:53.967 --> 00:18:56.270
因此 讓我們改變一下方法

00:18:56.870 --> 00:18:58.705
當我們決定其中一個
子佈局的矩形後

00:18:58.772 --> 00:19:01.175
我們將告訴那個子佈局
要在那個矩形中展示

00:19:02.576 --> 00:19:05.579
UIView和SKNode仍會遵守
我們的協議

00:19:06.180 --> 00:19:09.650
當它們被要求在矩形中展示時
它們將用它來設置它們的框架

00:19:10.017 --> 00:19:13.420
但現在 我們也可以使佈局
遵守這個協議

00:19:13.987 --> 00:19:15.522
它們已經知道如何佈局

00:19:15.589 --> 00:19:17.958
當給它們一個框架時
它們只需要分割那個矩形

00:19:18.025 --> 00:19:19.593
並提供給子佈局

00:19:21.728 --> 00:19:24.932
我們現需稍微
變更一下DecoratingLayout

00:19:24.998 --> 00:19:27.901
允許它在子佈局的類型上
有更多的靈活性

00:19:28.168 --> 00:19:30.637
我們稍後會進行詳細解釋

00:19:32.406 --> 00:19:34.241
現在 我們能創建
我們喜歡的佈局了

00:19:34.308 --> 00:19:37.744
通過把CascadingLayout
和裝飾佈局

00:19:38.078 --> 00:19:39.880
合成到一起

00:19:42.916 --> 00:19:45.752
這種合成可以使我們
以一種聲明的方式

00:19:45.819 --> 00:19:47.254
創建這樣的高級佈局

00:19:47.855 --> 00:19:50.490
示例代碼中還有更多的例子

00:19:51.458 --> 00:19:53.060
當你創建自己的應用時

00:19:53.126 --> 00:19:56.196
當你需要重新使用代碼
或自定義一些行爲時

00:19:56.530 --> 00:19:58.565
請嘗試用合成 這個工具很好用

00:20:01.969 --> 00:20:04.371
那麼我之前提到了我們添加

00:20:04.438 --> 00:20:05.772
佈局內容

00:20:05.839 --> 00:20:08.041
到超級視圖或
SpriteKit場景中

00:20:08.709 --> 00:20:11.979
重點之一就是以正確的順序
添加這些內容

00:20:13.080 --> 00:20:16.283
比如 我們的CascadingLayout
希望它的子佈局按一定的順序排列

00:20:16.350 --> 00:20:19.186
這樣可以顯示成一豎排 一個在
另一個的上面 就像這樣

00:20:20.721 --> 00:20:23.790
我們可以擴展協議
來支持這種需要

00:20:24.691 --> 00:20:26.593
我們將在佈局協議中添加一個屬性

00:20:27.094 --> 00:20:28.829
返回它的內容

00:20:29.796 --> 00:20:32.366
我們的合成佈局將以正確順序

00:20:32.432 --> 00:20:33.800
返回所有內容

00:20:34.468 --> 00:20:37.171
然後葉視圖和節點只返回自己

00:20:38.872 --> 00:20:42.509
但又一次 如果我們只把內容類型
作爲協議

00:20:42.843 --> 00:20:45.212
就會允許產生混合環境

00:20:45.279 --> 00:20:46.780
作爲內容的UI視圖和SK節點

00:20:47.648 --> 00:20:49.716
因爲我們把這些子佈局
添加到了父佈局

00:20:49.783 --> 00:20:51.818
我們只想實現同類集合

00:20:51.885 --> 00:20:54.321
只有UI視圖或只有SK節點

00:20:56.356 --> 00:20:59.426
爲了強制實現這個目標 我們可以
向協議中添加一個關聯類型

00:21:00.394 --> 00:21:02.563
關聯類型就像是一個類型佔位符

00:21:03.130 --> 00:21:06.233
一致的類型選擇想要使用的
具體類型

00:21:07.367 --> 00:21:10.037
協議的關聯類型是我們要放在

00:21:10.103 --> 00:21:12.139
佈局內容的數組中的類型

00:21:13.807 --> 00:21:16.877
這就允許我們寫出一些
只知道如何展示視圖

00:21:16.944 --> 00:21:19.313
並指定其內容類型
爲UIView的代碼

00:21:20.280 --> 00:21:24.051
類似的 我們也可以寫出只有
SK節點作爲內容的佈局

00:21:25.018 --> 00:21:26.753
這種類型的安全性非常好

00:21:26.820 --> 00:21:30.824
跟以前一樣 我們不想
通過佈局的通用版本

00:21:32.359 --> 00:21:34.194
分別給視圖和節點寫佈局

00:21:34.261 --> 00:21:36.830
我們仍然擁有支持
兩者的單一佈局

00:21:37.664 --> 00:21:38.899
對於內容類型

00:21:39.132 --> 00:21:41.401
我們只使用子佈局的內容
無論內容是什麼

00:21:42.769 --> 00:21:44.838
意思是我們可以創建
DecoratingLayout

00:21:44.905 --> 00:21:48.408
要麼只能跟UI視圖一起使用
要麼只能跟SK節點一起使用

00:21:48.842 --> 00:21:51.678
這兩個都是強型的
因此我們可以取出它們的內容

00:21:51.745 --> 00:21:53.080
並準確地瞭解它們

00:21:53.580 --> 00:21:55.549
它們仍然可以共享
所有的佈局邏輯

00:21:56.583 --> 00:22:00.354
相關類型是使協議變得
更健壯的一個好方法

00:22:05.459 --> 00:22:07.528
現在我們改進了佈局協議

00:22:07.594 --> 00:22:10.731
我們還可重新訪問
DecoratingLayout的子佈局類型

00:22:11.565 --> 00:22:13.634
在這裏
我們需要它們是同一種類型

00:22:13.867 --> 00:22:16.236
如果都是UI視圖
用起來沒問題

00:22:16.904 --> 00:22:20.007
但若我們想把CascadingLayout
和UIView一起用就不行了

00:22:20.240 --> 00:22:22.409
就像我們之前在合成
中談到的那樣

00:22:23.744 --> 00:22:27.247
我們真正想要的是使所有內容
都擁有同一種類型

00:22:28.282 --> 00:22:30.250
讓我們更新一下佈局

00:22:31.451 --> 00:22:35.055
我們可以改變結構 使它有兩個
不同的通用類型參數

00:22:35.722 --> 00:22:37.291
每個子佈局一個

00:22:38.292 --> 00:22:41.528
然後 我們還可以添加
通用限制來要求

00:22:41.595 --> 00:22:43.997
那兩種類型有同種類型的內容

00:22:44.531 --> 00:22:47.334
這就使我們準確地表達出了限制條件

00:22:47.601 --> 00:22:49.770
子佈局的內容必須是同一個類型的

00:22:52.306 --> 00:22:53.907
這就是我們完成的協議

00:22:54.007 --> 00:22:56.009
表達了我們的佈局抽象

00:22:56.443 --> 00:22:59.079
比我們之前那個協議要好得多

00:22:59.279 --> 00:23:00.480
這個協議有實際意義

00:23:00.981 --> 00:23:02.549
它是一整套操作

00:23:02.850 --> 00:23:05.752
表達了它作爲佈局進程
的一部分的意義

00:23:06.753 --> 00:23:09.389
你還可以查看我們的示例應用
瞭解一切運作的

00:23:09.456 --> 00:23:10.657
詳細信息

00:23:10.791 --> 00:23:12.326
包括我們如何用它

00:23:12.426 --> 00:23:15.162
在後臺線程上實現
渲染圖片的佈局

00:23:16.830 --> 00:23:18.832
我們可以利用新佈局協議的最後一點

00:23:18.899 --> 00:23:21.101
就是單元測試

00:23:22.603 --> 00:23:24.771
我們可以寫一個有框架屬性的結構

00:23:25.472 --> 00:23:27.207
使結構服從我們的佈局協議

00:23:27.841 --> 00:23:30.611
然後我們可以改變單元測試
在單元測試中使用這個結構

00:23:30.677 --> 00:23:32.679
而不是使用佈局中作爲
子佈局的UI視圖

00:23:33.814 --> 00:23:36.850
現在 佈局只會在這些
簡單的結構上設置框架

00:23:38.252 --> 00:23:41.054
意思就是 我們的測試
跟UIView是完全隔離的

00:23:41.321 --> 00:23:44.825
並且只依賴於我們自己的佈局
和測試結構的邏輯

00:23:45.993 --> 00:23:48.562
我們在不使用GUI的情況下
對佈局進行單元測試

00:23:49.129 --> 00:23:50.564
我認爲Crusty一定感到自豪

00:23:58.472 --> 00:24:02.643
這些是如何
在應用的視圖層以一種

00:24:02.709 --> 00:24:05.612
你想象不到的方式
使用類型和協議的一些示例

00:24:06.446 --> 00:24:08.715
我們還瞭解了一些不錯的
通用Swift技巧

00:24:08.782 --> 00:24:10.284
你可以隨意應用

00:24:11.285 --> 00:24:13.820
首先 我們瞭解瞭如何
通過使用值類型

00:24:13.887 --> 00:24:15.022
改進局部推理

00:24:15.956 --> 00:24:18.292
然後我們瞭解了
如何使用通用類型

00:24:18.392 --> 00:24:20.561
來得到更好的類型安全
和靈活的代碼

00:24:21.628 --> 00:24:24.765
我們還瞭解了值的合成
對於自定義

00:24:24.831 --> 00:24:28.135
和創建複雜的行爲來說
是個多麼棒的工具

00:24:29.002 --> 00:24:31.338
現在讓我們歡迎Alex
回到臺上 談一下

00:24:31.405 --> 00:24:32.906
我們對應用中控制器的處理

00:24:42.749 --> 00:24:43.750
謝謝Jacob

00:24:44.518 --> 00:24:47.955
現在我想重點談一下我們如何
在控制器層中使用值類型

00:24:48.555 --> 00:24:52.426
讓我們談一下應用的撤銷功能

00:24:54.995 --> 00:24:59.600
我們在夢想列表中實現了
撤銷功能 很好用

00:25:00.901 --> 00:25:03.203
但我們注意到有個小漏洞

00:25:03.637 --> 00:25:06.406
就是不能撤銷
最喜愛的創造物功能

00:25:07.074 --> 00:25:10.711
爲了重現這個漏洞
我們可以輕觸最喜愛的創造物

00:25:12.446 --> 00:25:15.549
目前有隻粉色麒麟
是我們最喜愛的創造物

00:25:15.616 --> 00:25:17.484
現在讓我們把它變成龍

00:25:19.219 --> 00:25:23.223
變更完成 我們只需要輕觸
右上方的完成按鈕即可

00:25:24.625 --> 00:25:27.628
好了 我們已經修改了
最喜愛的創造物

00:25:27.928 --> 00:25:31.365
但問題是 如果我們搖動設備
來撤銷 什麼也不會發生

00:25:32.432 --> 00:25:33.500
所以這是一個漏洞

00:25:33.967 --> 00:25:36.904
讓我們看一下代碼
看看爲什麼會這樣

00:25:38.338 --> 00:25:41.508
目前 在視圖控制器上
有兩個模型屬性

00:25:41.775 --> 00:25:44.912
一個是夢想的模型屬性
一個是最喜愛的創造物的模型屬性

00:25:45.913 --> 00:25:48.448
這在UIKit應用中
是個很典型的安排

00:25:48.715 --> 00:25:51.818
尤其是當模型增加和功能增加時

00:25:53.820 --> 00:25:57.024
再一次 我們只有夢想功能

00:25:57.324 --> 00:26:00.260
那麼我們實現了撤銷 這很棒

00:26:01.094 --> 00:26:03.864
但當我們添加
最喜愛的創造物功能後

00:26:04.064 --> 00:26:05.599
我們的撤銷代碼就不見了

00:26:06.967 --> 00:26:09.169
漏洞的產生是因爲忘了添加那段代碼

00:26:10.103 --> 00:26:12.906
要修復這個漏洞
我們可以添加另一個代碼路徑

00:26:13.807 --> 00:26:16.043
實現最喜愛的創造物的撤銷功能

00:26:16.543 --> 00:26:18.512
聽起來像是一個噩夢

00:26:18.579 --> 00:26:21.281
因爲每次要添加
另一個模型屬性時

00:26:21.849 --> 00:26:24.685
我們就不得不添加另一個
代碼路徑來實現撤銷

00:26:25.285 --> 00:26:26.720
這很糟糕

00:26:27.654 --> 00:26:28.822
我們不希望這樣

00:26:30.290 --> 00:26:31.992
我們往回退一步

00:26:32.059 --> 00:26:34.695
當我們添加更多的模型屬性時

00:26:34.761 --> 00:26:36.897
想要找到一個更好的解決方案

00:26:38.866 --> 00:26:41.935
那麼方案就是把這些
模型屬性合成

00:26:42.135 --> 00:26:45.005
到一個單一值中
我們的模型結構

00:26:45.672 --> 00:26:49.142
撤銷邏輯會按照
那一個類型單獨運行

00:26:50.644 --> 00:26:54.014
請注意 模型仍然有值語義
這很重要

00:26:54.314 --> 00:26:56.884
那是因爲它是由兩個
別的值合成的

00:26:57.451 --> 00:26:59.887
這個方法很棒

00:26:59.987 --> 00:27:02.356
因爲現在兩個模型屬性

00:27:02.689 --> 00:27:04.458
只有一個單一代碼路徑

00:27:04.525 --> 00:27:06.460
如果我們添加另一個模型屬性

00:27:06.527 --> 00:27:08.262
我們仍然有一個代碼路徑

00:27:08.662 --> 00:27:10.030
這很棒

00:27:14.134 --> 00:27:17.504
我們可以通過把兩個
模型屬性挪到視圖控制器上的

00:27:17.571 --> 00:27:20.440
新模型結構中實現

00:27:21.642 --> 00:27:25.245
這樣 我們要做的就是向
視圖控制器添加新的模型屬性

00:27:27.047 --> 00:27:28.815
這也是我們的構造方式

00:27:28.882 --> 00:27:30.784
但現在 我們需要實現撤銷代碼

00:27:31.318 --> 00:27:32.452
我們如何實現呢？

00:27:33.020 --> 00:27:35.789
嗯 我首先要展示的是
常見的實現方式

00:27:35.856 --> 00:27:37.691
以及我們爲何認爲
這種方式有漏洞

00:27:39.526 --> 00:27:42.996
左側是視圖控制器的當前模型值

00:27:43.630 --> 00:27:46.433
右側是運算和撤銷堆棧

00:27:47.401 --> 00:27:49.203
在應用的原始版本中

00:27:49.336 --> 00:27:52.472
我們認爲撤銷堆棧
是一系列的小步驟

00:27:52.940 --> 00:27:56.043
每個步驟都能響應
對第一個模型的修改

00:27:56.310 --> 00:27:58.212
和匹配的視圖

00:27:59.813 --> 00:28:01.882
比如 在第一個撤銷步驟中

00:28:02.149 --> 00:28:04.618
我們要移除用戶剛添加的夢想

00:28:04.918 --> 00:28:07.054
然後我們要從那個表視圖中刪除那一行

00:28:09.990 --> 00:28:12.292
然後繼續下一個撤銷步驟

00:28:13.994 --> 00:28:15.762
在這個撤銷步驟中

00:28:16.363 --> 00:28:21.635
我們要把模型重新變回粉色麒麟

00:28:23.303 --> 00:28:26.106
那麼這個分別修改並更新

00:28:26.173 --> 00:28:27.841
視圖個體模型屬性的方法

00:28:28.108 --> 00:28:29.743
很容易出錯

00:28:29.810 --> 00:28:32.446
因爲你需要精確地
匹配模型中的變更

00:28:32.513 --> 00:28:35.415
和視圖中的變更

00:28:36.283 --> 00:28:39.386
如果失敗會導致模型和視圖

00:28:39.453 --> 00:28:41.255
之間的很多矛盾

00:28:41.889 --> 00:28:43.690
最後就會得到這樣的漏洞

00:28:44.791 --> 00:28:47.027
我確定你們所有人都遇到過
這樣的問題

00:28:47.094 --> 00:28:48.495
我總會遇到這樣的問題

00:28:49.630 --> 00:28:51.098
很難進行調試

00:28:51.865 --> 00:28:53.367
爲什麼很難調試呢？

00:28:54.401 --> 00:28:55.836
嗯 讓我們再看看

00:28:55.903 --> 00:28:58.005
我們最初的撤銷堆棧

00:28:59.206 --> 00:29:01.942
這些不可撤銷的變更
實際上是從哪兒來的呢？

00:29:03.510 --> 00:29:07.381
嗯 每個不可撤銷的變更都來自
我們的視圖控制器

00:29:07.881 --> 00:29:11.351
並且每個不可撤銷的變更
都會影響順序

00:29:12.653 --> 00:29:16.890
當我們嚮應用中添加功能時
出錯的機率很大

00:29:18.025 --> 00:29:20.928
我們的代碼中並沒有可以

00:29:20.994 --> 00:29:24.164
讓我們在模型和視圖更新之間
推理一致性的地方

00:29:24.831 --> 00:29:26.834
這很不好 因爲太複雜了

00:29:28.368 --> 00:29:32.272
讓我們尋找一種更簡單的方式
來處理撤銷

00:29:34.842 --> 00:29:37.144
如果不記錄小的變更

00:29:38.612 --> 00:29:41.381
堆棧中的每一條都只是個
完整的新值

00:29:41.682 --> 00:29:42.783
完整的新模型

00:29:43.250 --> 00:29:44.818
現在 在模型上

00:29:44.885 --> 00:29:46.420
實施撤銷就非常簡單了

00:29:47.020 --> 00:29:49.723
只需要用堆棧上的模型
替換當前模型即可

00:29:50.390 --> 00:29:52.893
這樣我們就不用再擔心
順序問題了

00:29:53.827 --> 00:29:55.395
然後我們只替換值

00:29:57.698 --> 00:29:59.766
這樣我們就解決了模型的問題

00:29:59.833 --> 00:30:02.336
我們還要解決如何更新
UI的問題

00:30:04.171 --> 00:30:07.474
在視圖控制器中 無論什麼時候
只要模型發生變更

00:30:07.541 --> 00:30:09.877
我們就調用
modelDidChange方法

00:30:10.811 --> 00:30:13.313
我建議你下載這個示例

00:30:13.380 --> 00:30:16.617
瞭解這個方法具體是如何
運作的更多信息

00:30:17.684 --> 00:30:19.753
在那個方法中
我們需要找到

00:30:19.820 --> 00:30:21.922
新舊模型值之間的不同點

00:30:22.189 --> 00:30:23.590
並更新我們的UI進行匹配

00:30:24.625 --> 00:30:26.793
比如 我們可以查看

00:30:26.860 --> 00:30:29.630
舊模型中最喜愛的創造物
是不是跟

00:30:29.897 --> 00:30:31.932
新模型中最喜愛的創造物不一樣

00:30:32.999 --> 00:30:35.536
如果不一樣 我們就更新表視圖中

00:30:35.602 --> 00:30:38.472
包含最喜愛的創造物的那一行

00:30:40.541 --> 00:30:43.944
在對象中有一個更好的實現

00:30:44.011 --> 00:30:46.346
就像我剛提到的那樣
我建議你查看

00:30:46.413 --> 00:30:47.915
關於更新UI的更多信息

00:30:49.983 --> 00:30:52.386
最後 我們只需要註冊撤銷邏輯

00:30:52.920 --> 00:30:54.988
把模型重設爲舊值

00:30:55.589 --> 00:30:58.225
這很棒
因爲我們現在只需要一個

00:30:58.292 --> 00:31:01.028
或者說我們只需要在一個地方
註冊撤銷

00:31:03.730 --> 00:31:05.265
這有什麼好處呢？

00:31:05.799 --> 00:31:09.236
正如我們所看到的 爲了更新UI
我們生成了一個單一代碼路徑

00:31:09.603 --> 00:31:11.738
所有操作都按順序獨立進行

00:31:12.005 --> 00:31:13.574
以前並不是這樣的

00:31:14.241 --> 00:31:16.810
這能幫助我們對代碼進行局部推理

00:31:17.211 --> 00:31:18.879
和UI更新代碼

00:31:20.480 --> 00:31:24.084
我們還能瞭解值之間是如何
恰如其分地組合在一起的

00:31:24.885 --> 00:31:28.388
如果單一值的屬性有兩個值

00:31:28.856 --> 00:31:31.191
那個值仍然會有值語義

00:31:37.497 --> 00:31:41.168
好了 讓我們談談如何
在有模型屬性的控制器層

00:31:41.235 --> 00:31:44.137
使用值類型

00:31:44.671 --> 00:31:46.039
在控制器的UI狀態屬性中

00:31:46.173 --> 00:31:48.242
我想實現同樣的功能

00:31:49.810 --> 00:31:51.645
你以前看過這個屏幕

00:31:51.812 --> 00:31:53.914
這是夢想列表

00:31:54.381 --> 00:31:57.217
但這個視圖控制器有許多不同的狀態

00:31:57.818 --> 00:31:59.853
我要給你們展示視圖控制器的狀態圖

00:31:59.920 --> 00:32:03.390
因爲它跟我們一個很酷的功能有關

00:32:03.624 --> 00:32:05.526
就是和朋友分享夢想

00:32:06.460 --> 00:32:07.661
讓我們來看一下

00:32:09.296 --> 00:32:10.964
這是基本狀態圖

00:32:13.267 --> 00:32:15.836
我們要從瀏覽狀態開始

00:32:17.504 --> 00:32:19.706
輕觸頂部的分享按鈕

00:32:19.773 --> 00:32:21.875
將會把我們帶入選擇狀態

00:32:23.210 --> 00:32:25.179
然後選擇要分享的夢想

00:32:26.380 --> 00:32:29.383
然後輕觸完成按鈕返回分享狀態

00:32:34.121 --> 00:32:36.957
分享完成後
我們會回到瀏覽狀態

00:32:38.625 --> 00:32:39.927
用起來很流暢

00:32:40.661 --> 00:32:43.263
但讓我們再快速返回選擇狀態

00:32:43.931 --> 00:32:47.668
你會注意到 我們可以通過輕觸

00:32:47.734 --> 00:32:50.037
左上角的取消按鈕停止分享

00:32:53.640 --> 00:32:55.876
這將把我們帶回瀏覽狀態

00:32:56.543 --> 00:32:58.946
你會看到導航欄看起來
顯示的是正確的

00:32:59.313 --> 00:33:01.281
因爲它又顯示分享按鈕了

00:33:01.915 --> 00:33:03.917
但其實在應用中有一個很小的UI漏洞

00:33:03.984 --> 00:33:05.886
是由一種不一致狀態導致的

00:33:07.487 --> 00:33:09.857
表視圖左側的UI

00:33:10.057 --> 00:33:13.961
仍然可見 並仍然允許用戶選擇
夢想並分享 這樣是不對的

00:33:15.495 --> 00:33:17.397
當我們返回去調試這段代碼時

00:33:17.464 --> 00:33:19.967
我們看到某些狀態屬性

00:33:20.133 --> 00:33:22.669
在狀態變更時並沒有被全部清除

00:33:23.737 --> 00:33:26.840
在這種情況下
即使我們進入了瀏覽狀態

00:33:26.907 --> 00:33:28.909
我們忘記去清除選擇狀態的

00:33:28.976 --> 00:33:30.377
某些屬性

00:33:31.311 --> 00:33:35.048
讓我們再看看狀態圖
看是否修復了這個問題

00:33:37.985 --> 00:33:41.054
這裏的每個狀態都有相應的屬性

00:33:41.822 --> 00:33:44.691
並且這些屬性是視圖控制器上的屬性

00:33:46.360 --> 00:33:49.730
狀態屬性的個數

00:33:49.897 --> 00:33:52.466
隨着應用功能的增加
視圖控制器中的

00:33:52.533 --> 00:33:54.801
增長可能會很迅速

00:33:55.502 --> 00:33:59.873
在這種情況下 重點是我們的屬性
是相互排斥的

00:34:01.542 --> 00:34:03.510
那麼 當我們瀏覽時
我們就不分享

00:34:03.577 --> 00:34:05.846
當我們分享時 我們就不選擇

00:34:07.381 --> 00:34:10.284
但是 我們寫這段代碼的方式是
當你設置一個屬性時

00:34:10.350 --> 00:34:12.418
你需要清除其他所有屬性

00:34:12.485 --> 00:34:13.987
這很容易出錯

00:34:15.222 --> 00:34:16.924
我們要如何解決這個問題呢？

00:34:17.391 --> 00:34:21.460
嗯 枚舉非常適合處理
相互排斥的值

00:34:23.297 --> 00:34:27.835
我們把所有UI狀態屬性
都轉成了枚舉值

00:34:29.036 --> 00:34:32.272
然後 我們只需要通過使用枚舉
把狀態屬性添加到視圖控制器即可

00:34:34.641 --> 00:34:38.846
 我們可以確保
狀態是相互排斥的

00:34:39.478 --> 00:34:42.949
這很棒
因爲我們之前發現的無效狀態漏洞

00:34:43.016 --> 00:34:46.119
現已不可能再發生了
因爲它受類體系的迫使

00:34:47.721 --> 00:34:50.556
這個方案也意味着
我們的狀態變更

00:34:50.858 --> 00:34:54.494
是突然發生的
不需要任何可能的中間狀態

00:34:54.828 --> 00:34:59.566
因此
我們不需要協調該死的屬性

00:34:59.933 --> 00:35:01.702
和隱含的時間依賴性

00:35:03.437 --> 00:35:05.873
此外 使狀態多合一

00:35:05.939 --> 00:35:07.774
更容易以用戶

00:35:07.941 --> 00:35:10.310
上次離開時的完全相同的
狀態啓動應用

00:35:10.410 --> 00:35:14.047
我真心推薦你們再次查看
和下載這個項目

00:35:14.114 --> 00:35:17.317
看我們是如何在應用中
實現狀態修復的

00:35:20.220 --> 00:35:22.256
好了 我們今天講了很多內容

00:35:23.490 --> 00:35:28.195
開始講了
改進應用中的局部推理

00:35:28.495 --> 00:35:31.098
通過把值類型和協議引入

00:35:31.164 --> 00:35:33.667
到基於模型視圖控制器的應用

00:35:34.301 --> 00:35:35.769
我們是如何實現的？

00:35:36.870 --> 00:35:39.873
開始是通過把夢想類型做成結構

00:35:40.107 --> 00:35:41.742
使模型有值語義

00:35:42.709 --> 00:35:45.612
使我們更容易對代碼
進行局部推理

00:35:45.979 --> 00:35:48.916
因爲我們的夢想變量
沒有隱含的分享

00:35:50.851 --> 00:35:53.487
然後Jacob展示了
如何創建小組件

00:35:53.720 --> 00:35:56.056
如DecoratingLayout
和CascadingLayout

00:35:57.024 --> 00:36:00.661
這些小組件利用了通用協議

00:36:00.727 --> 00:36:04.798
確保通用組件可以在視圖、
中重新使用

00:36:05.165 --> 00:36:07.301
SpriteKit節點和圖形渲染

00:36:08.035 --> 00:36:10.270
這使我們得到了更好的局部推理

00:36:10.404 --> 00:36:14.975
因爲每個類型都是小的、
可測試的、分離的值類型

00:36:18.512 --> 00:36:21.882
然後我們瞭解瞭如何利用
視圖控制器上的模型屬性

00:36:22.082 --> 00:36:24.318
合成到單一類型中

00:36:25.152 --> 00:36:28.455
這使我們更容易用單一
代碼路徑實現撤銷

00:36:29.122 --> 00:36:31.992
即使我們的模型類型
有更多的屬性

00:36:33.160 --> 00:36:37.631
這個方案還給了我們一個
更新UI的代碼路徑

00:36:37.998 --> 00:36:40.300
使我們更容易理解

00:36:40.734 --> 00:36:42.636
獨立視圖控制器的UI邏輯

00:36:45.005 --> 00:36:49.343
最後 我們瞭解瞭如何把相互
排斥的狀態屬性轉成

00:36:49.409 --> 00:36:51.979
視圖控制器上的枚舉值

00:36:52.446 --> 00:36:56.183
這降低了UI爲不一致
狀態的潛在機率

00:36:57.217 --> 00:37:01.788
並且這也是我們今天
討論的值類型

00:37:02.890 --> 00:37:05.325
但是 如果你下載示例項目

00:37:05.792 --> 00:37:08.629
你將看到項目中的更多信息

00:37:10.163 --> 00:37:13.767
而且我們整個應用也使用了很多值類型

00:37:13.834 --> 00:37:17.437
除了我們需要用控制器
或視圖對象的地方

00:37:18.338 --> 00:37:21.008
現在 UIKit要求把這些
作爲引用類型

00:37:21.308 --> 00:37:26.013
但是我們仍然把絕大多數功能
挪到了值類型中

00:37:29.550 --> 00:37:33.153
我們今天講了很多 我希望你回家

00:37:33.220 --> 00:37:36.356
的時候頭腦裏要記得這幾點

00:37:38.492 --> 00:37:41.495
第一是通過合成而不是繼承

00:37:41.895 --> 00:37:44.231
進行自定義

00:37:45.065 --> 00:37:46.667
你再坐在辦公桌旁

00:37:47.067 --> 00:37:50.103
繪製類圖來解決問題時

00:37:51.338 --> 00:37:54.241
我希望你考慮如何使用合成

00:37:54.641 --> 00:37:56.977
而不是繼承來解決那個問題

00:37:57.344 --> 00:38:00.280
這樣你就能獲得我們今天講到的
值類型的各種好處了

00:38:01.849 --> 00:38:05.552
第二個技巧是給通用的可重複
使用的代碼使用協議

00:38:06.620 --> 00:38:09.423
你可以做可重複使用的小組件

00:38:09.489 --> 00:38:12.359
很容易進行局部推理和測試

00:38:13.060 --> 00:38:15.062
我強烈建議你們查看

00:38:15.128 --> 00:38:17.264
我們是如何用通用類型而不是類層次

00:38:17.331 --> 00:38:21.201
在那個示例中實現的

00:38:23.637 --> 00:38:26.607
我們還展示瞭如何利用值語義

00:38:27.274 --> 00:38:28.909
需要記住的重點是

00:38:29.076 --> 00:38:33.146
如果有由其他屬性組成的值

00:38:33.714 --> 00:38:36.183
較大的值也會有值語義

00:38:38.418 --> 00:38:40.787
最後 我們談了局部推理

00:38:42.155 --> 00:38:45.459
局部推理實際上是個
非常通用的技巧

00:38:45.592 --> 00:38:50.464
並不是UI編程專用的

00:38:50.597 --> 00:38:54.601
也不是移動開發專用的
也不是Swift專用的

00:38:55.335 --> 00:38:57.237
這是所有編程語言的

00:38:57.304 --> 00:39:00.541
一個非常重要的方面

00:39:01.408 --> 00:39:04.111
當你回到辦公室並開始編碼時

00:39:04.545 --> 00:39:06.647
我希望你思考 無論是哪種語言

00:39:07.114 --> 00:39:10.484
如何使用那塊代碼
看那塊代碼如何支持局部推理

00:39:11.618 --> 00:39:17.658
Swift如此強調值類型
絕不是偶然

00:39:17.991 --> 00:39:20.394
因爲它們是個非常重要的方面

00:39:20.761 --> 00:39:23.497
可以讓你對代碼進行局部推理

00:39:26.600 --> 00:39:27.501
就是這樣了

00:39:27.801 --> 00:39:31.371
你可以從這裏找到示例代碼
和更多相關資源

00:39:31.438 --> 00:39:33.073
我強烈建議你們這樣做

00:39:34.374 --> 00:39:37.444
我們還有一些相關演講
我們在演講中也提到了

00:39:37.878 --> 00:39:39.680
我建議你們觀看相關視頻

00:39:40.180 --> 00:39:42.749
謝謝大家 希望你們在
WWDC期間過得愉快

00:00:19.386 --> 00:00:22.389
優化應用的網頁內容

00:00:22.456 --> 00:00:23.290
大家好

00:00:27.427 --> 00:00:29.763
歡迎來到“優化應用的網頁內容”

00:00:29.830 --> 00:00:31.398
我是Jonathan Davis

00:00:31.465 --> 00:00:34.168
網絡技術的推廣人
負責Safari和WebKit

00:00:34.902 --> 00:00:37.271
現在我要先說明一些事情

00:00:38.172 --> 00:00:40.707
很多人說我長得像
Edward Snowden

00:00:40.774 --> 00:00:42.309
但我向你保證 我不是他

00:00:43.210 --> 00:00:46.947
但這麼多衛星在頭頂盤旋
大概都是來抓我們的

00:00:47.915 --> 00:00:50.751
除此之外 我很激動地要展示些新東西

00:00:50.817 --> 00:00:53.787
它們可以幫助你
提升應用網頁內容的性能

00:00:54.288 --> 00:00:56.323
我們一直都知道

00:00:56.390 --> 00:00:59.326
性能是提供最佳用戶體驗的關鍵

00:00:59.393 --> 00:01:04.431
若你是個應用開發者並在應用裏用了
WebViews和JSContext

00:01:05.364 --> 00:01:07.901
而且你很關心性能
那你就來對地方了

00:01:08.569 --> 00:01:09.970
說到性能

00:01:10.304 --> 00:01:14.074
在當今時代裏
性能其實就是指電池壽命

00:01:14.141 --> 00:01:17.411
我認爲電池壽命是最終的有限資源

00:01:17.845 --> 00:01:20.280
它帶來很不同的結果
如果你能撥出最後一通電話

00:01:20.347 --> 00:01:23.717
或者發出最後一份重要的文件
在電池耗光之前

00:01:24.218 --> 00:01:26.420
性能對用戶來說
事關重大

00:01:26.753 --> 00:01:29.389
他們所選擇的應用
不會讓設備變慢

00:01:29.456 --> 00:01:30.724
而且耗電量低

00:01:31.692 --> 00:01:35.596
我們的經驗就是
根據用戶的反饋和各自的體會

00:01:35.662 --> 00:01:38.966
性能很重要
因爲電池壽命事關重大

00:01:40.400 --> 00:01:44.104
所以今年我們致力於
提供更好的工具

00:01:44.171 --> 00:01:46.640
來找到和修復
網頁內容的性能問題

00:01:47.207 --> 00:01:49.510
現在我們爲應用提供了工具
比如Swift

00:01:49.576 --> 00:01:51.778
還有Objective-C代碼
比如Instruments

00:01:52.312 --> 00:01:56.049
我們還提供了網絡檢查器
幫助網頁開發者創建網頁和網站

00:01:57.017 --> 00:01:59.286
但不要覺得
因爲你選擇了

00:01:59.353 --> 00:02:02.422
在應用中用網絡技術
就沒有其他工具可用了

00:02:02.489 --> 00:02:05.259
實際上
我今天展示給你的所有工具

00:02:05.325 --> 00:02:07.427
就是開發給人們
既能幫助他們建設網站

00:02:07.494 --> 00:02:10.430
也能讓他們在應用裏
用網絡技術

00:02:11.265 --> 00:02:12.566
那麼我首先要
向你展示

00:02:12.633 --> 00:02:15.936
如何把網絡檢查器連接到
JSContext的WebViews

00:02:16.003 --> 00:02:18.505
這樣在你需要它的時候
它就會立刻出現

00:02:19.540 --> 00:02:21.375
之後你會瞭解
一些新的功能

00:02:21.441 --> 00:02:25.479
它們能讓你瞭解JavaScript代碼
如何分配時間

00:02:25.546 --> 00:02:29.650
以及這些新功能
如何幫你迅速找到性能上的問題

00:02:30.651 --> 00:02:34.955
如果你想要看到
網絡內容的內存使用情況

00:02:35.022 --> 00:02:38.392
我們也給網絡檢查器增添了新的時間線
我都已等不及想展示了

00:02:38.592 --> 00:02:41.562
它們會幫你節省很多時間
來找到內存過大的問題

00:02:41.995 --> 00:02:43.797
準備好了？
那就開始吧

00:02:45.032 --> 00:02:46.333
第一件
我們要做的事

00:02:46.400 --> 00:02:48.769
是把網絡檢查器
連接到應用裏

00:02:49.469 --> 00:02:52.840
在應用裏使用網絡技術
有很多原因

00:02:53.574 --> 00:02:56.276
如JS context裏的
一些JavaScript模塊

00:02:56.343 --> 00:02:59.980
可以讓你輕鬆交換邏輯
並無編譯地添加新的模塊

00:03:00.747 --> 00:03:05.419
可能有些人正在tvOS應用裏
使用TVML的 JSContext

00:03:06.053 --> 00:03:09.690
另外一個使用網絡技術的原因
就是你要顯示的網頁內容

00:03:10.157 --> 00:03:12.059
比如第三方網站的
一個網頁

00:03:12.459 --> 00:03:13.727
這個網站
你不能控制

00:03:14.027 --> 00:03:16.663
可能就要用到Safari視圖控制器

00:03:16.730 --> 00:03:18.398
如果不是
你也許可以去聽聽

00:03:18.465 --> 00:03:21.602
去年的演講
“介紹Safari視圖控制器”

00:03:22.903 --> 00:03:26.106
但如果你顯示的內容
是你自己的或者你可以控制的

00:03:26.173 --> 00:03:31.912
或是可自定義的HTML CSS
或JavaScript編寫的內容

00:03:31.979 --> 00:03:34.281
或者是
可以提升應用體驗的內容

00:03:34.615 --> 00:03:36.350
WKWebView
是最好的選擇

00:03:36.717 --> 00:03:39.786
它實際上是個矩形
把網頁內容拉入應用

00:03:40.354 --> 00:03:43.690
它引入了iOS 8
和OS 10 Yosemite

00:03:44.858 --> 00:03:47.561
若你還在使用WebView
或者UIWebView

00:03:47.828 --> 00:03:51.164
那你一定要考慮
升級到WKWebView

00:03:51.565 --> 00:03:54.735
事實上 升級到WKWebView
可以讓你利用

00:03:54.801 --> 00:03:58.805
Nitro JavaScript
核心引擎和四級JIT編譯器

00:03:58.872 --> 00:04:00.007
這能大大提升速度

00:04:00.741 --> 00:04:02.743
若想了解更多WKWebView信息

00:04:03.010 --> 00:04:07.314
我推薦2014年的演講
介紹了現代化的WebKit API

00:04:08.282 --> 00:04:11.418
那麼去年我們給WKWebView
添加了很多優秀的功能

00:04:11.485 --> 00:04:16.589
比如 加載文件URL和自定義用戶代理字符串
還有WK網站數據存儲API

00:04:17.858 --> 00:04:22.296
現今有了iOS 10和macOS Sierra
我們改進了3D-touch支持

00:04:23.063 --> 00:04:25.532
現在你的應用就可以執行這些好用的

00:04:25.599 --> 00:04:27.835
Peek和Pop事件
在WKWebView裏

00:04:29.336 --> 00:04:31.438
就像我之前說的
因爲你選了

00:04:31.505 --> 00:04:32.906
在應用裏
應用網絡技術

00:04:33.807 --> 00:04:35.142
並不意味着
你沒有工具可用

00:04:35.209 --> 00:04:37.811
不論哪種情況
你可連接網絡檢查器

00:04:37.878 --> 00:04:40.214
發掘網頁內容
或JavaScript活動情況

00:04:41.081 --> 00:04:44.985
但使用網絡檢查器前
你必須要激活develop菜單

00:04:45.219 --> 00:04:49.156
只要上傳Safari設置
然後找到“高級”標籤

00:04:49.356 --> 00:04:51.558
然後在底部
你會看到這個複選框

00:04:51.625 --> 00:04:53.961
寫着在菜單欄顯示Develop菜單

00:04:54.995 --> 00:04:56.730
那就點擊它

00:04:56.964 --> 00:04:59.766
Develop菜單就會出現在
Safari的菜單欄裏

00:05:01.735 --> 00:05:04.371
爲讓網絡檢查器
連接到iOS設備

00:05:04.438 --> 00:05:06.073
你要開啓一個設置

00:05:06.607 --> 00:05:10.210
在iOS的設置應用裏
點擊Safari

00:05:10.511 --> 00:05:16.016
然後拉到底部 點擊“高級”
然後把檢查器設置打開

00:05:16.884 --> 00:05:18.652
現在你就可以
把設備連到Mac上

00:05:18.719 --> 00:05:20.654
在Safari裏
檢查Develop菜單

00:05:22.356 --> 00:05:24.558
Develop菜單裏
有些很酷炫的東西

00:05:24.625 --> 00:05:26.627
你之前可能
從未注意到過

00:05:26.693 --> 00:05:28.962
就是你能看到設備的列表

00:05:29.029 --> 00:05:32.866
這裏有已連接的iPhone
MacBook Pro和模擬器

00:05:33.500 --> 00:05:36.837
要連接一個設備
並開始使用這些工具

00:05:36.904 --> 00:05:39.206
進行調試
那麼只要選擇Device菜單

00:05:39.473 --> 00:05:43.377
就會收到 當前設備上運行的
WebViews和JSContexts 的列表

00:05:44.411 --> 00:05:46.580
這裏的Mac應用
並沒有使用WebKit

00:05:46.647 --> 00:05:48.015
而用JavaScript

00:05:48.148 --> 00:05:50.651
所以我可以直接連接它
並使用工具

00:05:51.585 --> 00:05:56.190
iOS裏的應用只會出現在
用Xcode創建和運行的時候

00:05:56.924 --> 00:06:00.194
但是說到Mac應用
你還要做一件事

00:06:01.261 --> 00:06:05.299
就是保持應用的完整性
我們不會讓任何人下載你的應用

00:06:05.365 --> 00:06:08.168
並用網絡檢查器
巡查你的應用

00:06:08.669 --> 00:06:10.103
所以你要添加
這個授權

00:06:10.170 --> 00:06:12.272
到應用本地開發的
授權文件裏

00:06:13.307 --> 00:06:15.542
你可能已經有了一個
授權文件

00:06:15.609 --> 00:06:17.477
如果沒有
創建一個也很簡單

00:06:17.544 --> 00:06:20.581
你只要創建新的plist
拓展名爲.entitlements

00:06:20.914 --> 00:06:25.419
並且Xcode的創建設置裏
定義一個代碼簽名的授權傳遞路徑

00:06:26.753 --> 00:06:28.488
這個要在
開發的時候添加

00:06:28.555 --> 00:06:30.791
之後在
運行應用的時候刪除

00:06:31.792 --> 00:06:32.893
一旦有了這個授權

00:06:33.126 --> 00:06:35.395
你的設備和應用就
出現在Develop菜單

00:06:35.462 --> 00:06:36.496
這樣就可以連接了

00:06:36.830 --> 00:06:42.669
輕鬆把網絡檢查器連接到
JSContext和WebViews上了

00:06:44.805 --> 00:06:47.674
我們已正常運行了
網絡檢查器和應用

00:06:48.675 --> 00:06:51.078
該談談網絡檢查器裏
新功能了

00:06:51.144 --> 00:06:53.814
我想首先講講
分析JavaScript代碼

00:06:53.881 --> 00:06:54.715
分析JavaScript

00:06:54.781 --> 00:06:57.584
JavaScript的分析器
已經存在挺長時間了

00:06:57.651 --> 00:06:59.620
今年它變得更好

00:06:59.686 --> 00:07:03.156
更有效率
能幫助你迅速找到

00:07:03.223 --> 00:07:05.392
哪裏調出的JavaScript
成本最高

00:07:05.459 --> 00:07:06.660
原因很簡單

00:07:07.628 --> 00:07:11.965
新的分析器採用了取樣技術
不會影響性能

00:07:12.032 --> 00:07:13.734
比以前好太多

00:07:14.568 --> 00:07:17.504
我們的分析器
在編譯器能用之前的時代

00:07:17.571 --> 00:07:18.739
實際是個翻譯器

00:07:19.206 --> 00:07:23.143
但是現在我們有了
這個強大的四級JIT編譯器

00:07:23.443 --> 00:07:26.947
那麼這個分析器
就真正成爲樣本分析器

00:07:28.048 --> 00:07:31.518
樣本分析器告訴你
代碼把時間都用在哪裏

00:07:31.752 --> 00:07:35.622
幫你解答
哪個代碼佔用的時間最多？

00:07:36.590 --> 00:07:39.059
它在運行程序中的取樣
以每毫秒爲單位

00:07:39.126 --> 00:07:40.594
並且短暫地
停頓執行

00:07:40.661 --> 00:07:43.130
並快照
所有正在運行的代碼

00:07:44.598 --> 00:07:45.966
它還可以取樣

00:07:46.033 --> 00:07:48.936
在代碼運行於
JIT編譯器所有四級的時候

00:07:49.002 --> 00:07:52.039
所以它的取樣速度
跟你代碼的實際速度差不多

00:07:52.873 --> 00:07:56.443
由於斷點處理
會導致代碼去優化

00:07:56.510 --> 00:07:57.978
我們暫時不管它們

00:07:58.545 --> 00:08:02.583
那麼當你分析的時候
你就可以瞭解網頁應用的真實性能

00:08:03.050 --> 00:08:06.854
使用樣本分析器
對性能幾乎沒有損害

00:08:07.120 --> 00:08:10.157
這就意味着
當你分析代碼的時候

00:08:10.657 --> 00:08:13.560
速度高達以前的30倍

00:08:14.361 --> 00:08:17.931
這就讓代碼分析過程
更快也更簡單

00:08:17.998 --> 00:08:20.434
而且收到的數據
也更準確

00:08:21.869 --> 00:08:25.939
這個進步真令人振奮 因爲我們團隊
和網絡檢查器團隊

00:08:26.006 --> 00:08:29.610
能利用它來發現
可以提升速度的地方

00:08:29.676 --> 00:08:31.044
就在網絡檢查器本身

00:08:32.412 --> 00:08:34.515
好了
現在我們有了樣本分析器

00:08:34.581 --> 00:08:37.618
看看如何利用網絡檢查器
幫我們找到問題

00:08:38.519 --> 00:08:41.688
這個內容很多
但是可以簡單的拆分開來

00:08:41.788 --> 00:08:43.991
更方便的是
這都是你已經熟悉的代碼

00:08:44.958 --> 00:08:47.160
當我們說到
分析JavaScript時

00:08:47.227 --> 00:08:50.597
意思是在Events裏
爲JavaScript記錄時間線

00:08:50.664 --> 00:08:52.399
這就是Events視圖

00:08:52.733 --> 00:08:56.270
顯示了一列單獨而且具體的
JavaScript事件

00:08:56.570 --> 00:09:00.073
特別的是
這裏都是D3庫的代碼

00:09:00.140 --> 00:09:02.910
所以它能更方便
調試代碼

00:09:02.976 --> 00:09:05.612
和分析代碼
在你正在使用的庫裏

00:09:06.346 --> 00:09:09.449
而且這裏的每一條
都是代碼運行的事件

00:09:09.716 --> 00:09:13.187
這是代碼進出
JavaScript核心引擎的情況

00:09:14.087 --> 00:09:15.856
包括了
監聽事件的回調

00:09:15.923 --> 00:09:19.193
比如動畫框架的條目
是在請求動畫框架處理器

00:09:20.160 --> 00:09:22.596
腳本評估條目
顯示JavaScript文件

00:09:22.663 --> 00:09:24.331
的上傳和首次評估

00:09:25.265 --> 00:09:27.234
這裏還有一些
時間信息

00:09:27.701 --> 00:09:30.971
告訴你運行的代碼
所花費的時間

00:09:32.039 --> 00:09:34.708
所以如果有哪個
超過了10或15毫秒

00:09:34.775 --> 00:09:36.343
你就快要打破

00:09:36.410 --> 00:09:38.812
60幀每秒的
流暢性能底線

00:09:40.647 --> 00:09:43.217
Events視圖很有用
但是還有另一個視圖

00:09:43.283 --> 00:09:46.119
是我們爲你添加的
叫做Call Trees視圖

00:09:46.553 --> 00:09:49.790
如果你用過其他分析工具
那麼對這個應該很熟悉

00:09:51.225 --> 00:09:54.161
只要點擊這個菜單
然後轉換到Call Trees視圖

00:09:55.429 --> 00:09:59.399
現在顯示了調用堆棧裏
函數的累計運行時間

00:10:00.133 --> 00:10:01.768
這個叫做Top Down視圖

00:10:01.835 --> 00:10:04.137
你可以用它
深入發掘Call Tree

00:10:04.204 --> 00:10:06.707
來找到
耗費大量時間的熱函數

00:10:07.774 --> 00:10:10.177
但我最喜歡的視圖是
Bottom Up視圖

00:10:12.513 --> 00:10:14.448
它能直接讓我找到
最熱的函數

00:10:14.515 --> 00:10:16.650
就是取樣最頻繁的函數

00:10:17.551 --> 00:10:19.319
這裏羅列的
是調出的函數

00:10:19.386 --> 00:10:21.622
按照用時
從大到小分類

00:10:21.688 --> 00:10:26.593
它反轉了Call Tree
讓你能直接對比各個函數的耗時

00:10:27.861 --> 00:10:30.731
你能準確地看到
耗時最多的地方

00:10:32.332 --> 00:10:35.169
你可以展開這一條
並按照路徑返回

00:10:35.235 --> 00:10:36.837
找到耗時最多的函數

00:10:37.471 --> 00:10:41.108
你就能知道這個成本最高的代碼
是何時何地調出的

00:10:42.809 --> 00:10:45.312
那麼關於這部分
有請我的同事

00:10:45.379 --> 00:10:46.980
Brian Burg
上臺爲大家展示

00:10:55.155 --> 00:10:57.858
謝謝你 Jon
樣本分析器很好用

00:10:57.925 --> 00:11:00.494
因爲它可以提取
十分複雜的內容

00:11:00.561 --> 00:11:03.564
並進行分析
讓你看到十分精確的信息

00:11:03.630 --> 00:11:05.132
而且你可以讓它
跑的更快

00:11:05.832 --> 00:11:09.469
爲了給你們展示
我要用我製作的iPad應用

00:11:09.770 --> 00:11:12.139
叫做衛星跟蹤器
在這裏看看

00:11:15.676 --> 00:11:19.680
衛星跟蹤器
會展示給你現在或任何時間

00:11:20.080 --> 00:11:21.615
衛星所在的位置

00:11:21.882 --> 00:11:24.618
你可以選擇
地球上的不同地點

00:11:25.219 --> 00:11:26.787
也可以選擇不同的衛星

00:11:28.222 --> 00:11:29.223
不同的時區

00:11:30.023 --> 00:11:30.858
這很棒吧

00:11:31.725 --> 00:11:33.460
如果你擔心
頭上盤旋的衛星

00:11:33.527 --> 00:11:36.330
要帶個錫紙帽子以防萬一
這個應用就是理想之選

00:11:37.064 --> 00:11:39.633
但是這裏有個小問題

00:11:39.700 --> 00:11:44.071
如果很多衛星
或者很多衛星組件

00:11:44.137 --> 00:11:47.207
像這樣擠爆了
那麼幀率的波動會很大

00:11:47.674 --> 00:11:49.676
這肯定不是
60幀每秒

00:11:49.743 --> 00:11:50.878
它會一直波動

00:11:51.411 --> 00:11:53.981
這樣就可以用
樣本分析器來查找

00:11:54.047 --> 00:11:55.849
發生了什麼
爲什麼這麼慢

00:11:57.751 --> 00:12:03.257
我們要做的就是打開Safari
並進入Develop菜單

00:12:03.957 --> 00:12:06.026
找到這裏的iPad
並連接上

00:12:07.594 --> 00:12:11.098
那麼我要做的第一件事
就是進入Frames視圖

00:12:11.164 --> 00:12:14.001
看看現在的位置
幀率如何

00:12:14.067 --> 00:12:16.069
那麼開始記錄

00:12:17.137 --> 00:12:18.572
我再轉回iPad

00:12:19.373 --> 00:12:20.774
做點什麼

00:12:22.876 --> 00:12:24.244
比如轉動一下

00:12:25.746 --> 00:12:27.514
或者換一個衛星

00:12:29.383 --> 00:12:30.250
換個時區

00:12:30.884 --> 00:12:32.219
好了
現在回去看看

00:12:35.489 --> 00:12:36.723
好的
把這個縮小

00:12:37.424 --> 00:12:40.227
所有的性能
就都顯示在這裏了

00:12:40.294 --> 00:12:44.865
有的時候是60幀每秒
像左邊這些

00:12:45.299 --> 00:12:47.367
在中間
則上下都有

00:12:47.434 --> 00:12:48.802
因爲我們在
更改視圖

00:12:49.136 --> 00:12:51.972
這一些
就太慢了

00:12:52.940 --> 00:12:55.042
我想知道
出了什麼問題

00:12:56.710 --> 00:12:58.879
那麼我就轉到
Events視圖

00:13:00.981 --> 00:13:03.283
點擊JavaScript
和Events時間線

00:13:03.350 --> 00:13:06.019
重點看看
樣本分析器的數據

00:13:07.955 --> 00:13:10.691
就像Jon之前演示的那樣
這裏的Events視圖

00:13:10.757 --> 00:13:12.926
會顯示所有
運行循環裏的內容

00:13:12.993 --> 00:13:16.096
這個例子裏
就是動畫和模擬

00:13:16.163 --> 00:13:18.398
就是我們在
不斷地渲染幀

00:13:18.465 --> 00:13:22.769
這不是很有用
因爲無法找到耗時最多的地方

00:13:23.537 --> 00:13:25.939
那麼我們轉到
Call Trees視圖

00:13:27.574 --> 00:13:30.844
這裏我們看到Top Down
Call Tree

00:13:31.211 --> 00:13:35.849
集合顯示了
所有的渲染幀

00:13:35.916 --> 00:13:37.484
都是最耗時的地方

00:13:38.352 --> 00:13:42.356
展開這個就能看到
D3有一個Timer函數

00:13:42.422 --> 00:13:45.893
它調出一些代碼
畫了一些場景

00:13:46.960 --> 00:13:49.863
這些場景包括
衛星

00:13:49.930 --> 00:13:52.099
和時間等

00:13:52.165 --> 00:13:56.303
這個很棒
能讓我們瞭解代碼在做什麼

00:13:56.670 --> 00:13:59.373
但是如果要想找出
哪個函數最耗費

00:14:00.073 --> 00:14:02.376
最好還是去看
Bottom Up視圖

00:14:04.044 --> 00:14:09.316
這裏我們列出了所有函數
無論誰調用它們

00:14:09.917 --> 00:14:12.686
我們看到這個fillText

00:14:12.753 --> 00:14:15.322
和tangent
是最耗費的兩個

00:14:15.422 --> 00:14:18.559
那爲什麼
會調出tangent呢？

00:14:18.792 --> 00:14:23.630
我們展開這一行
看看調令來源

00:14:23.830 --> 00:14:28.202
就在這裏
是_plotSatellites

00:14:28.435 --> 00:14:33.273
好像正在計算轉換
用來繪製地球

00:14:34.041 --> 00:14:35.876
好的
這些看着都很正常

00:14:36.443 --> 00:14:39.079
也許我該找出數學課本
讓它算得快一點

00:14:40.314 --> 00:14:41.682
現在看看
fillText

00:14:41.748 --> 00:14:45.652
換個畫面
回到這裏的應用

00:14:46.320 --> 00:14:51.458
我們正在當前時間上繪製文本
也在每個數據點上繪製

00:14:52.492 --> 00:14:53.460
這說得通

00:14:53.527 --> 00:14:57.898
但是如果仔細看
我們實際上把這個時間畫了兩次

00:14:58.699 --> 00:15:00.000
這就有點奇怪

00:15:00.767 --> 00:15:03.403
所以我們展開這一行

00:15:04.238 --> 00:15:06.707
就能看到
調令來自哪裏

00:15:07.975 --> 00:15:11.245
這裏我們好像
一次畫了兩個不同的前景

00:15:11.778 --> 00:15:14.114
這大概
不是我們想要的

00:15:15.516 --> 00:15:17.284
那麼來找找
哪兒出了問題

00:15:17.417 --> 00:15:20.120
如果像這樣
畫了兩個前景

00:15:20.220 --> 00:15:23.290
那麼我們的工作量
實際就是所需的兩倍

00:15:24.858 --> 00:15:28.729
爲了讓你的記憶更清晰
記住我們有個平面地圖

00:15:28.795 --> 00:15:31.431
然後有這個地球
它在轉動

00:15:32.833 --> 00:15:36.303
那麼
現在回到代碼

00:15:37.771 --> 00:15:41.942
找一找是什麼
控制着兩個地圖的切換

00:15:42.009 --> 00:15:43.010
估計哪裏弄錯了

00:15:46.513 --> 00:15:49.783
改變地點的時候
我們會讓兩個地球互換

00:15:51.051 --> 00:15:52.252
這是 updateLocation

00:15:52.819 --> 00:15:57.191
好的 因爲已經有一個地圖
就不再需要另一個

00:15:57.291 --> 00:16:00.494
這是有道理的
因爲這裏我們添加了隱藏類

00:16:00.561 --> 00:16:02.863
就爲了不讓它
顯示出來

00:16:04.298 --> 00:16:07.701
這裏在_globeMap
我們定義running值爲真

00:16:07.768 --> 00:16:09.236
在整個運行中

00:16:09.603 --> 00:16:12.506
而且在place中聲明
我們顯示的不是_globeProjection

00:16:12.573 --> 00:16:13.407
這是對的

00:16:13.473 --> 00:16:15.042
當我們顯示
平面地圖

00:16:15.108 --> 00:16:17.144
我們不會顯示地球
它也不會運行

00:16:18.178 --> 00:16:20.280
這個平面地圖
看上去好像

00:16:20.347 --> 00:16:22.382
一直在運行
UI也在運行

00:16:22.516 --> 00:16:26.086
這也挺奇怪的

00:16:26.486 --> 00:16:28.655
那麼我們回到地圖
試着做點兒什麼

00:16:32.192 --> 00:16:34.628
這裏我們選擇
這個數據組

00:16:35.762 --> 00:16:37.431
然後進入Earth

00:16:38.465 --> 00:16:43.237
它的幀率要好於
只做世界地圖

00:16:43.303 --> 00:16:44.505
那麼
這就很有道理

00:16:44.571 --> 00:16:47.574
我想我們在世界地圖活動的時候
畫了兩張地圖

00:16:47.641 --> 00:16:49.443
但是在平面地圖的時候
只畫了一個

00:16:49.510 --> 00:16:53.914
那麼我們就在這裏
改變這個條件

00:16:59.786 --> 00:17:01.288
糟糕
應該反過來

00:17:04.558 --> 00:17:08.996
好的 先停下
看看有沒有修復

00:17:12.598 --> 00:17:14.001
回到iPad

00:17:15.502 --> 00:17:16.737
好的
這看上去很流暢

00:17:16.803 --> 00:17:17.671
來到這裏

00:17:19.006 --> 00:17:19.839
恩 很好

00:17:22.041 --> 00:17:22.910
看上去不錯

00:17:22.976 --> 00:17:25.913
那麼我們再去檢查
時間渲染

00:17:25.979 --> 00:17:29.249
看看是不是
60幀每秒

00:17:30.684 --> 00:17:32.386
那麼
回到Frames視圖

00:17:33.053 --> 00:17:37.024
然後開始記錄
很不錯

00:17:37.090 --> 00:17:40.160
我轉動地球的時候
有點慢

00:17:40.227 --> 00:17:42.496
但穩定度
看上去...

00:17:42.563 --> 00:17:45.299
不錯
絕對在60幀每秒以下

00:17:45.832 --> 00:17:49.736
在這裏有一個條
只要低於它就是好的

00:17:52.940 --> 00:17:56.610
現在衛星跟蹤器
快了很多

00:17:56.677 --> 00:17:58.779
我們就知道
什麼時候帶上帽子

00:17:58.946 --> 00:17:59.780
這很棒

00:18:00.247 --> 00:18:04.017
這就是個簡單的例子
關於如何使用樣本分析器

00:18:04.084 --> 00:18:07.788
來發現最繁忙的內容
並讓它運行的更快

00:18:08.689 --> 00:18:12.893
下面Jon會跟大家講講
內存和分配

00:18:21.802 --> 00:18:22.636
謝謝 Brian

00:18:24.371 --> 00:18:27.074
你看到了
分析很迅速

00:18:27.274 --> 00:18:29.443
它能讓你瞭解
代碼的真實速度

00:18:29.510 --> 00:18:31.311
這樣你就能
獲得十分精確的數據

00:18:31.678 --> 00:18:34.448
再看看JavaScript
和Events時間線

00:18:34.948 --> 00:18:37.918
並用它們找到
緩慢的回調處理器和定時器

00:18:37.985 --> 00:18:40.454
或者在Events視圖裏
緩慢的腳本初始化

00:18:41.822 --> 00:18:44.157
請用新的Call Trees視圖
來瞭解耗時

00:18:44.224 --> 00:18:47.227
因爲它們會沿着
你選擇的時間線堆積起來

00:18:48.228 --> 00:18:50.464
記着Bottom Up
是你的新朋友

00:18:50.531 --> 00:18:54.201
它能幫助你找到
最需要優化的地方

00:18:55.869 --> 00:18:58.071
那麼現在我們已經看過了
新的樣本分析器

00:18:58.138 --> 00:19:00.574
和新的JavaScript
Call Trees視圖

00:19:00.908 --> 00:19:04.611
我很激動能用更好的工具
來優化CPU時間

00:19:04.678 --> 00:19:06.513
這樣就能給用戶
快速的體驗

00:19:06.580 --> 00:19:08.282
並幫他們
節省了電池

00:19:08.782 --> 00:19:10.551
這真的不錯
現在我們繼續

00:19:10.617 --> 00:19:12.219
看看性能的另一方面

00:19:12.586 --> 00:19:14.254
就是了解
內存都去哪兒了

00:19:15.189 --> 00:19:17.858
你肯定想更有效率地使用
網頁內容的內存

00:19:17.925 --> 00:19:19.526
因爲這是有限資源

00:19:19.960 --> 00:19:24.731
有效地使用內存可以
優化網頁內容的比例

00:19:24.798 --> 00:19:26.600
並能處理
大型數據組

00:19:28.335 --> 00:19:32.472
而且內存佔用過多會降低性能
我們並不想這樣

00:19:33.273 --> 00:19:35.175
它也會讓
你的網頁內容崩潰

00:19:35.242 --> 00:19:36.777
這更非我們所願

00:19:37.311 --> 00:19:41.682
好消息是若你運行WKWebView
它會以單獨的進程運行

00:19:41.982 --> 00:19:43.450
不會讓
整個應用崩潰

00:19:43.517 --> 00:19:45.752
但是這仍然不是
一個好的用戶體驗

00:19:46.286 --> 00:19:48.755
爲了幫你解決這些問題
我們添加了兩個新時間線

00:19:48.822 --> 00:19:50.557
給網絡檢查器
和Safari 10

00:19:51.859 --> 00:19:55.295
當啓動新網絡檢查器
新時間線就默認關閉

00:19:55.362 --> 00:19:56.730
所以要打開它們

00:19:56.797 --> 00:19:59.633
你只要點擊Edit
就在時間線上面

00:20:01.134 --> 00:20:03.704
就可以配置
自己想看的時間線

00:20:03.770 --> 00:20:06.673
這樣就可以只研究
自己想用的那個

00:20:06.740 --> 00:20:08.342
就和Instruments應用一樣

00:20:09.543 --> 00:20:12.946
只要開啓新的時間線
就可以記錄新的時間線了

00:20:13.280 --> 00:20:15.983
但你可能不想
讓它們同時運行

00:20:16.550 --> 00:20:19.386
JavaScript和
Events時間線樣本分析器

00:20:19.453 --> 00:20:21.188
雖然負載較少
但還是有

00:20:21.722 --> 00:20:24.491
而JavaScript Allocation
的時間線會添加更多進程

00:20:24.558 --> 00:20:27.761
在垃圾回收過程中
這會影響性能

00:20:28.428 --> 00:20:31.965
那我們就一直開着
Memory時間線

00:20:32.032 --> 00:20:35.002
那麼在記錄一個時間線的時候
你會看到這個

00:20:35.936 --> 00:20:39.907
這個新的Memory時間線圖表
顯示了內存如何分配

00:20:39.973 --> 00:20:42.342
到不同的目錄裏
在不同的時間

00:20:43.076 --> 00:20:44.878
這裏有一系列圖表

00:20:44.945 --> 00:20:48.515
幫你瞭解
內存的使用和劃分

00:20:49.750 --> 00:20:52.319
Breakdown表顯示了
內存如何分配給

00:20:52.386 --> 00:20:56.356
JavaScript和圖畫
和構成頁面的分層

00:20:56.423 --> 00:20:58.825
以及其他
引擎相關的網頁

00:21:00.060 --> 00:21:03.463
Max Comparison圖
幫你研究內存高峯

00:21:03.530 --> 00:21:04.831
這裏有一個高的水印

00:21:04.898 --> 00:21:07.401
幫你觀察
過去的內存問題

00:21:07.467 --> 00:21:10.437
你甚至可以分離各個峯
通過選擇一個特定的部分

00:21:10.504 --> 00:21:14.041
或者在一個峯值周圍
選擇一個特定的時間段

00:21:14.541 --> 00:21:17.945
然後你就可以使用
下面的目錄分類

00:21:18.011 --> 00:21:20.180
來看看是什麼
造成了大部分高峯

00:21:20.781 --> 00:21:23.784
這裏的每個圖表
都是獨立測量的

00:21:23.851 --> 00:21:26.653
所以你可以清楚地看到
不同時間的變化

00:21:28.021 --> 00:21:30.591
JavaScript裏的峯值
顯示的是

00:21:30.657 --> 00:21:33.527
大量新對象
被創建和引用的地方

00:21:33.660 --> 00:21:36.763
其中包括的對象
有字符串對象和函數

00:21:37.164 --> 00:21:41.201
以及所有支持它們的引擎數據
比如結構數據和編譯代碼

00:21:41.902 --> 00:21:44.605
當你看到
JavaScript的用量下降

00:21:44.671 --> 00:21:47.241
就是說垃圾回收
在回收內存

00:21:48.308 --> 00:21:50.811
圖片顯示了
分配給圖片的內存

00:21:50.878 --> 00:21:52.713
這些圖片都
通過解碼顯示

00:21:52.980 --> 00:21:54.815
這裏的圖片數據
比較大

00:21:54.882 --> 00:21:57.551
通常用於
可以在視口顯示的圖片

00:21:59.052 --> 00:22:01.722
層顯示的是
圖層內存

00:22:01.788 --> 00:22:04.858
分配在WebKits
tileGrid複合層

00:22:04.925 --> 00:22:06.093
和其他引擎層

00:22:07.227 --> 00:22:08.896
頁面就囊括了
所有其他的東西

00:22:08.962 --> 00:22:10.931
引擎所追蹤的
所有內容

00:22:10.998 --> 00:22:14.234
比如DOM和頁面風格
以及字體渲染數據

00:22:14.301 --> 00:22:16.470
內存緩存和系統分配

00:22:17.271 --> 00:22:19.306
所以這個分類
能讓你很好的保證

00:22:19.373 --> 00:22:22.242
內存用量
符合你的預期

00:22:22.943 --> 00:22:26.446
若你有很多JavaScript內容
你要明白

00:22:26.513 --> 00:22:30.150
JavaScript會是分類圖表裏
用量最多的一類

00:22:30.217 --> 00:22:33.086
在時間線圖表裏
你可能會隨着時間看到更多變化

00:22:33.954 --> 00:22:38.125
但是對於多圖片的頁面
比如畫廊

00:22:38.192 --> 00:22:41.428
那麼分層和圖片目錄
就可能是最大的

00:22:41.495 --> 00:22:42.896
隨着時間
變化也更多

00:22:43.830 --> 00:22:47.501
這就是Safari 10裏
最新的Memory時間線

00:22:49.203 --> 00:22:53.540
Memory時間線的補充就是
新的JavaScript Allocations時間線

00:22:54.074 --> 00:22:56.343
你不僅能看到
不同時間裏內存的變化

00:22:56.510 --> 00:22:58.111
還能更細的探究

00:22:58.178 --> 00:23:00.781
JavaScript Allocations
的真實情況

00:23:00.948 --> 00:23:06.553
對此我們有個強大的工具
JavaScript Allocation Snapshots

00:23:07.321 --> 00:23:08.889
快照的強大之處

00:23:08.956 --> 00:23:12.426
是你可在JavaScripts堆裏
對一個時刻進行快照

00:23:12.726 --> 00:23:15.696
然後你就可以深入看到
所有被分配的東西

00:23:16.129 --> 00:23:18.765
但是更強大的是
你有兩個快照的時候

00:23:19.466 --> 00:23:22.436
你就可以回頭再看
並進行對比

00:23:22.503 --> 00:23:25.639
對比快照
是我們最強大的工具之一

00:23:25.706 --> 00:23:29.243
它可以解答
我是不是做了不必要的分配？

00:23:30.110 --> 00:23:32.579
一定要利用它
因爲你需要多個快照

00:23:32.646 --> 00:23:36.783
這也就是爲什麼
默認每10秒照一次

00:23:37.217 --> 00:23:39.753
不僅要在記錄開始
還要在結束

00:23:40.153 --> 00:23:42.923
快照是在時間線上設計的
所以它們能連到

00:23:42.990 --> 00:23:44.825
其他時間線上
發生的事情

00:23:44.892 --> 00:23:46.894
在這裏
其他的都被我關了

00:23:48.128 --> 00:23:50.330
這些快照在下面列出
並附了一些細節

00:23:50.397 --> 00:23:51.899
比如堆的
時間和大小

00:23:52.766 --> 00:23:54.501
要了解一個特定的問題

00:23:54.568 --> 00:23:56.870
就通常需要
在開始和結束的時候快照

00:23:56.937 --> 00:23:58.739
圍繞你認爲
內存會出問題的地方

00:23:59.173 --> 00:24:00.541
這裏有三個技巧

00:24:01.074 --> 00:24:03.710
你可以依賴自動快照
每10秒一次

00:24:04.478 --> 00:24:07.247
或者可以親自快照
就按快照鍵

00:24:08.282 --> 00:24:09.750
或者用代碼執行

00:24:10.551 --> 00:24:14.254
最簡單的找到問題的方法
還是改代碼

00:24:14.555 --> 00:24:16.623
調出
takeHeapSnapshot API

00:24:16.690 --> 00:24:19.526
傳遞一個自定義的標籤參數
它可以是任何

00:24:19.593 --> 00:24:21.261
之後能幫你識別它的東西

00:24:21.695 --> 00:24:24.198
還有你要做
一對快照

00:24:24.264 --> 00:24:27.100
在你認爲導致問題的代碼
的前後

00:24:28.035 --> 00:24:30.537
你還可以通過快照
來使用這個代碼

00:24:30.604 --> 00:24:32.940
在一個循環內的
工作之間

00:24:33.340 --> 00:24:34.308
分析內存

00:24:34.374 --> 00:24:38.846
下面講講要時刻牢記的幾點
關於takeHeapSnapshot API

00:24:39.179 --> 00:24:43.050
要記住快照會增添一些額外的進程
在垃圾回收進程中

00:24:43.116 --> 00:24:45.552
這會影響性能
所以你一定要注意

00:24:45.619 --> 00:24:48.088
你的代碼是否
頻繁的發射快照

00:24:49.189 --> 00:24:52.726
你也要捕捉到
前後不同的信息

00:24:52.793 --> 00:24:55.462
當代碼在一個循環之間的
某個時刻運行時

00:24:56.630 --> 00:24:57.698
不要留下這個

00:24:57.764 --> 00:25:00.734
如果你把它留下
對大部分用戶來說沒問題

00:25:00.801 --> 00:25:04.204
但一旦有人運行網絡檢查器
它們就會使用所有的快照

00:25:04.271 --> 00:25:05.506
你大概也不想這樣

00:25:05.572 --> 00:25:08.876
所以要記住
在啓動前一定把它們刪除

00:25:09.776 --> 00:25:11.411
那麼這些快照
都顯示了什麼？

00:25:13.146 --> 00:25:14.181
讓我們來看一看

00:25:14.848 --> 00:25:18.619
你只要點擊時間線上的
快照圖標

00:25:18.685 --> 00:25:21.555
或者在快照列表條目裏
點擊Arrow按鍵

00:25:22.422 --> 00:25:25.225
你看到的這一列對象
都是之前分配在堆裏的

00:25:25.292 --> 00:25:27.294
快照有兩個視圖

00:25:27.694 --> 00:25:29.129
這是Instances視圖

00:25:29.196 --> 00:25:33.033
展示了堆裏的對象列表
按照類來分組

00:25:33.634 --> 00:25:35.736
另一個是
對象圖像視圖

00:25:35.802 --> 00:25:37.871
這實際上
概括了所有東西

00:25:37.938 --> 00:25:40.073
所有的所有

00:25:40.507 --> 00:25:42.109
如果你很熟悉這個代碼

00:25:42.176 --> 00:25:45.946
它就能很好地幫助你
確認事情或者找到相應的位置

00:25:46.947 --> 00:25:49.183
但是實際上
更有用的視圖

00:25:49.249 --> 00:25:51.785
是在Instances視圖裏

00:25:51.852 --> 00:25:54.221
它的強大在於
你可以輕鬆地找到對象

00:25:54.288 --> 00:25:57.057
不論他們在屬性路徑裏
藏得多深

00:25:57.958 --> 00:26:00.494
這裏的Count可以幫你
意識到潛在的問題

00:26:00.561 --> 00:26:02.162
就是它們
無法達到預期的時候

00:26:02.229 --> 00:26:05.199
比如我能否實現
4000多個字符串對象？

00:26:06.733 --> 00:26:10.470
你可以展開這個Classes
來看看所有分配到這裏的對象

00:26:11.238 --> 00:26:14.942
然後判斷什麼是什麼
通過這麼多不同的線索

00:26:15.008 --> 00:26:16.076
Class是一線索

00:26:16.944 --> 00:26:19.379
另外就是
對象的實際屬性

00:26:19.713 --> 00:26:21.648
這能讓我們很快了解
什麼是什麼

00:26:22.516 --> 00:26:24.785
但是最簡單的
瞭解對象的方法

00:26:24.852 --> 00:26:29.323
就是懸停在這個對象識別器上
你就會看到這個

00:26:30.924 --> 00:26:34.795
這裏實際上顯示的是
到對象的最短路徑

00:26:35.362 --> 00:26:38.098
它告訴了你究竟是什麼
讓這個對象保持活動

00:26:38.732 --> 00:26:40.868
它基本上總會給你
你需要的答案

00:26:41.768 --> 00:26:45.572
特別是在JavaScript的
垃圾回收裏

00:26:45.639 --> 00:26:48.509
這就是能
立刻解開疑惑的方法

00:26:49.643 --> 00:26:53.013
但是它最重要的功能
和最關鍵的要點

00:26:53.080 --> 00:26:55.048
在於它能
比較兩個快照

00:26:55.349 --> 00:26:57.551
看看這個
當你已經收集了一些快照

00:26:58.218 --> 00:27:00.521
只要點擊此處“比較快照”按鍵

00:27:01.321 --> 00:27:04.992
然後選擇Baseline快照
再選一個對比

00:27:05.792 --> 00:27:06.627
一下子

00:27:07.027 --> 00:27:09.263
你就有了一個
新的對比快照可以研究

00:27:09.796 --> 00:27:11.131
這個十分有意義

00:27:11.498 --> 00:27:13.467
因爲現在只能看到
新的對象

00:27:13.534 --> 00:27:16.637
在兩個點之間
在兩個快照之間

00:27:18.172 --> 00:27:21.475
展開對象類分組
可以看到所有的對象分配

00:27:21.542 --> 00:27:24.945
預覽中顯示了它們的名字
和類似遙測數據的東西

00:27:25.646 --> 00:27:27.848
這裏就說明
它是衛星對象

00:27:28.348 --> 00:27:31.151
這裏的彈窗顯示
_Satellites Array屬性

00:27:32.319 --> 00:27:34.054
由於這是
一個快照對比

00:27:34.121 --> 00:27:36.857
衛星的對象
都是新分配的

00:27:36.924 --> 00:27:39.359
這是個很重要的線索
顯示代碼在做什麼

00:27:39.893 --> 00:27:42.296
那麼爲了讓你們實際看到
這些新的存儲功能

00:27:42.362 --> 00:27:44.798
我要有請Brian回到臺上
來做另一個演示

00:27:51.171 --> 00:27:52.005
謝謝 Jon

00:27:52.606 --> 00:27:55.742
我把衛星跟蹤器
給了我的朋友Ed

00:27:55.809 --> 00:27:58.545
他熬了一夜
在玩這個

00:28:00.113 --> 00:28:04.251
他很開心
因爲他從來沒有被衛星跟蹤過

00:28:04.351 --> 00:28:05.452
但是這就有個問題

00:28:05.519 --> 00:28:09.122
它運行時間越長
最終會變得越來越慢

00:28:09.790 --> 00:28:13.026
這在我看來
很像傳統的內存

00:28:13.093 --> 00:28:15.262
打開時間越久
就越慢

00:28:15.929 --> 00:28:20.601
我想在衛星跟蹤器裏
用這些新存儲工具來看看

00:28:20.667 --> 00:28:22.369
我們是否泄漏了
一些內存

00:28:23.637 --> 00:28:26.173
那麼第一件事

00:28:26.240 --> 00:28:28.575
我的iPad在這兒

00:28:29.309 --> 00:28:31.545
我要回到
網絡檢查器...

00:28:34.381 --> 00:28:35.782
並且檢查這個應用

00:28:36.717 --> 00:28:38.418
我要做的第一件事

00:28:39.286 --> 00:28:43.857
在我不知道問題在哪兒的時候
就是要使用Memory時間線

00:28:43.924 --> 00:28:48.595
它會告訴我
頁面上大概發生了什麼

00:28:48.662 --> 00:28:50.030
那麼我們開始記錄

00:28:51.131 --> 00:28:52.766
轉回來

00:28:52.833 --> 00:28:57.604
我在兩個衛星之間
來回切換

00:28:58.138 --> 00:29:00.741
也許我會在這裏
添加一些效果

00:29:02.142 --> 00:29:04.611
好的
我在來回切換

00:29:06.613 --> 00:29:08.048
好了
現在去時間線看看

00:29:11.351 --> 00:29:15.422
在時間線概覽中
你看到一個堆積線形圖

00:29:15.489 --> 00:29:17.624
顯示了所有不同的部分
和相關的大小

00:29:17.858 --> 00:29:21.128
如果你點擊這裏
會看到更多的細節

00:29:22.563 --> 00:29:24.831
那麼這個頁面上
沒有圖片

00:29:24.898 --> 00:29:25.766
都是畫布

00:29:26.400 --> 00:29:27.801
分層也很平面

00:29:28.268 --> 00:29:30.804
頁面有些波動
有些內容在垃圾回收

00:29:30.871 --> 00:29:31.705
沒有問題

00:29:32.306 --> 00:29:35.175
如果你仔細看看JavaScript
你會看到...

00:29:35.776 --> 00:29:37.444
雖然有些東西
被垃圾回收

00:29:37.511 --> 00:29:40.280
但是整體來說
它還是在隨着時間堆積

00:29:40.614 --> 00:29:44.318
如果我們運行一整晚
那估計會堆積更多

00:29:44.952 --> 00:29:51.358
下一步就是啓用heap快照
或allocation快照

00:29:51.425 --> 00:29:54.194
這樣我們就能找到
隨着時間而分配的內容

00:29:56.630 --> 00:30:00.667
爲了實現這個
我們要開始新的記錄

00:30:03.103 --> 00:30:06.139
這有個快捷鍵
Shift 點擊或Shift 空格

00:30:06.206 --> 00:30:08.942
這樣就會啓動新的記錄
而不是繼續之前那個

00:30:09.510 --> 00:30:11.778
等等
我忘了改時間線

00:30:11.845 --> 00:30:13.046
去掉Memory

00:30:14.314 --> 00:30:15.916
選上Allocations

00:30:18.252 --> 00:30:19.520
好了
開始記錄

00:30:20.387 --> 00:30:21.288
回到iPad

00:30:23.190 --> 00:30:25.759
添加了小小的
takeHeapSnapshot鍵

00:30:25.826 --> 00:30:29.229
我已給控制檯添加了
一些takeHeapSnapshot的調令

00:30:29.296 --> 00:30:32.633
用於切換兩個衛星小組
和其他操作

00:30:33.800 --> 00:30:38.038
對這個記錄
我要轉動地圖

00:30:38.105 --> 00:30:41.942
然後不斷在
兩個衛星中切換

00:30:46.580 --> 00:30:49.416
我們還要看看Spy Satellites
看上去也有關聯

00:30:52.419 --> 00:30:54.254
好了 你會發現
開始有點卡了

00:30:54.321 --> 00:30:57.591
因爲我們給JavaScript堆裏的
所有東西拍了快照

00:30:57.658 --> 00:31:00.060
因此
產生了很多對象

00:31:00.127 --> 00:31:01.795
這會大幅降低
應用的速度

00:31:01.862 --> 00:31:05.265
所以一定不要
拍很多快照

00:31:05.332 --> 00:31:08.435
只在重要的時候拍

00:31:08.802 --> 00:31:13.974
這裏你可以看到方塊裏的S
就是我們拍的快照

00:31:16.043 --> 00:31:18.812
放大一下能看到

00:31:18.879 --> 00:31:20.814
隨着時間過去
內存十分穩定的增長

00:31:20.881 --> 00:31:23.584
當我們開始在
兩個衛星之間切換的時候

00:31:26.753 --> 00:31:29.056
如果我們要研究這個
像Jon說的那樣

00:31:29.122 --> 00:31:35.829
我們就要啓動對比
來看看是什麼被攔住了

00:31:35.896 --> 00:31:40.167
那麼我們就對比
快照9和11

00:31:41.602 --> 00:31:45.072
立刻
我們就看到很多東西

00:31:45.138 --> 00:31:49.443
被分配在9和11之間
並且仍然在活動中

00:31:49.943 --> 00:31:52.412
這就清楚地說明瞭
它們被留存了

00:31:52.479 --> 00:31:54.648
雖然我們
並不想這麼做

00:31:55.649 --> 00:31:57.551
那麼我們來看看
這些都是什麼

00:31:58.752 --> 00:31:59.620
這是些陣列

00:32:00.454 --> 00:32:03.423
看上去這個陣列裏
全是座標

00:32:04.858 --> 00:32:07.728
你知道在應用的不同部分
我們會用大量的座標

00:32:07.794 --> 00:32:11.164
但是如果我們停在這裏
就會看到它的路徑

00:32:11.265 --> 00:32:14.701
它們好像是被保存於
trajectoryHistory

00:32:14.768 --> 00:32:18.572
這是我們用來製作
追蹤衛星的東西

00:32:19.973 --> 00:32:21.375
好的
這樣不錯

00:32:21.441 --> 00:32:23.710
但是我想不應該

00:32:25.112 --> 00:32:27.714
再在已不顯示的衛星裏用
trajectoryHistory

00:32:27.781 --> 00:32:29.416
這好像是個bug

00:32:31.985 --> 00:32:33.620
我們也分配了
一些對象

00:32:35.055 --> 00:32:39.526
但奇怪的是
在快照9和11之間

00:32:39.593 --> 00:32:41.795
我們之前已經看到
這些衛星

00:32:41.862 --> 00:32:45.065
那麼我就不想
再給每個衛星創建新的對象

00:32:45.132 --> 00:32:48.735
我們只要直接使用它們
只要我們已經爲他們獲取了資源

00:32:48.802 --> 00:32:53.140
然後這裏有了很多
座標和遙測

00:32:53.207 --> 00:32:56.476
好像正在
重新解析什麼

00:32:58.045 --> 00:32:59.646
我不太確定
那麼...

00:33:00.113 --> 00:33:03.851
在這個視圖裏
我們有很多對象

00:33:03.917 --> 00:33:05.085
你不能讀取所有

00:33:05.152 --> 00:33:08.355
所以我想做的
就是找出很特別的那一個

00:33:08.856 --> 00:33:10.357
那麼在這個快照裏

00:33:11.825 --> 00:33:13.861
我們有很多字符串
陣列和對象

00:33:13.927 --> 00:33:15.395
但只有一個Promise

00:33:15.829 --> 00:33:17.831
它停留在
兩個快照之間

00:33:17.898 --> 00:33:19.900
所以我認爲
應該調試這個

00:33:19.967 --> 00:33:24.071
那麼我就找到代碼
看看是哪裏在用Promises

00:33:24.371 --> 00:33:27.274
因爲好像它與別的什麼
一起被泄露了

00:33:27.441 --> 00:33:29.576
於是
搜索Promise

00:33:30.077 --> 00:33:34.882
好了 這是D3庫
這是使用它的代碼

00:33:37.251 --> 00:33:39.052
好的
來看看這個

00:33:39.887 --> 00:33:44.892
好了 在［聽不清］裏
我們常常在衛星之間切換

00:33:44.958 --> 00:33:46.593
代碼是loadDataset

00:33:46.793 --> 00:33:50.631
有人寫了評論
太好了

00:33:51.665 --> 00:33:56.103
這裏看上去好像
有人請求我們改變衛星

00:33:57.271 --> 00:34:03.710
那麼這裏就可以
異步從URL下載數據

00:34:03.777 --> 00:34:06.046
當它返回
我們就要解析

00:34:07.414 --> 00:34:10.918
然後使用衛星繪圖庫 
做更多的解析

00:34:11.784 --> 00:34:13.887
然後我們把它存到
衛星列表上

00:34:15.389 --> 00:34:18.525
這都很不錯
但是回到檢查器

00:34:18.592 --> 00:34:20.527
我們好像每次都泄露該Promise

00:34:20.594 --> 00:34:22.929
如果你更仔細的想想

00:34:22.996 --> 00:34:25.732
如果切換到
已經下載的數據組會怎樣？

00:34:26.967 --> 00:34:29.235
我們甚至都沒有
檢查過這個事情

00:34:30.237 --> 00:34:33.373
你仔細的看看這裏

00:34:34.107 --> 00:34:36.577
每次在兩個衛星之間轉換

00:34:37.277 --> 00:34:38.812
我們就發出
一個新的網絡請求

00:34:38.879 --> 00:34:40.179
如果我們進入這個時間線

00:34:41.014 --> 00:34:44.618
就會看到我們在不斷請求
同樣的垃圾數據

00:34:46.018 --> 00:34:49.523
這是正常的
如果回到代碼 發出請求

00:34:49.590 --> 00:34:51.859
解析的時候
會產生大量的對象

00:34:52.492 --> 00:34:54.293
然後我們把它推入
衛星陣列

00:34:54.360 --> 00:34:56.697
就目前來看
它怎麼都不清楚

00:34:56.763 --> 00:35:02.202
我們好像一直在做無用功
然後不斷泄露

00:35:02.269 --> 00:35:04.838
所以這裏
我們要做的

00:35:04.905 --> 00:35:08.475
是檢查我們是否已經
解析了這個衛星對象

00:35:08.742 --> 00:35:10.043
因爲這是Promise

00:35:10.344 --> 00:35:14.081
如果它確實存在
我們可以調出.then

00:35:14.848 --> 00:35:18.886
由於這已解決
下一次評估Promise的反應時

00:35:18.952 --> 00:35:22.556
它就會進行檢查
並將衛星放到地圖上

00:35:23.657 --> 00:35:26.960
那麼在這裏
添加代碼

00:35:30.664 --> 00:35:33.734
如果不存在
我們就創建一個

00:35:42.242 --> 00:35:47.314
好了 現在停下來看看
有沒有效果

00:35:50.117 --> 00:35:52.352
我們就要回去
重新連接

00:35:55.923 --> 00:35:59.993
這是我們的應用
開始記錄吧

00:36:02.329 --> 00:36:05.132
當我們回到應用
我就打開快照

00:36:05.632 --> 00:36:06.700
打開一些效果

00:36:06.800 --> 00:36:10.237
然後往南走

00:36:10.804 --> 00:36:13.240
好的 間諜衛星

00:36:14.274 --> 00:36:16.777
衛星的科學實驗

00:36:17.811 --> 00:36:18.779
科學實驗

00:36:20.480 --> 00:36:21.315
好了

00:36:24.885 --> 00:36:28.455
如果我們回到這裏
我們看到內存的增長大大降低

00:36:28.522 --> 00:36:31.959
大概在1兆
而不是四五兆

00:36:32.025 --> 00:36:34.228
那麼這裏可能有
更多的泄露

00:36:34.294 --> 00:36:38.665
但是在快照結束的時候
我們的內存

00:36:38.732 --> 00:36:41.168
跟剛開始渲染的時候
一樣大

00:36:41.235 --> 00:36:43.537
這樣我們就修復了
這個特殊的泄露

00:36:44.805 --> 00:36:49.710
這就展示了我們如何使用
Allocations和Memory時間線

00:36:49.776 --> 00:36:53.547
來解決像這樣的
應用的內存泄露問題

00:36:54.114 --> 00:36:58.585
這很不錯
因爲應用可以用更多的操作

00:36:58.652 --> 00:37:00.954
有了diffing功能

00:37:01.021 --> 00:37:04.825
我們就可以深入觀察
我們所關心的衛星裏的變化

00:37:06.660 --> 00:37:09.062
好了
衛星跟蹤器就講到這

00:37:10.197 --> 00:37:11.031
你回來吧 Jon

00:37:16.670 --> 00:37:17.504
謝謝 Brian

00:37:17.738 --> 00:37:21.241
你看到了
真是不可思議的迅速和簡單

00:37:21.308 --> 00:37:24.845
這些新的時間線
讓內存零問題

00:37:25.512 --> 00:37:27.748
所以請記住
Memory時間線是瞭解

00:37:27.814 --> 00:37:30.317
內存的使用情況
和造成內存高峯的原因

00:37:30.384 --> 00:37:32.119
這樣你就知道
該去哪裏找問題

00:37:33.020 --> 00:37:37.291
然後使用多個Heap快照
在JavaScript Allocations時間線裏

00:37:37.357 --> 00:37:39.826
以便單獨放大
造成內存增長的代碼

00:37:40.761 --> 00:37:43.363
還有不要忘了刪除
takeHeapSnapshot

00:37:43.430 --> 00:37:44.932
在代碼運行之前

00:37:46.066 --> 00:37:48.101
要記住性能所受的影響

00:37:48.168 --> 00:37:51.505
是JavaScript Allocations
時間線記錄時產生的

00:37:53.607 --> 00:37:56.577
那麼以上就是
新的時間線工具

00:37:56.643 --> 00:37:58.445
可用在Safari 10的
網絡檢查器上

00:37:58.979 --> 00:38:00.747
我想你一定會
愛上它們

00:38:01.982 --> 00:38:04.852
在結束之前
我還想再說幾點

00:38:05.586 --> 00:38:08.355
我要建議你們
重新考慮下WKWebView

00:38:08.422 --> 00:38:09.623
如果你還沒有換掉它

00:38:11.358 --> 00:38:13.493
在Safari設置裏
打開Develop菜單

00:38:13.560 --> 00:38:15.262
連接網絡檢查器
到你的應用

00:38:15.329 --> 00:38:17.631
然後開始利用
這些新功能

00:38:18.031 --> 00:38:21.468
節省大量時間
Bottom Up視圖和Call Trees用於

00:38:21.535 --> 00:38:23.504
找到最需要優化的地方

00:38:23.570 --> 00:38:26.974
Memory時間線可以
快速看到內存高峯的情況

00:38:27.140 --> 00:38:31.111
Heap快照可以
輕鬆查找和比較對象分配

00:38:32.379 --> 00:38:33.881
時刻關注
新功能的更新

00:38:33.947 --> 00:38:36.550
今年網絡檢查器
和WebKit有更多內容

00:38:36.617 --> 00:38:39.486
可以讓你利用
應用的網頁內容

00:38:39.620 --> 00:38:41.722
來創造絕佳的
應用內的用戶體驗

00:38:42.789 --> 00:38:45.225
除了Brian和我
今天爲你們展示的功能

00:38:45.292 --> 00:38:48.562
我們團隊過去一年也爲
網絡檢查器添加了很多內容

00:38:49.396 --> 00:38:53.500
Quick Open會讓你直接跳到
頁面加載的資源

00:38:53.867 --> 00:38:58.739
尾調用堆棧
現在可顯示調試器裏的尾調用優化函數

00:38:59.339 --> 00:39:02.809
初春的時候在OS 10系統下
我們引進了Safari 9.1

00:39:03.277 --> 00:39:05.245
並更新了
網絡檢查器

00:39:05.913 --> 00:39:09.416
它顯示了Elements標籤下
DOM Tree裏的Pseudo Elements

00:39:09.883 --> 00:39:12.319
這裏還有一個
新的視覺風格邊欄

00:39:13.787 --> 00:39:15.489
可能你還沒注意到

00:39:15.756 --> 00:39:17.991
網絡檢查器
是一個開發者工具

00:39:18.058 --> 00:39:20.527
作爲WebKit開源項目的一部分

00:39:21.962 --> 00:39:25.199
WebKit是網頁瀏覽器引擎
用來支持你的應用

00:39:25.265 --> 00:39:27.668
驅動WebViews
和JSContext

00:39:28.068 --> 00:39:30.137
當然它也是Safari
背後的動力

00:39:31.004 --> 00:39:34.508
在過去一年裏
我們爲WebKit添加了好多新功能

00:39:34.575 --> 00:39:36.910
我們對ES6
100％支持

00:39:37.678 --> 00:39:40.714
我們改進了對IndexedDB
Standard的支持

00:39:41.215 --> 00:39:45.219
還添加了Shadow DOM支持
WebDriver和CSS變量

00:39:45.619 --> 00:39:46.753
以及Picture Element

00:39:47.688 --> 00:39:50.224
所以真的是很多內容
而且作爲開源項目

00:39:50.290 --> 00:39:52.559
一旦有新的出現
你就能知道

00:39:53.060 --> 00:39:55.329
你們在座大部分人
肯定都想能利用它工作

00:39:55.395 --> 00:39:58.365
如果你們想
對這些內容作出改進

00:39:58.432 --> 00:39:59.433
完全有機會

00:39:59.499 --> 00:40:01.702
因爲WebKit
是開放資源

00:40:02.669 --> 00:40:05.906
你可在WebKit.org上
找到更多WebKit項目信息

00:40:05.973 --> 00:40:09.710
WebKit團隊及其背後的
工程師們會在博客上寫他們的開發工作

00:40:09.776 --> 00:40:11.778
實際上
我們現在有兩個博客

00:40:11.845 --> 00:40:14.648
關於Memory時間線
和樣本分析器

00:40:14.715 --> 00:40:15.716
就是今天講的內容

00:40:15.782 --> 00:40:18.151
所以如果你想了解更多
可以去那裏看看

00:40:18.552 --> 00:40:21.355
我們還有一個功能狀態頁
一目瞭然的列出了所有更新

00:40:21.421 --> 00:40:22.789
針對網頁標準進程

00:40:23.357 --> 00:40:26.260
這裏還有鏈接
可以下載WebKit夜間建構

00:40:26.727 --> 00:40:29.930
和最新的瀏覽器
Safari技術概覽

00:40:30.797 --> 00:40:34.201
每幾周更新一次
附帶更新的WebKit引擎

00:40:34.668 --> 00:40:37.871
所以你可以在WebKit上
嘗試這些新的實驗性功能

00:40:37.938 --> 00:40:39.606
它們每兩週改進一次

00:40:40.474 --> 00:40:44.411
我們團隊投入了大量精力給Safari
WebKit和網絡檢查器

00:40:44.478 --> 00:40:47.581
網絡檢查器團隊
可以使用這些新性能特性

00:40:47.648 --> 00:40:50.918
就像我們今天展示的那樣
去查詢問題並提高性能

00:40:50.984 --> 00:40:52.419
對網絡檢查器本身

00:40:52.619 --> 00:40:54.555
我已經迫不及待
想看看你們會做些什麼

00:40:54.855 --> 00:40:56.590
想了解更多信息
請觀看這個演講

00:40:56.657 --> 00:40:59.259
在developer.apple.com
下載幻燈片

00:41:00.093 --> 00:41:03.163
這周的前幾天有很多場相關演講

00:41:03.230 --> 00:41:04.831
過去幾年也有不少

00:41:05.098 --> 00:41:07.835
這些都能在
developer.apple.com上找到

00:41:08.769 --> 00:41:12.606
那麼代表Brian 我自己
和Safari與WebKit團隊

00:41:12.673 --> 00:41:15.442
感謝你們的到來
祝大家在接下來的WWDC中過得愉快

00:00:19.386 --> 00:00:22.389
優化應用的網頁內容

00:00:22.456 --> 00:00:23.290
大家好

00:00:27.427 --> 00:00:29.763
歡迎來到“優化應用的網頁內容”

00:00:29.830 --> 00:00:31.398
我是Jonathan Davis

00:00:31.465 --> 00:00:34.168
網絡技術的推廣人
負責Safari和WebKit

00:00:34.902 --> 00:00:37.271
現在我要先說明一些事情

00:00:38.172 --> 00:00:40.707
很多人說我長得像
Edward Snowden

00:00:40.774 --> 00:00:42.309
但我向你保證 我不是他

00:00:43.210 --> 00:00:46.947
但這麼多衛星在頭頂盤旋
大概都是來抓我們的

00:00:47.915 --> 00:00:50.751
除此之外 我很激動地要展示些新東西

00:00:50.817 --> 00:00:53.787
它們可以幫助你
提升應用網頁內容的性能

00:00:54.288 --> 00:00:56.323
我們一直都知道

00:00:56.390 --> 00:00:59.326
性能是提供最佳用戶體驗的關鍵

00:00:59.393 --> 00:01:04.431
若你是個應用開發者並在應用裏用了
WebViews和JSContext

00:01:05.364 --> 00:01:07.901
而且你很關心性能
那你就來對地方了

00:01:08.569 --> 00:01:09.970
說到性能

00:01:10.304 --> 00:01:14.074
在當今時代裏
性能其實就是指電池壽命

00:01:14.141 --> 00:01:17.411
我認爲電池壽命是最終的有限資源

00:01:17.845 --> 00:01:20.280
它帶來很不同的結果
如果你能撥出最後一通電話

00:01:20.347 --> 00:01:23.717
或者發出最後一份重要的文件
在電池耗光之前

00:01:24.218 --> 00:01:26.420
性能對用戶來說
事關重大

00:01:26.753 --> 00:01:29.389
他們所選擇的應用
不會讓設備變慢

00:01:29.456 --> 00:01:30.724
而且耗電量低

00:01:31.692 --> 00:01:35.596
我們的經驗就是
根據用戶的反饋和各自的體會

00:01:35.662 --> 00:01:38.966
性能很重要
因爲電池壽命事關重大

00:01:40.400 --> 00:01:44.104
所以今年我們致力於
提供更好的工具

00:01:44.171 --> 00:01:46.640
來找到和修復
網頁內容的性能問題

00:01:47.207 --> 00:01:49.510
現在我們爲應用提供了工具
比如Swift

00:01:49.576 --> 00:01:51.778
還有Objective-C代碼
比如Instruments

00:01:52.312 --> 00:01:56.049
我們還提供了網絡檢查器
幫助網頁開發者創建網頁和網站

00:01:57.017 --> 00:01:59.286
但不要覺得
因爲你選擇了

00:01:59.353 --> 00:02:02.422
在應用中用網絡技術
就沒有其他工具可用了

00:02:02.489 --> 00:02:05.259
實際上
我今天展示給你的所有工具

00:02:05.325 --> 00:02:07.427
就是開發給人們
既能幫助他們建設網站

00:02:07.494 --> 00:02:10.430
也能讓他們在應用裏
用網絡技術

00:02:11.265 --> 00:02:12.566
那麼我首先要
向你展示

00:02:12.633 --> 00:02:15.936
如何把網絡檢查器連接到
JSContext的WebViews

00:02:16.003 --> 00:02:18.505
這樣在你需要它的時候
它就會立刻出現

00:02:19.540 --> 00:02:21.375
之後你會瞭解
一些新的功能

00:02:21.441 --> 00:02:25.479
它們能讓你瞭解JavaScript代碼
如何分配時間

00:02:25.546 --> 00:02:29.650
以及這些新功能
如何幫你迅速找到性能上的問題

00:02:30.651 --> 00:02:34.955
如果你想要看到
網絡內容的內存使用情況

00:02:35.022 --> 00:02:38.392
我們也給網絡檢查器增添了新的時間線
我都已等不及想展示了

00:02:38.592 --> 00:02:41.562
它們會幫你節省很多時間
來找到內存過大的問題

00:02:41.995 --> 00:02:43.797
準備好了？
那就開始吧

00:02:45.032 --> 00:02:46.333
第一件
我們要做的事

00:02:46.400 --> 00:02:48.769
是把網絡檢查器
連接到應用裏

00:02:49.469 --> 00:02:52.840
在應用裏使用網絡技術
有很多原因

00:02:53.574 --> 00:02:56.276
如JS context裏的
一些JavaScript模塊

00:02:56.343 --> 00:02:59.980
可以讓你輕鬆交換邏輯
並無編譯地添加新的模塊

00:03:00.747 --> 00:03:05.419
可能有些人正在tvOS應用裏
使用TVML的 JSContext

00:03:06.053 --> 00:03:09.690
另外一個使用網絡技術的原因
就是你要顯示的網頁內容

00:03:10.157 --> 00:03:12.059
比如第三方網站的
一個網頁

00:03:12.459 --> 00:03:13.727
這個網站
你不能控制

00:03:14.027 --> 00:03:16.663
可能就要用到Safari視圖控制器

00:03:16.730 --> 00:03:18.398
如果不是
你也許可以去聽聽

00:03:18.465 --> 00:03:21.602
去年的演講
“介紹Safari視圖控制器”

00:03:22.903 --> 00:03:26.106
但如果你顯示的內容
是你自己的或者你可以控制的

00:03:26.173 --> 00:03:31.912
或是可自定義的HTML CSS
或JavaScript編寫的內容

00:03:31.979 --> 00:03:34.281
或者是
可以提升應用體驗的內容

00:03:34.615 --> 00:03:36.350
WKWebView
是最好的選擇

00:03:36.717 --> 00:03:39.786
它實際上是個矩形
把網頁內容拉入應用

00:03:40.354 --> 00:03:43.690
它引入了iOS 8
和OS 10 Yosemite

00:03:44.858 --> 00:03:47.561
若你還在使用WebView
或者UIWebView

00:03:47.828 --> 00:03:51.164
那你一定要考慮
升級到WKWebView

00:03:51.565 --> 00:03:54.735
事實上 升級到WKWebView
可以讓你利用

00:03:54.801 --> 00:03:58.805
Nitro JavaScript
核心引擎和四級JIT編譯器

00:03:58.872 --> 00:04:00.007
這能大大提升速度

00:04:00.741 --> 00:04:02.743
若想了解更多WKWebView信息

00:04:03.010 --> 00:04:07.314
我推薦2014年的演講
介紹了現代化的WebKit API

00:04:08.282 --> 00:04:11.418
那麼去年我們給WKWebView
添加了很多優秀的功能

00:04:11.485 --> 00:04:16.589
比如 加載文件URL和自定義用戶代理字符串
還有WK網站數據存儲API

00:04:17.858 --> 00:04:22.296
現今有了iOS 10和macOS Sierra
我們改進了3D-touch支持

00:04:23.063 --> 00:04:25.532
現在你的應用就可以執行這些好用的

00:04:25.599 --> 00:04:27.835
Peek和Pop事件
在WKWebView裏

00:04:29.336 --> 00:04:31.438
就像我之前說的
因爲你選了

00:04:31.505 --> 00:04:32.906
在應用裏
應用網絡技術

00:04:33.807 --> 00:04:35.142
並不意味着
你沒有工具可用

00:04:35.209 --> 00:04:37.811
不論哪種情況
你可連接網絡檢查器

00:04:37.878 --> 00:04:40.214
發掘網頁內容
或JavaScript活動情況

00:04:41.081 --> 00:04:44.985
但使用網絡檢查器前
你必須要激活develop菜單

00:04:45.219 --> 00:04:49.156
只要上傳Safari設置
然後找到“高級”標籤

00:04:49.356 --> 00:04:51.558
然後在底部
你會看到這個複選框

00:04:51.625 --> 00:04:53.961
寫着在菜單欄顯示Develop菜單

00:04:54.995 --> 00:04:56.730
那就點擊它

00:04:56.964 --> 00:04:59.766
Develop菜單就會出現在
Safari的菜單欄裏

00:05:01.735 --> 00:05:04.371
爲讓網絡檢查器
連接到iOS設備

00:05:04.438 --> 00:05:06.073
你要開啓一個設置

00:05:06.607 --> 00:05:10.210
在iOS的設置應用裏
點擊Safari

00:05:10.511 --> 00:05:16.016
然後拉到底部 點擊“高級”
然後把檢查器設置打開

00:05:16.884 --> 00:05:18.652
現在你就可以
把設備連到Mac上

00:05:18.719 --> 00:05:20.654
在Safari裏
檢查Develop菜單

00:05:22.356 --> 00:05:24.558
Develop菜單裏
有些很酷炫的東西

00:05:24.625 --> 00:05:26.627
你之前可能
從未注意到過

00:05:26.693 --> 00:05:28.962
就是你能看到設備的列表

00:05:29.029 --> 00:05:32.866
這裏有已連接的iPhone
MacBook Pro和模擬器

00:05:33.500 --> 00:05:36.837
要連接一個設備
並開始使用這些工具

00:05:36.904 --> 00:05:39.206
進行調試
那麼只要選擇Device菜單

00:05:39.473 --> 00:05:43.377
就會收到 當前設備上運行的
WebViews和JSContexts 的列表

00:05:44.411 --> 00:05:46.580
這裏的Mac應用
並沒有使用WebKit

00:05:46.647 --> 00:05:48.015
而用JavaScript

00:05:48.148 --> 00:05:50.651
所以我可以直接連接它
並使用工具

00:05:51.585 --> 00:05:56.190
iOS裏的應用只會出現在
用Xcode創建和運行的時候

00:05:56.924 --> 00:06:00.194
但是說到Mac應用
你還要做一件事

00:06:01.261 --> 00:06:05.299
就是保持應用的完整性
我們不會讓任何人下載你的應用

00:06:05.365 --> 00:06:08.168
並用網絡檢查器
巡查你的應用

00:06:08.669 --> 00:06:10.103
所以你要添加
這個授權

00:06:10.170 --> 00:06:12.272
到應用本地開發的
授權文件裏

00:06:13.307 --> 00:06:15.542
你可能已經有了一個
授權文件

00:06:15.609 --> 00:06:17.477
如果沒有
創建一個也很簡單

00:06:17.544 --> 00:06:20.581
你只要創建新的plist
拓展名爲.entitlements

00:06:20.914 --> 00:06:25.419
並且Xcode的創建設置裏
定義一個代碼簽名的授權傳遞路徑

00:06:26.753 --> 00:06:28.488
這個要在
開發的時候添加

00:06:28.555 --> 00:06:30.791
之後在
運行應用的時候刪除

00:06:31.792 --> 00:06:32.893
一旦有了這個授權

00:06:33.126 --> 00:06:35.395
你的設備和應用就
出現在Develop菜單

00:06:35.462 --> 00:06:36.496
這樣就可以連接了

00:06:36.830 --> 00:06:42.669
輕鬆把網絡檢查器連接到
JSContext和WebViews上了

00:06:44.805 --> 00:06:47.674
我們已正常運行了
網絡檢查器和應用

00:06:48.675 --> 00:06:51.078
該談談網絡檢查器裏
新功能了

00:06:51.144 --> 00:06:53.814
我想首先講講
分析JavaScript代碼

00:06:53.881 --> 00:06:54.715
分析JavaScript

00:06:54.781 --> 00:06:57.584
JavaScript的分析器
已經存在挺長時間了

00:06:57.651 --> 00:06:59.620
今年它變得更好

00:06:59.686 --> 00:07:03.156
更有效率
能幫助你迅速找到

00:07:03.223 --> 00:07:05.392
哪裏調出的JavaScript
成本最高

00:07:05.459 --> 00:07:06.660
原因很簡單

00:07:07.628 --> 00:07:11.965
新的分析器採用了取樣技術
不會影響性能

00:07:12.032 --> 00:07:13.734
比以前好太多

00:07:14.568 --> 00:07:17.504
我們的分析器
在編譯器能用之前的時代

00:07:17.571 --> 00:07:18.739
實際是個翻譯器

00:07:19.206 --> 00:07:23.143
但是現在我們有了
這個強大的四級JIT編譯器

00:07:23.443 --> 00:07:26.947
那麼這個分析器
就真正成爲樣本分析器

00:07:28.048 --> 00:07:31.518
樣本分析器告訴你
代碼把時間都用在哪裏

00:07:31.752 --> 00:07:35.622
幫你解答
哪個代碼佔用的時間最多？

00:07:36.590 --> 00:07:39.059
它在運行程序中的取樣
以每毫秒爲單位

00:07:39.126 --> 00:07:40.594
並且短暫地
停頓執行

00:07:40.661 --> 00:07:43.130
並快照
所有正在運行的代碼

00:07:44.598 --> 00:07:45.966
它還可以取樣

00:07:46.033 --> 00:07:48.936
在代碼運行於
JIT編譯器所有四級的時候

00:07:49.002 --> 00:07:52.039
所以它的取樣速度
跟你代碼的實際速度差不多

00:07:52.873 --> 00:07:56.443
由於斷點處理
會導致代碼去優化

00:07:56.510 --> 00:07:57.978
我們暫時不管它們

00:07:58.545 --> 00:08:02.583
那麼當你分析的時候
你就可以瞭解網頁應用的真實性能

00:08:03.050 --> 00:08:06.854
使用樣本分析器
對性能幾乎沒有損害

00:08:07.120 --> 00:08:10.157
這就意味着
當你分析代碼的時候

00:08:10.657 --> 00:08:13.560
速度高達以前的30倍

00:08:14.361 --> 00:08:17.931
這就讓代碼分析過程
更快也更簡單

00:08:17.998 --> 00:08:20.434
而且收到的數據
也更準確

00:08:21.869 --> 00:08:25.939
這個進步真令人振奮 因爲我們團隊
和網絡檢查器團隊

00:08:26.006 --> 00:08:29.610
能利用它來發現
可以提升速度的地方

00:08:29.676 --> 00:08:31.044
就在網絡檢查器本身

00:08:32.412 --> 00:08:34.515
好了
現在我們有了樣本分析器

00:08:34.581 --> 00:08:37.618
看看如何利用網絡檢查器
幫我們找到問題

00:08:38.519 --> 00:08:41.688
這個內容很多
但是可以簡單的拆分開來

00:08:41.788 --> 00:08:43.991
更方便的是
這都是你已經熟悉的代碼

00:08:44.958 --> 00:08:47.160
當我們說到
分析JavaScript時

00:08:47.227 --> 00:08:50.597
意思是在Events裏
爲JavaScript記錄時間線

00:08:50.664 --> 00:08:52.399
這就是Events視圖

00:08:52.733 --> 00:08:56.270
顯示了一列單獨而且具體的
JavaScript事件

00:08:56.570 --> 00:09:00.073
特別的是
這裏都是D3庫的代碼

00:09:00.140 --> 00:09:02.910
所以它能更方便
調試代碼

00:09:02.976 --> 00:09:05.612
和分析代碼
在你正在使用的庫裏

00:09:06.346 --> 00:09:09.449
而且這裏的每一條
都是代碼運行的事件

00:09:09.716 --> 00:09:13.187
這是代碼進出
JavaScript核心引擎的情況

00:09:14.087 --> 00:09:15.856
包括了
監聽事件的回調

00:09:15.923 --> 00:09:19.193
比如動畫框架的條目
是在請求動畫框架處理器

00:09:20.160 --> 00:09:22.596
腳本評估條目
顯示JavaScript文件

00:09:22.663 --> 00:09:24.331
的上傳和首次評估

00:09:25.265 --> 00:09:27.234
這裏還有一些
時間信息

00:09:27.701 --> 00:09:30.971
告訴你運行的代碼
所花費的時間

00:09:32.039 --> 00:09:34.708
所以如果有哪個
超過了10或15毫秒

00:09:34.775 --> 00:09:36.343
你就快要打破

00:09:36.410 --> 00:09:38.812
60幀每秒的
流暢性能底線

00:09:40.647 --> 00:09:43.217
Events視圖很有用
但是還有另一個視圖

00:09:43.283 --> 00:09:46.119
是我們爲你添加的
叫做Call Trees視圖

00:09:46.553 --> 00:09:49.790
如果你用過其他分析工具
那麼對這個應該很熟悉

00:09:51.225 --> 00:09:54.161
只要點擊這個菜單
然後轉換到Call Trees視圖

00:09:55.429 --> 00:09:59.399
現在顯示了調用堆棧裏
函數的累計運行時間

00:10:00.133 --> 00:10:01.768
這個叫做Top Down視圖

00:10:01.835 --> 00:10:04.137
你可以用它
深入發掘Call Tree

00:10:04.204 --> 00:10:06.707
來找到
耗費大量時間的熱函數

00:10:07.774 --> 00:10:10.177
但我最喜歡的視圖是
Bottom Up視圖

00:10:12.513 --> 00:10:14.448
它能直接讓我找到
最熱的函數

00:10:14.515 --> 00:10:16.650
就是取樣最頻繁的函數

00:10:17.551 --> 00:10:19.319
這裏羅列的
是調出的函數

00:10:19.386 --> 00:10:21.622
按照用時
從大到小分類

00:10:21.688 --> 00:10:26.593
它反轉了Call Tree
讓你能直接對比各個函數的耗時

00:10:27.861 --> 00:10:30.731
你能準確地看到
耗時最多的地方

00:10:32.332 --> 00:10:35.169
你可以展開這一條
並按照路徑返回

00:10:35.235 --> 00:10:36.837
找到耗時最多的函數

00:10:37.471 --> 00:10:41.108
你就能知道這個成本最高的代碼
是何時何地調出的

00:10:42.809 --> 00:10:45.312
那麼關於這部分
有請我的同事

00:10:45.379 --> 00:10:46.980
Brian Burg
上臺爲大家展示

00:10:55.155 --> 00:10:57.858
謝謝你 Jon
樣本分析器很好用

00:10:57.925 --> 00:11:00.494
因爲它可以提取
十分複雜的內容

00:11:00.561 --> 00:11:03.564
並進行分析
讓你看到十分精確的信息

00:11:03.630 --> 00:11:05.132
而且你可以讓它
跑的更快

00:11:05.832 --> 00:11:09.469
爲了給你們展示
我要用我製作的iPad應用

00:11:09.770 --> 00:11:12.139
叫做衛星跟蹤器
在這裏看看

00:11:15.676 --> 00:11:19.680
衛星跟蹤器
會展示給你現在或任何時間

00:11:20.080 --> 00:11:21.615
衛星所在的位置

00:11:21.882 --> 00:11:24.618
你可以選擇
地球上的不同地點

00:11:25.219 --> 00:11:26.787
也可以選擇不同的衛星

00:11:28.222 --> 00:11:29.223
不同的時區

00:11:30.023 --> 00:11:30.858
這很棒吧

00:11:31.725 --> 00:11:33.460
如果你擔心
頭上盤旋的衛星

00:11:33.527 --> 00:11:36.330
要帶個錫紙帽子以防萬一
這個應用就是理想之選

00:11:37.064 --> 00:11:39.633
但是這裏有個小問題

00:11:39.700 --> 00:11:44.071
如果很多衛星
或者很多衛星組件

00:11:44.137 --> 00:11:47.207
像這樣擠爆了
那麼幀率的波動會很大

00:11:47.674 --> 00:11:49.676
這肯定不是
60幀每秒

00:11:49.743 --> 00:11:50.878
它會一直波動

00:11:51.411 --> 00:11:53.981
這樣就可以用
樣本分析器來查找

00:11:54.047 --> 00:11:55.849
發生了什麼
爲什麼這麼慢

00:11:57.751 --> 00:12:03.257
我們要做的就是打開Safari
並進入Develop菜單

00:12:03.957 --> 00:12:06.026
找到這裏的iPad
並連接上

00:12:07.594 --> 00:12:11.098
那麼我要做的第一件事
就是進入Frames視圖

00:12:11.164 --> 00:12:14.001
看看現在的位置
幀率如何

00:12:14.067 --> 00:12:16.069
那麼開始記錄

00:12:17.137 --> 00:12:18.572
我再轉回iPad

00:12:19.373 --> 00:12:20.774
做點什麼

00:12:22.876 --> 00:12:24.244
比如轉動一下

00:12:25.746 --> 00:12:27.514
或者換一個衛星

00:12:29.383 --> 00:12:30.250
換個時區

00:12:30.884 --> 00:12:32.219
好了
現在回去看看

00:12:35.489 --> 00:12:36.723
好的
把這個縮小

00:12:37.424 --> 00:12:40.227
所有的性能
就都顯示在這裏了

00:12:40.294 --> 00:12:44.865
有的時候是60幀每秒
像左邊這些

00:12:45.299 --> 00:12:47.367
在中間
則上下都有

00:12:47.434 --> 00:12:48.802
因爲我們在
更改視圖

00:12:49.136 --> 00:12:51.972
這一些
就太慢了

00:12:52.940 --> 00:12:55.042
我想知道
出了什麼問題

00:12:56.710 --> 00:12:58.879
那麼我就轉到
Events視圖

00:13:00.981 --> 00:13:03.283
點擊JavaScript
和Events時間線

00:13:03.350 --> 00:13:06.019
重點看看
樣本分析器的數據

00:13:07.955 --> 00:13:10.691
就像Jon之前演示的那樣
這裏的Events視圖

00:13:10.757 --> 00:13:12.926
會顯示所有
運行循環裏的內容

00:13:12.993 --> 00:13:16.096
這個例子裏
就是動畫和模擬

00:13:16.163 --> 00:13:18.398
就是我們在
不斷地渲染幀

00:13:18.465 --> 00:13:22.769
這不是很有用
因爲無法找到耗時最多的地方

00:13:23.537 --> 00:13:25.939
那麼我們轉到
Call Trees視圖

00:13:27.574 --> 00:13:30.844
這裏我們看到Top Down
Call Tree

00:13:31.211 --> 00:13:35.849
集合顯示了
所有的渲染幀

00:13:35.916 --> 00:13:37.484
都是最耗時的地方

00:13:38.352 --> 00:13:42.356
展開這個就能看到
D3有一個Timer函數

00:13:42.422 --> 00:13:45.893
它調出一些代碼
畫了一些場景

00:13:46.960 --> 00:13:49.863
這些場景包括
衛星

00:13:49.930 --> 00:13:52.099
和時間等

00:13:52.165 --> 00:13:56.303
這個很棒
能讓我們瞭解代碼在做什麼

00:13:56.670 --> 00:13:59.373
但是如果要想找出
哪個函數最耗費

00:14:00.073 --> 00:14:02.376
最好還是去看
Bottom Up視圖

00:14:04.044 --> 00:14:09.316
這裏我們列出了所有函數
無論誰調用它們

00:14:09.917 --> 00:14:12.686
我們看到這個fillText

00:14:12.753 --> 00:14:15.322
和tangent
是最耗費的兩個

00:14:15.422 --> 00:14:18.559
那爲什麼
會調出tangent呢？

00:14:18.792 --> 00:14:23.630
我們展開這一行
看看調令來源

00:14:23.830 --> 00:14:28.202
就在這裏
是_plotSatellites

00:14:28.435 --> 00:14:33.273
好像正在計算轉換
用來繪製地球

00:14:34.041 --> 00:14:35.876
好的
這些看着都很正常

00:14:36.443 --> 00:14:39.079
也許我該找出數學課本
讓它算得快一點

00:14:40.314 --> 00:14:41.682
現在看看
fillText

00:14:41.748 --> 00:14:45.652
換個畫面
回到這裏的應用

00:14:46.320 --> 00:14:51.458
我們正在當前時間上繪製文本
也在每個數據點上繪製

00:14:52.492 --> 00:14:53.460
這說得通

00:14:53.527 --> 00:14:57.898
但是如果仔細看
我們實際上把這個時間畫了兩次

00:14:58.699 --> 00:15:00.000
這就有點奇怪

00:15:00.767 --> 00:15:03.403
所以我們展開這一行

00:15:04.238 --> 00:15:06.707
就能看到
調令來自哪裏

00:15:07.975 --> 00:15:11.245
這裏我們好像
一次畫了兩個不同的前景

00:15:11.778 --> 00:15:14.114
這大概
不是我們想要的

00:15:15.516 --> 00:15:17.284
那麼來找找
哪兒出了問題

00:15:17.417 --> 00:15:20.120
如果像這樣
畫了兩個前景

00:15:20.220 --> 00:15:23.290
那麼我們的工作量
實際就是所需的兩倍

00:15:24.858 --> 00:15:28.729
爲了讓你的記憶更清晰
記住我們有個平面地圖

00:15:28.795 --> 00:15:31.431
然後有這個地球
它在轉動

00:15:32.833 --> 00:15:36.303
那麼
現在回到代碼

00:15:37.771 --> 00:15:41.942
找一找是什麼
控制着兩個地圖的切換

00:15:42.009 --> 00:15:43.010
估計哪裏弄錯了

00:15:46.513 --> 00:15:49.783
改變地點的時候
我們會讓兩個地球互換

00:15:51.051 --> 00:15:52.252
這是 updateLocation

00:15:52.819 --> 00:15:57.191
好的 因爲已經有一個地圖
就不再需要另一個

00:15:57.291 --> 00:16:00.494
這是有道理的
因爲這裏我們添加了隱藏類

00:16:00.561 --> 00:16:02.863
就爲了不讓它
顯示出來

00:16:04.298 --> 00:16:07.701
這裏在_globeMap
我們定義running值爲真

00:16:07.768 --> 00:16:09.236
在整個運行中

00:16:09.603 --> 00:16:12.506
而且在place中聲明
我們顯示的不是_globeProjection

00:16:12.573 --> 00:16:13.407
這是對的

00:16:13.473 --> 00:16:15.042
當我們顯示
平面地圖

00:16:15.108 --> 00:16:17.144
我們不會顯示地球
它也不會運行

00:16:18.178 --> 00:16:20.280
這個平面地圖
看上去好像

00:16:20.347 --> 00:16:22.382
一直在運行
UI也在運行

00:16:22.516 --> 00:16:26.086
這也挺奇怪的

00:16:26.486 --> 00:16:28.655
那麼我們回到地圖
試着做點兒什麼

00:16:32.192 --> 00:16:34.628
這裏我們選擇
這個數據組

00:16:35.762 --> 00:16:37.431
然後進入Earth

00:16:38.465 --> 00:16:43.237
它的幀率要好於
只做世界地圖

00:16:43.303 --> 00:16:44.505
那麼
這就很有道理

00:16:44.571 --> 00:16:47.574
我想我們在世界地圖活動的時候
畫了兩張地圖

00:16:47.641 --> 00:16:49.443
但是在平面地圖的時候
只畫了一個

00:16:49.510 --> 00:16:53.914
那麼我們就在這裏
改變這個條件

00:16:59.786 --> 00:17:01.288
糟糕
應該反過來

00:17:04.558 --> 00:17:08.996
好的 先停下
看看有沒有修復

00:17:12.598 --> 00:17:14.001
回到iPad

00:17:15.502 --> 00:17:16.737
好的
這看上去很流暢

00:17:16.803 --> 00:17:17.671
來到這裏

00:17:19.006 --> 00:17:19.839
恩 很好

00:17:22.041 --> 00:17:22.910
看上去不錯

00:17:22.976 --> 00:17:25.913
那麼我們再去檢查
時間渲染

00:17:25.979 --> 00:17:29.249
看看是不是
60幀每秒

00:17:30.684 --> 00:17:32.386
那麼
回到Frames視圖

00:17:33.053 --> 00:17:37.024
然後開始記錄
很不錯

00:17:37.090 --> 00:17:40.160
我轉動地球的時候
有點慢

00:17:40.227 --> 00:17:42.496
但穩定度
看上去...

00:17:42.563 --> 00:17:45.299
不錯
絕對在60幀每秒以下

00:17:45.832 --> 00:17:49.736
在這裏有一個條
只要低於它就是好的

00:17:52.940 --> 00:17:56.610
現在衛星跟蹤器
快了很多

00:17:56.677 --> 00:17:58.779
我們就知道
什麼時候帶上帽子

00:17:58.946 --> 00:17:59.780
這很棒

00:18:00.247 --> 00:18:04.017
這就是個簡單的例子
關於如何使用樣本分析器

00:18:04.084 --> 00:18:07.788
來發現最繁忙的內容
並讓它運行的更快

00:18:08.689 --> 00:18:12.893
下面Jon會跟大家講講
內存和分配

00:18:21.802 --> 00:18:22.636
謝謝 Brian

00:18:24.371 --> 00:18:27.074
你看到了
分析很迅速

00:18:27.274 --> 00:18:29.443
它能讓你瞭解
代碼的真實速度

00:18:29.510 --> 00:18:31.311
這樣你就能
獲得十分精確的數據

00:18:31.678 --> 00:18:34.448
再看看JavaScript
和Events時間線

00:18:34.948 --> 00:18:37.918
並用它們找到
緩慢的回調處理器和定時器

00:18:37.985 --> 00:18:40.454
或者在Events視圖裏
緩慢的腳本初始化

00:18:41.822 --> 00:18:44.157
請用新的Call Trees視圖
來瞭解耗時

00:18:44.224 --> 00:18:47.227
因爲它們會沿着
你選擇的時間線堆積起來

00:18:48.228 --> 00:18:50.464
記着Bottom Up
是你的新朋友

00:18:50.531 --> 00:18:54.201
它能幫助你找到
最需要優化的地方

00:18:55.869 --> 00:18:58.071
那麼現在我們已經看過了
新的樣本分析器

00:18:58.138 --> 00:19:00.574
和新的JavaScript
Call Trees視圖

00:19:00.908 --> 00:19:04.611
我很激動能用更好的工具
來優化CPU時間

00:19:04.678 --> 00:19:06.513
這樣就能給用戶
快速的體驗

00:19:06.580 --> 00:19:08.282
並幫他們
節省了電池

00:19:08.782 --> 00:19:10.551
這真的不錯
現在我們繼續

00:19:10.617 --> 00:19:12.219
看看性能的另一方面

00:19:12.586 --> 00:19:14.254
就是了解
內存都去哪兒了

00:19:15.189 --> 00:19:17.858
你肯定想更有效率地使用
網頁內容的內存

00:19:17.925 --> 00:19:19.526
因爲這是有限資源

00:19:19.960 --> 00:19:24.731
有效地使用內存可以
優化網頁內容的比例

00:19:24.798 --> 00:19:26.600
並能處理
大型數據組

00:19:28.335 --> 00:19:32.472
而且內存佔用過多會降低性能
我們並不想這樣

00:19:33.273 --> 00:19:35.175
它也會讓
你的網頁內容崩潰

00:19:35.242 --> 00:19:36.777
這更非我們所願

00:19:37.311 --> 00:19:41.682
好消息是若你運行WKWebView
它會以單獨的進程運行

00:19:41.982 --> 00:19:43.450
不會讓
整個應用崩潰

00:19:43.517 --> 00:19:45.752
但是這仍然不是
一個好的用戶體驗

00:19:46.286 --> 00:19:48.755
爲了幫你解決這些問題
我們添加了兩個新時間線

00:19:48.822 --> 00:19:50.557
給網絡檢查器
和Safari 10

00:19:51.859 --> 00:19:55.295
當啓動新網絡檢查器
新時間線就默認關閉

00:19:55.362 --> 00:19:56.730
所以要打開它們

00:19:56.797 --> 00:19:59.633
你只要點擊Edit
就在時間線上面

00:20:01.134 --> 00:20:03.704
就可以配置
自己想看的時間線

00:20:03.770 --> 00:20:06.673
這樣就可以只研究
自己想用的那個

00:20:06.740 --> 00:20:08.342
就和Instruments應用一樣

00:20:09.543 --> 00:20:12.946
只要開啓新的時間線
就可以記錄新的時間線了

00:20:13.280 --> 00:20:15.983
但你可能不想
讓它們同時運行

00:20:16.550 --> 00:20:19.386
JavaScript和
Events時間線樣本分析器

00:20:19.453 --> 00:20:21.188
雖然負載較少
但還是有

00:20:21.722 --> 00:20:24.491
而JavaScript Allocation
的時間線會添加更多進程

00:20:24.558 --> 00:20:27.761
在垃圾回收過程中
這會影響性能

00:20:28.428 --> 00:20:31.965
那我們就一直開着
Memory時間線

00:20:32.032 --> 00:20:35.002
那麼在記錄一個時間線的時候
你會看到這個

00:20:35.936 --> 00:20:39.907
這個新的Memory時間線圖表
顯示了內存如何分配

00:20:39.973 --> 00:20:42.342
到不同的目錄裏
在不同的時間

00:20:43.076 --> 00:20:44.878
這裏有一系列圖表

00:20:44.945 --> 00:20:48.515
幫你瞭解
內存的使用和劃分

00:20:49.750 --> 00:20:52.319
Breakdown表顯示了
內存如何分配給

00:20:52.386 --> 00:20:56.356
JavaScript和圖畫
和構成頁面的分層

00:20:56.423 --> 00:20:58.825
以及其他
引擎相關的網頁

00:21:00.060 --> 00:21:03.463
Max Comparison圖
幫你研究內存高峯

00:21:03.530 --> 00:21:04.831
這裏有一個高的水印

00:21:04.898 --> 00:21:07.401
幫你觀察
過去的內存問題

00:21:07.467 --> 00:21:10.437
你甚至可以分離各個峯
通過選擇一個特定的部分

00:21:10.504 --> 00:21:14.041
或者在一個峯值周圍
選擇一個特定的時間段

00:21:14.541 --> 00:21:17.945
然後你就可以使用
下面的目錄分類

00:21:18.011 --> 00:21:20.180
來看看是什麼
造成了大部分高峯

00:21:20.781 --> 00:21:23.784
這裏的每個圖表
都是獨立測量的

00:21:23.851 --> 00:21:26.653
所以你可以清楚地看到
不同時間的變化

00:21:28.021 --> 00:21:30.591
JavaScript裏的峯值
顯示的是

00:21:30.657 --> 00:21:33.527
大量新對象
被創建和引用的地方

00:21:33.660 --> 00:21:36.763
其中包括的對象
有字符串對象和函數

00:21:37.164 --> 00:21:41.201
以及所有支持它們的引擎數據
比如結構數據和編譯代碼

00:21:41.902 --> 00:21:44.605
當你看到
JavaScript的用量下降

00:21:44.671 --> 00:21:47.241
就是說垃圾回收
在回收內存

00:21:48.308 --> 00:21:50.811
圖片顯示了
分配給圖片的內存

00:21:50.878 --> 00:21:52.713
這些圖片都
通過解碼顯示

00:21:52.980 --> 00:21:54.815
這裏的圖片數據
比較大

00:21:54.882 --> 00:21:57.551
通常用於
可以在視口顯示的圖片

00:21:59.052 --> 00:22:01.722
層顯示的是
圖層內存

00:22:01.788 --> 00:22:04.858
分配在WebKits
tileGrid複合層

00:22:04.925 --> 00:22:06.093
和其他引擎層

00:22:07.227 --> 00:22:08.896
頁面就囊括了
所有其他的東西

00:22:08.962 --> 00:22:10.931
引擎所追蹤的
所有內容

00:22:10.998 --> 00:22:14.234
比如DOM和頁面風格
以及字體渲染數據

00:22:14.301 --> 00:22:16.470
內存緩存和系統分配

00:22:17.271 --> 00:22:19.306
所以這個分類
能讓你很好的保證

00:22:19.373 --> 00:22:22.242
內存用量
符合你的預期

00:22:22.943 --> 00:22:26.446
若你有很多JavaScript內容
你要明白

00:22:26.513 --> 00:22:30.150
JavaScript會是分類圖表裏
用量最多的一類

00:22:30.217 --> 00:22:33.086
在時間線圖表裏
你可能會隨着時間看到更多變化

00:22:33.954 --> 00:22:38.125
但是對於多圖片的頁面
比如畫廊

00:22:38.192 --> 00:22:41.428
那麼分層和圖片目錄
就可能是最大的

00:22:41.495 --> 00:22:42.896
隨着時間
變化也更多

00:22:43.830 --> 00:22:47.501
這就是Safari 10裏
最新的Memory時間線

00:22:49.203 --> 00:22:53.540
Memory時間線的補充就是
新的JavaScript Allocations時間線

00:22:54.074 --> 00:22:56.343
你不僅能看到
不同時間裏內存的變化

00:22:56.510 --> 00:22:58.111
還能更細的探究

00:22:58.178 --> 00:23:00.781
JavaScript Allocations
的真實情況

00:23:00.948 --> 00:23:06.553
對此我們有個強大的工具
JavaScript Allocation Snapshots

00:23:07.321 --> 00:23:08.889
快照的強大之處

00:23:08.956 --> 00:23:12.426
是你可在JavaScripts堆裏
對一個時刻進行快照

00:23:12.726 --> 00:23:15.696
然後你就可以深入看到
所有被分配的東西

00:23:16.129 --> 00:23:18.765
但是更強大的是
你有兩個快照的時候

00:23:19.466 --> 00:23:22.436
你就可以回頭再看
並進行對比

00:23:22.503 --> 00:23:25.639
對比快照
是我們最強大的工具之一

00:23:25.706 --> 00:23:29.243
它可以解答
我是不是做了不必要的分配？

00:23:30.110 --> 00:23:32.579
一定要利用它
因爲你需要多個快照

00:23:32.646 --> 00:23:36.783
這也就是爲什麼
默認每10秒照一次

00:23:37.217 --> 00:23:39.753
不僅要在記錄開始
還要在結束

00:23:40.153 --> 00:23:42.923
快照是在時間線上設計的
所以它們能連到

00:23:42.990 --> 00:23:44.825
其他時間線上
發生的事情

00:23:44.892 --> 00:23:46.894
在這裏
其他的都被我關了

00:23:48.128 --> 00:23:50.330
這些快照在下面列出
並附了一些細節

00:23:50.397 --> 00:23:51.899
比如堆的
時間和大小

00:23:52.766 --> 00:23:54.501
要了解一個特定的問題

00:23:54.568 --> 00:23:56.870
就通常需要
在開始和結束的時候快照

00:23:56.937 --> 00:23:58.739
圍繞你認爲
內存會出問題的地方

00:23:59.173 --> 00:24:00.541
這裏有三個技巧

00:24:01.074 --> 00:24:03.710
你可以依賴自動快照
每10秒一次

00:24:04.478 --> 00:24:07.247
或者可以親自快照
就按快照鍵

00:24:08.282 --> 00:24:09.750
或者用代碼執行

00:24:10.551 --> 00:24:14.254
最簡單的找到問題的方法
還是改代碼

00:24:14.555 --> 00:24:16.623
調出
takeHeapSnapshot API

00:24:16.690 --> 00:24:19.526
傳遞一個自定義的標籤參數
它可以是任何

00:24:19.593 --> 00:24:21.261
之後能幫你識別它的東西

00:24:21.695 --> 00:24:24.198
還有你要做
一對快照

00:24:24.264 --> 00:24:27.100
在你認爲導致問題的代碼
的前後

00:24:28.035 --> 00:24:30.537
你還可以通過快照
來使用這個代碼

00:24:30.604 --> 00:24:32.940
在一個循環內的
工作之間

00:24:33.340 --> 00:24:34.308
分析內存

00:24:34.374 --> 00:24:38.846
下面講講要時刻牢記的幾點
關於takeHeapSnapshot API

00:24:39.179 --> 00:24:43.050
要記住快照會增添一些額外的進程
在垃圾回收進程中

00:24:43.116 --> 00:24:45.552
這會影響性能
所以你一定要注意

00:24:45.619 --> 00:24:48.088
你的代碼是否
頻繁的發射快照

00:24:49.189 --> 00:24:52.726
你也要捕捉到
前後不同的信息

00:24:52.793 --> 00:24:55.462
當代碼在一個循環之間的
某個時刻運行時

00:24:56.630 --> 00:24:57.698
不要留下這個

00:24:57.764 --> 00:25:00.734
如果你把它留下
對大部分用戶來說沒問題

00:25:00.801 --> 00:25:04.204
但一旦有人運行網絡檢查器
它們就會使用所有的快照

00:25:04.271 --> 00:25:05.506
你大概也不想這樣

00:25:05.572 --> 00:25:08.876
所以要記住
在啓動前一定把它們刪除

00:25:09.776 --> 00:25:11.411
那麼這些快照
都顯示了什麼？

00:25:13.146 --> 00:25:14.181
讓我們來看一看

00:25:14.848 --> 00:25:18.619
你只要點擊時間線上的
快照圖標

00:25:18.685 --> 00:25:21.555
或者在快照列表條目裏
點擊Arrow按鍵

00:25:22.422 --> 00:25:25.225
你看到的這一列對象
都是之前分配在堆裏的

00:25:25.292 --> 00:25:27.294
快照有兩個視圖

00:25:27.694 --> 00:25:29.129
這是Instances視圖

00:25:29.196 --> 00:25:33.033
展示了堆裏的對象列表
按照類來分組

00:25:33.634 --> 00:25:35.736
另一個是
對象圖像視圖

00:25:35.802 --> 00:25:37.871
這實際上
概括了所有東西

00:25:37.938 --> 00:25:40.073
所有的所有

00:25:40.507 --> 00:25:42.109
如果你很熟悉這個代碼

00:25:42.176 --> 00:25:45.946
它就能很好地幫助你
確認事情或者找到相應的位置

00:25:46.947 --> 00:25:49.183
但是實際上
更有用的視圖

00:25:49.249 --> 00:25:51.785
是在Instances視圖裏

00:25:51.852 --> 00:25:54.221
它的強大在於
你可以輕鬆地找到對象

00:25:54.288 --> 00:25:57.057
不論他們在屬性路徑裏
藏得多深

00:25:57.958 --> 00:26:00.494
這裏的Count可以幫你
意識到潛在的問題

00:26:00.561 --> 00:26:02.162
就是它們
無法達到預期的時候

00:26:02.229 --> 00:26:05.199
比如我能否實現
4000多個字符串對象？

00:26:06.733 --> 00:26:10.470
你可以展開這個Classes
來看看所有分配到這裏的對象

00:26:11.238 --> 00:26:14.942
然後判斷什麼是什麼
通過這麼多不同的線索

00:26:15.008 --> 00:26:16.076
Class是一線索

00:26:16.944 --> 00:26:19.379
另外就是
對象的實際屬性

00:26:19.713 --> 00:26:21.648
這能讓我們很快了解
什麼是什麼

00:26:22.516 --> 00:26:24.785
但是最簡單的
瞭解對象的方法

00:26:24.852 --> 00:26:29.323
就是懸停在這個對象識別器上
你就會看到這個

00:26:30.924 --> 00:26:34.795
這裏實際上顯示的是
到對象的最短路徑

00:26:35.362 --> 00:26:38.098
它告訴了你究竟是什麼
讓這個對象保持活動

00:26:38.732 --> 00:26:40.868
它基本上總會給你
你需要的答案

00:26:41.768 --> 00:26:45.572
特別是在JavaScript的
垃圾回收裏

00:26:45.639 --> 00:26:48.509
這就是能
立刻解開疑惑的方法

00:26:49.643 --> 00:26:53.013
但是它最重要的功能
和最關鍵的要點

00:26:53.080 --> 00:26:55.048
在於它能
比較兩個快照

00:26:55.349 --> 00:26:57.551
看看這個
當你已經收集了一些快照

00:26:58.218 --> 00:27:00.521
只要點擊此處“比較快照”按鍵

00:27:01.321 --> 00:27:04.992
然後選擇Baseline快照
再選一個對比

00:27:05.792 --> 00:27:06.627
一下子

00:27:07.027 --> 00:27:09.263
你就有了一個
新的對比快照可以研究

00:27:09.796 --> 00:27:11.131
這個十分有意義

00:27:11.498 --> 00:27:13.467
因爲現在只能看到
新的對象

00:27:13.534 --> 00:27:16.637
在兩個點之間
在兩個快照之間

00:27:18.172 --> 00:27:21.475
展開對象類分組
可以看到所有的對象分配

00:27:21.542 --> 00:27:24.945
預覽中顯示了它們的名字
和類似遙測數據的東西

00:27:25.646 --> 00:27:27.848
這裏就說明
它是衛星對象

00:27:28.348 --> 00:27:31.151
這裏的彈窗顯示
_Satellites Array屬性

00:27:32.319 --> 00:27:34.054
由於這是
一個快照對比

00:27:34.121 --> 00:27:36.857
衛星的對象
都是新分配的

00:27:36.924 --> 00:27:39.359
這是個很重要的線索
顯示代碼在做什麼

00:27:39.893 --> 00:27:42.296
那麼爲了讓你們實際看到
這些新的存儲功能

00:27:42.362 --> 00:27:44.798
我要有請Brian回到臺上
來做另一個演示

00:27:51.171 --> 00:27:52.005
謝謝 Jon

00:27:52.606 --> 00:27:55.742
我把衛星跟蹤器
給了我的朋友Ed

00:27:55.809 --> 00:27:58.545
他熬了一夜
在玩這個

00:28:00.113 --> 00:28:04.251
他很開心
因爲他從來沒有被衛星跟蹤過

00:28:04.351 --> 00:28:05.452
但是這就有個問題

00:28:05.519 --> 00:28:09.122
它運行時間越長
最終會變得越來越慢

00:28:09.790 --> 00:28:13.026
這在我看來
很像傳統的內存

00:28:13.093 --> 00:28:15.262
打開時間越久
就越慢

00:28:15.929 --> 00:28:20.601
我想在衛星跟蹤器裏
用這些新存儲工具來看看

00:28:20.667 --> 00:28:22.369
我們是否泄漏了
一些內存

00:28:23.637 --> 00:28:26.173
那麼第一件事

00:28:26.240 --> 00:28:28.575
我的iPad在這兒

00:28:29.309 --> 00:28:31.545
我要回到
網絡檢查器...

00:28:34.381 --> 00:28:35.782
並且檢查這個應用

00:28:36.717 --> 00:28:38.418
我要做的第一件事

00:28:39.286 --> 00:28:43.857
在我不知道問題在哪兒的時候
就是要使用Memory時間線

00:28:43.924 --> 00:28:48.595
它會告訴我
頁面上大概發生了什麼

00:28:48.662 --> 00:28:50.030
那麼我們開始記錄

00:28:51.131 --> 00:28:52.766
轉回來

00:28:52.833 --> 00:28:57.604
我在兩個衛星之間
來回切換

00:28:58.138 --> 00:29:00.741
也許我會在這裏
添加一些效果

00:29:02.142 --> 00:29:04.611
好的
我在來回切換

00:29:06.613 --> 00:29:08.048
好了
現在去時間線看看

00:29:11.351 --> 00:29:15.422
在時間線概覽中
你看到一個堆積線形圖

00:29:15.489 --> 00:29:17.624
顯示了所有不同的部分
和相關的大小

00:29:17.858 --> 00:29:21.128
如果你點擊這裏
會看到更多的細節

00:29:22.563 --> 00:29:24.831
那麼這個頁面上
沒有圖片

00:29:24.898 --> 00:29:25.766
都是畫布

00:29:26.400 --> 00:29:27.801
分層也很平面

00:29:28.268 --> 00:29:30.804
頁面有些波動
有些內容在垃圾回收

00:29:30.871 --> 00:29:31.705
沒有問題

00:29:32.306 --> 00:29:35.175
如果你仔細看看JavaScript
你會看到...

00:29:35.776 --> 00:29:37.444
雖然有些東西
被垃圾回收

00:29:37.511 --> 00:29:40.280
但是整體來說
它還是在隨着時間堆積

00:29:40.614 --> 00:29:44.318
如果我們運行一整晚
那估計會堆積更多

00:29:44.952 --> 00:29:51.358
下一步就是啓用heap快照
或allocation快照

00:29:51.425 --> 00:29:54.194
這樣我們就能找到
隨着時間而分配的內容

00:29:56.630 --> 00:30:00.667
爲了實現這個
我們要開始新的記錄

00:30:03.103 --> 00:30:06.139
這有個快捷鍵
Shift 點擊或Shift 空格

00:30:06.206 --> 00:30:08.942
這樣就會啓動新的記錄
而不是繼續之前那個

00:30:09.510 --> 00:30:11.778
等等
我忘了改時間線

00:30:11.845 --> 00:30:13.046
去掉Memory

00:30:14.314 --> 00:30:15.916
選上Allocations

00:30:18.252 --> 00:30:19.520
好了
開始記錄

00:30:20.387 --> 00:30:21.288
回到iPad

00:30:23.190 --> 00:30:25.759
添加了小小的
takeHeapSnapshot鍵

00:30:25.826 --> 00:30:29.229
我已給控制檯添加了
一些takeHeapSnapshot的調令

00:30:29.296 --> 00:30:32.633
用於切換兩個衛星小組
和其他操作

00:30:33.800 --> 00:30:38.038
對這個記錄
我要轉動地圖

00:30:38.105 --> 00:30:41.942
然後不斷在
兩個衛星中切換

00:30:46.580 --> 00:30:49.416
我們還要看看Spy Satellites
看上去也有關聯

00:30:52.419 --> 00:30:54.254
好了 你會發現
開始有點卡了

00:30:54.321 --> 00:30:57.591
因爲我們給JavaScript堆裏的
所有東西拍了快照

00:30:57.658 --> 00:31:00.060
因此
產生了很多對象

00:31:00.127 --> 00:31:01.795
這會大幅降低
應用的速度

00:31:01.862 --> 00:31:05.265
所以一定不要
拍很多快照

00:31:05.332 --> 00:31:08.435
只在重要的時候拍

00:31:08.802 --> 00:31:13.974
這裏你可以看到方塊裏的S
就是我們拍的快照

00:31:16.043 --> 00:31:18.812
放大一下能看到

00:31:18.879 --> 00:31:20.814
隨着時間過去
內存十分穩定的增長

00:31:20.881 --> 00:31:23.584
當我們開始在
兩個衛星之間切換的時候

00:31:26.753 --> 00:31:29.056
如果我們要研究這個
像Jon說的那樣

00:31:29.122 --> 00:31:35.829
我們就要啓動對比
來看看是什麼被攔住了

00:31:35.896 --> 00:31:40.167
那麼我們就對比
快照9和11

00:31:41.602 --> 00:31:45.072
立刻
我們就看到很多東西

00:31:45.138 --> 00:31:49.443
被分配在9和11之間
並且仍然在活動中

00:31:49.943 --> 00:31:52.412
這就清楚地說明瞭
它們被留存了

00:31:52.479 --> 00:31:54.648
雖然我們
並不想這麼做

00:31:55.649 --> 00:31:57.551
那麼我們來看看
這些都是什麼

00:31:58.752 --> 00:31:59.620
這是些陣列

00:32:00.454 --> 00:32:03.423
看上去這個陣列裏
全是座標

00:32:04.858 --> 00:32:07.728
你知道在應用的不同部分
我們會用大量的座標

00:32:07.794 --> 00:32:11.164
但是如果我們停在這裏
就會看到它的路徑

00:32:11.265 --> 00:32:14.701
它們好像是被保存於
trajectoryHistory

00:32:14.768 --> 00:32:18.572
這是我們用來製作
追蹤衛星的東西

00:32:19.973 --> 00:32:21.375
好的
這樣不錯

00:32:21.441 --> 00:32:23.710
但是我想不應該

00:32:25.112 --> 00:32:27.714
再在已不顯示的衛星裏用
trajectoryHistory

00:32:27.781 --> 00:32:29.416
這好像是個bug

00:32:31.985 --> 00:32:33.620
我們也分配了
一些對象

00:32:35.055 --> 00:32:39.526
但奇怪的是
在快照9和11之間

00:32:39.593 --> 00:32:41.795
我們之前已經看到
這些衛星

00:32:41.862 --> 00:32:45.065
那麼我就不想
再給每個衛星創建新的對象

00:32:45.132 --> 00:32:48.735
我們只要直接使用它們
只要我們已經爲他們獲取了資源

00:32:48.802 --> 00:32:53.140
然後這裏有了很多
座標和遙測

00:32:53.207 --> 00:32:56.476
好像正在
重新解析什麼

00:32:58.045 --> 00:32:59.646
我不太確定
那麼...

00:33:00.113 --> 00:33:03.851
在這個視圖裏
我們有很多對象

00:33:03.917 --> 00:33:05.085
你不能讀取所有

00:33:05.152 --> 00:33:08.355
所以我想做的
就是找出很特別的那一個

00:33:08.856 --> 00:33:10.357
那麼在這個快照裏

00:33:11.825 --> 00:33:13.861
我們有很多字符串
陣列和對象

00:33:13.927 --> 00:33:15.395
但只有一個Promise

00:33:15.829 --> 00:33:17.831
它停留在
兩個快照之間

00:33:17.898 --> 00:33:19.900
所以我認爲
應該調試這個

00:33:19.967 --> 00:33:24.071
那麼我就找到代碼
看看是哪裏在用Promises

00:33:24.371 --> 00:33:27.274
因爲好像它與別的什麼
一起被泄露了

00:33:27.441 --> 00:33:29.576
於是
搜索Promise

00:33:30.077 --> 00:33:34.882
好了 這是D3庫
這是使用它的代碼

00:33:37.251 --> 00:33:39.052
好的
來看看這個

00:33:39.887 --> 00:33:44.892
好了 在［聽不清］裏
我們常常在衛星之間切換

00:33:44.958 --> 00:33:46.593
代碼是loadDataset

00:33:46.793 --> 00:33:50.631
有人寫了評論
太好了

00:33:51.665 --> 00:33:56.103
這裏看上去好像
有人請求我們改變衛星

00:33:57.271 --> 00:34:03.710
那麼這裏就可以
異步從URL下載數據

00:34:03.777 --> 00:34:06.046
當它返回
我們就要解析

00:34:07.414 --> 00:34:10.918
然後使用衛星繪圖庫 
做更多的解析

00:34:11.784 --> 00:34:13.887
然後我們把它存到
衛星列表上

00:34:15.389 --> 00:34:18.525
這都很不錯
但是回到檢查器

00:34:18.592 --> 00:34:20.527
我們好像每次都泄露該Promise

00:34:20.594 --> 00:34:22.929
如果你更仔細的想想

00:34:22.996 --> 00:34:25.732
如果切換到
已經下載的數據組會怎樣？

00:34:26.967 --> 00:34:29.235
我們甚至都沒有
檢查過這個事情

00:34:30.237 --> 00:34:33.373
你仔細的看看這裏

00:34:34.107 --> 00:34:36.577
每次在兩個衛星之間轉換

00:34:37.277 --> 00:34:38.812
我們就發出
一個新的網絡請求

00:34:38.879 --> 00:34:40.179
如果我們進入這個時間線

00:34:41.014 --> 00:34:44.618
就會看到我們在不斷請求
同樣的垃圾數據

00:34:46.018 --> 00:34:49.523
這是正常的
如果回到代碼 發出請求

00:34:49.590 --> 00:34:51.859
解析的時候
會產生大量的對象

00:34:52.492 --> 00:34:54.293
然後我們把它推入
衛星陣列

00:34:54.360 --> 00:34:56.697
就目前來看
它怎麼都不清楚

00:34:56.763 --> 00:35:02.202
我們好像一直在做無用功
然後不斷泄露

00:35:02.269 --> 00:35:04.838
所以這裏
我們要做的

00:35:04.905 --> 00:35:08.475
是檢查我們是否已經
解析了這個衛星對象

00:35:08.742 --> 00:35:10.043
因爲這是Promise

00:35:10.344 --> 00:35:14.081
如果它確實存在
我們可以調出.then

00:35:14.848 --> 00:35:18.886
由於這已解決
下一次評估Promise的反應時

00:35:18.952 --> 00:35:22.556
它就會進行檢查
並將衛星放到地圖上

00:35:23.657 --> 00:35:26.960
那麼在這裏
添加代碼

00:35:30.664 --> 00:35:33.734
如果不存在
我們就創建一個

00:35:42.242 --> 00:35:47.314
好了 現在停下來看看
有沒有效果

00:35:50.117 --> 00:35:52.352
我們就要回去
重新連接

00:35:55.923 --> 00:35:59.993
這是我們的應用
開始記錄吧

00:36:02.329 --> 00:36:05.132
當我們回到應用
我就打開快照

00:36:05.632 --> 00:36:06.700
打開一些效果

00:36:06.800 --> 00:36:10.237
然後往南走

00:36:10.804 --> 00:36:13.240
好的 間諜衛星

00:36:14.274 --> 00:36:16.777
衛星的科學實驗

00:36:17.811 --> 00:36:18.779
科學實驗

00:36:20.480 --> 00:36:21.315
好了

00:36:24.885 --> 00:36:28.455
如果我們回到這裏
我們看到內存的增長大大降低

00:36:28.522 --> 00:36:31.959
大概在1兆
而不是四五兆

00:36:32.025 --> 00:36:34.228
那麼這裏可能有
更多的泄露

00:36:34.294 --> 00:36:38.665
但是在快照結束的時候
我們的內存

00:36:38.732 --> 00:36:41.168
跟剛開始渲染的時候
一樣大

00:36:41.235 --> 00:36:43.537
這樣我們就修復了
這個特殊的泄露

00:36:44.805 --> 00:36:49.710
這就展示了我們如何使用
Allocations和Memory時間線

00:36:49.776 --> 00:36:53.547
來解決像這樣的
應用的內存泄露問題

00:36:54.114 --> 00:36:58.585
這很不錯
因爲應用可以用更多的操作

00:36:58.652 --> 00:37:00.954
有了diffing功能

00:37:01.021 --> 00:37:04.825
我們就可以深入觀察
我們所關心的衛星裏的變化

00:37:06.660 --> 00:37:09.062
好了
衛星跟蹤器就講到這

00:37:10.197 --> 00:37:11.031
你回來吧 Jon

00:37:16.670 --> 00:37:17.504
謝謝 Brian

00:37:17.738 --> 00:37:21.241
你看到了
真是不可思議的迅速和簡單

00:37:21.308 --> 00:37:24.845
這些新的時間線
讓內存零問題

00:37:25.512 --> 00:37:27.748
所以請記住
Memory時間線是瞭解

00:37:27.814 --> 00:37:30.317
內存的使用情況
和造成內存高峯的原因

00:37:30.384 --> 00:37:32.119
這樣你就知道
該去哪裏找問題

00:37:33.020 --> 00:37:37.291
然後使用多個Heap快照
在JavaScript Allocations時間線裏

00:37:37.357 --> 00:37:39.826
以便單獨放大
造成內存增長的代碼

00:37:40.761 --> 00:37:43.363
還有不要忘了刪除
takeHeapSnapshot

00:37:43.430 --> 00:37:44.932
在代碼運行之前

00:37:46.066 --> 00:37:48.101
要記住性能所受的影響

00:37:48.168 --> 00:37:51.505
是JavaScript Allocations
時間線記錄時產生的

00:37:53.607 --> 00:37:56.577
那麼以上就是
新的時間線工具

00:37:56.643 --> 00:37:58.445
可用在Safari 10的
網絡檢查器上

00:37:58.979 --> 00:38:00.747
我想你一定會
愛上它們

00:38:01.982 --> 00:38:04.852
在結束之前
我還想再說幾點

00:38:05.586 --> 00:38:08.355
我要建議你們
重新考慮下WKWebView

00:38:08.422 --> 00:38:09.623
如果你還沒有換掉它

00:38:11.358 --> 00:38:13.493
在Safari設置裏
打開Develop菜單

00:38:13.560 --> 00:38:15.262
連接網絡檢查器
到你的應用

00:38:15.329 --> 00:38:17.631
然後開始利用
這些新功能

00:38:18.031 --> 00:38:21.468
節省大量時間
Bottom Up視圖和Call Trees用於

00:38:21.535 --> 00:38:23.504
找到最需要優化的地方

00:38:23.570 --> 00:38:26.974
Memory時間線可以
快速看到內存高峯的情況

00:38:27.140 --> 00:38:31.111
Heap快照可以
輕鬆查找和比較對象分配

00:38:32.379 --> 00:38:33.881
時刻關注
新功能的更新

00:38:33.947 --> 00:38:36.550
今年網絡檢查器
和WebKit有更多內容

00:38:36.617 --> 00:38:39.486
可以讓你利用
應用的網頁內容

00:38:39.620 --> 00:38:41.722
來創造絕佳的
應用內的用戶體驗

00:38:42.789 --> 00:38:45.225
除了Brian和我
今天爲你們展示的功能

00:38:45.292 --> 00:38:48.562
我們團隊過去一年也爲
網絡檢查器添加了很多內容

00:38:49.396 --> 00:38:53.500
Quick Open會讓你直接跳到
頁面加載的資源

00:38:53.867 --> 00:38:58.739
尾調用堆棧
現在可顯示調試器裏的尾調用優化函數

00:38:59.339 --> 00:39:02.809
初春的時候在OS 10系統下
我們引進了Safari 9.1

00:39:03.277 --> 00:39:05.245
並更新了
網絡檢查器

00:39:05.913 --> 00:39:09.416
它顯示了Elements標籤下
DOM Tree裏的Pseudo Elements

00:39:09.883 --> 00:39:12.319
這裏還有一個
新的視覺風格邊欄

00:39:13.787 --> 00:39:15.489
可能你還沒注意到

00:39:15.756 --> 00:39:17.991
網絡檢查器
是一個開發者工具

00:39:18.058 --> 00:39:20.527
作爲WebKit開源項目的一部分

00:39:21.962 --> 00:39:25.199
WebKit是網頁瀏覽器引擎
用來支持你的應用

00:39:25.265 --> 00:39:27.668
驅動WebViews
和JSContext

00:39:28.068 --> 00:39:30.137
當然它也是Safari
背後的動力

00:39:31.004 --> 00:39:34.508
在過去一年裏
我們爲WebKit添加了好多新功能

00:39:34.575 --> 00:39:36.910
我們對ES6
100％支持

00:39:37.678 --> 00:39:40.714
我們改進了對IndexedDB
Standard的支持

00:39:41.215 --> 00:39:45.219
還添加了Shadow DOM支持
WebDriver和CSS變量

00:39:45.619 --> 00:39:46.753
以及Picture Element

00:39:47.688 --> 00:39:50.224
所以真的是很多內容
而且作爲開源項目

00:39:50.290 --> 00:39:52.559
一旦有新的出現
你就能知道

00:39:53.060 --> 00:39:55.329
你們在座大部分人
肯定都想能利用它工作

00:39:55.395 --> 00:39:58.365
如果你們想
對這些內容作出改進

00:39:58.432 --> 00:39:59.433
完全有機會

00:39:59.499 --> 00:40:01.702
因爲WebKit
是開放資源

00:40:02.669 --> 00:40:05.906
你可在WebKit.org上
找到更多WebKit項目信息

00:40:05.973 --> 00:40:09.710
WebKit團隊及其背後的
工程師們會在博客上寫他們的開發工作

00:40:09.776 --> 00:40:11.778
實際上
我們現在有兩個博客

00:40:11.845 --> 00:40:14.648
關於Memory時間線
和樣本分析器

00:40:14.715 --> 00:40:15.716
就是今天講的內容

00:40:15.782 --> 00:40:18.151
所以如果你想了解更多
可以去那裏看看

00:40:18.552 --> 00:40:21.355
我們還有一個功能狀態頁
一目瞭然的列出了所有更新

00:40:21.421 --> 00:40:22.789
針對網頁標準進程

00:40:23.357 --> 00:40:26.260
這裏還有鏈接
可以下載WebKit夜間建構

00:40:26.727 --> 00:40:29.930
和最新的瀏覽器
Safari技術概覽

00:40:30.797 --> 00:40:34.201
每幾周更新一次
附帶更新的WebKit引擎

00:40:34.668 --> 00:40:37.871
所以你可以在WebKit上
嘗試這些新的實驗性功能

00:40:37.938 --> 00:40:39.606
它們每兩週改進一次

00:40:40.474 --> 00:40:44.411
我們團隊投入了大量精力給Safari
WebKit和網絡檢查器

00:40:44.478 --> 00:40:47.581
網絡檢查器團隊
可以使用這些新性能特性

00:40:47.648 --> 00:40:50.918
就像我們今天展示的那樣
去查詢問題並提高性能

00:40:50.984 --> 00:40:52.419
對網絡檢查器本身

00:40:52.619 --> 00:40:54.555
我已經迫不及待
想看看你們會做些什麼

00:40:54.855 --> 00:40:56.590
想了解更多信息
請觀看這個演講

00:40:56.657 --> 00:40:59.259
在developer.apple.com
下載幻燈片

00:41:00.093 --> 00:41:03.163
這周的前幾天有很多場相關演講

00:41:03.230 --> 00:41:04.831
過去幾年也有不少

00:41:05.098 --> 00:41:07.835
這些都能在
developer.apple.com上找到

00:41:08.769 --> 00:41:12.606
那麼代表Brian 我自己
和Safari與WebKit團隊

00:41:12.673 --> 00:41:15.442
感謝你們的到來
祝大家在接下來的WWDC中過得愉快