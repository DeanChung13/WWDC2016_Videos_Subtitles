00:00:19.887 --> 00:00:24.591 
Xcode下可視化調試工具

00:00:29.796 --> 00:00:30.864 
大家下午好

00:00:31.632 --> 00:00:34.201 
歡迎來到
“Xcode下可視化調試工具”演講

00:00:35.169 --> 00:00:38.172 
我是Chris
在Xcode調試工具UI小組工作

00:00:39.373 --> 00:00:43.210 
衆所周知 調試工具存在已久

00:00:44.611 --> 00:00:46.180 
就在不久以前

00:00:46.246 --> 00:00:48.715 
調試工具看上去還是這個樣子

00:00:51.418 --> 00:00:53.820 
此後不久 UI進行了改進

00:00:53.887 --> 00:00:56.757 
調試工具開始看上去像這個樣子

00:00:59.259 --> 00:01:00.661 
但是快進到今天

00:01:00.727 --> 00:01:03.530 
調試工具變得更加強大

00:01:03.597 --> 00:01:06.066 
同時也更容易操作

00:01:06.567 --> 00:01:09.736 
其中大部分要歸功於它變得更爲可視化

00:01:09.803 --> 00:01:12.940 
這幫助我們更爲快速
更爲直觀地解決問題

00:01:13.874 --> 00:01:16.076 
今天 我將和同事們一起講解

00:01:16.143 --> 00:01:18.979 
Xcode中最新的可視化調試工具

00:01:22.583 --> 00:01:24.284 
首先 快速概述一下講座的內容

00:01:25.219 --> 00:01:27.621 
我們將會講解Xcode的新功能

00:01:27.688 --> 00:01:31.625 
能報告工具發現的運行時問題

00:01:32.626 --> 00:01:35.229 
我們還將講解最新的增強功能

00:01:35.295 --> 00:01:37.197 
對Xcode的視圖調試工具所作的

00:01:37.264 --> 00:01:40.601 
以及如何把自動佈局調試
變得前所未有地簡單

00:01:41.735 --> 00:01:44.838 
我們還將講解一個新功能
可以可視化調試

00:01:44.905 --> 00:01:47.674 
就是狀態機 以及做出的增強

00:01:47.741 --> 00:01:51.812 
在FPS性能測量方面
從而更好幫助調試SpriteKit

00:01:51.879 --> 00:01:53.514 
以及SceneKit幀率問題

00:01:54.548 --> 00:01:58.151 
最後 將講解Xcode的一個新功能

00:01:58.218 --> 00:01:59.820 
可視化內存圖形調試工具

00:02:03.857 --> 00:02:05.926 
首先來看問題

00:02:08.862 --> 00:02:12.332 
我們都知道 編譯時發生的問題
比如編譯器警告 錯誤

00:02:12.399 --> 00:02:15.469 
和靜態分析問題 都已經得到了

00:02:15.536 --> 00:02:20.307 
Xcode用戶界面充分支持
和測試時發現的問題相同

00:02:21.408 --> 00:02:24.077 
然而 不能同理可證

00:02:24.144 --> 00:02:27.681 
調試和分析工具的擴展組件
發現的運行時問題

00:02:28.348 --> 00:02:32.452 
這些工具都已經被遺忘

00:02:32.519 --> 00:02:36.757 
最多會被用來在控制檯上記錄輸出結果

00:02:37.124 --> 00:02:38.292 
不是最好的體驗

00:02:38.792 --> 00:02:40.561 
我們認爲可以做得更好

00:02:42.396 --> 00:02:45.199  
在Xcode 8
我們引進了運行時問題

00:02:52.239 --> 00:02:55.943 
運行時問題
把工具在運行時發現的問題上升

00:02:56.543 --> 00:03:00.514 
和UI裏傳統編譯時問題同等地位

00:03:02.950 --> 00:03:05.619 
活動查看器會如此顯示

00:03:05.686 --> 00:03:09.523 
當發現任何運行時問題時
並報告問題數量

00:03:12.025 --> 00:03:15.095 
我們增強了問題瀏覽器
包含新的運行時範圍

00:03:15.362 --> 00:03:17.664 
這區分了運行時問題

00:03:17.731 --> 00:03:19.499 
和傳統的編譯時問題

00:03:19.566 --> 00:03:22.636 
比如編譯器警告 錯誤和靜態分析問題

00:03:26.440 --> 00:03:29.810 
在運行時 會看到什麼樣的問題呢？

00:03:30.477 --> 00:03:33.013 
在Xcode 8 我們處理三個範圍

00:03:33.580 --> 00:03:36.316 
首先 線程問題

00:03:37.017 --> 00:03:38.886 
我們全新的
"Thread Sanitizer線程檢查工具"

00:03:38.952 --> 00:03:43.390 
可檢測線程問題在應用中 在運行時

00:03:45.692 --> 00:03:46.894 
UI佈局問題

00:03:46.994 --> 00:03:49.396 
我們擴展了Xcode的視圖調試工具

00:03:49.463 --> 00:03:52.165 
來自動檢測模糊的佈局問題

00:03:52.232 --> 00:03:53.534 
在應用中 在運行時

00:03:55.903 --> 00:03:56.837 
以及 內存問題

00:03:57.237 --> 00:03:59.139 
全新的內存圖形調試工具

00:03:59.206 --> 00:04:01.241 
一會兒我們會詳細解釋

00:04:01.308 --> 00:04:03.977 
它可以自動檢測內存泄漏

00:04:04.044 --> 00:04:05.612 
在應用中 在運行時

00:04:09.783 --> 00:04:11.118 
所以 如你在週一所聽到的

00:04:11.185 --> 00:04:13.287 
Xcode最新的運行時的檢查工具

00:04:13.353 --> 00:04:14.821 
就是"Thread Sanitizer線程檢查工具"

00:04:15.422 --> 00:04:19.892 
"Thread Sanitizer線程檢查工具"
幫助我們檢測和更好地理解線程問題

00:04:19.959 --> 00:04:21.962 
在應用中 在運行時

00:04:22.629 --> 00:04:25.032 
它可以檢測到的問題有 數據競爭

00:04:25.098 --> 00:04:28.368 
使用爲初始化的互斥鎖
來自錯誤線程的解鎖

00:04:28.836 --> 00:04:31.471 
線程泄漏及信號處理器的不安全調用等

00:04:32.172 --> 00:04:36.176 
發現以上任何一種問題
都會被報告爲運行時問題

00:04:37.244 --> 00:04:40.180 
"Thread Sanitizer線程檢查工具"
是一個強大的全新的運行時分析工具

00:04:40.247 --> 00:04:43.083 
爲了更充分地理解它可以觀看
關於"Thread Sanitizer線程檢查工具"

00:04:43.150 --> 00:04:44.551 
以及靜態分析演講

00:04:50.591 --> 00:04:52.559 
視圖調試是一個非常優秀的範例

00:04:52.626 --> 00:04:55.495 
在Xcode的調試工具中
變得越來越可視化

00:04:56.063 --> 00:05:00.901 
僅僅在過去幾年 關於UI調試問題

00:05:00.968 --> 00:05:04.071 
我們從必須要讀取調試輸出

00:05:04.137 --> 00:05:07.407 
到一個像這樣的工具臺 變成這樣

00:05:08.008 --> 00:05:11.245 
Xcode的可視化視圖調試工具
有非常好的用戶體驗

00:05:11.445 --> 00:05:14.414 
對於調試和理解可視化UI問題

00:05:15.449 --> 00:05:16.783 
如果你還從未使用過

00:05:17.484 --> 00:05:19.319 
當應用在運行Xcode時

00:05:20.053 --> 00:05:24.291 
只需點擊調試工具條下方的
“調試視圖層次結構”按鈕

00:05:25.526 --> 00:05:27.594 
Xcode將會快照你的應用

00:05:28.529 --> 00:05:29.930 
快照你的視圖層次結構

00:05:29.997 --> 00:05:32.766 
把它在一可互動的3D場景裏分解出來

00:05:33.600 --> 00:05:38.071 
在那裏
你可以在3D畫布裏檢查視圖層次結構

00:05:38.672 --> 00:05:40.541 
還可以在分級視圖裏

00:05:40.774 --> 00:05:44.545 
你可以檢查所有視圖和限制的屬性

00:05:44.611 --> 00:05:45.846 
利用檢查器

00:05:48.916 --> 00:05:52.386 
在Xcode 8
我們讓視圖調試——

00:05:53.554 --> 00:05:54.988 
你猜？比過去任何時候都更好

00:06:02.963 --> 00:06:05.365 
快照現在比過去快了近70％

00:06:05.432 --> 00:06:07.201 
所以你可以從運行應用

00:06:07.267 --> 00:06:09.570 
切換到調試UI問題 前所未有的快

00:06:15.542 --> 00:06:17.110 
渲染複雜佈局

00:06:17.177 --> 00:06:20.581 
和轉換視圖在Xcode 8裏更準確

00:06:20.681 --> 00:06:24.184 
談到準確
Xcode現可渲染模糊視圖

00:06:24.251 --> 00:06:26.987 
比如畫布上帶高保真視覺效果的視圖

00:06:27.621 --> 00:06:30.357 
因此在Xcode的
視圖調試工具所見到的

00:06:30.424 --> 00:06:32.459 
更爲準確地反應了在設備上所見到的

00:06:33.026 --> 00:06:35.429 
在beta 2
將會看到改進的模糊渲染

00:06:36.930 --> 00:06:39.132 
我們添加了便利性 比如可以直接跳轉

00:06:39.199 --> 00:06:41.101 
從視圖類到源代碼

00:06:41.168 --> 00:06:43.904 
只需在對象檢查器上點擊跳轉按鈕

00:06:45.706 --> 00:06:48.442 
瀏覽過濾也變得更爲強大了

00:06:48.842 --> 00:06:53.514 
可以通過任何標籤上的文本
或按鈕標題上的文本進行過濾

00:06:54.448 --> 00:06:58.719 
或者你可以通過類名進行過濾
也包括超類名

00:06:58.852 --> 00:07:02.656 
比如 如果通過UI標籤進行過濾
將會返回

00:07:02.723 --> 00:07:05.559 
所有視圖層次結構中
該UI標籤的所有子類

00:07:06.193 --> 00:07:07.895 
甚至可以通過內存地址進行過濾

00:07:08.061 --> 00:07:10.230 
這樣可以迅速找到特定的視圖

00:07:10.297 --> 00:07:11.999 
只需知道其內存地址

00:07:17.171 --> 00:07:20.240 
自動佈局調試也進步顯著

00:07:20.741 --> 00:07:24.378 
檢查器可以顯示更多
和自動佈局相關的屬性

00:07:25.045 --> 00:07:27.915 
限制在畫布上表現得更好

00:07:28.582 --> 00:07:30.484 
我們用標記渲染限制

00:07:30.551 --> 00:07:33.654 
來代表不平等或長寬比關係

00:07:33.987 --> 00:07:37.057 
我們還用虛線渲染非必須限制

00:07:37.124 --> 00:07:39.393 
所以你可以很容易分辨

00:07:39.459 --> 00:07:41.562 
畫布上的必須限制和非必須限制

00:07:42.696 --> 00:07:45.399 
但是我最欣賞的自動佈局調試的新功能

00:07:45.465 --> 00:07:47.601 
是它結合了運行時問題

00:07:49.436 --> 00:07:52.773 
Xcode現可自動檢測模糊佈局問題

00:07:52.840 --> 00:07:55.142 
在視圖層次結構裏 在運行時

00:08:01.648 --> 00:08:02.816 
它是怎麼運作的？

00:08:03.150 --> 00:08:04.885 
當快照視圖層次結構時

00:08:04.952 --> 00:08:09.223 
Xcode將會檢查每一個視圖
並將準確決定

00:08:09.289 --> 00:08:11.758 
其中任何一個視圖是否存在模糊佈局

00:08:11.825 --> 00:08:13.760 
以及模糊原因

00:08:14.595 --> 00:08:20.434 
如果檢測到任何佈局問題
將會作爲運行時問題報告

00:08:21.134 --> 00:08:23.270 
所以可以看見它們顯示在活動查看器裏

00:08:23.604 --> 00:08:26.507 
還可以看見它們在運行時
被列在問題瀏覽器裏

00:08:28.075 --> 00:08:31.645 
此外 視圖層次結構一覽將會標記

00:08:31.712 --> 00:08:34.847 
任何有佈局問題的視圖
因此可以輕易找到它們

00:08:34.914 --> 00:08:37.150 
在整個佈局層次結構下

00:08:39.318 --> 00:08:42.956 
對於一個選中的視圖
尺寸檢查器將會包含

00:08:43.023 --> 00:08:46.326 
任何佈局問題的細節 以及所有

00:08:46.393 --> 00:08:48.529 
參與該視圖佈局的限制

00:08:49.830 --> 00:08:51.999 
我們對Xcode新功能感到十分激動

00:08:52.065 --> 00:08:54.902 
它可以在運行時自動檢測模糊佈局問題

00:08:55.202 --> 00:08:56.603 
我想爲你們做一個演示

00:08:59.273 --> 00:09:02.442 
我有一個iPhone連在Mac上

00:09:02.743 --> 00:09:05.946 
Xcode已經啓動
正運行一個叫DemoBots的項目

00:09:06.013 --> 00:09:10.484 
這是我們今年更新Swift 3中的
示例代碼項目之一

00:09:11.385 --> 00:09:13.287 
在右邊 我正使用
QuickTime Player

00:09:13.353 --> 00:09:16.290 
把手機屏幕映射在桌面上
大家才都可以看見

00:09:17.024 --> 00:09:20.027 
我們的團隊的任務是
把一個遊戲指導說明書

00:09:20.093 --> 00:09:22.629 
添加到DemoBots
所以做了一個“如何開始遊戲”界面

00:09:23.197 --> 00:09:26.300 
然而 在演講前我們發現了一些問題

00:09:26.400 --> 00:09:28.869 
現在是調試這些問題的好機會

00:09:29.603 --> 00:09:30.637 
點擊“如何開始遊戲”

00:09:30.971 --> 00:09:32.406 
這就是“如何開始遊戲”界面

00:09:32.806 --> 00:09:33.740 
不怎麼樣是吧？

00:09:34.374 --> 00:09:36.577 
顯然 存在一些問題 來看一下

00:09:36.643 --> 00:09:39.146 
可以看到DemoBots圖標在後面

00:09:39.213 --> 00:09:41.615 
上方有一些錯位的文本

00:09:41.982 --> 00:09:44.284 
我們需要來調試 從哪兒開始？

00:09:45.118 --> 00:09:46.420 
給你們一點提示

00:09:46.920 --> 00:09:50.023 
DemoBots是一款用
SpriteKit編寫的街機小遊戲

00:09:50.090 --> 00:09:53.093 
但該屏幕是
用UIKit和自動佈局產生的

00:09:53.660 --> 00:09:55.929 
所以最好的開始的地方是在

00:09:55.996 --> 00:09:59.867 
在視圖層次和佈局結構上

00:09:59.933 --> 00:10:01.034 
我們一起來操作

00:10:01.835 --> 00:10:03.136 
回到Xcode

00:10:04.571 --> 00:10:05.539 
最底部

00:10:06.206 --> 00:10:08.342 
找到“調試視圖層次”按鈕

00:10:09.610 --> 00:10:10.711 
點擊

00:10:10.777 --> 00:10:14.047 
它將暫停應用 快照整個視圖結構

00:10:14.948 --> 00:10:15.816 
在編輯器裏

00:10:16.350 --> 00:10:19.853 
我們返回了剛纔屏幕上所見的準確表達

00:10:20.721 --> 00:10:22.956 
爲了查看內部結構

00:10:23.023 --> 00:10:24.892 
我們只需把它拖進畫布

00:10:24.958 --> 00:10:28.495 
把完整的視圖結構開拓成3D視圖

00:10:33.867 --> 00:10:37.204 
在這裏 可看到構成該屏幕的所有視圖

00:10:37.271 --> 00:10:38.539 
後面的視窗

00:10:38.672 --> 00:10:40.707 
容器視圖 視覺效果視圖

00:10:40.774 --> 00:10:43.644 
及構成“如何開始遊戲”說明書的視圖

00:10:43.944 --> 00:10:45.112 
放大看一下

00:10:45.579 --> 00:10:47.481 
我們看到DemoBots圖標在後面

00:10:47.548 --> 00:10:49.383 
還有很多標籤和圖像

00:10:49.716 --> 00:10:53.086 
我們迅速可以瞭解 通過旋轉

00:10:53.153 --> 00:10:55.055 
找出屏幕上的一團亂的原因

00:10:55.322 --> 00:10:57.925 
所有這些視圖都彼此疊加

00:10:58.225 --> 00:10:59.526 
所以我們的佈局有問題

00:11:00.127 --> 00:11:02.629 
傳統的工作流程是

00:11:02.696 --> 00:11:04.565 
檢測每一個視圖及其限制

00:11:04.631 --> 00:11:07.034 
然後試着確定產生布局問題的原因

00:11:07.367 --> 00:11:10.304 
但在Xcode 8
我們有一些額外的可用信息

00:11:10.871 --> 00:11:13.874 
注意上方的活動查看器Xcode報告

00:11:13.941 --> 00:11:15.676 
我們有運行時問題

00:11:16.577 --> 00:11:18.545 
可以點擊它

00:11:18.779 --> 00:11:21.481 
將會打開問題瀏覽器

00:11:21.982 --> 00:11:24.952 
但你可能也注意到了左邊這裏

00:11:25.018 --> 00:11:26.553 
在調試瀏覽器裏

00:11:27.487 --> 00:11:29.423 
Xcode標記出一些視圖

00:11:29.690 --> 00:11:31.859 
它告訴我們 這些視圖有佈局問題

00:11:31.925 --> 00:11:33.227 
直接來看這裏

00:11:34.228 --> 00:11:35.662 
如果選中第一個視圖

00:11:36.263 --> 00:11:38.365 
畫布中高亮顯示

00:11:38.665 --> 00:11:41.735 
然後打開該視圖的尺寸檢查器
右邊這裏

00:11:42.970 --> 00:11:46.139 
在這裏 我們可以在限制中
找出佈局問題的原因

00:11:46.507 --> 00:11:49.343 
該視圖有一個模糊垂直位置

00:11:50.077 --> 00:11:52.579 
也就是說自動佈局沒有足夠的信息

00:11:52.646 --> 00:11:56.083 
在垂直維度明確定位該視圖

00:11:56.984 --> 00:11:58.685 
很典型 限制缺失

00:12:00.354 --> 00:12:01.722 
來看下一個視圖

00:12:02.256 --> 00:12:04.658 
有着一樣的問題 垂直位置模糊

00:12:05.292 --> 00:12:06.827 
下一個視圖也是

00:12:06.894 --> 00:12:08.095 
若我隨機點擊一些別的

00:12:08.161 --> 00:12:09.796 
似乎它們都有同樣的問題

00:12:10.264 --> 00:12:13.467 
我很好奇 這個列表的第一個子視圖

00:12:13.934 --> 00:12:15.135 
並沒被標記顯示有問題

00:12:15.202 --> 00:12:17.304 
可能是查看佈局代碼時的一個線索

00:12:17.905 --> 00:12:18.972 
現在我們來看一下

00:12:19.239 --> 00:12:20.674 
如果選中父視圖

00:12:21.241 --> 00:12:23.710 
類名是
InstructionsLayoutView

00:12:23.777 --> 00:12:26.713 
這就是負責顯示
“如何開始遊戲”屏幕的視圖

00:12:27.581 --> 00:12:29.383 
來看看它的源代碼

00:12:29.917 --> 00:12:32.686 
一種簡單的方法就是選中視圖

00:12:32.753 --> 00:12:34.021 
右邊這裏

00:12:34.087 --> 00:12:36.290 
可以找到 對象檢查器

00:12:36.657 --> 00:12:39.927 
該按鈕可以直接跳轉到視圖源代碼

00:12:40.627 --> 00:12:41.728 
如此操作

00:12:41.795 --> 00:12:43.797 
關上檢查器 多留出一點空間

00:12:44.031 --> 00:12:46.667 
我們來看看
InstructionsLayoutView的源代碼

00:12:48.202 --> 00:12:50.838 
首先開始循環

00:12:50.904 --> 00:12:53.140 
說明書的每一個部分 都是模塊對象

00:12:53.207 --> 00:12:57.678 
描述了頁眉部分 段落部分 和圖片

00:12:58.212 --> 00:13:00.914 
代碼把它們從上到下顯示

00:13:01.582 --> 00:13:04.785 
對於每一個部分 修復視圖
把它添加到視圖層次結構

00:13:05.152 --> 00:13:07.354 
然後是水平佈局的源代碼

00:13:07.487 --> 00:13:09.323 
但在水平佈局中沒有發現任何問題

00:13:09.389 --> 00:13:11.525 
所以略過此處 到垂直佈局

00:13:12.526 --> 00:13:14.228 
這裏 有兩條通路

00:13:14.595 --> 00:13:17.130 
第一條是 對於第一個子視圖

00:13:17.197 --> 00:13:18.198 
把它限制到容器頂端

00:13:18.866 --> 00:13:22.569 
我們已經注意到 第一個子視圖

00:13:22.636 --> 00:13:23.871 
並未報告含有任何問題

00:13:24.071 --> 00:13:26.406 
所以 該限制我們認爲是設置正確的

00:13:26.473 --> 00:13:28.642 
來看看條件的另一面

00:13:29.510 --> 00:13:32.713 
這裏 查找可選的
previousPartView

00:13:32.779 --> 00:13:36.016 
如果找到了
就把它指定給上面的局部變量

00:13:36.383 --> 00:13:39.620 
然後可把每個視圖限制到它上面的視圖

00:13:40.020 --> 00:13:41.855 
看上去這就是缺失的限制

00:13:42.389 --> 00:13:46.760 
讓我們來看看爲什麼該條件不爲真

00:13:47.461 --> 00:13:50.864 
選中previousPartView
我們從它開始

00:13:50.931 --> 00:13:55.335 
我將使用Command-A選中
Command-F跳出搜索欄

00:13:56.069 --> 00:13:57.771 
檢查該變量的實例

00:13:58.272 --> 00:13:59.907 
可以看到其在頂端被定義

00:14:00.107 --> 00:14:02.409 
它被指定爲nil 在for循環之前

00:14:02.843 --> 00:14:04.211 
在下方這裏也檢查

00:14:04.645 --> 00:14:06.747 
在外循環外又檢查一次

00:14:06.813 --> 00:14:08.615 
來處理底部限制

00:14:08.682 --> 00:14:10.717 
但看上去我們從未指定給它

00:14:10.918 --> 00:14:12.219 
快速修復一下

00:14:13.053 --> 00:14:15.422 
在循環結尾 我們可把
previousPartView

00:14:16.023 --> 00:14:17.257 
設定給當前的partView

00:14:17.624 --> 00:14:21.028 
然後在每一個循環中
前一個視圖都可用

00:14:21.094 --> 00:14:23.497 
都將指定給上面的視圖

00:14:23.564 --> 00:14:26.567 
我們將從視圖到其上面的視圖
之間建立一個限制

00:14:27.234 --> 00:14:29.169 
停止 重新運行 看看結果

00:14:29.903 --> 00:14:31.305 
我把QuickTime移到前面

00:14:32.105 --> 00:14:34.241 
請注意Xcode能給提供多少信息

00:14:34.308 --> 00:14:36.510 
甚至在看到代碼之前

00:14:36.977 --> 00:14:39.279 
{\an2用視圖調試器查看結構內部

00:14:39.346 --> 00:14:40.881 
看看有什麼問題

00:14:41.181 --> 00:14:43.350 
更重要的 Xcode會主動告訴我們

00:14:43.417 --> 00:14:46.486 
應用裏的某些佈局問題

00:14:46.787 --> 00:14:50.190 
哪個視圖有問題 尤其是什麼樣的問題

00:14:50.457 --> 00:14:53.093 
這在我們查看代碼之前就有了很多信息

00:14:53.160 --> 00:14:56.463 
因此我們可以迅速鎖定
需要查看的代碼部分

00:14:57.698 --> 00:15:00.033 
現在應用正在運行
點擊“如何開始遊戲”

00:15:01.034 --> 00:15:02.236 
看上去好多了

00:15:02.302 --> 00:15:03.971 
我們有了一個美觀的說明頁面

00:15:11.211 --> 00:15:16.083 
現在Xcode可以報告運行時錯誤

00:15:16.149 --> 00:15:19.253 
採用和檢測編譯時問題時一樣的UI

00:15:20.587 --> 00:15:23.423 
今年 Xcode的視圖調試器
也有了顯著的改進

00:15:23.790 --> 00:15:27.494 
包括更爲迅速的快照和更爲準確的渲染

00:15:27.561 --> 00:15:30.297 
在複雜佈局和模糊視圖方面

00:15:31.598 --> 00:15:34.401 
在自動調試方面也有了顯著的改進

00:15:34.468 --> 00:15:36.370 
尤其是 Xcode現在可以

00:15:36.436 --> 00:15:40.040 
在運行時自動檢測模糊佈局問題

00:15:40.674 --> 00:15:43.043 
Xcode的視圖調試器支持各種UI

00:15:43.110 --> 00:15:45.679 
在Mac OS iOS和tvOS上

00:15:46.146 --> 00:15:47.247 
在你的項目中試一下

00:15:47.314 --> 00:15:50.918 
我們很樂意得到反饋
關於它如何在調試流程中給你帶來幫助

00:15:53.120 --> 00:15:54.855 
下面 我想把講臺讓給Tyler

00:15:54.922 --> 00:15:58.659 
他將爲我們講解
調試狀態機和幀速率問題

00:15:58.926 --> 00:15:59.760 
謝謝大家

00:16:04.865 --> 00:16:05.799 
謝謝Chris

00:16:06.500 --> 00:16:09.336 
今天 我將爲大家演示
一種增強調試體驗的新方法

00:16:09.403 --> 00:16:10.771 
利用狀態機快速查看

00:16:10.838 --> 00:16:14.274 
及Xcode 8中FPS性能檢測的
內部機理

00:16:15.909 --> 00:16:17.444 
今天有很多有用的快速查看

00:16:17.511 --> 00:16:19.580 
已經在Xcode 7裏可用

00:16:19.847 --> 00:16:23.183 
這些爲你提供了
實時查看各種對象的可能

00:16:23.250 --> 00:16:24.318 
在調試過程中

00:16:24.718 --> 00:16:27.020 
你甚至可以自定義快速查看

00:16:27.087 --> 00:16:28.889 
來檢查應用內部對象

00:16:29.656 --> 00:16:30.991 
現在在Xcode 8

00:16:31.058 --> 00:16:34.294 
我們擴展了內置的快速查看
包含了狀態機

00:16:35.195 --> 00:16:37.397 
首先我們來看狀態機到底是什麼

00:16:37.464 --> 00:16:39.066 
以及如何在應用內部使用

00:16:41.168 --> 00:16:43.737 
你們當中一定有很多人已對
GKStateMachine很熟悉

00:16:43.804 --> 00:16:46.139 
去年它是
GameplayKit的一部分

00:16:46.206 --> 00:16:49.376 
可用於
Mac OS iOS和tvOS

00:16:50.277 --> 00:16:53.146 
狀態機允許你更爲簡單地定義複雜行爲

00:16:53.213 --> 00:16:55.382 
通過把它構建成爲一個有向圖

00:16:55.816 --> 00:16:57.017 
在狀態機內

00:16:57.084 --> 00:16:59.486 
你爲每一個狀態提供一個離散行爲

00:17:00.220 --> 00:17:02.723 
可以像播放一個動畫這麼簡單

00:17:02.789 --> 00:17:05.459 
或者更復雜的 比如一個AI

00:17:06.460 --> 00:17:08.929 
然後對每一個狀態定義條件

00:17:08.996 --> 00:17:12.266 
狀態機可以據此
從一個狀態轉換到另一個狀態

00:17:13.834 --> 00:17:17.637 
組裝完成後
狀態機可以產生極其複雜的行爲

00:17:17.704 --> 00:17:21.308 
然而 在代碼裏它們也會變得很難辨識

00:17:21.375 --> 00:17:22.943 
由於它們複雜度的增加

00:17:23.377 --> 00:17:26.914 
簡單的狀態機可以迅速進化得更爲詳細

00:17:28.615 --> 00:17:31.118 
在Xcode 7.3
對調試狀態機的支持

00:17:31.185 --> 00:17:34.087 
只侷限在當前狀態和它的轉換

00:17:34.454 --> 00:17:36.156 
而現在在Xcode 8

00:17:36.223 --> 00:17:38.725 
我們可以可視化完整的狀態機

00:17:38.792 --> 00:17:40.594 
因此可以一目瞭然當前狀態

00:17:41.728 --> 00:17:43.764 
這非常有用 不論你正在

00:17:43.830 --> 00:17:46.767 
操作簡單的狀態機 還是你在操作

00:17:46.834 --> 00:17:49.469 
更爲複雜的狀態機

00:17:50.003 --> 00:17:53.207 
利用快速查看
你可以迅速調試潛在問題

00:17:53.273 --> 00:17:56.343 
並且準確評估狀態機的當前情況

00:17:59.246 --> 00:18:01.582 
現在我們把焦點轉到性能

00:18:02.282 --> 00:18:04.751 
任何時候新建任何形式的
遊戲或視覺應用

00:18:04.885 --> 00:18:06.620 
保證良好性能都是關鍵

00:18:06.987 --> 00:18:09.690 
在Xcode 8
我們擴大了FPS性能測量

00:18:09.756 --> 00:18:10.824 
在這方面進行幫助

00:18:12.526 --> 00:18:14.027 
你們當中很多人應該已很熟悉

00:18:14.094 --> 00:18:16.530 
Xcode 7的FPS性能測量

00:18:16.830 --> 00:18:18.632 
在報告一開始

00:18:18.699 --> 00:18:20.667 
可以看到實時狀態的數據

00:18:21.535 --> 00:18:22.703 
這包括了幀速率

00:18:22.769 --> 00:18:25.172 
即當前每秒被渲染的幀數

00:18:26.006 --> 00:18:27.541 
以及GPU利用率

00:18:27.608 --> 00:18:30.143 
可以看到哪部分的GPU利用率最高

00:18:30.611 --> 00:18:33.580 
以及CPU和GPU的幀時間

00:18:34.147 --> 00:18:37.818 
可以幫助表明
是CPU綁定還是GPU綁定

00:18:39.953 --> 00:18:41.922 
現在 除了實時數據

00:18:41.989 --> 00:18:44.791 
Xcode 8還提供了時間線歷史

00:18:44.858 --> 00:18:47.261 
SpriteKit和
SceneKit幀時間

00:18:47.327 --> 00:18:49.129 
爲CPU和GPU兩者

00:18:49.563 --> 00:18:51.665 
在iOS和watchOS都可用

00:18:52.165 --> 00:18:55.135 
這裏很棒的一點是
我們分解了CPU的幀時間

00:18:55.202 --> 00:18:56.904 
以及CPU的各個部分

00:18:56.970 --> 00:18:58.572 
所以可很清楚地看到有多少時間

00:18:58.639 --> 00:19:01.141 
用於渲染 或運行更新循環

00:19:01.208 --> 00:19:04.611 
評估行動和物理
甚至多少時間是空閒的

00:19:06.046 --> 00:19:07.548 
當應用暫停時

00:19:07.614 --> 00:19:10.284 
可以滾動查看所有性能歷史

00:19:10.350 --> 00:19:12.953 
就可看到它隨着應用的運行如何變化

00:19:13.854 --> 00:19:16.123 
如果有某一個特別感興趣的地方

00:19:16.190 --> 00:19:19.293 
你可以深入檢查更多的細節

00:19:19.660 --> 00:19:21.495 
查看確切時間點

00:19:23.864 --> 00:19:26.300 
來看一下如何在應用裏應用

00:19:43.116 --> 00:19:45.853 
我們找到了佈局問題

00:19:45.953 --> 00:19:48.989 
在“如何開始遊戲”菜單
點進遊戲本身

00:19:51.058 --> 00:19:54.294 
這個遊戲的目標是
把所有的損壞的機器人

00:19:54.361 --> 00:19:56.463 
變成好的機器人

00:19:57.064 --> 00:19:59.466 
要達成目標 我有一道光束 射向它們

00:19:59.533 --> 00:20:01.768 
就可以把它們重置爲好機器人

00:20:02.202 --> 00:20:05.339 
我們看到這裏有一個壞機器人在追我

00:20:05.405 --> 00:20:07.374 
我用光束射向它

00:20:11.578 --> 00:20:14.715 
可看到它變成好機器人了 顯示爲綠色

00:20:15.415 --> 00:20:18.218 
但是我看到還有光束

00:20:18.285 --> 00:20:20.654 
顯示在機器人上面 不該有這樣的情況

00:20:21.388 --> 00:20:24.892 
既然我們用狀態機來管理光束行爲

00:20:25.225 --> 00:20:26.627 
這是一個很好的對象

00:20:26.693 --> 00:20:29.796 
來使用狀態機快速查看這裏是怎麼回事

00:20:31.365 --> 00:20:35.169 
我將會暫停應用
瀏覽BeamComponent

00:20:36.203 --> 00:20:39.473 
我們用BeamComponent
來新建和更新

00:20:39.540 --> 00:20:41.608 
管理光束行爲的狀態機

00:20:41.975 --> 00:20:44.178 
在更新循環裏添加一個斷點

00:20:44.244 --> 00:20:47.080 
繼續遊戲 馬上進入斷點

00:20:48.081 --> 00:20:50.450 
因爲應用已經暫停 可以進入調試區

00:20:50.517 --> 00:20:52.553 
找到狀態機的實例

00:20:52.953 --> 00:20:54.087 
快速查看它

00:20:55.088 --> 00:20:57.424 
在這裏 我們看到整個狀態機

00:20:58.058 --> 00:21:01.895 
藍色是當前所處狀態
即BeamFiringState

00:21:01.962 --> 00:21:04.264 
灰色是所有

00:21:04.331 --> 00:21:05.866 
組成狀態機的其餘狀態

00:21:06.767 --> 00:21:09.403 
我們還可以看到每個狀態之間的轉換

00:21:09.570 --> 00:21:12.773 
我立即注意到的是有很多轉換條件

00:21:12.840 --> 00:21:16.143 
指向BeamFiringState
但沒有轉換指出去

00:21:16.810 --> 00:21:18.745 
也就是說 一旦進入到開火模式

00:21:18.812 --> 00:21:20.080 
就沒辦法離開

00:21:20.681 --> 00:21:22.716 
來檢查
BeamFiringState

00:21:22.783 --> 00:21:24.051 
看到底是怎麼回事

00:21:24.918 --> 00:21:27.754 
刪除斷點 關閉調試區

00:21:27.821 --> 00:21:29.423 
切換到
BeamFiringState

00:21:31.491 --> 00:21:33.126 
現在來看更新循環

00:21:33.193 --> 00:21:36.096 
這裏可以看到有一些轉換邏輯

00:21:36.163 --> 00:21:38.599 
既指向CoolingState
又指向IdleState

00:21:39.466 --> 00:21:40.667 
但在下面的方法裏

00:21:40.734 --> 00:21:44.304 
檢查我們要轉換的狀態是否有效

00:21:44.371 --> 00:21:45.806 
總是返回假

00:21:45.873 --> 00:21:47.908 
這是不正確的 因爲我們想要轉換到

00:21:47.975 --> 00:21:49.176 
冷卻狀態或者空閒狀態

00:21:50.177 --> 00:21:51.712 
現在修復該問題

00:21:51.778 --> 00:21:53.714 
通過檢查想要轉換到的狀態

00:21:53.780 --> 00:21:55.415 
是否是兩個有效的狀態之一

00:21:55.816 --> 00:21:57.217 
回到遊戲當中

00:21:57.284 --> 00:21:59.553 
檢查這是否是我們看到的問題

00:22:00.754 --> 00:22:04.625 
當我們轉換到FiringState
滿足條件退出時

00:22:04.691 --> 00:22:07.828 
我們應該可轉換回IdleState

00:22:09.830 --> 00:22:10.931 
進入遊戲

00:22:10.998 --> 00:22:14.301 
向壞機器人開火

00:22:14.368 --> 00:22:15.736 
把它變爲好機器人

00:22:16.036 --> 00:22:20.073 
可以看到光束已經不在遊戲者頭上了

00:22:20.140 --> 00:22:21.775 
看來問題已經解決了

00:22:23.076 --> 00:22:25.679 
我們還發現了遊戲存在性能問題

00:22:26.013 --> 00:22:28.682 
底部有很多地面機器人

00:22:28.749 --> 00:22:31.018 
我發現如果遊戲者被機器人襲擊

00:22:31.084 --> 00:22:33.020 
性能會急劇下降

00:22:33.987 --> 00:22:35.756 
我將切換到FPS性能測量

00:22:35.822 --> 00:22:39.059 
這樣就可以在運行時實時看到性能數據

00:22:39.693 --> 00:22:42.963 
可以看到在這裏 顯示的是目標幀時間

00:22:43.263 --> 00:22:45.966 
本例中 是16.6毫秒

00:22:46.133 --> 00:22:49.303 
也就是保持每秒60幀的幀速率

00:22:50.838 --> 00:22:53.674 
可以看到一部分時間被用在渲染的時間

00:22:53.740 --> 00:22:55.442 
以及用在運行客戶更新的時間

00:22:55.776 --> 00:22:58.512 
還有CPU空閒時間的迴旋餘地

00:22:59.947 --> 00:23:02.115 
回到遊戲 移到右邊

00:23:02.182 --> 00:23:04.852 
有一個敵人機器人 我會讓它襲擊我

00:23:04.918 --> 00:23:07.221 
試着重現性能問題

00:23:08.088 --> 00:23:09.857 
現在切換回性能測量

00:23:09.923 --> 00:23:11.725 
看看更新循環裏是怎麼回事

00:23:12.326 --> 00:23:15.395 
我發現很長一段時間被用於評估操作上

00:23:15.462 --> 00:23:18.131 
事實上 現在幀速率大幅下降

00:23:18.899 --> 00:23:20.367 
暫停應用

00:23:20.434 --> 00:23:22.703 
來看看其中的問題所在

00:23:23.837 --> 00:23:26.306 
既然已經暫停 我可以及時滾動

00:23:26.373 --> 00:23:27.808 
回到幀分解

00:23:27.875 --> 00:23:30.244 
看看應用裏之前的幀時間

00:23:30.711 --> 00:23:33.313 
可以看到在主菜單

00:23:33.380 --> 00:23:35.115 
只有小部分時間用於渲染

00:23:35.182 --> 00:23:36.583 
大部分時間都在空閒

00:23:36.950 --> 00:23:39.219 
遊戲中的分解部分也是如此

00:23:39.586 --> 00:23:41.655 
我們已經找出了性能問題

00:23:41.722 --> 00:23:44.424 
可以點擊 然後按住來查看細節

00:23:44.491 --> 00:23:46.727 
對於我們發現的性能問題

00:23:47.227 --> 00:23:51.665 
在這裏 我看到幀時間是36.2毫秒

00:23:51.732 --> 00:23:54.902 
71%都用於評估操作

00:23:55.802 --> 00:23:59.039 
也就是說在遊戲中
可能存在一個或兩個問題

00:23:59.473 --> 00:24:01.241 
我們可能在場景中有一個操作

00:24:01.308 --> 00:24:04.444 
佔用了非常長的時間來評估

00:24:04.845 --> 00:24:08.215 
或者 可能會有很多操作
造成更新循環產生瓶頸

00:24:08.916 --> 00:24:12.386 
現在已經知道更新循環裏哪裏有問題

00:24:16.056 --> 00:24:18.225 
我們知道該如何利用狀態機快速查看

00:24:18.292 --> 00:24:20.627 
來調試遊戲中碰到的問題

00:24:20.994 --> 00:24:23.130 
以及FPS性能測量如何顯示

00:24:23.197 --> 00:24:25.866 
更新循環的具體哪裏出了問題

00:24:26.800 --> 00:24:28.602 
現邀請Daniel Delwood

00:24:28.669 --> 00:24:30.838 
上臺爲大家講解全新的內存圖形調試器

00:24:30.904 --> 00:24:32.439 
我們用來確定

00:24:32.506 --> 00:24:35.642 
操作問題從哪裏產生
然後可以對其進行修復

00:24:43.350 --> 00:24:44.284 
謝謝你 Tyler

00:24:44.985 --> 00:24:46.086 
我很激動能夠爲大家講解

00:24:46.153 --> 00:24:48.722 
Xcode 8裏
全新的內存圖形調試器

00:24:48.789 --> 00:24:51.391 
我很喜歡視圖調試器

00:24:51.625 --> 00:24:53.961 
它是可以更好理解應用的工具

00:24:54.127 --> 00:24:57.464 
如同視圖調試器瞭解視圖層次結構

00:24:57.531 --> 00:25:00.367 
內存圖形調試器可以幫助瞭解內存

00:25:00.434 --> 00:25:02.069 
以及內存之間如何互相引用

00:25:02.469 --> 00:25:06.073 
它想回答的一個核心問題是

00:25:06.340 --> 00:25:09.076 
爲什麼某些對象還存在於堆裏？

00:25:10.010 --> 00:25:12.179 
對象互相引用

00:25:12.246 --> 00:25:16.583 
你知道 現在引用

00:25:16.650 --> 00:25:19.920 
和註釋已經成爲
自動引用指南世界的重要問題

00:25:20.721 --> 00:25:24.791 
我們該如何解決存在

00:25:24.858 --> 00:25:27.528 
不需要的對象 泄漏的對象
或遺棄的對象的問題

00:25:28.195 --> 00:25:31.398 
有一些命令行工具 比如Heap

00:25:32.065 --> 00:25:35.135 
Heap將快照你的進程

00:25:35.202 --> 00:25:37.804 
遍歷檢查 找出不同類型的摘要

00:25:37.871 --> 00:25:41.108 
以及進程中對象數量

00:25:41.175 --> 00:25:45.579 
你甚至可以使用“地址”標記
來尋找特定類型的對象

00:25:45.646 --> 00:25:47.748 
獲取實例列表

00:25:48.315 --> 00:25:50.684 
一旦對某個實例感興趣

00:25:51.185 --> 00:25:54.188 
可以用leaks中
尋找關於連接問題的信息

00:25:54.254 --> 00:25:56.423 
是否未被引用？是否存在泄漏？

00:25:56.790 --> 00:25:59.860 
是不是從全局位置有一條通路

00:25:59.927 --> 00:26:03.830 
在應用中一直指向該對象？

00:26:05.065 --> 00:26:08.802 
在任何此類調查時
你都可能需要進一步的細節

00:26:08.869 --> 00:26:10.504 
比如棧分配追蹤

00:26:10.804 --> 00:26:12.372 
可以用
malloc_history獲得

00:26:12.906 --> 00:26:15.442 
而這些都不是可視化體驗

00:26:15.509 --> 00:26:18.579 
這就是我們爲何要把這三個工具集成到

00:26:18.645 --> 00:26:20.280 
內存圖形調試器的IDE

00:26:20.681 --> 00:26:24.218 
快速瀏覽一下它的構成

00:26:24.484 --> 00:26:27.921 
左邊 瀏覽器中顯示堆類型信息

00:26:27.988 --> 00:26:29.256 
用來開始分析

00:26:29.957 --> 00:26:31.792 
中間的編輯器

00:26:31.859 --> 00:26:33.894 
顯示連接問題

00:26:34.328 --> 00:26:37.564 
右邊 我們用來顯示

00:26:37.631 --> 00:26:40.501 
通過檢查器顯示棧分配追蹤

00:26:40.868 --> 00:26:43.403 
講完以上 回到演示例子

00:26:44.104 --> 00:26:46.507 
從Tyler講到的地方開始
看看我們是否

00:26:46.573 --> 00:26:48.575 
能看到他所看到的操作問題

00:26:48.842 --> 00:26:49.710 
好

00:26:50.010 --> 00:26:54.748 
現在我們在FPS性能測量

00:26:54.815 --> 00:26:59.520 
看到那些應用裏可能出錯的動作

00:26:59.953 --> 00:27:01.655 
我們可以直接查看

00:27:01.722 --> 00:27:04.858 
通過選擇內存圖形調試器按鈕

00:27:05.058 --> 00:27:07.561 
在調試菜單欄

00:27:08.061 --> 00:27:10.030 
左邊這裏

00:27:10.564 --> 00:27:15.569 
瀏覽器顯示了我的應用中所有不同類型

00:27:15.636 --> 00:27:17.004 
分配在應用中的

00:27:17.237 --> 00:27:21.775 
它們按照模式被分解 然後按照類型

00:27:21.842 --> 00:27:24.178 
每一個對象 都有一個實例

00:27:25.212 --> 00:27:29.983 
在本例中 我對搜索堆感興趣

00:27:30.184 --> 00:27:31.251 
這很容易做到

00:27:31.318 --> 00:27:34.655 
在過濾器裏打字 搜索“操作”

00:27:36.290 --> 00:27:38.725 
出現了
在SpriteKit裏出現所有類型

00:27:38.792 --> 00:27:42.829 
我們看到有很多操作——559個

00:27:43.197 --> 00:27:45.532 
應該是操作太多了的問題

00:27:45.599 --> 00:27:49.036 
而不是隻有一個一直在運行的操作

00:27:50.637 --> 00:27:52.406 
選擇其中一個對象

00:27:53.040 --> 00:27:57.444 
編輯器顯示問題的答案

00:27:57.511 --> 00:27:59.613 
即爲什麼這個對象還存在

00:28:00.013 --> 00:28:02.149 
在這裏 它顯示了根操作圖形

00:28:02.216 --> 00:28:06.653 
可以追蹤選中的對象

00:28:06.720 --> 00:28:09.523 
回到左邊 回到應用根目錄

00:28:09.890 --> 00:28:14.061 
可以看到它被一個SKC序列反覆引用

00:28:14.127 --> 00:28:15.696 
還帶有一個數組

00:28:15.796 --> 00:28:18.232 
我還可以發現更多問題

00:28:18.932 --> 00:28:22.236 
這裏有帶一些操作的SKNode

00:28:22.302 --> 00:28:25.172 
這是該SKNode的部分操作列表

00:28:25.439 --> 00:28:28.642 
可以點擊 然後快速查看

00:28:29.209 --> 00:28:34.147 
如果想查看關於該操作更多的信息

00:28:34.214 --> 00:28:37.117 
我可以選中它 拉出檢查器

00:28:38.719 --> 00:28:40.888 
檢查器將顯示一些內存細節

00:28:40.954 --> 00:28:44.625 
比如類名 地址 層次結構

00:28:44.691 --> 00:28:47.628 
如果是其它對象的子類

00:28:48.228 --> 00:28:50.631 
我想知道該操作是在哪裏新建的

00:28:50.697 --> 00:28:51.798 
這樣就可以找到該位置

00:28:52.599 --> 00:28:57.905 
摺疊該棧追蹤 進入代碼

00:28:58.872 --> 00:29:02.109 
這裏有一個函數
refreshHurtAction

00:29:03.010 --> 00:29:06.180 
一個HurtAction在運行

00:29:06.246 --> 00:29:11.552 
可以用快速幫助看到該操作已經添加到

00:29:11.618 --> 00:29:14.087 
結點的操作列表當中

00:29:15.556 --> 00:29:18.492 
但實際上我只想有一個單機操作

00:29:18.559 --> 00:29:21.195 
並確保它取代之前的操作

00:29:21.261 --> 00:29:22.529 
所以修復很簡單

00:29:22.596 --> 00:29:25.465 
我將使用withKey變量

00:29:25.532 --> 00:29:28.035 
取代“playerAction”

00:29:31.772 --> 00:29:35.042 
快速幫助將會顯示
是的 這就是我想要的

00:29:35.108 --> 00:29:37.177 
如果一個操作在使用正運行的統一鍵值

00:29:37.244 --> 00:29:38.946 
它將會在該操作加進來之前被移除

00:29:39.012 --> 00:29:40.013 
很好

00:29:40.881 --> 00:29:46.420 
這是一種非常簡單的方法
對某個特定類型進行調查

00:29:46.753 --> 00:29:47.888 
但是我還注意到另外一點

00:29:47.955 --> 00:29:50.791 
當我點擊內存圖像調試按鈕時

00:29:50.858 --> 00:29:55.062 
運行時問題瀏覽器提醒我有一些問題

00:29:55.295 --> 00:29:56.363 
點擊該提醒

00:29:56.430 --> 00:30:00.367 
來到新的運行時問題瀏覽器

00:30:00.868 --> 00:30:04.171 
顯示在應用裏有很多泄漏

00:30:05.372 --> 00:30:09.276 
我先從模式裏定義的一個類型開始

00:30:09.343 --> 00:30:11.378 
比如這個LoadSceneOperation

00:30:12.546 --> 00:30:16.116 
選中它 圖形沒有顯示同樣的風格

00:30:16.183 --> 00:30:18.719 
它顯示了一個引用週期

00:30:19.219 --> 00:30:21.889 
它是一個泄漏的對象

00:30:21.955 --> 00:30:24.892 
從應用裏的位置無法訪問它

00:30:25.392 --> 00:30:28.061 
需要找出哪些

00:30:28.128 --> 00:30:30.898 
泄漏的對象正在彼此引用

00:30:31.765 --> 00:30:33.100 
快速來看這一點

00:30:33.433 --> 00:30:36.803 
有一個帶有內部狀態的操作

00:30:37.070 --> 00:30:39.106 
它在引用一個完成塊

00:30:39.606 --> 00:30:43.944 
作爲該塊的一部分 有一些捕捉

00:30:44.011 --> 00:30:46.213 
正在強力引用LoadSceneOperation

00:30:46.613 --> 00:30:47.481 
有意思

00:30:48.315 --> 00:30:51.418 
如果點擊該模塊 我可以看到回溯軌跡

00:30:51.485 --> 00:30:52.686 
馬上去那裏

00:30:54.855 --> 00:30:56.323 
在這裏

00:30:56.623 --> 00:30:58.458 
我的LoadSceneOperation的完成塊

00:30:58.525 --> 00:31:01.461 
我甚至有一個“unowned self”捕捉列表

00:31:02.029 --> 00:31:04.631 
但是圖形顯示該self沒有問題

00:31:04.698 --> 00:31:07.467 
問題是LoadSceneOperation
正在捕捉自己

00:31:08.268 --> 00:31:09.770 
就在該模塊中

00:31:11.471 --> 00:31:13.407 
此處修復也非常簡單

00:31:13.674 --> 00:31:17.477 
只需要捕捉unowned

00:31:18.245 --> 00:31:21.181 
就可以繼續了 但是

00:31:23.917 --> 00:31:26.653 
可惜的是 這不是真正的解決方案

00:31:26.987 --> 00:31:31.091 
因爲是整個模塊 我的
LoadSceneOperation已要結束了

00:31:31.558 --> 00:31:33.760 
如果它執行了該模塊

00:31:34.194 --> 00:31:36.830 
LoadSceneOperation將會結束其生命週期

00:31:36.897 --> 00:31:38.599 
不會存在很長時間

00:31:38.966 --> 00:31:41.401 
也就是說
如果用dispatch_async回到主隊列

00:31:42.536 --> 00:31:44.972 
該LoadSceneOperation
可能已經不可用

00:31:45.038 --> 00:31:46.240 
系統將會崩潰

00:31:46.807 --> 00:31:50.944 
只是想告訴大家
有時這些捕捉會有點複雜

00:31:51.245 --> 00:31:54.214 
需要一點調查

00:31:54.581 --> 00:31:56.450 
希望內存圖形調試器

00:31:56.517 --> 00:31:58.986 
也能夠幫助你檢查問題

00:32:06.326 --> 00:32:10.397 
現在我們再來講講泄漏和廢棄內存

00:32:10.964 --> 00:32:14.535 
內存圖形調試器是一個調試模式

00:32:14.601 --> 00:32:17.471 
它會暫停 開始對目標應用進行檢查

00:32:17.738 --> 00:32:20.607 
這樣應用就不會繼續運行並改變狀態

00:32:20.674 --> 00:32:22.843 
可以有一個恆定的視圖

00:32:22.910 --> 00:32:25.879 
也可以讓你做一些諸如快速查看的操作
或者PO不同的對象

00:32:25.946 --> 00:32:27.681 
在你進行調查時

00:32:27.748 --> 00:32:30.184 
而且在所有平臺上都可用

00:32:31.018 --> 00:32:33.987 
如我所演示的
共有兩種不同的圖形風格

00:32:34.054 --> 00:32:37.491 
第一種是 根路徑圖形風格

00:32:37.558 --> 00:32:39.426 
它將顯示引用過的內存

00:32:39.493 --> 00:32:40.594 
也許你廢棄了它

00:32:41.028 --> 00:32:45.299 
應用中不同的根 比如全局變量

00:32:45.365 --> 00:32:47.968 
和正在運行的線程
是如何引用該內存的

00:32:48.502 --> 00:32:50.103 
利用漸進展開模式

00:32:50.170 --> 00:32:54.708 
它讓你從對象開始回溯不同的中間對象

00:32:54.775 --> 00:32:57.411 
找到那些不應該存在的引用

00:32:58.679 --> 00:33:02.716 
對未引用或泄露的內存來說
第二種風格是週期視圖

00:33:02.783 --> 00:33:08.989 
其目標是幫助顯示正強引用自身的對象

00:33:09.056 --> 00:33:11.992 
會再一次找出引用問題

00:33:14.127 --> 00:33:18.465 
在查看器裏看到的棧記錄集成

00:33:20.467 --> 00:33:24.438 
它無法自由記錄所有的分配和釋放

00:33:24.505 --> 00:33:27.007 
這是一種需要選擇加入的診斷

00:33:28.709 --> 00:33:31.879 
進入方案編輯器 選中“分配棧記錄”

00:33:31.945 --> 00:33:34.448 
在“診斷”標籤

00:33:34.815 --> 00:33:38.252 
它將記錄所有的磁盤分配和釋放

00:33:38.318 --> 00:33:39.653 
方便之後的查詢

00:33:40.521 --> 00:33:42.189 
但是對於內存圖形調試

00:33:42.256 --> 00:33:44.591 
你不真正需要所有的分配和釋放

00:33:44.658 --> 00:33:49.329 
之前的分配模塊通常也沒什麼用

00:33:49.796 --> 00:33:56.236 
所以在最新的OS中有一個新特性
“實時只分配模式”

00:33:56.303 --> 00:33:59.206 
這樣做開銷較低

00:33:59.673 --> 00:34:02.910 
它還讓你獲得這些有用的信息

00:34:02.976 --> 00:34:04.378 
在進行內存圖形調試時

00:34:04.645 --> 00:34:09.183 
它將把“分配棧記錄”
標識爲“lite”

00:34:09.248 --> 00:34:10.884 
在目標環境下

00:34:13.320 --> 00:34:18.492 
關於內存圖形調試
你們還可能喜歡的一點

00:34:18.559 --> 00:34:21.295 
我們引入.memgraph文件類型

00:34:21.762 --> 00:34:23.830 
當在調試某個問題時

00:34:23.897 --> 00:34:26.867 
你並沒有時間去好好研究

00:34:27.234 --> 00:34:28.768 
你想把它存下來

00:34:28.835 --> 00:34:31.438 
或者讓團隊裏的其他工程師也來看看

00:34:32.105 --> 00:34:35.141 
在Xcode裏
你可以點擊“文件”菜單

00:34:35.208 --> 00:34:37.277 
選擇“導出內存圖形”

00:34:37.710 --> 00:34:39.246 
這將保存所有

00:34:39.313 --> 00:34:41.815 
連接信息和堆信息

00:34:41.882 --> 00:34:45.452 
以及一些VM數據 到一個文件

00:34:45.853 --> 00:34:47.920 
之後某個時間 你可以雙擊它

00:34:47.987 --> 00:34:52.259 
加載到Xcode 看一看內存圖形

00:34:52.960 --> 00:34:55.094 
但是用這種方法 調試器裏沒有進程

00:34:55.161 --> 00:34:58.999 
所以你無法回溯 也無法快速查看對象
無法PO對象

00:34:59.333 --> 00:35:03.504 
但這仍然是出錯後分析應用的
一項非常強大技術

00:35:04.638 --> 00:35:08.642 
如果你想持續集成

00:35:09.576 --> 00:35:11.645 
在命令行中有一些選項

00:35:12.279 --> 00:35:16.316 
只要運行leaks-outputGraph
選擇一個路徑

00:35:16.383 --> 00:35:18.819 
保存到一個.memgraph文件
以便之後使用

00:35:20.020 --> 00:35:24.391 
leaks vmmap heap
都可以讀這個文件

00:35:31.398 --> 00:35:33.133 
好了 到了有趣的部分

00:35:33.200 --> 00:35:34.801 
我們來講講有用的小技巧

00:35:34.868 --> 00:35:37.704 
這一切都建立在泄漏結構上

00:35:38.338 --> 00:35:40.507 
說明圖形是保守的

00:35:41.108 --> 00:35:46.213 
我們非常非常小心
避免在對象沒有泄漏時報告其泄漏

00:35:46.280 --> 00:35:50.350 
避免誤報

00:35:50.918 --> 00:35:53.387 
在圖形裏可能會看到多餘的引用

00:35:54.354 --> 00:35:59.026 
這些引用將被顯示爲灰色 表示未知

00:35:59.092 --> 00:36:01.061 
可能是有效引用 可能不是

00:36:01.361 --> 00:36:04.364 
可能不止提供元數據給工具

00:36:04.731 --> 00:36:10.170 
當你查看這些圖形時 要多多注意

00:36:10.671 --> 00:36:13.173 
提高準確度的一個方法是

00:36:13.240 --> 00:36:14.441 
就是開啓“內存塗鴉”

00:36:14.508 --> 00:36:16.944 
該方案下的另一個診斷工具

00:36:17.311 --> 00:36:20.347 
它的作用是當分配自由

00:36:20.714 --> 00:36:23.851 
它將把內存寫入 你就不用了

00:36:23.917 --> 00:36:27.721 
未初始化的內存寫入新的模塊

00:36:29.590 --> 00:36:31.325 
對於那些已知的強引用來說

00:36:31.391 --> 00:36:33.427 
在圖形裏會粗體顯示

00:36:33.493 --> 00:36:39.233 
Swift 3實際上有
很多可用反射元數據

00:36:39.600 --> 00:36:43.804 
我推薦大家使用

00:36:44.571 --> 00:36:46.940 
因爲它絕對更爲準確

00:36:47.007 --> 00:36:49.476 
在理解捕捉和引用方面

00:36:50.511 --> 00:36:53.113 
最後 我應該關掉內存圖形調試器

00:36:53.180 --> 00:36:55.716 
暫時關閉所有檢查工具

00:36:55.782 --> 00:36:58.785 
比如地址檢查工具
或"Thread Sanitizer線程檢查工具"

00:37:00.087 --> 00:37:01.588 
有很多的信息

00:37:02.222 --> 00:37:04.591 
這是不是一個開始編寫應用的好地方？

00:37:05.092 --> 00:37:07.294 
驗證你的期待吧

00:37:07.794 --> 00:37:10.564 
還有別的某種類型的對象要期待嗎？

00:37:11.164 --> 00:37:13.934 
對象是不是在你想要時被釋放？

00:37:14.601 --> 00:37:17.938 
你的類型還有沒有泄漏？

00:37:18.672 --> 00:37:21.375 
如果你對某一個對象很感興趣

00:37:21.909 --> 00:37:24.378 
目標就是找到一條不應該

00:37:24.444 --> 00:37:25.646 
連到對象上的路徑

00:37:26.079 --> 00:37:29.950 
還有兩種常見模式

00:37:30.017 --> 00:37:32.619 
來自塊和閉包的強捕捉

00:37:33.287 --> 00:37:39.026 
或圖形中潛在的向上引用

00:37:39.359 --> 00:37:41.361 
這些需要被標示爲
“weak”或“unowned”

00:37:42.629 --> 00:37:45.532 
講了很多信息

00:37:46.066 --> 00:37:50.704 
我非常感謝你們的傾聽

00:37:50.771 --> 00:37:54.641 
Xcode 8中
全新改進的可視化工具

00:37:54.842 --> 00:37:56.176 
我們對此非常激動

00:37:56.243 --> 00:38:00.047 
如更好的可視化調試 用視圖調試器

00:38:00.314 --> 00:38:03.750 
用FPS測量以及內存圖形調試器

00:38:03.984 --> 00:38:08.455 
今天就在應用中放手一試
多多解決問題吧