00:00:19.386 --> 00:00:23.724
watchOS 3性能架構設計

00:00:28.395 --> 00:00:32.299
大家下午好 歡迎來到
watchOS 3性能架構設計

00:00:32.799 --> 00:00:34.201
我是Tyler McAtee

00:00:34.334 --> 00:00:36.870
稍後你會看到
我的同事Todd Grooms

00:00:37.371 --> 00:00:40.807
今天我們會討論在Apple
我們思考性能優化的方法

00:00:40.874 --> 00:00:42.976
和我們怎麼樣創建watchOS 3

00:00:43.810 --> 00:00:45.946
我們從2-Second任務開始說

00:00:46.313 --> 00:00:49.449
它是什麼 它對watchOS 3
的設計有什麼幫助和影響

00:00:49.583 --> 00:00:51.752
對你的應用架構意味着什麼

00:00:52.352 --> 00:00:56.356
我還會討論一下
設計策略是怎麼影響性能的

00:00:56.423 --> 00:00:59.126
同時展示一個新的詳細分頁API

00:00:59.193 --> 00:01:01.695
它可以減少不必要的導航時間

00:01:02.930 --> 00:01:05.966
最後 Todd會上臺展示我們如何

00:01:06.033 --> 00:01:08.735
利用這些想法並
應用到watch股票應用上

00:01:09.369 --> 00:01:11.205
我們從2-Second開始

00:01:11.438 --> 00:01:13.841
我們專注於這個理念
作爲經驗法則

00:01:14.074 --> 00:01:16.443
和Apple Watch交互感覺
是怎樣的

00:01:16.510 --> 00:01:17.778
什麼是2-Second任務

00:01:18.612 --> 00:01:21.148
2-Second任務是
用戶想要完成操作

00:01:21.215 --> 00:01:23.083
或看Apple Watch而學習

00:01:23.717 --> 00:01:26.086
這些任務應該在幾秒內完成

00:01:27.988 --> 00:01:29.022
這幾秒應該從

00:01:29.122 --> 00:01:31.692
開始交互到結束衡量

00:01:31.859 --> 00:01:34.695
從用戶擡起手看
Apple Watch開始

00:01:34.761 --> 00:01:35.762
到他們放下手結束

00:01:36.763 --> 00:01:39.466
一些2-Second任務
的例子可能是這樣

00:01:40.033 --> 00:01:43.537
查看通知 設定定時器或者開始鍛鍊

00:01:44.838 --> 00:01:45.873
今天我們會瞭解下

00:01:45.939 --> 00:01:47.875
我們對系統做的一些重要變動

00:01:47.941 --> 00:01:50.477
解釋這將怎麼影響開發者

00:01:50.544 --> 00:01:53.347
思考你的WatchKit應用的性能

00:01:54.982 --> 00:01:58.418
完成一個Apple Watch
任務的第一個瓶頸

00:01:58.485 --> 00:02:01.922
是訪問到相應應用 花費的導航的次數

00:02:02.489 --> 00:02:04.625
Apple Watch上
打開一個應用最快的方法

00:02:04.691 --> 00:02:06.226
是通過點擊一個
complication

00:02:06.894 --> 00:02:09.363
只鼓勵開發者實現一個
complication

00:02:09.429 --> 00:02:11.098
如果他們有相關數據去顯示

00:02:11.765 --> 00:02:15.502
大多程序 例如信息 郵件和手機
並沒有complication

00:02:16.236 --> 00:02:18.605
爲了增加Apple Watch
的可操縱性

00:02:18.772 --> 00:02:21.575
和同時給用戶提供更多選擇去定製化

00:02:21.775 --> 00:02:25.045
現在在watchOS 3上
應用都有complication

00:02:25.879 --> 00:02:28.448
這些啓動complication
對於從錶盤上快速訪問

00:02:28.515 --> 00:02:31.151
你喜歡的應用是很有用的

00:02:31.785 --> 00:02:34.721
對於你的應用
我們也鼓勵你去適應這個規則

00:02:34.788 --> 00:02:37.591
實現一個complication
無論是否有數據顯示

00:02:38.992 --> 00:02:41.728
新的watchOS 3中
我們爲你帶來了dock

00:02:42.563 --> 00:02:45.632
通過按壓側鍵開關
用戶可以調用dock

00:02:45.699 --> 00:02:48.101
且快速瀏覽所有他們最愛的應用程序

00:02:49.236 --> 00:02:52.539
瀏覽這些應用程序是非常快和容易的

00:02:53.507 --> 00:02:56.143
我們想要我們的用戶能夠
使用這些最愛的應用程序

00:02:56.210 --> 00:02:57.678
並且使他們準備好加載好

00:02:57.744 --> 00:02:59.847
而不是必須等待

00:02:59.913 --> 00:03:01.348
因爲這個應用已開始運行了

00:03:01.949 --> 00:03:05.085
在watchOS 3中爲了記錄這些
所有的應用程序

00:03:05.152 --> 00:03:08.055
一個用戶選擇放在錶盤上
或者在他們的dock中

00:03:08.121 --> 00:03:10.657
應用將在系統中
保持運行或暫停在內存中

00:03:11.925 --> 00:03:14.027
這樣當他們和應用程序交互時

00:03:14.094 --> 00:03:16.463
他們只需等待恢復 無需重新啓動

00:03:16.897 --> 00:03:18.966
但是系統只有固定大小的內存

00:03:19.032 --> 00:03:22.169
並且在一個在系統中
應用需要成爲一個好的公民

00:03:22.436 --> 00:03:26.173
因爲最多可以有10個dock應用
5個complications

00:03:26.373 --> 00:03:29.042
同時還有系統應用 進程等等

00:03:30.911 --> 00:03:33.780
你要記得你僅是
龐大生態系統中的一部分

00:03:33.847 --> 00:03:36.550
因此你需要儘可能
只用你需要的資源

00:03:38.519 --> 00:03:40.954
這個系統 因爲生態系統的自然性

00:03:41.088 --> 00:03:43.790
我們的系統提高了固定內存數量的上限

00:03:43.857 --> 00:03:45.526
一個WatchKit
的應用可使用的量

00:03:46.026 --> 00:03:47.160
如果應用超出這個限制

00:03:47.261 --> 00:03:50.163
我們的系統將會終止應用
連哭的機會都不給你

00:03:50.230 --> 00:03:52.733
因此內存可以被其他的程序使用

00:03:53.934 --> 00:03:55.102
限制不是目的

00:03:55.169 --> 00:03:57.070
儘量別用光內存

00:03:57.137 --> 00:03:59.339
事實上 它應該遠不及限制

00:03:59.673 --> 00:04:02.109
現在在watchOS 3上
的限制是30兆字節

00:04:02.176 --> 00:04:04.878
每個WatchKit應用程序
但這個將來可能會改變

00:04:05.779 --> 00:04:08.515
所以有什麼好的技巧控制應用
的內存使用？

00:04:09.149 --> 00:04:11.518
用合適於watch屏幕尺寸的圖片

00:04:11.652 --> 00:04:13.587
這個不僅可以控制內存使用

00:04:13.820 --> 00:04:15.422
而且將會有助於提高整體性能

00:04:15.489 --> 00:04:18.692
{\an2因爲這讓watch不用做
額外去調整圖片大小的工作

00:04:20.527 --> 00:04:24.364
用大小合適的數據集
不要去下載大量的數據集

00:04:24.431 --> 00:04:26.667
如果你只顯示很少的數據在屏幕上

00:04:26.733 --> 00:04:29.236
如果你只顯示一個數據對象的屬性

00:04:29.303 --> 00:04:32.172
不要下載或保存其他屬性

00:04:33.106 --> 00:04:36.009
如果你能控制API下載數據

00:04:36.076 --> 00:04:39.413
讓我們看這個簡單的應用

00:04:39.479 --> 00:04:40.914
因爲watch將可能顯示

00:04:40.981 --> 00:04:42.883
一個更濃縮的信息版本

00:04:43.217 --> 00:04:45.719
這將會幫助節省大量的網絡流量

00:04:45.786 --> 00:04:47.154
你的watch會處理它

00:04:47.221 --> 00:04:49.456
瞬時數據和內存也會減少

00:04:50.290 --> 00:04:53.427
最後 重要的是釋放你不再使用的對象

00:04:53.727 --> 00:04:54.962
花些時間過一遍你的代碼

00:04:55.028 --> 00:04:58.131
並且確定你只保存必需的東西

00:04:58.532 --> 00:05:02.269
因爲用戶選擇的應用
放在他們的錶盤上

00:05:02.336 --> 00:05:05.372
或者在dock中 系統會讓它們
保持存活和懸掛在內存中

00:05:05.839 --> 00:05:08.208
它們更多的是被恢復而不是被啓動

00:05:08.876 --> 00:05:10.410
因爲這個 對於watchOS 3

00:05:10.477 --> 00:05:13.046
我們想要集中優化的關鍵
是恢復時間

00:05:14.047 --> 00:05:16.750
現在應用程序將不經常被恢復

00:05:16.850 --> 00:05:20.187
因爲它們將被保存在內存裏
但也因爲它們在dock裏

00:05:20.787 --> 00:05:23.090
當用戶在dock欄中滑到你的應用

00:05:23.390 --> 00:05:24.925
應用會被恢復

00:05:25.125 --> 00:05:27.995
當用戶滑過應用
應用將會被暫停

00:05:29.463 --> 00:05:32.132
這種經常恢復和暫停的行爲

00:05:32.199 --> 00:05:35.269
是watchos3中應用典型的方式

00:05:36.003 --> 00:05:38.438
理解軟件生命週期中哪一個方法

00:05:38.505 --> 00:05:39.706
用來做主要工作

00:05:39.773 --> 00:05:41.942
哪一個用來做不重要的工作很重要

00:05:42.876 --> 00:05:44.578
來看一下不同的生命週期方法

00:05:44.645 --> 00:05:46.813
在watchKit擴展代理會遇到

00:05:47.581 --> 00:05:50.884
你的代理中看到的第一個方法是
ApplicationDidFinishLaunching

00:05:50.951 --> 00:05:53.086
當程序第一次運行時 它將會被調用

00:05:53.420 --> 00:05:56.456
並且這是一個不錯的地方
來執行應用應用的最終初始化

00:05:56.523 --> 00:05:59.159
像其他任務一樣 這隻需要被執行一次

00:06:00.160 --> 00:06:02.462
在你的代理中接下來看到的是

00:06:02.729 --> 00:06:04.298
applicationDidBecomeActive

00:06:05.032 --> 00:06:09.136
只要你的應用在系統中
變成活躍應用 這個將會被調用

00:06:09.203 --> 00:06:11.171
重新開始任何一個之前被暫停的任務

00:06:11.238 --> 00:06:14.541
或者沒有啓動 只要有需要
將會刷新用戶界面

00:06:15.976 --> 00:06:19.179
一旦應用從活躍變爲非活躍狀態

00:06:19.246 --> 00:06:21.615
applicationWillResignActive會被調用

00:06:22.149 --> 00:06:24.518
這可能因爲某些類型的臨時中斷而發生

00:06:24.585 --> 00:06:26.820
例如一個打進來的電話或者通知

00:06:27.421 --> 00:06:29.923
當用戶按下側鍵來喚醒dock時

00:06:29.990 --> 00:06:31.792
或者當用戶退出你的應用時

00:06:31.859 --> 00:06:34.261
並且它將會過渡到後臺運行狀態

00:06:35.295 --> 00:06:38.232
當你的應用不再活躍並且被調到後臺

00:06:38.332 --> 00:06:40.334
applicationDidEnterBackground將被調用

00:06:40.601 --> 00:06:42.369
當你的應用返回到前臺時

00:06:42.436 --> 00:06:44.938
applicationWillEnterForeground將會被調用

00:06:45.072 --> 00:06:48.008
這些函數只有在程序
從後臺到前臺時纔會被調用

00:06:48.075 --> 00:06:51.278
或者當程序從前臺到後臺
所以在程序第一次啓動時不會被調用

00:06:52.646 --> 00:06:56.550
另外 有些生命週期方法
和接口控制器相關聯

00:06:56.984 --> 00:06:58.352
AwakeWithContext
會被調用

00:06:58.418 --> 00:07:00.921
在你的接口控制器第一次實例化的時候

00:07:00.988 --> 00:07:03.724
這是一個好位置
對那些只需要做一次的工作

00:07:04.424 --> 00:07:07.060
當界面激活時
willActivate將被調用

00:07:07.127 --> 00:07:08.996
或者能夠更新的時候
它將會被調用

00:07:09.062 --> 00:07:11.598
在界面對於用戶確實可見之前

00:07:11.865 --> 00:07:13.734
一旦用戶完全看見界面

00:07:13.800 --> 00:07:15.335
didAppear被調用

00:07:15.636 --> 00:07:18.906
如果你有在恢復時需要做的工作
這些方法是是合適的位置

00:07:19.239 --> 00:07:21.041
如果需要做的比較多 你最好

00:07:21.108 --> 00:07:23.143
把任務分發到後臺的隊列

00:07:23.210 --> 00:07:26.480
這樣這些方法可以完成
並且你的應用能夠完成恢復

00:07:27.981 --> 00:07:30.083
一旦你的應用暫停了

00:07:30.150 --> 00:07:33.053
在接口控制器中
willDisappear將被調用

00:07:33.120 --> 00:07:37.024
當用戶界面不再對用戶可見時

00:07:37.724 --> 00:07:40.928
或者用戶界面無效並且不再更新

00:07:40.994 --> 00:07:43.230
didDeactivate
將會被調用

00:07:43.463 --> 00:07:45.966
這些方法是取消任何繁重任務的地方

00:07:46.033 --> 00:07:48.602
你在willActivate
和didAppear中啓動的任務

00:07:51.672 --> 00:07:53.273
理解這個生命週期非常重要

00:07:53.340 --> 00:07:56.610
並且明白這些方法
可能被重複頻繁的調用

00:07:57.644 --> 00:07:59.179
我想通過一個例子

00:07:59.246 --> 00:08:01.882
一個程序是怎樣遇到這些事件
在它的生命週期中

00:08:02.349 --> 00:08:05.252
我們將會從一個程序開始
爲了這次課程的目的

00:08:05.319 --> 00:08:07.154
程序在前臺和後臺都沒有運行

00:08:07.421 --> 00:08:08.956
當用戶點擊你的應用

00:08:09.022 --> 00:08:11.792
第一個方法將進入到
WatchKit擴展代理中

00:08:11.859 --> 00:08:13.861
didFinishLaunching
和didBecomeActive

00:08:14.228 --> 00:08:16.864
還有接口控制器將會接收到
awakeWithContext

00:08:16.930 --> 00:08:18.465
willActivate
和didAppear

00:08:19.533 --> 00:08:22.503
現在你的應用正在前臺運行
並且是活躍的

00:08:22.703 --> 00:08:25.973
但是當用戶按下側鍵開關
調出dock時會發生什麼呢

00:08:26.573 --> 00:08:30.444
此時你的應用不再是前臺活躍的應用

00:08:30.511 --> 00:08:31.945
這是系統應用

00:08:32.111 --> 00:08:35.082
所以你的代理將會調用
applicationWillResignActive

00:08:37.251 --> 00:08:39.686
當用戶繼續選定你的應用

00:08:39.820 --> 00:08:42.722
程序將會在前臺一直運行
一直在被CPU執行

00:08:42.789 --> 00:08:45.526
更新用戶界面

00:08:45.626 --> 00:08:47.961
一旦用戶滑走你的應用

00:08:48.028 --> 00:08:49.930
系統將會懸掛你的應用

00:08:50.097 --> 00:08:53.500
所以你的界面控制器將會調用
willDisappear和didDeactivate

00:08:53.567 --> 00:08:55.903
並且應用的didEnterBackground會被調用

00:08:58.005 --> 00:09:00.974
現在這裏你的應用剛進入後臺

00:09:01.041 --> 00:09:02.910
因此係統可能喚起你的應用

00:09:02.976 --> 00:09:04.611
爲了一個後臺快照任務

00:09:04.912 --> 00:09:08.382
瞭解更多這些快照任務
看看我們今早的課程

00:09:08.448 --> 00:09:10.217
保持你的watch
應用持續更新

00:09:10.651 --> 00:09:13.987
你的設備接口控制器被
willActivate和didAppear激活

00:09:14.054 --> 00:09:17.357
在你的代理把機會給
handleBackgroundTasks之前

00:09:17.824 --> 00:09:21.361
然後你的接口控制器會調用
willDisappear和didDeactivate

00:09:22.062 --> 00:09:25.732
現在你的應用被完全暫停
並且應用將執行它的後臺任務

00:09:25.999 --> 00:09:28.068
一旦用戶滑回你的應用

00:09:28.168 --> 00:09:30.504
程序將會調用applicationWillEnterForeground

00:09:30.571 --> 00:09:32.072
還有willActivate
和didAppear

00:09:33.674 --> 00:09:37.144
你的應用再次運行
同時進入dock的前臺中

00:09:37.644 --> 00:09:39.746
直到用戶點進你的應用

00:09:39.813 --> 00:09:41.882
你的應用纔會變成前臺中活躍的應用

00:09:41.949 --> 00:09:44.184
並且調用applicationDidBecomeActive

00:09:45.352 --> 00:09:47.988
從用戶進入到dock時
發生了大量的事情

00:09:48.055 --> 00:09:50.557
自從用戶滑出應用又滑回應用

00:09:50.924 --> 00:09:53.861
這就是爲什麼
理解程序的生命週期很重要

00:09:53.927 --> 00:09:55.629
就像用戶瀏覽他們的dock

00:09:55.696 --> 00:09:59.099
你的應用可能重複頻繁的遇到這些事件

00:10:01.034 --> 00:10:03.403
還有什麼其他技巧
能縮短恢復時間

00:10:04.538 --> 00:10:07.708
你應該用discretion
當更新WKInterface對象時

00:10:07.774 --> 00:10:10.644
你每次給WKInterface對象
設置一個屬性

00:10:10.711 --> 00:10:12.446
系統會創造一個信息來發送

00:10:12.613 --> 00:10:15.983
將它打包 並且分發到
應用進程中UI正在被更新的位置

00:10:16.583 --> 00:10:19.853
那可能是臨時的
在你的應用上來建立一些方法

00:10:19.920 --> 00:10:22.990
更新應用的UI
且在每次恢復的時候調用

00:10:23.123 --> 00:10:25.125
但是設置每一個屬性需要花費時間

00:10:25.225 --> 00:10:26.860
哪怕屬性不會改變

00:10:26.927 --> 00:10:30.330
這導致了在應用和擴展間不必要的溝通

00:10:31.565 --> 00:10:33.534
僅設置這些屬性是值得的

00:10:33.600 --> 00:10:35.602
若屬性變了
那你必須這麼做

00:10:38.472 --> 00:10:42.409
你需要注意WKInterfaceTable
和UITableView的不同

00:10:42.809 --> 00:10:45.712
手機有大量的內存來存儲大量的信息

00:10:45.946 --> 00:10:47.748
UITableView
做了專門的優化

00:10:47.814 --> 00:10:50.050
當在這些比較大的數據集上快速滑動時

00:10:50.184 --> 00:10:53.153
cells被按需創建
當你滑動時會被重新使用

00:10:53.921 --> 00:10:55.622
然而用
WKInterfaceTable

00:10:55.689 --> 00:10:58.425
所有的cells被提前創建
並且不會被重新使用

00:10:58.492 --> 00:11:00.294
所以watch需要做的工作

00:11:00.360 --> 00:11:02.563
和表格的大小呈正相關

00:11:02.996 --> 00:11:06.533
由於這個原因控制
WKInterfaceTable的大小非常重要

00:11:06.834 --> 00:11:08.468
watch不合適這種類型

00:11:08.535 --> 00:11:10.270
翻閱數以百計的記錄

00:11:10.337 --> 00:11:11.705
事實上 我們發現最好

00:11:11.772 --> 00:11:15.008
WKInterfaceTable
大小保持20出頭

00:11:17.177 --> 00:11:19.279
你的應用應該避免重新加載一個
WKInterfaceTable

00:11:19.346 --> 00:11:20.814
無論如何

00:11:21.782 --> 00:11:23.350
這是一個耗費資源的操作

00:11:23.717 --> 00:11:26.153
它可能嘗試重新加載整個表

00:11:26.220 --> 00:11:28.555
在恢復或數據集改變時

00:11:28.622 --> 00:11:30.257
但若你需要添加或移動一些行

00:11:30.324 --> 00:11:32.793
最好用插入和刪除API

00:11:35.662 --> 00:11:37.431
我現在想談一些設計方面的

00:11:37.931 --> 00:11:41.101
想想適合watch的信息展示方式

00:11:41.168 --> 00:11:44.271
好的展示方式對性能也很有幫助

00:11:45.572 --> 00:11:49.276
在watchos 3中
你應把應用設計成可以掃着看的

00:11:49.710 --> 00:11:55.449
dock讓用戶可快速訪問收藏的應用

00:11:55.682 --> 00:11:58.852
你的應用可能只會被大體的掃一下

00:11:58.919 --> 00:12:01.688
當用戶從一個應用滑到另一個的時候

00:12:01.889 --> 00:12:04.491
集中顯示最重要的信息

00:12:04.558 --> 00:12:06.426
並儘量清晰的顯示

00:12:07.327 --> 00:12:11.532
根據特定的目的來設計
可以讓應用變得更利於掃視

00:12:12.065 --> 00:12:14.034
watch不是合適的載體

00:12:14.101 --> 00:12:16.136
對於瀏覽大量的內容

00:12:16.503 --> 00:12:18.438
或者查看複雜的數據繼承

00:12:19.473 --> 00:12:21.642
通過僅展示最基礎的信息

00:12:21.708 --> 00:12:23.977
同時你會得到更好的性能

00:12:24.244 --> 00:12:27.314
由於你展示更少的信息
可以節省處理器和內存

00:12:27.381 --> 00:12:29.449
同時保持更新時需要更少的網絡請求

00:12:31.585 --> 00:12:33.787
最後 導航也很重要

00:12:34.054 --> 00:12:37.090
我已經講了很多關於我們如何在
系統層面提升導航了

00:12:37.157 --> 00:12:40.561
在應用層面考慮這些同樣很重要

00:12:41.094 --> 00:12:43.597
爲了幫助實現這些
我們引進了一個新的

00:12:44.331 --> 00:12:46.266
詳細分頁API

00:12:46.834 --> 00:12:51.538
WatchKit應用的
一個標準配置是繼承數據視圖

00:12:51.738 --> 00:12:53.707
你有一個表格

00:12:53.874 --> 00:12:56.810
點擊其中一個單元
進入這個項目的詳細

00:12:57.010 --> 00:12:58.245
這種設置的問題是

00:12:58.312 --> 00:13:00.480
如果你想瀏覽多個項目的詳細

00:13:00.547 --> 00:13:02.883
你需要後退好多次

00:13:03.584 --> 00:13:05.986
爲了解決這個問題
新的詳細分頁API

00:13:06.053 --> 00:13:08.822
可以讓我們快速的瀏覽
從一個詳細視圖到另一個

00:13:09.089 --> 00:13:12.359
通過從屏幕上滑動或者
旋轉數字表冠

00:13:13.293 --> 00:13:15.562
爲了瞭解在代碼中如何設置這些API

00:13:15.629 --> 00:13:18.432
同時學習其他快速交互技術

00:13:18.498 --> 00:13:19.900
我們向開發者發佈的

00:13:19.967 --> 00:13:23.670
請查閱昨天的
“watchOS快速交互技巧”演講

00:13:24.705 --> 00:13:27.741
在本次演講中 我想說說這些API

00:13:27.808 --> 00:13:30.344
的視圖控制器生命週期

00:13:30.444 --> 00:13:32.613
從視圖的性能方面這很重要

00:13:33.080 --> 00:13:36.750
所以這裏我們有一個有三個單元的表格
紅的 橘黃的 黃的

00:13:37.251 --> 00:13:39.353
詳細分頁API觸發segue

00:13:39.419 --> 00:13:41.822
從內部表到接口控制器

00:13:41.889 --> 00:13:44.591
當你點擊其中的一個單元
我們會觸發一個segue

00:13:45.058 --> 00:13:47.427
當你點擊這個單元
你的主接口控制器

00:13:47.494 --> 00:13:51.331
將會調用contextForSegue:withIdentifier:inTable方法

00:13:52.165 --> 00:13:54.868
你可以在這裏創建上下文對象傳遞給

00:13:54.935 --> 00:13:57.938
詳細視圖控制器和
awakeWithContext方法

00:13:58.438 --> 00:14:00.407
你的主視圖控制器不會只接到它的調用

00:14:00.474 --> 00:14:03.977
你點擊的單元
而是表格每一個單元

00:14:04.778 --> 00:14:07.748
我們爲每一個詳細視圖控制器
都準備了上下文

00:14:07.814 --> 00:14:10.250
所以當我們準備上下文的時候

00:14:10.317 --> 00:14:12.219
我們可以提前實例化

00:14:12.486 --> 00:14:14.721
那樣的話 當用戶點擊第一個的時候

00:14:14.788 --> 00:14:16.890
可以在所有的單元間快速的滑動

00:14:20.327 --> 00:14:22.496
你的第一個視圖控制器

00:14:22.563 --> 00:14:24.698
會是第一個調用
awakeWithContext

00:14:24.765 --> 00:14:27.601
包括willActivate
和didAppear

00:14:28.001 --> 00:14:30.470
這個是滑動試圖最有意思的部分

00:14:30.804 --> 00:14:34.007
我們讓控制器接近
這個選擇的詳細視圖控制器

00:14:34.274 --> 00:14:36.610
然後用戶可以滑動到下一個

00:14:36.944 --> 00:14:38.779
其他的顏色進入他們的生命週期方法

00:14:38.846 --> 00:14:40.013
會一樣調用

00:14:40.714 --> 00:14:43.116
他們會首先調用
awakeWithContext

00:14:44.251 --> 00:14:46.820
然後是willActivate和
didDeactivate

00:14:50.023 --> 00:14:51.825
如何設置工作很重要

00:14:51.892 --> 00:14:53.660
對那些還沒有渲染的視同控制器

00:14:54.027 --> 00:14:57.631
不要盲目的啓動耗費CPU的任務

00:14:57.698 --> 00:15:01.468
這可能導致CPU處理不過來

00:15:01.535 --> 00:15:03.170
如果你有很多表格單元的話

00:15:03.604 --> 00:15:05.839
當用戶從一個詳細視圖
滑動到另一個的時候

00:15:06.039 --> 00:15:09.977
你之前的接口控制器會是第一個調用
willDisappear

00:15:10.811 --> 00:15:13.547
willActivate didDeactivate
和didAppear

00:15:14.147 --> 00:15:16.683
這使你的接口控制器維持一致的狀態

00:15:16.817 --> 00:15:19.820
那些最近展示到屏幕
上的調用didAppear

00:15:19.887 --> 00:15:23.690
那些最近離開屏幕的調用
didDeactivate

00:15:24.324 --> 00:15:25.459
當你點擊後退

00:15:25.526 --> 00:15:29.229
回到主控制界面 只有一個控制器

00:15:29.296 --> 00:15:31.899
需要用生命週期方法調用它
並且它是可視的

00:15:31.965 --> 00:15:34.568
應用調用willDisappear
和didDeactivate

00:15:37.104 --> 00:15:39.306
當然 我想要邀請Todd去談論這些

00:15:39.373 --> 00:15:42.409
我們如何應用這些想法到我們的
Stocks WatchKit應用

00:15:42.743 --> 00:15:43.577
謝謝

00:15:55.756 --> 00:15:56.690
下午好

00:15:57.357 --> 00:15:59.126
我是一個watch OS的工程師

00:15:59.193 --> 00:16:03.363
我們把Stocks作爲一個案例研究
面向WatchKit和開發者

00:16:04.431 --> 00:16:05.899
你們中大多數可能不知道這個

00:16:05.966 --> 00:16:08.468
但Stocks是用WatchKit
建立的watch應用

00:16:08.836 --> 00:16:11.605
在Apple我們想要有第一手的經驗

00:16:11.672 --> 00:16:14.408
在WatchKit開發中
我們感覺Stocks

00:16:14.474 --> 00:16:16.910
將會是WatchKit開發中
一個很棒的應用方案

00:16:19.313 --> 00:16:21.782
今天我有三個想要討論的主題

00:16:21.849 --> 00:16:24.117
關於Stocks和
WatchKit開發

00:16:24.718 --> 00:16:28.655
我將要去分辨Stocks中的
2-Second任務

00:16:29.256 --> 00:16:32.259
之後我將要討論一些實現的細節

00:16:32.326 --> 00:16:34.895
在我們的後臺刷新用例中

00:16:36.797 --> 00:16:40.367
最後 我將要說一些關於我們做的優化

00:16:40.534 --> 00:16:44.905
通過擴展優化恢復時間
啓動時間

00:16:46.507 --> 00:16:49.910
因此 我們將從2-Second任務開始

00:16:51.879 --> 00:16:53.146
我們思考Stocks時

00:16:53.647 --> 00:16:56.149
我們想到三個重要的
2-Second任務

00:16:56.750 --> 00:16:59.186
第一個是你很可能喜歡想要看的

00:16:59.253 --> 00:17:02.256
一個最愛的股票現在的價格是如何的

00:17:03.156 --> 00:17:06.260
這可以用一個
complication實現

00:17:07.027 --> 00:17:08.295
但是在dock

00:17:08.428 --> 00:17:11.832
我們能夠得到一點
2-Second任務的細節

00:17:12.132 --> 00:17:15.502
特別地 我想到另一個
2-Second任務

00:17:15.801 --> 00:17:19.039
想看看你最愛的股票的流通表現

00:17:19.106 --> 00:17:20.874
通過日線圖

00:17:22.009 --> 00:17:25.646
最後 我們認爲很重要的是 你能看見

00:17:25.712 --> 00:17:28.015
一些股票的當前價格

00:17:29.449 --> 00:17:31.185
我們從complication說起

00:17:31.618 --> 00:17:34.054
當然 complication
是最快的

00:17:34.454 --> 00:17:37.191
在你的watch上察看數據的方法

00:17:37.891 --> 00:17:39.626
數據總是最新的

00:17:39.693 --> 00:17:42.763
你每次從watch上看時間
也能看到它們

00:17:44.264 --> 00:17:46.700
這裏最重要的一點
在watchOS 3中

00:17:46.767 --> 00:17:51.605
是數據在complication
和應用之間是同步的

00:17:52.372 --> 00:17:54.308
想要了解更多的信息

00:17:54.374 --> 00:17:57.878
可以去看看“讓你的Watch應用
保持更新”的演講

00:17:58.078 --> 00:17:59.346
今天早上開始的這個課程

00:18:01.682 --> 00:18:03.016
現在我們將要開始討論

00:18:03.083 --> 00:18:07.020
一些其他的2-Second任務是
如何在watchOS 2表現的

00:18:08.488 --> 00:18:11.658
所以在watchOS 2中
你可以啓動Stocks

00:18:12.025 --> 00:18:14.862
並且你可以看到現在的股票價格

00:18:14.928 --> 00:18:17.564
你感興趣的或者其他的股票

00:18:18.265 --> 00:18:21.401
如果你想看到其他其他的股票
在一天中的表現情況

00:18:21.468 --> 00:18:24.638
你需要點一下那個股票
現在你可以看見了

00:18:24.705 --> 00:18:28.175
這是一點小信息
但是它還是沒有回答

00:18:28.242 --> 00:18:31.211
一天股票價格是怎麼被展示的

00:18:31.645 --> 00:18:33.080
所以 如果你想知道

00:18:33.146 --> 00:18:35.983
你得向下滾動一點
現在你在圖表上了

00:18:37.084 --> 00:18:40.420
我們有四個選項 關於這個列表
我們有一天的間隔

00:18:40.487 --> 00:18:43.357
一週 一個月 半年

00:18:43.891 --> 00:18:46.059
你第一次可能滾動到這裏

00:18:46.126 --> 00:18:48.929
你甚至不能看到你關心的間隔

00:18:48.996 --> 00:18:51.031
那可能是一天的間隔

00:18:52.165 --> 00:18:55.335
因此這需要你點擊這些小按鈕

00:18:55.536 --> 00:18:57.404
並且打開那個圖表

00:18:58.172 --> 00:18:59.273
之後

00:18:59.339 --> 00:19:02.576
你將從下面獲取其他的元數據

00:19:02.643 --> 00:19:05.179
其實大量的時間並不是必要的

00:19:05.245 --> 00:19:08.015
當你瞥一眼今天的信息

00:19:09.149 --> 00:19:11.251
當然 如果你想看多個股票

00:19:11.318 --> 00:19:12.920
他們一天是如何表現的

00:19:12.986 --> 00:19:15.656
你得向前瀏覽 點進一個新的去

00:19:15.722 --> 00:19:18.125
很像剛剛Tyler
在動畫中給你們展示的

00:19:19.326 --> 00:19:21.261
讓我們看看watchOS 3

00:19:22.062 --> 00:19:24.865
這是新的watchOS 3設計
正如你看到的

00:19:24.932 --> 00:19:28.001
首先 仍然是一個你們可以進入的列表

00:19:28.535 --> 00:19:31.471
但是字體變大了 更易讀了

00:19:31.538 --> 00:19:33.207
一點簡化的接口

00:19:33.273 --> 00:19:37.044
對我來說很好
並且小字體也很容易讀

00:19:37.110 --> 00:19:38.445
像你在dock中看的

00:19:39.613 --> 00:19:42.382
如果你想看看apple今天怎麼樣

00:19:42.449 --> 00:19:45.452
該怎麼操作
你會再一次點擊Apple

00:19:45.953 --> 00:19:47.988
但現在你在那裏看到了表格

00:19:48.222 --> 00:19:51.225
同時我們假設你總是想看日線圖

00:19:52.092 --> 00:19:54.795
也有例外 沒有日線圖

00:19:55.095 --> 00:19:57.297
像基金沒有日線圖

00:19:57.764 --> 00:20:00.067
我們可以回退到一個月的圖表

00:20:00.133 --> 00:20:01.468
當我們瀏覽它

00:20:01.702 --> 00:20:05.105
這可能是你更期望的一目瞭然的間隔

00:20:07.441 --> 00:20:10.410
我們同時去掉了
下面分鐘的詳細信息

00:20:10.878 --> 00:20:12.846
這讓我們獲得兩個好處

00:20:12.980 --> 00:20:17.751
一個是 去掉了一個網絡請求
加快了加載性能

00:20:18.919 --> 00:20:23.257
第二個是 我們可以使用新的垂直
詳細分頁API

00:20:23.490 --> 00:20:26.693
那樣的話 你可以瀏覽多個股票

00:20:26.860 --> 00:20:30.330
可以通過旋轉數字表冠
或者用手指輕掃

00:20:31.031 --> 00:20:34.101
當然 如果你想查看股票的詳細信息

00:20:34.735 --> 00:20:36.837
像以前的分鐘信息

00:20:36.904 --> 00:20:39.273
比如52周最高 52周最低

00:20:39.840 --> 00:20:41.608
你可以使用Handoff

00:20:42.209 --> 00:20:44.144
通過Handoff

00:20:44.278 --> 00:20:48.949
你可以設置一個上下文
然後把它轉移到iPhone上

00:20:49.449 --> 00:20:52.653
所以我們感覺watch是
大體瀏覽數據的地方

00:20:53.187 --> 00:20:56.790
iPhone纔是瀏覽 像一個視圖

00:20:56.857 --> 00:20:59.793
詳細和複雜的數據的地方

00:21:01.662 --> 00:21:03.830
好的是新的設計 像我剛纔說的

00:21:03.897 --> 00:21:05.432
在dock上是易讀的

00:21:06.266 --> 00:21:08.535
通過dock

00:21:08.602 --> 00:21:12.039
我們決定重新評估對於股票
我們應該在dock顯示什麼

00:21:12.639 --> 00:21:14.341
如果你參加了其他的一些課程

00:21:14.408 --> 00:21:18.345
你會注意到有一個理念默認狀態
和一個快照

00:21:20.113 --> 00:21:22.516
這表示這應該是一個粘性的視圖

00:21:22.816 --> 00:21:25.419
粘性的意思是當你離開股票應用時

00:21:25.485 --> 00:21:27.120
如果你正在看股票列表

00:21:27.387 --> 00:21:29.990
當你回到股票 無論從dock中或者

00:21:30.057 --> 00:21:32.292
通過應用進入

00:21:32.459 --> 00:21:34.027
你還會看到股票列表

00:21:34.862 --> 00:21:36.897
這個視圖我們會持續更新

00:21:36.964 --> 00:21:37.965
在這一天中

00:21:38.966 --> 00:21:42.803
然而 如果你點擊進入股票詳細

00:21:42.870 --> 00:21:46.940
然後返回dock或進入應用

00:21:47.841 --> 00:21:49.343
你將會看到詳細視圖

00:21:49.710 --> 00:21:51.345
這裏有一個需要注意的地方

00:21:52.079 --> 00:21:55.415
在股票中你設置complication股票

00:21:55.782 --> 00:21:58.752
你可以看到的股票
在你的complication

00:21:58.819 --> 00:22:01.722
我們這麼做是這很可能是你喜歡的股票

00:22:02.155 --> 00:22:03.524
一旦你設置了它

00:22:03.590 --> 00:22:05.926
這將是我們返回給你的詳細視圖

00:22:06.260 --> 00:22:07.728
如果你打開股票

00:22:07.794 --> 00:22:11.131
你從Apple瀏覽到
Facebook

00:22:11.532 --> 00:22:13.901
然後回到桌面

00:22:14.935 --> 00:22:16.036
差不多一個小時內

00:22:16.103 --> 00:22:19.439
當我們返回快照默認狀態標識時

00:22:20.073 --> 00:22:22.309
我們會回到Apple的股票

00:22:22.543 --> 00:22:23.777
我們這樣做是因爲

00:22:23.844 --> 00:22:26.547
你已選擇了它作爲
你的complication股票

00:22:26.847 --> 00:22:28.215
然後將會是你的收藏股票

00:22:28.282 --> 00:22:30.317
這個是我們想要返回給你的

00:22:30.384 --> 00:22:32.553
我們有一個可預期的體驗

00:22:32.619 --> 00:22:34.521
總是返回用戶期望看到的東西

00:22:34.588 --> 00:22:37.191
在過一段時間後

00:22:38.792 --> 00:22:43.130
讓我們概括下關於股票
我們做了什麼2-Second任務

00:22:43.397 --> 00:22:44.231
第一件事是

00:22:46.099 --> 00:22:50.737
我們要保證應用和complication間的數據一致性

00:22:51.738 --> 00:22:52.573
另一個是

00:22:52.873 --> 00:22:54.274
我們簡化了我們的設計

00:22:54.541 --> 00:22:57.411
我們在減小大小的同時
讓它變得更清晰易讀

00:22:58.278 --> 00:23:00.747
更易用

00:23:01.181 --> 00:23:05.219
無論何時你通過
詳細分頁API垂直滾動

00:23:05.619 --> 00:23:09.189
可以快速的讓你查看多個股票

00:23:09.456 --> 00:23:11.792
替代以前的來回拖拽

00:23:13.060 --> 00:23:15.762
接下來 我們講一下後臺刷新

00:23:16.463 --> 00:23:18.065
我會多講一下

00:23:18.131 --> 00:23:20.934
我們如何實現股票的後臺刷新

00:23:25.873 --> 00:23:28.675
當我們開始實現股票中的後臺刷新

00:23:28.876 --> 00:23:30.277
我們需要考慮兩個問題

00:23:30.611 --> 00:23:31.445
第一

00:23:31.845 --> 00:23:34.915
我們需要一個什麼樣的頻率
來更新股票中的信息

00:23:36.049 --> 00:23:40.320
第二我們需要獲取什麼樣的
數據來更新應用

00:23:42.489 --> 00:23:45.392
決定我們應該多久刷新下股票的數據

00:23:45.659 --> 00:23:47.461
有一點取巧的意思

00:23:48.195 --> 00:23:51.965
首先我們感覺每15分鐘更新一次
看起來不錯

00:23:54.301 --> 00:23:57.571
這將會使應用在一天中更新好多次

00:23:57.638 --> 00:24:02.709
但是其中很多時候的更新都沒有用

00:24:02.976 --> 00:24:06.980
像當每天結束或者週末閉盤的時候

00:24:08.815 --> 00:24:10.717
讓我們參考下已知的一些事實情況

00:24:10.784 --> 00:24:13.820
因爲我們感覺可以更好的實現它

00:24:13.921 --> 00:24:16.790
首先 股市只在每天的特定時間開盤

00:24:17.157 --> 00:24:19.760
例如 我們訂閱了一個

00:24:19.826 --> 00:24:21.195
紐交所的股票

00:24:22.196 --> 00:24:23.397
同時我們知道

00:24:23.463 --> 00:24:26.166
紐交所在東部時間早上9:30開盤

00:24:26.533 --> 00:24:28.669
並且會在東部時間下午4點閉盤

00:24:29.269 --> 00:24:31.905
如果我們限制了後臺刷新請求

00:24:31.972 --> 00:24:35.142
僅當股市開盤時

00:24:35.409 --> 00:24:38.045
我們可以減少更新次數

00:24:38.846 --> 00:24:41.949
可以節省出資源給其他應用

00:24:43.483 --> 00:24:45.185
同時也會讓我們受益

00:24:45.285 --> 00:24:48.422
不用多次更新我們的應用
和complication

00:24:49.323 --> 00:24:51.058
它會很沒效率

00:24:51.758 --> 00:24:53.293
同時這樣也很好

00:24:58.632 --> 00:25:01.068
讓我們看一點我們怎麼實現的僞代碼

00:25:01.134 --> 00:25:04.638
我們如何判斷何時需要進行下一次刷新

00:25:05.606 --> 00:25:08.475
首先 我們會遍歷我們的股票列表

00:25:09.943 --> 00:25:16.617
然後我們檢查股市是不是都關閉了

00:25:16.683 --> 00:25:18.719
因爲如果我們知道股市都閉盤了

00:25:18.785 --> 00:25:22.656
我們想知道股票列表中的
下一個最近的開盤時間

00:25:23.524 --> 00:25:26.093
不然的話 這表示
至少有一個股市是開着的

00:25:26.360 --> 00:25:28.962
那我們就需要15分鐘刷新一次了

00:25:30.564 --> 00:25:32.199
我們看一點源代碼

00:25:32.900 --> 00:25:34.401
首先大家需要注意

00:25:34.468 --> 00:25:36.303
一個函數 我們在股票應用中用來

00:25:36.370 --> 00:25:38.238
在後臺定時刷新

00:25:38.572 --> 00:25:40.374
在特定的時間裏

00:25:42.376 --> 00:25:47.814
我們用的是WKExtension中
的scheduleBackgroundRefresh方法

00:25:48.282 --> 00:25:51.418
我們會傳入
preferredDate

00:25:52.486 --> 00:25:54.922
這個preferredDate是在
應用中的其他地方計算的

00:25:55.055 --> 00:25:57.424
代表我們的後臺計劃刷新時間

00:25:57.491 --> 00:25:59.860
我們從最後往前看一下

00:26:01.295 --> 00:26:04.998
我們看看在nextPreferredRefreshDate裏有什麼

00:26:06.099 --> 00:26:08.569
這個函數的開始有個guard

00:26:08.702 --> 00:26:13.874
我們會調用earliestNextOpenDateInStocks

00:26:15.442 --> 00:26:17.177
如果返回nil

00:26:18.412 --> 00:26:20.047
我們繼續往前

00:26:20.214 --> 00:26:22.983
因爲在earliestNextOpenDateInStocks中

00:26:23.050 --> 00:26:26.320
如果列表中沒有股票我們會返回nil

00:26:26.520 --> 00:26:29.223
因爲這時候 做後臺刷新沒有用

00:26:29.289 --> 00:26:30.924
因爲沒有數據刷新

00:26:33.060 --> 00:26:37.598
我們接着往下並且計算下一個
nextRegularRefreshDate

00:26:37.698 --> 00:26:40.234
剛好是更新頻率 每15分鐘一次

00:26:41.502 --> 00:26:43.737
最後我們在這裏檢查

00:26:43.804 --> 00:26:46.373
所以 我們用earliestNextOpenDateInStocks

00:26:46.773 --> 00:26:51.111
我們會和nextRegularRefreshDate做時間比較

00:26:52.179 --> 00:26:54.448
現在我們的earliestNextOpenDateInStocks

00:26:54.515 --> 00:26:58.085
也會多了一個返回
distantPast

00:26:58.585 --> 00:27:01.154
如果我們的任何一支股票正在開盤

00:27:01.488 --> 00:27:06.226
這段代碼中後面的時間會
一直是固定的刷新時間

00:27:08.362 --> 00:27:11.131
我們看看earliestNextOpenDateInStocks方法

00:27:11.965 --> 00:27:13.967
首先我們將獲取我們的股票列表

00:27:14.234 --> 00:27:16.270
然後做檢查

00:27:17.504 --> 00:27:20.507
如果這裏還是0
我們會退出 返回nil

00:27:20.574 --> 00:27:23.043
這時後臺刷新沒有用

00:27:25.379 --> 00:27:29.183
然後我們遍歷我們列表中的股票

00:27:31.785 --> 00:27:35.689
如果任何其中一個開盤

00:27:36.089 --> 00:27:38.392
我們會提前返回
distantPast

00:27:39.126 --> 00:27:41.195
不然的話我們將檢查

00:27:41.461 --> 00:27:45.232
我們會遍歷列表找到
earliestNextOpenDate

00:27:46.066 --> 00:27:48.702
我的意思是 我想展示一些代碼

00:27:49.269 --> 00:27:52.606
因爲我們認爲這是限制後臺刷新

00:27:52.673 --> 00:27:55.709
次數的很好的方式
不用全部的代碼

00:27:59.613 --> 00:28:02.149
我們說說多個後臺請求調度

00:28:02.716 --> 00:28:03.917
因爲特別對股票來說

00:28:03.984 --> 00:28:06.987
我們需要在兩個地方保持應用數據更新

00:28:07.354 --> 00:28:08.522
我們需要在終點A

00:28:08.589 --> 00:28:11.792
保持應用數據更新

00:28:11.859 --> 00:28:14.695
我們還需要終點B
更新complication

00:28:17.331 --> 00:28:20.567
所以如果我們計劃後臺刷新時間

00:28:20.901 --> 00:28:21.735
我們這麼做

00:28:22.102 --> 00:28:24.605
我們一旦收到處理後臺任務

00:28:25.172 --> 00:28:28.242
我們會提交終端A的請求
提交終端B的請求

00:28:28.509 --> 00:28:31.044
我們會計劃我們未來後臺刷新時間

00:28:31.111 --> 00:28:32.813
它看起來是什麼樣的
好的...

00:28:33.046 --> 00:28:36.650
在WKExtension代理中
我們有處理後臺任務的方法

00:28:37.718 --> 00:28:40.754
我們會遍歷這些後臺任務

00:28:41.889 --> 00:28:43.590
我們會首先檢查

00:28:43.657 --> 00:28:45.325
是否是一個應用刷新任務

00:28:45.759 --> 00:28:49.396
如果是 我們會進行和
計劃那些數據更新請求

00:28:49.463 --> 00:28:53.066
在那裏我們進行我們的NSURL請求

00:28:54.434 --> 00:28:57.437
接着我們會計劃下一次後臺刷新時間

00:28:57.504 --> 00:29:00.073
使用nextPreferredRefreshDate

00:29:01.575 --> 00:29:03.610
然後我們會完成我們的應用刷新任務

00:29:04.545 --> 00:29:06.046
最後一部分
大家需要注意的是

00:29:06.113 --> 00:29:08.348
這個URL會話後臺刷新任務

00:29:08.415 --> 00:29:09.650
你會得到其中的一個

00:29:09.983 --> 00:29:13.787
當你觸發一個後臺NSURL會話調用

00:29:14.288 --> 00:29:16.757
我們需要把它先存到某個地方

00:29:16.823 --> 00:29:20.460
我們會稍後完成它無論請求何時結束

00:29:24.031 --> 00:29:26.400
現在我們討論過了它
我們看看 它看起來啥樣

00:29:26.466 --> 00:29:28.402
當我們觸發那些NSURL請求

00:29:28.468 --> 00:29:29.469
在一個高的層級

00:29:29.770 --> 00:29:34.575
我們安排那些請求
然後當那些請求結束了

00:29:35.242 --> 00:29:38.078
我們會計劃一個快照
重新加載complication

00:29:38.145 --> 00:29:40.781
當我們將要完成我們的後臺刷新任務

00:29:42.382 --> 00:29:43.383
第一件事

00:29:43.450 --> 00:29:46.653
我們會設置應用數據請求
和complication數據請求

00:29:47.554 --> 00:29:49.790
然後我們設置我們的完成更新處理函數

00:29:49.857 --> 00:29:53.794
現在完成更新處理函數僅僅是

00:29:53.861 --> 00:29:57.431
一個我設置的塊
無論何時NSURL會話

00:29:57.497 --> 00:30:01.468
的完成後臺請求代理方法被調用

00:30:01.535 --> 00:30:03.504
我就能調用那個完成更新處理函數

00:30:03.804 --> 00:30:06.507
這是那個塊裏面的所有內容

00:30:09.409 --> 00:30:10.878
然後我們有一個
submitRequest

00:30:10.944 --> 00:30:13.547
作用就是開始這個網絡請求

00:30:13.614 --> 00:30:15.482
同時調用這個任務的恢復

00:30:16.984 --> 00:30:21.388
一旦該任務完成了 我們可從
urlSessionTasks裏得到該任務

00:30:21.455 --> 00:30:22.756
它是一個字典

00:30:23.457 --> 00:30:26.293
我們會計劃快照
重新加載complication

00:30:26.727 --> 00:30:29.796
我們繼續然後完成那個URL會話任務

00:30:32.866 --> 00:30:37.004
最後我要調用的是
urlSessionDidFinishEvents

00:30:37.070 --> 00:30:40.407
爲了給你展示
無論何時你的請求完成了

00:30:40.474 --> 00:30:45.179
我們會從會話配置裏得到標識

00:30:45.579 --> 00:30:47.281
然後我們請求我們的
finishUpdateHandler

00:30:47.948 --> 00:30:49.650
這個給你一個線索

00:30:49.716 --> 00:30:53.187
如何同時運行多個請求
保持你的應用更新

00:30:53.253 --> 00:30:56.156
如果你的應用和
complication有不同的請求

00:30:56.723 --> 00:30:59.593
第一件事
明顯是你想優化

00:30:59.660 --> 00:31:01.862
調用你應用的更新頻率是多少

00:31:01.929 --> 00:31:03.497
當你做後臺刷新時

00:31:03.864 --> 00:31:05.832
這是第一目標

00:31:06.767 --> 00:31:09.336
如果你從服務器上更新數據

00:31:09.403 --> 00:31:12.573
儘量單獨制定的端點
如果你能控制的話

00:31:12.940 --> 00:31:14.808
如果你不能 它可以

00:31:14.875 --> 00:31:17.811
提交多個請求在後臺刷新時

00:31:19.012 --> 00:31:22.916
現在我們看下恢復時間優化

00:31:23.150 --> 00:31:25.886
當通過擴展你優化你的恢復時間

00:31:25.953 --> 00:31:27.988
你將同時會優化你的啓動時間

00:31:28.055 --> 00:31:28.956
這很棒

00:31:31.558 --> 00:31:33.360
我們說說我們能做什麼

00:31:33.694 --> 00:31:35.062
就像Tyler剛纔說的

00:31:36.363 --> 00:31:39.867
你可以在willActivate和
didAppear時 將任務最小化

00:31:39.933 --> 00:31:41.201
你知道做它

00:31:41.268 --> 00:31:44.271
避免從willActivate中
觸發較長運行時間的任務

00:31:44.505 --> 00:31:47.140
我們將會做一個聰明的
加載和重新加載數據

00:31:47.508 --> 00:31:49.810
當然像他剛纔說的我們最好只設置屬性

00:31:49.877 --> 00:31:52.412
屬於接口中改變的元素的

00:31:53.380 --> 00:31:55.949
我將會用一個警示開始

00:31:56.016 --> 00:31:59.486
這包括實現垂直詳細分頁API

00:32:00.153 --> 00:32:01.121
像Tyler剛纔說的

00:32:01.188 --> 00:32:03.590
相鄰的詳細分頁的
willActivate會被調用

00:32:04.091 --> 00:32:06.693
你同時想要避免耗時的操作

00:32:06.760 --> 00:32:08.829
在詳細頁面
willActivate中

00:32:08.896 --> 00:32:12.699
尤其是 在這個視圖裏有一個
非常耗時的操作

00:32:13.600 --> 00:32:15.102
所以由幾個錯誤報告開始

00:32:15.169 --> 00:32:17.204
我們基本上得到的是加載慢的報告

00:32:17.271 --> 00:32:20.874
股票視圖加載慢
當你第一次進入詳細頁面時

00:32:21.308 --> 00:32:23.911
其他詳細頁從來沒有加載他們的圖表

00:32:23.977 --> 00:32:25.612
或者是相當慢

00:32:26.213 --> 00:32:27.581
現在我們看看代碼

00:32:27.848 --> 00:32:29.349
嘗試看看到底發生了什麼

00:32:29.416 --> 00:32:32.286
這是一個縮減版的股票接口控制器

00:32:32.352 --> 00:32:33.420
你會發現

00:32:33.487 --> 00:32:36.390
在willActivate我們
調用了downloadAndGenerateChart

00:32:36.723 --> 00:32:40.994
基本上NSOperation
是一個長時間運行的

00:32:41.061 --> 00:32:44.164
並且做很多工作
獲取圖表數據繪製圖表

00:32:45.032 --> 00:32:46.800
我們能在這個基礎上提高點什麼呢

00:32:48.101 --> 00:32:51.338
我們知道didAppear被調用

00:32:51.405 --> 00:32:53.774
當視圖控制器可見的時候

00:32:53.841 --> 00:32:55.275
對用戶同時被選中

00:32:56.176 --> 00:32:59.613
如果我們開始在這裏
下載和生成數據表呢

00:33:00.514 --> 00:33:04.585
如果你頻繁的滑動會發生什麼

00:33:05.252 --> 00:33:07.754
我們不想繼續下載和生成圖表數據

00:33:07.821 --> 00:33:09.256
對於已經離開的視圖

00:33:09.756 --> 00:33:12.659
我們會調用cancelDownloadAndGenerateChart

00:33:12.726 --> 00:33:15.295
它會獲得運行的操作

00:33:15.362 --> 00:33:16.296
並取消它

00:33:16.830 --> 00:33:21.268
我們看看
再一次看看其中的注意事項

00:33:21.335 --> 00:33:23.570
因爲我已經知道了這裏的錯誤

00:33:24.338 --> 00:33:27.307
想在willActivate
避免觸發長時間的運行任務

00:33:29.543 --> 00:33:34.047
如果可能 最好使用可取消的操作

00:33:34.448 --> 00:33:37.985
做這個NSOperation
是一個比較好的模板

00:33:38.285 --> 00:33:40.621
我們看看WKInterfaceTable加載

00:33:41.655 --> 00:33:43.657
我們知道所有的行被加載到內存

00:33:44.124 --> 00:33:45.993
我們知道它提前有個線性的花費

00:33:46.059 --> 00:33:48.195
根據你表中的行數

00:33:48.762 --> 00:33:52.232
同時不會像
UITableView會有重用

00:33:52.933 --> 00:33:54.868
我將會展示一個圖
一個性能分析

00:33:54.935 --> 00:33:56.270
我對這個股票做的

00:33:57.037 --> 00:34:00.040
這是初始化啓動時間
重啓以後

00:34:00.107 --> 00:34:01.975
沒有恢復時間或其他的

00:34:02.409 --> 00:34:05.245
重要的是你要注意這裏
我們沒有股票在列表中

00:34:05.312 --> 00:34:08.382
一個空的股票列表
用了5.5秒加載

00:34:09.683 --> 00:34:11.851
如果我們添加一個股票進去
它會多一點

00:34:11.918 --> 00:34:14.955
差不多6.5秒
如果加5個股票

00:34:15.022 --> 00:34:16.989
稍微多餘6.5秒

00:34:17.424 --> 00:34:21.295
如果我們添加10個股票
現在開始接近7秒了

00:34:22.596 --> 00:34:25.899
如果你有大量的行

00:34:25.966 --> 00:34:30.404
在你的表中那會延長

00:34:30.469 --> 00:34:32.339
接口控制器的加載時間

00:34:36.176 --> 00:34:39.012
我們這裏能做什麼才能降低加載時間

00:34:39.079 --> 00:34:41.648
第一我們可以限制加載的行數

00:34:42.416 --> 00:34:45.418
我們可以智能的更新我們的表格

00:34:45.485 --> 00:34:48.388
當行發生變化 當列表發生變化

00:34:48.722 --> 00:34:50.991
我們看看loadTable
的初始化部分

00:34:52.525 --> 00:34:55.128
我們從manager裏面獲取數據

00:34:55.195 --> 00:34:57.731
接着設置表的行數

00:34:59.166 --> 00:35:00.133
然後

00:35:00.200 --> 00:35:03.237
我們計算每個股票的行控制器

00:35:03.537 --> 00:35:06.373
開始看起來沒有問題
那裏放生了什麼

00:35:06.507 --> 00:35:09.776
股票的數量沒有被限制
如果你有20個股票

00:35:09.843 --> 00:35:12.980
那將有20行 若有30個會有30行
依次往下

00:35:14.948 --> 00:35:17.084
我們一直使用一定數量行的集合

00:35:17.317 --> 00:35:21.488
如果有一行被添加
當使用那一行時

00:35:21.555 --> 00:35:24.958
你會擦掉之前有的

00:35:25.425 --> 00:35:26.894
然後從頭開始

00:35:26.960 --> 00:35:28.028
這很沒有效率

00:35:28.829 --> 00:35:31.632
我們看看我們怎麼樣處理
讓它變得智能點

00:35:31.932 --> 00:35:34.902
我們像之前一樣先獲取股票
我們檢查數量

00:35:34.968 --> 00:35:37.538
然後我們設置一個最大值

00:35:37.604 --> 00:35:39.106
在這個股票例子 爲20

00:35:40.407 --> 00:35:43.110
我們接着計算行差異

00:35:43.177 --> 00:35:45.579
看他們之間的不同
變了多少

00:35:45.779 --> 00:35:47.881
然後我們調用insertRemoveTableRows

00:35:47.948 --> 00:35:49.249
稍後我們會仔細看看

00:35:49.950 --> 00:35:51.919
在下面

00:35:51.985 --> 00:35:54.188
我們確定我們沒有做
超過必須的過多工作

00:35:54.254 --> 00:35:56.323
我們會檢查確認索引

00:35:56.390 --> 00:35:59.092
在最大的股票列表大小之內

00:36:01.028 --> 00:36:03.130
我們看看insertRemoveTableRows

00:36:03.463 --> 00:36:06.533
第一個要做的是
計算行變化

00:36:07.134 --> 00:36:09.069
然後我檢查股票行變化

00:36:09.136 --> 00:36:11.405
如果大於零
我們會處理

00:36:11.705 --> 00:36:16.176
如果小於零
我們需要刪除掉

00:36:16.510 --> 00:36:17.477
最重要是

00:36:17.544 --> 00:36:19.680
你可以做的更聰明點
如果你想

00:36:19.746 --> 00:36:23.116
基於列表實際變了多少來更新

00:36:23.650 --> 00:36:25.185
但我們發現 因爲性能原因

00:36:25.252 --> 00:36:29.857
僅僅做一個在0處插入或刪除

00:36:29.923 --> 00:36:32.960
在索引0處
看起來工作的不錯

00:36:34.127 --> 00:36:35.963
所以我們不要做我們不需要做的工作

00:36:37.397 --> 00:36:40.634
概括來說
你的股票列表的股票的數量

00:36:40.701 --> 00:36:43.070
或者像我的例子 這個股票列表

00:36:43.136 --> 00:36:44.805
你的情況中 我不確定你放了什麼進去

00:36:44.872 --> 00:36:46.940
但是保持這個數量降低
並且控制在

00:36:47.007 --> 00:36:49.276
一個合理的數量在你的用例中

00:36:50.944 --> 00:36:53.947
下一步 當你插入和移除行時

00:36:54.014 --> 00:36:55.582
那將會更有效

00:36:55.649 --> 00:36:59.786
比你僅僅調用
WKInterfaceTable的設置行數方法

00:37:02.456 --> 00:37:04.525
最後一件事
不要遍歷整個表

00:37:04.591 --> 00:37:08.362
當一行數據更新時

00:37:08.428 --> 00:37:12.533
所以這麼想 就像如果
我們正在更新Apple股票的價格

00:37:12.599 --> 00:37:15.269
在表列表或股票列表

00:37:16.336 --> 00:37:17.471
作爲取代遍歷和

00:37:17.538 --> 00:37:20.140
更新每一行當我們不必這麼做時

00:37:20.707 --> 00:37:23.010
我們可以使用
rowController(at index)

00:37:23.076 --> 00:37:25.512
這樣我們就可以只更新
我們想更新的那一行

00:37:25.979 --> 00:37:30.117
或者 你甚至可以做類似
存儲一個引用

00:37:30.184 --> 00:37:32.619
對於rowController
且在稍後更新

00:37:34.922 --> 00:37:38.091
我們討論下更新UIElements

00:37:38.392 --> 00:37:42.729
Tyler剛纔提到的
UIObjects和WatchKit

00:37:43.297 --> 00:37:47.067
他們在extension進程中
被修改更新這些屬性

00:37:47.134 --> 00:37:49.369
需要從extension進程
發送到應用進程

00:37:49.903 --> 00:37:53.006
app進程處理界面的佈局

00:37:53.473 --> 00:37:56.610
我們看看股票的UI
只有一個rowController

00:37:56.944 --> 00:37:58.512
但我們有個錶盤這裏

00:37:58.579 --> 00:38:01.248
對於這行是可點擊的

00:38:02.282 --> 00:38:05.018
我們也有一個列表名字
就是股票代碼

00:38:05.085 --> 00:38:07.221
的公司名 它是個標籤

00:38:07.287 --> 00:38:09.356
還有changeInPointsLabel

00:38:09.423 --> 00:38:11.325
這就是需要修改的地方

00:38:11.658 --> 00:38:14.094
還有價格標籤表示當前價格

00:38:14.494 --> 00:38:16.463
我們看看我們需要做什麼

00:38:16.530 --> 00:38:18.332
更新rowController時

00:38:18.398 --> 00:38:19.700
我們有更新方法

00:38:19.766 --> 00:38:21.568
它會接收我們給它的任何值

00:38:21.635 --> 00:38:23.504
它會立刻設置那些屬性

00:38:24.505 --> 00:38:28.342
現在不好 因爲界面上的對象屬性

00:38:28.408 --> 00:38:31.945
沒有被緩存 對麼

00:38:32.779 --> 00:38:36.283
設置對象的屬性會每次

00:38:36.350 --> 00:38:39.086
都發送值給應用進程
我們會減少它

00:38:39.152 --> 00:38:41.388
但我想強調它的重要性

00:38:42.723 --> 00:38:45.792
一般來說 在我的分析中

00:38:45.859 --> 00:38:49.696
在股票中需要花費大約
200毫秒把一個值

00:38:49.763 --> 00:38:52.733
從extension進程發送到
應用進程

00:38:53.233 --> 00:38:56.403
看起來時間不長 但是

00:38:57.371 --> 00:39:01.575
在有些分析中
在初次啓動時

00:39:02.142 --> 00:39:05.846
我發現會超過平均值很多

00:39:05.913 --> 00:39:09.883
最壞的情況需要1.4秒

00:39:09.950 --> 00:39:12.719
從extension進程發送到
應用進程

00:39:13.387 --> 00:39:14.655
變化很大

00:39:16.924 --> 00:39:18.725
我們該如何做才能更智能些

00:39:19.426 --> 00:39:22.262
緩存那些已經發送的數據

00:39:22.329 --> 00:39:25.399
只在發生變化時發送

00:39:26.533 --> 00:39:30.037
我們來概括下恢復時間的討論

00:39:30.370 --> 00:39:33.140
我們想盡量減少
willActivate裏的工作

00:39:33.207 --> 00:39:35.642
在 didAppear 我們想使用

00:39:35.709 --> 00:39:38.312
可取消的操作 當可能的時候

00:39:38.979 --> 00:39:42.316
你還要注意 過於複雜的用戶界面

00:39:42.649 --> 00:39:44.451
會導致更慢的加載時間

00:39:44.518 --> 00:39:46.553
所以當數據越多

00:39:46.620 --> 00:39:49.122
需要更新到UI上
它就可能越慢

00:39:49.890 --> 00:39:52.526
當然 我們只想更新我們的用戶界面

00:39:52.593 --> 00:39:54.895
在必要的時候 當發生變化時

00:39:55.863 --> 00:39:58.165
總結一下 這個股票的案例

00:39:58.532 --> 00:40:02.002
希望大家能從這裏開始
思考關於你的應用

00:40:02.503 --> 00:40:05.305
保證你的任務小和簡單

00:40:06.073 --> 00:40:08.742
簡化你的用戶界面

00:40:09.209 --> 00:40:12.813
使用新的後臺刷新API

00:40:13.981 --> 00:40:15.849
集中在應用的恢復時間

00:40:15.916 --> 00:40:19.419
我們需要多注意WKInterfaceController
生命週期方法

00:40:19.486 --> 00:40:21.522
尤其是willActivate
和didAppear

00:40:21.855 --> 00:40:24.725
充分利用可取消的操作

00:40:25.092 --> 00:40:27.961
在你更新UI時要做優化

00:40:28.028 --> 00:40:29.763
不要發送冗餘的信息

00:40:30.631 --> 00:40:33.600
想要了解更多
你可以訪問開發者網站

00:40:33.667 --> 00:40:35.102
我們的演講編號是227

00:40:36.003 --> 00:40:38.805
一些相關的演講 不幸的是已經開始了

00:40:39.239 --> 00:40:40.874
其中一些我感覺很重要

00:40:40.941 --> 00:40:44.545
不僅是WatchKit開發
我們也有併發編程

00:40:44.611 --> 00:40:47.214
Swift 3中的GCD
所以也同樣重要

00:40:48.649 --> 00:40:51.885
謝謝
祝大家本週接下來的日子過得愉快