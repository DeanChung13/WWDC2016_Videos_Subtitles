00:00:19.453 --> 00:00:25.325
令應用自適應 第二部分

00:00:27.394 --> 00:00:30.330
早上好
我叫David Duncan

00:00:30.564 --> 00:00:33.333
和Kurt Revis一起
今天我們要講講

00:00:33.400 --> 00:00:35.769
如何使應用自適應

00:00:36.737 --> 00:00:41.241
那麼 第一部分你們會看到
Interface Builder加入了的

00:00:41.308 --> 00:00:43.343
工具

00:00:43.610 --> 00:00:47.981
以及做自適應佈局的基礎

00:00:48.815 --> 00:00:50.784
這個部分中
我們會跟你講更多

00:00:50.851 --> 00:00:55.155
能幫助你做自適應應用的技巧

00:00:56.156 --> 00:00:57.791
以及自己定製想要的體驗

00:00:57.858 --> 00:01:01.261
同時保持自適應性
所需要寫的代碼

00:01:02.062 --> 00:01:04.164
那麼 看看今天的議程

00:01:05.065 --> 00:01:07.100
我們要談的第一個

00:01:07.167 --> 00:01:11.805
只是一些尺寸和屏幕分類的基礎
幫助大家溫習一下

00:01:12.940 --> 00:01:18.478
我們還要講講在UIKit工具中已經
有的一些東西

00:01:18.545 --> 00:01:24.117
能夠幫助你用Interface Builder
最有效利用UIKit

00:01:25.018 --> 00:01:28.021
最後 Kurt會上來講

00:01:28.088 --> 00:01:32.526
怎樣跨屏幕構造自定義體驗

00:01:33.327 --> 00:01:35.329
那麼 讓我們從尺寸開始

00:01:37.364 --> 00:01:39.099
好 尺寸

00:01:39.600 --> 00:01:41.802
如果直接拿過來所有的設備

00:01:41.869 --> 00:01:44.805
和它們的設備方向
和它們在屏幕上的適配

00:01:44.872 --> 00:01:48.308
這樣看起來是很複雜的一些東西呢

00:01:48.609 --> 00:01:51.245
我不認爲任何人會想把這些問題都
連根拔起

00:01:51.478 --> 00:01:53.981
搞清楚它們的佈局看上去怎麼樣
使它工作

00:01:54.047 --> 00:01:57.551
讓我們看看是否可以
將需簡化的所有這些做個圖表

00:02:00.254 --> 00:02:04.091
好吧 還是挺複雜的

00:02:04.157 --> 00:02:07.628
你不必讀它
這些文本很難看清楚

00:02:07.694 --> 00:02:11.665
看看把文字和顏色去掉會不會簡單些

00:02:12.232 --> 00:02:15.235
並沒有什麼幫助
那麼我們還可以怎麼做？

00:02:16.003 --> 00:02:21.942
好吧 我們在UIKit考慮該問題時
我們會想可以怎樣

00:02:22.042 --> 00:02:26.747
分配空間
給用戶創造好的體驗？

00:02:28.215 --> 00:02:32.252
正如你已經猜到的
我們在講的是屏幕分類

00:02:32.920 --> 00:02:38.592
用網格分開 分成緊湊寬度
和常規寬度

00:02:38.659 --> 00:02:40.394
緊湊高度和常規高度

00:02:40.794 --> 00:02:44.264
我們決定 當你在緊湊型時

00:02:44.331 --> 00:02:48.068
你會有更接近iPhone的體驗
更好運用空間

00:02:48.702 --> 00:02:53.507
但當在常規型時
你可以做到一些更高級的事

00:02:53.574 --> 00:02:57.110
真正利用空間做到更有趣的一些事

00:02:58.011 --> 00:03:02.850
那麼從中學到的就是
當你看到常規尺寸時

00:03:03.183 --> 00:03:07.054
就是給了你機會給用戶
提供更好的用戶體驗

00:03:07.120 --> 00:03:08.288
利用空間

00:03:08.355 --> 00:03:11.291
超越能在緊湊型尺寸辦到的

00:03:12.292 --> 00:03:16.897
那麼 看看基於屏幕分類 UIKit
已經能辦到的

00:03:18.298 --> 00:03:21.001
大部分視圖和控制實際上並沒有變

00:03:21.768 --> 00:03:23.237
如果你看一下開關

00:03:23.303 --> 00:03:25.639
它在緊湊型還是常規型是一樣的

00:03:25.806 --> 00:03:28.709
導航條在緊湊型還是常規型也是一樣的

00:03:28.976 --> 00:03:30.577
但什麼會變呢？

00:03:31.812 --> 00:03:33.413
好吧 這裏有個展示

00:03:33.780 --> 00:03:37.284
看上去是個全屏展示
在iPhone 6s Plus上

00:03:37.784 --> 00:03:42.122
如果我們旋轉設備 把它放在緊湊型時
我們看到一個表單

00:03:42.756 --> 00:03:45.492
所以在展示中看到的一件事是

00:03:45.626 --> 00:03:49.263
如果你在常規型尺寸展示表單

00:03:49.329 --> 00:03:52.966
轉而到緊湊型尺寸
不會有足夠的空間來展示

00:03:53.033 --> 00:03:55.636
所以會把它改成全屏展示

00:03:56.937 --> 00:04:00.908
現在在UIKit中做着最複雜的適配

00:04:00.974 --> 00:04:03.210
基於屏幕分類和有限空間

00:04:03.510 --> 00:04:05.179
的是UISplitViewController

00:04:05.679 --> 00:04:10.918
在iPhone 6s Plus上看
緊湊型寬度的觀看體驗

00:04:11.318 --> 00:04:14.021
會看到 如同你常常體驗到的

00:04:14.087 --> 00:04:17.224
只能看到一個能夠推送、彈出東西
的導航控制器

00:04:17.658 --> 00:04:20.627
我們再旋轉到緊湊型寬度時

00:04:21.028 --> 00:04:22.462
就引入了邊欄

00:04:22.629 --> 00:04:27.868
在iPhone 6s Plus上
我們認爲所有常規型尺寸的空間

00:04:27.935 --> 00:04:32.539
有邊欄比沒有帶來的用戶體驗更好

00:04:32.973 --> 00:04:36.243
儘管我們只有這麼些空間來加上它

00:04:37.211 --> 00:04:41.348
跟在iPad上相似
橫屏9.7英寸iPad

00:04:41.415 --> 00:04:44.551
你會看到也有邊欄

00:04:44.618 --> 00:04:47.120
讓你更方便切換於不同郵件之間

00:04:47.788 --> 00:04:49.823
如果換到豎屏怎麼辦？

00:04:50.691 --> 00:04:53.393
記住 在iPad上還是常規型尺寸

00:04:54.061 --> 00:04:57.598
但是我們覺得在iPad上通常有內容

00:04:57.731 --> 00:05:00.234
更大、更有趣的內容

00:05:00.300 --> 00:05:04.104
內聯圖像等等
你需要多餘空間

00:05:04.471 --> 00:05:07.374
來和內容交互

00:05:08.041 --> 00:05:11.411
然而 我們允許你在邊欄切換

00:05:11.478 --> 00:05:14.681
這樣你還是能方便切換於不同郵件之間

00:05:15.415 --> 00:05:19.620
這就是UIKit的一些

00:05:19.686 --> 00:05:24.525
基於兩種屏幕分類
提供最好體驗的功能

00:05:24.591 --> 00:05:26.660
和有限的實際空間

00:05:27.528 --> 00:05:31.832
爲了更好利用它
讓我們看看UIKit的一些實踐

00:05:32.232 --> 00:05:35.802
充分利用現有功能

00:05:36.870 --> 00:05:40.908
講講Xcode工具裏UIKit的

00:05:41.074 --> 00:05:42.943
第一部分中

00:05:43.010 --> 00:05:46.713
你們看過了Interface Builder的用來做自適應
應用的增強功能

00:05:47.181 --> 00:05:50.684
爲了在所有範圍輕易做調試
基於屏幕分類

00:05:50.751 --> 00:05:51.652
和特徵

00:05:52.519 --> 00:05:55.689
但是 Xcode還提供了資源目錄

00:05:55.756 --> 00:05:59.293
資源目錄很棒
不僅用來整理圖像

00:05:59.359 --> 00:06:02.663
還指定了什麼時候該用這些圖像

00:06:03.931 --> 00:06:06.466
當然UIKit有很多技術

00:06:06.600 --> 00:06:08.735
讓構建自適應應用變得簡單

00:06:09.403 --> 00:06:11.738
我們討論自動佈局很多年了

00:06:11.805 --> 00:06:14.007
有很多相關演講
如果你想了解

00:06:14.074 --> 00:06:15.309
可以去回顧它們

00:06:15.475 --> 00:06:18.879
當然今天稍晚些有個演講
關於自動佈局的新進展

00:06:20.013 --> 00:06:22.850
特徵集合在第一部分回顧過了

00:06:23.684 --> 00:06:26.153
但還有別的東西比如動態字體

00:06:26.486 --> 00:06:29.756
讓你的應用適應不同字體大小

00:06:29.823 --> 00:06:31.158
基於用戶想使用的

00:06:32.426 --> 00:06:36.163
佈局導引是個很好的方式
用於傳遞自動佈局信息

00:06:36.230 --> 00:06:37.331
向層級下

00:06:37.431 --> 00:06:40.701
我們會討論一些UIKit默認提供的
一些佈局導引

00:06:41.835 --> 00:06:44.505
最後UIAppearance能很好

00:06:44.571 --> 00:06:48.342
聲明指定你想讓你的應用

00:06:48.408 --> 00:06:49.843
控制和視圖看上去怎樣

00:06:51.178 --> 00:06:53.380
讓我們從資源目錄開始

00:06:54.581 --> 00:06:58.919
資源目錄讓你自動適應圖像

00:06:59.052 --> 00:07:02.022
基於圖像所在展示的特徵環境

00:07:02.890 --> 00:07:04.391
這裏有個小例子

00:07:04.958 --> 00:07:07.427
這裏是些Sophia寶寶的圖片

00:07:07.594 --> 00:07:11.231
有1x 2x 3x版本的圖像

00:07:11.565 --> 00:07:16.537
不管你在iPad 2
還是iPhone 6s Plus上

00:07:16.703 --> 00:07:20.741
你會得到那個設備下最好分辨率
的圖像

00:07:21.842 --> 00:07:23.377
另一個優點是

00:07:23.443 --> 00:07:27.314
資源目錄可以爲應用瘦身設計

00:07:27.648 --> 00:07:32.553
這意味着如果我指定這個應用
給iPhone 6s

00:07:32.619 --> 00:07:36.356
一個2x設備
我不用付出空間損失

00:07:36.423 --> 00:07:38.859
給攜帶1x和3x的圖片

00:07:39.693 --> 00:07:43.197
同樣的 還壓縮了圖像基於屏幕分類

00:07:43.263 --> 00:07:44.298
和其他一些東西

00:07:44.431 --> 00:07:46.266
那麼 用資源目錄

00:07:46.333 --> 00:07:49.036
可以給圖像做最好的細分

00:07:49.136 --> 00:07:50.671
讓你用盡量少的容量

00:07:50.737 --> 00:07:52.706
部署給用戶設備的時候

00:07:54.541 --> 00:07:57.644
另外 資源目錄提供了元數據信息

00:07:57.711 --> 00:08:00.647
爲了各種理由添加到圖像上的

00:08:00.914 --> 00:08:03.717
第一件要討論的是對齊嵌入物

00:08:03.851 --> 00:08:05.552
把Sophia寶寶弄回來

00:08:06.153 --> 00:08:07.988
比如有個應用

00:08:08.055 --> 00:08:12.025
有時我們要剪裁這張圖片成正方形

00:08:12.726 --> 00:08:15.329
如果隨便取中間部分

00:08:15.395 --> 00:08:16.830
會看不見她大部分的臉

00:08:16.997 --> 00:08:20.667
真正要的部分是在她臉上畫個正方形

00:08:21.768 --> 00:08:23.504
現在你該怎麼辦？

00:08:23.570 --> 00:08:25.405
要引入一些度量

00:08:25.472 --> 00:08:28.041
搞清楚從邊到正方形的距離

00:08:29.009 --> 00:08:33.046
不用把這些寫入代碼和資源相連

00:08:33.447 --> 00:08:36.049
你可以直接在資源目錄完成這些

00:08:36.582 --> 00:08:40.254
UIImage會在你需要時
提供這些數值

00:08:40.419 --> 00:08:43.023
類似的 你可以用這些數值創建圖像

00:08:43.090 --> 00:08:44.958
把圖像放進資源目錄

00:08:45.025 --> 00:08:48.495
意味着你無需巨大的表格關聯資源名字

00:08:48.729 --> 00:08:49.630
和元數據

00:08:51.164 --> 00:08:56.136
類似的 比如表格視圖有個背景

00:08:56.203 --> 00:08:58.472
之類的 你需要調整大小

00:08:58.539 --> 00:09:01.208
來適應展示尺寸

00:09:01.708 --> 00:09:06.046
你可以創建一個分成9部分的圖片
創建切割邊緣

00:09:06.513 --> 00:09:08.882
儲存這些進資源目錄

00:09:09.416 --> 00:09:12.152
然後當這張圖片改成
最終狀態下的尺寸時

00:09:13.120 --> 00:09:16.356
它不需要大尺寸圖像就能調整大小

00:09:16.423 --> 00:09:18.892
而且特定的根據你在工作的設備大小

00:09:20.527 --> 00:09:22.429
好 這些是資源目錄

00:09:22.496 --> 00:09:26.066
講講其他可以給應用做的適配

00:09:26.333 --> 00:09:27.301
使用動態字體

00:09:28.635 --> 00:09:29.803
我們喜歡動態字體

00:09:30.437 --> 00:09:33.207
它給用戶提供了指定字體大小的能力

00:09:33.273 --> 00:09:37.044
給用戶一些視野上的幫助

00:09:37.110 --> 00:09:41.081
指定很大的字體大小來更方便閱讀

00:09:41.782 --> 00:09:42.950
今年

00:09:43.417 --> 00:09:47.387
我們讓你在應用上用動態字體更加簡單

00:09:47.788 --> 00:09:49.256
用兩種方法

00:09:49.790 --> 00:09:52.526
第一種 把它放在特徵目錄其中

00:09:52.960 --> 00:09:55.963
就不用等着聽通知了

00:09:56.163 --> 00:10:00.234
它就在那兒給你使用來自定義文本
如果你需要它

00:10:00.801 --> 00:10:04.538
但我們發現你在常規型文本視圖下
應該不需要做這些

00:10:04.605 --> 00:10:07.040
給標籤 文本框和文本視圖

00:10:08.008 --> 00:10:10.210
我們把這些變得非常簡單

00:10:10.544 --> 00:10:14.615
你只要指定想要的字體樣式

00:10:14.982 --> 00:10:18.485
給內容尺寸類別
設置調整尺寸的標誌

00:10:18.852 --> 00:10:21.355
所有標籤 文本框和文本視圖

00:10:21.421 --> 00:10:24.124
都自動適配成當前動態字體尺寸

00:10:24.191 --> 00:10:25.826
你不用做任何事

00:10:31.899 --> 00:10:33.834
當然 如果你用了這個方法

00:10:33.901 --> 00:10:37.771
確定在所有動態字體尺寸下測試應用

00:10:37.838 --> 00:10:40.040
如我提到的有些很大的字體

00:10:40.107 --> 00:10:43.810
Mac的無障礙檢查器會連接你的應用

00:10:43.877 --> 00:10:45.345
你可以動態調回來

00:10:45.412 --> 00:10:47.548
而不用來回設置

00:10:48.015 --> 00:10:50.918
如果你要在表格或集合視圖展示

00:10:50.984 --> 00:10:54.788
回顧一下“集合視圖的新特性”演講

00:10:54.855 --> 00:10:58.659
其中有些很好的信息關於性能和行爲
的增強功能

00:10:58.725 --> 00:11:02.196
在集合視圖中可以很好利用的

00:11:03.630 --> 00:11:05.933
那麼討論討論佈局導引

00:11:06.967 --> 00:11:10.370
UIView提供兩種佈局導引

00:11:10.571 --> 00:11:13.006
邊距導引 和可讀內容導引

00:11:13.073 --> 00:11:14.608
我們會依次說

00:11:15.075 --> 00:11:17.377
這兩種都源於視圖

00:11:18.045 --> 00:11:19.913
不管要放什麼內容

00:11:20.280 --> 00:11:25.786
邊距導引由UIView中的
一項屬性定義

00:11:26.153 --> 00:11:27.554
那就是佈局邊距

00:11:27.921 --> 00:11:29.990
定義了插入物的所有邊

00:11:31.391 --> 00:11:33.594
那麼 接下來怎麼創建佈局導引呢

00:11:33.861 --> 00:11:37.764
那只是由視圖指定的一個長方形而已

00:11:38.432 --> 00:11:42.503
邊距導引 當然 提供自動佈局對象

00:11:42.569 --> 00:11:44.638
給你生成自定義約束

00:11:45.205 --> 00:11:46.039
簡單

00:11:46.740 --> 00:11:50.210
那麼 可讀內容導引跟這有什麼關係呢

00:11:51.378 --> 00:11:52.913
可讀內容導引

00:11:53.480 --> 00:11:57.985
提供信息如何佈局文本

00:11:58.352 --> 00:12:00.320
讓文本的每行長度看上去好
可讀性高

00:12:00.988 --> 00:12:04.791
如果你在用
新的12.9英寸iPad Pros

00:12:04.992 --> 00:12:07.060
把文本佈局成一邊到另一邊

00:12:07.127 --> 00:12:09.963
用戶在閱讀時會不停轉頭

00:12:10.497 --> 00:12:15.469
第一件要計算的是文本長度的理想寬度
是多少？

00:12:16.537 --> 00:12:19.306
我們不想要文本溢出邊距

00:12:19.373 --> 00:12:22.976
所以把邊距導引作爲計算的一部分

00:12:23.477 --> 00:12:27.781
把兩者結合成可讀內容導引

00:12:28.081 --> 00:12:32.252
另一種在UIView中放入文本佈局

00:12:33.687 --> 00:12:37.157
現在 可讀內容導引基於動態字體大小

00:12:37.724 --> 00:12:39.626
如果動態字體大小變了會怎麼樣？

00:12:40.127 --> 00:12:42.329
好吧 我們放大了動態字體大小

00:12:42.396 --> 00:12:43.997
理想寬度變大了

00:12:44.531 --> 00:12:45.599
如你所見

00:12:45.666 --> 00:12:49.002
因爲可讀內容導引基於邊距

00:12:49.369 --> 00:12:52.306
導引不會穿過這些邊距

00:12:52.739 --> 00:12:54.374
所以你可以鋪開文本

00:12:54.441 --> 00:12:58.912
得到可讀性強的文本長度在視圖裏面

00:13:00.314 --> 00:13:02.583
那麼
讓我們講講UIAppearance

00:13:04.051 --> 00:13:06.954
UIAppearance
如果你還沒用過 是個聲明方式

00:13:07.221 --> 00:13:10.424
給你指定你想讓應用看上去怎麼樣

00:13:11.024 --> 00:13:12.125
這什麼意思？

00:13:12.726 --> 00:13:17.497
這意味着 比如說不同於有個新的
標籤欄就寫代碼

00:13:17.564 --> 00:13:18.398
你寫道：

00:13:19.066 --> 00:13:21.301
你寫說 對於我所有的標籤欄

00:13:21.735 --> 00:13:25.205
外表樣式中所有未選擇的着色是藍色

00:13:25.706 --> 00:13:28.442
非常簡單
每次創建標籤欄時

00:13:28.775 --> 00:13:30.377
未選擇項目會是藍色

00:13:31.111 --> 00:13:32.513
但它同樣是基於上下文的

00:13:33.013 --> 00:13:37.217
意味着你可以指定基於特徵集合

00:13:37.284 --> 00:13:40.487
或基於視圖包含物

00:13:42.923 --> 00:13:45.025
這看上去什麼樣？
讓我們看看

00:13:46.059 --> 00:13:48.762
這是我們的應用

00:13:49.196 --> 00:13:53.800
至於樣式 我們想把大的標題圖片
放在頂部

00:13:53.867 --> 00:13:56.136
在常規型豎向屏幕的時候

00:13:56.403 --> 00:13:59.673
圖片會替換導航欄的背景

00:14:00.140 --> 00:14:02.643
然而 當我們在緊湊型豎向屏幕時

00:14:02.910 --> 00:14:04.811
會呈現並排佈局

00:14:04.878 --> 00:14:07.714
圖片不會超出導航條

00:14:07.781 --> 00:14:10.551
所以我們會用默認背景

00:14:11.151 --> 00:14:13.053
先讓我們做默認背景

00:14:14.054 --> 00:14:17.524
創建一個UITraitCollection
給豎向緊湊型屏幕

00:14:19.059 --> 00:14:22.362
把導航條樣式賦給特徵集合

00:14:23.463 --> 00:14:27.668
說我們不想給這個樣式用任何背景圖片

00:14:27.968 --> 00:14:31.772
這會導致導航條用回原來默認樣式

00:14:32.840 --> 00:14:36.476
類似的 做豎向常規型屏幕時

00:14:37.144 --> 00:14:39.146
給它創建一個特徵集合

00:14:40.214 --> 00:14:41.615
用這個樣式

00:14:42.549 --> 00:14:45.752
指定一個空圖片
導致導航條

00:14:45.819 --> 00:14:48.188
不使用背景圖片

00:14:49.089 --> 00:14:53.393
現在 記住給特徵集合的樣式API

00:14:53.560 --> 00:14:54.695
可能會被讀取的很奇怪

00:14:54.761 --> 00:14:57.331
我們實際想修改C2的API

00:14:57.397 --> 00:14:58.665
所以仔細注意這部分

00:14:59.766 --> 00:15:03.604
要結束這個最佳實踐的部分前

00:15:04.137 --> 00:15:07.741
這個部分我們回顧瞭如何用資源目錄
整理圖片

00:15:08.742 --> 00:15:12.312
動態字體適配用戶改變字體大小的願望

00:15:13.313 --> 00:15:15.883
佈局導引幫助你構建你自己的佈局

00:15:15.949 --> 00:15:20.120
以容易適配所有佈局情況的方式

00:15:20.988 --> 00:15:22.489
最後 外表

00:15:22.656 --> 00:15:25.459
讓你的應用看上去跟你想要的一樣

00:15:25.759 --> 00:15:27.694
那麼接下來
我要交給Kurt繼續講

00:15:35.269 --> 00:15:36.170
謝謝 David

00:15:37.104 --> 00:15:41.408
如果你還記得 從
自適應應用 第一部分演講中

00:15:41.708 --> 00:15:43.944
要記住的訊息是：

00:15:44.411 --> 00:15:47.247
系統會做大部分工作
你不用做

00:15:48.015 --> 00:15:50.484
現在 我今天要講的是超越系統做的

00:15:50.951 --> 00:15:54.221
如果你想超越系統提供的

00:15:54.821 --> 00:15:55.822
接下來告訴你怎麼做

00:15:56.390 --> 00:15:58.492
這裏的關鍵詞是“如果你想要”

00:15:58.559 --> 00:15:59.693
不是必須的

00:16:00.360 --> 00:16:03.664
然而 如果你不想要
即使你不利用它

00:16:03.964 --> 00:16:07.401
還是可以學到如何更有效使用
UIKit

00:16:08.836 --> 00:16:10.938
那麼我要講一些超越基礎的

00:16:11.905 --> 00:16:15.409
我要告訴你怎麼設計應用來解決
所有各種

00:16:15.475 --> 00:16:17.511
設備方向 尺寸的問題

00:16:18.345 --> 00:16:20.280
你如何實現這些設計

00:16:20.347 --> 00:16:23.317
應用改變大小時 如何動態改變設計

00:16:23.984 --> 00:16:26.186
然後我要講關於使用可重複元素

00:16:26.253 --> 00:16:28.822
讓構建應用更方便快捷

00:16:29.456 --> 00:16:32.459
我會放在做一個應用的上下文中講這些
這兒我們會做個真正的應用

00:16:32.726 --> 00:16:35.462
那麼 稱我的應用爲
我的非常自適應的應用

00:16:35.996 --> 00:16:38.165
幸運的是
它也很簡單

00:16:38.732 --> 00:16:41.635
在這個應用中只要展現三件事

00:16:42.336 --> 00:16:44.204
三個項目
每個項目有個標題

00:16:44.371 --> 00:16:45.973
只是A B 和C

00:16:46.440 --> 00:16:50.010
然後還有更長一些的文本
每個項目一個描述

00:16:50.511 --> 00:16:53.814
即使這個應用非常簡單
我會用到一些技巧 你可以在

00:16:53.881 --> 00:16:57.251
更復雜更大的應用中使用

00:16:58.485 --> 00:17:01.622
這就是我應用的原型
這是其中的數據

00:17:01.788 --> 00:17:04.324
那麼我的應用該看上去如何
以及如何運行呢？

00:17:04.525 --> 00:17:05.392
設計什麼樣？

00:17:06.660 --> 00:17:08.762
好 當我在思考設計時

00:17:08.862 --> 00:17:10.830
我需要考慮所有尺寸和方向的組合

00:17:11.330 --> 00:17:14.434
給每個組合做個特別的設計太費事了

00:17:14.734 --> 00:17:17.738
這工作量太大了
讓我們試着簡化

00:17:18.472 --> 00:17:21.008
我覺得我的應用只需要兩個設計

00:17:21.608 --> 00:17:23.143
稱第一個爲“高的”

00:17:23.210 --> 00:17:26.980
我把所有項目豎着排放
A B 和C豎着放在堆裏

00:17:27.981 --> 00:17:31.718
另一個設計叫“寬的”
於是橫着排所有項目

00:17:32.819 --> 00:17:35.689
現在 我認爲不管應用實際是什麼尺寸

00:17:36.023 --> 00:17:39.326
我可以用兩者之一的設計
讓它們放的合適

00:17:40.661 --> 00:17:41.662
現在我的問題是：

00:17:41.728 --> 00:17:44.364
給到一個設備方向和尺寸的組合

00:17:44.431 --> 00:17:46.366
怎麼選擇用哪個設計？

00:17:46.800 --> 00:17:50.070
我要定義一個規則
我的應用專用

00:17:51.004 --> 00:17:54.441
我覺得我要選：
如果寬度低於高度

00:17:54.508 --> 00:17:56.009
用“高的”設計

00:17:56.710 --> 00:17:58.645
否則的話 用“寬的”設計

00:17:59.880 --> 00:18:02.616
運行所有的組合看效果怎麼樣

00:18:02.683 --> 00:18:05.586
在寫代碼之前先在紙上看看

00:18:06.353 --> 00:18:08.822
比如 這個iPhone是豎向的

00:18:08.889 --> 00:18:11.959
寬度低於高度
我們用“高的“設計

00:18:12.559 --> 00:18:15.162
把iPhone放到橫向

00:18:15.462 --> 00:18:19.032
或者iPad全屏
或者iPad部分屏幕

00:18:19.132 --> 00:18:22.302
過一遍所有的例子
全都試一遍確保這個規則能用

00:18:23.871 --> 00:18:25.239
再說一遍我剛剛做的

00:18:25.305 --> 00:18:27.407
在設計應用解決尺寸問題時

00:18:27.808 --> 00:18:29.610
我考慮了所有的組合

00:18:30.577 --> 00:18:34.281
想出了幾個設計來覆蓋所有組合
整個範圍

00:18:35.082 --> 00:18:38.819
然後定義規則來確定用哪個設計

00:18:40.687 --> 00:18:42.189
當我在定義規則時

00:18:42.422 --> 00:18:45.158
有很多方式可以用
這也是讓我的應用變得特別的地方

00:18:45.526 --> 00:18:47.661
但要注意我本來可以檢查

00:18:47.728 --> 00:18:50.464
尺寸是否正好匹配

00:18:50.531 --> 00:18:53.967
我本來可以看1024x768尺寸

00:18:54.034 --> 00:18:56.803
那麼說這是iPad
然後基於這個信息決定設計

00:18:57.104 --> 00:19:00.274
我不想這麼做因爲這樣做會要
解決太多組合

00:19:00.340 --> 00:19:02.176
而具體尺寸會隨着時間變化

00:19:03.443 --> 00:19:05.979
所以我定義了一個簡單的是否條件

00:19:06.046 --> 00:19:08.081
來告訴我用哪個設計

00:19:08.515 --> 00:19:10.150
有很多方法做這些

00:19:10.551 --> 00:19:13.086
第一條 最明顯的是用屏幕分類

00:19:13.153 --> 00:19:14.855
然後就完成了大部分工作

00:19:14.922 --> 00:19:17.891
你只要檢查是常規型還是緊湊型

00:19:19.026 --> 00:19:21.228
應用會像系統其他應用一樣工作

00:19:21.295 --> 00:19:23.363
因爲在用同一個屏幕分類

00:19:23.764 --> 00:19:27.467
所有的Xcode工具可以幫到你
你會無償得到很多

00:19:28.001 --> 00:19:29.903
但是你也可以自己定義一個規則

00:19:30.637 --> 00:19:34.441
比如可以比較一個值 比如寬度或高度
跟一個閾值比較

00:19:35.409 --> 00:19:38.445
或者比較兩個值 像我之前做的
寬度和高度比較

00:19:38.879 --> 00:19:40.080
或者結合這些規則

00:19:40.147 --> 00:19:43.483
重點是想出一個簡單清除的規定

00:19:43.550 --> 00:19:45.319
來決定用哪個設計

00:19:47.054 --> 00:19:51.158
在考慮設計時
即使尺寸相同

00:19:51.225 --> 00:19:54.127
比如iPad的一邊或者另一邊

00:19:54.561 --> 00:19:59.466
不要把設計特定到設備按鈕位置

00:19:59.533 --> 00:20:02.469
或者多線程操作時另一個應用在哪兒

00:20:04.938 --> 00:20:06.773
找到應用的大小

00:20:07.674 --> 00:20:10.677
用規則決定用哪個設計

00:20:11.311 --> 00:20:14.014
最後 把設計用在UI上

00:20:14.081 --> 00:20:16.450
改變UI的視圖來適配

00:20:17.851 --> 00:20:19.319
現在我該把這段代碼放哪兒？

00:20:19.853 --> 00:20:22.923
如果我用個Xcode的新模板
或者新的視圖控制器

00:20:22.990 --> 00:20:25.058
有viewDidLoad方法的模板

00:20:25.125 --> 00:20:29.029
它說 在這裏進行任何額外設置
那麼我就在這兒放代碼 對不對？

00:20:29.530 --> 00:20:31.231
不幸的是 沒那麼簡單

00:20:31.865 --> 00:20:35.102
原因是你不會想做這些
因爲視圖在所需時加載

00:20:35.536 --> 00:20:39.106
第一次要求視圖時
這個視圖會被調用

00:20:39.606 --> 00:20:40.707
那得很早了

00:20:41.508 --> 00:20:44.878
我們知道那時視圖還不是父視圖

00:20:45.379 --> 00:20:46.914
佈局還無效呢

00:20:47.414 --> 00:20:49.349
所以你不能指望視圖尺寸

00:20:49.416 --> 00:20:52.085
活任何父級尺寸或特徵之類的

00:20:52.152 --> 00:20:53.086
只是太早了

00:20:53.954 --> 00:20:58.492
對於一次性東西 像初始器
loadView、viewDidLoad

00:20:58.725 --> 00:21:02.229
你會想放一些設計中都一樣的代碼

00:21:03.130 --> 00:21:04.998
對我來說更好的地方放規則代碼

00:21:05.332 --> 00:21:07.768
是在視圖控制器的
viewWillLayoutSubViews方法裏

00:21:09.870 --> 00:21:13.473
你會看到因爲那時視圖在父視圖中

00:21:14.074 --> 00:21:16.109
父視圖的佈局已經發生了

00:21:16.243 --> 00:21:18.378
尺寸有效
視圖尺寸有效

00:21:18.445 --> 00:21:20.547
特徵有效
一切都很好

00:21:21.648 --> 00:21:25.619
這是操縱視圖控制器中元素的好時機

00:21:25.719 --> 00:21:28.622
這裏改變視圖控制器的視圖

00:21:28.689 --> 00:21:30.490
約束等等

00:21:31.625 --> 00:21:36.463
現在 注意要小心
因爲這是條非常火的路徑

00:21:36.530 --> 00:21:39.666
經常被調用 經常
出於你掌控之外的原因

00:21:40.667 --> 00:21:44.304
所以在這個方法裏做盡量少的工作

00:21:45.072 --> 00:21:48.909
理想條件下你會發現上次被調用後
什麼改變了

00:21:48.976 --> 00:21:51.845
然後基於變化 儘量少的更新

00:21:52.212 --> 00:21:56.183
只改變視圖的必須改變的屬性

00:21:58.151 --> 00:22:00.754
最後 小心不要導致佈局循環

00:22:01.188 --> 00:22:03.323
如果使父視圖佈局失效

00:22:03.724 --> 00:22:05.692
它們會反過來失效你的佈局

00:22:05.859 --> 00:22:08.395
馬上你會發現你應用沒做任何事
只是不停使生效、

00:22:08.462 --> 00:22:11.198
失效佈局
然後任何實際都沒有發生

00:22:11.365 --> 00:22:14.434
要了解更多關於調試和
更多關於佈局循環

00:22:14.501 --> 00:22:17.204
可以看看今天稍晚些的
自動佈局的新進展演講

00:22:19.339 --> 00:22:22.576
那麼這裏是我的兩個設計
回到這裏

00:22:22.643 --> 00:22:24.878
怎樣實現它們呢？

00:22:25.612 --> 00:22:29.449
我可以給每個項目A B C一個視圖

00:22:30.450 --> 00:22:32.085
然後用UIStackView

00:22:32.152 --> 00:22:34.521
來橫向或豎向排列這些東西

00:22:34.788 --> 00:22:37.891
UIStackView做全部工作
我不用特別努力思考

00:22:38.959 --> 00:22:39.993
這有一些代碼

00:22:40.427 --> 00:22:43.897
我簡單示例的視圖控制器是一個
UIViewController的子類

00:22:44.598 --> 00:22:45.866
爲它做個storyboard

00:22:45.933 --> 00:22:49.136
其中有個堆視圖
而且這個視圖中已經有了三個視圖

00:22:49.970 --> 00:22:54.374
現在我要
在viewWillLayoutSubviews方法裏

00:22:54.441 --> 00:22:55.375
覆寫這些

00:22:56.243 --> 00:22:59.112
第一步 得到尺寸
寫view.bounds.size

00:23:00.214 --> 00:23:01.582
第二 採用規則

00:23:01.949 --> 00:23:04.151
如果寬度大於高度...

00:23:04.218 --> 00:23:08.255
或等於高度 選擇用“寬的”設計

00:23:09.389 --> 00:23:11.291
最後採用設計

00:23:11.892 --> 00:23:13.994
如果再用“寬的”設計

00:23:14.061 --> 00:23:16.530
堆視圖的讀取會是橫向的

00:23:16.597 --> 00:23:19.366
否則就是豎向的
這是所有我要做的

00:23:20.033 --> 00:23:22.469
注意這裏我不用做很多工作

00:23:23.003 --> 00:23:26.039
我還利用了StackView很聰明
這個事實

00:23:26.507 --> 00:23:29.710
如果設置讀取已有值

00:23:29.776 --> 00:23:31.678
不需要做額外工作

00:23:33.347 --> 00:23:36.717
讓我們看看在活動的應用
這是我應用在iPhone豎向屏幕上

00:23:36.783 --> 00:23:40.587
看到豎向佈局
現在我旋轉到橫向

00:23:41.154 --> 00:23:44.391
會看到應用也旋轉到橫向

00:23:45.259 --> 00:23:47.094
我還無償得到這個動畫

00:23:47.661 --> 00:23:49.963
現在回到豎向
再展示一下

00:23:53.367 --> 00:23:54.701
這樣
旋轉了

00:23:55.402 --> 00:23:56.403
把這給David看

00:23:56.470 --> 00:23:59.173
因爲我被震撼到了
堆視圖 免費給了我這個

00:23:59.239 --> 00:24:00.240
我沒料到

00:24:00.707 --> 00:24:02.442
他說“好 這很棒

00:24:02.509 --> 00:24:04.912
但怎麼讓它更好？
你能讓它變得更突出嗎？”

00:24:05.712 --> 00:24:09.149
如果你是個應用開發者 也許你曾經
從客戶那兒聽到過這些

00:24:09.383 --> 00:24:11.151
我說“當然 我能讓這更突出”

00:24:11.652 --> 00:24:14.721
我可以讓應用稍微有趣些
讓它更突出

00:24:15.122 --> 00:24:20.260
通過在旋轉時 讓項目向你變大

00:24:21.195 --> 00:24:23.997
旋轉後我讓它們回到正常大小

00:24:24.164 --> 00:24:25.165
縮回到正常大小

00:24:27.868 --> 00:24:30.404
這不是我們必須提倡

00:24:30.504 --> 00:24:31.772
你在你應用中做的

00:24:32.739 --> 00:24:35.509
不是這個特定的讓應用突出的技巧

00:24:35.843 --> 00:24:40.214
重點是把代碼放在哪兒以及具體怎麼做

00:24:41.114 --> 00:24:44.585
那麼我把代碼放在viewWillTransition
方法裏來調整大小

00:24:44.651 --> 00:24:45.552
和協調器

00:24:46.353 --> 00:24:49.823
我這麼做因爲它會在應用尺寸變化時
被調用

00:24:49.890 --> 00:24:50.824
或者在旋轉時

00:24:51.225 --> 00:24:53.560
我給協調器設置動畫

00:24:53.627 --> 00:24:56.296
在旋轉同時設置
之後發生

00:24:57.497 --> 00:24:59.600
爲什麼不把所有佈局代碼放在這兒？

00:25:00.000 --> 00:25:03.537
因爲應用啓動時
第一次不會調用這個方法

00:25:03.604 --> 00:25:05.873
還有別的原因 但那是主要原因

00:25:06.907 --> 00:25:09.076
那麼我用協調器
設一段代碼

00:25:09.142 --> 00:25:11.044
來在旋轉時加入動效

00:25:11.478 --> 00:25:12.746
我要做的是在這段代碼中

00:25:12.813 --> 00:25:14.915
設置參數表示我想要動畫

00:25:14.982 --> 00:25:18.886
它就會以相同曲線和相同時間旋轉

00:25:19.353 --> 00:25:21.321
接下來設置堆視圖變化

00:25:21.388 --> 00:25:25.359
到1.4倍
所以變大一點點

00:25:26.627 --> 00:25:30.063
然後結束後
設置自己的動畫和持續時間

00:25:30.130 --> 00:25:32.266
這裏我選了.5
然後回到正常大小

00:25:32.332 --> 00:25:34.668
設置CGAffineTransform爲默認

00:25:34.968 --> 00:25:35.869
也就是正常大小

00:25:36.803 --> 00:25:37.638
那麼就這樣

00:25:38.005 --> 00:25:40.674
這是同一個應用
上面有多加的代碼

00:25:41.008 --> 00:25:41.875
會旋轉

00:25:43.911 --> 00:25:45.946
向你彈出然後回去

00:25:46.813 --> 00:25:49.883
如果再旋轉 它會做同樣的事

00:25:50.817 --> 00:25:53.120
就這樣
我加入了彈出效果

00:25:53.187 --> 00:25:54.855
讓它變得有趣了些

00:25:54.922 --> 00:25:57.157
但我沒有變核心佈局代碼

00:25:57.224 --> 00:25:59.426
它保持原樣
我只是加了些在頂部

00:26:01.929 --> 00:26:04.765
最後我想講的是可再用元素

00:26:05.599 --> 00:26:08.702
這種方法可以讓你構建應用

00:26:08.769 --> 00:26:11.638
由不同設計中可再用的元素

00:26:12.506 --> 00:26:15.509
這種應用構建方法更快
而且利用了

00:26:15.576 --> 00:26:18.579
不同設計而不用重寫所有東西

00:26:19.313 --> 00:26:21.148
我們會用到視圖控制器

00:26:21.215 --> 00:26:23.317
每個元素往往是一個視圖控制器

00:26:23.684 --> 00:26:26.787
這是因爲視圖控制器打包了
很多有用的東西在一起

00:26:27.221 --> 00:26:29.122
比如你得到了一個樹的視圖

00:26:29.189 --> 00:26:31.625
不僅是單個視圖
而是一整個樹的視圖

00:26:32.092 --> 00:26:34.061
和所有它們的約束一起

00:26:34.828 --> 00:26:36.964
可以連接到其他的視圖控制器

00:26:37.030 --> 00:26:39.933
於是你可以用segue跳轉到另一個
不同的視圖控制器

00:26:40.000 --> 00:26:43.737
或者呈現某個東西
找到父視圖控制器

00:26:43.804 --> 00:26:44.638
之類的

00:26:45.305 --> 00:26:48.408
這裏可以和應用的其他部分建立連結

00:26:48.475 --> 00:26:51.845
你可以連接到模型對象或者一個對象

00:26:51.912 --> 00:26:54.081
代表網路接入之類的

00:26:55.516 --> 00:26:59.119
現在你應用的視圖控制器有不同的角色

00:26:59.786 --> 00:27:01.755
也許有一個容器視圖控制器

00:27:02.122 --> 00:27:06.460
它也許包含了幾個被包含的視圖控制器

00:27:07.361 --> 00:27:10.364
也許你曾經寫過被包含的視圖控制器

00:27:10.430 --> 00:27:13.133
然後把它們放在
UIKit提供的容器裏

00:27:13.767 --> 00:27:16.870
比如導航控制器
或者分割視圖控制器

00:27:16.937 --> 00:27:18.438
或者標籤欄控制器等等

00:27:18.705 --> 00:27:21.241
但你可以寫自己的容器視圖控制器

00:27:21.375 --> 00:27:23.644
這讓你解鎖很多能量

00:27:23.710 --> 00:27:25.846
你可以通過這做到很多事

00:27:26.880 --> 00:27:29.216
我會展示給你如何做到
又是我的設計

00:27:29.816 --> 00:27:33.820
在我的案例中 我認爲我可以有一個
外面的容器視圖控制器

00:27:35.556 --> 00:27:37.858
我稱它爲
示例容器視圖控制器

00:27:38.292 --> 00:27:41.228
在那裏面我又三個元素視圖控制器

00:27:41.295 --> 00:27:42.863
每個元素有一個視圖控制器

00:27:44.264 --> 00:27:48.202
現在 想想
我認爲我的設計需要一點精化

00:27:48.669 --> 00:27:50.103
如果我沒有很多空間

00:27:50.170 --> 00:27:52.806
我會需要展示這些項目的預覽

00:27:52.873 --> 00:27:55.209
我沒有地方放全部文本
只夠放標題

00:27:56.009 --> 00:27:58.345
那麼當我點擊其中一項時

00:27:58.412 --> 00:28:01.448
或者 不好意思 輕擊其中一項時
它會呈現預覽

00:28:01.915 --> 00:28:05.319
會呈現展示全文的另一個視圖控制器

00:28:06.119 --> 00:28:09.423
然後如果我再輕擊那個
我們就遣散了它 它會不見

00:28:10.624 --> 00:28:14.328
做出這個通過...
我的示例容器視圖控制器

00:28:14.394 --> 00:28:17.397
會有三個小的元素視圖控制器

00:28:17.464 --> 00:28:18.565
我們等會兒會定義它

00:28:19.233 --> 00:28:21.401
當我們要呈現一個時
輕擊它

00:28:21.468 --> 00:28:24.905
就創建並呈現了一個新的大的
元素視圖控制器

00:28:26.240 --> 00:28:29.042
如果我的應用夠大
我不需要做這些

00:28:29.109 --> 00:28:33.380
我只要展示這裏的大的
元素視圖控制器就可以了

00:28:34.481 --> 00:28:35.883
直接在容器裏

00:28:36.149 --> 00:28:39.119
所以我的容器會有三個另一個類的
實例

00:28:39.186 --> 00:28:40.754
LargeElementViewController類

00:28:41.188 --> 00:28:44.892
當應用動態改變尺寸時

00:28:45.058 --> 00:28:49.096
我們要在這兩種視圖控制器層級的狀態
之間改變

00:28:50.130 --> 00:28:51.431
在這裏展示代碼

00:28:51.498 --> 00:28:54.201
我們將從被包含的視圖控制器
向上講到

00:28:54.268 --> 00:28:55.402
容器

00:28:55.469 --> 00:28:58.572
從給這些被包含的視圖控制器的
storyboard開始講

00:28:58.906 --> 00:29:02.176
它很簡單 這裏有個簡單帶標題的視圖

00:29:02.476 --> 00:29:06.180
注意我設置自定義類爲
小元素視圖控制器

00:29:06.513 --> 00:29:09.850
把storyboard標識符
設爲小元素

00:29:09.917 --> 00:29:13.387
就能在storyboard找到這些
然後之後舉例說明它們

00:29:14.588 --> 00:29:17.791
至於大元素視圖控制器
它更大 其中有更多文本

00:29:17.858 --> 00:29:18.692
同樣道理

00:29:18.759 --> 00:29:21.428
設置自定義類爲
大元素視圖控制器

00:29:21.895 --> 00:29:23.163
然後設置標識符

00:29:24.498 --> 00:29:26.934
這兒是給小元素視圖控制器的代碼

00:29:27.201 --> 00:29:29.570
從這開始
我知道每次展示這些

00:29:29.636 --> 00:29:32.673
就要點擊來展示大的視圖了

00:29:32.739 --> 00:29:36.243
在viewDidLoad方法中
有個適合的時機來做這個

00:29:36.643 --> 00:29:38.712
我要設置輕擊手勢識別器

00:29:39.046 --> 00:29:40.047
加到視圖中

00:29:41.114 --> 00:29:44.484
接下來它被輕擊時會被調用

00:29:45.319 --> 00:29:47.521
找到主storyboard

00:29:47.588 --> 00:29:50.390
舉例說明大元素視圖控制器

00:29:50.457 --> 00:29:52.226
用標識符 大元素

00:29:52.993 --> 00:29:55.863
最後只要呈現它們

00:29:57.664 --> 00:30:00.200
在大元素視圖控制器中更復雜一些

00:30:00.267 --> 00:30:02.936
因爲我們需要知道是否在被呈現

00:30:03.136 --> 00:30:05.372
如果在被展示
需要輕擊來退出

00:30:05.439 --> 00:30:06.473
如果不是
不需要

00:30:07.174 --> 00:30:09.076
所以我把這段代碼放在
viewWillAppear方法裏

00:30:09.343 --> 00:30:11.545
我這麼做因爲能用另一個方法

00:30:11.945 --> 00:30:15.082
isBeingPresented
方法找出這視圖是否被呈現

00:30:16.049 --> 00:30:19.353
如果在被展現
跟之前一樣加入輕擊手勢識別器

00:30:19.853 --> 00:30:22.155
當被輕擊時
所有要做的只是退出

00:30:25.158 --> 00:30:27.561
現在進入容器視圖控制器

00:30:28.629 --> 00:30:30.430
我準備加額外的一個對象

00:30:30.497 --> 00:30:32.165
讓它更容易工作

00:30:35.802 --> 00:30:37.938
叫做設計對象

00:30:39.173 --> 00:30:41.141
設計對象可以包裹

00:30:41.208 --> 00:30:43.977
所有描述一個設計的信息

00:30:45.379 --> 00:30:48.315
我把它做成一個無法改變的值類
出於安全考慮

00:30:48.382 --> 00:30:52.252
寫一個函數返回其中一個
之後它無法改變

00:30:52.319 --> 00:30:53.287
沒人能改變它

00:30:54.521 --> 00:30:56.456
它允許比較

00:30:56.523 --> 00:31:01.295
這樣就可以看我想要的設計和當前顯示
是否不同

00:31:02.462 --> 00:31:07.134
讓我們實現它
我只有一個簡單的Swift結構

00:31:07.401 --> 00:31:09.636
它有兩項信息

00:31:09.736 --> 00:31:11.171
第一個是軸

00:31:11.505 --> 00:31:15.242
從堆視圖中重複使用這個枚舉
可以是豎向或橫向的

00:31:16.543 --> 00:31:20.113
然後定義這個自己的枚舉爲
是否在用小版本

00:31:20.180 --> 00:31:22.382
或裏面視圖控制器的大版本

00:31:22.449 --> 00:31:23.717
稱其爲ElementKind

00:31:24.852 --> 00:31:27.955
最後這裏有個只讀的計算的屬性

00:31:28.055 --> 00:31:29.423
稱爲
elementIdentifier

00:31:29.723 --> 00:31:31.959
這只是用來告訴我用哪個標識符

00:31:32.025 --> 00:31:34.428
做storyboard裏視圖控制器

00:31:36.396 --> 00:31:39.399
最後 實現Swift裏的
Equatable協議

00:31:39.733 --> 00:31:43.537
這裏只是雙等號函數
我在兩個設計中比較數據

00:31:43.604 --> 00:31:44.671
來看它們是否相同

00:31:46.640 --> 00:31:49.009
讓我們進入容器視圖控制器

00:31:49.076 --> 00:31:50.143
然後做這些

00:31:50.210 --> 00:31:53.113
你記得它會有三個子視圖控制器

00:31:54.014 --> 00:31:57.317
它要用這些規則來創建決定用哪個設計

00:31:58.051 --> 00:31:59.152
然後更新

00:31:59.219 --> 00:32:01.955
每個佈局會重新評估用哪個設計

00:32:02.022 --> 00:32:03.423
然後改些東西如果需要的話

00:32:04.224 --> 00:32:06.860
那麼這樣
示例視圖控制器

00:32:06.927 --> 00:32:10.731
這裏有個包含三個位置的數組
給三個可選視圖控制器

00:32:11.198 --> 00:32:12.165
它們開始是無值

00:32:12.232 --> 00:32:15.903
當它一開始被創建時
還沒有展示任何東西

00:32:17.237 --> 00:32:20.440
我還要跟蹤記錄當前展示的設計

00:32:20.507 --> 00:32:23.677
這也是可選的 現在是無值的
因爲還沒有發生什麼

00:32:24.745 --> 00:32:28.148
在viewWillLayoutSubviews方法中
這些現在應該看來很熟悉了

00:32:28.215 --> 00:32:29.550
得到尺寸

00:32:30.050 --> 00:32:33.086
調用一個叫
decideDesign的函數

00:32:33.320 --> 00:32:35.923
基於尺寸
返回一個新的設計使用

00:32:36.657 --> 00:32:39.393
如果這個設計和當前顯示的不同

00:32:39.459 --> 00:32:43.230
我就把設計用到UI上
改變UI來匹配

00:32:44.031 --> 00:32:48.235
注意這和我之前講的僞代碼一模一樣

00:32:48.735 --> 00:32:51.438
不管你的應用做什麼

00:32:51.638 --> 00:32:53.607
你也可以按照這個模式來

00:32:53.740 --> 00:32:55.742
也許你的設計中有不同的東西

00:32:55.876 --> 00:32:58.946
你的decideDesign和
applyDesign方法不同

00:32:59.479 --> 00:33:02.649
但會按照一模一樣的模式

00:33:03.951 --> 00:33:06.253
現在把這些函數填進示例應用中

00:33:06.653 --> 00:33:10.691
DecideDesign
先決定座標軸

00:33:10.757 --> 00:33:13.660
我們已經講過了對這個規則怎麼做

00:33:14.361 --> 00:33:16.730
對elementKind
我將用一個不同規則

00:33:16.797 --> 00:33:21.468
我決定選擇比較應用寬度是否低於
閾值的規則

00:33:21.535 --> 00:33:24.238
選擇用小的視圖控制器
否則用大的

00:33:24.605 --> 00:33:26.373
這裏我在跟一個定值做比較

00:33:26.440 --> 00:33:28.442
這是一個給我應用用的例子

00:33:28.509 --> 00:33:31.845
你不一定在你的應用中用這個值
這只是一個例子

00:33:33.280 --> 00:33:35.949
把這兩樣信息打包

00:33:36.016 --> 00:33:37.918
進設計對象
然後返回它

00:33:39.319 --> 00:33:42.422
用這個設計 採用這兩樣

00:33:42.623 --> 00:33:44.391
我需要找出它們是否改變了

00:33:44.591 --> 00:33:47.194
座標軸直接傳遞到堆視圖

00:33:47.261 --> 00:33:49.596
它很聰明
不會做任何不需要做的事

00:33:50.531 --> 00:33:52.633
對於elementKind
我們還有些工作要做

00:33:53.500 --> 00:33:58.605
如果有舊的元素視圖控制器
而且元素類型在改變

00:33:58.672 --> 00:34:01.275
那麼我們需要毀掉老的
創建新的

00:34:01.675 --> 00:34:05.112
這裏我們要做的是迭代整個數組

00:34:05.179 --> 00:34:07.247
這裏我用了這個枚舉函數

00:34:07.314 --> 00:34:10.150
因爲它讓我們得到索引和
在那個索引的對象

00:34:10.217 --> 00:34:12.018
在迭代的同時

00:34:13.085 --> 00:34:15.856
最後 如果我們有一個
舊的元素視圖控制器

00:34:16.190 --> 00:34:18.926
需要刪除它
可以調用這個函數刪除

00:34:19.626 --> 00:34:22.329
到storyboard
創建一個新的元素視圖控制器

00:34:22.396 --> 00:34:24.598
用設計給我的標識符創建

00:34:25.199 --> 00:34:28.335
最後調用函數 加入新的子視圖控制器

00:34:28.969 --> 00:34:32.005
然後保存它到數組爲了下一次迭代

00:34:33.774 --> 00:34:36.210
這是最後一頁代碼幻燈片
謝謝你們聽我講到這兒

00:34:36.409 --> 00:34:37.744
這些是我們需要做的

00:34:37.811 --> 00:34:40.013
來做一個運行良好的容器視圖控制器

00:34:40.080 --> 00:34:42.649
完全按照這個順序完成步驟很重要

00:34:43.350 --> 00:34:46.954
加入新的視圖控制器時
調用addChildViewController

00:34:47.020 --> 00:34:52.926
這個方法加入這個視圖控制器
到自身的一列視圖控制器中

00:34:53.827 --> 00:34:56.763
然後需要加入那個新的
視圖控制器的視圖

00:34:56.830 --> 00:34:57.931
到視圖層級中

00:34:58.565 --> 00:35:02.603
通過運用堆視圖的
addArrangedSubviews方法

00:35:03.036 --> 00:35:04.538
UIKit不會幫你做這個

00:35:04.605 --> 00:35:06.840
也不能幫你做這個
因爲我們不知道

00:35:06.907 --> 00:35:09.643
在視圖層級中它該放在哪兒

00:35:09.710 --> 00:35:11.178
只有你能告訴我們這些

00:35:12.379 --> 00:35:14.915
最後 做完前面步驟以後
你告訴那個視圖控制器

00:35:14.982 --> 00:35:18.018
它移到了新的父視圖控制器
那裏是“自己”

00:35:19.319 --> 00:35:22.289
要移除舊的
做基本上相同的步驟

00:35:22.356 --> 00:35:23.557
只是以相反的順序

00:35:23.757 --> 00:35:27.094
我們告訴它
它會移到一新的父視圖控制器 即無值

00:35:27.861 --> 00:35:29.863
從視圖層級中移除它的視圖

00:35:30.163 --> 00:35:34.301
最後從自身的子視圖控制器中移除自己

00:35:36.370 --> 00:35:38.972
就是這樣
最終給你們展示了應用

00:35:39.139 --> 00:35:43.010
這裏我們在看橫屏的iPad
有很多空間

00:35:43.076 --> 00:35:46.813
我們用橫向佈局和大元素視圖控制器

00:35:47.548 --> 00:35:50.350
現在我劃到另一個應用固定住

00:35:52.085 --> 00:35:55.022
我的應用變小了
它換到了豎向佈局

00:35:55.255 --> 00:35:57.491
我還是在用大元素視圖控制器

00:35:57.558 --> 00:36:01.128
它們和之前我們看的視圖控制器一樣

00:36:01.828 --> 00:36:04.598
現在如果我還把應用變得更小

00:36:06.867 --> 00:36:08.936
你會注意到我們換到了小點兒的設計

00:36:09.002 --> 00:36:11.872
還是豎向 但在用小一點的設計

00:36:12.105 --> 00:36:14.808
現在我能輕擊其中一個小視圖控制器

00:36:14.875 --> 00:36:18.412
呈現大的那個
如果再輕擊 會退出它

00:36:19.980 --> 00:36:22.883
這就是我的應用
記住我們超越了基本的

00:36:22.950 --> 00:36:25.886
我們真的決定了要自己完成這些

00:36:26.453 --> 00:36:29.022
我解決了所有組合的設計

00:36:30.224 --> 00:36:31.658
實現了每個設計

00:36:31.725 --> 00:36:34.995
應用變換尺寸時在不同設計間動態變化

00:36:35.762 --> 00:36:38.065
還用了可重複使用元素來完成

00:36:38.966 --> 00:36:42.336
我的應用只是一個示例
你的應用也能做到這些

00:36:44.538 --> 00:36:48.509
我們講過了基礎
展示給你Xcode能辦到什麼

00:36:48.575 --> 00:36:52.279
展示了一些
UIKit提供的很棒的東西

00:36:52.346 --> 00:36:54.281
在一整套瑞士軍刀一樣的工具裏

00:36:54.581 --> 00:36:56.984
在實例應用中講過了代碼

00:36:57.317 --> 00:36:59.520
可我們還只是涉及了表面

00:36:59.586 --> 00:37:00.754
還有很多要做

00:37:00.988 --> 00:37:03.757
看看這個URL裏的示例代碼

00:37:04.725 --> 00:37:07.861
還有 如果你還沒有看第一部分
請回顧它

00:37:07.928 --> 00:37:11.665
有一個“兼收幷蓄的應用設計”演講
會講到字體排印

00:37:12.733 --> 00:37:16.670
David提到
集合視圖和自動佈局的新特性

00:37:17.171 --> 00:37:19.373
還有WWDC去年兩年

00:37:19.439 --> 00:37:21.975
我們講過關於自適應應用和多線程任務

00:37:22.042 --> 00:37:24.578
真的不想重複太多那些材料

00:37:24.645 --> 00:37:26.380
所以請複習那些東西

00:37:26.446 --> 00:37:28.715
那些演講中有很多很好的材料

00:37:29.449 --> 00:37:31.451
那麼謝謝各位
願各位度過一個很棒的週五