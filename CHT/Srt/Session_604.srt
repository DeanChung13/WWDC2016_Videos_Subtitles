00:00:19.720 --> 00:00:22.990
Metal的新特性 第一部分

00:00:24.558 --> 00:00:25.692
各位早上好

00:00:26.727 --> 00:00:27.628
謝謝

00:00:30.497 --> 00:00:32.266
我叫Aaftab Munshi

00:00:32.698 --> 00:00:34.601
我和我的同事十分激動地

00:00:34.668 --> 00:00:36.770
與大家分享Metal的新特性

00:00:36.870 --> 00:00:39.039
macOS Sierra
和iOS 10中

00:00:39.273 --> 00:00:44.311
不過開始我先着重說說
今年我們關於Metal的演講

00:00:44.378 --> 00:00:45.379
在 WWDC

00:00:45.445 --> 00:00:49.383
昨天我們有兩場演講
談論了將Metal採用到

00:00:49.449 --> 00:00:50.817
你的應用程序中

00:00:51.084 --> 00:00:53.253
今天我們有三場演講

00:00:53.320 --> 00:00:58.458
所以這一場 外加兩場演講
覆蓋了Metal的新特性

00:00:58.525 --> 00:01:01.628
之後還有另一場演講
其中我們會講

00:01:01.695 --> 00:01:03.130
Metal着色器優化

00:01:04.364 --> 00:01:06.466
那麼我們...

00:01:08.335 --> 00:01:10.504
看看我們將要講的功能

00:01:10.571 --> 00:01:14.074
在第二場演講中
我們要談的功能是

00:01:14.141 --> 00:01:18.612
函數或着色器特殊化
以及寫入資源的能力

00:01:18.679 --> 00:01:22.583
例如來自片段和頂點
着色器的緩衝和紋理

00:01:23.016 --> 00:01:27.187
廣色域 在你的應用程序中
使用廣色域顯示 以及紋理資源

00:01:27.254 --> 00:01:30.691
還有在Metal性能着色器上
添加的一些新內容

00:01:30.757 --> 00:01:34.928
具體是通過Metal在GPU上
使用輔助卷積神經網絡

00:01:35.195 --> 00:01:36.230
本次演講中

00:01:37.264 --> 00:01:38.732
我們將談談

00:01:39.066 --> 00:01:41.735
我們在工具上
加入的一些改進

00:01:41.802 --> 00:01:43.670
我們認爲大家一定會喜歡的

00:01:43.937 --> 00:01:48.075
我們也讓資源堆
和資源分配更加快速

00:01:48.175 --> 00:01:49.343
給你更多的控制

00:01:49.409 --> 00:01:52.446
我們將談談那個資源堆
和無記憶渲染目標

00:01:52.613 --> 00:01:54.648
然後我將談談曲面細分

00:01:54.982 --> 00:01:56.016
所以開始吧

00:01:56.650 --> 00:01:58.085
好了 首先

00:01:58.385 --> 00:02:01.989
我們花一點時間去理解

00:02:02.122 --> 00:02:04.057
爲什麼需要
曲面細分

00:02:04.224 --> 00:02:07.861
我們看到應用程序
例如遊戲

00:02:08.095 --> 00:02:10.531
渲染越來越多的
逼真視覺內容

00:02:10.597 --> 00:02:13.033
所以這意味着
爲了渲染那麼多內容

00:02:13.100 --> 00:02:16.737
我們需要能將精細的
幾何圖形發送給GPU

00:02:16.837 --> 00:02:18.572
我們要將輸入發送過去

00:02:19.039 --> 00:02:22.910
這意味着需要處理
非常多的三角形

00:02:23.143 --> 00:02:25.345
這會極大增加存儲帶寬

00:02:25.412 --> 00:02:27.080
一件非常好的事是

00:02:27.514 --> 00:02:31.084
如果我們能將
這個發送給GPU的

00:02:31.151 --> 00:02:33.921
幾何圖形只描述成
一個低分辨率的模型

00:02:33.987 --> 00:02:35.489
名爲Core Smash

00:02:35.556 --> 00:02:39.726
然後讓GPU生成
高分辨率的模型

00:02:39.793 --> 00:02:43.130
事實上 這就是
曲面細分的功能

00:02:43.463 --> 00:02:46.800
曲面細分這種技術
你可以用它來放大並細化

00:02:46.867 --> 00:02:48.836
幾何對象的細節

00:02:49.002 --> 00:02:51.672
我們必須要符合
兩個重要的要求

00:02:51.972 --> 00:02:55.175
第一個是
那個生成的高分辨率

00:02:55.242 --> 00:02:59.213
三角形模型
不能存儲在顯存中

00:02:59.279 --> 00:03:01.081
我們不想佔用帶寬

00:03:01.148 --> 00:03:04.585
第二 所使用的方法
需要是可編程的

00:03:04.651 --> 00:03:06.987
所以我們來看一個例子

00:03:07.054 --> 00:03:10.724
這是GFXBench 4.0的截圖

00:03:10.891 --> 00:03:13.060
是一款由Kishonti
發佈的測試程序

00:03:13.126 --> 00:03:15.696
其注重的一個關鍵功能
就是曲面細分

00:03:15.796 --> 00:03:19.666
這張截圖是沒有使用
曲面細分而渲染出的汽車

00:03:19.766 --> 00:03:21.235
你看看那些輪圈

00:03:21.602 --> 00:03:23.470
多邊形很明顯
你不會開種車的

00:03:23.537 --> 00:03:24.538
對吧？

00:03:24.938 --> 00:03:27.975
就連車身板件上都有裂紋

00:03:28.041 --> 00:03:33.213
因爲這就是實際
發送過去的幾何圖形

00:03:33.280 --> 00:03:35.516
你能看到 沒有很多三角形

00:03:36.450 --> 00:03:38.418
這很好
--正是我們想要的

00:03:38.552 --> 00:03:41.388
曲面細分的功能是
將那個輸入的幾何圖形

00:03:41.455 --> 00:03:42.756
變成這個樣子

00:03:44.324 --> 00:03:45.726
我認爲這十分炫酷

00:03:46.693 --> 00:03:51.098
如果你看看線框圖
你可以看到是GPU負責生成

00:03:51.164 --> 00:03:53.934
現在我們渲染出
非常多的三角形 是吧？

00:03:54.001 --> 00:03:55.402
這就是曲面細分的威力

00:03:55.903 --> 00:03:59.306
好了 我們來看看曲面細分
如何在Metal中工作的

00:04:00.307 --> 00:04:03.944
所以就像Metal那樣

00:04:04.044 --> 00:04:07.381
我們想採用
全新的設計方法

00:04:07.447 --> 00:04:09.950
我們想設計出--

00:04:10.117 --> 00:04:13.420
即使現在有支持
曲面細分的API

00:04:13.554 --> 00:04:14.888
你可能很熟悉

00:04:14.955 --> 00:04:17.925
我們想要的是
易於表達的東西

00:04:18.024 --> 00:04:19.226
易於使用

00:04:19.293 --> 00:04:21.995
而且我們不想保留任何性能

00:04:22.996 --> 00:04:25.666
我們認爲我們做到了
希望你也會認同

00:04:25.732 --> 00:04:27.067
在這次展示之後

00:04:28.302 --> 00:04:32.005
曲面細分在macOS Sierra
和iOS上可以使用

00:04:32.072 --> 00:04:33.473
搭載A9處理器

00:04:33.774 --> 00:04:37.211
好了 我想談論的是

00:04:37.277 --> 00:04:41.248
用於曲面細分的Metal
圖形管線是什麼樣的？

00:04:41.548 --> 00:04:43.517
如何使用曲面細分
渲染我的幾何圖形？

00:04:43.617 --> 00:04:46.153
以及如何將它應用到
我的應用程序中？

00:04:46.253 --> 00:04:47.287
所以開始吧

00:04:48.255 --> 00:04:52.326
現在 當你用Metal將
基元發送給GPU

00:04:52.693 --> 00:04:56.029
你發送的是三角形
線條或者是點

00:04:56.163 --> 00:04:59.633
有了曲面細分 你發送
的東西我們稱其爲面片

00:04:59.733 --> 00:05:03.270
簡單來說
面片就是參數曲面

00:05:03.337 --> 00:05:05.272
是由樣條曲線構成
但這意味着什麼？

00:05:05.339 --> 00:05:08.976
你可能聽過Bezier面片
或B樣條面片之類的東西

00:05:09.142 --> 00:05:12.412
你通過一組控制點來描述面片

00:05:12.513 --> 00:05:16.383
所以這個圖中
你看到的是B樣條面片

00:05:16.450 --> 00:05:20.187
所以你有16個控制點
或者是控制頂點

00:05:20.287 --> 00:05:25.158
曲面細分的作用是
簡單來說 允許你控制

00:05:25.359 --> 00:05:28.762
使用多少個三角形
來渲染這個面片

00:05:28.829 --> 00:05:32.065
所以你會決定
“我不想要很多的三角形”

00:05:32.132 --> 00:05:33.600
“我不在乎它什麼樣”

00:05:33.667 --> 00:05:36.770
所以你可以決定
四個三角形就足夠了

00:05:36.837 --> 00:05:38.305
然後你會得到
多邊形的外觀

00:05:38.505 --> 00:05:42.242
或你決定 “我真的
想讓它看起來精緻又平滑”

00:05:43.310 --> 00:05:46.313
這會需要更多的三角形
不過這是由你控制

00:05:48.081 --> 00:05:48.949
所以我們開始

00:05:49.016 --> 00:05:52.686
當我們做曲面細分時
圖形管線中的第一階段

00:05:52.753 --> 00:05:54.454
我們稱之爲曲面細分內核

00:05:54.721 --> 00:05:56.590
它的作用是將面片

00:05:56.657 --> 00:05:59.426
我們講了帶有
控制點的面片 作爲輸入

00:05:59.493 --> 00:06:03.096
並決定
“我需要將它細分成多少？”

00:06:03.163 --> 00:06:06.200
“我想讓GPU生成
多少個三角形” 對吧？

00:06:06.300 --> 00:06:10.370
這種信息是在
曲面細分因子中捕捉到的

00:06:10.437 --> 00:06:14.408
我會在幾個幻燈片之後
稍微談談這些因子

00:06:15.042 --> 00:06:18.445
你還可以生成額外面片數據

00:06:18.512 --> 00:06:20.414
如果在隨後階段中需要的話

00:06:20.480 --> 00:06:22.282
關鍵的是
這是一個可編程階段

00:06:22.349 --> 00:06:23.750
意味着你要寫代碼

00:06:24.885 --> 00:06:28.388
一旦你寫完了
生成了曲面細分因子

00:06:28.455 --> 00:06:30.657
下一階段叫做鑲嵌器

00:06:30.858 --> 00:06:33.760
這是一個固定函數階段
所以沒有代碼可寫

00:06:33.827 --> 00:06:37.297
不過你確實會得到
配置它的旋鈕

00:06:37.531 --> 00:06:42.569
所以它使用那些曲面細分因子
然後將面片分解成三角形

00:06:43.437 --> 00:06:46.907
鑲嵌器在這裏的
關鍵作用是它不將

00:06:46.974 --> 00:06:49.543
生成的三角形列表
存儲在顯存中

00:06:50.010 --> 00:06:52.713
除了其生成的三角形列表之外

00:06:52.779 --> 00:06:56.483
對於三角形列表中的每個頂點
它會生成我們所稱的

00:06:56.550 --> 00:06:59.253
參數座標 U和V值

00:06:59.319 --> 00:07:02.956
它將這個和控制點一起使用

00:07:03.624 --> 00:07:06.393
來計算在表面上的實際位置

00:07:06.793 --> 00:07:09.263
鑲嵌器會生成三角形

00:07:09.329 --> 00:07:13.834
今天在Metal中
當你想渲染基元時

00:07:13.934 --> 00:07:16.136
你將三角形發送給GPU

00:07:16.270 --> 00:07:21.074
首先會發生什麼？
執行頂點着色器

00:07:21.141 --> 00:07:23.777
在這裏是鑲嵌器生成
三角形 所以...

00:07:24.745 --> 00:07:28.315
如果你邏輯思考一下
下一階段就會是頂點着色器

00:07:28.382 --> 00:07:29.416
確實如此

00:07:29.550 --> 00:07:32.452
我們將其稱爲
後曲面細分頂點着色器

00:07:32.519 --> 00:07:36.790
因爲它在由鑲嵌器
生成的三角形上運行

00:07:37.090 --> 00:07:41.128
所以它會在
三角形的頂點上執行

00:07:41.195 --> 00:07:42.896
三角形由鑲嵌器生成的

00:07:42.963 --> 00:07:45.933
然後會輸出變換位置

00:07:45.999 --> 00:07:51.171
如果你熟悉DirectX
這個着色器所扮演的角色

00:07:51.238 --> 00:07:53.473
和DirectX中的域着色器相似

00:07:54.975 --> 00:07:57.444
好了 之後剩下的
管線都是一樣的

00:07:57.511 --> 00:08:00.080
我們有光柵器和
片段着色器

00:08:00.147 --> 00:08:03.717
你可能會問 “所以
我需要寫這個計算內核

00:08:03.784 --> 00:08:05.586
來生成曲面細分因子嗎？”

00:08:05.819 --> 00:08:08.388
“我能使用頂點或
片段着色器嗎？”

00:08:08.722 --> 00:08:09.857
你當然可以

00:08:09.923 --> 00:08:14.061
事實上 你根本不需要編寫
着色器來生成這些因子

00:08:14.127 --> 00:08:15.796
你可能預先計算好它們了

00:08:15.863 --> 00:08:18.565
你就能將它們加載到緩衝中
然後將其傳給鑲嵌器

00:08:18.632 --> 00:08:20.200
所以你有很多控制

00:08:20.300 --> 00:08:24.404
不過如果你在GPU中
生成這些因子

00:08:24.471 --> 00:08:26.273
我們建議你使用計算內核

00:08:26.340 --> 00:08:27.441
因爲你知道嗎？

00:08:27.508 --> 00:08:32.145
這會允許我們將那個內核
和其他繪製指令異步運行

00:08:32.412 --> 00:08:36.116
所以讓你提高性能
我認爲你們會喜歡的

00:08:36.850 --> 00:08:38.986
讓我們更進一步

00:08:39.052 --> 00:08:41.087
你不需要每一幀
都運行這個內核

00:08:41.355 --> 00:08:42.489
因爲你知道嗎？

00:08:42.556 --> 00:08:44.491
如果你已經計算了
曲面細分因子--

00:08:44.558 --> 00:08:45.626
假如你決定

00:08:45.692 --> 00:08:49.496
“離鏡頭更近的物體
會有更多的曲面細分”

00:08:49.563 --> 00:08:51.865
“更遠的物體就沒那麼多”

00:08:51.932 --> 00:08:55.602
一旦計算完了 之後
根據物體的運動方式

00:08:55.669 --> 00:08:58.872
我可以應用一個刻度
然後鑲嵌器會接受它

00:08:59.039 --> 00:09:03.343
所以管線真的十分簡單
我們有四個階段

00:09:03.410 --> 00:09:07.047
我們拿它和沒有
曲面細分的圖形管線相比

00:09:08.081 --> 00:09:10.384
沒有曲面細分的話
我們有三個階段--

00:09:10.450 --> 00:09:13.887
頂點着色器 光柵器
和片段着色器階段

00:09:14.188 --> 00:09:16.757
有曲面細分的話
我們添加了新的階段 鑲嵌器

00:09:16.823 --> 00:09:19.259
這是固定函數 所以
你不需要寫任何着色器

00:09:19.459 --> 00:09:22.663
然後頂點着色器成爲了
後曲面細分頂點着色器

00:09:23.397 --> 00:09:26.333
我們認爲這很容易理解

00:09:26.800 --> 00:09:28.068
希望你們會認同

00:09:29.203 --> 00:09:32.339
好了 如何用曲面細分
來渲染我的幾何圖形？

00:09:33.173 --> 00:09:34.975
這裏我要講四點

00:09:35.042 --> 00:09:37.110
我們先看看後曲面細分

00:09:37.177 --> 00:09:38.979
或後曲面細分
頂點着色器

00:09:39.046 --> 00:09:41.515
這與普通的
頂點着色器有何不同？

00:09:41.715 --> 00:09:43.617
如何傳遞我的面片輸入

00:09:43.684 --> 00:09:46.220
我跟你說過鑲嵌器是可以配置的

00:09:46.320 --> 00:09:49.256
我們來看看如何配置
之後繪製面片

00:09:50.891 --> 00:09:53.393
看看這就是新的着色器
跟舊的着色器一樣

00:09:53.460 --> 00:09:56.230
事實上 你聲明
後曲面細分頂點着色器

00:09:56.296 --> 00:09:57.898
要使用頂點限定符

00:09:57.965 --> 00:10:01.468
除此之外
你還要指定這個屬性

00:10:01.535 --> 00:10:03.470
寫着
“這是作用於面片的”

00:10:03.537 --> 00:10:06.807
這裏有兩種面片
--四邊形和三角形面片

00:10:06.874 --> 00:10:08.542
你看到它邊上的數字了嗎？

00:10:08.709 --> 00:10:12.412
那個數字就是告訴你
那個面片作用於多少個控制點

00:10:13.013 --> 00:10:15.949
如果你有普通的頂點着色器
你會傳遞

00:10:16.016 --> 00:10:17.684
一個頂點ID輸入

00:10:17.784 --> 00:10:20.187
現在你將patchID
作爲輸入傳遞

00:10:20.587 --> 00:10:24.758
還記得我告訴你鑲嵌器
生成參數UV座標嗎？

00:10:24.825 --> 00:10:28.595
那就這個
position_in_patch輸入

00:10:28.729 --> 00:10:31.198
之後 如果你有
普通頂點着色器

00:10:31.298 --> 00:10:33.433
你要將其作爲
stage_in傳遞

00:10:33.500 --> 00:10:35.769
我們在stage_in
傳遞的面片輸入

00:10:36.036 --> 00:10:37.638
其他東西
你就進行計算

00:10:37.704 --> 00:10:41.308
然後就生成
變換的頂點輸出

00:10:41.575 --> 00:10:43.644
這實際上會完全相同

00:10:43.710 --> 00:10:48.615
因爲下一階段 無論
有沒有曲面細分 都是光柵器

00:10:50.250 --> 00:10:52.152
好了 我們看看面片輸入

00:10:52.953 --> 00:10:57.224
如果你有普通頂點着色器
你會在着色器中將頂點輸入

00:10:57.291 --> 00:10:59.393
描述爲結構體

00:10:59.459 --> 00:11:02.229
如果你將數據類型
解耦合了 這意味着

00:11:02.296 --> 00:11:05.199
佈局和產生頂點輸入的緩衝

00:11:05.265 --> 00:11:08.202
無法匹配着色器中的聲明

00:11:08.268 --> 00:11:10.838
之後你要使用
MTLVertexDescriptor

00:11:11.004 --> 00:11:12.506
來描述佈局

00:11:12.573 --> 00:11:17.744
這裏有兩種面片輸入
一種是每面片輸入

00:11:17.811 --> 00:11:21.014
還記得我告訴你的
這裏有一個或以上的控制點嗎？

00:11:21.114 --> 00:11:23.717
所以我們也需要
將它們指定爲輸入

00:11:24.284 --> 00:11:27.588
不過你指定
它們的方法看起來一樣

00:11:27.688 --> 00:11:31.325
你用MTLVertexDescriptor
將面片輸入數據的

00:11:31.391 --> 00:11:33.827
佈局在內存中指定

00:11:34.194 --> 00:11:38.599
我之前展示過這個幻燈片
我們還將輸入作爲stage_in聲明

00:11:38.832 --> 00:11:44.271
你使用屬性索引在着色器中
將元素識別爲輸入

00:11:44.338 --> 00:11:48.175
通過MTLVertexDescriptor中
相應的聲明

00:11:49.309 --> 00:11:51.678
因爲會有不止一個控制點

00:11:52.546 --> 00:11:55.949
基本上 我們要使用
模板類型來對其聲明

00:11:56.016 --> 00:11:57.518
我會在下一個幻燈片上講的

00:11:57.584 --> 00:11:59.186
我們來看一個例子

00:11:59.286 --> 00:12:02.289
這裏我有我的控制點數據
上面有兩個元素

00:12:02.356 --> 00:12:04.424
我使用0和1屬性

00:12:04.992 --> 00:12:08.095
每面片數據
是2和3屬性

00:12:08.262 --> 00:12:09.730
我們將這兩個組合一起

00:12:09.796 --> 00:12:12.900
這是每個面片的面片輸入

00:12:13.100 --> 00:12:17.471
注意那個控制模板類型
patch_control_point

00:12:17.571 --> 00:12:19.573
這就在告訴
Metal的着色編譯器

00:12:19.640 --> 00:12:22.676
“這是引用控制點輸入”

00:12:23.177 --> 00:12:26.780
還記得我告訴你的這個
數字16嗎？數字多少無所謂

00:12:26.914 --> 00:12:30.717
這也在告訴Metal着色編譯器
這裏有多少個控制點

00:12:30.884 --> 00:12:34.655
現在我們有了爲獲取
面片輸入所需的所有信息

00:12:35.189 --> 00:12:37.157
所以我們將它
作爲stage_in傳遞

00:12:37.991 --> 00:12:38.892
非常簡單

00:12:40.861 --> 00:12:41.795
我認爲

00:12:42.129 --> 00:12:43.030
好了

00:12:43.530 --> 00:12:45.532
我如何配置旋鈕呢？

00:12:45.732 --> 00:12:46.767
這裏有屬性

00:12:46.834 --> 00:12:49.603
你可以設置在
MTLRenderPipelineDescriptor中

00:12:50.404 --> 00:12:53.640
幾個例子是
你可以告訴鑲嵌器

00:12:53.707 --> 00:12:56.476
你想用的三角形生成方法

00:12:56.543 --> 00:12:58.312
叫做分區模式

00:12:58.579 --> 00:13:01.849
你還可以指定
最高曲面細分等級

00:13:01.915 --> 00:13:04.685
我們認爲這是非常有用的

00:13:04.751 --> 00:13:08.355
因爲這允許你控制
所生成的幾何圖形最大量

00:13:08.422 --> 00:13:11.258
由GPU爲曲面細分物體生成

00:13:12.292 --> 00:13:15.095
記住鑲嵌器需要讀取這些因子

00:13:15.162 --> 00:13:17.664
所以你需要指定
產生它們的緩衝

00:13:17.731 --> 00:13:21.268
所以使用
setTessellationFactorBuffer API

00:13:21.335 --> 00:13:22.202
來完成

00:13:22.269 --> 00:13:28.909
這些因子會說明沿着邊緣
將這些面片細分成什麼程度

00:13:28.976 --> 00:13:30.344
還有在內部

00:13:30.444 --> 00:13:32.079
所以我們有兩種面片

00:13:32.145 --> 00:13:36.016
如果是三角形面片
會有三個邊和一個內部

00:13:36.116 --> 00:13:39.686
如果是四邊形
那就會有四個邊和兩個內部

00:13:39.920 --> 00:13:43.690
所以你將它們指定爲
半精度浮點值

00:13:43.757 --> 00:13:44.791
傳遞進去

00:13:47.494 --> 00:13:48.629
然後是繪製

00:13:48.695 --> 00:13:51.765
現在 當你繪製基元時

00:13:51.832 --> 00:13:54.067
你發送的三角形由GPU渲染

00:13:54.134 --> 00:13:57.671
你要麼調用drawPrimitives
或者drawIndexPrimitives

00:13:57.905 --> 00:14:01.175
你指定起始頂點
頂點數量

00:14:01.308 --> 00:14:05.546
如果你的頂點索引不是連續的
你就傳遞一個索引緩衝

00:14:05.646 --> 00:14:08.315
要想繪製面片
你就調用drawPatches

00:14:08.649 --> 00:14:09.816
或者drawIndexedPatches

00:14:10.184 --> 00:14:13.453
你指定起始面片
面片數量

00:14:13.620 --> 00:14:17.624
如果你的控制點索引不是連續的
你就指定一個索引緩衝

00:14:17.824 --> 00:14:19.059
所以這是一對一映射

00:14:19.893 --> 00:14:22.996
然後這裏有
DrawIndirect變體

00:14:23.063 --> 00:14:25.866
它們的功能是
你不指定出

00:14:25.966 --> 00:14:28.135
哪個是起始面片
以及面片數量

00:14:28.202 --> 00:14:31.071
以及當你進行
繪製調用時的其他信息

00:14:31.238 --> 00:14:32.906
相反 你傳遞一個緩衝

00:14:33.373 --> 00:14:35.776
這些信息會填寫在其上面

00:14:35.843 --> 00:14:38.645
通過一個在GPU上
運行的指令 就像你在

00:14:38.712 --> 00:14:40.013
drawPrimitives
上做得那樣

00:14:40.314 --> 00:14:43.517
如果你不知道如何
使用drawPrimitives

00:14:43.884 --> 00:14:46.787
drawPatches的
效果非常相似

00:14:47.020 --> 00:14:49.489
所以我們認爲
這非常易於使用

00:14:50.290 --> 00:14:51.191
好了

00:14:52.025 --> 00:14:52.860
稍等

00:14:57.464 --> 00:15:00.534
我給你展示了
什麼是Metal曲面細分

00:15:00.601 --> 00:15:01.735
以及使用方法

00:15:02.669 --> 00:15:05.172
在座很多人可能熟悉

00:15:05.239 --> 00:15:09.443
或者已經在你的應用程序中
使用了曲面細分 通過DirectX

00:15:09.776 --> 00:15:10.844
或者OpenGL

00:15:10.911 --> 00:15:13.347
你會注意到Metal
曲面細分有點不同

00:15:13.514 --> 00:15:14.381
別擔心

00:15:14.448 --> 00:15:17.484
我們設計的Metal曲面細分
可以極其直截了當地

00:15:17.551 --> 00:15:20.187
將你現有的曲面細分
代碼轉移到Metal上

00:15:20.287 --> 00:15:24.491
例如 在過去幾周裏
我們與Unity合作

00:15:24.791 --> 00:15:27.928
在極短的時間裏
他們能夠

00:15:27.995 --> 00:15:30.931
將Metal曲面細分
整合到他們的引擎中

00:15:31.231 --> 00:15:32.866
他們是這樣評價的

00:15:35.602 --> 00:15:39.072
我們非常激動地宣佈
對Metal曲面細分

00:15:39.139 --> 00:15:42.142
Metal Compute和在Unity中
編寫原生Metal着色器的功能支持

00:15:42.209 --> 00:15:45.512
將於今年晚些時候推出
這十分令人激動

00:15:46.513 --> 00:15:50.517
而且我們也與Epic合作
來有效地將

00:15:50.584 --> 00:15:52.853
Metal曲面細分整合到
Unreal Engine 4中

00:15:53.820 --> 00:15:58.358
而且Epic計劃將於今年
晚些時候發佈對UE4的支持

00:16:00.093 --> 00:16:04.331
所以我們有UE4 我們有
Unity支持Metal曲面細分

00:16:05.299 --> 00:16:11.171
讓我給你展示曲面細分在
這些遊戲引擎中的實際效果

00:16:11.238 --> 00:16:14.741
通過演示
兩種常用的渲染技術

00:16:14.842 --> 00:16:18.679
叫做適配曲面細分
和置換貼圖

00:16:19.813 --> 00:16:20.814
好了

00:16:25.719 --> 00:16:29.489
我們有一個簡單的演示...

00:16:31.291 --> 00:16:33.760
由幾位Apple工程師開發的

00:16:33.827 --> 00:16:35.062
使用Unreal Engine 4

00:16:35.128 --> 00:16:39.066
我們已經關上曲面細分
然後看看線框圖模式

00:16:39.166 --> 00:16:42.769
你能看到沒有很多的
三角形發送給GPU

00:16:42.836 --> 00:16:44.338
非常好
這正是我們想要的

00:16:44.404 --> 00:16:48.375
我們要將發送給GPU的
幾何圖形量維持得越少越好

00:16:48.509 --> 00:16:51.245
我們啓用曲面細分
看看會發生什麼

00:16:52.179 --> 00:16:55.649
你能看到現在GPU
生成了非常多的三角形

00:16:56.083 --> 00:16:59.987
適配曲面細分這種技術
允許你控制

00:17:00.053 --> 00:17:02.022
重要地方的幾何細節

00:17:02.089 --> 00:17:03.524
在這個例子中

00:17:03.624 --> 00:17:07.027
我們決定離鏡頭更近的
物體需要更多的細節

00:17:07.094 --> 00:17:09.061
所以繪製上更多的三角形

00:17:09.128 --> 00:17:11.231
相反 遠處的物體則不會

00:17:11.298 --> 00:17:16.236
藍色的區域代表着
曲面細分量最少的區域

00:17:16.303 --> 00:17:18.438
然後紅色的區域代表着

00:17:18.505 --> 00:17:19.873
曲面細分量最大的區域

00:17:19.940 --> 00:17:22.309
我可以展示
隨着我將滑動器向右滑動

00:17:22.376 --> 00:17:24.278
我可以用它來增加
曲面細分級別

00:17:24.344 --> 00:17:27.513
你能看到更近的
物體變成了紅色

00:17:27.580 --> 00:17:30.284
好了 我們將線框圖關掉

00:17:31.351 --> 00:17:34.154
如果你跑動
隨着我們通過這個洞穴

00:17:34.488 --> 00:17:36.456
你可以看到這裏有
更多的細節 對吧？

00:17:36.523 --> 00:17:40.294
如果我將曲面細分關掉
所有的細節都沒了 丟失了

00:17:41.028 --> 00:17:44.164
打開曲面細分
看起來非常驚豔

00:17:44.264 --> 00:17:49.603
所以這個例子演示了
如何使用曲面細分

00:17:50.304 --> 00:17:53.874
在我的應用程序中
構建豐富的視覺場景

00:17:54.274 --> 00:17:58.078
我想感謝那些在Epic的能人
他們讓這一切成爲現實

00:17:58.712 --> 00:17:59.780
所以下一個演示...

00:18:02.449 --> 00:18:03.917
是置換貼圖...

00:18:07.821 --> 00:18:09.923
在Unity上運行

00:18:10.123 --> 00:18:12.025
這裏我們渲染出一個球體

00:18:12.326 --> 00:18:15.329
我們看看用了多少個
三角形來渲染這個球體

00:18:16.363 --> 00:18:17.364
不多 對吧？

00:18:17.431 --> 00:18:19.299
大概有3000個三角形

00:18:19.766 --> 00:18:22.202
置換貼圖指的是
一種技術

00:18:22.269 --> 00:18:27.641
允許你置換幾何圖形
來創建驚人的細節

00:18:28.141 --> 00:18:33.780
其做法是使用
一個置換貼圖 是一種紋理

00:18:33.847 --> 00:18:36.283
所以你從紋理查找
從這個紋理

00:18:36.350 --> 00:18:39.052
之後用它將頂點位置偏移

00:18:39.453 --> 00:18:41.855
或者如果你想的話
你可以按順序地做

00:18:42.556 --> 00:18:45.726
不過置換貼圖需要

00:18:45.792 --> 00:18:48.028
你要繪製數量衆多的

00:18:48.095 --> 00:18:49.496
非常小的三角形

00:18:49.563 --> 00:18:52.366
否則不會有效
它創建一個工件 只是裂紋

00:18:52.499 --> 00:18:53.700
不過這沒問題的

00:18:53.767 --> 00:18:55.736
我們可使用曲面細分
它是專門做這個的

00:18:55.802 --> 00:18:58.305
因爲我們還想要
將3000個三角形

00:18:58.372 --> 00:19:01.441
更小的三角形發送給GPU
然後用曲面細分來生成它

00:19:01.508 --> 00:19:03.076
我們將線框圖模式關掉

00:19:03.143 --> 00:19:05.145
我們啓用置換貼圖

00:19:06.180 --> 00:19:09.283
如你所見 現在
球體上的細節非常驚人

00:19:09.383 --> 00:19:11.318
如果我將線框圖模式打開

00:19:11.485 --> 00:19:16.123
你可以看到我們生成了
非常多的三角形 而且都非常小

00:19:16.290 --> 00:19:18.725
實際上 我們看看這個
置換貼圖的動畫效果

00:19:18.792 --> 00:19:22.963
你能看到形狀變化
我們放大來看看細節

00:19:25.065 --> 00:19:26.934
你可以看到自陰影的出現

00:19:27.801 --> 00:19:30.504
自陰影在這裏出現的原因是

00:19:30.571 --> 00:19:33.440
因爲我們在改變幾何圖形

00:19:33.507 --> 00:19:37.177
與在座很多人可能熟悉的
凹凸貼圖技術不同

00:19:37.244 --> 00:19:39.313
那只是創建虛假的現實

00:19:39.379 --> 00:19:42.516
所以這是另一種技術
你可以用上曲面細分

00:19:42.583 --> 00:19:46.553
在所渲染的應用程序中
創建出驚人的細節

00:19:46.620 --> 00:19:49.089
還有 非常感謝Unity
提供這個演示

00:19:50.123 --> 00:19:53.927
演示
曲面細分實際效果

00:19:58.165 --> 00:19:59.132
好了 所以...

00:20:05.205 --> 00:20:10.110
Metal曲面細分還可以
用於加速數字內容創作工具

00:20:10.344 --> 00:20:15.516
例如 OpenSubdiv是由
Pixar發佈的開源庫

00:20:15.649 --> 00:20:19.253
它會實現高性能細分表面

00:20:19.553 --> 00:20:20.921
實際上 它集成到了多個

00:20:20.988 --> 00:20:23.924
第三方數字內容創作工具

00:20:23.991 --> 00:20:25.826
例如Autodesk的Maya

00:20:26.627 --> 00:20:30.964
OpenSubdiv使用曲面細分
來渲染這些細分表面

00:20:31.231 --> 00:20:35.936
Apple在OpenSubdiv中
加入了Metal曲面細分

00:20:36.003 --> 00:20:39.573
我很激動地在這裏宣佈
我們計劃將這些變更

00:20:39.640 --> 00:20:43.010
今夏晚些時候在OpenSubdiv
開源項目上發佈

00:20:43.677 --> 00:20:45.412
這是Pixar的評價

00:20:46.513 --> 00:20:50.150
如你所見 Pixar非常激動
看到在iOS和macOS中

00:20:50.284 --> 00:20:54.321
實現了OpenSubdiv上的
原生Metal

00:20:55.856 --> 00:20:58.992
好了 現在你可能會問
“那我呢？”

00:20:59.092 --> 00:21:02.629
“我如何將現有的曲面細分
代碼轉移到Metal中？”

00:21:02.863 --> 00:21:04.064
我來展示給你看

00:21:04.431 --> 00:21:08.302
所以我們以DirectX爲例
不過對OpenGL的規則也是一樣的

00:21:08.435 --> 00:21:12.639
這是帶有曲面細分的
DirectX圖形管線

00:21:12.806 --> 00:21:15.375
我們有三個新的階段--
其中兩個是可編程的

00:21:15.442 --> 00:21:17.344
它們叫做外殼和域着色器

00:21:17.444 --> 00:21:18.946
然後我們在中間有鑲嵌器

00:21:19.046 --> 00:21:21.281
那我如何
將它轉移到Metal中？

00:21:21.348 --> 00:21:24.785
注意域着色器的位置
正好在鑲嵌器的後面

00:21:25.285 --> 00:21:28.488
這讓你想起其他我在
Metal管線中展示的着色器嗎？

00:21:28.856 --> 00:21:29.890
“我想是吧”

00:21:29.957 --> 00:21:32.826
沒錯 後曲面細分頂點着色器
不過你知道嗎？

00:21:32.893 --> 00:21:37.497
曲面細分的域着色器
就會成爲新的頂點着色器

00:21:38.332 --> 00:21:44.404
就像你可很容易將HLSL或
GLSL頂點函數移動至Metal中

00:21:44.471 --> 00:21:47.174
你可以非常容易地
將這些域着色器移動到

00:21:47.274 --> 00:21:49.776
後曲面細分頂點着色器

00:21:49.843 --> 00:21:52.746
鑲嵌器是完全相同的
沒有改變

00:21:52.880 --> 00:21:55.549
所以就是這個東西
這兩個着色器

00:21:55.616 --> 00:21:56.850
頂點和外殼着色器

00:21:56.917 --> 00:21:58.552
我們要將它們放入內核中

00:21:58.685 --> 00:22:00.854
那麼我們看看如何去做

00:22:02.189 --> 00:22:07.027
我們看看一些
因爲我們已經有了頂點着色器

00:22:07.294 --> 00:22:10.797
這意味着這裏可能
有頂點描述符在運行時

00:22:10.864 --> 00:22:12.866
由應用程序所描述

00:22:13.267 --> 00:22:17.304
因爲數據可能會解耦合

00:22:17.437 --> 00:22:22.242
這意味着我要聲明stage_in
但我無法在內核中stage_in

00:22:22.309 --> 00:22:24.244
對吧？不過現在可以了

00:22:24.311 --> 00:22:25.646
我們添加了支持

00:22:25.846 --> 00:22:29.016
所以就像在頂點着色器中
你使用stage_in來說

00:22:29.082 --> 00:22:32.452
“這是我的頂點輸入”
你可以用stage_in來說

00:22:32.519 --> 00:22:34.755
“這是我的每線程輸入”

00:22:34.821 --> 00:22:38.258
而且你可以指定
實際數據佈局

00:22:38.425 --> 00:22:40.961
在MTLStage
inputOutputDescriptor中

00:22:41.028 --> 00:22:42.229
表現相同

00:22:42.296 --> 00:22:44.998
非常相似於
MTLVertexDescriptor

00:22:45.098 --> 00:22:48.735
有一些你指定的東西
有一點不同

00:22:48.802 --> 00:22:51.538
因爲這是用於計算的
而不是頂點的

00:22:56.476 --> 00:22:58.946
然後 要觀察兩點

00:23:00.714 --> 00:23:04.551
DirectX或OpenGL的
曲面細分頂點着色器執行於

00:23:04.618 --> 00:23:06.553
面片的控制點

00:23:06.753 --> 00:23:10.224
外殼着色器有這兩個函數

00:23:10.290 --> 00:23:12.526
一個是在控制點上執行

00:23:12.593 --> 00:23:14.394
另一個是在面片上執行

00:23:14.494 --> 00:23:16.997
每面片外殼函數纔是真正生成

00:23:17.064 --> 00:23:18.465
你的曲面細分因子

00:23:18.632 --> 00:23:20.634
那最好的做法是？

00:23:20.701 --> 00:23:23.403
將所有這三個函數
轉化成Metal函數

00:23:23.604 --> 00:23:26.573
然後我們寫一個Metal內核
來調用這些函數

00:23:26.640 --> 00:23:28.675
不過別擔心
我們不會做函數調用

00:23:28.742 --> 00:23:31.144
Metal編譯器
會將它們內聯的

00:23:32.246 --> 00:23:33.981
我們來看看這是怎麼起作用的

00:23:34.047 --> 00:23:38.986
基本上 每個線程會
調用控制點函數 用於頂點的

00:23:39.052 --> 00:23:40.721
和外殼的

00:23:40.821 --> 00:23:44.925
假設這裏有16個控制點
所有第一個線程調用頂點

00:23:44.992 --> 00:23:46.593
和控制點外殼函數

00:23:46.760 --> 00:23:50.163
第二個也是一樣
如此類推

00:23:50.230 --> 00:23:53.634
它們產生的任何間歇數據
如果想分享的話

00:23:53.700 --> 00:23:55.169
會放入線程組內存中

00:23:55.235 --> 00:24:00.274
就是高性能
極低延遲的本地內存

00:24:00.340 --> 00:24:02.176
我們不會去使用顯存

00:24:02.442 --> 00:24:06.413
之後 如果有16個控制點
這就會有16個線程

00:24:06.480 --> 00:24:07.614
在上面運行

00:24:07.748 --> 00:24:10.984
只需其中一個執行
每面片外殼函數

00:24:11.051 --> 00:24:14.321
這意味着通常會遇到柵欄
之後你只會執行

00:24:14.388 --> 00:24:16.657
其中的一個線程
會執行外殼函數

00:24:16.723 --> 00:24:18.058
你會遇到條件性檢查 會說

00:24:18.125 --> 00:24:22.629
“我的線程是在線程組ID0嗎？
之後調用這個”

00:24:22.829 --> 00:24:27.668
這個函數會將
曲面細分因子輸出到

00:24:27.734 --> 00:24:29.002
顯存中

00:24:29.069 --> 00:24:33.006
如果你有額外想要輸出
的面片數據 你可以做到

00:24:33.173 --> 00:24:38.212
如果你真的非常想輸出
控制點數據 你可以做到

00:24:38.278 --> 00:24:42.115
但我們發現在大多數情況中
控制點數據只是通過

00:24:42.216 --> 00:24:47.187
是這些現有API中
圖形管線的性質

00:24:47.254 --> 00:24:48.956
需要你將它們傳遞過去

00:24:49.022 --> 00:24:51.291
不過你只是讓它們傳遞過去
不要寫出來

00:24:51.358 --> 00:24:53.861
你已經在緩衝中有了

00:24:54.895 --> 00:24:56.163
好了 讓我總結一下

00:24:56.230 --> 00:25:02.503
我希望給你展示了
MetalTessellation是很簡單的

00:25:02.569 --> 00:25:03.604
而且易於使用

00:25:03.704 --> 00:25:07.241
我們從頭開始設計
專注性能

00:25:07.641 --> 00:25:12.713
我展示了將你現有的曲面細分
代碼應用到Metal中是很簡單的

00:25:13.280 --> 00:25:15.115
在iOS和macOS上可用

00:25:15.182 --> 00:25:16.383
現在輪到你們了

00:25:18.352 --> 00:25:23.056
展示出來 使用曲面細分
並創建一些驚豔的畫面

00:25:23.123 --> 00:25:24.958
在你的應用程序中渲染

00:25:26.126 --> 00:25:29.029
我想感謝大家抽出寶貴時間
我將請上我的同事 James

00:25:29.096 --> 00:25:31.164
他將談談關於資源堆

00:25:31.231 --> 00:25:33.233
和無記憶渲染目標
謝謝大家

00:25:41.008 --> 00:25:42.276
好了 謝謝你 Aaftab

00:25:43.443 --> 00:25:46.280
本次演講的下一部分
我很激動地介紹

00:25:46.346 --> 00:25:50.417
在iOS和tvOS上
可用的兩項新Metal功能

00:25:50.684 --> 00:25:53.554
資源堆和無記憶渲染目標

00:25:54.154 --> 00:25:57.457
這些功能可以讓你
控制你的資源管理

00:25:57.524 --> 00:26:00.194
從而實現更大的
CPU和內存效率

00:26:00.861 --> 00:26:04.631
我將首先介紹資源堆
之後再講無記憶渲染目標

00:26:06.133 --> 00:26:10.704
資源堆是Metal中的一個
新的較低開銷資源管理選項

00:26:11.205 --> 00:26:13.607
你早就可以在Metal中
創建緩衝和紋理了

00:26:13.674 --> 00:26:15.475
那爲什麼還要
另一種方式？

00:26:16.076 --> 00:26:18.478
在設備上通過現有Metal API

00:26:18.545 --> 00:26:21.348
創建資源是既容易又方便的

00:26:21.415 --> 00:26:23.917
而且很多開發者
很讚賞這種簡單

00:26:24.351 --> 00:26:25.385
另一方面

00:26:25.452 --> 00:26:29.857
隨着Metal應用渲染
越來越豐富複雜的場景

00:26:29.923 --> 00:26:33.126
你會尋求更完善的
Metal資源控制

00:26:33.193 --> 00:26:35.929
來解鎖更大的
CPU和內存效率

00:26:36.430 --> 00:26:38.699
這就是我們推出資源堆的原因

00:26:39.466 --> 00:26:43.370
資源堆可以實現
快速的資源創建和綁定

00:26:43.437 --> 00:26:45.339
通過資源子分配

00:26:45.772 --> 00:26:49.142
資源堆的靈活性
會節省你的內存

00:26:49.209 --> 00:26:52.412
通過允許多個資源
在內存中取別名

00:26:53.380 --> 00:26:57.417
最後 資源堆的效率
和靈活性的實現是靠

00:26:57.484 --> 00:27:01.088
你控制資源依賴性跟蹤

00:27:01.188 --> 00:27:03.223
通過使用顯式指令同步

00:27:03.891 --> 00:27:05.526
我們來深入瞭解這些功能

00:27:05.959 --> 00:27:07.828
從資源子分配開始

00:27:09.196 --> 00:27:11.431
在談子分配的細節之前

00:27:11.765 --> 00:27:16.170
我們首先討論爲什麼
基於設備的資源創建耗費巨大

00:27:17.337 --> 00:27:18.939
創建單個資源

00:27:19.006 --> 00:27:21.241
使用Metal設備
涉及多個步驟

00:27:21.775 --> 00:27:24.912
分配內存
準備內存用於GPU

00:27:25.412 --> 00:27:27.181
清除內存保證安全

00:27:27.247 --> 00:27:29.917
最後
創建Metal對象

00:27:30.551 --> 00:27:32.920
每一步都需要時間
而大多數時間

00:27:32.986 --> 00:27:35.122
都花在內存操作上

00:27:36.156 --> 00:27:38.792
不過也有這種情況
當你需要創建資源

00:27:38.859 --> 00:27:42.496
在性能關鍵的路徑上
並且不出現性能故障

00:27:43.297 --> 00:27:45.132
紋理流就是一個例子

00:27:45.332 --> 00:27:47.901
或者也許你有
一個圖像處理應用

00:27:47.968 --> 00:27:51.405
需要生產多個臨時紋理
來執行一個濾鏡

00:27:53.340 --> 00:27:55.008
綁定資源的成本

00:27:55.209 --> 00:27:58.178
對於指令編碼器來說
也會成爲性能問題

00:27:58.779 --> 00:28:01.481
Metal必須跟蹤
每個綁定到指令編碼器

00:28:01.548 --> 00:28:05.285
的獨特資源來確保
GPU能夠訪問內存

00:28:05.686 --> 00:28:08.589
對於複製的場景
這個成本也會水漲船高

00:28:09.990 --> 00:28:13.594
資源子分配解決了
這兩個性能問題

00:28:14.161 --> 00:28:16.797
記住資源創建中
開銷大的部分

00:28:16.864 --> 00:28:18.432
是在內存操作中

00:28:18.966 --> 00:28:21.502
有了資源堆
你可以提前執行

00:28:21.568 --> 00:28:23.770
內存操作
在遊戲循環之外

00:28:24.905 --> 00:28:27.508
資源堆解決了綁定成本
做法是允許你

00:28:27.574 --> 00:28:31.211
從單個堆中對許多
邏輯資源進行子分配

00:28:31.979 --> 00:28:34.615
通過從一個堆中
對多個資源進行子分配

00:28:34.681 --> 00:28:39.052
Metal跟蹤的是一個內存分配
而不是每個資源的內存分配

00:28:39.419 --> 00:28:41.822
這會顯著降低
你的驅動過載

00:28:43.457 --> 00:28:44.825
我們給資源創建做對比

00:28:44.892 --> 00:28:47.528
在Metal設備和
新的Metal資源堆之間

00:28:48.629 --> 00:28:50.831
當你使用設備創建資源

00:28:50.898 --> 00:28:53.300
Metal會分配並準備
一個內存塊

00:28:53.367 --> 00:28:54.868
然後創建Metal對象

00:28:55.335 --> 00:28:59.239
對於四個資源 Metal會
分配並準備四個內存塊

00:29:00.474 --> 00:29:01.942
這與MTLHeap相比

00:29:02.376 --> 00:29:04.144
將MTLHeap
用於資源創建時

00:29:04.211 --> 00:29:06.580
你首先要提前創建堆對象

00:29:07.614 --> 00:29:11.084
內存會按請求的大小
分配並準備一個內存塊

00:29:11.385 --> 00:29:14.054
如果你在渲染循環
之外提前做了這件事

00:29:14.321 --> 00:29:17.057
資源創建中
開銷大的部分就完成了

00:29:18.091 --> 00:29:20.594
要從MTLHeap中
創建出四個資源

00:29:20.928 --> 00:29:23.797
Metal只需要保留
一塊堆的內存

00:29:23.864 --> 00:29:25.332
然後創建資源元數據

00:29:25.532 --> 00:29:26.733
這會更加快速

00:29:27.434 --> 00:29:30.103
現在來看看當我們想釋放
一些資源時會發生什麼

00:29:31.205 --> 00:29:35.008
當基於設備的資源釋放後
Metal對象就會被破壞

00:29:35.242 --> 00:29:38.412
不過設備也會釋放
內存資源分配

00:29:39.179 --> 00:29:41.281
另一方面
當釋放堆資源時

00:29:41.548 --> 00:29:45.352
只有對象被破壞
內存還由堆所佔有

00:29:45.786 --> 00:29:47.588
所以在設備上創建新資源

00:29:47.654 --> 00:29:50.257
會引起另一次
高開銷內存分配

00:29:50.524 --> 00:29:55.362
而堆可以快速將閒置內存
再分配給另一個資源

00:29:56.763 --> 00:29:58.031
我給你展示這有多容易

00:29:58.098 --> 00:30:00.200
用Swift對Metal資源
進行子分配

00:30:01.869 --> 00:30:04.137
所以跟很多Metal對象一樣

00:30:04.204 --> 00:30:07.875
Metal資源堆有
一個相應的描述符對象

00:30:08.842 --> 00:30:11.278
我們創建堆描述符
然後將大小設置成

00:30:11.345 --> 00:30:13.213
支持堆的內存量

00:30:14.781 --> 00:30:16.783
憑藉堆描述符
我們可以請求設備

00:30:16.850 --> 00:30:18.385
給我們創建一個堆對象

00:30:18.652 --> 00:30:21.555
記住 這個操作會比較慢
所以要提前做

00:30:21.955 --> 00:30:24.691
例如當應用啓動時
或是內容加載時間

00:30:26.059 --> 00:30:29.363
有了這個創建出的堆
我們可以調用其資源創建方法

00:30:29.530 --> 00:30:32.533
這看起來非常眼熟
因爲名稱和參數

00:30:32.599 --> 00:30:35.002
與設備上的名稱和參數相同

00:30:39.439 --> 00:30:41.275
在進行下一個話題之前

00:30:41.341 --> 00:30:45.045
我想分享一些使用資源堆
進行子分配的最佳做法

00:30:46.113 --> 00:30:48.382
最重要的一點
就是使用資源堆

00:30:48.448 --> 00:30:51.318
在性能關鍵的路徑上創建資源

00:30:51.618 --> 00:30:54.354
使用設備去創建資源不是專門

00:30:54.421 --> 00:30:56.623
用於遊戲循環的
資源堆是專門的

00:30:58.959 --> 00:31:03.897
分配大小不同的資源
可能會導致堆內存出現碎片

00:31:04.198 --> 00:31:06.500
如果資源有不同的生命週期

00:31:07.167 --> 00:31:10.404
所以使用多個堆
並按照大小將資源裝好

00:31:10.470 --> 00:31:12.239
來限制碎片的影響

00:31:14.041 --> 00:31:17.211
你可以還在想
如何選擇合適的堆大小

00:31:17.644 --> 00:31:20.380
Metal在Metal設備上
提供了兩種新的方法

00:31:20.747 --> 00:31:23.984
來查詢紋理和緩衝的大小與排列

00:31:24.952 --> 00:31:27.955
使用這些查詢來幫助你
計算所需堆的大小

00:31:29.323 --> 00:31:33.093
好了 我們來看看資源堆的
下一項功能：資源別名

00:31:34.194 --> 00:31:36.897
資源別名允許多個動態資源

00:31:37.164 --> 00:31:38.565
佔用相同的內存

00:31:38.832 --> 00:31:41.268
因此減少了資源的總體

00:31:41.335 --> 00:31:42.336
內存佔用

00:31:42.903 --> 00:31:46.540
動態資源的內容
每一幀都是再生成的

00:31:46.607 --> 00:31:50.177
內容包括陰影貼圖
G緩衝數據

00:31:50.244 --> 00:31:53.780
或是用於後處理的臨時紋理

00:31:55.182 --> 00:31:58.018
我們這裏有一個堆
包含兩個非別名的資源

00:31:58.585 --> 00:32:01.321
與這個包含兩個
相同資源的堆相比

00:32:01.388 --> 00:32:02.656
不過現在用了別名

00:32:03.023 --> 00:32:04.992
你能明顯看到
使用別名的資源

00:32:05.058 --> 00:32:06.760
可以放入更小的堆中

00:32:10.797 --> 00:32:13.634
我們將資源別名
應用到這個遊戲幀中

00:32:14.301 --> 00:32:16.570
陰影貼圖過程
會渲染一組陰影貼圖

00:32:16.970 --> 00:32:18.772
用於場景中的每個光源

00:32:19.373 --> 00:32:21.608
所以在這裏的堆中
我們有多個陰影貼圖

00:32:23.343 --> 00:32:25.846
在主過程的碎片加工中

00:32:25.979 --> 00:32:28.282
着色器會採樣
陰影貼圖來判定

00:32:28.348 --> 00:32:30.284
是否每個對象都在陰影中

00:32:31.752 --> 00:32:34.655
在主過程結束後
陰影貼圖的內容

00:32:34.721 --> 00:32:35.956
就會被完全消耗

00:32:36.223 --> 00:32:38.425
它們會在下一幀中再生成

00:32:40.060 --> 00:32:42.663
在主過程結束後
我們會執行後處理鏈

00:32:42.729 --> 00:32:45.732
這個可能包含多個
離屏渲染過程

00:32:45.799 --> 00:32:48.569
每個都執行特定的濾鏡
像是模糊或者高光

00:32:49.803 --> 00:32:52.139
這些濾鏡會將其內容
存儲進紋理中

00:32:52.206 --> 00:32:55.142
來將濾鏡結果傳遞給
鏈中的下一個階段

00:32:55.943 --> 00:32:58.645
這裏的要點是
陰影貼圖的

00:32:58.712 --> 00:33:00.714
內容和後處理紋理

00:33:00.781 --> 00:33:02.382
從來不是同時使用的

00:33:02.983 --> 00:33:04.618
所以爲何不共享內存呢？

00:33:07.087 --> 00:33:10.824
我來給你展示如何用Swift
創建這些別名資源集

00:33:11.258 --> 00:33:12.960
這第一部分
應該看起來眼熟

00:33:13.327 --> 00:33:14.962
首先我們請求設備創建一個堆

00:33:15.796 --> 00:33:17.664
然後我們創建三個陰影貼圖

00:33:18.999 --> 00:33:21.802
現在我們看到了一個新方法
makeAliasable

00:33:22.469 --> 00:33:24.671
通過在堆資源上
調用makeAliasable

00:33:24.805 --> 00:33:28.342
你告訴那個堆
將資源的內存視爲閒置的

00:33:29.309 --> 00:33:32.980
陰影貼圖仍在啓用中
但是它們的內存可以自由

00:33:33.046 --> 00:33:35.482
被堆再分配給新的資源

00:33:36.650 --> 00:33:39.553
現在當我們在相同的堆上
創建後處理紋理時

00:33:40.087 --> 00:33:43.023
它們可以作爲陰影貼圖
佔用相同的內存

00:33:45.526 --> 00:33:47.794
現在我們來談談
一些最佳做法

00:33:47.861 --> 00:33:48.996
用於資源別名

00:33:50.163 --> 00:33:53.433
爲了實現動態資源的
內存再使用最大化

00:33:53.834 --> 00:33:56.703
調用資源創建方法

00:33:56.770 --> 00:34:00.040
在一個幀裏
資源所使用的相同序列中

00:34:00.574 --> 00:34:02.876
允許你調用
makeAliasable

00:34:03.544 --> 00:34:06.547
會允許你交錯
makeAliasable調用

00:34:06.947 --> 00:34:09.216
當資源內容被消耗的時候

00:34:11.717 --> 00:34:15.121
而且你要將動態資源和
靜態資源保持在分隔的堆中

00:34:15.822 --> 00:34:18.926
靜態資源一般無法進行別名
而且會導致

00:34:18.992 --> 00:34:22.596
動態資源無法互相使用別名

00:34:22.663 --> 00:34:24.331
由於堆的內存碎片

00:34:25.866 --> 00:34:28.735
接下來我將談談如何
實現堆資源的

00:34:28.802 --> 00:34:30.237
同步指令訪問

00:34:32.973 --> 00:34:36.643
目前我們討論了
憑藉子分配實現的快速資源創建

00:34:36.976 --> 00:34:39.713
以及通過資源別名
實現的高效內存使用

00:34:39.947 --> 00:34:42.482
但要記住資源堆是快速靈活的

00:34:42.549 --> 00:34:45.252
因爲你控制
堆資源的同步

00:34:45.819 --> 00:34:48.522
你在設備資源上不必這樣做

00:34:49.656 --> 00:34:52.226
但與設備資源不同
Metal不知道

00:34:52.292 --> 00:34:54.895
指令會什麼時候
修改堆資源的內容

00:34:55.395 --> 00:34:59.032
例如當渲染過程
將新內容存儲到紋理中

00:35:00.267 --> 00:35:02.503
Metal也不知道
你何時會將堆內存的

00:35:02.569 --> 00:35:05.506
解釋從一個別名集
改成另一個

00:35:07.174 --> 00:35:10.944
不過爲了正確性 Metal需要
知道何時指令會更新堆資源

00:35:11.011 --> 00:35:14.114
這樣其他指令
可以安全地讀取結果

00:35:14.915 --> 00:35:16.250
這尤爲重要

00:35:16.316 --> 00:35:18.986
因爲GPU可以並行
執行多個指令

00:35:20.654 --> 00:35:22.789
爲了實現堆資源的同步訪問

00:35:22.856 --> 00:35:25.926
你的應用程序會創建
並管理GPU柵欄

00:35:26.393 --> 00:35:29.196
來在指令之間
溝通資源依賴性

00:35:30.197 --> 00:35:32.132
我們深入看看
GPU柵欄的工作原理

00:35:33.333 --> 00:35:35.536
GPU柵欄就是時間戳

00:35:35.903 --> 00:35:39.506
是GPU執行時間軸上的
一個參考點

00:35:40.240 --> 00:35:43.310
你可以用柵欄
編碼兩種行動來同步指令

00:35:43.810 --> 00:35:47.214
指令可以更新柵欄
將時間戳向前移

00:35:47.281 --> 00:35:48.649
當指令完成後

00:35:49.483 --> 00:35:51.351
而且指令可以等待柵欄

00:35:51.552 --> 00:35:55.255
在執行之前 等到
GPU觸及最新的柵欄更新

00:35:56.623 --> 00:35:58.759
那我們回來看看
之前的遊戲幀

00:35:58.926 --> 00:36:00.561
我會展示給你
如何使用柵欄

00:36:00.661 --> 00:36:03.530
來實現別名堆資源的
同步指令訪問

00:36:05.132 --> 00:36:08.702
這就是示例幀
這個幀有三部分

00:36:08.802 --> 00:36:11.505
但現在我們有五個方框
因爲兩個渲染階段

00:36:11.572 --> 00:36:15.409
渲染過程分成了
頂點和片段處理步驟

00:36:16.043 --> 00:36:18.178
我們有陰影過程
主過程

00:36:18.245 --> 00:36:21.815
最後是後處理過程
我們會使用計算來執行

00:36:23.584 --> 00:36:27.855
Metal指令是按順序
提交給指令隊列的

00:36:28.488 --> 00:36:29.790
所以可能目前不清楚

00:36:29.857 --> 00:36:32.059
爲什麼我們需要
指令間的同步

00:36:32.993 --> 00:36:35.429
不過GPU是並行機
可以並行地

00:36:35.495 --> 00:36:36.930
執行多個指令

00:36:38.232 --> 00:36:41.902
我們iOS和tvOS產品中的
GPU可以執行頂點

00:36:42.302 --> 00:36:45.372
片段和計算指令
全部並行執行

00:36:45.439 --> 00:36:47.841
將GPU的利用率最大化

00:36:48.709 --> 00:36:52.412
GPU甚至可以同時
執行多個幀

00:36:53.247 --> 00:36:55.015
好了 現在你可能
會發現一個問題

00:36:56.049 --> 00:36:57.885
看看這兩個突出顯示的指令

00:36:58.519 --> 00:37:00.153
它們都是在同時更新

00:37:00.220 --> 00:37:01.922
別名堆資源

00:37:02.923 --> 00:37:04.925
我們要使用柵欄來修復它

00:37:06.193 --> 00:37:07.794
首先我們將柵欄帶入

00:37:09.162 --> 00:37:11.632
後處理指令更新柵欄

00:37:12.933 --> 00:37:16.036
所以陰影指令片段處理階段

00:37:16.103 --> 00:37:17.304
可以等待柵欄

00:37:18.539 --> 00:37:22.442
現在這兩個指令
不再同時執行了

00:37:23.510 --> 00:37:25.179
我將展示給你如何使用Swift

00:37:25.245 --> 00:37:27.481
給柵欄更新和柵欄等待編碼

00:37:29.483 --> 00:37:31.685
首先 我們用設備創建柵欄

00:37:32.352 --> 00:37:34.154
這是新方法
--不帶參數

00:37:34.955 --> 00:37:37.724
接下來 我們編碼
後處理計算編碼器

00:37:37.824 --> 00:37:39.193
在第一幀的結尾

00:37:39.693 --> 00:37:43.363
我們首先創建
computeCommandEncoder

00:37:43.597 --> 00:37:44.865
然後編碼分派

00:37:46.567 --> 00:37:51.104
在我們結束編碼器之前
我們首先更新柵欄

00:37:51.205 --> 00:37:55.843
這樣後續指令可以等待
直到這個指令執行完成

00:37:57.444 --> 00:38:01.248
在下一個幀中我們會
編碼陰影渲染

00:38:01.648 --> 00:38:03.283
我們創建
renderCommandEncoder

00:38:03.884 --> 00:38:06.353
在commandBufB中
代表指令緩衝

00:38:06.420 --> 00:38:07.521
用於下一幀

00:38:08.555 --> 00:38:12.159
不過在繪製場景之前
我們首先編碼柵欄等待

00:38:13.160 --> 00:38:16.196
來等待到GPU上的後處理完成

00:38:16.496 --> 00:38:18.565
注意這一次
這裏有兩個參數

00:38:18.632 --> 00:38:21.168
第二個參數
叫做beforeStages

00:38:22.436 --> 00:38:25.439
渲染指令在兩個階段中執行
--頂點和片段

00:38:25.539 --> 00:38:29.209
所以Metal允許你指定
特定的需要

00:38:29.276 --> 00:38:30.444
等待柵欄的階段

00:38:30.978 --> 00:38:32.980
在我們的例子中
只有片段階段需要

00:38:33.046 --> 00:38:36.583
訪問堆資源
所以我們指定片段階段

00:38:38.352 --> 00:38:40.654
最後 我們可以安全地
渲染我們的陰影貼圖

00:38:41.021 --> 00:38:43.390
因爲我們知道
這個指令只有在

00:38:43.457 --> 00:38:46.293
前一幀的後處理
完成後纔會執行

00:38:48.395 --> 00:38:51.265
讓我談談一些
指令同步的最佳做法

00:38:52.332 --> 00:38:55.202
你知道如果使用堆
你必須使用柵欄

00:38:55.269 --> 00:38:56.970
來同步指令訪問

00:38:57.037 --> 00:39:00.207
但你有這個控制是因爲
你非常清楚

00:39:00.274 --> 00:39:02.476
你的資源是如何使用的

00:39:02.776 --> 00:39:05.879
而且你的應用程序
會有更高的CPU效率

00:39:06.180 --> 00:39:08.515
如果使用Metal
爲你進行跟蹤

00:39:09.449 --> 00:39:11.785
例如
只初始化一次的紋理

00:39:11.852 --> 00:39:14.588
並且未被修改
是不需要跟蹤的

00:39:15.856 --> 00:39:17.057
另一個例子

00:39:17.324 --> 00:39:21.228
一起使用的資源可以
通過單個柵欄一同跟蹤

00:39:24.131 --> 00:39:27.067
所以讓我總結
資源堆的主旨

00:39:28.268 --> 00:39:31.071
憑藉子分配
更快速創建資源

00:39:32.239 --> 00:39:35.642
通過資源別名
更加有效使用內存預算

00:39:36.710 --> 00:39:43.083
然後使用GPU柵欄
實現GPU指令間的堆更新同步

00:39:45.953 --> 00:39:50.991
好了 現在我想介紹另一項
在iOS和tvOS上可用的新功能

00:39:51.058 --> 00:39:52.693
無記憶渲染目標

00:39:53.560 --> 00:39:55.162
這聽起來有點魔幻

00:39:55.295 --> 00:39:58.498
不過我會給你展示幾乎
所有Metal應用都能使用該功能

00:39:58.565 --> 00:40:02.703
只通過一行代碼
就節省大量的內存

00:40:04.571 --> 00:40:06.974
無記憶渲染目標
這種紋理

00:40:07.040 --> 00:40:10.077
不將任何系統內存
分配給紋理內容

00:40:10.811 --> 00:40:14.615
沒有任何內存
存儲紋理內容

00:40:14.848 --> 00:40:16.950
剩下的就是紋理元數據

00:40:17.017 --> 00:40:20.020
例如紋理尺寸和內部紋理格式

00:40:20.454 --> 00:40:22.956
很明顯 這節省了大量的內存

00:40:23.290 --> 00:40:25.526
但什麼時候能用
無記憶渲染目標呢？

00:40:26.426 --> 00:40:29.696
你可以將它們用於
未保存的渲染過程附件

00:40:30.497 --> 00:40:34.468
大多數Metal應用
會有一些附件與

00:40:34.535 --> 00:40:38.105
存儲不在意行動
或多重採樣解析有關

00:40:38.672 --> 00:40:42.109
而且用於那些渲染過程附件
的紋理可以是無記憶的

00:40:43.610 --> 00:40:46.180
要製作無記憶渲染目標

00:40:46.480 --> 00:40:49.116
你可以像平常創建紋理那樣

00:40:49.249 --> 00:40:51.185
使用額外存儲模式標記

00:40:51.351 --> 00:40:53.487
MTLStorageModeMemoryless

00:40:53.554 --> 00:40:54.454
這就行了

00:40:55.222 --> 00:40:59.193
該功能只支持iOS和tvOS
因爲它依靠於

00:40:59.259 --> 00:41:03.564
A7及其之後GPU的
磚牆式渲染架構

00:41:04.531 --> 00:41:06.233
我來給你展示其工作原理

00:41:07.201 --> 00:41:09.970
在你的右邊我們有
兩個渲染過程附件

00:41:10.070 --> 00:41:12.039
一個色彩附件
一個深度附件

00:41:13.073 --> 00:41:16.376
A7及其之後GPU
以每次一個分塊執行渲染過程

00:41:16.710 --> 00:41:20.380
利用快速的GPU分塊存儲

00:41:20.614 --> 00:41:22.015
在GPU的核心

00:41:23.050 --> 00:41:25.719
GPU分塊存儲包含
分塊大小的

00:41:25.786 --> 00:41:28.388
深度 模板以及
色彩附件的代表

00:41:28.856 --> 00:41:31.191
這個分塊存儲
是完全隔離於

00:41:31.491 --> 00:41:33.594
紋理支持和系統內存

00:41:34.995 --> 00:41:37.331
在Metal中 你的
加載和存儲動作控制着

00:41:37.397 --> 00:41:40.000
如何初始化GPU
分塊存儲 以及是否

00:41:40.067 --> 00:41:44.004
將GPU分塊存儲的結果
複製回系統內存裏

00:41:45.205 --> 00:41:47.207
如果附件未從內存中加載

00:41:47.274 --> 00:41:49.042
而且未保存在內存中

00:41:49.343 --> 00:41:52.012
你可以使那個附件的
紋理變得無記憶

00:41:52.079 --> 00:41:54.615
來消除內存分配

00:41:55.716 --> 00:41:57.851
接下來 我會描述
一些很常見的情景

00:41:57.918 --> 00:42:00.587
你可以將該功能
應用到你的應用上

00:42:02.789 --> 00:42:06.894
深度附件經常在3D場景中
用於啓用深度測試

00:42:07.895 --> 00:42:10.898
不過A7及其之後GPU
的深度測試是完全在

00:42:10.964 --> 00:42:13.433
GPU分塊存儲中進行
每次一個分塊

00:42:13.834 --> 00:42:16.503
深度測試不需要
使用系統內存

00:42:17.171 --> 00:42:19.940
如果你不保存深度紋理
爲之後過程所用

00:42:20.507 --> 00:42:22.709
那就將紋理變得無記憶
並節省下內存

00:42:24.311 --> 00:42:25.979
我來給你展示另一個機會

00:42:27.147 --> 00:42:29.049
當執行多重採樣渲染時

00:42:29.116 --> 00:42:32.786
A7及其之後GPU在
GPU分塊存儲中進行所有渲染

00:42:33.053 --> 00:42:35.789
MSAA色彩附件紋理
會被使用

00:42:35.856 --> 00:42:38.625
只有在你選擇
保存採樣數據以備後用

00:42:39.593 --> 00:42:43.397
不過大多數應用會選擇
多重採樣解析存儲動作

00:42:43.764 --> 00:42:46.133
這直接源於從GPU分塊存儲

00:42:46.200 --> 00:42:48.068
到解析色彩附件紋理

00:42:49.203 --> 00:42:52.739
在那種情況下 確保多重採樣
色彩附件紋理是無記憶的

00:42:52.806 --> 00:42:54.675
而且這會節省大量的內存

00:42:56.009 --> 00:42:59.346
如你所見 採用該功能
所帶來的節省是顯著的

00:42:59.613 --> 00:43:02.449
通過將1080p
深度紋理變成無記憶的

00:43:02.783 --> 00:43:04.952
你的應用會省下將近8MB空間

00:43:05.586 --> 00:43:09.223
若你在12.9英寸iPad Pro
上渲染原始分辨率

00:43:09.489 --> 00:43:11.959
深度緩存的節省會高達20MB

00:43:12.759 --> 00:43:15.395
而且將四倍多重採樣
渲染目標變得

00:43:15.462 --> 00:43:18.498
無記憶 會節省下更多
4倍之多

00:43:19.733 --> 00:43:23.303
所以使用無記憶渲染目標
來最大程度使用

00:43:23.370 --> 00:43:25.772
你的應用程序的內存預算

00:43:26.340 --> 00:43:29.409
使用這省下的空間降低
你遊戲的內存佔用

00:43:29.510 --> 00:43:31.812
或更好
用省下的空間

00:43:31.879 --> 00:43:34.248
在遊戲中加入更加
精美獨特的內容

00:43:36.350 --> 00:43:40.754
我想邀請Jose上臺告訴大家
關於Metal工具上的所有改進

00:43:47.394 --> 00:43:48.262
謝謝 James

00:43:48.595 --> 00:43:50.898
除了Metal API上
新加的出色功能

00:43:50.964 --> 00:43:54.234
我們在Metal Developer Tool上
有一些出色的改進 給大家展示

00:43:56.904 --> 00:43:59.239
首先我們會談談
Metal System Trace的新功能

00:43:59.773 --> 00:44:02.309
之後介紹一項新功能
叫做GPU Overrides

00:44:03.076 --> 00:44:05.279
我們有一些非常
激動人心的新功能

00:44:05.345 --> 00:44:07.514
登錄到
GPU Frame Debugger

00:44:11.785 --> 00:44:13.253
什麼是
Metal System Trace？

00:44:14.254 --> 00:44:16.990
在之前的Metal演講中
我們出示了這個圖表

00:44:17.591 --> 00:44:21.295
展示了Metal在CPU和GPU
上的工作情況

00:44:22.062 --> 00:44:25.866
Metal System Trace
這一套工具可以將其可視化

00:44:26.633 --> 00:44:29.503
幫助你瞭解你的
Metal應用程序的時間軸

00:44:29.803 --> 00:44:33.340
通過整體圖形管線
從CPU

00:44:33.740 --> 00:44:36.643
到GPU
再到顯示器

00:44:38.812 --> 00:44:43.016
去年 WWDC 我們推出了
iOS平臺的Metal System Trace

00:44:43.750 --> 00:44:46.253
我極力推薦去觀看去年的展示

00:44:46.320 --> 00:44:48.388
來更好地總覽Metal
System Trace

00:44:49.690 --> 00:44:52.392
之後在秋季
我們加入了tvOS支持

00:44:53.160 --> 00:44:55.662
今天我們很高興宣佈Metal
System Trace

00:44:55.729 --> 00:44:59.199
登錄macOS 幫助你
榨乾最後一滴性能

00:44:59.733 --> 00:45:01.168
在所有Metal平臺上

00:45:06.406 --> 00:45:08.642
我們全方位地改進了Metal
System Trace

00:45:08.709 --> 00:45:10.377
擴展我們報告的事件

00:45:12.145 --> 00:45:13.213
對於資源事件

00:45:13.280 --> 00:45:16.116
我們將高開銷的資源操作
變得直觀 例如選取數據

00:45:16.183 --> 00:45:18.085
從系統內存到顯存

00:45:20.053 --> 00:45:24.324
這種案例中
我們能看到macOS中的繪製

00:45:24.391 --> 00:45:26.426
這導致了GPU執行延遲

00:45:29.463 --> 00:45:32.666
Metal System
Trace還顯示調試組

00:45:32.833 --> 00:45:36.937
這讓你更容易讓你瞭解
跟蹤中的指令編碼關係

00:45:38.839 --> 00:45:42.509
在macOS上 我們支持
同時跟蹤多個GPU

00:45:42.776 --> 00:45:44.678
這對一些使用案例來說
這難以置信

00:45:44.745 --> 00:45:47.481
比如你在不同GPU之間分配工作

00:45:49.349 --> 00:45:52.052
在iOS上
我們現在顯示定標器工作量

00:45:52.119 --> 00:45:54.922
所以當你遇到延遲時
可以進行診斷

00:45:55.222 --> 00:45:57.558
通過旋轉或縮放你的視圖

00:46:01.094 --> 00:46:03.363
你現在可以將種類更多的工具

00:46:03.430 --> 00:46:05.132
與Metal System
Trace一同使用

00:46:05.599 --> 00:46:09.970
例如Time Profiler
File Activity

00:46:10.838 --> 00:46:13.273
Allocations 還有更多

00:46:13.607 --> 00:46:18.078
甚至不同的視圖 例如CPU數據
這會展示CPU核心時間片段

00:46:19.713 --> 00:46:23.483
這會幫助你將Metal事件
與內容進行關聯

00:46:23.550 --> 00:46:25.152
深入瞭解

00:46:25.219 --> 00:46:27.888
系統運行應用程序的情況

00:46:27.955 --> 00:46:34.895
允許你診斷像是由
CPU停滯引起的GPU飢餓

00:46:35.429 --> 00:46:37.264
由於錯誤的I/O操作

00:46:40.767 --> 00:46:43.136
Metal System
Trace會捕捉大量的數據

00:46:43.504 --> 00:46:45.939
所以我們讓解釋和
導航變得更容易

00:46:47.441 --> 00:46:49.243
使用新的工作量突出顯示

00:46:49.443 --> 00:46:52.279
你可以注重於任何
指令編碼器或編碼緩衝

00:46:53.113 --> 00:46:54.848
隨着它在管線中通過

00:46:55.182 --> 00:46:56.783
通過鍵盤導航支持

00:46:56.850 --> 00:46:59.219
你可以將你的選擇
快速地在跟蹤中移動

00:47:01.655 --> 00:47:04.625
最後我想介紹Performance
Observation

00:47:04.958 --> 00:47:07.761
Performance
Observation是給你呈現

00:47:07.828 --> 00:47:10.764
潛在問題的完整列表
這是我們在

00:47:10.831 --> 00:47:12.499
跟蹤中通過分析找到的

00:47:13.934 --> 00:47:16.470
從顯示面耗時過長

00:47:17.504 --> 00:47:20.140
到意外着色器彙編

00:47:21.241 --> 00:47:23.510
或者高GPU執行時間

00:47:24.344 --> 00:47:27.781
Performance Observations
替你發現你在尋找的事件

00:47:28.215 --> 00:47:31.451
你能從Performance
Observation列表直接導航

00:47:32.619 --> 00:47:33.887
所有這些新功能
會允許你

00:47:33.954 --> 00:47:37.457
調整你的Metal應用程序
使其如你所想的那樣流暢運行

00:47:38.358 --> 00:47:41.595
現在爲了展示我們在
GPU調試上做出的出色改進

00:47:41.662 --> 00:47:43.430
讓我交給我的同事 Alp

00:47:43.897 --> 00:47:47.434
演示GPU
Frame Debugger

00:47:56.977 --> 00:47:57.878
謝謝 Jose

00:47:58.779 --> 00:48:01.181
我今天有很多
出色的功能要給大家展示

00:48:01.348 --> 00:48:02.716
我們直接開始吧

00:48:04.117 --> 00:48:05.652
我的應用在這裏運行

00:48:05.819 --> 00:48:09.590
漫遊過美麗的地形
細節由曲面細分做到了極致

00:48:10.657 --> 00:48:12.993
在線框圖中查看這個地形該多好

00:48:13.060 --> 00:48:14.862
去查看每一個三角形

00:48:15.896 --> 00:48:19.499
好消息是 我們最新的功能
GPU Overrides

00:48:19.600 --> 00:48:22.069
讓你能夠修改你的Metal渲染

00:48:22.169 --> 00:48:24.705
直接從調試欄
當應用還在運行時

00:48:26.039 --> 00:48:28.775
我們有多個不同的
覆蓋你可以混搭使用

00:48:28.842 --> 00:48:30.210
包括線框圖模式

00:48:31.445 --> 00:48:35.015
我們切換到線框圖模式
來看看地形的曲面細分程度

00:48:37.184 --> 00:48:38.785
顯示每個三角形

00:48:39.019 --> 00:48:41.922
你可能想要調整
曲面細分來找到

00:48:41.989 --> 00:48:44.558
性能和視覺品質之間平衡

00:48:45.259 --> 00:48:49.263
通常你需要回去更改你的代碼
重新編譯 然後運行

00:48:49.796 --> 00:48:52.332
但是有了GPU Overrides
你可以

00:48:52.399 --> 00:48:55.636
直接從Overrides菜單
試驗曲面細分比例

00:48:57.070 --> 00:48:59.406
我們將比例設置到25%

00:49:02.242 --> 00:49:06.313
現在我們有更少的三角形
而且還丟失了一些有趣的細節

00:49:07.648 --> 00:49:09.283
我們試試75%

00:49:11.685 --> 00:49:14.688
我認爲這個效果更好
我們看看沒有線框圖的樣子

00:49:16.757 --> 00:49:18.091
可以 我喜歡這個

00:49:18.525 --> 00:49:21.161
這比開始少了很多三角形

00:49:21.461 --> 00:49:23.130
不過還是有全部的細節

00:49:23.197 --> 00:49:27.167
外加提升的性能 我可以
在場景中加入更多炫酷效果

00:49:28.702 --> 00:49:32.539
如你所見 GPU
Overrides這工具非常有助於

00:49:32.606 --> 00:49:34.775
初次診斷場景中的

00:49:34.842 --> 00:49:36.877
一些視覺和性能問題

00:49:38.345 --> 00:49:43.016
接下來我們捕捉這一幀
來給你展示一些功能

00:49:43.083 --> 00:49:45.452
來極大提升你的調試工作流

00:49:47.988 --> 00:49:49.323
幀捕捉已經完成

00:49:49.556 --> 00:49:55.362
我在查看地形資源
來看看地形面片的情況

00:49:57.397 --> 00:50:00.467
在Resource Center
中切換到所有GPU對象

00:50:00.868 --> 00:50:03.303
你能看到所有的紋理和緩衝

00:50:06.206 --> 00:50:08.141
我們這裏有全部的資源

00:50:08.442 --> 00:50:10.577
我要一個個地查看

00:50:10.644 --> 00:50:13.614
來找地形資源
會花一些時間

00:50:14.615 --> 00:50:17.117
這就是新的篩選條
發揮作用的時刻

00:50:17.985 --> 00:50:21.421
你可以按這裏的任何屬性
進行篩選 例如標籤

00:50:21.922 --> 00:50:23.790
類型 大小或者細節

00:50:25.559 --> 00:50:29.029
因爲我標註了所有的資源
我就只按地形篩選

00:50:29.897 --> 00:50:33.834
在這裏 我有所有
用於渲染地形的資源

00:50:35.569 --> 00:50:37.704
現在我找到了
地形面片緩衝

00:50:38.005 --> 00:50:41.108
我想做的是
看看它用在什麼地方

00:50:42.409 --> 00:50:47.014
通過簡單的拖放
我可以篩選功能導航器

00:50:47.080 --> 00:50:51.785
給我展示所有用於地形面片
緩衝的調用 就像這樣

00:50:52.586 --> 00:50:56.323
在這個案例中 我使用計算
得知了它的計算位置

00:50:56.823 --> 00:50:59.793
以及當渲染地形時
它的讀取位置

00:51:01.662 --> 00:51:03.230
這個篩選十分強大

00:51:03.697 --> 00:51:06.066
我還可以使用綁定資源的

00:51:06.133 --> 00:51:08.168
其他任何屬性
來篩選繪製調用

00:51:09.069 --> 00:51:12.239
例如 如果你按sRGB篩選

00:51:12.706 --> 00:51:16.343
你會看到所有繪製調用
使用的紋理

00:51:16.410 --> 00:51:18.478
都是sRGB像素格式

00:51:19.613 --> 00:51:22.850
這是很自然的方式
快速地在幀上導航

00:51:25.085 --> 00:51:28.388
接下來 我們進入
綁定GPU對象

00:51:28.455 --> 00:51:31.859
來看看我們是如何
使用資源來渲染地形的

00:51:34.194 --> 00:51:36.864
在綁定模式中
你的資源歸入在

00:51:36.930 --> 00:51:39.032
不同的部分中
基於使用它們的

00:51:39.099 --> 00:51:43.036
Metal管線階段
所以你知道到哪裏去找

00:51:44.404 --> 00:51:46.073
看看頂點階段

00:51:46.139 --> 00:51:49.443
地形面片是一個
綁定到多個綁定點的緩衝

00:51:49.510 --> 00:51:50.744
擁有不同的偏移量

00:51:52.279 --> 00:51:55.482
我們使用唯一的
緩衝來檢查數據

00:51:57.918 --> 00:51:59.953
所有的頂點數據的佈局

00:52:00.020 --> 00:52:03.390
排列整齊 除了這是
來自帶有面片的Metal函數

00:52:03.957 --> 00:52:07.828
所以這使用了與
後頂點函數完全相同的結構體

00:52:09.863 --> 00:52:11.498
我們這裏有顏色數據

00:52:11.899 --> 00:52:15.435
它識別顏色單詞
然後在這裏顯示

00:52:15.502 --> 00:52:17.070
值的真正顏色

00:52:19.640 --> 00:52:22.976
因爲這是包含
不同數據類型的大型緩衝

00:52:23.210 --> 00:52:27.080
我用新的MTLBuffer API
添加了一些調試標記

00:52:27.247 --> 00:52:30.117
這會讓你極其輕鬆地
找到你想要的東西

00:52:32.719 --> 00:52:35.389
通過佈局菜單
你可以直接跳入

00:52:35.455 --> 00:52:38.125
其他你想檢查的可用佈局

00:52:43.230 --> 00:52:45.098
查看單個緩衝是很好的

00:52:45.866 --> 00:52:48.836
更好的是
新的輸入屬性視圖

00:52:49.469 --> 00:52:52.172
讓你看到所有的頂點數據

00:52:52.239 --> 00:52:53.974
與頂點着色器的視角一樣

00:52:55.943 --> 00:52:58.979
輸入屬性從你的實例
中收集所有數據

00:52:59.413 --> 00:53:02.749
曲面細分因子緩衝
和stage_in數據

00:53:03.283 --> 00:53:06.954
之後提供給你單個視圖
來一同查看它們

00:53:10.190 --> 00:53:14.061
在這個案例中
我們用多個面片渲染實例

00:53:14.361 --> 00:53:18.699
我可以看出什麼數據
屬於實例的哪個面片

00:53:20.601 --> 00:53:22.269
所以這簡短介紹了

00:53:22.336 --> 00:53:25.005
GPU Frame
Debugger上的一些最新功能

00:53:25.072 --> 00:53:27.407
我們切回幻燈片
做個總結

00:53:32.212 --> 00:53:35.449
演示GPU
Frame Debugger

00:53:37.784 --> 00:53:41.421
你剛纔看到了一些最新的GPU
Frame Debugger功能

00:53:41.588 --> 00:53:43.590
我想再告訴大家兩個

00:53:46.326 --> 00:53:49.596
有了新Extended Validation模式
GPU Frame Debugger可以

00:53:49.663 --> 00:53:52.533
進行更加深入的應用分析

00:53:53.333 --> 00:53:57.271
在選擇最佳紋理使用上
提供推薦

00:53:57.371 --> 00:53:59.573
或者資源的存儲模式

00:54:01.275 --> 00:54:04.278
你可以從Xcode方案編輯器
中啓用這個模式

00:54:07.548 --> 00:54:10.384
獨立Metal Library
Projects的新支持

00:54:10.450 --> 00:54:14.354
讓你創建Metal庫
在多個應用中共享

00:54:14.755 --> 00:54:17.157
或者將多個庫
包含在一個應用中

00:54:17.658 --> 00:54:19.960
就像其他任何框架或庫

00:54:22.729 --> 00:54:24.331
使用我們講的功能

00:54:24.398 --> 00:54:26.333
能極大提升
你的工具體驗

00:54:26.900 --> 00:54:30.037
現在我們總結
本次演講中看到的內容

00:54:32.840 --> 00:54:36.410
我們看到通過曲面細分
給Metal API新增的功能

00:54:36.844 --> 00:54:39.646
資源堆和無記憶渲染目標

00:54:40.147 --> 00:54:42.216
之後我們展示了改進的工具

00:54:42.282 --> 00:54:44.685
Metal System Trace
和GPU Frame Debugger

00:54:45.519 --> 00:54:47.754
一定要看看
下午的第二部分

00:54:47.821 --> 00:54:50.991
我會講講關於函數特殊化

00:54:51.124 --> 00:54:52.826
和函數資源讀寫

00:54:53.760 --> 00:54:55.696
廣色域和紋理資源

00:54:56.230 --> 00:54:58.765
以及Metal性能
着色器的增加功能

00:55:00.868 --> 00:55:04.204
有關更多本次演講的信息
請訪問這個網絡連接

00:55:04.605 --> 00:55:09.142
你可以補看視頻 並得到
資料和示例代碼鏈接

00:55:11.812 --> 00:55:15.148
我們昨天的演講十分精彩
你可以在線觀看

00:55:15.816 --> 00:55:19.219
這個下午 我們有
Metal的新功能 第二部分

00:55:19.419 --> 00:55:22.155
之後高級Metal着色器優化
就在這個演講廳

00:55:23.190 --> 00:55:25.492
感謝大家的到來
祝各位 WWDC 過得愉快