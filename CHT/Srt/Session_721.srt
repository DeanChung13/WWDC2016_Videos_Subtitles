00:00:19.920 --> 00:00:23.624
統一日誌和活動追蹤
記錄未來

00:00:30.764 --> 00:00:36.503
歡迎大家來到“統一日誌和
活動追蹤——記錄未來”

00:00:36.603 --> 00:00:40.307
感謝大家
能在週五晚上來到這裏

00:00:41.775 --> 00:00:43.877
我是
Steven Szymanski

00:00:48.248 --> 00:00:50.684
真沒想到這個時間
還有這麼多人來聽

00:00:50.751 --> 00:00:53.987
我是Steven Szymanski
將會主持大部分演講

00:00:54.054 --> 00:00:56.757
稍後我會邀請
Matthieu Lucas上臺

00:00:57.624 --> 00:01:00.994
那麼我們開始吧
要講的內容很多

00:01:01.728 --> 00:01:03.764
我開始先做個
簡單的介紹

00:01:03.830 --> 00:01:07.067
然後講講新的日誌系統
背後的基本概念

00:01:07.134 --> 00:01:08.869
這是這周
才引入的新系統

00:01:08.936 --> 00:01:10.704
一會兒
做個簡短的演示

00:01:10.771 --> 00:01:13.006
然後再回過頭來
講解如何真正使用它

00:01:13.073 --> 00:01:15.742
如何使用API
怎麼使用這些工具

00:01:16.243 --> 00:01:19.947
再討論一下
我們心目中的最佳操作

00:01:21.215 --> 00:01:24.384
然後講一下
如何收集你創建的記錄

00:01:24.685 --> 00:01:27.588
最後講一些
棄用的界面

00:01:28.722 --> 00:01:29.790
那麼開始吧

00:01:31.658 --> 00:01:32.960
先講一點背景

00:01:33.660 --> 00:01:37.297
如果你已經聽過幾場演講
你就知道在2014年

00:01:37.664 --> 00:01:40.300
Apple引入了“活動追蹤”的概念

00:01:40.801 --> 00:01:43.937
它能跟蹤所有的工作

00:01:44.204 --> 00:01:47.908
代表某些操作
在整個系統裏運行

00:01:48.141 --> 00:01:50.878
這個工作可以在一個應用裏完成

00:01:50.978 --> 00:01:55.082
可以在應用調出的一個框架庫裏完成

00:01:55.148 --> 00:01:59.052
甚至可以代表應用在另外的進程裏完成

00:02:00.053 --> 00:02:02.289
我們同時引入的另一個概念

00:02:02.856 --> 00:02:04.691
就是故障和錯誤

00:02:04.758 --> 00:02:10.464
這種特殊類型的日誌事件
會引發額外的工作

00:02:10.531 --> 00:02:12.566
讓系統收集額外數據

00:02:14.101 --> 00:02:16.670
作爲開場白的最後一點

00:02:16.737 --> 00:02:21.008
就是我們意識到
Apple已有一些記錄API

00:02:21.074 --> 00:02:25.179
而且希望演講結束後
你能明白我們爲什麼要介紹

00:02:25.245 --> 00:02:29.149
這個新的API
以及它如何與其他人相互關聯

00:02:32.186 --> 00:02:34.755
那麼這個項目的目標是什麼？

00:02:35.455 --> 00:02:38.025
首先我們想要做的是創建

00:02:38.091 --> 00:02:42.763
一個公開公共且有效的記錄機制
覆蓋整個系統

00:02:42.829 --> 00:02:45.432
既能用在用戶模式下
也能用在內核模式下

00:02:45.499 --> 00:02:46.834
目標

00:02:46.900 --> 00:02:51.205
其中一個目的是爲了
儘可能多的收集信息

00:02:51.271 --> 00:02:54.541
同時 最小化觀察者效應

00:02:55.309 --> 00:02:59.112
這裏的觀察者效應指的是
我們開發者都有的體驗

00:02:59.179 --> 00:03:02.883
當你遇到問題
將一些日誌粘貼到你的代碼

00:03:02.950 --> 00:03:06.153
問題一下子就沒有了
因爲你改變了時間

00:03:06.453 --> 00:03:10.023
我們想要一個無痕的
記錄界面

00:03:10.090 --> 00:03:14.494
在你調出代碼的時候
對代碼的影響最小

00:03:15.596 --> 00:03:19.166
如何實現這一目標
就是這場演講我要具體講的內容

00:03:19.499 --> 00:03:21.001
首先 我們壓縮數據

00:03:21.435 --> 00:03:25.506
這樣就能在磁盤上
存更多的信息

00:03:26.607 --> 00:03:28.842
卻不佔用更多空間

00:03:29.910 --> 00:03:33.280
另外一件重要的事就是
我們延遲了許多工作

00:03:33.780 --> 00:03:38.185
我們能做的所有事情
都是在顯示信息的時候

00:03:38.252 --> 00:03:42.055
而不是在收集信息的時候
所以我們想要延遲到那個時候

00:03:42.122 --> 00:03:45.125
這是我們採用的主要方法
來避免觀察者效應

00:03:46.159 --> 00:03:51.698
另外我們做的就是用新方法
來管理消息的生命週期

00:03:52.232 --> 00:03:54.601
我們的想法是
不同種類的信息

00:03:54.668 --> 00:03:57.704
可能在系統裏
停留的時間不同

00:03:57.771 --> 00:04:01.942
要儘可能讓你想要的信息
真正出現在

00:04:02.009 --> 00:04:03.610
你實際去研究
和使用它們的時候

00:04:04.378 --> 00:04:07.247
背景情況是
我們想要能

00:04:07.314 --> 00:04:11.051
打開系統裏儘可能多的日誌
無論在任何時候

00:04:11.351 --> 00:04:13.220
而不需要回去再說

00:04:13.287 --> 00:04:16.423
“能否打開這個
再給我一個新的日誌”

00:04:16.490 --> 00:04:18.659
我們要看到所有
越多越好

00:04:20.060 --> 00:04:21.762
另外一個動機是

00:04:21.827 --> 00:04:25.732
我們想把隱私
完全融入系統裏

00:04:25.832 --> 00:04:27.568
這個我一會兒也會細講

00:04:30.003 --> 00:04:32.105
那麼
這個新系統的主要功能是什麼？

00:04:33.207 --> 00:04:38.245
就是用新改進的方法
分類和篩選日誌消息

00:04:38.545 --> 00:04:40.948
因此我們將爲你
提供新的工具

00:04:41.014 --> 00:04:43.550
讓你能給日誌信息分類

00:04:43.617 --> 00:04:45.853
這樣在需要查看日誌的時候

00:04:46.220 --> 00:04:48.822
能更簡單的找到
你要的信息

00:04:49.323 --> 00:04:50.424
特性

00:04:50.490 --> 00:04:55.662
另外很重要的一點是
日誌系統會爲你收集調令源的信息

00:04:55.729 --> 00:05:00.767
所以你不再需要傳遞文件和代碼行

00:05:00.834 --> 00:05:02.769
去確定這個調令來自哪裏

00:05:02.836 --> 00:05:04.905
我們自動爲你收集好

00:05:12.379 --> 00:05:15.782
這裏還有很多
新的內置分類符

00:05:16.183 --> 00:05:19.887
讓我們可以爲你
處理二進制數據的格式

00:05:19.953 --> 00:05:21.989
這樣你就不用
花時間做這個了

00:05:22.856 --> 00:05:25.726
我們有個新的Console應用
和一個新的命令行工具

00:05:25.792 --> 00:05:27.761
我們用它們
來訪問所有的功能

00:05:29.329 --> 00:05:31.365
我們所有的平臺都支持它

00:05:31.431 --> 00:05:35.936
macOS iOS watchOS
tvOS和所有的模擬器

00:05:36.503 --> 00:05:38.005
它同時也可用於...

00:05:43.143 --> 00:05:48.282
用於這周發佈的C
C++和Objctive-C版本

00:05:48.348 --> 00:05:50.717
不久之後也會支持Swift

00:05:54.021 --> 00:05:56.990
那麼現在
給你一些小預告

00:05:57.057 --> 00:05:59.927
這是現在使用的Console應用
就是你看到的這樣

00:06:01.528 --> 00:06:04.431
而這是
新Console的樣子

00:06:04.498 --> 00:06:07.000
這裏我要指出

00:06:11.705 --> 00:06:14.308
仔細看看高亮的這一部分

00:06:14.374 --> 00:06:18.579
這個樹狀圖向你展示的
是一個特定活動

00:06:18.645 --> 00:06:20.948
不斷從一個進程
到另一個進程的過程

00:06:21.014 --> 00:06:24.218
這樣你就可以直觀的看到
所有的工作情況

00:06:24.284 --> 00:06:26.720
它們代表你所請求的操作

00:06:28.789 --> 00:06:32.359
那麼我們先來打個基礎 講講理論

00:06:32.426 --> 00:06:34.328
以及背後的抽象概念

00:06:35.195 --> 00:06:36.330
首先 採用

00:06:37.197 --> 00:06:41.001
如果你想使用新的統一日誌系統
你一開始要做的

00:06:41.068 --> 00:06:43.737
就是使用這周新發布的SDK
來進行創建

00:06:45.172 --> 00:06:46.373
如果這樣做

00:06:46.440 --> 00:06:51.144
所有遺留的API NSLog
asl log和message syslog

00:06:51.211 --> 00:06:54.581
所有這些
都會被重新引入新系統

00:06:54.715 --> 00:06:58.051
你一行代碼都不用改
就可以開始使用這個系統

00:06:58.118 --> 00:07:03.290
當然如果要使用這些新功能
就要開始使用新的API

00:07:03.357 --> 00:07:06.994
但是如果你什麼都不做
直接使用新系統創建

00:07:07.060 --> 00:07:09.730
它們就都被引入
新的日誌架構

00:07:10.531 --> 00:07:13.600
另一方面
如果你不想開始使用

00:07:13.667 --> 00:07:16.970
新的日誌系統
並且繼續用舊的SDK創建

00:07:17.037 --> 00:07:19.039
那麼你的系統
不會有任何變化

00:07:19.106 --> 00:07:20.207
採用

00:07:21.041 --> 00:07:23.377
下面來講
新的文件格式

00:07:25.646 --> 00:07:31.151
在新的系統裏
日誌數據是以二進制形式壓縮在磁盤裏

00:07:31.218 --> 00:07:32.886
叫做.tracev3文件

00:07:34.521 --> 00:07:37.958
這些文件現在的保存路徑爲
/var/db/diagnostics

00:07:38.559 --> 00:07:42.696
其輔助文件的路徑爲
/var/db/uuidtext

00:07:43.997 --> 00:07:46.800
現在可以用新的工具
訪問這個數據

00:07:46.867 --> 00:07:49.803
我們有新的Console
新的命令行工具

00:07:50.070 --> 00:07:51.371
你還要記住一點

00:07:51.438 --> 00:07:55.142
就是由於數據
以二進制格式保存

00:07:55.409 --> 00:07:57.477
你必須使用新工具來訪問

00:07:57.544 --> 00:08:01.348
所以你不能再用grep命令查找日誌
而必須用我們的工具

00:08:01.415 --> 00:08:02.716
來瀏覽日誌

00:08:04.151 --> 00:08:07.487
還有另一種新的文件類型
.logarchive

00:08:07.554 --> 00:08:09.990
這是爲了
實現數據可移植性

00:08:10.390 --> 00:08:13.927
其實.logarchive文件
是信息的集合

00:08:13.994 --> 00:08:17.364
來自/var/db/diagnostics
和uuidtext

00:08:17.431 --> 00:08:19.733
它們集合到一個文件裏

00:08:19.800 --> 00:08:25.405
這樣就能更方便郵件傳輸
添加到故障報告等

00:08:28.041 --> 00:08:30.210
這個系統背後的
另一個新概念是

00:08:30.277 --> 00:08:32.145
子系統和分類

00:08:33.179 --> 00:08:37.017
日誌消息現在可以
與一個子系統和一個分類聯繫在一起

00:08:38.284 --> 00:08:42.556
它可以用來控制
日誌消息的篩選和顯示

00:08:43.890 --> 00:08:47.427
一個子系統實際上
可以包含很多個不同的類別

00:08:47.861 --> 00:08:52.165
而且你可以使用很多子系統和分類
只要你需要

00:08:53.033 --> 00:08:57.237
舉個例子
你可能有一些應用

00:08:57.304 --> 00:09:01.775
並定義一個子系統爲
com.your-company.your-application

00:09:01.842 --> 00:09:06.246
它有三個分類setup
inprogress和teardown

00:09:06.914 --> 00:09:08.348
在同一個應用裏

00:09:08.415 --> 00:09:14.855
你還可以定義另一個子系統
com.your-company.test.your-application

00:09:14.922 --> 00:09:17.324
只包含一個分類測試

00:09:17.758 --> 00:09:22.129
你可以用它們
來控制日誌消息的顯示

00:09:23.664 --> 00:09:26.400
日誌行爲
這是這個系統的核心所在

00:09:27.034 --> 00:09:32.072
每個日誌消息都有一個級別
由你創建使用的API決定

00:09:32.372 --> 00:09:36.376
有三個基本級別：Default
Info和Debug

00:09:36.910 --> 00:09:39.847
還有兩個特殊級別：故障和錯誤

00:09:42.516 --> 00:09:44.918
每個基本級別有兩個特徵

00:09:44.985 --> 00:09:49.289
既可以在系統範圍內
定義給某個子系統

00:09:49.556 --> 00:09:52.392
也可以給子系統裏
定義一個特定類別

00:09:53.160 --> 00:09:54.795
第一個是指
是否可用

00:09:54.862 --> 00:09:57.898
如果你發出指令
它是否真的能生成一個log line

00:09:58.699 --> 00:10:01.835
要注意
默認消息總是可用的

00:10:01.935 --> 00:10:03.770
你無法關閉默認消息

00:10:05.172 --> 00:10:08.709
另一個特徵就是
你可以定義所有級別

00:10:08.775 --> 00:10:10.911
是要保存到磁盤
還是內存

00:10:11.211 --> 00:10:13.747
看上去應該是
存到磁盤裏

00:10:14.982 --> 00:10:16.917
但是我說的是
存到內存裏

00:10:16.984 --> 00:10:19.253
新的統一日誌系統

00:10:19.319 --> 00:10:23.624
保存了大量的
內存中環形緩衝區

00:10:23.824 --> 00:10:26.360
一些日誌消息
可以被轉到這裏

00:10:26.860 --> 00:10:30.931
然後這些消息只會在
故障和錯誤時存到磁盤裏

00:10:31.832 --> 00:10:34.968
這很有用
尤其是對很快就過期的消息來說

00:10:35.035 --> 00:10:37.004
假設你有一個消息

00:10:37.337 --> 00:10:41.875
這個信息
基本上已經沒用了

00:10:42.042 --> 00:10:44.945
你所能看到的
就是這個消息最後的版本

00:10:45.012 --> 00:10:49.550
無論何時你收到一個日誌
都沒有必要把幾百個

00:10:49.616 --> 00:10:50.918
不同的備份存到磁盤上

00:10:51.218 --> 00:10:55.989
如果存到緩衝區
它就可以在故障與錯誤中找到

00:10:56.056 --> 00:10:57.791
而且就是你需要的
最後一版

00:10:57.858 --> 00:10:59.960
而不用存
一堆額外的東西

00:11:01.695 --> 00:11:03.864
這些級別是有順序的

00:11:03.931 --> 00:11:06.800
也就是說 若你定義Debug給磁盤

00:11:06.867 --> 00:11:09.403
那麼信息也會引入磁盤

00:11:11.305 --> 00:11:13.240
所有這些行爲都可以自定義

00:11:13.307 --> 00:11:16.777
通過安裝文件
或者在macOS上使用log命令

00:11:19.379 --> 00:11:21.415
會立刻出現
什麼樣的標準行爲呢？

00:11:21.481 --> 00:11:24.151
如果你沒有安裝
一個特定文件的話

00:11:24.985 --> 00:11:28.055
Default級別的消息
總是可用

00:11:28.121 --> 00:11:31.959
標準配置下
他們會進入磁盤

00:11:32.693 --> 00:11:36.263
Info級別的信息可用
但是他們進入內存

00:11:37.197 --> 00:11:42.536
Debug級別的信息是關閉的
他們不可用

00:11:42.603 --> 00:11:45.172
當然因爲處於關閉
他們哪裏也去不了

00:11:46.406 --> 00:11:50.344
那麼另外兩種類型的消息
就是故障和錯誤

00:11:51.512 --> 00:11:54.448
故障和錯誤通常都是開啓的
並總是存入磁盤

00:11:56.650 --> 00:11:58.418
現在花點時間
來講講隱私

00:11:59.686 --> 00:12:02.990
你知道
Apple十分重視客戶隱私

00:12:03.056 --> 00:12:05.792
作爲指導原則
我們設計的所有產品

00:12:05.859 --> 00:12:09.162
在我們的應用 服務
以及OS的新版本

00:12:09.429 --> 00:12:11.565
都要尊重用戶的隱私

00:12:11.999 --> 00:12:16.403
所有的開發者 包括你們在座的各位
都跟我們有一樣的責任

00:12:17.070 --> 00:12:18.539
如何在日誌裏體現呢？

00:12:18.605 --> 00:12:21.375
我們想避免的是不小心記錄了

00:12:21.441 --> 00:12:25.078
能夠識別個人信息的日誌

00:12:25.279 --> 00:12:27.915
這樣其他人就可以
從日誌數據中提取信息

00:12:28.882 --> 00:12:33.287
因此 動態字符串
集合 陣列和對象等

00:12:33.353 --> 00:12:36.056
都被認爲
是包含隱私的數據

00:12:36.256 --> 00:12:39.626
靜態字符串和標量
被認爲是可公開的

00:12:40.694 --> 00:12:44.231
稍後我們會進一步講講
怎樣控制它

00:12:45.632 --> 00:12:46.567
現在來看
故障和錯誤

00:12:46.633 --> 00:12:50.470
我之前講過
作爲活動追蹤的一部分

00:12:50.838 --> 00:12:53.040
我們引入了
故障和錯誤的概念

00:12:54.374 --> 00:12:56.577
它的一個基本理念就是

00:12:56.643 --> 00:13:00.948
我們在故障和錯誤上
下更多功夫

00:13:01.014 --> 00:13:02.549
就能保存更多的信息

00:13:03.283 --> 00:13:06.553
錯誤指的是一個問題

00:13:06.620 --> 00:13:09.056
出現在不同應用或者庫裏

00:13:09.857 --> 00:13:13.961
對於錯誤
我們查找內存緩衝區

00:13:14.027 --> 00:13:17.898
收集來自相關進程的
所有日誌消息

00:13:17.965 --> 00:13:20.501
並保存到磁盤上
作爲錯誤的一部分

00:13:21.602 --> 00:13:26.139
相對而言 故障代表的是
系統中更廣泛的問題

00:13:26.206 --> 00:13:27.975
是更大型的故障

00:13:28.876 --> 00:13:32.112
針對故障
我們查找存儲緩衝區

00:13:32.179 --> 00:13:35.182
收集相關進程的
所有日誌消息

00:13:35.249 --> 00:13:38.051
以及這個活動
涉及到的所有進程

00:13:39.353 --> 00:13:42.322
實際上我們還收集了
一些其他系統信息

00:13:42.389 --> 00:13:44.157
它們可能對我們有用

00:13:45.459 --> 00:13:49.396
故障與錯誤以及所有
作爲它們的部分而收集的日誌數據

00:13:49.463 --> 00:13:52.766
都實際上存到了
單獨的一套日誌文件中

00:13:53.967 --> 00:13:58.205
這樣做是爲了
不讓正常的日誌把他們擠掉

00:13:58.272 --> 00:14:02.476
因爲這會導致它們超出份額
佔用更多的空間

00:14:02.809 --> 00:14:05.679
也就是說
故障和錯誤的數據會一直存在

00:14:05.746 --> 00:14:08.248
甚至比正常的日誌數據還長

00:14:10.651 --> 00:14:15.155
好的 現在我來做
一個很直觀的介紹

00:14:15.222 --> 00:14:17.958
看看系統如何在
細節大量丟失的情況下工作

00:14:18.025 --> 00:14:21.995
這是個比較寬泛粗略的討論

00:14:22.629 --> 00:14:24.097
好了 每一個進程裏

00:14:24.164 --> 00:14:27.668
有一個小緩衝區的集合
我們會把日誌消息存在這裏

00:14:28.068 --> 00:14:31.672
這些緩衝區實際存在於
與日誌守候進程共享的內存裏

00:14:32.406 --> 00:14:35.742
緩衝區滿了的時候
日誌守候進程就會開啓

00:14:36.009 --> 00:14:39.980
把數據壓縮進
它的一個更大的緩衝區

00:14:40.814 --> 00:14:44.918
當這些大的緩衝區也滿了的時候
我們可以把它們存到磁盤上

00:14:44.985 --> 00:14:48.355
也可以再利用
將它們作爲內存緩衝器的一部分

00:14:48.422 --> 00:14:50.023
架構

00:14:50.090 --> 00:14:52.559
那麼最後會做的就是

00:14:52.626 --> 00:14:55.629
請求在線流式
日誌數據

00:14:55.696 --> 00:14:58.332
比如你在Console上
想看到的日誌

00:14:58.498 --> 00:15:00.000
是在一出現就實時記錄的

00:15:00.567 --> 00:15:01.802
我們執行的方法是

00:15:01.869 --> 00:15:06.440
立刻做一個IPC
連接到診斷守候進程

00:15:06.807 --> 00:15:09.943
它會分發日誌消息
給所有的客戶

00:15:10.644 --> 00:15:12.513
副作用是

00:15:12.579 --> 00:15:16.850
它會極大的影響
在線流式日誌數據的性能

00:15:17.317 --> 00:15:21.722
基本上我們做了很多努力
來節省力氣 提高日誌的速度

00:15:21.788 --> 00:15:25.392
這樣你的代碼
就不會有觀察者效應

00:15:25.459 --> 00:15:29.263
因爲我們給每個調令
都做了IPC

00:15:30.397 --> 00:15:34.902
另外要注意的是
每一類消息是如何

00:15:34.968 --> 00:15:39.106
不管從應用還是某個子系統
還是繞過這些路徑

00:15:39.173 --> 00:15:41.675
如果通過配置等等來改變

00:15:43.544 --> 00:15:48.182
我講的差不多了
請Matthieu Lucas上臺

00:15:48.248 --> 00:15:52.252
來爲大家實際演示一下
如何使用Console應用

00:15:59.092 --> 00:16:00.093
謝謝 Steven

00:16:00.727 --> 00:16:03.197
就像Steven
在一開始說的那樣

00:16:03.797 --> 00:16:06.366
今年我們引入了
全新的Console應用

00:16:06.767 --> 00:16:10.871
我們重新
用Swift編寫

00:16:11.205 --> 00:16:14.107
我們想創建
一個新的日誌系統

00:16:14.174 --> 00:16:17.911
讓你們的開發
能夠更簡單

00:16:18.679 --> 00:16:19.947
讓我們來看看這個應用

00:16:21.215 --> 00:16:22.182
這是新的界面

00:16:23.684 --> 00:16:26.486
你能看到
佈局其實沒怎麼變

00:16:26.553 --> 00:16:30.691
中間還是主要流式

00:16:30.757 --> 00:16:34.761
頂部是不同的操作
邊欄是不同的來源

00:16:35.229 --> 00:16:38.565
先來看看邊欄

00:16:38.899 --> 00:16:41.201
你還是能看到
不同的報告

00:16:42.102 --> 00:16:46.406
系統報告或者用戶報告
還有不同的遺留日誌

00:16:46.473 --> 00:16:48.408
它們可能都有
系統路徑

00:16:48.775 --> 00:16:50.944
但是這裏你看到
有一個新部分

00:16:51.011 --> 00:16:55.015
我們現在可以顯示
所有連接到你的機器的設備

00:16:55.082 --> 00:16:56.817
也會顯示當前的機器

00:17:01.622 --> 00:17:07.060
我們可以支持iOS
tvOS和watchOS設備

00:17:07.127 --> 00:17:10.430
所以你可以連接
所有你有的設備

00:17:10.830 --> 00:17:13.700
現在再來看看
主要流式

00:17:14.134 --> 00:17:16.136
現在 日誌流
由兩個視圖組成

00:17:16.637 --> 00:17:19.673
一個是消息視圖
一個是活動視圖

00:17:20.406 --> 00:17:22.309
就跟Steven
之前說的一樣

00:17:22.742 --> 00:17:27.114
在活動視圖裏
你可以看到活動的分層

00:17:27.181 --> 00:17:29.716
以及相關的消息
如果有的話

00:17:29.783 --> 00:17:33.053
細節會顯示在底部
這裏

00:17:34.888 --> 00:17:37.391
現在轉過來看看消息

00:17:38.425 --> 00:17:42.029
這裏你看到
有一大堆消息

00:17:42.196 --> 00:17:46.767
那麼爲了能包含
Debug和Info消息

00:17:46.834 --> 00:17:49.703
你需要在Action菜單裏
手動操作

00:17:49.770 --> 00:17:52.206
這樣他們就能
和默認的流一起顯示

00:17:53.307 --> 00:17:55.943
現在我們來多看一些...

00:17:56.343 --> 00:18:00.214
我開幾個應用來創建一些日誌

00:18:00.781 --> 00:18:04.418
這裏現在能看到
出現了更多的信息

00:18:04.685 --> 00:18:07.721
能看到
不同的消息類型

00:18:08.222 --> 00:18:12.192
通過這些彩色的點
在類型這一欄

00:18:12.259 --> 00:18:16.630
灰色的是Info消息

00:18:17.231 --> 00:18:21.001
黃色的是錯誤
紅色的是故障

00:18:21.101 --> 00:18:26.340
深灰色的是Debug

00:18:26.440 --> 00:18:29.776
如果沒有點
就是默認類型

00:18:31.311 --> 00:18:37.150
你也可以展開
或者摺疊你的消息

00:18:37.217 --> 00:18:41.154
直接在行內
使用左右箭頭

00:18:41.221 --> 00:18:45.459
或者使用這裏的
視圖菜單選項

00:18:45.526 --> 00:18:47.127
展開或摺疊

00:18:48.195 --> 00:18:51.398
只要你點一個消息

00:18:51.465 --> 00:18:55.602
你就能看到
有關這個消息的所有細節

00:18:55.669 --> 00:18:58.505
就在下面這個
細節視圖裏

00:18:59.273 --> 00:19:01.875
所以說
我們可以展示給你所有信息

00:19:01.942 --> 00:19:07.414
只要是有關這個日誌的
這就是新的日誌系統的一部分

00:19:07.581 --> 00:19:11.919
那麼現在我們來展示一下進程
還有它來自哪個庫

00:19:12.186 --> 00:19:13.954
你們看到這一個

00:19:14.021 --> 00:19:18.258
它就accountsd下的
Accounts.framework

00:19:20.961 --> 00:19:26.700
你還能看到更多的信息
在我們收集所有新日誌的時候

00:19:26.900 --> 00:19:30.537
你現在看到
我們有子系統 分類

00:19:31.205 --> 00:19:34.041
活動ID
線程ID或PID

00:19:35.742 --> 00:19:39.213
現在再看看這個iPad

00:19:39.479 --> 00:19:45.986
我連接的iPad只有一個最基本應用
上面有些數字

00:19:46.320 --> 00:19:52.526
我們要找到它們
通過瀏覽不同的功能

00:19:53.660 --> 00:19:57.698
首先我們最小化
欄的佈局

00:19:57.764 --> 00:20:01.201
我可以右擊上方
這裏

00:20:01.268 --> 00:20:05.873
然後添加一些新的欄

00:20:05.939 --> 00:20:09.877
我就添加子系統
和分類

00:20:11.411 --> 00:20:13.714
然後把它挪到這裏

00:20:13.780 --> 00:20:19.086
現在這個佈局是永久的
你不用再設第二遍

00:20:19.820 --> 00:20:24.525
現在我們可以看到
這個設備上有很多信息

00:20:24.591 --> 00:20:27.661
爲了精確你的搜索

00:20:27.728 --> 00:20:31.965
我們有兩個方法

00:20:32.032 --> 00:20:35.202
你可以首先
右擊一個消息

00:20:35.769 --> 00:20:38.505
然後你能選擇
不要子系統

00:20:38.572 --> 00:20:42.576
不要進程
或者只顯示一個特定的進程

00:20:42.643 --> 00:20:48.115
這樣我們開始就可以
減掉特定的分類

00:20:48.182 --> 00:20:49.983
假設我們要widgets不出聲

00:20:51.351 --> 00:20:57.291
第二個方法就是

00:20:57.357 --> 00:20:58.859
在這裏直接打字輸入

00:20:58.926 --> 00:21:03.063
所以你看到 我們只添加了一個
自定義的token給widget

00:21:03.864 --> 00:21:07.601
假設我只想看Bookmarks應用

00:21:07.668 --> 00:21:09.770
就是這個應用
在我的設備上出錯了

00:21:10.938 --> 00:21:15.509
這樣一來 這裏就只有
來自Bookmarks的消息了

00:21:15.776 --> 00:21:17.611
而沒有分類widget

00:21:18.045 --> 00:21:23.350
那麼再來添加一個token
只顯示錯誤類型

00:21:24.685 --> 00:21:27.554
現在看到的消息
就只來自於Bookmarks

00:21:27.621 --> 00:21:31.859
沒有分類widget
並帶有一個錯誤類型

00:21:32.159 --> 00:21:38.532
我們可以看到網頁視圖的
不同的錯誤

00:21:39.933 --> 00:21:45.672
這就是我們如何
直接關聯到要查找的內容

00:21:46.173 --> 00:21:50.043
爲了之後能修正錯誤
你只要保存它

00:21:50.110 --> 00:21:53.847
通過點擊右上方的
保存鍵

00:21:54.948 --> 00:21:58.018
名字就叫Bookmark Errors

00:21:58.952 --> 00:22:04.124
你可以看到所有你保存的搜索
都會顯示在這個部分裏

00:22:04.992 --> 00:22:09.596
你可以重新排列它們
願意的話也可以刪除

00:22:09.663 --> 00:22:12.466
你會有兩個
默認保存的搜索

00:22:12.533 --> 00:22:14.768
就是全部信息
和故障及錯誤

00:22:15.002 --> 00:22:18.539
現在來轉到
活動視圖

00:22:18.605 --> 00:22:21.575
看看能否找到
更多有關這些日誌的情況

00:22:21.642 --> 00:22:24.545
能否簡單的
重製這些錯誤

00:22:25.679 --> 00:22:29.583
這裏我們看到
不同的活動

00:22:29.917 --> 00:22:33.987
這些活動的視圖
基於同樣的搜索機制

00:22:34.621 --> 00:22:39.193
所以我們可以使用同樣的功能
並且保存

00:22:39.927 --> 00:22:41.328
這裏我們看到

00:22:41.395 --> 00:22:47.401
不同孩子的
Bookmarks活動

00:22:47.768 --> 00:22:49.837
我們可以看到
當時是在準備轉換

00:22:49.903 --> 00:22:55.609
然後我們檢索一個對象
打開細節視圖

00:22:55.676 --> 00:22:58.879
然後設定細節視圖
下載網頁視圖

00:22:59.279 --> 00:23:04.518
現在你就可以看到
信息直接顯示在底部的視圖

00:23:04.985 --> 00:23:06.820
這些都是
有關這個活動的信息

00:23:06.887 --> 00:23:12.960
這個消息是記錄在這個活動裏的
所以纔會顯示在這裏

00:23:13.327 --> 00:23:16.263
我們現在看到
這些消息

00:23:16.330 --> 00:23:20.901
這兩個錯誤
是加載網頁視圖活動的一部分

00:23:22.135 --> 00:23:26.206
那麼我們就知道了
是什麼情況

00:23:26.273 --> 00:23:29.409
導致了這個錯誤

00:23:29.743 --> 00:23:34.448
那麼現在我們添加
一個分享選項給Console

00:23:34.515 --> 00:23:37.985
你只要選擇
一些活動或消息

00:23:38.318 --> 00:23:41.622
直接分享給某個人
或者給備註

00:23:41.688 --> 00:23:45.325
我這裏就只添加爲備註
以便以後的調試

00:23:46.527 --> 00:23:47.861
下一個問題

00:23:53.500 --> 00:23:58.739
另外一個可用的輸入
是日誌檔案

00:23:58.805 --> 00:24:00.941
在桌面上有一個日誌檔案

00:24:01.008 --> 00:24:03.810
是另外一個設備
之前生成的

00:24:04.178 --> 00:24:07.714
如果你也有一個
雙擊它

00:24:07.781 --> 00:24:09.049
Console會打開它

00:24:09.616 --> 00:24:13.787
你可以看到
無論何時你點開它

00:24:14.087 --> 00:24:15.489
它就會下載所有的東西

00:24:15.923 --> 00:24:17.558
你還可以看到

00:24:17.624 --> 00:24:22.095
這裏保存的篩選
跟我們之前說的一樣

00:24:22.162 --> 00:24:28.135
那麼爲了能看到
這個特定的日誌文檔

00:24:28.202 --> 00:24:33.140
是否包含了同樣的錯誤消息
作爲流的當前設備

00:24:33.207 --> 00:24:38.712
我們只要點擊它
它就會自動重新應用同樣的篩選

00:24:39.513 --> 00:24:42.449
這裏就看到
錯誤是一樣的

00:24:42.516 --> 00:24:48.689
同樣我們也可以在活動視圖
查看同樣的活動

00:24:49.323 --> 00:24:54.561
這就是Console的全部內容
我要請Steven回到舞臺

00:24:54.928 --> 00:24:55.863
謝謝

00:25:05.539 --> 00:25:07.241
十分感謝 Matthieu

00:25:08.275 --> 00:25:12.379
我十分喜歡新的Console
很好用

00:25:13.113 --> 00:25:17.184
那麼我們來講講
新的統一日誌系統

00:25:17.251 --> 00:25:18.552
以及如何實際使用

00:25:20.320 --> 00:25:23.690
首先我們來總結一下
所有新的API

00:25:24.291 --> 00:25:29.796
Os_log是基本的日誌API
用默認模式記錄

00:25:30.097 --> 00:25:36.003
Os_log_info是一個調令
默認發送日誌消息給內存

00:25:36.069 --> 00:25:40.874
也用於你想收集的額外即時信息

00:25:41.441 --> 00:25:44.178
Os_log_debug用於
十分頻繁的調試

00:25:45.012 --> 00:25:47.548
另外還有os_log_error
和os_log_fault

00:25:47.614 --> 00:25:49.483
用來生成故障和錯誤信息

00:25:49.816 --> 00:25:52.219
最後一個調令
是os_log_create

00:25:52.286 --> 00:25:55.856
它能創建一個日誌對象
讓你自定義你的行爲

00:25:56.156 --> 00:25:58.158
就這一點
我們再深入講一下

00:25:58.225 --> 00:26:00.427
因爲它對你們來說
應該是最不熟悉的

00:26:00.494 --> 00:26:02.729
相較於其他內容而言

00:26:03.263 --> 00:26:06.533
調出os_log_create
由兩個參數組成

00:26:06.600 --> 00:26:09.203
子系統的名字
和分類的名字

00:26:09.670 --> 00:26:12.873
它要做的是創建
一個線程安全的單例對象

00:26:13.106 --> 00:26:16.510
來控制
你傳遞的日誌調令行爲

00:26:17.611 --> 00:26:21.014
在默認情況下
這是個系統範圍內的行爲

00:26:21.315 --> 00:26:24.084
但是你可以自定義爲
某種特定的行爲

00:26:24.151 --> 00:26:26.653
通過使用配置
或者日誌命令行工具

00:26:27.454 --> 00:26:30.524
使用方法就是
簡單地將它作爲第一個參數傳遞

00:26:30.591 --> 00:26:31.625
給所有其他調令

00:26:31.692 --> 00:26:35.729
這裏我調出os_log
第一個參數爲log

00:26:35.796 --> 00:26:39.132
它是從os_log_create
返回的值

00:26:41.034 --> 00:26:44.104
它所做的就是
製造一個引用給分類

00:26:44.171 --> 00:26:47.574
和用這個日誌對象
定義的子系統

00:26:47.641 --> 00:26:50.711
跟每個用到的日誌消息
存在一起

00:26:51.211 --> 00:26:55.916
以便以後可用在後端上
篩選和顯示消息

00:26:57.050 --> 00:27:01.755
如果你無所謂有沒有
自己的子系統和分類

00:27:01.822 --> 00:27:04.958
那麼另一個辦法就是傳遞一個
os_log_default

00:27:05.025 --> 00:27:07.728
只是我們一直提供的
默認日誌對象

00:27:07.995 --> 00:27:09.963
它沒有子系統或分類

00:27:10.197 --> 00:27:13.834
但是它很有用
如果你不需要那種控制的話

00:27:16.203 --> 00:27:17.538
內置類別格式化

00:27:18.205 --> 00:27:24.044
我們都花費了大量的代碼
去把二進制信息轉換成字符串

00:27:24.111 --> 00:27:25.345
以便我們記錄

00:27:25.612 --> 00:27:28.715
統一日誌系統
可以幫你完成大部分這樣的工作

00:27:28.782 --> 00:27:31.885
通過爲常見的類別
提供內置格式化

00:27:32.319 --> 00:27:34.021
更重要的是

00:27:34.087 --> 00:27:39.126
我們省去了轉換工作
直到我們要顯示日誌消息的時候

00:27:39.193 --> 00:27:41.461
所以你不需要
爲轉換而苦惱

00:27:41.528 --> 00:27:43.564
在生成日誌消息的時候

00:27:44.031 --> 00:27:49.069
避免所有不同類型的
觀察者效應

00:27:50.070 --> 00:27:52.506
這點我們多講一些

00:27:52.606 --> 00:27:55.209
對於一些常用的值
這裏有內置的解碼

00:27:55.542 --> 00:27:58.645
語法不是％d

00:27:58.712 --> 00:28:04.117
而是％（time t ）d

00:28:04.184 --> 00:28:06.720
這就是說
這個十進制的值

00:28:06.787 --> 00:28:10.023
你傳遞的實際上
是一個time_t

00:28:10.090 --> 00:28:13.694
那麼在打印的時候
印出的就是一個time字符串

00:28:14.695 --> 00:28:17.865
同樣的
對於錯誤你要寫 ％（errno ）d

00:28:17.931 --> 00:28:21.301
這樣這個錯誤就會被轉換成
肉眼可以辨識的格式

00:28:23.537 --> 00:28:29.443
我們還有一個新的基本時間格式
％P 不是小寫p

00:28:29.510 --> 00:28:31.044
這已經不是新聞了

00:28:31.111 --> 00:28:34.114
你可以用它來顯示
任意二進制數據

00:28:35.015 --> 00:28:39.920
所有常用類型都有解碼器
比如％（uuid t ）

00:28:40.721 --> 00:28:46.260
這裏列出了
我們現在使用的所有代碼

00:28:46.326 --> 00:28:48.529
包括所有不同類型的時間值

00:28:48.595 --> 00:28:53.934
errno和uuids
還有所有不同類型的網絡ID

00:28:54.501 --> 00:28:58.405
而且我們很期待
未來還有更多的代碼出現

00:29:00.607 --> 00:29:02.809
那現在講講
以參數爲單位的隱私

00:29:04.111 --> 00:29:07.648
隱私現在基於參數處理
並以一個參數爲單位

00:29:08.115 --> 00:29:11.051
標量和靜態字符串
被認爲是公開的

00:29:11.718 --> 00:29:16.356
另一方面
動態字符串 集合和對象被認爲

00:29:16.423 --> 00:29:20.194
含有隱私信息
除非你特別說明

00:29:21.161 --> 00:29:25.365
那麼這個行爲就可以重寫
以一個參數爲基準

00:29:25.666 --> 00:29:28.335
以前會寫％@
來表示

00:29:28.402 --> 00:29:33.073
“我想把這個對象
包含進我的日誌”

00:29:33.140 --> 00:29:36.643
而現在你要寫％（public ）@
來告訴我們這個對象

00:29:36.710 --> 00:29:40.547
以及這個對象裏的所有內容都是公開的
不用擔心

00:29:41.215 --> 00:29:45.786
另外如果你有一個事件
裏面的一些數值

00:29:45.853 --> 00:29:50.357
出於某些原因是隱私的
你就可以寫％（private ）d

00:29:50.591 --> 00:29:54.127
讓這個數據記錄爲
隱私信息

00:29:56.897 --> 00:29:59.700
這樣你就可以把
隱私和格式結合起來

00:29:59.766 --> 00:30:04.771
那麼我可以寫
％（public, uuid t ）.16P

00:30:04.838 --> 00:30:06.940
來表示這裏有一個uuid

00:30:07.007 --> 00:30:10.344
它是公開信息
並且已格式化

00:30:12.112 --> 00:30:14.047
那麼我們再講講實例

00:30:14.114 --> 00:30:18.051
看看寫代碼的時候
會產生什麼不同

00:30:18.719 --> 00:30:21.355
日誌消息簡化

00:30:21.522 --> 00:30:23.524
這是我們以前用的方法

00:30:23.991 --> 00:30:26.126
好的
首先你要檢查並聲明

00:30:26.193 --> 00:30:29.463
當前的日誌層級
是否在發出任何調令前可用

00:30:29.530 --> 00:30:34.101
然後你要聲明
你要顯示一個uuid

00:30:34.168 --> 00:30:38.071
你要做的第一件事就是
調出unparse 轉換成字符串

00:30:38.705 --> 00:30:41.074
碰巧你還有
一個套接字地址

00:30:41.141 --> 00:30:43.377
這個之後
也要轉換成字符串

00:30:44.378 --> 00:30:48.682
然後調出NSLog
包括所有已經轉換的元素

00:30:48.749 --> 00:30:51.185
當然你還要
傳遞這個函數的名字

00:30:51.251 --> 00:30:53.153
以及file和line的數字

00:30:53.787 --> 00:30:55.923
完成後
不要忘了

00:30:55.989 --> 00:30:58.992
釋放爲套接字地址
所創建的字符串

00:30:59.526 --> 00:31:00.494
這就好了

00:31:01.195 --> 00:31:02.329
下面來看看新方法

00:31:03.263 --> 00:31:07.601
簡單地調出os_log_info
它可以幫你檢查日誌級別

00:31:07.935 --> 00:31:10.270
這種情況下
我傳遞默認的日誌對象

00:31:11.305 --> 00:31:17.211
我在格式字符串裏定義所給的參數
是一個uuid和一個套接字地址

00:31:17.277 --> 00:31:19.146
就不用再做轉換

00:31:19.213 --> 00:31:22.816
現在我什麼也不做
直到我們要顯示它的時候

00:31:23.417 --> 00:31:26.086
然後我只要傳遞參數
就這麼簡單

00:31:35.896 --> 00:31:38.065
在我做示例的時候
讓我多說一下

00:31:38.131 --> 00:31:40.200
使用其他API的例子

00:31:41.435 --> 00:31:46.874
這裏我做了一個log_create
定義了一個子系統和分類

00:31:46.940 --> 00:31:49.209
子系統是
com.apple.logging.example

00:31:49.543 --> 00:31:53.313
分類就是普通分類
那麼這就是我一般的日誌對象

00:31:53.680 --> 00:31:57.484
我要做一樣的事情 但這次
我創建了一個分類timestamp

00:31:59.553 --> 00:32:01.154
然後寫個簡單的調令

00:32:01.221 --> 00:32:05.893
調出os _log 使用general_log對象
傳遞字符串 日誌完成

00:32:07.160 --> 00:32:09.196
這裏有個更有趣的案例

00:32:09.263 --> 00:32:10.464
我調出os_log_info

00:32:10.531 --> 00:32:12.866
這之後會進入
內存緩衝區

00:32:12.933 --> 00:32:15.435
並只保存在
有故障和錯誤的時候

00:32:16.136 --> 00:32:21.074
在我的格式行裏
我定義％（public ）s給filename

00:32:21.141 --> 00:32:23.343
因爲filename
是個動態字符串

00:32:23.410 --> 00:32:25.979
所以我們假設
它是隱私信息

00:32:26.046 --> 00:32:27.781
除非你特別聲明
它是公開的

00:32:28.649 --> 00:32:30.317
下面這是個
比較複雜的例子

00:32:30.384 --> 00:32:32.753
我打開一個文件
檢查到一個錯誤

00:32:32.819 --> 00:32:36.256
如果它返回一個錯誤
我就調出os_log_error

00:32:36.890 --> 00:32:41.428
在我的格式行裏就會聲明
這個filename是公開信息

00:32:41.495 --> 00:32:44.898
我聲明給格式
定義errno爲errno

00:32:45.799 --> 00:32:49.736
這是另一個相似的例子
這一次我調出fstat

00:32:49.803 --> 00:32:52.906
但糟糕的是我調出的fstat
是在打開文件之後

00:32:52.973 --> 00:32:56.910
所以如果我收到報錯
就可能有奇怪的問題出現

00:32:57.177 --> 00:33:00.013
因此我調出os_log_fault
同樣類型的參數

00:33:01.582 --> 00:33:04.651
最後一步
就是調出os_log_info

00:33:04.818 --> 00:33:07.888
但是這一次
我傳遞timestamp日誌對象

00:33:08.388 --> 00:33:11.692
然後基本上我會丟掉
這個文件的所有timestamp

00:33:11.758 --> 00:33:15.062
這就意味着
當我打開瀏覽Console的時候

00:33:16.096 --> 00:33:18.365
我可以簡單地篩選
並說

00:33:18.432 --> 00:33:22.769
我只要看timestamp數據
或者我不想看timestamp數據

00:33:22.836 --> 00:33:24.404
因爲我要看其他數據

00:33:26.106 --> 00:33:30.410
新的統一日誌系統
不是此次發佈的唯一改變

00:33:30.544 --> 00:33:33.514
我們還改進了
活動跟蹤系統

00:33:34.314 --> 00:33:38.652
活動 是最優先
被保存和再利用的對象

00:33:39.853 --> 00:33:43.724
創建操作
讓你能控制

00:33:43.790 --> 00:33:48.462
不同活動對象之間的關係
就在你創建它們的時候

00:33:49.630 --> 00:33:53.967
還有一些新的API
是觀察你的代碼活動

00:33:55.702 --> 00:33:56.837
改進的活動API

00:33:56.904 --> 00:33:59.373
這裏就是
所有的新API

00:33:59.640 --> 00:34:04.878
這個新的os_activity_create
跟os_log_create一樣

00:34:04.945 --> 00:34:08.581
都是創建一個日誌對象
只是在識別一個活動的時候

00:34:10.184 --> 00:34:13.554
你可以使用兩個調令
在你的代碼上

00:34:13.620 --> 00:34:17.123
os_activity_scope
和os_activity_apply

00:34:17.190 --> 00:34:20.860
我一會兒讓你們看幾個例子
看看他們的運行有何不同

00:34:21.495 --> 00:34:26.600
最後就是os_activity_label_useraction
它將活動標記爲

00:34:26.667 --> 00:34:29.770
基於UI的用戶活動

00:34:31.103 --> 00:34:32.940
那我們用個例子
來說明

00:34:33.639 --> 00:34:37.878
首先調出os_activity_create
創建init活動

00:34:39.079 --> 00:34:41.281
注意這個函數的
第二個參數

00:34:41.348 --> 00:34:43.550
是常量
os_activity_current

00:34:43.617 --> 00:34:46.719
這就是說這個init活動是
附屬於

00:34:46.786 --> 00:34:49.255
當前活動的
不論這個活動是什麼

00:34:50.357 --> 00:34:54.228
現在我開始做os_activity_create
爲驗證活動

00:34:54.594 --> 00:34:57.898
但是第二個參數
是我剛建的init活動

00:34:57.965 --> 00:35:02.369
這樣我就給這些活動
手動創建了一個層級結構

00:35:03.971 --> 00:35:05.772
現在我有了一個代碼塊

00:35:05.839 --> 00:35:09.176
準備好了
我大括號裏還有一些代碼

00:35:09.543 --> 00:35:12.713
第一件事就是調出
os_activity_scope

00:35:13.013 --> 00:35:15.482
然後傳遞
這個驗證活動

00:35:15.949 --> 00:35:19.219
意思就是
這個代碼塊裏的其他代碼

00:35:19.286 --> 00:35:23.357
被認爲是這個活動範圍之內的
直到我點擊結束括號

00:35:23.991 --> 00:35:28.428
不用再記得要在結束時
調出os_activity_end

00:35:28.495 --> 00:35:30.264
它會自動完成

00:35:30.898 --> 00:35:35.369
當你離開這個scope的時候
你就不再是這個活動的一部分了

00:35:36.737 --> 00:35:39.840
我們提供的另一調令是
os_activity_apply

00:35:40.507 --> 00:35:45.279
先傳遞活動對象
再傳遞這個代碼塊

00:35:45.345 --> 00:35:49.449
然後它就會運行這個代碼塊
並以這個活動爲執行範圍

00:35:51.018 --> 00:35:52.052
工具

00:35:52.786 --> 00:35:56.123
Matthieu已經爲你們
展示了新的Console

00:35:56.190 --> 00:35:59.193
那麼我就快速
過一下它的功能

00:36:00.127 --> 00:36:02.629
你可以瀏覽系統中
的活動內容

00:36:03.030 --> 00:36:04.831
可以打開日誌檔案

00:36:05.132 --> 00:36:08.802
可以使用新的日誌檢測
的活動中心視圖

00:36:09.503 --> 00:36:11.872
你可以使用
高級的篩選和搜索

00:36:12.306 --> 00:36:14.775
還可以看到設備的日誌

00:36:16.777 --> 00:36:20.314
現在我仔細講講
新的命令行工具

00:36:22.783 --> 00:36:25.819
它提供了跟Console
完全一樣的功能

00:36:25.886 --> 00:36:27.120
但是是用命令行

00:36:27.588 --> 00:36:33.360
要想獲取在線流式日誌消息
只要寫log stream

00:36:33.994 --> 00:36:35.229
如果要漂亮一點

00:36:35.295 --> 00:36:40.334
你可以寫log stream
--predicate eventMessage contains my message

00:36:40.400 --> 00:36:43.437
它能做的就是
獲取所有流式日誌消息

00:36:43.504 --> 00:36:45.506
包括了my message字符串

00:36:47.040 --> 00:36:51.278
就跟Console一樣
讓你打開日誌檔案

00:36:51.512 --> 00:36:56.016
一個日誌檔案可以
通過日誌命令顯示

00:36:56.450 --> 00:36:59.152
你可以寫log_show
然後給它文件名

00:36:59.486 --> 00:37:01.588
然後它就可以顯示
這個日誌文件的內容

00:37:03.524 --> 00:37:08.896
你可以在macOS做的另一件事
使用日誌命令去更改

00:37:08.962 --> 00:37:11.798
你的子系統和分類的配置

00:37:12.065 --> 00:37:13.367
這裏是個案例

00:37:13.433 --> 00:37:18.672
我寫了
log_config --mode level:debug

00:37:18.739 --> 00:37:22.242
然後寫-system com.mycorp.myapp

00:37:22.309 --> 00:37:24.845
這麼做是爲了能夠記錄

00:37:24.912 --> 00:37:28.348
這個子系統的日誌
在你的macOS上

00:37:30.918 --> 00:37:32.219
即將推出

00:37:33.020 --> 00:37:39.626
我們很感謝你們
將使用iOS 10來開發你的應用

00:37:39.693 --> 00:37:45.399
但是請繼續使用Mac上的macOS 10.11
即El Capitan

00:37:46.466 --> 00:37:52.339
讓你能夠通過El Capitan
訪問新日誌的工具馬上就會推出

00:37:52.406 --> 00:37:55.042
但與此同時

00:37:57.878 --> 00:38:00.113
我們煞費苦心的
提供了一個變通方案

00:38:00.180 --> 00:38:04.017
能讓你的新工具
在模擬器內部運行

00:38:04.384 --> 00:38:07.020
xcrun simctl spawn booted

00:38:07.087 --> 00:38:09.890
然後寫
log show system logs.logarchive

00:38:09.957 --> 00:38:13.861
然後你就可以執行所有命令
跟往常一樣

00:38:14.261 --> 00:38:16.196
另一種方法也再研究中

00:38:21.435 --> 00:38:25.239
那麼我現在開始講最佳操作
記錄規則

00:38:27.140 --> 00:38:30.944
一定要保證你的消息裏
只包含真正有用的信息

00:38:31.011 --> 00:38:35.215
不要有額外的空白字
或者填充數據

00:38:35.415 --> 00:38:36.550
要保持緊湊

00:38:38.752 --> 00:38:43.891
讓我們利用內置格式化組件
去做格式轉換

00:38:43.957 --> 00:38:47.828
你提前做的
字符串轉換越多

00:38:47.895 --> 00:38:49.630
你的應用就顯示得越慢

00:38:49.696 --> 00:38:53.967
相比之下
輸出的時候再轉換就好很多

00:38:55.402 --> 00:38:58.772
避免將日誌API
包含於其他函數

00:38:59.039 --> 00:39:01.375
如果你把它
包在其他函數裏

00:39:01.441 --> 00:39:06.046
你就無法
收集文件和行數

00:39:07.114 --> 00:39:10.450
如果你必須要
包裝我們的API

00:39:10.517 --> 00:39:13.086
那麼把它們包在宏命令裏
不要包在函數裏

00:39:14.254 --> 00:39:17.791
只從字典和檔案裏
記錄所需要的內容

00:39:17.858 --> 00:39:20.260
這裏說的字典是指
字典和數組

00:39:21.261 --> 00:39:22.796
它們佔用了
磁盤上很多的空間

00:39:22.863 --> 00:39:26.633
也就是說他們會擠掉
其他人們需要的日誌消息

00:39:26.934 --> 00:39:31.438
儘可能的只記錄
你日誌所真正需要的部分

00:39:32.973 --> 00:39:36.710
還要避免記錄到
緊湊代碼循環裏

00:39:38.579 --> 00:39:42.482
簡單說一下我們心目中
這些新API的最佳用途

00:39:43.050 --> 00:39:49.223
Os_log是記錄
日誌信息的基本細節

00:39:49.289 --> 00:39:51.458
這個信息類型
可能正是你需要的

00:39:51.525 --> 00:39:54.228
能在幾個小時前
幫你調試問題

00:39:55.362 --> 00:39:59.533
使用os_log_info
去獲取額外的即時信息

00:39:59.900 --> 00:40:02.970
這個首先要用於
很快就會過期的信息

00:40:03.770 --> 00:40:07.674
使用os_log_debug
來處理開發過程中大量的調試工作

00:40:08.575 --> 00:40:12.446
錯誤出現在
你需要收集額外信息

00:40:12.513 --> 00:40:13.914
併爲你的應用保留的情況下

00:40:14.648 --> 00:40:16.783
故障是指你想要收集額外的

00:40:16.850 --> 00:40:19.052
有關係統的信息

00:40:20.921 --> 00:40:23.724
簡單來講講
日誌收集

00:40:24.925 --> 00:40:29.062
我們推薦Sysdiagnose
來捕捉有關故障報告的數據

00:40:29.129 --> 00:40:30.264
使用sysdiagnose

00:40:30.330 --> 00:40:35.302
如果你使用sysdiagnose
我剛剛描述的系統裏的日誌數據

00:40:35.369 --> 00:40:39.640
就會出現在檔案裏
文件名是system logs.archive

00:40:41.642 --> 00:40:44.745
可使用key-chords
來激活sysdiagnose

00:40:45.112 --> 00:40:47.214
如果在Apple watch上

00:40:47.281 --> 00:40:49.883
它不僅會在手錶上激活
也會在與之匹配的手機上激活

00:40:50.951 --> 00:40:54.154
然後你可以用iTunes
轉移這個檔案

00:40:54.221 --> 00:40:57.424
給你的Mac
來進行操作

00:40:58.325 --> 00:41:02.462
這個文件就是
Apple想要爲你提供的

00:41:02.529 --> 00:41:04.498
解決你給我們提出的問題

00:41:04.565 --> 00:41:06.333
所以你可以把它附在雷達上

00:41:06.400 --> 00:41:08.669
也可以發送給
開發者技術支持

00:41:11.271 --> 00:41:13.273
這就是各種key-chords

00:41:13.574 --> 00:41:16.410
Shift + Control + Option
+ Command + Period （. ） 對Mac OS

00:41:16.710 --> 00:41:19.880
Volume up + Volume Down
+ Power 對iOS

00:41:20.547 --> 00:41:23.784
手機上會產生輕微震動
iPad不會

00:41:24.184 --> 00:41:28.889
在watchOS上
長按電子錶冠和邊鍵一整秒

00:41:29.223 --> 00:41:32.125
如果按的時間不夠長
你就只獲得一個截屏

00:41:32.593 --> 00:41:39.132
啓動的時候
會有輕微的觸摸震動

00:41:40.667 --> 00:41:43.370
Play/Pause + Volume Down
在tvOS上

00:41:43.504 --> 00:41:46.573
注意以前的
Apple TV遙控器

00:41:46.773 --> 00:41:49.443
得按五秒鐘才能激活

00:41:50.544 --> 00:41:51.411
棄用

00:41:52.412 --> 00:41:56.950
這一部分
我們要對一些API說再見了

00:41:58.585 --> 00:42:03.056
首先就是所有的ASL日誌API
現在已經被這些新的API所替代了

00:42:03.123 --> 00:42:05.559
所以這些舊的API就被棄用了

00:42:06.226 --> 00:42:08.161
但這裏還有
一個有趣的極端情況

00:42:08.462 --> 00:42:13.433
搜索日誌數據的新API
在這一版本不會被公佈

00:42:13.500 --> 00:42:17.304
意思就是
現在沒有能替代asl搜索功能的工具

00:42:17.804 --> 00:42:21.441
如果你的系統
完全依賴asl搜索

00:42:21.775 --> 00:42:25.479
那就得等着使用
新的日誌系統了

00:42:29.149 --> 00:42:33.187
還有一些活動API
也會被棄用

00:42:33.720 --> 00:42:38.458
現在不用再寫os_activity_start
和os_activity_end

00:42:38.525 --> 00:42:42.162
而是像我展示的那樣
寫os_activity_create就可以

00:42:42.229 --> 00:42:45.832
然後調出scope或者apply
來應用到代碼塊

00:42:46.200 --> 00:42:50.704
Os_activity_breadcrumb已經被
os_activity_user_label代替

00:42:51.004 --> 00:42:55.542
Os_trace_with_payload也換成了
任意os_log調令

00:42:56.276 --> 00:42:59.313
注意這些函數
在這一版本里以沒有ops

00:42:59.379 --> 00:43:02.082
所以如果你繼續調用它們
它們也不會進行任何操作

00:43:03.317 --> 00:43:04.284
總的來說

00:43:05.085 --> 00:43:10.724
新的日誌系統更快也更簡單
也給你更多的控制力

00:43:10.791 --> 00:43:13.727
但它的確要使用
新的API和新工具

00:43:14.595 --> 00:43:16.129
相關演講

00:43:16.196 --> 00:43:20.234
我提到了幾次
在2014年發佈的“活動追蹤”

00:43:20.300 --> 00:43:22.603
這個演講
講的就是這個內容

00:43:22.669 --> 00:43:24.371
所以如果你想回顧一下

00:43:24.872 --> 00:43:29.009
或者想了解更多有關這個演講的信息
請登陸這個URL

00:43:29.343 --> 00:43:30.410
謝謝大家