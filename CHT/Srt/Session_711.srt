00:00:19.486 --> 00:00:22.389 
NSURLSession：新特性和典範

00:00:29.796 --> 00:00:31.798 
謝謝大家 早上好

00:00:34.034 --> 00:00:35.969 
感謝大家今天的到來

00:00:36.537 --> 00:00:41.308 
這裏是NSURLSession:
新特性和典範講座

00:00:41.408 --> 00:00:42.809 
我是Jeff Jenkins

00:00:42.876 --> 00:00:46.213 
我是一個軟件工程師
來自網絡技術部

00:00:46.747 --> 00:00:50.284 
我今天有一些非常有用的信息
想和大家分享

00:00:50.350 --> 00:00:51.752 
關於NSURLSession

00:00:51.818 --> 00:00:54.688 
那我們還等什麼
現在就按日程開始

00:00:54.755 --> 00:00:57.224 
看看今天我們會講些什麼

00:00:58.525 --> 00:01:02.863 
NSURLSession API
給我們提供了非常豐富的類

00:01:02.963 --> 00:01:07.067 
和方法可以簡化
現代日常網絡工作的複雜性

00:01:08.368 --> 00:01:13.073 
今天我們就來討論下
NSURLSession API已取得的發展

00:01:13.140 --> 00:01:15.309 
我還要和你分享一些它的新特性

00:01:15.442 --> 00:01:18.478 
和我們對這個API所做的強化

00:01:18.679 --> 00:01:20.547 
我們將會用一個實例應用向你展示

00:01:20.614 --> 00:01:24.051 
一些新特性和運行狀況

00:01:26.420 --> 00:01:28.989 
我來花些時間談談安全性

00:01:29.356 --> 00:01:34.361 
對於你們用戶來說
保護你們的數據和隱私很重要

00:01:34.528 --> 00:01:35.829 
如果這個對你們很重要

00:01:35.896 --> 00:01:38.832 
我們就知道這個對你和
你的應用程序很重要

00:01:39.199 --> 00:01:41.635 
我會和你們分享下
我們做得一些技術強化

00:01:41.702 --> 00:01:44.938 
對於NSURLSession安全性

00:01:46.573 --> 00:01:49.810 
在講座的整個階段

00:01:49.877 --> 00:01:53.313 
我會不時的和大家分享
一些最佳實踐和技巧

00:01:53.380 --> 00:01:55.916 
這樣你就能讓你的應用變得更了不起

00:01:58.819 --> 00:02:02.356 
好了 我們先從頂層API開始看起

00:02:02.422 --> 00:02:05.826 
它對Apple所有平臺的
應用程序都是可用的

00:02:06.894 --> 00:02:11.164 
這麼多年來Foundation框架
一直支撐着NSURLConnection API

00:02:11.598 --> 00:02:15.435 
NSURLConnection
現如今成爲了一個強大的網絡抽象

00:02:15.502 --> 00:02:18.772 
它提供了很多非常好的基礎網絡功能

00:02:18.839 --> 00:02:20.607 
可以被開發者在應用中使用

00:02:21.041 --> 00:02:24.244 
但是 我們常問自己
怎麼才能做的更好

00:02:24.745 --> 00:02:27.681 
還有開發者會想要我們做什麼

00:02:27.748 --> 00:02:30.284 
於是我們就坐下來討論這個話題

00:02:30.350 --> 00:02:33.253 
然後我們發現很多問題的答案都和

00:02:33.320 --> 00:02:34.821 
配置網絡有關

00:02:34.888 --> 00:02:37.457 
但是在應用中配置網絡可能會非常困難

00:02:37.524 --> 00:02:38.525 
特別是你需要

00:02:38.592 --> 00:02:41.895 
在同一個應用程序中
配置不同類型的網絡

00:02:43.397 --> 00:02:44.631 
因此 我們就採取了行動

00:02:45.132 --> 00:02:50.470 
在2015年我們正式的棄用了
NSURLConnection API

00:02:50.537 --> 00:02:53.941 
意思是我們不會對那API增加新功能

00:02:54.007 --> 00:02:56.176 
它只能得到很少的維護

00:02:57.477 --> 00:03:02.416 
但是我們在2013年的
WWDC 上正式棄用之前

00:03:02.749 --> 00:03:04.785 
我們引入了NSURLSession

00:03:04.852 --> 00:03:08.388 
來替換Foundation層
網絡的API

00:03:09.056 --> 00:03:12.226 
我們當時提倡過你們
我們現在繼續提倡你們

00:03:12.492 --> 00:03:14.962 
在網絡代碼中開始使用
NSURLSession API

00:03:15.028 --> 00:03:16.630 
現在正在使用的應用

00:03:16.697 --> 00:03:19.533 
和你未來即將開發的應用程序

00:03:21.535 --> 00:03:25.506 
既然NSURLSession
是最好的頂層API

00:03:25.973 --> 00:03:29.042 
對於Apple平臺的網絡編程來說

00:03:29.343 --> 00:03:32.679 
先來看一些NSURLSession
的基礎知識

00:03:33.013 --> 00:03:39.186 
如果你想要一個詳細深入的
NSURLSession介紹

00:03:39.253 --> 00:03:44.224 
我推薦你去2015年 WWDC

00:03:44.291 --> 00:03:46.593 
特別是2014年的

00:03:46.660 --> 00:03:49.029 
然後看看那些

00:03:50.697 --> 00:03:54.101 
和NSURLSession講座
配套的視頻和幻燈片

00:03:55.636 --> 00:03:57.671 
我一直吹捧
NSURLSession API

00:03:57.738 --> 00:04:01.275 
推薦在你的應用中使用這個API

00:04:01.675 --> 00:04:05.245 
那到底爲何NSURLSession
值得這樣的稱讚？

00:04:05.312 --> 00:04:09.583 
其中一部分好處是
我們會持續有力的支持

00:04:09.750 --> 00:04:12.519 
HTTP/1.1協議

00:04:13.887 --> 00:04:16.523 
我們也支持SPDY協議

00:04:16.690 --> 00:04:21.128 
但我們不贊成
新網頁服務的建立基於SPDY協議

00:04:21.195 --> 00:04:26.800 
你應該朝前看 使用HTTP/2協議

00:04:26.867 --> 00:04:31.405 
顯然我們的NSURLSession
支持HTTP/2

00:04:31.772 --> 00:04:35.142 
我們的支持是基於RFC7540的

00:04:35.375 --> 00:04:38.345 
而且我們會不停的給這個協議
增加新的功能

00:04:41.181 --> 00:04:43.917 
應用安全傳輸 或ATS

00:04:43.984 --> 00:04:46.887 
是NSURLSession
內置非常好的功能

00:04:47.120 --> 00:04:50.324 
它是一個安全性功能
可以提高隱私保護

00:04:50.624 --> 00:04:55.662 
和數據完整性
在應用和網頁連接過程中

00:04:56.830 --> 00:04:59.666 
ATS最重要方面之一

00:04:59.733 --> 00:05:03.303 
是你的應用必須使用HTTPS協議

00:05:03.971 --> 00:05:06.306 
同時它允許你 也就是開發者

00:05:06.373 --> 00:05:09.576 
在建立連接時採用最佳實踐

00:05:09.643 --> 00:05:12.279 
通過HTTPS來和遠程服務器通信

00:05:13.680 --> 00:05:18.118 
HTTP嚴格傳輸安全
或叫HSTS

00:05:18.318 --> 00:05:20.988 
是NSURLSession內置的
另外一個非常好的功能

00:05:21.154 --> 00:05:24.291 
這個功能保護了用戶的數據和隱私

00:05:24.358 --> 00:05:27.728 
現在它可以通過HTTP報頭進行配置

00:05:27.794 --> 00:05:29.897 
來自你的網頁服務

00:05:30.163 --> 00:05:32.966 
或者它可以通過預加載的列表進行配置

00:05:33.033 --> 00:05:36.069 
（列表）是嵌入在你應用程序系統中的

00:05:36.470 --> 00:05:40.307 
當配置好了以後
所有被傳輸 發送 接收的數據

00:05:40.374 --> 00:05:42.176 
都會通過一個安全的連接進行

00:05:42.609 --> 00:05:43.877 
HSTS最棒的

00:05:43.944 --> 00:05:47.447 
是它不需要在你的應用程序中
進行任何代碼改動

00:05:50.150 --> 00:05:53.420 
所有非常好的內置功能都支持

00:05:53.487 --> 00:05:58.025 
來處理緩存cookies代理

00:05:58.292 --> 00:05:59.760 
和認證請求的內置子系統

00:05:59.826 --> 00:06:02.162 
所有這些都是
NSURLSession自帶的

00:06:03.764 --> 00:06:05.399 
最後特別是 配置

00:06:05.465 --> 00:06:07.501 
正如我所說
我們討論了很多如何才能把

00:06:07.568 --> 00:06:11.772 
網絡或在你應用程序中
配置網絡變得簡單一些

00:06:12.406 --> 00:06:14.942 
因爲我們需要更好的去控制網絡

00:06:15.008 --> 00:06:17.077 
所以我們刻苦鑽研了配置這一塊兒

00:06:17.144 --> 00:06:22.649 
爲了達到二級精度
和讓你更好的控制網絡

00:06:22.716 --> 00:06:24.985 
在NSURLSession中
我們創建了一個新的類

00:06:25.052 --> 00:06:27.354 
叫NSURLSessionConfiguration

00:06:27.888 --> 00:06:31.458 
這個類包含了很多你可以配置的屬性

00:06:32.693 --> 00:06:34.528 
你可以在你的應用程序中

00:06:34.595 --> 00:06:38.165 
根據不同的網絡需求創建配置文件

00:06:39.399 --> 00:06:42.436 
這裏是一些屬性的一個樣本

00:06:42.536 --> 00:06:45.772 
你可以用NSURLSessionConfiguration
來設置它們

00:06:46.773 --> 00:06:50.978 
安全傳輸層協議
或TLS版本

00:06:51.778 --> 00:06:54.715 
你可以控制TLS版本的最低值和最高值

00:06:54.781 --> 00:06:56.884 
以便你的應用來支持

00:06:57.184 --> 00:07:02.956 
我們默認設置TSL最低版本是1.0
最高版本是1.2

00:07:04.892 --> 00:07:09.162 
你可以用你的應用程序
控制蜂窩數據的使用

00:07:09.229 --> 00:07:12.299 
你是否允許你的應用使用
蜂窩網絡

00:07:12.366 --> 00:07:16.470 
可能你只想用Wi-Fi網絡
你就可以在這裏設置

00:07:19.406 --> 00:07:22.309 
你可以指定你的網絡服務類型

00:07:22.576 --> 00:07:24.811 
這裏的一些例子可能都是默認值

00:07:24.878 --> 00:07:27.181 
也是標準的網絡數據流量

00:07:27.481 --> 00:07:30.284 
你的應用可能會有VoiP控制

00:07:30.350 --> 00:07:34.488 
或視頻數據和聲音數據
各種不同種類的數據

00:07:34.555 --> 00:07:38.091 
說實在的
這只是低端網絡層的一些提示

00:07:38.358 --> 00:07:42.729 
告訴你都有什麼樣的數據
這樣才能建立一個高質量的服務

00:07:42.796 --> 00:07:45.966 
這對你設備上運行的程序是最好的

00:07:48.402 --> 00:07:49.436 
Cookie政策

00:07:49.503 --> 00:07:52.673 
也許你想讓你的cookie
只存在一段時間

00:07:52.739 --> 00:07:54.107 
或者一直存在

00:07:54.174 --> 00:07:56.376 
這裏就是設置它的地方

00:07:56.577 --> 00:07:59.646 
同理 對於緩存
也許你想要一個臨時緩存

00:07:59.780 --> 00:08:02.850 
或者在加載應用時用持續緩存

00:08:03.283 --> 00:08:05.219 
這裏就是設置它的地方

00:08:06.320 --> 00:08:09.323 
你還可以指定存儲對象

00:08:09.523 --> 00:08:13.760 
好吧 有可能你需要在
不同類型的網絡之間共享緩存

00:08:13.827 --> 00:08:17.331 
或不同類型網絡間共享cookies
而且全部在你同一個應用中

00:08:17.531 --> 00:08:21.802 
這裏就可以設置
存儲對象實現那個配置

00:08:22.703 --> 00:08:27.975 
超時設定
你可以設置資源和請求的超時時間

00:08:28.208 --> 00:08:31.778 
這樣你的應用就可以處理
網絡中的錯誤情況

00:08:33.580 --> 00:08:38.251 
假設大多數人都有些瞭解
NSURLSession API

00:08:38.318 --> 00:08:43.490 
若沒 去2014年 WWDC 看看
關於NSURLSession部分

00:08:43.557 --> 00:08:47.995 
你會更深的
瞭解那個API是怎麼工作的

00:08:48.195 --> 00:08:50.797 
我想對於我們剩下要談的部分

00:08:50.864 --> 00:08:53.901 
最好能看一下
NSURLSession

00:08:54.501 --> 00:08:56.737 
從代碼角度來看是怎麼工作的

00:08:57.738 --> 00:08:59.973 
很簡單 我們第一步要做的

00:09:00.040 --> 00:09:02.709 
是創建一個配置對象

00:09:02.776 --> 00:09:05.979 
第一件事 這裏我們把它稱作
NSURLSessionConfigurations

00:09:06.046 --> 00:09:08.448 
.defaultSessionConfiguration

00:09:08.949 --> 00:09:13.487 
我們全部使用默認值然後我們就
有了一個非常簡單的配置可以使用

00:09:15.088 --> 00:09:18.625 
現在我們把那個配置傳給一個session

00:09:18.692 --> 00:09:21.495 
通過調用NSURLSessions emitter
可創建一個session

00:09:21.762 --> 00:09:23.163 
它接收的參數是一配置對象

00:09:23.230 --> 00:09:26.300 
噢！我們就有了
一個非常簡單的session可以使用

00:09:28.001 --> 00:09:30.737 
有了這個session
我們就可以做點事情了

00:09:31.171 --> 00:09:34.308 
好 我們首先要建立一個NSURL

00:09:34.708 --> 00:09:36.310 
並指定它的端點

00:09:36.376 --> 00:09:39.746 
就是我們從哪兒接收和請求數據

00:09:40.314 --> 00:09:43.217 
當我們有了它
我們就可以新建一個任務

00:09:43.283 --> 00:09:45.152 
在此我們調用dataTask方法

00:09:45.219 --> 00:09:47.421 
然後把NSURL對象

00:09:47.621 --> 00:09:49.923 
是我們之前新建的
傳給dataTask方法

00:09:51.592 --> 00:09:53.727 
我們也提供一個閉包

00:09:54.394 --> 00:09:56.964 
這個閉包在這裏被異步地調用

00:09:57.097 --> 00:09:59.099 
當我們的任務加載完成時

00:09:59.166 --> 00:10:02.870 
請求的資源就返回給了我們

00:10:04.238 --> 00:10:08.108 
老樣子 別忘了你要確保調用了
task.resume

00:10:08.208 --> 00:10:10.677 
我們新建的所有任務都處於掛起狀態

00:10:10.744 --> 00:10:14.348 
你必須調用task.resume
來執行那個任務

00:10:15.916 --> 00:10:18.519 
好了 現在複習下 簡單的複習

00:10:18.719 --> 00:10:22.055 
NSURLSession
實際上就是一個三部曲

00:10:22.890 --> 00:10:25.192 
首先你需要新建一個配置對象

00:10:27.794 --> 00:10:30.597 
有了那個配置項
你就可以新建你的session

00:10:32.332 --> 00:10:35.169 
有了session你就能開始幹活了

00:10:35.235 --> 00:10:37.504 
還要在session上新建些任務

00:10:37.871 --> 00:10:40.741 
我現在要建議給你些最佳實踐

00:10:42.476 --> 00:10:47.447 
一定要避免單任務對單
session的模型

00:10:48.782 --> 00:10:52.019 
你絕對不應該這樣設置你的網絡

00:10:52.686 --> 00:10:55.789 
說真的 你應該這樣設計

00:10:55.856 --> 00:10:59.426 
有一個session服務
建立很多很多任務

00:10:59.493 --> 00:11:01.495 
當然你也可以有多個session

00:11:01.728 --> 00:11:06.099 
但是一定要避免單session對單
任務的模型

00:11:06.233 --> 00:11:09.269 
原因是
它真的會降低你的網絡性能

00:11:09.403 --> 00:11:13.340 
你可以通過創建很少的幾個sessions
運行很多任務

00:11:13.407 --> 00:11:17.444 
這樣就會更好地管理內存
優化OS資源使用

00:11:20.180 --> 00:11:23.617 
像我提到過的
NSURLSession API一直在改進

00:11:23.951 --> 00:11:27.087 
我們來談一下HTTP/2協議

00:11:27.454 --> 00:11:29.723 
還有我們一直在這個協議上做出的努力

00:11:29.790 --> 00:11:31.458 
都和
NSURLSession相關

00:11:34.094 --> 00:11:37.531 
在NSURLSession中
對HTTP/2協議的支持

00:11:37.598 --> 00:11:40.100 
是去年在 WWDC 上引入的

00:11:40.701 --> 00:11:43.103 
它正在變得熱門起來

00:11:44.238 --> 00:11:48.775 
你知道吧 大的因特網服務提供商
逐漸開始支持HTTP/2

00:11:50.010 --> 00:11:53.447 
是什麼讓HTTP/2協議
變得如此吸引人

00:11:53.914 --> 00:11:55.716 
那我們就來看一下它的一些功能

00:11:55.816 --> 00:12:00.621 
HTTP/2協議非常棒的功能之一是
支持多路複用技術和併發

00:12:00.921 --> 00:12:05.158 
這個功能允許多個請求和響應

00:12:05.225 --> 00:12:07.594 
同時發生

00:12:07.995 --> 00:12:10.264 
響應可以不按順序被接收

00:12:10.464 --> 00:12:13.667 
所有的響應都在一次TCP連接中完成

00:12:14.801 --> 00:12:18.005 
這個協議另一個很棒的功能是
報頭壓縮

00:12:18.205 --> 00:12:22.142 
這樣可以減少HTTP/2報頭的大小

00:12:22.509 --> 00:12:24.945 
這也減少了在網絡上往返的次數

00:12:25.012 --> 00:12:26.446 
這樣對帶寬更好

00:12:26.513 --> 00:12:29.283 
而且更好的是可提高你應用程序的性能

00:12:30.517 --> 00:12:33.687 
還有一個很棒的功能
是流的優先級

00:12:33.820 --> 00:12:36.156 
作爲HTTP/2的客戶端

00:12:36.256 --> 00:12:40.994 
你可以指定從服務器返回資源的優先級

00:12:41.061 --> 00:12:43.730 
這就允許你留意並調整

00:12:43.797 --> 00:12:46.233 
你應用的網絡

00:12:47.467 --> 00:12:51.605 
所以本質上講
HTTP/2都是關於性能的

00:12:51.672 --> 00:12:55.075 
這樣會提升終端用戶的體驗

00:12:55.142 --> 00:12:56.977 
當他們和你的應用進行互動時

00:12:57.344 --> 00:13:02.349 
好了 關於HTTP/2
我們還有最後一個功能要來看一下

00:13:02.850 --> 00:13:06.086 
今天我們介紹的是
NSURLSession

00:13:06.153 --> 00:13:09.923 
對於HTTP/2服務器
推送功能的支持

00:13:15.996 --> 00:13:17.931 
那麼什麼是服務器推送

00:13:17.998 --> 00:13:22.803 
當客戶端發出一個請求
服務器就會對請求做出響應

00:13:23.237 --> 00:13:27.608 
但同時 它可以推送
額外的響應給客戶端

00:13:27.674 --> 00:13:29.209 
試想一個網頁

00:13:29.276 --> 00:13:31.578 
它是由很多很多資源組成的

00:13:31.945 --> 00:13:36.216 
與其讓客戶端在
網絡上一個個的抓取資源

00:13:36.283 --> 00:13:40.487 
服務器可以
在發送原始響應的同時

00:13:40.654 --> 00:13:45.459 
推送額外客戶端可能會用到的信息

00:13:46.994 --> 00:13:52.332 
這樣服務器推送就避免了HTTP/1.1
和無服務器推送產生的HTTP/2

00:13:52.399 --> 00:13:56.637 
如今所要求的網絡上往返多次

00:13:57.938 --> 00:14:01.175 
現在我想請大家注意下
服務器

00:14:01.241 --> 00:14:05.078 
很顯然得支持這個協議
得支持HTTP/2

00:14:05.145 --> 00:14:07.514 
還得進行配置

00:14:07.814 --> 00:14:10.317 
來使用服務器推送的功能

00:14:10.851 --> 00:14:14.021 
服務器推送現在可以被

00:14:14.788 --> 00:14:16.757 
使用NSURLSession
的應用程序使用了

00:14:16.823 --> 00:14:21.195 
沒有必要去選擇性加入
沒有搞笑的屬性你需要去設置

00:14:21.261 --> 00:14:23.730 
它就在那兒
就這麼簡單

00:14:24.198 --> 00:14:25.933 
這就是我們強烈認爲

00:14:25.999 --> 00:14:30.504 
NSURLSession API是
如今應用程序可以使用的最好的API

00:14:30.871 --> 00:14:33.907 
我們現在來花幾分鐘深入探討下

00:14:33.974 --> 00:14:36.343 
服務器推送如何讓你的應用受益

00:14:39.279 --> 00:14:42.983 
我有一個圖表代表着一個應用使用
NSURLSession的情況

00:14:43.050 --> 00:14:48.355 
它是用HTTP/1.1協議
來做一些網絡加載

00:14:48.689 --> 00:14:52.626 
現在我們往下看這個圖表
時間在累積

00:14:52.693 --> 00:14:55.095 
這些總共的延遲

00:14:55.162 --> 00:14:57.965 
就是當我們的應用程序
進行網絡加載時產生的

00:14:59.299 --> 00:15:02.503 
下面 首先我們的應用
要繼續開始一個任務

00:15:03.904 --> 00:15:07.074 
這個任務要請求index.html

00:15:08.041 --> 00:15:11.411 
我們會假設一切運行良好
因爲網絡會辦到的

00:15:12.079 --> 00:15:15.682 
我們就會從服務器得到響應
包含我們請求的數據

00:15:16.450 --> 00:15:19.753 
除了index.html的數據

00:15:19.820 --> 00:15:21.522 
我們發現時間已經過去了

00:15:21.755 --> 00:15:25.058 
我們的總延遲在累計 在增長

00:15:26.293 --> 00:15:28.929 
現在我們的應用要繼續執行另一個任務

00:15:28.996 --> 00:15:32.232 
然後從服務器請求style.css

00:15:32.299 --> 00:15:34.434 
假設一切正常工作

00:15:34.501 --> 00:15:36.303 
我們將會得到響應

00:15:36.937 --> 00:15:39.373 
我們就有了style.css

00:15:39.706 --> 00:15:42.576 
我們的總延遲也開始增長

00:15:42.643 --> 00:15:44.811 
隨着在網絡上獲取所需資源的時間

00:15:47.247 --> 00:15:49.616  
現在應用程序將繼續執行最後一個任務

00:15:49.683 --> 00:15:51.752  
請求background.jpg

00:15:52.219 --> 00:15:56.890  
我們會從服務器得到響應
就有了background.jpg

00:15:58.158 --> 00:16:01.595  
我們的應用到此就結束了它的網絡加載

00:16:01.795 --> 00:16:05.799  
再來看圖表
我們看到這個就是我們的總延時

00:16:05.866 --> 00:16:08.635  
用的是HTTP/1.1協議進行加載

00:16:10.537 --> 00:16:12.372 
再來看我們的應用程序

00:16:12.439 --> 00:16:16.009 
當它可以使用服務器推送的情況

00:16:16.343 --> 00:16:19.213 
我準備把HTTP/1.1
加載結果的圖表移到

00:16:19.279 --> 00:16:20.948 
一邊來做參考

00:16:21.782 --> 00:16:26.854 
我們的應用將再次繼續一個任務
請求index.html

00:16:27.087 --> 00:16:31.491 
這是我們第二次得到響應的總延遲

00:16:32.492 --> 00:16:36.029 
我們的總延遲的變化

00:16:36.163 --> 00:16:38.932 
和無服務器推送比相差不大

00:16:39.366 --> 00:16:40.567 
這是預料之中的

00:16:40.968 --> 00:16:43.237 
會發生的是

00:16:43.437 --> 00:16:47.508 
在原始請求響應的同時

00:16:47.574 --> 00:16:51.011 
服務器會推送
其他資源給NSURLSession

00:16:52.246 --> 00:16:55.115 
這個會和原始請求一起

00:16:55.182 --> 00:16:57.384 
或者是對原始請求的響應

00:16:58.452 --> 00:17:02.155 
當我們的應用繼續第二個任務時

00:17:02.723 --> 00:17:07.060 
也就是請求style.css時
我們幾乎立馬得到了響應

00:17:07.127 --> 00:17:09.363 
這是因爲服務器推送給了我們這個數據

00:17:09.429 --> 00:17:11.964 
在我們知道需要它之前

00:17:12.933 --> 00:17:16.670 
我們就有了style.css
看累計時間我們注意到

00:17:16.737 --> 00:17:19.439 
style.css的延時非常的短

00:17:19.506 --> 00:17:21.642 
比起HTTP/1.1而言

00:17:21.708 --> 00:17:24.578 
需要加載的是一摸一樣的資源

00:17:27.013 --> 00:17:31.118 
現在 我們的應用繼續了最後一個任務
請求了background.jpg

00:17:31.285 --> 00:17:33.620 
又一次 我們很快得到了響應

00:17:33.887 --> 00:17:36.023 
應用得到了background.jpg

00:17:36.223 --> 00:17:39.760 
我們把這次總延時加到累計總延時上

00:17:40.727 --> 00:17:43.597 
到這裏 應用結束了它的網絡加載

00:17:44.698 --> 00:17:48.235 
我們看到使用服務器推送的
HTTP/2所用的總延時

00:17:48.302 --> 00:17:53.507 
比使用HTTP/1或者
不用服務器推送的加載時間要短的多

00:17:53.974 --> 00:17:57.444 
能提高性能的原因是有了服務器推送

00:17:57.678 --> 00:18:00.981 
我們就能縮短在網絡上多次往返的延時

00:18:01.048 --> 00:18:03.450 
當我們需要請求資源的時候

00:18:06.920 --> 00:18:09.923 
下面 有請
Andreas Garkuscha

00:18:09.990 --> 00:18:14.361 
向我們展示在實際應用程序中
服務器推送是什麼樣子的

00:18:14.428 --> 00:18:15.596 
Andreas

00:18:20.100 --> 00:18:20.934 
謝謝你 Jeff

00:18:21.869 --> 00:18:23.070 
大家早上好

00:18:23.604 --> 00:18:25.873 
今天我將向大家展示的是

00:18:25.939 --> 00:18:30.244 
當你的應用加載資源時
使用HTTP/2服務器推送的優勢

00:18:39.219 --> 00:18:42.789 
你們看到的是一個應用非常普通的部分
你們很多人

00:18:43.056 --> 00:18:44.625 
可能已經實現過

00:18:44.691 --> 00:18:48.095 
或者在使用你們已有的應用時至少見過

00:18:48.729 --> 00:18:53.567 
你現在看到的可能是
一個針對攝影者的社交應用

00:18:53.634 --> 00:18:55.402 
可以展示最受歡迎的照片

00:18:55.669 --> 00:19:00.107 
可以爲特定的攝影者
列出最受歡迎的圖片

00:19:00.340 --> 00:19:02.142 
可以單獨看照片

00:19:02.910 --> 00:19:04.044 
可以看下一張

00:19:04.845 --> 00:19:08.215 
可以看上一張 可以回到列表最頂端
選擇另外一張進行瀏覽

00:19:09.049 --> 00:19:10.217 
等等

00:19:11.151 --> 00:19:14.154 
這個應用也可能是關於食譜的應用

00:19:14.221 --> 00:19:17.257 
或者音樂流的應用
在向我們展示專輯封面

00:19:17.324 --> 00:19:21.862 
這裏有一個應用正在從服務器加載資源

00:19:23.363 --> 00:19:26.500 
假設它是在加載和展示一些圖片

00:19:27.067 --> 00:19:30.604 
請注意的是出於演示原因
這裏有一個開關

00:19:31.271 --> 00:19:33.907 
它允許我們在初始URL上

00:19:33.974 --> 00:19:37.244 
選擇配置服務器推送
或者沒有服務器推送

00:19:38.345 --> 00:19:42.316 
在這兩種情況下
首先我們請求一個初始文檔

00:19:42.816 --> 00:19:45.285 
裏麪包含有圖片的URL以便加載

00:19:46.053 --> 00:19:47.688 
然後我們請求圖片

00:19:48.388 --> 00:19:51.625 
如果沒有使用服務器推送
什麼都不會被推送

00:19:51.692 --> 00:19:53.227 
我們就需要發送請求

00:19:53.293 --> 00:19:55.729 
讓每一個圖片都通過網絡傳回來

00:19:56.763 --> 00:20:00.667 
在啓用服務器推送的情況下
我現在就選擇到這個模式

00:20:01.835 --> 00:20:04.037 
正如Jeff之前解釋的

00:20:04.471 --> 00:20:09.576 
請求初始文檔就會引發服務器推送資源

00:20:09.643 --> 00:20:12.145 
到你的應用程序裏

00:20:13.113 --> 00:20:17.317 
這就不用通過網絡
爲每一個圖片發送請求

00:20:17.417 --> 00:20:20.153 
數據任務請求的數據就會

00:20:20.220 --> 00:20:24.291 
從服務器推送存儲中
直接傳遞到你的應用程序裏

00:20:26.627 --> 00:20:31.098 
現在我們來對比下
服務器推送和無服務器推送的加載性能

00:20:31.632 --> 00:20:36.170 
我將會在初始URL上在有服務器推送

00:20:36.236 --> 00:20:37.504 
和無服務器推送之間轉換

00:20:39.206 --> 00:20:40.507 
幾次

00:20:42.309 --> 00:20:46.213 
這樣你就可以看到
當服務器推送啓用時

00:20:47.181 --> 00:20:50.517 
整個集合視圖會加載的快一些

00:20:51.585 --> 00:20:54.788 
但是到底快多少？
好吧 讓我來展示給你

00:20:55.589 --> 00:21:00.093 
現在示例應用程序
即將給我們呈現結果

00:21:00.394 --> 00:21:02.062 
這是當前視圖的底部

00:21:02.362 --> 00:21:05.499 
紅色的是無服務器推送的最快結果

00:21:06.166 --> 00:21:09.336 
綠色的是服務器推送的最快結果

00:21:11.338 --> 00:21:13.006 
讓我多做幾次

00:21:17.845 --> 00:21:19.780 
藝術家視圖也是一樣的

00:21:23.083 --> 00:21:25.619 
多做幾次
服務器推送關閉 服務器推送開啓

00:21:26.486 --> 00:21:31.458 
你會發現服務器推送的
加載速度至少快2倍

00:21:34.561 --> 00:21:38.031 
推送圖片
大概快2到3倍

00:21:38.098 --> 00:21:41.268 
在高延遲的網絡環境中

00:21:41.335 --> 00:21:42.836 
就像我們現在正在使用的

00:21:43.203 --> 00:21:45.305 
這樣的網絡是你的應用程序

00:21:45.372 --> 00:21:48.542 
在使用蜂窩數據或
很慢的Wi-Fi下可以碰到的

00:21:49.610 --> 00:21:51.678 
我準備了一個視頻來展示

00:21:52.179 --> 00:21:56.450 
服務器推送和無服務器推送的比對

00:21:56.683 --> 00:21:58.352 
讓我來展示給你

00:22:07.628 --> 00:22:12.666 
你能看見有服務器推送
用戶已經在瀏覽圖片了

00:22:12.733 --> 00:22:15.269 
另外一個人還在試圖加載藝術家視圖

00:22:18.705 --> 00:22:20.274 
讓我們再看一遍

00:22:20.707 --> 00:22:25.612 
又一次 右邊使用服務器推送的用戶

00:22:25.679 --> 00:22:28.715 
比左邊無服務器推送的用戶進展快的多

00:22:36.323 --> 00:22:37.824 
要快2到3倍

00:22:38.258 --> 00:22:39.927 
試想下

00:22:40.093 --> 00:22:43.330 
想像下你能給你的用戶
提供的用戶體驗

00:22:43.430 --> 00:22:47.134 
你只需在你的HTTP/2服務器上
配置服務器推送

00:22:47.501 --> 00:22:50.704 
你連程序中的一個代碼都不用改

00:22:50.771 --> 00:22:52.873 
這太棒了
簡直完美

00:22:53.006 --> 00:22:54.408 
這就是服務器推送的演示

00:22:54.508 --> 00:22:56.510 
非常感謝
會議愉快

00:22:56.677 --> 00:22:57.845 
好了 換回Jeff

00:23:04.151 --> 00:23:05.452 
好 謝謝Andreas

00:23:08.188 --> 00:23:10.591 
下面讓我們總結下我們看到和討論過的

00:23:10.657 --> 00:23:14.228 
關於HTTP/2和服務器推送的內容

00:23:15.395 --> 00:23:18.799 
僅NSURLSession API
支持服務器推送

00:23:18.866 --> 00:23:22.436 
所以若你在寫新的應用或
還用NSURLConnection

00:23:22.970 --> 00:23:26.974 
我們強烈建議你馬上改用
NSURLSession API

00:23:28.041 --> 00:23:32.279 
利用服務器推送不需要任何代碼改動

00:23:32.346 --> 00:23:34.681 
不需要選擇加入
直接就可以用

00:23:35.983 --> 00:23:39.987 
你的應用有了服務器推送
就能以最佳方式運行

00:23:40.120 --> 00:23:44.358 
讓你的用戶對你的應用程序
有甚至更好的用戶體驗

00:23:47.127 --> 00:23:50.364 
NSURLSession API
的另一個改進

00:23:50.430 --> 00:23:52.966 
是附加的Network Statistics

00:23:55.836 --> 00:23:58.906 
那麼在場的誰喜歡統計？
有沒搞統計的人？

00:23:58.972 --> 00:24:00.340 
有沒熱愛統計的人？

00:24:00.407 --> 00:24:02.576 
好了 我這兒有個統計給你
準備好了嗎？

00:24:03.577 --> 00:24:04.478 
就是這個

00:24:06.914 --> 00:24:08.815 
好吧
剛纔不好意思 抱歉

00:24:08.882 --> 00:24:11.652 
我們將要看些實際有用的統計

00:24:11.718 --> 00:24:16.423 
這個就是 我們相信網絡統計就在
那2%有用的數據裏

00:24:16.857 --> 00:24:19.092 
那麼 它爲什麼有用？

00:24:19.159 --> 00:24:23.030 
你們的應用是否
碰到很差網絡性能的時候

00:24:23.730 --> 00:24:24.765 
我猜有些人遇見過

00:24:24.831 --> 00:24:27.968 
你怎麼做才能
發現到底哪兒出了問題？

00:24:28.368 --> 00:24:29.937 
你怎麼調試？

00:24:30.671 --> 00:24:34.641 
我們相信網絡統計對你們會很有用

00:24:34.741 --> 00:24:37.778 
當你在開發或調試環境下的時候

00:24:38.478 --> 00:24:41.615 
你能用這個收集信息
可能在實際運行時

00:24:41.682 --> 00:24:43.550 
可能你會最大限度利用
Test Flight

00:24:43.617 --> 00:24:46.653 
然後收集一些你的應用
在實際運行時的信息

00:24:47.688 --> 00:24:50.724 
Network Statistics是關於

00:24:50.791 --> 00:24:52.726 
你的應用中網絡加載的性能分析

00:24:52.793 --> 00:24:56.463 
是關於找到並修復和網絡相關的漏洞

00:24:56.763 --> 00:24:59.032 
也是關於讓你更好理解

00:24:59.099 --> 00:25:02.603 
你的應用裏的網絡表現如何

00:25:04.371 --> 00:25:10.711 
目前 iOS  macOS和
tvOS平臺支持網絡統計

00:25:12.479 --> 00:25:15.716 
在我們開始看實際統計數據之前

00:25:15.782 --> 00:25:18.552 
讓我來解釋下
你怎樣才能得到這些數據

00:25:18.619 --> 00:25:20.921 
要得到數據
我們需要看一些代碼

00:25:22.456 --> 00:25:28.095 
在此我們有一個全新委託
叫DidFinishCollectingMetrics

00:25:28.362 --> 00:25:32.533 
這是NSURLSession Task Delegate
類的一個委託方法

00:25:32.966 --> 00:25:36.003 
當你實現這個委託時

00:25:36.103 --> 00:25:40.240 
它需要接收一個任務參數
被用來收集度量值

00:25:40.307 --> 00:25:45.312 
還要接收一個新的類對象
這就是NSURLSessionTaskMetrics

00:25:47.414 --> 00:25:52.319 
NSURLSessionTaskMetrics類
有一個屬性叫taskInterval

00:25:53.520 --> 00:25:56.390 
這是一個時間間隔
從任務建立開始到

00:25:56.456 --> 00:25:58.525 
所有的統計數字剛被收集完成

00:25:58.592 --> 00:25:59.960 
馬上就可以傳送給

00:26:00.027 --> 00:26:02.963 
你的didFinish
CollectingMetrics委託爲止

00:26:03.197 --> 00:26:06.600 
我在這裏向你展示的另外一個屬性
是redirectCount

00:26:06.934 --> 00:26:09.837 
這個很直接
如它的名字所示

00:26:09.903 --> 00:26:13.540 
這是HTTP重定向發生的次數

00:26:13.607 --> 00:26:16.276 
在任務執行期間

00:26:17.177 --> 00:26:18.612 
NSURLSessionTaskMetrics
的最後一個屬性

00:26:19.980 --> 00:26:24.017 
叫transactionMetrics

00:26:24.451 --> 00:26:26.253 
這個屬性纔是核心

00:26:26.320 --> 00:26:28.422 
這是網絡數據的靈魂

00:26:28.488 --> 00:26:33.994 
你可以從這裏得到一個數組包含
NSURLTaskTransactionMetric對象

00:26:34.061 --> 00:26:37.598 
我們來仔細看下這個獨特的新類因爲

00:26:37.664 --> 00:26:40.601 
這纔是非常有用的度量值所在的地方

00:26:42.402 --> 00:26:44.705 
爲了更好的理解這些度量值

00:26:44.771 --> 00:26:47.474 
我們得把他們分割成4類

00:26:49.042 --> 00:26:52.880 
頭兩個NSURLTaskTransactionMetrics的屬性

00:26:52.946 --> 00:26:54.314 
組成了第一類

00:26:54.381 --> 00:26:57.351 
我們把它稱作請求和響應

00:26:58.652 --> 00:27:03.156 
這裏有兩個屬性叫做請求和響應

00:27:03.624 --> 00:27:07.928 
它們允許你去分析我到底要的是什麼

00:27:07.995 --> 00:27:12.799 
還有對原始問題的響應是什麼

00:27:14.635 --> 00:27:19.006 
統計數據的第二類是關於協議和連接的

00:27:21.708 --> 00:27:24.144 
屬性networkProtocolName

00:27:24.878 --> 00:27:28.448 
告訴你傳輸時用的是哪種類型的協議

00:27:28.515 --> 00:27:31.785 
和收集了的統計數據

00:27:31.852 --> 00:27:34.588 
這裏是你可能看到的名字的列表

00:27:34.721 --> 00:27:37.824 
HTTP/1.1 HTTP/2
或者SPDY

00:27:37.891 --> 00:27:40.160 
注意這個列表可能而且也會
隨時間而變化

00:27:41.094 --> 00:27:44.598 
你能接觸到的另一個屬性是
isProxyConnection

00:27:44.965 --> 00:27:48.168 
這個告訴你
事務是其中一部分

00:27:48.235 --> 00:27:52.439 
或者在數據採集期間有代理連接參與

00:27:52.940 --> 00:27:55.209 
或者統計數據被採集或收集了

00:27:57.311 --> 00:28:00.848 
isReusedConnection
這個屬性會被設置爲是

00:28:00.914 --> 00:28:05.219 
如果在資源獲取的時候
使用的是持續連接

00:28:08.088 --> 00:28:11.058 
度量值的第三個分類只有一個屬性

00:28:11.124 --> 00:28:15.562 
它處理的是資源加載或加載信息的信息

00:28:16.663 --> 00:28:19.633 
這個單一的屬性叫
resourceFetchType

00:28:19.967 --> 00:28:22.669 
它告訴你的是一個資源如何被得到

00:28:22.736 --> 00:28:26.373 
你在這裏可以看到網絡加載的一些數據

00:28:26.440 --> 00:28:28.909 
它意味着資源是從網絡進行加載的

00:28:28.976 --> 00:28:31.678 
或者通常所說的源加載

00:28:32.379 --> 00:28:34.081 
你可能會看見本地緩存

00:28:34.181 --> 00:28:36.450 
意味着資源是從本地緩存獲取的

00:28:36.517 --> 00:28:37.985 
資源是在你應用程序本地保存

00:28:38.051 --> 00:28:40.854 
不需要網絡事務參與

00:28:41.321 --> 00:28:42.623 
還有服務器推送

00:28:42.890 --> 00:28:47.561 
這個說明資源是從
服務器推送後的緩存裏找到的

00:28:48.195 --> 00:28:49.730 
當你發送了相應的請求時

00:28:51.164 --> 00:28:53.300 
第四類事務

00:28:53.367 --> 00:28:56.470 
和連接的建立和傳輸有關

00:28:57.538 --> 00:28:59.540 
第一組度量值

00:28:59.606 --> 00:29:03.243 
測量的是網絡連接建立所花的時間

00:29:04.745 --> 00:29:09.583 
第二組度量值測量的是
網絡加載中和HTTP相關活動的時間

00:29:09.950 --> 00:29:11.652 
這些屬性是時間戳

00:29:11.718 --> 00:29:15.122 
每有一個事件發生時被記錄一次

00:29:15.189 --> 00:29:18.725 
讓我們仔細看看
這些度量值和它們被收集的時間

00:29:18.792 --> 00:29:21.061 
在網絡加載被執行的時候

00:29:22.329 --> 00:29:24.965 
要做這個
我們來看一個很簡單的網絡加載

00:29:25.032 --> 00:29:28.035 
值得注意的是這只是加載中
某一類的某一個模型

00:29:28.101 --> 00:29:31.905 
在網絡加載時會有各種各樣的活動發生

00:29:32.005 --> 00:29:34.708 
你有緩存查找
你有cookie查找

00:29:34.775 --> 00:29:38.312 
你要處理重定向
有時候還有請求認證

00:29:38.378 --> 00:29:41.481 
但是我們讓它簡單點
只要能達到我們的目的就行

00:29:42.649 --> 00:29:45.886 
NSURLTaskTransactionMetrics類

00:29:45.953 --> 00:29:50.023 
包含的屬性中含有
在不同點的所有的這些時間戳

00:29:50.090 --> 00:29:51.725 
那麼 我們先從

00:29:52.793 --> 00:29:54.061 
fetchStart開始

00:29:54.828 --> 00:29:58.565 
fetchStart是應用程序
開始請求資源時的時間

00:29:58.632 --> 00:30:01.268 
這個獲取可以從本地緩存中實現

00:30:01.368 --> 00:30:03.971 
或者可能是源加載的資源

00:30:05.539 --> 00:30:07.774 
我們現在看的是
domainLookup

00:30:09.009 --> 00:30:11.144 
domainLookupStart
屬性

00:30:11.211 --> 00:30:15.015 
這個是資源開始準備進行
名字查找的時間

00:30:15.082 --> 00:30:16.850 
這個是DNS查詢

00:30:16.917 --> 00:30:19.820 
它把主機名轉換成一個IP地址

00:30:20.020 --> 00:30:23.991 
所以domainLookupEnd
是查找完成的時間

00:30:24.091 --> 00:30:26.193 
一個IP地址會發送回給調用者

00:30:28.195 --> 00:30:29.496 
這裏我們會看一下

00:30:29.563 --> 00:30:32.566 
連接建立時我們收集到什麼樣的度量值

00:30:33.567 --> 00:30:37.604 
connectStart屬性
是應用準備運行

00:30:37.671 --> 00:30:41.208 
或者與遠程服務器
建立TCP連接的時間

00:30:41.475 --> 00:30:43.143 
這個值可能是無效的

00:30:43.210 --> 00:30:45.512 
如果響應是從本地緩存中發現的

00:30:46.246 --> 00:30:48.849 
我馬上會談connectEnd屬性

00:30:52.519 --> 00:30:56.924 
如果你用的是HTTPS
你需要一個TLS握手協議

00:30:56.990 --> 00:30:58.759 
我們得到了
一個相關的統計數據

00:30:59.126 --> 00:31:02.329 
secureConnectionStart度量值是

00:31:02.396 --> 00:31:05.465 
在應用程序準備開始安全握手

00:31:05.532 --> 00:31:09.236 
來保證當前連接的安全性的時間
secureConnectionEnd

00:31:09.303 --> 00:31:12.773 
是當安全握手完成時 它也計時完成

00:31:14.208 --> 00:31:16.476 
正如我提過的connectEnd

00:31:16.543 --> 00:31:18.679 
是當一個應用

00:31:18.745 --> 00:31:20.814 
剛剛和遠程服務器建立起連接的時間

00:31:20.881 --> 00:31:23.917 
包括所有的安全相關的握手

00:31:24.151 --> 00:31:28.155 
這就是一個連接被認爲建立完成的時候

00:31:29.923 --> 00:31:32.025 
現在我們有了一個建立完成的連接

00:31:32.092 --> 00:31:34.394 
我們實際上可以做一些HTTP

00:31:35.863 --> 00:31:38.065 
我們有一小部分可以收集的數據

00:31:38.131 --> 00:31:40.234 
是關於請求和響應的

00:31:40.300 --> 00:31:42.636 
首先我們有requestStart

00:31:42.703 --> 00:31:45.138 
這個是當應用開始請求資源的時間

00:31:45.205 --> 00:31:47.407 
不管有沒有獲取資源

00:31:47.474 --> 00:31:49.743 
從本地緩存也好從遠程服務器也罷

00:31:50.043 --> 00:31:51.979 
如果需要一個源加載

00:31:52.312 --> 00:31:57.251 
這就是HTTP報頭
準備傳輸第一個字節的時間

00:31:57.851 --> 00:32:02.890 
requestEnd是向
網絡發送請求的最後一個字節完成時間

00:32:06.593 --> 00:32:08.061 
responseStart

00:32:08.428 --> 00:32:11.331 
這個代表服務器響應返回的第一個字節

00:32:11.398 --> 00:32:13.467 
被收到的時間

00:32:13.800 --> 00:32:14.968 
如果這是一個緩存加載

00:32:15.035 --> 00:32:19.072 
這就是從緩存收到緩存響應的時間

00:32:19.306 --> 00:32:22.843 
responseEnd
是當應用程序剛剛

00:32:22.910 --> 00:32:27.614 
收到請求資源的最後一個字節的時間

00:32:30.517 --> 00:32:34.588 
我們一直在看源加載過程中
收集到的數據

00:32:34.955 --> 00:32:37.658 
那就是 我們得通過物理網絡
發送每一個字節

00:32:39.760 --> 00:32:42.496 
網絡請求有可能

00:32:42.563 --> 00:32:44.164 
從本地緩存中得到
我也提過這點

00:32:44.231 --> 00:32:48.235 
如果一個本地緩存包含我們請求的響應

00:32:48.335 --> 00:32:49.736 
那就沒有必要用DNS

00:32:49.803 --> 00:32:52.906 
也就是沒必要建立TCP連接等等

00:32:53.273 --> 00:32:56.276 
在此緩存情況下
這些統計數據值會被設成無效

00:32:56.343 --> 00:32:59.146 
所以當你看這些統計數據時
請留意一下以上情況

00:33:00.581 --> 00:33:03.016 
那麼 你有可能會問
“嗯 這個非常酷

00:33:03.784 --> 00:33:08.388 
但我如何在我的代碼中使用它？”
想實現它 我們需要來看一些代碼

00:33:10.057 --> 00:33:12.626 
就像我之前給你們講過的
我們從委託入手

00:33:12.726 --> 00:33:17.364 
這裏我有
NSURLSessionTaskDelegate的一個實現

00:33:17.698 --> 00:33:21.702 
它實現了新
didFinishCollectingMetrics

00:33:21.768 --> 00:33:22.970 
委託的回調函數

00:33:23.036 --> 00:33:24.137 
而我在此展示的這個

00:33:24.204 --> 00:33:26.874 
在此時其實什麼用都沒有

00:33:26.940 --> 00:33:30.077 
我完全能預料到你們會在這裏
搞出一番名堂

00:33:30.143 --> 00:33:31.845 
有可能你會輸出些日誌

00:33:31.945 --> 00:33:33.213 
一個調試的好地方

00:33:33.280 --> 00:33:35.716 
可以看看你的網絡出了什麼狀況

00:33:35.782 --> 00:33:38.652 
最大限度利用Test Flight
然後輸出些日誌

00:33:38.719 --> 00:33:42.222 
這樣你就可以收集一些
在你應用程序實際運行時

00:33:42.289 --> 00:33:44.892 
網絡性能如何的信息

00:33:45.659 --> 00:33:46.727 
這都取決於你

00:33:47.194 --> 00:33:50.030 
讓我們回到這個例子上來

00:33:50.097 --> 00:33:52.499 
我們來做一些清理代碼

00:33:52.599 --> 00:33:55.135 
第一件事 我們要對委託實現

00:33:55.202 --> 00:33:57.704 
實例化出一個對象

00:34:00.073 --> 00:34:02.209 
我們要新建一個默認的配置對象

00:34:02.276 --> 00:34:06.113 
我們想全部使用默認值只需要調用
defaultSessionConfiguration

00:34:07.548 --> 00:34:10.417 
下一步我們要新建一個實例

00:34:10.484 --> 00:34:13.587 
或者說我們要新建一個
NSOperatonQueue實例

00:34:13.887 --> 00:34:16.956 
我們不得不這麼做是因爲
我們需要有個地方 有個隊列

00:34:17.190 --> 00:34:20.494 
這樣我們的委託才能真正的開始工作

00:34:23.563 --> 00:34:25.666 
像我之前提到過的

00:34:25.899 --> 00:34:29.101 
我用配置對象
創建一個NSURLSession

00:34:29.168 --> 00:34:32.773 
但在此我將調用
NSURLSession的init函數

00:34:32.940 --> 00:34:34.541 
它可以接收額外的參數

00:34:34.608 --> 00:34:38.812 
也就是那些實例化的委託對象

00:34:38.879 --> 00:34:42.416 
和我們創建的NSOperationQueue對象

00:34:42.716 --> 00:34:44.418 
好了 現在我們可以幹活了

00:34:45.886 --> 00:34:47.888 
我們用session創建一個任務

00:34:48.522 --> 00:34:50.757 
那我們需要我們的任務做些什麼？

00:34:50.824 --> 00:34:53.694 
那就讓它做個簡單的加載
服務器根目錄下的網頁吧

00:34:54.027 --> 00:34:57.030 
在這我又一次調用了
dataTask方法

00:34:57.464 --> 00:35:01.068 
它要求一個閉包作爲參數

00:35:01.802 --> 00:35:04.004 
注意下這個閉包

00:35:04.071 --> 00:35:07.441 
我們的didFinishCollectingMetrics
委託回調函數

00:35:07.508 --> 00:35:12.746 
會首先被調用而且在
閉包被調用之前

00:35:13.614 --> 00:35:14.448 
那麼

00:35:15.716 --> 00:35:18.252 
噢 還有 別忘了
你的老朋友resume任務

00:35:18.318 --> 00:35:21.755 
你得確保你讓那個任務恢復執行
這樣工作纔會真正的開始

00:35:21.822 --> 00:35:25.492 
下面是一個非常非常簡短的複習
怎樣實現

00:35:25.559 --> 00:35:30.664 
networkStatisticDelegate回調函數
和讓它能正常工作的代碼

00:35:30.764 --> 00:35:33.367 
我相信你們會去做很多更有意思的事情

00:35:33.433 --> 00:35:34.501 
會更富創造性

00:35:34.568 --> 00:35:37.704 
在你使用Network
Statistics的時候

00:35:39.773 --> 00:35:41.909 
我希望你們喜歡剛纔看到的
關於Network Statistics的內容

00:35:41.975 --> 00:35:43.143 
你們感覺如何？

00:35:44.411 --> 00:35:45.245 
好了

00:35:47.648 --> 00:35:52.352 
現在你們可以接觸到關於後臺

00:35:52.419 --> 00:35:54.488 
網絡傳輸中到底發生了什麼的一些信息

00:35:55.055 --> 00:35:57.958 
這會在調試環境中幫你

00:35:58.792 --> 00:36:00.427 
找到漏洞並修復你的應用

00:36:00.494 --> 00:36:03.297 
讓你的應用達到它們理想的工作狀態

00:36:03.363 --> 00:36:07.668 
還有調整 真正的調整網頁服務
和你在開發的應用的類型

00:36:07.734 --> 00:36:09.837 
這樣它們可以以最佳的方式運行

00:36:10.971 --> 00:36:14.875 
再說一次 這個新功能在
NSURLSession API裏已可用了

00:36:14.942 --> 00:36:18.045 
現在到了使用
NSURLSession的時候了

00:36:20.414 --> 00:36:22.416 
在最後一個環節

00:36:22.482 --> 00:36:25.085 
我會談論一個
對每個人都至關重要的話題

00:36:25.552 --> 00:36:27.221 
作爲一個開發者

00:36:27.354 --> 00:36:30.891 
我們都在意保護用戶數據的隱私

00:36:31.458 --> 00:36:35.195 
NSURLSession API
有一些內置的非常好的功能

00:36:35.262 --> 00:36:39.066 
我想給大家分享一些
我們對這些功能作出的加強

00:36:40.334 --> 00:36:42.302 
傳輸層安全 簡稱TLS

00:36:42.369 --> 00:36:47.374 
是一個保護網絡終端數據傳輸的協議

00:36:47.441 --> 00:36:51.445 
有時候你聽到SSL
這是TLS的前輩

00:36:51.512 --> 00:36:54.815 
所以TLS和SSL
有時候會換着用

00:36:55.182 --> 00:36:58.986 
TLS利用cipher
來實現這個保護

00:36:59.052 --> 00:37:03.891 
cipher在一端把數據打亂
打亂的數據通過網絡發送出去

00:37:03.991 --> 00:37:06.360 
接收端用一樣的cipher

00:37:06.426 --> 00:37:09.663 
還原打亂的數據
這樣它就可以被理解和使用

00:37:09.730 --> 00:37:12.733 
如果有人截獲了這些數據

00:37:12.799 --> 00:37:14.735 
那隻能是一大堆亂碼

00:37:14.801 --> 00:37:16.737 
他們沒辦法使用
這樣就保護了數據

00:37:17.604 --> 00:37:21.175 
有一點發生了變化
我希望提醒一下大家

00:37:21.241 --> 00:37:26.580 
那就是APPLE的平臺
不再支持RC4 cipher

00:37:27.648 --> 00:37:32.019 
想要了解更多細節
我推薦你看一下

00:37:32.753 --> 00:37:35.789 
週二關於安全性的講座

00:37:36.056 --> 00:37:37.824 
有機會的話加入他們的實驗室

00:37:37.891 --> 00:37:40.861 
然後在那兒問些更細緻的問題

00:37:41.228 --> 00:37:43.797 
這對你的應用程序意味着 儘管

00:37:43.864 --> 00:37:47.334 
你之前的連接是成功的

00:37:47.401 --> 00:37:49.903 
它有可能突然失敗

00:37:49.970 --> 00:37:54.808 
這有可能是因爲服務器
只支持RC4 cipher

00:37:55.142 --> 00:37:58.245 
我們有一個方法
你可以測試下這個理論

00:37:59.279 --> 00:38:02.883 
Mac OS有一個命令行工具
叫nscurl

00:38:03.317 --> 00:38:06.453 
可用來測和你的應用通訊的
只支持RC4 ciphers

00:38:06.520 --> 00:38:08.922 
的服務器

00:38:10.290 --> 00:38:15.796 
這裏 我會用nscurl簡單地
抓取服務器根目錄的文檔

00:38:15.929 --> 00:38:17.731 
如果我執行這個命令

00:38:18.365 --> 00:38:22.135 
哇！我看到了
HTTP加載失敗

00:38:22.202 --> 00:38:24.738 
太搞笑了
我之前還能連上那個服務器

00:38:24.805 --> 00:38:28.375 
讓我們來看看
我們關於RC4的理論到底成不成立

00:38:29.576 --> 00:38:34.348 
在這裏我向nscurl添加了
一個標記叫enable-rc4

00:38:34.648 --> 00:38:37.851 
它的意思是
我會強制使用RC4

00:38:37.918 --> 00:38:40.821 
在連接的客戶端這邊
我接着執行這個

00:38:41.355 --> 00:38:43.257 
哇！
一下子就連上了

00:38:43.323 --> 00:38:46.793 
所以這個證明瞭
服務器只支持RC4

00:38:46.894 --> 00:38:49.630 
我要和服務器的管理員談談

00:38:49.730 --> 00:38:53.267 
怎樣才能把
一些安全的cipher加進服務器

00:38:53.333 --> 00:38:57.037 
那樣我們就能在
應用程序中保護用戶數據

00:38:57.104 --> 00:38:58.939 
我希望你理解這點

00:38:59.006 --> 00:39:01.909 
我們的平臺
不再支持RC4 cipher了

00:39:01.975 --> 00:39:04.845 
這可能會影響你的應用程序
所以請注意下

00:39:06.480 --> 00:39:09.850 
應用程序安全傳輸 簡稱ATS
這是一個非常棒的功能

00:39:09.917 --> 00:39:13.053 
它允許你爲你的應用設置安全性策略

00:39:13.120 --> 00:39:15.656 
你指定密鑰來同意授權

00:39:15.956 --> 00:39:18.358 
這些成爲你應用程序的策略

00:39:18.425 --> 00:39:21.061 
我們向其中添加了兩個新的密鑰
我想和你們分享一下

00:39:21.628 --> 00:39:25.899 
第一個是
NSAllowsArbitraryLoadsInWebContent

00:39:25.999 --> 00:39:31.605 
如果你有一個WK網頁視圖
而且限定了範圍只有那個類、

00:39:31.672 --> 00:39:34.374 
如果在你的應用程序中有那個類、

00:39:34.441 --> 00:39:37.477 
而且你把這個密鑰呈現出來
那個對象就會被允許、

00:39:37.544 --> 00:39:40.214 
使用你指定的任何種形式的網絡加載、

00:39:40.280 --> 00:39:43.417 
它會忽略你的應用中任何其它策略

00:39:43.584 --> 00:39:45.619 
只有在這個對象內適用

00:39:45.686 --> 00:39:50.457 
任何這個對象之外的加載
會遵循你的安全性策略

00:39:52.726 --> 00:39:57.598 
另外一個密鑰
是NSRequiresCertificateTransparency

00:39:57.731 --> 00:40:00.601 
這個要求你的應用收到的證書

00:40:00.667 --> 00:40:05.305 
必須支持證書透明功能

00:40:05.606 --> 00:40:09.409 
證書透明
是簽名證書的一個功能

00:40:09.610 --> 00:40:14.047 
它允許你使用一個更加有保障的證書

00:40:14.314 --> 00:40:15.983 
可以保障提供的證書是合法的

00:40:16.283 --> 00:40:19.286 
而且你可以相信終端提供給你的證書

00:40:20.020 --> 00:40:23.323 
更多關於那個主題的細節

00:40:23.390 --> 00:40:26.293  
我還是要推薦你去看一看
這些關於安全性的講座

00:40:26.360 --> 00:40:31.031  
或者參加他們的實驗室來瞭解
證書透明的更多細節

00:40:31.431 --> 00:40:34.968 
我談過的所有內容都是關於
NSURLSession API的

00:40:35.135 --> 00:40:39.273 
我們也目睹了這個API
通過新增加的功能而進步

00:40:39.473 --> 00:40:40.908 
我們非常興奮的想看到

00:40:40.974 --> 00:40:43.277 
你們會對你們的應用程序
做出怎樣的調整

00:40:43.343 --> 00:40:45.879 
在你們利用某些新功能時

00:40:47.447 --> 00:40:51.251 
我介紹了對HTTP/2服務器
推送功能的支持

00:40:51.652 --> 00:40:55.088 
這意味着你們的應用
將可以運行的更良好

00:40:56.823 --> 00:40:59.026 
我介紹了Network Statistics

00:40:59.426 --> 00:41:02.529 
你就可以內省
你的應用程序的網絡行爲

00:41:02.596 --> 00:41:04.064 
這是前所未有的

00:41:04.364 --> 00:41:08.836 
這會提升你應用程序的
終端用戶的用戶體驗

00:41:10.070 --> 00:41:13.473 
我還分享了ATS中
一些安全性相關的功能

00:41:13.540 --> 00:41:16.076 
和棄用RC4 cipher

00:41:16.243 --> 00:41:19.379 
你的應用現在可以實現
最佳的安全實踐

00:41:19.446 --> 00:41:22.883 
來保證你用戶數據的安全

00:41:24.251 --> 00:41:28.322 
我們希望你會在應用程序中
使用NSURLSession

00:41:28.622 --> 00:41:31.225 
不僅僅因爲這些原因
也因爲所有非常棒的功能

00:41:31.291 --> 00:41:33.627 
都內置於
NSURLSession API

00:41:35.362 --> 00:41:38.765 
如果你需要更多信息
這是今天講座的URL鏈接

00:41:38.832 --> 00:41:41.702 
你可以回去回顧
我們今天談到的一些內容

00:41:42.736 --> 00:41:46.507 
我們認爲你可能會
感興趣的一些和這個主題相關的講座

00:41:46.573 --> 00:41:48.542 
我把它們在這兒給你列出來了

00:41:49.376 --> 00:41:50.611 
好的 就是這些
謝謝

00:41:50.677 --> 00:41:53.947 
希望你在餘下的
WWDC 會議裏過得愉快 謝謝