00:00:19.586 --> 00:00:24.291 
UIkit 動畫和過渡的新進展

00:00:29.830 --> 00:00:30.931 
下午好

00:00:32.299 --> 00:00:33.734 
我是Bruce Nilo

00:00:33.834 --> 00:00:36.470 
我是UIKit的一名工程經理

00:00:36.870 --> 00:00:41.575 
今天 我和我的同伴
Mike Turner都非常興奮

00:00:41.808 --> 00:00:44.645 
我們會介紹一些新的動畫API

00:00:44.711 --> 00:00:47.848 
在iOS 10中的UIKit
將會包含這些新特性

00:00:48.448 --> 00:00:51.752 
我們相信這些API將會讓你更簡單的

00:00:51.818 --> 00:00:54.888 
創建自然的 順暢的

00:00:54.955 --> 00:01:00.060 
和可響應的應用

00:01:00.961 --> 00:01:04.598 
今天我們會先快速重溫一下

00:01:04.965 --> 00:01:09.837 
UIKit中已有的
一些隱式動畫API

00:01:10.504 --> 00:01:12.840 
然後我們會深入的介紹一個全新的類

00:01:12.906 --> 00:01:16.410 
我們叫它UIViewPropertyAnimator

00:01:17.511 --> 00:01:21.782 
我們還會介紹一些
用於視圖控制器切換的擴展

00:01:21.949 --> 00:01:24.818 
以便於你們更好的使用這些新類

00:01:26.386 --> 00:01:31.024 
Mike將上臺給大家一個很棒的展示
展示如何使用這些新的API

00:01:31.091 --> 00:01:33.594 
還有一個全新的圖片應用的例子

00:01:33.660 --> 00:01:35.929 
不久你就可以下載到

00:01:36.964 --> 00:01:40.100 
我們還會討論一些細微的問題

00:01:40.167 --> 00:01:43.337 
關於這些新類的觸摸處理和點擊測試

00:01:43.904 --> 00:01:45.839 
和該如何使用這些新的類

00:01:45.906 --> 00:01:49.276 
來創建甚至可以被中斷的關鍵幀動畫

00:01:51.078 --> 00:01:54.948 
UIKit中的隱式屬性動畫

00:01:55.415 --> 00:01:59.219 
基本上是爲了

00:01:59.920 --> 00:02:04.625 
讓你可以創建動態的內容

00:02:04.691 --> 00:02:10.163 
你可以通過設置視圖的屬性
並讓動畫在一段時間內發生

00:02:12.999 --> 00:02:18.672 
它是隱式的
因爲UIKit爲你創建了動畫

00:02:18.739 --> 00:02:21.208 
值變化時會被記下來

00:02:21.275 --> 00:02:25.879 
用原始值和最後的值做個差值

00:02:25.946 --> 00:02:29.983 
這個值會在你指定的時間段上

00:02:30.050 --> 00:02:34.821 
用一個可選的定時函數決定
這個動畫的節奏

00:02:36.290 --> 00:02:37.991 
我們再具體的介紹下

00:02:38.759 --> 00:02:41.128 
這裏有一個非常簡單的動畫

00:02:41.595 --> 00:02:44.898 
今天的展示中我們會一直使用這個例子

00:02:44.965 --> 00:02:48.035 
我們有個圓基本就是從左到右來運動

00:02:48.836 --> 00:02:51.538 
通過設置視圖的中心屬性來讓其運動

00:02:51.605 --> 00:02:55.742 
在這個圖中我們看到一個虛線圓形

00:02:55.809 --> 00:02:57.845 
或者是一個虛線正方形
它代表了視圖

00:02:57.911 --> 00:02:59.880 
在實際動畫中你看到的樣子

00:03:00.247 --> 00:03:03.383 
而實線形狀代表目標值

00:03:03.450 --> 00:03:06.887 
我們也分別把它們叫做模型值和展示值

00:03:07.921 --> 00:03:12.626 
我們開始這個動畫
然後它以一定的速度進行

00:03:12.693 --> 00:03:15.762 
實際上你會注意到這個速度是恆定的

00:03:16.630 --> 00:03:18.665 
問題是今天我們將要怎麼做

00:03:19.099 --> 00:03:20.534 
今天的實現將會很簡單

00:03:21.468 --> 00:03:25.239 
你們中大部分可能熟悉
animateWithDuration API

00:03:26.139 --> 00:03:30.177 
在這個例子中 我們指定在X軸上

00:03:30.244 --> 00:03:33.180 
圓的中心應該從0移動到100

00:03:35.916 --> 00:03:39.586 
現在定時函數可設置爲.linear

00:03:39.653 --> 00:03:42.022 
簡單來說它表示一個特性函數

00:03:42.089 --> 00:03:45.392 
我們快速介紹下在UIKit中
什麼是定時函數

00:03:45.759 --> 00:03:52.232 
它是一個三次函數
映射"0到1"到"0到1"

00:03:52.366 --> 00:03:53.901 
同時有兩個約束

00:03:53.967 --> 00:03:56.170 
就是說 在動畫開始的時候

00:03:56.236 --> 00:03:58.572 
即在一開始時

00:03:58.772 --> 00:04:03.377 
動畫進行的速度值就是這個開始值

00:04:03.810 --> 00:04:05.479 
結束的時候 就是結束值

00:04:06.313 --> 00:04:13.020 
現在定時函數不定義你的動畫速度了

00:04:13.320 --> 00:04:19.125 
現在通過這個誇大的漸入定時函數
可以很容易的實現

00:04:19.692 --> 00:04:22.796 
你會注意到動畫進行到一半時

00:04:23.330 --> 00:04:25.632 
它的進度移動很少

00:04:25.999 --> 00:04:28.702 
它真的時進行的相當的慢

00:04:29.403 --> 00:04:32.406 
我們差不多離完成有90%了

00:04:32.773 --> 00:04:34.374 
但我們還是隻到了一半的位置

00:04:34.908 --> 00:04:37.811 
在你指定時間的最後10%裏

00:04:37.878 --> 00:04:39.680 
我們將會完成剩下的距離

00:04:39.746 --> 00:04:41.748 
簡單說 它會加速

00:04:41.982 --> 00:04:46.787 
從速度非常慢到非常快直到最後

00:04:47.054 --> 00:04:49.022 
這就是定時函數的作用

00:04:50.490 --> 00:04:55.395 
現在UIKit有四個定時函數

00:04:55.629 --> 00:04:58.398 
這些是特定的三次貝塞爾函數實例

00:04:58.465 --> 00:05:00.767 
這是我們以前看到的特定函數

00:05:01.001 --> 00:05:02.402 
這是漸入漸出

00:05:03.804 --> 00:05:06.807 
這是漸入

00:05:08.442 --> 00:05:11.578 
最後 這是漸出

00:05:12.746 --> 00:05:15.282  
這些是我們提供的非常細微的函數

00:05:15.349 --> 00:05:19.052  
將會影響一部分動畫的感覺

00:05:22.022 --> 00:05:23.423  
關於回彈會有什麼呢

00:05:24.091 --> 00:05:27.995 
我們也有隱式的動畫API
提供給你來設置一個回彈

00:05:28.529 --> 00:05:30.764 
我們不會否認如果你想說

00:05:30.831 --> 00:05:32.499 
"那不是實際的插值

00:05:32.566 --> 00:05:36.170 
我們把這個值做得
有點過並且有點回彈"

00:05:36.970 --> 00:05:40.474 
然而 接下來 大家可以都

00:05:40.541 --> 00:05:43.877 
想一下把回彈作爲
另一種類型的定時函數

00:05:44.411 --> 00:05:46.113 
現在看看我們爲什麼能這麼做

00:05:46.580 --> 00:05:48.916 
來看看這個簡單的應用

00:05:48.982 --> 00:05:51.618 
我們讓一個方塊從左面移動到了右面

00:05:54.388 --> 00:05:57.758 
我們繪製了位置移動圖

00:05:57.824 --> 00:06:01.595 
在方塊移動的過程中

00:06:01.662 --> 00:06:03.764 
它有點像定時函數

00:06:03.830 --> 00:06:05.365 
實際上它不是立方函數

00:06:05.632 --> 00:06:07.835 
我們過度設置了它的值

00:06:07.901 --> 00:06:12.406 
但我們仍可認爲
它是可以影響動畫的速度的

00:06:12.539 --> 00:06:16.877 
接下來的API中
我們將會對回彈動畫進行分類

00:06:18.545 --> 00:06:22.783 
現在在iOS 8中有另一個重要的
用來製造動畫的版本

00:06:23.283 --> 00:06:24.685 
我告訴你這些

00:06:24.751 --> 00:06:27.487 
因爲稍後我們還會談到它

00:06:28.555 --> 00:06:34.194 
簡單說 考慮一個動畫
在動畫進行的中間改變

00:06:34.261 --> 00:06:36.029  
所以你將從一個位置到另一個位置

00:06:36.096 --> 00:06:37.731  
到一半的時候 你變了

00:06:37.931 --> 00:06:44.204  
在iOS 8以前 如果你這麼做
你的動畫將會有一箇中斷

00:06:44.438 --> 00:06:46.640  
除非制定了一個特別的配置

00:06:46.707 --> 00:06:50.911  
UIViewAnimationOption
BeginFromCurrentState

00:06:51.278 --> 00:06:53.947  
如果你這麼做了
將會看起來好一點

00:06:54.681 --> 00:06:56.683  
將不會有間斷和跳躍

00:06:56.950 --> 00:06:58.418  
但是仍然不會順滑

00:06:58.485 --> 00:07:01.054  
速度變化的很突然

00:07:02.055 --> 00:07:07.528  
在iOS 8中
我們做了一個重大改變

00:07:07.895 --> 00:07:10.464  
動畫中的特定的屬性被漸進的完成

00:07:10.531 --> 00:07:13.600  
我們沒有移除之前的動畫
我們把後來的加了上去

00:07:13.667 --> 00:07:16.370  
這樣能平滑處理速度的變化

00:07:17.538 --> 00:07:22.809  
通過使用新的UIViewPropertyAnimator
第一種情況就不會再存在了

00:07:25.345 --> 00:07:29.983 
好的 現在我們看看新的類
我們已經快速瀏覽了

00:07:31.718 --> 00:07:32.719 
它的一些特性

00:07:32.786 --> 00:07:33.787 
我們已經很熟悉了

00:07:34.054 --> 00:07:38.825 
如果你熟悉以前的
animateWithDuration配套的API

00:07:38.892 --> 00:07:41.962 
新的API你也不會陌生

00:07:42.396 --> 00:07:43.430 
它是可以被中斷的

00:07:43.497 --> 00:07:46.200 
這意味着你可以暫停和停止動畫

00:07:46.834 --> 00:07:50.137 
你可以打磨它們
意思就是說你可以讓它前進後退

00:07:50.204 --> 00:07:53.640 
用你喜歡的方式
基於這個可編程的API

00:07:54.308 --> 00:07:55.275 
你可以反轉它們

00:07:55.342 --> 00:07:57.778 
你可以說
別擔心 往回走

00:07:58.445 --> 00:08:01.548 
我們將會介紹一整套定時函數

00:08:01.615 --> 00:08:03.784 
而不僅僅是以前的那四個

00:08:03.851 --> 00:08:08.755 
通過回彈動畫的一種小的子集

00:08:09.723 --> 00:08:11.358 
最後 當動畫運行時

00:08:11.425 --> 00:08:15.162 
往上添加動畫將會非常簡單

00:08:16.763 --> 00:08:20.767 
但是介紹這些API有點困難

00:08:20.834 --> 00:08:24.972 
所以我不打算做這撓頭的事

00:08:25.205 --> 00:08:28.108 
讓我們大體看一下
這些API是什麼樣子

00:08:28.342 --> 00:08:32.145 
在所有這些新類的中心是
UIViewPropertyAnimator

00:08:32.645 --> 00:08:36.416 
它實現了兩個新的協議

00:08:37.484 --> 00:08:40.453 
把它們作爲協議實現的原因

00:08:40.520 --> 00:08:43.890 
或實現這兩個新的協議
我們將會看到它會非常有用

00:08:43.957 --> 00:08:46.527 
當我們把它
和視圖控制器切換放在一起使用時

00:08:48.095 --> 00:08:49.663  
當你創建一個屬性動畫生成器

00:08:49.730 --> 00:08:51.598  
你將會創建一個新的對象類型

00:08:51.665 --> 00:08:54.735  
這會高效的指定定時函數

00:08:54.801 --> 00:08:57.337  
將會使用在你的動畫中

00:08:57.437 --> 00:09:00.340  
我們提供了兩個新的具體的類來實現

00:09:01.208 --> 00:09:04.545 
我們已經引入了一些新的枚舉

00:09:04.811 --> 00:09:07.614 
以供協議中的方法使用

00:09:07.681 --> 00:09:13.053 
例如 動畫生成器的狀態可以爲非活動
活動或者停止

00:09:13.253 --> 00:09:15.856 
一會我們再討論這些

00:09:16.557 --> 00:09:18.659 
我們也引入了位置

00:09:18.959 --> 00:09:21.795 
即動畫停止的地方

00:09:21.862 --> 00:09:24.731 
動畫會遍歷所有我們設定的地方麼

00:09:24.798 --> 00:09:26.800 
我們是通過反轉它來回到開始位置麼

00:09:26.867 --> 00:09:31.004 
或者我們可能打斷了它
還有可能其他的實現

00:09:31.805 --> 00:09:32.673 
好的

00:09:34.541 --> 00:09:37.845 
我們先來集中在這個圖的中間部分

00:09:38.745 --> 00:09:42.015  
然後我們會簡要說下
所有的這些新的定時函數

00:09:43.584 --> 00:09:47.688 
那麼我們來看看這個角上的API

00:09:47.754 --> 00:09:50.624 
它被定義在UIViewAnimating協議中

00:09:50.691 --> 00:09:52.025 
有趣的地方都在這

00:09:52.092 --> 00:09:53.427 
實際上這非常的簡單

00:09:53.493 --> 00:09:56.630 
有幾個屬性你可以獲得和設置

00:09:57.598 --> 00:09:59.867 
比如 你可以設置
fractionComplete

00:09:59.933 --> 00:10:01.468 
你可以讓動畫開始

00:10:01.535 --> 00:10:03.237 
你可以暫停 停止 完成動畫

00:10:03.303 --> 00:10:04.838 
這些都不用過多解釋

00:10:06.240 --> 00:10:10.711 
下一個協議給這個動畫生成器增加了
隱式的特徵

00:10:10.777 --> 00:10:14.314 
比如你想在哪裏設置塊和目標值

00:10:14.381 --> 00:10:16.884 
給這個設置動畫的屬性

00:10:17.184 --> 00:10:21.588 
這裏同時有個有意思的方法
叫做continueAnimation

00:10:21.655 --> 00:10:24.925 
能讓一個暫停的動畫

00:10:25.158 --> 00:10:28.295 
和一個完全不同的結束時間一起處理

00:10:28.495 --> 00:10:30.764 
甚至是一個不同的定時函數

00:10:33.800 --> 00:10:37.304 
UIViewPropertyAnimator
有幾個構造方法

00:10:37.371 --> 00:10:40.407 
也有一些屬性用來處理觸摸事件

00:10:40.474 --> 00:10:42.709 
我們會在最後討論它

00:10:44.411 --> 00:10:48.949 
首先我們討論下
如何使用這些基本的東西

00:10:49.249 --> 00:10:52.219 
我們將會討論一些不是那麼明顯的細節

00:10:52.286 --> 00:10:55.556 
你可能會在暫停和刷新
一個動畫的時候遇到

00:10:56.356 --> 00:10:58.358 
同時也有一些有趣的可能

00:10:58.425 --> 00:11:00.427 
取決於你如何反轉一個動畫

00:11:02.062 --> 00:11:06.099 
最後 我們會介紹所有的定時提供者

00:11:07.167 --> 00:11:09.303 
讓我們從一個實際的簡單的動畫開始

00:11:10.504 --> 00:11:12.339 
同時我讓這個例子變得更有趣了一些

00:11:12.406 --> 00:11:15.576 
爲了教學目的 稍後你會看到

00:11:16.176 --> 00:11:17.945 
我來問個問題

00:11:18.812 --> 00:11:21.448 
“你將怎麼樣使用屬性
動畫生成器來完成它”

00:11:21.882 --> 00:11:23.350 
它非常非常簡單

00:11:23.650 --> 00:11:26.053 
第一步需要創建一個定時對象

00:11:26.320 --> 00:11:32.759 
就像以前用的
枚舉.easeInOut

00:11:33.227 --> 00:11:37.364 
你需要指定持續時間
來實例化其中的一個對象

00:11:37.865 --> 00:11:39.233 
和這個定時對象

00:11:40.400 --> 00:11:43.270 
通過使用閉包添加動畫

00:11:43.337 --> 00:11:46.206 
更新你想設置動畫的屬性

00:11:46.740 --> 00:11:48.575 
你可添加一個可選的完成後執行函數

00:11:48.876 --> 00:11:52.846 
這個例子中
這個函數把背景色變成了橘色

00:11:53.413 --> 00:11:55.482 
然後你可以在任何時候開始這個動畫

00:11:56.483 --> 00:12:00.187 
是的 相對於舊的API有點繁瑣

00:12:00.254 --> 00:12:02.022 
但現在你有了個對象

00:12:02.089 --> 00:12:04.124 
你可以用它來做所有的事情

00:12:04.191 --> 00:12:06.059 
這和以前有點不同

00:12:07.327 --> 00:12:13.700 
讓我們看下UIViewPropertyAnimator
一些其他可用的屬性

00:12:13.767 --> 00:12:15.269 
其中有三個比較有意思

00:12:15.335 --> 00:12:17.905 
有狀態 有是否在運行

00:12:17.971 --> 00:12:21.108 
和是在正向還是反向在運行

00:12:21.441 --> 00:12:24.778 
這些都是KVO中可觀察的屬性

00:12:26.213 --> 00:12:28.081 
第一步你需要做的是添加一個動畫

00:12:28.148 --> 00:12:30.918 
我們將會讓這個圓再一次從左移動到右

00:12:31.118 --> 00:12:34.888 
一旦你開始你應該添加一個動畫閉包

00:12:35.389 --> 00:12:37.057 
你可以開始這個動畫

00:12:37.391 --> 00:12:40.894 
然後你開始這個動畫
動畫的狀態會改變 變成運行

00:12:41.228 --> 00:12:44.965 
現在這個視圖實際的值開始改變

00:12:45.032 --> 00:12:48.035 
有一個目標值你可以在屏幕上看到

00:12:48.702 --> 00:12:50.604 
然後動畫開始運行

00:12:50.671 --> 00:12:55.075 
現在不同的是
我可以在動畫運行的時候暫停

00:12:55.309 --> 00:12:58.245 
我可以通過讓動畫生成器暫停實現

00:12:59.346 --> 00:13:02.783 
我還可以讓它從相反的方向再來一次

00:13:03.083 --> 00:13:06.086 
現在動畫還是在在暫停中
你可以注意狀態的變化

00:13:07.154 --> 00:13:08.188 
然後我開始

00:13:09.056 --> 00:13:11.158 
動畫開始運行從相反的方向

00:13:12.426 --> 00:13:15.629 
現在我再改變 動畫接着向前運行

00:13:16.230 --> 00:13:17.431 
當完成的時候

00:13:18.165 --> 00:13:20.934 
將會調用你註冊的完成處理函數

00:13:21.201 --> 00:13:24.238 
這次我們通過.end來調用

00:13:24.304 --> 00:13:27.875 
我們一直用這種方式來初始化

00:13:28.108 --> 00:13:30.477 
如果在動畫運行時
我們沒有再一次反轉它

00:13:30.744 --> 00:13:33.080 
我們將會調用.start來完成動畫

00:13:33.146 --> 00:13:37.584 
這樣 你的結束處理函數
能知道動畫實際是在哪兒結束的

00:13:39.553 --> 00:13:40.420 
好的

00:13:40.487 --> 00:13:44.391 
除了暫停動畫還有其他你可以做

00:13:44.625 --> 00:13:46.293 
你可以停止動畫

00:13:46.560 --> 00:13:47.628 
這是什麼意思呢

00:13:47.895 --> 00:13:50.264 
首先你會注意到的是 立刻

00:13:50.330 --> 00:13:53.200 
這個圓在中間停住了

00:13:53.567 --> 00:13:57.237 
在屏幕中間可以看到我們明顯提示了

00:13:57.304 --> 00:14:01.141 
動畫視圖的實際模式數值

00:14:01.775 --> 00:14:04.478 
這時你可以對這個圓做任何操作

00:14:04.845 --> 00:14:08.649 
但我們傳了個false參數來停止

00:14:08.715 --> 00:14:10.417 
表示不要立即跳到

00:14:10.484 --> 00:14:13.520 
非活動狀態 保持在準完成狀態

00:14:13.987 --> 00:14:15.956 
它表示在未來某個時候

00:14:16.023 --> 00:14:18.592 
你將調用
finishAnimation

00:14:18.659 --> 00:14:23.764  
同時你將指定一個動畫實際結束的位置

00:14:23.830 --> 00:14:27.734  
在這個例子中 我們既不會在開始完成
也不會在結束完成

00:14:28.135 --> 00:14:31.171  
你的完成函數
將會在這個位置被調用

00:14:31.638 --> 00:14:34.241 
現若你調用了stopAnimation
並傳入了true參數

00:14:34.308 --> 00:14:36.410 
我們將不會調用你的結束函數

00:14:36.476 --> 00:14:39.580 
它將會在那個點完成

00:14:40.180 --> 00:14:44.651 
現在我們看看如果你調用
finishWithADifferentPosition會發生什麼

00:14:44.952 --> 00:14:47.154 
若調用
finishWithTheEnd

00:14:48.355 --> 00:14:52.860 
它將會直接跳到動畫的起始位置

00:14:53.393 --> 00:14:56.196 
你可能回想
“爲什麼需要這麼做”

00:14:56.630 --> 00:14:59.733 
實際上這給了你很多可能

00:14:59.800 --> 00:15:03.036 
比如 想象下你將要暫停這個圓

00:15:03.170 --> 00:15:05.772 
或者在你觸摸它的時候來暫停動畫

00:15:06.206 --> 00:15:07.875 
然後你可以拽這個圓來回轉動

00:15:07.941 --> 00:15:10.844 
也許你設置了一些
UIKit的臨時行爲

00:15:10.911 --> 00:15:14.281 
在結束位置或者目標位置

00:15:14.481 --> 00:15:17.718 
當你釋放它 根據你手勢的速度

00:15:17.885 --> 00:15:20.387 
它可能卡入那些相對位置

00:15:20.587 --> 00:15:23.557 
一旦到達了那裏就可調用
finishAnimation

00:15:23.757 --> 00:15:25.726 
通過.end和.begin

00:15:25.926 --> 00:15:27.561 
然後你可以做一些有意思的事情

00:15:27.628 --> 00:15:30.764 
來種植你開啓的動畫

00:15:40.274 --> 00:15:42.609 
好的 暫停和刷新

00:15:43.310 --> 00:15:44.845 
不是很多 對麼

00:15:45.479 --> 00:15:46.947 
這有點意思

00:15:47.014 --> 00:15:50.517 
這裏有個樣例程序

00:15:51.351 --> 00:15:53.887 
我們給這個方塊設置了一些手勢識別

00:15:53.954 --> 00:15:56.023 
在那個綠色進度條上

00:15:56.957 --> 00:16:00.594 
我們可以刷那個進度條

00:16:00.661 --> 00:16:03.096 
我們用方塊的位置更新它的值

00:16:03.163 --> 00:16:04.998 
然後我們繼續操作方塊

00:16:05.632 --> 00:16:09.736 
你會發現移動的時候方塊的位置

00:16:09.803 --> 00:16:12.206 
在圖中看起來有奇怪的突起

00:16:12.272 --> 00:16:14.041 
這裏我們簡單的說下

00:16:15.509 --> 00:16:18.478 
在介紹之前 我們看看這些手勢識別

00:16:18.545 --> 00:16:21.915 
在方塊上 我們添加了輕觸手勢識別

00:16:22.115 --> 00:16:24.751 
來檢查動畫是否是活動的

00:16:25.018 --> 00:16:28.155 
如果是活動的 它將會檢查是否在運行

00:16:28.522 --> 00:16:30.224 
如果它在運行 將會暫停它

00:16:30.290 --> 00:16:32.359 
如果不是 它將會重新開始

00:16:32.693 --> 00:16:33.760 
相當直觀

00:16:34.995 --> 00:16:38.699 
在進度條上
我們設置了一個平移手勢

00:16:38.932 --> 00:16:41.802 
我們會根據位置計算一個分數

00:16:41.869 --> 00:16:46.807 
我們在平移時

00:16:46.874 --> 00:16:50.244 
相對整個進度條的邊界

00:16:50.310 --> 00:16:52.346 
根據我們計算的分數

00:16:52.513 --> 00:16:56.817 
我們將同時更新動畫生成器和
進度條作爲fractionComplete

00:17:00.554 --> 00:17:01.388 
好的

00:17:01.622 --> 00:17:04.590 
那麼 這個圖怎麼了

00:17:08.896 --> 00:17:11.498 
有些有意思的事情在發生

00:17:14.167 --> 00:17:17.069 
方便解釋它
我將會回到之前類似的

00:17:17.137 --> 00:17:19.573 
誇大的漸入曲線

00:17:20.307 --> 00:17:23.944 
這次 進入了50%

00:17:24.011 --> 00:17:26.780 
我們暫停了動畫
現在我們想刷信它

00:17:29.116 --> 00:17:31.852 
需要重點注意的是
fractionComplete

00:17:32.119 --> 00:17:35.422 
實際上你的設置和時間無關

00:17:35.489 --> 00:17:37.024 
我們剛暫停了動畫

00:17:37.090 --> 00:17:42.629 
你設置的是相對於終點值的小數

00:17:42.930 --> 00:17:46.166 
在這種情況下 我們不會有任何進展

00:17:46.633 --> 00:17:48.969 
現在我們將會刷新這條線

00:17:49.036 --> 00:17:50.637 
我們將會繼續來一次

00:17:51.138 --> 00:17:56.243 
我們不想跳到能看出位置

00:17:56.543 --> 00:17:58.345 
這個正在設置動畫的視圖

00:17:58.779 --> 00:18:02.115 
所以 實際上 我們是把時間映射回

00:18:02.182 --> 00:18:04.585 
定時函數開始的位置

00:18:04.918 --> 00:18:08.956 
就是說當我們繼續這個特殊的例子的話

00:18:09.857 --> 00:18:11.859 
這個動畫將會快速的完成

00:18:12.759 --> 00:18:16.063 
所以當我們回到剛纔看到的曲線

00:18:16.129 --> 00:18:18.398 
你會發現我們有點往回跳

00:18:18.465 --> 00:18:22.169 
到漸入漸出定時函數

00:18:22.636 --> 00:18:25.205 
並且注意到這很重要
當暫停和刷新的時候

00:18:25.272 --> 00:18:29.309 
根據任何UI提示你可能需要這麼做

00:18:29.409 --> 00:18:33.847 
你可能會看到這些不連續性
並且需要做些補償

00:18:35.015 --> 00:18:36.984 
好的 讓我們談下反轉

00:18:37.885 --> 00:18:40.921 
有三種方式你可以用來反轉

00:18:41.421 --> 00:18:46.527 
一個是你可以暫停反轉 比如需要交互

00:18:46.894 --> 00:18:48.095 
需要再來一遍

00:18:48.662 --> 00:18:52.699 
你會發現你是字面上的直接反轉回來

00:18:52.799 --> 00:18:55.402 
通過你指定的定時函數

00:18:55.836 --> 00:18:57.571 
你可以在任何時候反轉

00:18:58.038 --> 00:18:59.973 
就是說 即使在動畫運行時

00:19:00.040 --> 00:19:01.208 
你也可以來讓動畫反轉

00:19:01.275 --> 00:19:03.377 
這有點像打一堵牆

00:19:03.710 --> 00:19:07.080 
再一次
這將會導致速度上的很大的不連續性

00:19:07.414 --> 00:19:12.219 
這將可能是你想要的

00:19:12.286 --> 00:19:15.389 
如果你想要一個完美的非彈性碰撞
或者類似的東西

00:19:15.989 --> 00:19:18.959 
如果你不想這樣或者
你想讓它更順滑些

00:19:19.193 --> 00:19:21.195 
你可以累加的使用動畫

00:19:21.628 --> 00:19:24.965 
在這個例子中 我們將會反轉動畫

00:19:25.065 --> 00:19:27.134  
不是通過修改反轉屬性

00:19:27.568 --> 00:19:31.905  
二是通過實際的修改值到
原始的位置

00:19:32.573 --> 00:19:34.741  
它們的不同是

00:19:34.808 --> 00:19:36.877  
結束的時候處理函數的調用

00:19:36.944 --> 00:19:38.979  
.end函數將會被調用

00:19:39.213 --> 00:19:41.014  
你已經改變了目標

00:19:41.081 --> 00:19:46.687  
你將不會回到初始的目標

00:19:46.753 --> 00:19:50.190 
你將會回到你剛纔指定的目標

00:19:51.825 --> 00:19:54.361 
好的 有些有意思的

00:19:55.329 --> 00:20:01.468 
定時對象可以用

00:20:02.503 --> 00:20:05.639 
第一個是UICubicTimingParameter類

00:20:05.706 --> 00:20:08.141 
如果創建這一類時不設定任何參數

00:20:08.208 --> 00:20:11.778 
你將得到默認的core animation時間曲線

00:20:11.845 --> 00:20:14.848 
這之前在UIKit層面並不可用

00:20:15.482 --> 00:20:17.584 
第二 構造函數變量

00:20:17.651 --> 00:20:23.357 
本質上是現有的canned動畫曲線

00:20:23.423 --> 00:20:27.494 
最後我們開放了所有l
可用的貝賽爾曲線

00:20:27.761 --> 00:20:29.830 
供你在這個單位正方形內使用

00:20:30.030 --> 00:20:32.299 
舉個你可能會做的事情爲例

00:20:32.366 --> 00:20:34.968 
這個特殊的貝塞爾曲線
如果給它個名字

00:20:35.035 --> 00:20:36.737 
就叫“快進 快出”

00:20:37.004 --> 00:20:40.974 
你一定會欣喜若狂 當你看到想要用來
創建時間函數的貝塞爾曲線

00:20:47.581 --> 00:20:52.119 
我們已經爲你們提供了更多方法
去做比如彈跳這樣的動畫

00:20:52.219 --> 00:20:56.657 
而且再來想一下我們認爲
彈跳現在會影響時間

00:20:56.924 --> 00:21:01.128 
如果創建UISpringTimingParameter對象時
不設定引值

00:21:01.195 --> 00:21:03.864 
你會獲得一個臨界阻尼的彈跳動畫

00:21:03.931 --> 00:21:05.432 
這是很多人想要的動畫

00:21:05.699 --> 00:21:10.938 
比如我們就會用這個動畫
在導航控制上進行推入或調出

00:21:16.476 --> 00:21:22.482 
第二個變量很像現有的
UIKit彈跳動畫應用編程接口

00:21:22.549 --> 00:21:25.052 
但是還是點小區別
我馬上就會講到

00:21:25.919 --> 00:21:27.120 
但在講這個之前

00:21:27.521 --> 00:21:30.290 
我們以爲你打開了一個彈跳方程

00:21:30.357 --> 00:21:33.560 
你可以定義任何你想要的係數

00:21:33.627 --> 00:21:36.830 
我們也會切實重視這些係數

00:21:37.364 --> 00:21:38.565 
但這裏有個問題

00:21:38.632 --> 00:21:44.104 
就是你定義的時長
被忽略了

00:21:44.171 --> 00:21:48.041 
我們對這個時長的計算是根據
彈跳方程的解法

00:21:48.275 --> 00:21:49.810 
舉這樣一個例子

00:21:53.680 --> 00:21:54.948 
我說過他們之間有區別

00:21:55.015 --> 00:21:58.252 
你會發現初始的速率
現在變成了矢量

00:21:58.418 --> 00:21:59.720 
而不是標量

00:22:00.721 --> 00:22:02.890 
很多時候我們不會注意

00:22:02.956 --> 00:22:04.958 
這個矢量的y分量

00:22:05.359 --> 00:22:09.563 
但是如果你在視圖中心做動畫

00:22:09.863 --> 00:22:14.034 
那麼這個矢量的x和y分量
必須都要注意

00:22:14.101 --> 00:22:16.904 
原因就用這個應用程序實例說明

00:22:17.304 --> 00:22:19.740 
我們將正這個方形拖離中心

00:22:20.073 --> 00:22:22.276 
並在鬆手的時候要讓它

00:22:22.342 --> 00:22:24.845 
根據手勢的速率
彈回中心

00:22:25.779 --> 00:22:31.418 
直至現在這個速率
始終沿着一條線

00:22:31.485 --> 00:22:34.888 
就是兩個正方形之間的連線
這不是件好事

00:22:34.955 --> 00:22:39.026 
因爲我的手勢可能
在平面的任何地方結束

00:22:39.092 --> 00:22:42.062 
而我們事實上並沒有
實際考慮到這一點

00:22:42.996 --> 00:22:44.431 
但現在我們想到了

00:22:44.498 --> 00:22:46.166 
所以我們來看一下這個小視頻

00:22:46.233 --> 00:22:50.504 
展示了我們現在是怎樣
讓正方形彈回中心

00:22:50.571 --> 00:22:54.508 
並將二維矢量位置都考慮在內

00:22:54.741 --> 00:22:56.243 
你會看到
在我們開始做時

00:22:56.310 --> 00:22:58.645 
會同時考慮到
x和y分量

00:22:58.912 --> 00:22:59.913 
這很簡單

00:23:06.954 --> 00:23:08.856 
現在我們有了這個
很好的屬性動畫

00:23:08.922 --> 00:23:09.957 
那麼如何呢？

00:23:10.190 --> 00:23:13.961 
我想要利用它實現
自定義視圖控制器轉換

00:23:14.027 --> 00:23:16.330 
而且我希望它們也是可中斷的

00:23:17.331 --> 00:23:21.335 
三年前
我就此做了一整場演講

00:23:21.401 --> 00:23:23.036 
所以它的確有些複雜

00:23:23.103 --> 00:23:26.573 
如果你不熟悉自定義視圖控制器轉換

00:23:26.640 --> 00:23:28.408 
請參考之前的演講

00:23:28.475 --> 00:23:32.579 
但我會快速地概述一下
打個基礎

00:23:32.646 --> 00:23:34.982 
準備講解我們如何拓展這些協議

00:23:35.182 --> 00:23:39.019 
視圖控制器轉換一般是
一組連鎖協議

00:23:39.086 --> 00:23:43.524 
其中兩個包括
交互轉換和動畫轉換

00:23:43.590 --> 00:23:46.894 
他們是你創建對象時
需要符合的協議

00:23:47.427 --> 00:23:49.563 
好吧 是你創建的對象
要符合的協議

00:23:50.664 --> 00:23:53.767 
系統會創建另一個對象並傳遞給

00:23:53.834 --> 00:23:57.171 
該協議的方法

00:23:57.237 --> 00:23:58.772 
這個稍後我們會講清楚

00:23:59.473 --> 00:24:01.375 
但是要記得我們爲什麼想這麼做

00:24:01.441 --> 00:24:04.545 
假設你有一個應用程序
帶導航控制器

00:24:06.180 --> 00:24:08.215 
而且pop看上去挺正常

00:24:08.282 --> 00:24:11.852 
它是個不錯的
臨界阻尼彈跳動畫

00:24:12.219 --> 00:24:14.321 
但是你的應用
需要點不一樣的東西

00:24:14.655 --> 00:24:18.559 
它需要的是
完全不一樣的外觀

00:24:18.625 --> 00:24:22.362 
它可以爆炸式彈出
或許下面還帶模糊效果

00:24:22.829 --> 00:24:25.699 
這就是自定義視圖控制器轉換
讓你能做到的事情

00:24:25.832 --> 00:24:29.303 
而且它還可以讓你的編寫
和驅動更有交互性

00:24:30.504 --> 00:24:33.407 
要得到這些符合協議的對象

00:24:33.473 --> 00:24:35.375 
只需要通過一個代理

00:24:35.475 --> 00:24:37.678 
它可以是導航控制器代理

00:24:37.744 --> 00:24:40.514 
也可以是視圖控制器的轉換代理

00:24:41.381 --> 00:24:42.916 
我們要問這個代理

00:24:42.983 --> 00:24:45.953 
“你是否都有符合動畫轉換的對象

00:24:46.019 --> 00:24:49.022 
可以在任何時候顯示
推入或者彈出？”

00:24:49.590 --> 00:24:53.227 
如果有 我們將
繞過內置轉換

00:24:53.594 --> 00:24:56.563 
我們要創建其中一個
轉換context對象

00:24:56.630 --> 00:24:58.599 
它可以給你所有你需要的信息

00:24:58.665 --> 00:25:00.868 
去實現轉場動畫

00:25:01.101 --> 00:25:05.205 
我們會命令animateTransition
將context傳遞給你"

00:25:07.040 --> 00:25:08.475 
那如何讓這個流程可中斷？

00:25:08.976 --> 00:25:14.748 
我們所做的是添加了新的方法
叫interruptibleAnimator(using

00:25:15.082 --> 00:25:18.151 
如果要執行它
你需要返回一個對象

00:25:18.218 --> 00:25:20.954 
符合UIViewImplicitlyAnimating

00:25:21.021 --> 00:25:23.357 
他可以是一個UIViewPropertyAnimator

00:25:23.657 --> 00:25:24.858 
但不是必須的

00:25:24.925 --> 00:25:28.095 
它也可以是另一種動畫

00:25:28.161 --> 00:25:34.001 
即你的執行可以根據UIKit動態
或者其他動畫策略

00:25:36.670 --> 00:25:41.675 
如果你不執行交互控制器

00:25:42.409 --> 00:25:44.778 
意思是你只執行了
自定義動畫控制器

00:25:44.845 --> 00:25:46.980 
那麼你需要執行
animateTransition

00:25:47.047 --> 00:25:50.918 
這個十分簡單
只要你用這個方法

00:25:50.984 --> 00:25:54.188 
你只要接收可中斷的
animator然後返回值

00:25:54.621 --> 00:25:56.290 
然後只要給一個開始命令

00:25:56.623 --> 00:25:59.726 
這就是執行animateTransition的所有步驟了

00:26:01.461 --> 00:26:05.032 
但是我們建議你使用交互控制器

00:26:05.098 --> 00:26:06.800 
如果你想讓它變成可中斷

00:26:07.434 --> 00:26:11.972 
重申一下首要的事
就是要符合

00:26:12.172 --> 00:26:15.876 
是說返回的對象要符合
轉場動畫的協議

00:26:15.943 --> 00:26:19.646 
然後我們會要你提供一個
符合交互轉場的對象

00:26:19.713 --> 00:26:22.716 
並且會傳遞
之前返回給我們的對象

00:26:22.783 --> 00:26:24.952 
是作爲一個參數來傳遞

00:26:26.086 --> 00:26:29.489 
很多時候
你希望這個交互控制器

00:26:29.556 --> 00:26:32.860 
可以真正驅動動畫控制器

00:26:36.096 --> 00:26:38.899 
若是如此 我們就不用調出
animateTransition

00:26:38.966 --> 00:26:41.134 
而是調出
startInteractiveTransition

00:26:41.201 --> 00:26:42.936 
傳遞的context是完全一樣

00:26:43.003 --> 00:26:45.305 
用animateTransition也是這樣

00:26:47.941 --> 00:26:50.577 
我們會提供一個具體的類
你可以直接使用

00:26:50.644 --> 00:26:52.513 
這樣操作起來就十分簡單

00:26:53.914 --> 00:26:57.050 
在此之前還有一個限制

00:26:57.117 --> 00:27:00.721 
若要執行UIPercentDriven
InteractiveTransition

00:27:00.787 --> 00:27:04.157 
那麼animateTransition方法

00:27:04.224 --> 00:27:07.661 
在動畫控制器中的執行就要按照

00:27:07.728 --> 00:27:10.564 
現有的UIKit動畫應用編程接口執行

00:27:11.498 --> 00:27:14.868 
但是現在有了可中斷的animator

00:27:14.935 --> 00:27:18.238 
UIPercentDriven InteractiveTransition
根本就不需要在意這個接口

00:27:18.305 --> 00:27:23.944 
只要使用
UIViewImplicitlyAnimating定義的協議

00:27:24.077 --> 00:27:25.646 
就這些了

00:27:25.712 --> 00:27:27.948 
這樣你就可以真正創造一個
全然不同的動畫

00:27:28.015 --> 00:27:30.918 
由UIPercentDriven
I交互轉場驅動

00:27:31.451 --> 00:27:32.452 
這是不是很酷

00:27:34.021 --> 00:27:36.423 
假設你已經有了一個這樣的動畫

00:27:36.490 --> 00:27:37.891 
也有了一個自定義轉場

00:27:37.958 --> 00:27:38.992 
如何將他們合併呢？

00:27:39.426 --> 00:27:41.828 
一種方法從表面上來講

00:27:41.895 --> 00:27:46.233 
將animateTransition方法
重命名爲myAnimateTransition

00:27:46.300 --> 00:27:49.303 
再用同樣的方法
創建可中斷的animator

00:27:49.636 --> 00:27:52.873 
你就只要添加這個任務方法到

00:27:54.208 --> 00:27:56.276 
animator中
一個動畫上就可以了

00:27:56.643 --> 00:27:57.711 
這不難

00:28:00.314 --> 00:28:04.685 
我們的確要拓展
協議中的某些對象

00:28:04.751 --> 00:28:09.056 
比如現在的context轉場中就添加了
pauseInteractiveTransition

00:28:09.423 --> 00:28:13.193 
現在這就是進入交互狀態的方法

00:28:13.493 --> 00:28:17.998 
在這之前要先啓動交互
並關閉非交互式

00:28:18.098 --> 00:28:19.700 
現在你就可以來回移動了

00:28:19.766 --> 00:28:25.205 
移動要通過調用pauseInteractive
結束或取消也一樣

00:28:27.174 --> 00:28:30.377 
同樣isInteractive屬性
以及

00:28:30.444 --> 00:28:34.047 
transitionWasCancelled
就可以隨着你的前後移動

00:28:34.114 --> 00:28:37.784 
在交互和非交互中切換

00:28:40.053 --> 00:28:42.990 
我們添加了一個變量
叫wantsInteractiveStart

00:28:43.056 --> 00:28:44.925 
既然已經可以前後移動

00:28:45.459 --> 00:28:49.630 
那你也許想要交互控制器
從非交互式出發

00:28:49.863 --> 00:28:52.232 
此變量就控制這一行爲

00:28:54.902 --> 00:29:00.140 
最後我們更新
UIPercentDriven交互轉場

00:29:01.308 --> 00:29:02.342 
這有幾點規定

00:29:02.409 --> 00:29:05.078 
如果執行InterruptibleAnimator

00:29:05.212 --> 00:29:07.781 
我們希望它能真正有用

00:29:08.048 --> 00:29:09.650 
就是說不做其他事情

00:29:09.716 --> 00:29:11.084 
系統可能會很不高興

00:29:11.451 --> 00:29:13.053 
我們會始終調用
animateTransition

00:29:13.120 --> 00:29:15.088 
並最先啓動startInteractiveTransition

00:29:15.389 --> 00:29:17.391 
這樣就有很大的空間

00:29:17.457 --> 00:29:20.727 
去創建可中斷的animator
因爲它將在

00:29:20.794 --> 00:29:23.163 
之後編寫中被重複調出
用同樣的context

00:29:23.230 --> 00:29:28.168 
我們也希望返回值能
一直是同一個

00:29:28.769 --> 00:29:32.272 
最後animator的時長
可以涵蓋整個轉場時長

00:29:32.439 --> 00:29:36.343 
在整個轉場結束之前
它必須處於活動狀態

00:29:37.244 --> 00:29:40.981 
現在請Mike上臺爲大家展示
如何在應用程序中使用應用編程接口

00:29:42.783 --> 00:29:44.017 
沒給你留多少時間

00:29:48.589 --> 00:29:49.756 
謝謝你 Bruce

00:29:52.926 --> 00:29:53.794 
不客氣

00:29:55.429 --> 00:29:57.664 
首先來看這個演示應用

00:29:58.198 --> 00:30:02.603 
這個應用使用UIViewPropertyAnimator

00:30:02.669 --> 00:30:05.572 
和UIViewController
轉場的添加函數

00:30:06.907 --> 00:30:10.143 
在基本應用中創建
完美的可中斷自定義轉場

00:30:10.410 --> 00:30:13.814 
第一 應用要使用UINavigationController

00:30:14.348 --> 00:30:15.916 
並且內置有一個集合視圖控制器

00:30:15.983 --> 00:30:17.951 
這是個照片格子
可以拉動瀏覽

00:30:18.519 --> 00:30:19.820 
當我們點擊其中一張照片

00:30:20.120 --> 00:30:22.422 
它會推進導航棧上
其他視圖控制器

00:30:23.123 --> 00:30:26.059 
讓你的圖片視圖
更加清晰具體

00:30:26.126 --> 00:30:28.595 
如果我們點擊返回鍵
這個視圖就彈回導航棧

00:30:28.962 --> 00:30:31.965 
另外我們可以滑動屏幕
從左向右

00:30:32.332 --> 00:30:34.201 
實現交互轉場返回

00:30:34.268 --> 00:30:37.704 
這些在UINavigationController基本都免費

00:30:38.539 --> 00:30:41.842 
就像Bruce剛纔所說
我們還有很多套應用編程接口

00:30:41.909 --> 00:30:43.911 
能讓你自定義轉場

00:30:44.178 --> 00:30:45.946 
如果我們想放大照片

00:30:46.013 --> 00:30:49.316 
讓他鋪滿頁面
我們也可以做到 這很酷

00:30:49.383 --> 00:30:51.418 
點擊返回鍵
照片就縮小回去

00:30:51.818 --> 00:30:53.320 
這些在此之前都只是設想

00:30:53.820 --> 00:30:56.023 
另外你也可以向下拖拽

00:30:56.089 --> 00:30:58.926 
來啓動交互轉場
再轉動幾下

00:30:59.092 --> 00:31:01.128 
讓整個動作以動畫方式完成

00:31:01.762 --> 00:31:03.964 
我想向你們展示的是
我們如何做到這樣

00:31:04.031 --> 00:31:05.732 
通過使用UIViewPropertyAnimator

00:31:12.739 --> 00:31:15.409 
首先你做的就是告訴系統

00:31:15.475 --> 00:31:16.910 
這裏應該說是導航控制器

00:31:17.110 --> 00:31:19.913 
你要提供一個自定義轉場

00:31:19.980 --> 00:31:22.716 
那麼這裏我們就要符合
導航控制器的代理

00:31:23.050 --> 00:31:25.519 
通過AssetTransitionController來實現

00:31:25.586 --> 00:31:29.790 
這是我們創建的對象
可以執行這些轉場協議

00:31:30.490 --> 00:31:32.626 
這裏我們要注意
兩種十分重要的方法

00:31:32.693 --> 00:31:34.962 
第一個是調出動畫控制器

00:31:35.395 --> 00:31:37.464 
通過一個特定操作
推入或彈出

00:31:37.664 --> 00:31:40.067 
我們要保存該操作
然後返回值給自己

00:31:40.133 --> 00:31:41.635 
因爲我們就是動畫控制器

00:31:42.469 --> 00:31:44.938 
然後當我們將對象
從那個接口返回後

00:31:45.205 --> 00:31:47.407 
系統將調出一個交互控制器

00:31:48.041 --> 00:31:50.077 
在這裏我們還是返回值給自己

00:31:50.143 --> 00:31:51.912 
因爲我們也要扮演交互控制器

00:31:52.212 --> 00:31:54.581 
完成之後
系統就會知道

00:31:54.648 --> 00:31:55.916 
這裏會有一個交互轉場

00:31:56.717 --> 00:32:00.354 
現在來看一下UIViewController
InteractiveTransitioning

00:32:01.221 --> 00:32:04.358 
這裏系統會調出
startInteractiveTransition

00:32:04.424 --> 00:32:06.660 
並以轉場context調出
我們的對象

00:32:06.727 --> 00:32:08.295 
這會包含所有有關信息

00:32:08.362 --> 00:32:11.164 
對於我們開始自定義轉場十分必要

00:32:12.132 --> 00:32:14.268 
這裏我們將創建一個輔助對象

00:32:14.334 --> 00:32:16.703 
一會兒我們會看到更多

00:32:16.937 --> 00:32:21.275 
這個對象將會
創建我們的轉場動畫

00:32:21.341 --> 00:32:24.411 
我們要將context傳遞給
我們之前所保存的操作

00:32:24.478 --> 00:32:28.348 
同時也要傳給panGestureRecognizer
就是之前用於啓動交互轉場的程序

00:32:28.849 --> 00:32:32.319 
IOS10允許交互轉場

00:32:32.386 --> 00:32:35.656 
分兩個進程開始
動畫進程和交互進程

00:32:35.923 --> 00:32:38.192 
若從panGestureRecognizer開始

00:32:38.258 --> 00:32:41.161 
就要設initiallyInteractive變量

00:32:41.228 --> 00:32:42.963 
爲真
以便系統知道

00:32:43.030 --> 00:32:45.832 
我們正在開始這個交互轉場

00:32:48.001 --> 00:32:51.471 
下面看一下動畫轉場的執行

00:32:51.738 --> 00:32:54.842 
這裏我們不太在意
動畫方法

00:32:54.908 --> 00:32:57.611 
就像布魯斯提到那樣
我們使用的是交互控制器

00:32:57.678 --> 00:32:59.580 
它會調出startInteractiveTransition

00:32:59.646 --> 00:33:01.648 
相對於animateTransition

00:33:01.715 --> 00:33:04.751 
但iOS10裏
新的可中斷動畫接口

00:33:04.818 --> 00:33:06.286 
纔是我們真正的興趣所在

00:33:06.753 --> 00:33:07.921 
這裏是我們的輔助對象

00:33:07.988 --> 00:33:11.625 
一會兒會看到它創建了一個
UIViewPropertyAnimator

00:33:11.692 --> 00:33:13.460 
並且將它的值返回了系統

00:33:13.827 --> 00:33:17.364 
所以這裏就是系統
添加任何並列動畫的地方

00:33:17.431 --> 00:33:20.767 
在這個演示中你會看到
頂部的導航條

00:33:20.834 --> 00:33:22.402 
跟着我們的轉場一起在動

00:33:22.469 --> 00:33:26.406 
系統會利用這個animator
來添加這些動畫

00:33:27.040 --> 00:33:29.877 
現在看看轉場驅動
輔助對象有多快

00:33:31.545 --> 00:33:35.382 
在此 startInteractiveTransition
初始化了這個對象

00:33:36.783 --> 00:33:39.019 
這就會聯通
抱歉

00:33:40.387 --> 00:33:41.288 
是這裏

00:33:41.355 --> 00:33:44.024 
這就可以聯通這個輔助方法

00:33:44.091 --> 00:33:45.759 
和一些動畫
然後它會設定一些

00:33:45.826 --> 00:33:47.995 
背景動畫給這個轉場

00:33:48.662 --> 00:33:50.163 
視覺效果就是動態的

00:33:50.230 --> 00:33:52.399 
這兩個視圖控制器和alpha
也是動態的

00:33:52.699 --> 00:33:56.603 
我們稍後再講
圖片邊框切換

00:33:57.037 --> 00:34:00.274 
它會傳遞完成關閉指令
也會幫助清理

00:34:00.340 --> 00:34:01.542 
一些背景視圖

00:34:01.608 --> 00:34:04.144 
但是這裏的重點是
我們如何創建這個屬性動畫

00:34:04.211 --> 00:34:06.780 
並返回到interruptibleAnimator接口

00:34:07.114 --> 00:34:09.516 
首先我們從輔助函數中
獲得一個轉場時長

00:34:09.583 --> 00:34:11.150 
我們也是過會兒再看這個

00:34:11.485 --> 00:34:13.954 
創建PropertyAnimator
並選擇時長

00:34:14.021 --> 00:34:15.322 
以及easeOut曲線

00:34:15.621 --> 00:34:18.025 
我們會在收到的動畫間傳遞

00:34:18.692 --> 00:34:20.327 
並在這裏創建一個完成處理

00:34:21.061 --> 00:34:23.730 
然後調出這些傳給我們的
完成命令

00:34:23.797 --> 00:34:25.299 
重要的是我們要調出

00:34:25.364 --> 00:34:28.001 
轉場context
在動畫結束時

00:34:28.368 --> 00:34:31.103 
告訴系統
“嘿 我們的轉場完成了”

00:34:31.505 --> 00:34:33.206 
然後到了...

00:34:33.273 --> 00:34:34.141 
抱歉

00:34:34.208 --> 00:34:36.777 
completionTransition接口有一個博爾值

00:34:37.710 --> 00:34:39.847 
讓我們可以得到
應該傳遞的值

00:34:39.913 --> 00:34:42.382 
所以從這個接口傳遞“yes”

00:34:42.449 --> 00:34:43.951 
這就意味着
我們要結束這個轉場

00:34:44.016 --> 00:34:46.320 
如果傳遞“no”
意思就是取消轉場

00:34:47.221 --> 00:34:52.492 
在我接着講轉場動畫
輔助對象之前

00:34:52.826 --> 00:34:54.895 
我想再展示這個演示應用的
一些其他特點

00:34:54.962 --> 00:34:57.931 
都由UIViewPropertyAnimator實現

00:35:02.302 --> 00:35:06.273 
回到演示應用
我之前展示瞭如何放大圖片

00:35:06.340 --> 00:35:08.942 
和通過點擊返回鍵縮小屏幕

00:35:09.009 --> 00:35:11.812 
但我沒有展示
你可以在半空中暫停

00:35:12.379 --> 00:35:14.882 
現在我們正在動畫進程
但是暫停動畫

00:35:15.048 --> 00:35:16.650 
然後進入交互進程

00:35:16.984 --> 00:35:19.186 
這樣與照片的交互
就在轉場中途開始

00:35:19.253 --> 00:35:21.588 
當我們鬆開手
動畫會繼續

00:35:21.655 --> 00:35:22.656 
然後可以再次中斷

00:35:22.723 --> 00:35:25.893 
這樣我們可以自由來回
往返於動畫進程

00:35:25.993 --> 00:35:28.061 
和交互進程之間

00:35:28.295 --> 00:35:29.329 
這真的很炫

00:35:30.964 --> 00:35:33.634 
在返回代碼
告訴你我們如何做到之前

00:35:33.700 --> 00:35:35.002 
通過用新視圖控制器接口

00:35:35.502 --> 00:35:38.305 
我想用具體的場景來幫助大家

00:35:38.372 --> 00:35:40.107 
理解這些代碼是做什麼的

00:35:40.407 --> 00:35:41.808 
假設我們正在開始

00:35:41.875 --> 00:35:43.944 
用panGestureRecognizer
向下拉動視圖

00:35:44.011 --> 00:35:45.712 
從而開始一個交互式轉場

00:35:46.346 --> 00:35:48.081 
然後我們從屏幕上拿起手指

00:35:48.148 --> 00:35:50.584 
開始動畫進程
在動畫播放時

00:35:50.684 --> 00:35:53.820 
我們在中途暫停
然後再次回到動畫

00:35:53.887 --> 00:35:56.256 
然後取消轉場
直接向上拉回

00:35:56.823 --> 00:35:58.926 
這就是我要描述的場景

00:35:58.992 --> 00:36:00.360 
對照下面這段代碼

00:36:04.731 --> 00:36:08.468 
我將這個示例應用分成了四個方法

00:36:09.036 --> 00:36:12.039 
updateInteraction
是手勢識別處理

00:36:12.105 --> 00:36:14.808 
用來更新交互轉場

00:36:15.108 --> 00:36:16.310 
當擡起手指

00:36:16.376 --> 00:36:18.278 
調出endInteraction函數

00:36:18.979 --> 00:36:21.014 
然後調出動畫函數添加動畫

00:36:21.081 --> 00:36:22.583 
在開始或者結束位置

00:36:23.250 --> 00:36:25.152 
然後當我們中斷動畫

00:36:25.219 --> 00:36:26.887 
最後調出pauseAnimation

00:36:26.954 --> 00:36:31.491 
這個可以在轉場時長中
多次循環

00:36:31.558 --> 00:36:33.060 
想做多少次都可以

00:36:33.160 --> 00:36:35.128 
這裏我們只做了兩次

00:36:36.063 --> 00:36:37.965 
然後是
updateInteraction

00:36:38.031 --> 00:36:39.766 
這是手勢識別處理

00:36:39.967 --> 00:36:43.370 
當它調出
“狀態開始”或者“狀態改變”時

00:36:43.437 --> 00:36:45.873 
我們會看到手勢識別的翻譯

00:36:45.939 --> 00:36:48.976 
我們就會用這個去計算
要添加的進程步驟

00:36:49.042 --> 00:36:51.411 
把他們作爲fractionComplete
添加到轉場動畫

00:36:52.412 --> 00:36:54.681 
之後要在背景中
擦除這些動畫

00:36:54.748 --> 00:36:57.985 
就像chrome導航條的
背景視覺效果

00:36:58.051 --> 00:36:59.019 
這個很簡單

00:36:59.086 --> 00:37:01.255 
就跟在轉場動畫裏
設定fractionComplete一樣

00:37:01.321 --> 00:37:04.825 
這就可以基本免費
擦除所有動畫

00:37:05.526 --> 00:37:07.227 
再調出transitionContext

00:37:07.294 --> 00:37:09.530 
來更新交互轉場percentComplete

00:37:10.330 --> 00:37:12.766 
最後我們的圖片
就可以在屏幕上移動了

00:37:12.933 --> 00:37:15.002 
當處於轉場的
交互進程時

00:37:15.068 --> 00:37:17.104 
我們要手動設定邊框

00:37:17.171 --> 00:37:18.906 
因此我們要做一個小的輔助函數

00:37:20.174 --> 00:37:23.310 
最後我們重新設定
這個手勢識別的翻譯

00:37:23.744 --> 00:37:26.580 
當我們收到指令時
手指離開屏幕

00:37:26.647 --> 00:37:30.484 
手勢識別會出現“狀態結束”
然後調出endInteraction

00:37:31.118 --> 00:37:32.819 
研究endInteraction時

00:37:32.886 --> 00:37:35.722 
第一隻看我們的轉場context
是否是交互的

00:37:35.789 --> 00:37:38.959 
我們要保證它是在我們
離開交互進程之前完成

00:37:39.593 --> 00:37:41.028 
然後調出小輔助函數

00:37:41.094 --> 00:37:42.829 
它告訴我們
這個完成是在

00:37:42.896 --> 00:37:45.599 
動畫的開始位置
或者結束位置

00:37:46.066 --> 00:37:47.634 
如果在結束位置完成

00:37:47.701 --> 00:37:49.236 
調出context以表明

00:37:49.303 --> 00:37:51.505 
“嘿 交互轉場在這裏結束

00:37:51.772 --> 00:37:53.240 
我們要進入動畫進程了”

00:37:53.807 --> 00:37:55.709 
如果在開始位置完成

00:37:55.776 --> 00:37:57.711 
意思就是我們取消了這個交互進程

00:37:57.778 --> 00:37:59.346 
將要進入動畫進程

00:37:59.646 --> 00:38:00.581 
然後只要做動畫就好

00:38:00.914 --> 00:38:02.749 
現在來看動畫方法

00:38:04.351 --> 00:38:07.521 
之前我告訴你們
轉場動畫轉換的是

00:38:07.588 --> 00:38:10.791 
背景chrome和alpha通道

00:38:11.291 --> 00:38:13.594 
但這裏我們要創建一個
二級propertyAnimator

00:38:13.660 --> 00:38:15.696 
我們要使用它來繪製邊框動畫

00:38:15.762 --> 00:38:17.531 
讓圖片可以在屏幕上移動

00:38:17.598 --> 00:38:20.300 
我們之所以這麼做
是希望有些動畫

00:38:20.367 --> 00:38:23.804 
能有不一樣的時間函數
相較於背景動畫而言

00:38:23.937 --> 00:38:25.405 
一會兒就來講看這個

00:38:25.472 --> 00:38:27.474 
這裏我們要做的只是插入動畫

00:38:27.875 --> 00:38:30.043 
具體定義結束位置

00:38:30.110 --> 00:38:33.046 
或者只是定義目標
或者是圖片的初始邊框

00:38:33.380 --> 00:38:35.182 
隨後開始這個屬性動畫

00:38:35.249 --> 00:38:36.250 
並實時記錄

00:38:36.817 --> 00:38:38.919 
要記住我們還有一個轉場動畫

00:38:38.986 --> 00:38:42.756 
時長與我們之前返回系統的
轉場時長一樣

00:38:43.423 --> 00:38:46.393 
我們只要確保
這個動畫的方向是正確的

00:38:46.460 --> 00:38:48.795 
如果我們定義一個toPosition值爲“開始”

00:38:48.862 --> 00:38:50.597 
我們需要推翻該animator

00:38:51.398 --> 00:38:55.736 
最後 如果這是第一次
聯通這個動畫

00:38:55.802 --> 00:38:58.539 
轉場動畫就會處於
非活動狀態

00:38:58.739 --> 00:39:00.841 
所以我們要做的就是
開始這個轉場動畫

00:39:00.908 --> 00:39:02.509 
然後就進入動畫進程

00:39:03.577 --> 00:39:06.647 
另外 如果程序開始後
又暫停了

00:39:06.947 --> 00:39:08.148 
我們要用不一樣的東西

00:39:08.582 --> 00:39:10.350 
調出continueAnimation

00:39:11.018 --> 00:39:13.587 
withTimingParameters和durationFactor

00:39:13.654 --> 00:39:17.157 
continueAnimation
讓你可以暫停一個動畫

00:39:17.224 --> 00:39:19.793 
根據不同時間參數
和不同的時長

00:39:19.860 --> 00:39:21.295 
和剩餘時長
隨你喜好

00:39:21.628 --> 00:39:22.829 
這裏要傳遞“nil”

00:39:22.896 --> 00:39:25.098 
表示我們要用的時間參數

00:39:25.165 --> 00:39:27.768 
是在初始化這個轉場動畫時
就已經輸入過的

00:39:28.068 --> 00:39:32.139 
但是我們需要改變
後續動畫的durationFactor

00:39:32.206 --> 00:39:34.541 
這使得我們能使時長同步

00:39:34.608 --> 00:39:37.010 
讓新創建的itemFrameAnimator時長

00:39:37.077 --> 00:39:39.880 
與這個轉場動畫的剩餘時長一致

00:39:40.180 --> 00:39:42.082 
durationFactor
從而定義爲

00:39:42.149 --> 00:39:46.186 
1.0等同於之前設定的初始時長

00:39:46.253 --> 00:39:47.955 
在創建轉場動畫時

00:39:48.589 --> 00:39:51.325 
這就是開始動畫進程
要做的所有事情

00:39:51.391 --> 00:39:52.593 
循環的最後一步

00:39:52.659 --> 00:39:54.795 
看一下pauseAnimation

00:39:54.928 --> 00:39:58.465 
這發生在動畫進程中
但是暫停了

00:39:58.532 --> 00:40:00.200 
把手指放在圖片視圖下方

00:40:00.267 --> 00:40:03.670 
然後只要設置一個手勢識別
在這個示例應用中的圖片視圖

00:40:03.904 --> 00:40:05.239 
現在這都是免費的了

00:40:05.305 --> 00:40:09.009 
因爲UIViewPropertyAnimator會
自動點擊測試動畫視圖

00:40:09.910 --> 00:40:12.579 
在剛剛創建的itemFrameAnimator裏

00:40:12.646 --> 00:40:15.849 
我們要完全停止這個動畫
就要設參數值爲“真”

00:40:15.916 --> 00:40:20.521 
告訴系統我們不想
再繼續此動畫

00:40:20.587 --> 00:40:22.823 
而且我們要直接寫模態值

00:40:24.157 --> 00:40:27.127 
應該是顯示值直接返回模式

00:40:27.628 --> 00:40:31.164 
之後回到轉場動畫
調出pauseAnimation

00:40:31.231 --> 00:40:34.501 
就像updateInteraction裏
看到的一樣 我們會擦除動畫

00:40:34.568 --> 00:40:36.036 
在我們與圖片互動的時候

00:40:36.336 --> 00:40:38.672 
最後我們會告訴
轉場context

00:40:38.739 --> 00:40:43.510 
我們要離開動畫進程
回到交互進程

00:40:44.578 --> 00:40:46.880 
我再給大家展示另一個
技能和訣竅

00:40:47.748 --> 00:40:49.483 
也是這個演示應用的一個小細節

00:40:51.652 --> 00:40:56.156 
我們看到現在這個時間很慢
這是出於展示的目的

00:40:57.057 --> 00:40:59.426 
但你可能想要
更自然的感覺

00:40:59.493 --> 00:41:01.161 
再更生動一點

00:41:01.795 --> 00:41:04.698 
所以如果我們要
更改彈跳的時間

00:41:04.798 --> 00:41:06.366 
讓它跳出頁面

00:41:06.667 --> 00:41:09.570 
而且只讓圖片跳出頁面

00:41:09.636 --> 00:41:11.538 
而這些背景動畫還是繼續

00:41:11.605 --> 00:41:13.941 
按照我們定義的
easeOut曲線運行

00:41:14.608 --> 00:41:16.577 
其實我們可以實現這個變化

00:41:16.643 --> 00:41:19.813 
讓視覺更加生動
只用一行代碼就可以

00:41:19.880 --> 00:41:21.448 
而且在非中斷時
還可以繼續互動

00:41:21.515 --> 00:41:23.217 
那麼快速看一下這行代碼

00:41:27.487 --> 00:41:28.856 
回到演示應用

00:41:28.922 --> 00:41:31.592 
看看propertyAnimator的方便方法

00:41:31.959 --> 00:41:34.528 
注意我們正在定義
一個屬性動畫

00:41:34.595 --> 00:41:36.630 
其時間參數在這裏爲線性

00:41:36.964 --> 00:41:39.066 
這也就是爲什麼感覺
動畫很機械

00:41:39.533 --> 00:41:41.401 
我的一個同事留下了這個
偉大的註釋

00:41:41.468 --> 00:41:44.104 
來定義某些SpringTimingParameters

00:41:44.171 --> 00:41:48.675 
並使用大規模數據 強度
阻尼和初始速率

00:41:48.742 --> 00:41:50.677 
這樣就完整的定義了這個彈跳

00:41:51.178 --> 00:41:53.614 
當在創建
propertyAnimator

00:41:53.680 --> 00:41:56.483 
我們正在傳遞的時長
其實並不使用

00:41:56.750 --> 00:41:58.619 
而是會被計算

00:41:58.685 --> 00:42:00.821 
根據我們在彈跳時間中
所提供的屬性

00:42:01.421 --> 00:42:05.425 
因此我們需要有一個
動畫時長輔助函數

00:42:05.492 --> 00:42:08.161 
它只用propertyAnimator應用程序接口

00:42:08.228 --> 00:42:11.598 
就是下面這個
來計算時長

00:42:11.665 --> 00:42:13.934 
基本上它就爲我們
解開了這個彈跳方程

00:42:14.001 --> 00:42:17.371 
我們可以用這個去匹配
轉場動畫的其他時長

00:42:18.372 --> 00:42:19.873 
這都超級簡單

00:42:19.940 --> 00:42:23.310 
這個代碼看上去
是有點複雜

00:42:23.377 --> 00:42:25.112 
但也確實只要
幾百行而已

00:42:25.312 --> 00:42:28.115 
UIViewPropertyAnimator
使一切成爲可能

00:42:28.415 --> 00:42:31.218 
就這樣
讓我們請回布魯斯

00:42:36.056 --> 00:42:36.924 
謝謝你 Mike

00:42:39.092 --> 00:42:39.960 
好的

00:42:40.661 --> 00:42:43.197 
我得講快點了
時間所剩無幾

00:42:44.932 --> 00:42:47.034 
我們要來講一點
點擊測試

00:42:48.836 --> 00:42:52.840 
假定UserInteractionEnabled
值爲真

00:42:52.906 --> 00:42:55.475 
我們實際上就可以
點擊測試我們的視圖

00:42:55.542 --> 00:42:58.212 
如果值爲“假”
我們將吃掉所有觸摸事件

00:42:58.745 --> 00:43:01.815 
我們將這個屬性叫做
isManualHitTestingEnabled

00:43:01.882 --> 00:43:03.217 
並定義爲“假”

00:43:03.650 --> 00:43:05.185 
默認值爲“假”的原因是

00:43:05.252 --> 00:43:08.922 
我們想能夠
點擊測試我們的視圖

00:43:09.189 --> 00:43:12.292 
如果值爲“真”
也就是現在的系統活動

00:43:12.459 --> 00:43:15.596 
當你要觸摸
這個視圖下面的位置

00:43:15.662 --> 00:43:17.297 
就會發現我們無法點擊測試

00:43:17.798 --> 00:43:21.802 
令人迷惑的是
好像只在它運動方向上開始點擊測試

00:43:22.069 --> 00:43:25.839 
我們不想要這樣的結果
尤其是對可中斷的屬性動畫

00:43:26.106 --> 00:43:29.142 
在這個演講下方
我想你們推薦

00:43:29.510 --> 00:43:32.746 
一個技能
讓你們可以重寫點擊測試

00:43:32.813 --> 00:43:35.749 
做一些計算來繞過
顯示層面

00:43:35.816 --> 00:43:39.286 
調令“super”
來點擊測試一個移動視圖

00:43:40.320 --> 00:43:41.822 
這個技術依然生效

00:43:41.889 --> 00:43:45.225 
但是現在有了propertyAnimators
如果你有移動視圖

00:43:45.292 --> 00:43:48.095 
默認的手動
點擊測試值爲假

00:43:48.161 --> 00:43:50.898 
我們實際上就在
點擊測試這個視圖

00:43:51.498 --> 00:43:53.667 
所以這很酷炫
也很輕鬆

00:43:53.734 --> 00:43:56.904 
事實上 這個舞臺上
我們看到的所有東西

00:43:56.970 --> 00:43:58.238 
之前都是好用的

00:43:58.805 --> 00:44:00.307 
現在出了些問題

00:44:00.374 --> 00:44:02.509 
如果你有深層的視圖層
或者其他

00:44:02.576 --> 00:44:04.244 
我們就無法正確運行

00:44:04.578 --> 00:44:08.949 
這時你可能就要用其他技術
可能在其他演講中有提過

00:44:10.250 --> 00:44:11.084 
好的

00:44:11.151 --> 00:44:14.321 
我們今天講了關鍵幀動畫
所用的整個應用程序接口

00:44:14.388 --> 00:44:16.590 
這是UIKit現在所有的接口

00:44:16.790 --> 00:44:18.592 
如果讓它可中斷？

00:44:18.825 --> 00:44:20.727 
要重調
關鍵幀動畫

00:44:20.794 --> 00:44:24.565 
作爲一個常用動畫
除非你定義一個路徑

00:44:24.631 --> 00:44:27.201 
來導入你想要的動畫

00:44:29.236 --> 00:44:31.471 
我們也想讓他們
變成可中斷的

00:44:32.439 --> 00:44:36.343 
事實上我們想要做的
跟現在視頻上看到的是一樣的

00:44:36.410 --> 00:44:37.845 
我們要暫停它 擦除它

00:44:38.245 --> 00:44:40.380 
這應該都是意料之中

00:44:40.447 --> 00:44:41.982 
而且 你可以做到

00:44:42.182 --> 00:44:43.383 
這很簡單

00:44:43.450 --> 00:44:45.252 
使用現有的接口

00:44:45.319 --> 00:44:50.190 
封裝動畫控制器的動畫

00:44:50.457 --> 00:44:54.194 
從而你的關鍵幀動畫
也是可中斷的了

00:44:58.732 --> 00:45:00.734 
我再說最後一點
雖然聽上去是在撒謊

00:45:01.268 --> 00:45:03.337 
互動PopGestureRecognizers

00:45:03.403 --> 00:45:05.906 
這是內置的導航彈出視圖

00:45:06.340 --> 00:45:08.876 
現在如果你有
一個交互控制器

00:45:09.443 --> 00:45:10.777 
你就無法使用這個

00:45:11.445 --> 00:45:14.948 
但是新的iOS 10裏
如果你輸入一個錯誤請求

00:45:15.048 --> 00:45:17.951 
給手勢識別或者你自己

00:45:18.318 --> 00:45:22.322 
那麼內置的彈出
手勢識別就可以識別了

00:45:22.389 --> 00:45:28.462 
使用內置導航轉場
要與你自定義的互動一起

00:45:30.964 --> 00:45:32.199 
總的來說

00:45:33.300 --> 00:45:37.471 
我們學習瞭如何使用UIViewPropertyAnimator
創建可中斷動畫

00:45:38.372 --> 00:45:42.075 
你可以用到很多全新的
時間函數

00:45:42.843 --> 00:45:45.746 
你可以使用可中斷的
propertyAnimators

00:45:45.812 --> 00:45:48.882 
去創建可中斷的
視圖控制器轉場

00:45:49.750 --> 00:45:52.319 
更多信息請瀏覽這個網址

00:45:52.753 --> 00:45:54.588 
這裏有其他有關UIKit的演講

00:45:54.655 --> 00:45:57.858 
他們講的是動畫的其他種類
其中兩個就在明天

00:45:57.925 --> 00:45:59.359 
我希望你們聽一聽 看一看

00:45:59.860 --> 00:46:00.827 
謝謝