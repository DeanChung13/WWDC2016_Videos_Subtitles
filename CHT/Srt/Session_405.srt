00:00:19.520 --> 00:00:21.221 
LLVM的新內容

00:00:29.630 --> 00:00:31.131 
大家好
我是Alex Rosenberg

00:00:31.198 --> 00:00:33.834 
我很興奮
能在此跟你們分享一些

00:00:33.901 --> 00:00:36.069 
Apple LLVM編譯器的新特性

00:00:36.803 --> 00:00:39.740 
但首先我想講一下LLVM

00:00:40.107 --> 00:00:43.110 
基於這個項目我們創建了
Apple LLVM編譯器

00:00:44.111 --> 00:00:48.482 
LLVM是一個模塊框架
用來建立編譯器和其他相關工具

00:00:49.149 --> 00:00:52.352 
但它的使用
不一定非要按照傳統方法

00:00:53.187 --> 00:00:55.222 
我們都瞭解並且喜愛Xcode

00:00:55.722 --> 00:00:58.292 
它使用了大量的
LLVM框架在裏面

00:00:59.826 --> 00:01:03.664 
這個很棒的新應用Swift
Playgrounds也加入了

00:01:04.063 --> 00:01:06.133 
也在內部使用LLVM

00:01:07.935 --> 00:01:10.771 
LLVM也是組成
Metal應用內部工作的一部分

00:01:10.838 --> 00:01:12.706 
以及其他繪圖應用編程接口

00:01:14.741 --> 00:01:16.243 
LVVM是開放資源

00:01:16.743 --> 00:01:20.280 
Apple長期以來一直
堅持開放編譯器和語言資源

00:01:20.881 --> 00:01:24.218 
Swift語言就誕生於
LLVM工程

00:01:24.818 --> 00:01:27.921 
我們很高興你們
還有所有的貢獻者

00:01:28.355 --> 00:01:31.892 
能推動Swift在
Swift.org的進化中不斷髮展

00:01:32.860 --> 00:01:35.729 
這個進程
和Swift的發展進程

00:01:35.796 --> 00:01:39.433 
受到的啓發
都來自LLVM項目的發展

00:01:40.367 --> 00:01:42.736 
LLVM有一個廣闊的
開放資源社區

00:01:42.970 --> 00:01:45.372 
由非盈利
LLVM Foundation支持

00:01:47.808 --> 00:01:50.410 
LLVM有很強的自定義性
和可組合性

00:01:51.111 --> 00:01:53.747 
通過利用同樣強健
和成熟的基礎設施

00:01:53.847 --> 00:01:55.449 
支持Clang前端

00:01:55.782 --> 00:01:57.551 
我們爲Swift編譯器提供動力

00:01:59.286 --> 00:02:02.256 
想要了解有關Swift的更多信息
請回顧之前的演講

00:02:03.357 --> 00:02:06.660 
現在來簡單看一些
開放資源裏的可用框架

00:02:06.727 --> 00:02:08.127 
以及可以如何使用它們

00:02:09.997 --> 00:02:13.433 
Clang是編譯器前端
支持C Objective-C和C++語言

00:02:14.301 --> 00:02:16.537 
它的代碼庫裏
有很多先進的功能

00:02:16.603 --> 00:02:18.205 
比如靜態分析

00:02:18.272 --> 00:02:22.276 
編寫中會用到
代碼遷移和代碼改寫

00:02:23.343 --> 00:02:26.246 
它也支持開發環境集成

00:02:26.313 --> 00:02:27.548 
比如源代碼索引

00:02:27.915 --> 00:02:31.084 
以及代碼智能補全
這是Xcode最受歡迎的功能

00:02:32.819 --> 00:02:34.188 
開放資源工具庫

00:02:34.988 --> 00:02:38.892 
幫助你利用Clang的力量
使用你自定義的命令行工具

00:02:38.959 --> 00:02:40.294 
來處理源代碼

00:02:40.928 --> 00:02:43.197 
想想看你能做到
多少不可思議的事情

00:02:43.664 --> 00:02:47.334 
有這樣完善的語法分析器
運行於你的代碼

00:02:52.539 --> 00:02:56.043 
LLVM優化程序
這個我們會多講一點

00:02:56.109 --> 00:02:59.146 
有一套完整的現代編譯器優化

00:02:59.713 --> 00:03:02.382 
就是這個功能實現了
鏈接時間優化

00:03:03.083 --> 00:03:05.586 
敬請期待
LTO的新發展

00:03:09.790 --> 00:03:12.926 
然後我們有個後端
就是最終代碼生成的地方

00:03:13.527 --> 00:03:16.029 
這裏是目標文件操作庫

00:03:16.096 --> 00:03:18.232 
功能有彙編和反彙編

00:03:18.298 --> 00:03:19.499 
還有更高級的功能

00:03:19.566 --> 00:03:22.769 
比如即時編譯
可以很簡單的編在一起

00:03:24.805 --> 00:03:28.208 
LLVM還有很多其他的工具
由它的框架組成

00:03:28.408 --> 00:03:29.510 
讓我們來看一看

00:03:31.011 --> 00:03:33.413 
作爲完整的
LLVM工具鏈的一部分

00:03:33.814 --> 00:03:36.416 
就是常見的一套
二進制文件組件

00:03:36.483 --> 00:03:39.386 
包括開源社區
努力做出的一個框架

00:03:39.453 --> 00:03:41.355 
用來製作鏈接器和其他相關工具

00:03:41.421 --> 00:03:42.256 
其他工具概覽

00:03:42.322 --> 00:03:45.559 
但也許之中最出色的
工程就是LLDB

00:03:46.093 --> 00:03:49.663 
LLDB結合了許多庫
包括Clang Swift

00:03:49.963 --> 00:03:52.999 
Code Generator
以及它自己的一套調試框架

00:03:53.867 --> 00:03:56.904 
在週五 有一場很棒的演講

00:03:58.338 --> 00:03:59.973 
關於LLDB使用技巧和竅門

00:04:00.040 --> 00:04:03.110 
這些好的特性無論是
Xcode還是Swift Playgrounds

00:04:03.177 --> 00:04:05.779 
還是Apple LLVM編譯器
都不可能實現

00:04:06.013 --> 00:04:09.449 
如果沒有
LLVM開放資源社區的貢獻的話

00:04:10.117 --> 00:04:13.120 
這個社區裏
都是跟你們一樣的開發者

00:04:13.554 --> 00:04:16.523 
他們很有思想
並把他們的想法帶入LLVM框架

00:04:19.059 --> 00:04:22.162 
LLVM開放資源工程
發展速度之快令人咂舌

00:04:22.629 --> 00:04:25.199 
這頗有挑戰性
無論是團隊裏的哪一個人

00:04:25.265 --> 00:04:27.201 
或者哪一個公司
都很難趕上

00:04:29.169 --> 00:04:32.639 
我們想邀請你來
LLVM.org參與這個工程

00:04:32.840 --> 00:04:36.276 
看看你能否融入這個羣體
貢獻你獨到的見解

00:04:38.579 --> 00:04:40.414 
現在我來爲大家介紹Duncan

00:04:40.480 --> 00:04:42.516 
他會跟大家講一些
很棒的語言新特性

00:04:42.583 --> 00:04:44.585 
在Apple LLVM編譯器裏

00:04:47.955 --> 00:04:51.124 
語言支持

00:04:53.260 --> 00:04:54.962 
我們來講講語言支持

00:04:55.863 --> 00:04:58.332 
首先我們來講新的語言特性

00:04:58.398 --> 00:05:00.868 
然後再講升級C++庫

00:05:00.934 --> 00:05:04.204 
最後講新的錯誤和警告
來幫助你完善代碼

00:05:06.073 --> 00:05:08.041 
就從新的語言特性開始講吧

00:05:09.176 --> 00:05:11.845 
Objective-C現支持類屬性

00:05:12.346 --> 00:05:15.082 
這個功能一開始是Swift中的
類型屬性

00:05:15.215 --> 00:05:17.017 
我們將它帶入Objective-C

00:05:17.417 --> 00:05:19.086 
互操作運行良好

00:05:20.787 --> 00:05:24.424 
這個例子中
類屬性someString聲明瞭

00:05:24.658 --> 00:05:28.028 
使用屬性語法
通過添加class標誌

00:05:28.829 --> 00:05:32.299 
之後這個someString屬性
使用點語法訪問

00:05:34.034 --> 00:05:36.203 
類屬性永遠無法合成

00:05:36.270 --> 00:05:40.807 
你可以提供儲存 一個getter
一個setter在執行的時候

00:05:40.874 --> 00:05:41.875 
Objective C類屬性

00:05:41.942 --> 00:05:45.312 
或者你可以用@dynamic
來推遲解析到運行時

00:05:47.581 --> 00:05:48.815 
轉過來看C++

00:05:49.216 --> 00:05:50.117 
C++線程本地存儲（TLS）

00:05:50.184 --> 00:05:54.188 
LLVM很好地支持
C++11很多年了

00:05:54.521 --> 00:05:57.624 
唯一不支持的
是線性本地關鍵字

00:05:58.425 --> 00:06:00.027 
今年 我們添加了這個支持

00:06:00.527 --> 00:06:02.396 
我這就講一下

00:06:03.730 --> 00:06:06.867 
如果一個變量是以
線程本地關鍵字來聲明

00:06:06.934 --> 00:06:09.903 
LLVM會創建一個
單獨的變量給每個線程

00:06:10.971 --> 00:06:14.775 
調出初始化器
在第一次進入線程開始使用之前

00:06:14.842 --> 00:06:17.010 
退出線程的時候調出析構函數

00:06:18.445 --> 00:06:22.950 
C++類的線程本地存儲
支持任何C++類型

00:06:26.820 --> 00:06:30.157 
它的語法可以
移植到其他C++編譯器中

00:06:32.125 --> 00:06:36.964 
Apple LLVM編譯器
已經支持C-style線程本地存儲

00:06:37.030 --> 00:06:39.333 
即便是在編譯C++代碼的時候

00:06:39.800 --> 00:06:41.502 
有兩種可用的語法

00:06:41.802 --> 00:06:45.839 
一種是帶GCC關鍵字
另一種來自C11標準

00:06:46.907 --> 00:06:51.512 
C風格線程本地存儲負載較低
較C++本地線程而言

00:06:51.578 --> 00:06:53.247 
但是它也受限制

00:06:53.313 --> 00:06:56.717 
它要求使用連貫的初始化器
和簡單的老數據類型

00:06:56.884 --> 00:06:57.918 
哪種TLS適合我？

00:06:57.985 --> 00:06:59.987 
如果你的代碼符合這些限制

00:07:00.053 --> 00:07:03.156 
你就可以繼續使用
C-style線程本地存儲

00:07:03.223 --> 00:07:04.658 
以便獲得最高性能

00:07:05.192 --> 00:07:07.995 
如果不符合
就用C++線程本地關鍵字

00:07:08.328 --> 00:07:09.296 
這兩個都很好用

00:07:10.864 --> 00:07:14.801 
線程本地變量可以幫助修復
用戶線程代碼中的錯誤

00:07:15.269 --> 00:07:17.004 
要了解更多線程相關錯誤的信息

00:07:17.771 --> 00:07:20.941 
請觀看演講
線程檢查工具和靜態分析

00:07:22.676 --> 00:07:24.411 
這就是我要講的新的語言特性

00:07:25.245 --> 00:07:26.313 
C++庫升級

00:07:26.380 --> 00:07:29.049 
接下來我們看C++標準庫

00:07:30.350 --> 00:07:34.721 
Libc++多年來一直是
默認的C++標準庫

00:07:35.189 --> 00:07:38.659 
我們一直建議你們
棄用Libstandardc++

00:07:38.725 --> 00:07:41.995 
在Xcode8的所有平臺
我們都已棄用

00:07:42.529 --> 00:07:44.531 
請你也儘快升級

00:07:44.598 --> 00:07:45.699 
Libstdc++要棄用

00:07:45.766 --> 00:07:49.203 
如果你的Xcode工程
仍使用Libstandardc++

00:07:49.503 --> 00:07:51.438 
你必須要升級到Libc++

00:07:51.505 --> 00:07:54.708 
通過更改C++標準庫的建立設置

00:07:55.209 --> 00:07:58.712 
Xcode工程現代化會
自動完成這個升級

00:08:00.280 --> 00:08:04.885 
Libc++.dylib
今年在我們所有平臺上做了很大改進

00:08:04.952 --> 00:08:10.257 
它的庫現在完全支持C++14
還有其他的改善

00:08:10.557 --> 00:08:11.425 
Libc++Availability屬性

00:08:11.491 --> 00:08:16.096 
需要dylib的標準庫特性
現也有Availability屬性

00:08:16.763 --> 00:08:20.133 
當Apple框架要
部署給過去的目標

00:08:20.200 --> 00:08:21.802 
鼓勵在運行時檢查

00:08:22.102 --> 00:08:26.273 
C++標準庫的有效性檢查
在編譯時就已經完成

00:08:27.241 --> 00:08:30.644 
要使用C++功能
需要最新的dylib

00:08:30.911 --> 00:08:33.480 
所以你指向的平臺
必須支持它們

00:08:34.615 --> 00:08:36.549 
這就是C++庫

00:08:38.552 --> 00:08:40.621 
在Xcode7和Xcode8之間

00:08:41.355 --> 00:08:43.890 
我們添加了100多個
新的錯誤與警告

00:08:43.957 --> 00:08:45.626 
來幫助你找到代碼中的故障

00:08:46.159 --> 00:08:47.861 
我們簡單講講其中幾個

00:08:49.863 --> 00:08:51.198 
在Xcode 7

00:08:51.865 --> 00:08:55.435 
我們給Objective-C添加了很棒的新特性
叫做Lightweight Generics

00:08:56.103 --> 00:08:59.173 
這種_kindof類型修飾符
具有十分重要的作用

00:08:59.239 --> 00:09:03.377 
允許隱式轉換
到_kindof任意子類

00:09:03.443 --> 00:09:04.278 
_kindof類層次結構之外的方法

00:09:04.344 --> 00:09:09.316 
在Xcode 8我們完善了
_kindof類型的方法查找診斷

00:09:10.417 --> 00:09:11.451 
看這個例子

00:09:11.518 --> 00:09:14.788 
getAwesomeNumber在
My Custom Type中聲明

00:09:15.055 --> 00:09:16.790 
這是NSObject的繼承類

00:09:17.457 --> 00:09:21.261 
之後getAwesomeNumber
在kindof UIView中調出

00:09:21.862 --> 00:09:26.033 
這個代碼是壞的
因爲My Custom Type與UIView沒有關聯

00:09:27.167 --> 00:09:29.036 
Xcode 8這裏就會報錯

00:09:29.469 --> 00:09:31.839 
方法類型檢查
調出_kindof類型

00:09:31.905 --> 00:09:34.141 
限制於同一類層次結構

00:09:34.608 --> 00:09:37.845 
完善後的類型檢查
也可以避免誤導性的警告

00:09:37.911 --> 00:09:41.348 
當一個無關的類型
聲明一個名字相同的方法

00:09:41.849 --> 00:09:45.552 
在Xcode 8 _kindof
類型使用起來方便多了

00:09:46.954 --> 00:09:48.755 
容器的循環依賴

00:09:48.822 --> 00:09:53.060 
接下來 Objective-C容器
比如NSArray和NSMutableSet

00:09:53.126 --> 00:09:54.661 
可以包含任意對象

00:09:54.995 --> 00:10:00.033 
NSMutableSet調出“s”
在這個例子裏添加給了自身

00:10:01.401 --> 00:10:05.539 
這就造成了循環依賴
導致了Xcode 8的警告

00:10:06.507 --> 00:10:08.675 
除了創建循環強引用

00:10:08.742 --> 00:10:12.779 
循環依賴可以避免
一些方法被明確定義

00:10:15.883 --> 00:10:17.251 
無限遞歸

00:10:18.185 --> 00:10:20.854 
這個例子執行了
階乘函數

00:10:21.622 --> 00:10:25.058 
如果n是正值
就會返回n乘以階乘n-1

00:10:25.125 --> 00:10:26.960 
不斷遞歸來計算答案

00:10:27.828 --> 00:10:31.798 
如果n是0 返回階乘1
還是會遞歸

00:10:32.933 --> 00:10:34.801 
編譯器這時會收到一個警告

00:10:34.868 --> 00:10:37.437 
說所有通過此函數的路徑
都會調出自己

00:10:38.005 --> 00:10:40.807 
這是最典型的無限遞歸

00:10:42.876 --> 00:10:46.580 
這裏的一個可能的解決辦法就是
當n是0的時候返回1

00:10:49.016 --> 00:10:50.284 
無用移動
阻止返回值優化（RVO）

00:10:50.350 --> 00:10:53.453 
標準轉移是
C++最好的語言特性之一

00:10:54.121 --> 00:10:56.790 
它允許你定義
所有者可以被傳遞

00:10:56.857 --> 00:10:58.492 
從一個container到另一個

00:10:59.293 --> 00:11:02.396 
轉移資源
比深拷貝要快

00:11:04.031 --> 00:11:07.434 
但是要將標準轉移
用於返回值

00:11:07.501 --> 00:11:09.970 
就阻止了
具名返回值優化

00:11:10.804 --> 00:11:13.907 
通常當一個本地變量
以值來返回

00:11:13.974 --> 00:11:16.710 
編譯器就可以
完全避免複製

00:11:17.211 --> 00:11:22.783 
在generateBars裏
調用標準轉移使編譯器移動bars

00:11:24.117 --> 00:11:27.521 
雖然移動很快
但是什麼都不做不是更快

00:11:28.088 --> 00:11:31.091 
LLVM現在就會警告
這種無用移動

00:11:32.593 --> 00:11:35.495 
這種修復是爲了避免
標準移動返回值

00:11:35.562 --> 00:11:37.264 
使性能再次下降

00:11:38.699 --> 00:11:42.002 
同樣 當一個函數
以值接收一個參數

00:11:42.069 --> 00:11:43.704 
返回的也是一個值

00:11:44.037 --> 00:11:47.508 
編譯器會自動用
標準轉移返回

00:11:47.574 --> 00:11:49.209 
無需額外調出

00:11:49.276 --> 00:11:50.410 
多餘移動
幹擾樣板

00:11:50.477 --> 00:11:54.848 
如標準移動在rewriteText
的返回值是多餘的

00:11:55.482 --> 00:11:57.885 
儘管這不會實質上
減低性能

00:11:57.951 --> 00:11:59.386 
但還是降低了代碼的可讀性

00:12:00.220 --> 00:12:02.389 
最好還是直接返回文本

00:12:02.456 --> 00:12:06.393 
這更方便保持和連貫返回本地變量

00:12:08.962 --> 00:12:10.264 
參考隱式變換
C+- range-based循環

00:12:10.330 --> 00:12:13.967 
最後這個新的警告是
關於臨時引用

00:12:14.034 --> 00:12:16.170 
在C++ range-based
循環

00:12:17.237 --> 00:12:20.574 
這裏這個循環
是通過一個shorts矢量

00:12:20.641 --> 00:12:24.278 
但是循環變量 i
是一個常用引量到而不是int

00:12:25.145 --> 00:12:27.147 
由於隱形變換

00:12:27.214 --> 00:12:30.851 
出現在short和int之間
i 就是一個臨時量

00:12:32.719 --> 00:12:34.488 
這會導致一些細微的故障

00:12:34.555 --> 00:12:38.425 
因爲看上去i是在範圍內指向
但實際不是

00:12:39.059 --> 00:12:42.262 
編譯器這時就會警告
這個意外變換

00:12:42.796 --> 00:12:45.599 
一個解決辦法是將 i
改成一個short常用引量

00:12:46.700 --> 00:12:51.305 
另外一個方法是聲明i是個臨時量
通過去掉引用

00:12:52.739 --> 00:12:53.941 
類似的警告也會出現

00:12:54.341 --> 00:12:56.577 
如果range沒有返回
任何一個引用

00:12:56.643 --> 00:12:57.678 
引用複製

00:12:57.744 --> 00:13:01.582 
一個用博爾值的標準矢量迭代器
無法返回引用

00:13:01.915 --> 00:13:05.285 
所以迭代器變量b
在這裏就是臨時量

00:13:06.520 --> 00:13:10.190 
出乎意料的是
b並不指向矢量之內

00:13:10.257 --> 00:13:12.793 
於是編譯器警告
這個意外複製

00:13:15.495 --> 00:13:19.499 
解決辦法就是去掉引用
明確定義b是臨時量

00:13:21.502 --> 00:13:24.071 
這些新警告包括無限遞歸
標準移動,

00:13:24.137 --> 00:13:27.508 
和C++ range-based
循環是默認啓用的

00:13:28.008 --> 00:13:30.210 
要在你的expo進程中實驗它們

00:13:30.611 --> 00:13:33.213 
就把它們添加到
其他警告標誌的設置中

00:13:33.981 --> 00:13:35.582 
新的診斷就講完了

00:13:36.183 --> 00:13:37.017 
編譯器優化

00:13:37.084 --> 00:13:40.220 
下面來講講編譯器優化的進步

00:13:43.957 --> 00:13:46.827 
我們整體上完善了
LLVM編譯器

00:13:46.894 --> 00:13:49.730 
來優化你的代碼的
運行時性能

00:13:50.531 --> 00:13:52.533 
我們只選擇了幾個
在今天着重講解

00:13:53.400 --> 00:13:56.503 
我們會講到
鏈接時間優化的改進

00:13:56.570 --> 00:13:59.139 
重點講
新代碼生成優化

00:13:59.206 --> 00:14:02.376 
然後再講講
arm64緩存調整

00:14:04.444 --> 00:14:07.614 
鏈接時間優化

00:14:07.681 --> 00:14:10.984 
在過去幾年裏
我們討論過了鏈接時間優化

00:14:11.051 --> 00:14:13.053 
現在我們有重大進步要跟大家分享

00:14:13.820 --> 00:14:16.156 
鏈接時間優化
也叫LTO

00:14:16.223 --> 00:14:19.393 
它優化了可執行文件
把它們作爲單一的完整單元

00:14:20.027 --> 00:14:23.697 
它在源文件中內聯函數
刪除死代碼

00:14:23.797 --> 00:14:26.967 
執行其他功能強大
完整的工程優化

00:14:27.034 --> 00:14:27.868 
什麼是鏈接時間優化（LTO）？

00:14:27.935 --> 00:14:31.738 
LTO消除了
編譯器和鏈接器間的界限

00:14:32.873 --> 00:14:34.975 
要了解LTO的工作原理

00:14:35.075 --> 00:14:37.511 
首先要看看
傳統的編譯模型

00:14:38.679 --> 00:14:40.447 
假設我們有四個源文件

00:14:41.281 --> 00:14:45.052 
第一步是編譯
產生四個目標文件

00:14:46.353 --> 00:14:50.057 
目標文件鏈接到框架
產生應用

00:14:52.326 --> 00:14:54.561 
LTO的建立
一開始是一樣的

00:14:55.329 --> 00:14:57.798 
都是編譯源文件
到目標文件

00:14:58.799 --> 00:15:03.637 
在LTO裏的這些目標文件
包含了額外的優化信息

00:15:03.704 --> 00:15:07.074 
這些信息讓鏈接器可以執行
鏈接時間優化

00:15:07.140 --> 00:15:10.277 
從而產生單一的
單片集成目標文件

00:15:10.344 --> 00:15:11.411 
LTO編譯模型

00:15:11.478 --> 00:15:13.580 
LTO的輸出
與框架相連

00:15:13.647 --> 00:15:17.217 
比如Foundation
從而形成應用

00:15:19.419 --> 00:15:21.755 
LTO能讓性能最大化

00:15:23.590 --> 00:15:26.760 
Apple大量運用LTO
在我們的軟件裏

00:15:27.294 --> 00:15:32.032 
通常可執行檔的速度可以提高10%
相較於其他普通的發佈版本

00:15:33.033 --> 00:15:36.737 
它的效果會更明顯
如果跟性能分析引導優化結合使用

00:15:36.803 --> 00:15:38.138 
LTO運行時性能
用LTO使性能最大化

00:15:38.205 --> 00:15:42.709 
它還可以極大地降低代碼長度
在優化大小的時候

00:15:44.845 --> 00:15:47.214 
但是在編譯時會產生成本

00:15:47.281 --> 00:15:48.148 
LTO編譯時間的折中

00:15:48.215 --> 00:15:52.019 
集成優化步驟
會需要大量的記憶

00:15:52.085 --> 00:15:54.021 
不能利用你所有的核

00:15:54.454 --> 00:15:56.523 
而且會不斷重複
出現在增量編譯中

00:15:57.824 --> 00:16:02.596 
帶有調試信息的大型C++項目
編譯成本是最高的

00:16:03.897 --> 00:16:07.267 
在過去的兩年裏
我們一直致力於降低負載

00:16:08.335 --> 00:16:10.204 
比如研究內存用量

00:16:10.270 --> 00:16:15.275 
條件是Apple LLVM編譯器
與LTO和調試信息相鏈接

00:16:15.342 --> 00:16:16.610 
這個條越短越好

00:16:17.044 --> 00:16:20.180 
在Xcode 6佔用400億字節

00:16:20.247 --> 00:16:21.081 
LTO內存用量
完整調試信息

00:16:21.148 --> 00:16:24.017 
從那時起
我們就將內存用量減少了4倍

00:16:24.518 --> 00:16:27.287 
也將編譯時間減少了33%

00:16:29.089 --> 00:16:33.827 
Line Tables Only
調試信息水平佔用的內存比LTO還少

00:16:34.294 --> 00:16:38.165 
鏈接LLVM自己
現在只佔7千兆

00:16:38.232 --> 00:16:39.433 
LTO內存用量
Line Tables Only

00:16:39.633 --> 00:16:42.369 
LTO從來沒有這麼好過

00:16:43.470 --> 00:16:45.572 
但現在還是有
編譯時間折中的問題

00:16:45.639 --> 00:16:47.441 
特別是對增量編譯

00:16:50.143 --> 00:16:53.480 
但我們有一個很棒的新技術
可以減免這些成本

00:16:54.882 --> 00:16:57.684 
增量LTO能夠擴展你的系統

00:16:58.752 --> 00:17:03.023 
它執行整體分析和內聯
不需要結合目標文件

00:17:03.090 --> 00:17:04.090 
增量LTO

00:17:04.156 --> 00:17:08.729 
它的建立更加快速
因爲它可以同時優化每個目標文件

00:17:09.262 --> 00:17:13.133 
另外由於目標文件都是單獨的

00:17:13.200 --> 00:17:17.637 
而且你的緩存建立在鏈接器上
因此增量編譯能超速運行

00:17:19.373 --> 00:17:22.376 
我們來看
增量LTO編譯如何運行

00:17:22.442 --> 00:17:23.676 
增量LTO編譯模型

00:17:23.743 --> 00:17:26.547 
編譯步驟與單片集成LTO一樣

00:17:26.880 --> 00:17:29.449 
爲每個源文件
產生一個目標文件

00:17:31.084 --> 00:17:33.153 
不需要合成目標文件

00:17:33.220 --> 00:17:36.423 
鏈接器運行LTO分析
在整個工程裏

00:17:37.658 --> 00:17:41.094 
這個分析爲每個目標文件
傳送優化

00:17:41.161 --> 00:17:43.897 
使各個目標文件的函數內聯

00:17:43.964 --> 00:17:47.134 
也會內聯其他強大的
全工程優化

00:17:48.802 --> 00:17:53.240 
LTO優化的目標文件
儲存在鏈接器緩存裏

00:17:54.374 --> 00:17:57.377 
之後纔會鏈接到框架以形成應用

00:17:59.513 --> 00:18:02.049 
根據計算後的運行期性能

00:18:02.115 --> 00:18:06.153 
增量LTO創立的工程
與單片集成LTO差不多

00:18:06.620 --> 00:18:09.790 
有幾個benchmark慢點兒
另外幾個快點兒

00:18:11.191 --> 00:18:12.893 
但是編譯時間很快

00:18:13.794 --> 00:18:17.264 
那麼來看看
我最喜歡的C++工程的創立時間

00:18:17.331 --> 00:18:19.233 
Apple LLVM編譯器本身

00:18:20.300 --> 00:18:22.236 
在這個表裏
條越短越好

00:18:22.569 --> 00:18:25.072 
最上面這一條
是不用LTO建立的時間

00:18:26.039 --> 00:18:29.142 
單片集成LTO建立所用的時間
遠遠超過上面的

00:18:29.209 --> 00:18:31.612 
用了將近20分鐘
可不是6分鐘

00:18:31.678 --> 00:18:32.546 
創建大型C++工程的時間

00:18:32.613 --> 00:18:35.516 
增量LTO要快很多
用時少於8分鐘

00:18:35.582 --> 00:18:37.484 
負載只增加了25%

00:18:39.152 --> 00:18:41.955 
再單獨來看一下鏈接步驟
LTO就在這裏運行

00:18:43.056 --> 00:18:45.792 
不用LTO只鏈接
Apple LLVM編譯器自身

00:18:45.859 --> 00:18:47.361 
所用時間小於兩秒

00:18:47.895 --> 00:18:49.496 
在圖上看不到條

00:18:49.563 --> 00:18:52.766 
因爲鏈接器不執行任何編譯器優化

00:18:53.967 --> 00:18:59.806 
單片集成LTO用時將近14分鐘
因爲它可以用到所有的核

00:18:59.873 --> 00:19:02.276 
增量LTO用時2分14秒

00:19:02.342 --> 00:19:05.012 
比單片集成LTO快了6倍多

00:19:06.446 --> 00:19:08.015 
內存用量也很小

00:19:08.715 --> 00:19:12.186 
不用LTO單連
Apple LLVM編譯器所佔內存

00:19:12.252 --> 00:19:13.554 
也就200多兆

00:19:14.254 --> 00:19:17.758 
跟我們之前看到的一樣
單片集成LTO佔了70億字節

00:19:19.092 --> 00:19:21.895 
增量LTO佔用內存
小於800兆

00:19:22.162 --> 00:19:23.630 
這個比例令人不可思議

00:19:32.906 --> 00:19:34.708 
所有這些結果
都是新版本

00:19:34.942 --> 00:19:36.043 
以後還會更好

00:19:37.244 --> 00:19:38.512 
有了增量LTO

00:19:38.579 --> 00:19:41.615 
增量編譯
不會再重複無用功

00:19:42.316 --> 00:19:45.118 
再看一個例子
當控制器改變時

00:19:45.252 --> 00:19:47.554 
怎麼開始
App的增量編譯

00:19:47.621 --> 00:19:48.789 
增量編譯示例

00:19:48.856 --> 00:19:51.625 
改變控制器
會讓鏈接失效

00:19:52.025 --> 00:19:55.495 
但其他的LTO目標文件
還存在鏈接器緩存裏

00:19:56.029 --> 00:20:00.033 
但若一個控制器函數被內聯到主方法

00:20:00.100 --> 00:20:03.470 
那麼主方法需要重新優化
在LTO時間

00:20:06.006 --> 00:20:09.576 
那麼我們開始構建
只有控制器需要重新編譯

00:20:10.744 --> 00:20:14.481 
重新運行LTO分析之後
controller.O和main.O

00:20:14.548 --> 00:20:18.619 
都被優化了
新的LTO目標文件存入鏈接器緩存

00:20:19.486 --> 00:20:23.190 
LTO目標文件就如以往一樣
連在一起產生應用

00:20:25.392 --> 00:20:30.063 
增量LTO提供的性能
正是對增量編譯性能的期待

00:20:30.864 --> 00:20:34.134 
當帶有小輔助函數的
源文件被更改

00:20:34.201 --> 00:20:36.570 
使用它們的目標文件
會被重新優化

00:20:37.337 --> 00:20:39.706 
但對於典型的增量編譯

00:20:39.773 --> 00:20:43.677 
大部分LTO目標文件
直接從鏈接器緩存鏈接

00:20:45.078 --> 00:20:49.249 
最後再看一下鏈接到
Apple LLVM編譯器本身時間

00:20:49.883 --> 00:20:53.120 
最上面三條顯示的時間
是從之前的fresh build

00:20:53.187 --> 00:20:54.354 
大型C++工程的增量鏈接

00:20:54.421 --> 00:20:57.191 
如果我們更改了優化遍數的執行

00:20:57.791 --> 00:21:00.527 
單片集成LTO用時是一樣的

00:21:00.594 --> 00:21:02.062 
跟fresh build一樣

00:21:03.597 --> 00:21:06.333 
但是增量LTO只需要8秒

00:21:06.834 --> 00:21:12.239 
這比初始化版本快16倍
比單片集成LTO快100倍

00:21:16.910 --> 00:21:17.878 
真是令人驚歎

00:21:19.379 --> 00:21:21.682 
最新的科技
鏈接時間優化

00:21:21.748 --> 00:21:25.919 
低內存用量
快速增量編譯

00:21:26.486 --> 00:21:28.222 
今天就去試一下增量LTO吧

00:21:28.288 --> 00:21:29.623 
啓用增量LTO

00:21:30.691 --> 00:21:33.460 
LTO的改進十分出色

00:21:33.527 --> 00:21:36.463 
但如果你用LTO
處理大型C++工程

00:21:36.530 --> 00:21:39.533 
編譯時間要降到最低就只用
line tablesonly

00:21:39.600 --> 00:21:41.034 
調試信息層

00:21:41.602 --> 00:21:45.172 
這樣調試器裏可以獲得許多追蹤信息
而且成本最低

00:21:45.239 --> 00:21:47.040 
LTO和調試信息

00:21:47.107 --> 00:21:48.976 
以上就是鏈接時間優化

00:21:49.643 --> 00:21:53.480 
現在有請Gerolf上臺爲大家講講
新的代碼生成優化

00:21:54.147 --> 00:21:56.083 
代碼生成

00:21:59.753 --> 00:22:03.290 
好 接下來就講講
代碼生成優化

00:22:03.690 --> 00:22:08.362 
我們努力研究Xcode 8
Apple LLVM編譯器

00:22:08.428 --> 00:22:11.164 
爲了能提高所有應用的性能

00:22:12.199 --> 00:22:14.735 
在這一環節
我要講其中三個

00:22:15.169 --> 00:22:17.437 
Stack packing
和shrink wrapping

00:22:18.238 --> 00:22:20.440 
以及選擇混合型乘加運算

00:22:20.974 --> 00:22:22.576 
首先來講stack packing

00:22:23.510 --> 00:22:27.614 
這是關於本地變量
運行時棧內存

00:22:27.781 --> 00:22:30.984 
Apple LLVM編譯器
一直都帶有優化

00:22:31.051 --> 00:22:34.821 
努力壓縮棧內存大小

00:22:35.155 --> 00:22:39.393 
Xcode 8的編譯器
是優化最好的

00:22:40.294 --> 00:22:42.462 
原因就是這個
來看看這個例子

00:22:42.863 --> 00:22:48.402 
注意x的定義要在
if陳述的作用域之內

00:22:48.836 --> 00:22:52.072 
然後看一下y的定義
在if陳述之後

00:22:52.573 --> 00:22:55.175 
如果編譯器不去優化
這個代碼片段

00:22:55.242 --> 00:22:58.245 
那麼就是說
x和y這兩個變量

00:22:58.312 --> 00:23:01.882 
在運行時內存棧上
不同的兩個棧單元

00:23:03.183 --> 00:23:07.087 
但是
根據C-style語言規則

00:23:07.154 --> 00:23:10.924 
一個變量的生存期
結束於它所定義的作用域

00:23:11.525 --> 00:23:14.161 
這也就是編譯器所利用的一點

00:23:14.661 --> 00:23:17.831 
那麼來看看
這對我們的兩個變量有何影響

00:23:20.234 --> 00:23:22.936 
x被定義於if陳述之內

00:23:23.403 --> 00:23:26.907 
if陳述的作用域
就在y被定義之前結束

00:23:28.375 --> 00:23:31.712 
當y被定義之後
y就有了一個生存期

00:23:31.778 --> 00:23:33.280 
在這張圖上你可以看到

00:23:33.347 --> 00:23:37.217 
x和y 以及x和y的生存期
不會重疊

00:23:37.718 --> 00:23:40.854 
於是編譯器就可以給它們
一個相同的棧單元

00:23:44.157 --> 00:23:48.862  
這就減少了
程序用的總棧內存

00:23:48.929 --> 00:23:52.366  
就可能會提高應用的性能

00:23:54.368 --> 00:23:55.969  
目前一切都是完美

00:23:57.237 --> 00:23:59.840  
但是這裏有一個小小的警告

00:24:01.775 --> 00:24:05.879 
編程語言的規則有時很難去檢查

00:24:06.647 --> 00:24:08.081 
所以一旦出錯

00:24:09.149 --> 00:24:12.853 
你的程序
可能就會產生意外的結果

00:24:12.920 --> 00:24:16.490 
技術術語就是
未定義行爲

00:24:16.657 --> 00:24:18.325 
我們來看個例子

00:24:19.526 --> 00:24:21.795 
注意這個指針變量

00:24:21.995 --> 00:24:25.866 
在if代碼塊中
它的賦值是x的地址

00:24:25.933 --> 00:24:27.401 
現在看這個print陳述

00:24:27.835 --> 00:24:31.672 
這個時候
x的地址通過這個指針變量而使用

00:24:31.738 --> 00:24:33.373 
這麼這裏所看到的

00:24:33.440 --> 00:24:37.744 
就是x的地址
跑出了if陳述的作用域

00:24:37.811 --> 00:24:41.281 
這樣我們的語言規則
被視爲是未定義行爲

00:24:41.348 --> 00:24:42.883 
脫離本地地址

00:24:42.950 --> 00:24:45.085 
所幸這個修復很簡單

00:24:45.152 --> 00:24:47.087 
這只是個需要注意的地方

00:24:47.154 --> 00:24:50.424 
修復的方法很簡單
只要拓展作用域

00:24:50.490 --> 00:24:54.161 
給x的生存期
通過刪除x的定義

00:24:54.228 --> 00:24:59.566 
在if陳述之外的定義
在條件被檢查之前

00:24:59.867 --> 00:25:05.172 
那麼現在x的定義
所在的作用域

00:25:05.239 --> 00:25:07.441 
就與print陳述一致了

00:25:08.675 --> 00:25:10.644 
刪除很簡單

00:25:11.211 --> 00:25:13.981 
請一定要盡所有努力

00:25:14.581 --> 00:25:17.551 
讓你的程序符合
編程語言規則

00:25:17.618 --> 00:25:20.320 
這能帶來更好的體驗
給你

00:25:20.387 --> 00:25:23.624 
給編譯器
以及我們的用戶

00:25:24.625 --> 00:25:26.226 
以上就是stack packing

00:25:27.961 --> 00:25:29.663 
下面來說shrink wrapping

00:25:30.631 --> 00:25:35.102 
Shrink wrapping
是關於編譯器生成的代碼

00:25:35.169 --> 00:25:37.371 
在函數進入和退出的時候

00:25:37.771 --> 00:25:39.306 
這是一個資源管理代碼

00:25:39.573 --> 00:25:42.276 
管理運行時堆棧和寄存器

00:25:43.076 --> 00:25:44.645 
這裏觀察到的是

00:25:44.711 --> 00:25:48.782 
這個代碼並不需要
作用於函數的所有路徑

00:25:49.082 --> 00:25:53.754 
shrink wrapping
會把這個資源管理指令

00:25:53.820 --> 00:25:56.023 
放在真正需要它們的地方

00:25:57.024 --> 00:25:59.526 
那麼來看一個簡單的例子

00:26:01.895 --> 00:26:05.399 
這是一個簡單函數
有兩個參數a和b

00:26:05.599 --> 00:26:06.867 
將它們進行簡單比較

00:26:07.634 --> 00:26:10.504 
如果a小於b
就會調出一個函數foo

00:26:10.804 --> 00:26:14.741 
它以本地變量的位置
作爲一個參數

00:26:14.875 --> 00:26:16.310 
最後返回

00:26:16.710 --> 00:26:20.714 
瞭解shrink wrapping
來看一下僞彙編代碼

00:26:20.781 --> 00:26:23.684 
類似於編譯器
真正生成的代碼

00:26:24.184 --> 00:26:27.921 
這裏你看到的入口碼
分配堆棧內存

00:26:27.988 --> 00:26:30.924 
節省寄存器
運行比較和分行

00:26:30.991 --> 00:26:33.360 
出口代碼塊
會儲存寄存器

00:26:33.427 --> 00:26:36.063 
刪除堆棧並返回

00:26:36.129 --> 00:26:39.066 
如果條件正確
函數foo會被調出

00:26:39.132 --> 00:26:42.836 
所以這裏看到
我們的程序中有兩個路徑

00:26:42.903 --> 00:26:45.305 
一個是直接從入口碼到出口代碼塊

00:26:45.372 --> 00:26:50.177 
另一個從入口代碼塊到
出口代碼塊

00:26:50.244 --> 00:26:54.448 
這裏主要的發現就是
這個資源管理指令

00:26:54.781 --> 00:26:59.920 
指令運行時棧內存
和指令寄存器

00:26:59.987 --> 00:27:04.892 
只需要用在
調出函數指令時

00:27:05.759 --> 00:27:08.795 
shrink wrapping
所做的是識別這個條件

00:27:09.129 --> 00:27:13.734 
將這些指令
移出入口代碼塊

00:27:13.800 --> 00:27:17.004 
移出出口代碼塊
放到真正需要的地方

00:27:17.070 --> 00:27:18.939 
因此它縮短了生存期

00:27:19.306 --> 00:27:22.876 
資源管理指令的生存期
並在這個region中將它們打包

00:27:22.943 --> 00:27:24.077 
轉移到真正需要的地方

00:27:24.144 --> 00:27:26.413 
這裏的region就只是調令

00:27:26.713 --> 00:27:29.650 
現在設想一下
這個熱代碼

00:27:29.716 --> 00:27:34.087 
在你的函數裏
是從入到出的路徑

00:27:34.254 --> 00:27:38.592 
我們就不再需要執行
資源分配指令

00:27:39.159 --> 00:27:42.663 
如果這是個熱點函數
你會有很多這樣的熱點函數

00:27:42.763 --> 00:27:45.232 
你可以想象
這種方法可以節省幾百萬個

00:27:45.299 --> 00:27:47.935 
指令
讓性能更好的提升

00:27:48.001 --> 00:27:50.237 
也節省應用的用電量

00:27:50.971 --> 00:27:52.739 
以上即shrink wrapping

00:27:59.947 --> 00:28:02.549 
接着我們談談混合加乘運算

00:28:03.016 --> 00:28:06.253 
這把我們帶回到
很簡單的數學運算

00:28:06.320 --> 00:28:07.988 
加法和乘法

00:28:08.388 --> 00:28:10.157 
arm64處理器

00:28:11.592 --> 00:28:14.995 
有一個指令
就是混合加乘指令

00:28:15.495 --> 00:28:17.698 
這個指令會計算一個表達式

00:28:17.898 --> 00:28:21.435 
比如a加b乘以c
只用一個指令

00:28:21.502 --> 00:28:22.769 
選擇性加乘運算

00:28:22.836 --> 00:28:26.940 
你可能會天真地以爲
無論何時看到這樣一個表達式

00:28:27.007 --> 00:28:30.744 
最好的方法
就是隻生產這個指令

00:28:30.811 --> 00:28:33.380 
這也就是
編譯器現在所做的事情

00:28:35.015 --> 00:28:36.350 
但這一定出乎你的意料

00:28:36.416 --> 00:28:40.721 
在某些情況下
生產兩個指令實際上比一個要快

00:28:40.787 --> 00:28:43.857 
一個加法指令
和一個乘法指令

00:28:43.924 --> 00:28:45.959 
這會讓你的應用的性能變得更快

00:28:46.827 --> 00:28:47.728 
爲什麼？

00:28:48.095 --> 00:28:50.998 
我準備了一個簡單的例子
來進行演示

00:28:52.432 --> 00:28:55.435 
這個函數使用四個整數參數

00:28:55.502 --> 00:28:57.671 
並計算一個簡單表達

00:28:57.738 --> 00:28:59.873 
a乘以b加c乘以d

00:28:59.940 --> 00:29:01.308 
選擇性混合加乘運算

00:29:01.375 --> 00:29:03.177 
代碼會是什麼樣子？

00:29:03.243 --> 00:29:07.080 
當編譯器生成
一個單一混合加乘指令的時候？

00:29:08.115 --> 00:29:10.851 
它會計算a乘以b

00:29:10.918 --> 00:29:13.887 
然後加乘運算
需要等待這個結果

00:29:15.255 --> 00:29:19.660 
然後加乘運算
會計算這個表達式的值

00:29:20.093 --> 00:29:21.295 
要用多長時間？

00:29:21.562 --> 00:29:26.066 
乘法需要四個循環
加法也是

00:29:26.133 --> 00:29:29.503 
所以這個簡單序列
總共需要八個循環

00:29:32.773 --> 00:29:36.176 
當我們要生成
2個乘法和1個加法

00:29:36.777 --> 00:29:38.378 
怎麼可能更快呢？

00:29:38.512 --> 00:29:40.280 
那麼我們來看看這個序列

00:29:40.981 --> 00:29:45.519 
首先編譯器發出乘法指令
a乘以b

00:29:45.586 --> 00:29:47.187 
然後計算c乘以d

00:29:47.254 --> 00:29:50.190 
最後把結果相加

00:29:50.824 --> 00:29:55.762 
祕訣在於現代處理器
可以指令級並行

00:29:55.963 --> 00:29:59.499 
它們可以執行2個甚至更多乘法

00:29:59.566 --> 00:30:00.934 
兩個乘法 代碼更快

00:30:01.001 --> 00:30:03.704 
同時並列計算

00:30:03.770 --> 00:30:05.272 
因此在這裏

00:30:05.339 --> 00:30:08.208 
兩個乘法是
並列執行的

00:30:08.342 --> 00:30:12.479 
所以在四個循環中
我們得到的不是一個乘法的結果

00:30:12.546 --> 00:30:14.448 
而是兩個

00:30:14.515 --> 00:30:17.518 
然後我們只要把結果相加
一個循環裏完成

00:30:18.018 --> 00:30:22.756 
現在我們看到
要計算這個表達式的值

00:30:22.856 --> 00:30:24.758 
我們只需要五個循環

00:30:24.825 --> 00:30:27.594 
現在比較一下這個序列

00:30:28.495 --> 00:30:31.231 
與一個最少加乘的序列

00:30:31.298 --> 00:30:36.069 
那麼在這個簡單序列中
運算速度快了兩倍

00:30:37.171 --> 00:30:39.673 
因此使用選擇性加乘運算

00:30:39.740 --> 00:30:43.844 
就可以加速計算
應用裏的許多簡單表達式

00:30:44.077 --> 00:30:46.246 
以上就是混合加乘運算

00:30:54.054 --> 00:30:56.990 
接着我們講arm64緩存優化

00:30:58.258 --> 00:31:00.761 
這裏我要講兩個技術

00:31:00.827 --> 00:31:05.599 
編譯器決定
哪些數據會存在緩存裏

00:31:06.233 --> 00:31:08.535 
而緩存中的數據

00:31:08.602 --> 00:31:10.938 
決定了應用的性能

00:31:11.805 --> 00:31:15.108 
在我們詳細講解
編譯器的工作原理之前

00:31:15.175 --> 00:31:18.011 
我想快速的
回顧一下存儲層次

00:31:18.412 --> 00:31:22.683 
在頂部你看到的是主存儲
控制程序變量

00:31:24.117 --> 00:31:25.953 
這是上面這一條

00:31:26.053 --> 00:31:27.688 
在最底下
你看到是寄存器

00:31:27.754 --> 00:31:31.692 
從主存儲器下載數據
到寄存器十分緩慢

00:31:31.758 --> 00:31:35.462 
要鏈接這兩個部分需要一個緩存
就是臨時存儲

00:31:35.529 --> 00:31:40.434 
它比主存儲小
1萬到10萬倍

00:31:40.501 --> 00:31:43.804 
但是從緩存下載數據的速度
要快很多

00:31:43.871 --> 00:31:46.273 
大概快10到100倍

00:31:47.007 --> 00:31:49.243 
然後數據從主存儲中下載

00:31:50.244 --> 00:31:53.146 
我們下載的
不僅僅是單一的寄存值

00:31:53.213 --> 00:31:56.149 
而是把一整個緩存行
從主存儲中下載下來

00:31:56.216 --> 00:31:59.152 
所以緩存行中包括了
不止一個註冊值

00:32:00.053 --> 00:32:02.623 
這個設計之所以
能如此成功

00:32:02.689 --> 00:32:07.060 
是因爲你的程序數據
有兩個局部屬性

00:32:07.127 --> 00:32:10.063 
時間局部性
和空間局部性

00:32:10.597 --> 00:32:14.401 
時間局部性指的是
程序現在訪問的數據

00:32:14.468 --> 00:32:16.436 
很快會被再次訪問

00:32:16.837 --> 00:32:20.707 
空間局部性指的是
程序現在訪問的數據

00:32:20.774 --> 00:32:24.378 
隨後還會訪問相鄰的數據

00:32:24.645 --> 00:32:29.383 
所以當你訪問一個數組區域
它還會訪問相鄰的域

00:32:29.516 --> 00:32:33.220 
當它訪問你數據結構裏的一個域

00:32:33.287 --> 00:32:35.589 
它還會訪問相鄰的一個域

00:32:35.756 --> 00:32:36.957 
以此類推

00:32:37.024 --> 00:32:39.026 
現在你看着這個設計

00:32:39.927 --> 00:32:42.462 
而且你覺得

00:32:42.529 --> 00:32:46.333 
從緩存裏下載數據很快

00:32:46.600 --> 00:32:50.304 
那是不是可以
將數據預先加載到緩存裏

00:32:50.370 --> 00:32:54.441 
從主儲存中加載
在處理器處理其他操作的時候

00:32:54.508 --> 00:32:56.376 
這樣所有數據的加載都很快

00:32:56.443 --> 00:32:58.712 
當我們需要這些數據時
當程序需要這些數據時

00:33:00.881 --> 00:33:02.316 
你可能會感到吃驚

00:33:03.217 --> 00:33:07.087 
因爲你的iPhone處理器
已經實現了這個神奇的事情

00:33:07.754 --> 00:33:09.089 
這就是硬件預取

00:33:09.389 --> 00:33:13.393 
處理器會觀察
加載的每一個地址

00:33:13.694 --> 00:33:16.196 
試圖在這些地址裏找到模式

00:33:16.263 --> 00:33:17.598 
一旦這個模式找到

00:33:17.664 --> 00:33:21.535 
就可以預測你的程序
在將來需要什麼樣的數據

00:33:21.602 --> 00:33:24.471 
從主存儲中再次預取這個數據

00:33:24.538 --> 00:33:26.773 
在其他並行處理
還在運行中的時候

00:33:26.840 --> 00:33:30.577 
將數據存進緩存
最後當程序需要他們

00:33:30.644 --> 00:33:33.180 
程序可以很快的將它們
從緩存中加載

00:33:34.181 --> 00:33:37.251 
那麼今年
我們研究了硬件結構

00:33:37.451 --> 00:33:41.288 
來看看編譯器可以做到什麼

00:33:41.355 --> 00:33:44.358 
讓這個神奇預取
使應用運行得更好

00:33:44.424 --> 00:33:45.759 
軟件預取

00:33:45.826 --> 00:33:46.994 
我們找到了幾個模式

00:33:47.060 --> 00:33:51.198 
所以編譯器現在做的
就是分析源代碼

00:33:51.532 --> 00:33:54.635 
預測以後應用可能需要的數據

00:33:55.269 --> 00:34:00.207 
發出預取指令
讓應用獲取這個數據

00:34:00.274 --> 00:34:01.775 
在應用運行的時候

00:34:01.975 --> 00:34:03.944 
預取指令執行

00:34:04.011 --> 00:34:07.481 
從主存儲獲取數據
放入緩存中

00:34:09.116 --> 00:34:12.119 
當程序需要這些數據時

00:34:12.351 --> 00:34:14.855 
就可以很快很簡單的
從緩存中下載

00:34:14.922 --> 00:34:18.824 
程序就不需要再等待
數據從主存儲中下載

00:34:19.493 --> 00:34:21.728 
這就是軟件預取
所實現的魔法

00:34:25.032 --> 00:34:25.966 
到這兒....

00:34:32.139 --> 00:34:36.909 
我講的這個優化
是編譯器自動爲你做好的

00:34:37.911 --> 00:34:39.580 
下一個我要講的優化

00:34:39.713 --> 00:34:42.216 
非臨時存儲
是需要你幫助的

00:34:42.449 --> 00:34:47.855 
要了解怎麼回事
我們要看一看

00:34:47.920 --> 00:34:52.292 
數據存進主存儲的過程

00:34:54.261 --> 00:34:58.165 
那麼讓我們再來看看
存儲層次結構

00:34:58.232 --> 00:35:02.369 
假設程序要做一個簡單的任務

00:35:02.436 --> 00:35:05.105 
賦值的話
假設100

00:35:05.405 --> 00:35:09.810 
給主存儲變量
現在的值是55

00:35:10.711 --> 00:35:12.613 
第一件事就是

00:35:13.146 --> 00:35:16.650 
本想把新值存到的
舊數據的地址

00:35:16.717 --> 00:35:18.418 
加載到了緩存

00:35:19.920 --> 00:35:21.822 
由於我們從主存儲加載數據

00:35:21.889 --> 00:35:25.125 
不只是加載變量的舊數據

00:35:25.325 --> 00:35:28.562 
還有相鄰的數據

00:35:28.629 --> 00:35:30.564 
因爲我們填寫了整個緩存行

00:35:31.798 --> 00:35:36.570 
第二步
把值存入寄存器

00:35:37.104 --> 00:35:38.505 
存到緩存行

00:35:40.908 --> 00:35:41.909 
存到緩存裏

00:35:43.210 --> 00:35:44.645 
最後

00:35:44.711 --> 00:35:48.515 
緩存行的數據
或者是需要其他數據的緩存行

00:35:48.916 --> 00:35:52.419 
還有值會在第三步
從主存儲返回

00:35:52.686 --> 00:35:54.988 
所以總共是三步

00:35:56.089 --> 00:35:58.458 
從主存儲加載數據到緩存

00:35:58.525 --> 00:36:00.727 
緩存寄存器的值

00:36:00.794 --> 00:36:04.264 
最後將數據返回主存儲

00:36:05.866 --> 00:36:08.202 
這麼做的原因是數據

00:36:08.268 --> 00:36:12.472 
通常都有局部性
特別是時間局部性

00:36:12.840 --> 00:36:16.610 
但是如果你的數據
沒有空間局部性呢？

00:36:17.311 --> 00:36:22.549 
會不會能更快速
更方便的將值直接從

00:36:22.616 --> 00:36:26.653 
寄存器存入主存儲...

00:36:26.720 --> 00:36:27.554 
更快地儲存數據？

00:36:27.621 --> 00:36:29.389 
...只用一個步驟？

00:36:30.557 --> 00:36:34.228 
這正是非臨時存儲的做法

00:36:34.294 --> 00:36:36.897 
它能避免下載多餘的緩存行

00:36:37.497 --> 00:36:41.535 
還有一個好處就是

00:36:42.169 --> 00:36:47.107 
這個數據不再需要
不會再存入緩存

00:36:47.174 --> 00:36:50.611 
那麼緩存中就存儲其他數據
能對應用更有用

00:36:51.545 --> 00:36:53.447 
如何指令編譯器

00:36:53.514 --> 00:36:57.117 
生成非臨時存儲
是通過一個編譯器內置組件

00:36:57.184 --> 00:36:58.652 
非臨時存儲

00:36:59.686 --> 00:37:02.022 
那麼你用這個內置
來指令編譯器

00:37:02.089 --> 00:37:03.957 
生成非臨時存儲

00:37:04.091 --> 00:37:05.526 
這需要兩個參數

00:37:05.592 --> 00:37:09.830 
一個是你要存的值
一個是你要存的地址

00:37:11.532 --> 00:37:14.368 
什麼時候要用
非臨時存儲？

00:37:14.434 --> 00:37:17.437 
當沒有重複使用
沒有時間局部性

00:37:17.704 --> 00:37:21.642 
在你的代碼中
你可複製一大段數據

00:37:21.708 --> 00:37:24.178 
最好比緩存還多

00:37:24.745 --> 00:37:27.214 
讓應用更有價值

00:37:27.281 --> 00:37:29.149 
在性能缺失的地方

00:37:29.249 --> 00:37:30.751 
所以這必須是個熱循環

00:37:31.552 --> 00:37:33.854 
當全部條件無法滿足時

00:37:33.921 --> 00:37:36.723 
你不會想使用非臨時存儲

00:37:39.059 --> 00:37:40.460 
你能獲得什麼？

00:37:40.994 --> 00:37:42.296 
在這一張幻燈片

00:37:42.963 --> 00:37:47.334 
我們演示的是
非臨時存儲帶來的好處

00:37:47.401 --> 00:37:50.504 
從三個含有熱循環的
benchmark

00:37:50.571 --> 00:37:53.640 
這個看上去
跟我之前展示的例子差不多

00:37:54.041 --> 00:37:58.512 
所以這個數據告訴你
對於普遍的循環體

00:37:58.979 --> 00:38:05.219 
速度可以加快30%到40%

00:38:05.919 --> 00:38:08.155 
這就是非臨時存儲

00:38:08.222 --> 00:38:11.225 
可以爲應用熱循環所做的事情

00:38:19.499 --> 00:38:20.767 
這是個漫長的進程

00:38:21.735 --> 00:38:26.773 
我們看過了很多新特性
和很棒的新優化

00:38:27.474 --> 00:38:30.177 
都是新的編譯器提供給應用

00:38:30.444 --> 00:38:32.112 
我們也講了

00:38:32.179 --> 00:38:36.350 
Apple LLVM編譯器
是基於開放資源工程

00:38:36.416 --> 00:38:39.520 
你可以與我們互動
到我們的開放資源社區來

00:38:39.586 --> 00:38:42.189 
甚至提供一些補丁
給你喜愛的編譯器

00:38:42.689 --> 00:38:44.625 
我們看到了這麼多新的特性

00:38:44.691 --> 00:38:50.230 
比如objective類屬性
和C++線程本地存儲支持

00:38:50.531 --> 00:38:51.398 
現在...

00:38:52.099 --> 00:38:57.638 
新的Libc ++
完全支持C++14

00:38:57.871 --> 00:39:00.207 
而且有了許多新的改進特性

00:39:00.774 --> 00:39:04.511 
但是要記住
Libstandardc++是棄用的

00:39:05.012 --> 00:39:06.914 
現在有更多的警告和診斷

00:39:06.980 --> 00:39:09.016 
讓你的代碼
比以前更清楚

00:39:09.650 --> 00:39:12.386 
你也聽到了這個神奇的新特性

00:39:12.452 --> 00:39:16.056 
增量LTO
爲你提供一樣的性能

00:39:16.123 --> 00:39:20.027 
與單片集成LTO相比
而且編譯時間令人驚歎

00:39:20.494 --> 00:39:24.331 
之後我們講了一些
代碼生成優化

00:39:24.398 --> 00:39:28.268 
可以自動加速
所有應用的運行

00:39:28.702 --> 00:39:32.272 
最後我們講的是
長期的專業存儲

00:39:32.339 --> 00:39:34.408 
就是編譯器提供方法

00:39:34.842 --> 00:39:37.277 
而你用你的智慧
然後去使用他們

00:39:39.213 --> 00:39:41.148 
所以我希望這些能說服你

00:39:41.215 --> 00:39:43.984 
我們做的新編譯器
是一個真的很棒的版本

00:39:44.518 --> 00:39:46.386 
我們高興極了

00:39:46.453 --> 00:39:47.821 
請一定試一試

00:39:47.888 --> 00:39:50.490 
看看它能爲你的應用做什麼

00:39:53.060 --> 00:39:55.562 
你可以在我們網站上
找到更多信息

00:39:57.164 --> 00:40:00.267 
這裏還有更多
精彩的演講...

00:40:00.334 --> 00:40:01.401 
相關演講

00:40:01.468 --> 00:40:03.003 
...應該會讓你感興趣

00:40:03.136 --> 00:40:04.004 
關注一下

00:40:04.171 --> 00:40:05.606 
謝謝觀看

00:40:05.672 --> 00:40:06.707 
謝謝你們來到現場

00:40:07.207 --> 00:40:09.009 
祝你們在大會中過得愉快