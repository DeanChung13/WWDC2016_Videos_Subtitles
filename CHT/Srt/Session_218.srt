00:00:19.453 --> 00:00:24.892
讓Watch應用保持更新

00:00:32.566 --> 00:00:33.400
好的

00:00:33.467 --> 00:00:37.337
大家好 歡迎參加我們的演講
“讓Watch應用保持更新”

00:00:37.771 --> 00:00:41.642
我叫Eric Lanz 今天跟我
一起的還有Austen Green

00:00:41.808 --> 00:00:44.545
我們都是watchOS團隊的工程師

00:00:46.346 --> 00:00:49.349
這是一個日曆應用的截屏

00:00:49.516 --> 00:00:52.619
當你聽到應用這個詞時
你腦海中很可能會浮現這個畫面

00:00:53.554 --> 00:00:57.724
但watchOS還有很多超出
標準應用之外的互動方式

00:00:58.025 --> 00:01:01.428
比如 你的用戶認爲通知

00:01:01.495 --> 00:01:03.463
是你應用的一個重要部分

00:01:04.464 --> 00:01:07.534
如果你有complication
你的用戶會認爲

00:01:07.601 --> 00:01:09.636
那也是你應用的一個重要部分

00:01:10.971 --> 00:01:14.808
在watchOS 3中
我們引入了一個新的應用dock

00:01:15.175 --> 00:01:17.611
這個功能允許用戶添加多達十個

00:01:17.678 --> 00:01:21.348
應用到一個總是可見的dock中

00:01:21.682 --> 00:01:23.116
他們可以滑動瀏覽dock

00:01:23.183 --> 00:01:25.719
從dock中快速獲得所有數據

00:01:26.286 --> 00:01:28.755
這個現在已經成爲
應用的一個部分了

00:01:29.489 --> 00:01:31.959
人們以很多不同的方式使用你應用的數據

00:01:32.025 --> 00:01:34.828
並且希望所有這些方式

00:01:34.895 --> 00:01:37.664
都能一直同步和更新

00:01:38.165 --> 00:01:41.535
聽起來像是個不可能的任務
但不要擔心

00:01:41.602 --> 00:01:42.569
我們可以幫你們實現

00:01:44.438 --> 00:01:46.874
今天 我們要講五個話題

00:01:46.940 --> 00:01:50.911
第一 這個API的概述以及
它在watchOS上的使用

00:01:51.411 --> 00:01:55.315
第二 用真實代碼
演示一個示例應用

00:01:55.983 --> 00:01:57.918
第三 Austen將上臺

00:01:57.985 --> 00:02:00.888
演示預約在後臺是如何運行的

00:02:01.421 --> 00:02:03.590
第四 我們將分享一些最佳範例

00:02:03.657 --> 00:02:06.460
把這個API應用到你自己的應用中

00:02:06.894 --> 00:02:09.863
第五 我們將演示一個案例分析

00:02:09.930 --> 00:02:13.433
闡述我們是如何把這個API
應用到我們自己的股票應用中的

00:02:15.669 --> 00:02:19.573
首先 我們要思考的是我們
如何使用手機和表

00:02:19.640 --> 00:02:21.341
每天以不同的方式

00:02:22.876 --> 00:02:26.180
早上 你排隊買咖啡
開始新的一天

00:02:26.246 --> 00:02:28.849
你可以在手機上看幾分鐘新聞

00:02:29.483 --> 00:02:31.585
離開商店前 查一下天氣情況

00:02:31.652 --> 00:02:35.055
用錶盤上的complication
這是個兩秒鐘任務

00:02:36.456 --> 00:02:39.393
午飯時 再用地圖找一個不錯的餐廳

00:02:39.459 --> 00:02:42.462
幾分鐘後 你選好餐廳 收起電話

00:02:43.530 --> 00:02:46.033
在去餐廳的路上
你收到一條通知

00:02:46.099 --> 00:02:48.302
你快速地瞥了一眼手腕
你知道你的朋友們

00:02:48.368 --> 00:02:51.505
會晚幾分鐘到
這是另一個兩秒鐘任務

00:02:53.307 --> 00:02:57.144
在今天結束的時候 你再次使用
地圖規劃一下路線 你可能會改道

00:02:58.612 --> 00:03:01.582
你收到一條iMessage
詢問你今晚何時到家

00:03:02.115 --> 00:03:05.452
你使用watchOS 3的
快速回復功能回信息

00:03:05.519 --> 00:03:08.522
“在路上” 又一個兩秒鐘任務

00:03:10.057 --> 00:03:12.960
幾乎不可能在幾秒鐘之內

00:03:13.026 --> 00:03:15.696
把用戶即將傳給我們的數據準備好

00:03:15.762 --> 00:03:16.897
我們需要更長的時間

00:03:17.297 --> 00:03:19.399
在後臺進行刷新

00:03:19.900 --> 00:03:23.203
你可以通過這個強大的
新API預約運行時間

00:03:23.270 --> 00:03:26.507
這樣 在用戶需要這些數據之前
數據能提前準備好

00:03:30.511 --> 00:03:34.314
要了解這個新API的功能
讓我們仔細看一下

00:03:34.381 --> 00:03:36.416
在watchOS上查詢天氣情況

00:03:36.884 --> 00:03:40.687
這裏 我們看到查詢天氣
complication的前臺活動

00:03:41.221 --> 00:03:44.057
在查詢發生之前
我們就要準備好數據

00:03:44.992 --> 00:03:49.129
讓我們用這個API來預約查詢
發生之前的某個時間來更新UI

00:03:49.830 --> 00:03:52.366
但是 沒有數據該如何更新UI呢

00:03:52.766 --> 00:03:56.203
我們需要更多時間從服務器上
獲取最新的天氣數據

00:03:56.270 --> 00:03:57.838
爲此 我們要計劃一個任務

00:03:58.572 --> 00:04:01.308
但是 我們要怎麼着手
處理這一系列的事件呢？

00:04:01.675 --> 00:04:06.046
我們需要一種方式
使系統在後臺喚醒我們的應用

00:04:07.714 --> 00:04:11.818
在watchOS上 系統通過
給應用分配任務喚醒應用

00:04:12.386 --> 00:04:15.055
系統所能分配的任務有限

00:04:15.122 --> 00:04:17.357
所以你要充分利用
你得到的每一個任務

00:04:18.625 --> 00:04:20.928
當系統要喚醒你的應用時

00:04:20.994 --> 00:04:23.830
它會交付一個或幾個任務對象

00:04:24.198 --> 00:04:25.766
請一定要守住這個任務

00:04:25.832 --> 00:04:27.901
直到完成數據處理

00:04:29.169 --> 00:04:30.604
系統 交付任務

00:04:30.671 --> 00:04:33.607
通過調用已處理的
新後臺任務方法

00:04:33.674 --> 00:04:35.509
在WK擴展委託上

00:04:36.176 --> 00:04:38.712
稍後我們將演示
這個方法的一個示例

00:04:40.147 --> 00:04:41.882
當你完成後臺工作後

00:04:41.949 --> 00:04:44.818
完成任務並把任務返回給系統

00:04:44.885 --> 00:04:46.553
這就是基本流程

00:04:46.620 --> 00:04:49.756
你可以通過這個流程
在watchOS上獲得後臺運行時間

00:04:51.725 --> 00:04:54.361
現在 我們要從一個更高的層次
來瞭解任務系統

00:04:54.428 --> 00:04:57.130
讓我們再深入地看一下
具體的任務類型

00:04:57.197 --> 00:04:59.066
系統可以創建的

00:05:00.100 --> 00:05:02.402
首先 這是個應用任務

00:05:02.803 --> 00:05:05.806
這是個通用的運行時間任務
你可以預約

00:05:05.873 --> 00:05:08.442
在將來某一個日期喚醒應用

00:05:10.043 --> 00:05:14.214
在應用任務的運行時間內
你可以進行任何形式的本地處理

00:05:14.648 --> 00:05:17.217
你可能想
更新complication時間線

00:05:17.284 --> 00:05:20.320
或用URLSession
從服務器上下載數據

00:05:21.355 --> 00:05:23.757
URLSession任務是如何得知

00:05:23.824 --> 00:05:26.760
數據已下載完成並等待處理

00:05:27.794 --> 00:05:31.398
由於watchOS是個共享的
生態系統 沒有任何意義

00:05:31.465 --> 00:05:34.468
在數據下載時使應用保持運行

00:05:34.968 --> 00:05:37.371
最好是讓應用休眠

00:05:37.437 --> 00:05:39.506
那麼就讓系統替我們實現吧

00:05:41.008 --> 00:05:44.478
快照是watchOS上的一個
非常重要的部分

00:05:45.045 --> 00:05:46.613
它們既是你的啓動畫面

00:05:47.114 --> 00:05:49.316
又是在dock中運行時的預覽畫面

00:05:50.050 --> 00:05:52.986
如果用戶停留在你的應用上
你的應用將再次甦醒並運行

00:05:53.053 --> 00:05:56.823
關鍵是你的快照要持續更新

00:05:58.692 --> 00:06:02.196
快照任務是如何
獲得在後臺準備UI的運行時間

00:06:02.262 --> 00:06:05.098
並獲取新快照

00:06:08.368 --> 00:06:09.837
當你完成這個任務後

00:06:09.903 --> 00:06:12.606
系統會自動給UI創建快照

00:06:13.140 --> 00:06:16.810
請記住 完成數據處理後
一定要預約一個任務

00:06:16.877 --> 00:06:19.346
否則用戶就看不到
你剛剛所做的工作

00:06:20.614 --> 00:06:23.417
當通知到達時 用戶會看到通知

00:06:23.483 --> 00:06:26.854
然後他們會期待
你的complication和快照

00:06:26.920 --> 00:06:28.922
更新並顯示最新數據

00:06:29.523 --> 00:06:33.627
用戶喜歡那些感覺像是OS
密不可分的一部分一樣的應用

00:06:33.694 --> 00:06:36.396
並且他們把那些應用
放進dock中的可能性更大

00:06:38.599 --> 00:06:42.669
如果用戶有一個小時以上
不跟你的應用進行互動

00:06:42.736 --> 00:06:44.972
系統就會給你一個機會

00:06:45.038 --> 00:06:46.640
來修復你的缺省狀態

00:06:47.841 --> 00:06:50.511
缺省狀態對於不同的應用來說
含義不同

00:06:50.577 --> 00:06:53.313
有些應用沒有缺省狀態的概念

00:06:56.216 --> 00:07:00.687
在watchOS 3上設計精美快照
是個很大、很重要的話題

00:07:01.021 --> 00:07:03.423
我們建議你參加一些
其他相關的演講

00:07:03.490 --> 00:07:07.294
瞭解如何創建優秀
快照的一些設計建議

00:07:09.263 --> 00:07:12.099
最後一個任務類型是表連通性

00:07:12.633 --> 00:07:16.036
在watchOS 3上
我們整合了表連通性

00:07:16.103 --> 00:07:18.305
和後臺刷新API

00:07:19.072 --> 00:07:22.442
意思是 你現在可以使用
表連通性消息

00:07:22.509 --> 00:07:26.313
把數據更新到應用中
當應用在後臺運行時

00:07:28.582 --> 00:07:31.885
complication推送
應用情境、發送文件

00:07:31.952 --> 00:07:35.522
或發送用戶信息
都將在後臺喚醒應用

00:07:36.123 --> 00:07:37.858
我們希望這個版本會帶給

00:07:37.925 --> 00:07:41.161
我們的用戶更豐富的體驗

00:07:42.663 --> 00:07:46.133
當應用通過表連通性任務
被喚醒時

00:07:46.934 --> 00:07:49.303
使用標準API來獲取數據

00:07:49.736 --> 00:07:52.005
首先 確保會話是激活的

00:07:53.373 --> 00:07:54.908
一旦會話被重新激活

00:07:54.975 --> 00:07:58.378
就開始監控
新的hasContentPending屬性

00:07:59.046 --> 00:08:02.449
只要這個屬性爲真
就表示仍有數據要處理

00:08:02.950 --> 00:08:04.384
確保要一直守住這個任務

00:08:04.451 --> 00:08:06.553
直到完成數據處理

00:08:07.754 --> 00:08:10.290
完成時 你有責任將任務

00:08:10.357 --> 00:08:12.292
返回給系統

00:08:12.860 --> 00:08:15.963
如果你不這樣做
你將不會再獲得後臺運行時間

00:08:16.029 --> 00:08:17.998
並且我們會給你一個崩潰報告

00:08:19.099 --> 00:08:21.902
Austen稍後會提供詳細信息

00:08:21.969 --> 00:08:23.837
是關於運行時間警告的信息

00:08:25.405 --> 00:08:29.977
讓我們快速回顧一下
新後臺刷新API的使用流程

00:08:30.344 --> 00:08:33.013
首先 預約一個任務

00:08:33.847 --> 00:08:36.015
然後 接收系統任務

00:08:36.917 --> 00:08:38.619
現在你就可以進行後臺工作了

00:08:38.885 --> 00:08:42.121
一定要守住這個任務
直到完成後臺工作

00:08:42.890 --> 00:08:45.526
你可以利用這個運行時間
預約後續工作

00:08:45.592 --> 00:08:48.395
比如使用URLSession
從服務器獲取數據

00:08:49.863 --> 00:08:54.134
結束後 完成任務
並把任務返回給系統

00:08:56.803 --> 00:09:01.775
在繼續演講之前 我想強調一件
非常重要的事兒 就是做一個好公民

00:09:03.243 --> 00:09:07.147
watchOS是一個共享的生態系統
有許多應用

00:09:07.214 --> 00:09:10.984
和系統進程爭奪CPU時間
和電池壽命

00:09:11.451 --> 00:09:15.022
在這個生態系統中
我們作爲開發人員有責任

00:09:15.088 --> 00:09:18.058
盡最大努力有效地使用這些資源

00:09:18.825 --> 00:09:21.628
假如用戶在下午3點
啓動了你的應用

00:09:22.563 --> 00:09:25.899
你想確保在一個小時內有機會
跟服務器進行覈對

00:09:25.966 --> 00:09:27.901
那你就預約一個下午4點的任務

00:09:28.735 --> 00:09:32.072
嗯 如果用戶在下午3點50分
啓動了應用會怎麼樣呢？

00:09:33.073 --> 00:09:35.909
我們可以立即更新數據

00:09:35.976 --> 00:09:39.046
四點鐘當任務運行時再次更新數據 但這對於
我來說並不是最理想的方案

00:09:40.280 --> 00:09:43.450
最好的方法是在3點50分
利用運行時間

00:09:43.517 --> 00:09:47.254
重新預約一個小時後的後臺任務
也就是4點50分的任務

00:09:48.088 --> 00:09:49.256
每個應用都不一樣

00:09:49.323 --> 00:09:53.260
但我們希望你們能找到一個
這樣的模式 使資源最大化

00:09:54.995 --> 00:09:56.897
好了 讓我們看點兒代碼吧

00:09:57.865 --> 00:09:59.466
爲了幫助設計示例代碼

00:09:59.533 --> 00:10:02.636
我們將按照時間線
逐步演示一個示例應用

00:10:02.703 --> 00:10:04.505
並展示如何寫代碼

00:10:04.571 --> 00:10:07.274
來響應所有生命週期事件

00:10:07.808 --> 00:10:09.610
讓我們看一個足球應用

00:10:09.810 --> 00:10:13.881
假如今晚7點到9點
有一場重要比賽

00:10:14.882 --> 00:10:17.284
我們知道用戶最鍾愛的球隊
會參加比賽

00:10:17.351 --> 00:10:20.187
並且我們認爲他們一定
會頻繁地查看比分

00:10:20.587 --> 00:10:24.358
讓我們給後臺活動選定一個
三十分鐘的節奏

00:10:25.626 --> 00:10:29.463
後臺刷新API只能允許
每種類型有一個任務

00:10:29.530 --> 00:10:31.765
是執行狀態 在任何特定時間內

00:10:32.299 --> 00:10:36.103
一開始 我們預約第一個任務的
時間是7點半

00:10:37.171 --> 00:10:41.341
在7點半 我們將使用所得到的運行
時間預約下一個任務 時間爲8點

00:10:42.142 --> 00:10:46.480
8點時 我們將再次使用所得到的運行
時間預約下一個事件 時間是8點半

00:10:46.914 --> 00:10:50.284
一直確保預約未來任務非常重要

00:10:50.350 --> 00:10:53.287
否則你就不知道什麼時候
纔能有機會再運行

00:10:55.355 --> 00:10:59.793
在此 我們看到了在watchOS上
預約應用任務的代碼

00:11:00.227 --> 00:11:03.397
首先 讓我們把任務時間
設定爲三十分鐘以後

00:11:04.565 --> 00:11:08.936
使用userInfo對象來存儲某些
關於爲何做出請求的數據

00:11:09.369 --> 00:11:12.706
在這個例子中
我存了發起請求的日期

00:11:12.773 --> 00:11:16.810
和當任務返回時
能稍後查看原因的一個字符串

00:11:17.377 --> 00:11:18.745
這個屬性是可選的

00:11:18.812 --> 00:11:22.082
可以在這裏存儲任何
安全編碼的兼容數據

00:11:23.951 --> 00:11:26.587
這個完成日誌是獲知

00:11:26.653 --> 00:11:30.324
系統是否已經成功預約任務的

00:11:31.058 --> 00:11:33.093
請注意 正因爲這裏沒有報錯

00:11:33.160 --> 00:11:36.663
但這也並不意味着任務
會按所請求的時間運行

00:11:37.598 --> 00:11:41.902
Austen將爲大家解釋何時及爲何
系統觸發指定任務

00:11:43.837 --> 00:11:47.007
預約應用任務後
讓我們把重點放在時間線上

00:11:47.074 --> 00:11:50.811
看這個只有五分鐘的窗口
預約任務將在這個窗口中運行

00:11:52.546 --> 00:11:53.847
當系統喚醒應用時

00:11:53.914 --> 00:11:56.817
我們優先考慮的是
從服務器獲取最新比分數據

00:11:57.084 --> 00:11:58.452
讓我們看一下代碼

00:11:58.519 --> 00:12:01.588
在watchOS上
開始後臺URLSession的

00:12:06.193 --> 00:12:09.329
首先 創建一個
URLSession配置對象

00:12:09.696 --> 00:12:11.765
重點是把這個對象配置爲

00:12:11.832 --> 00:12:14.801
後臺會話 因爲我們要在後臺運行

00:12:16.236 --> 00:12:20.007
同時設置一個標識符
稍後用來獲取數據

00:12:22.075 --> 00:12:25.546
接下來 用這個配置
創建一個URL會話

00:12:26.847 --> 00:12:31.251
我們要求URLSession提供
一個或多個下載任務對象

00:12:31.919 --> 00:12:35.589
可以給會話關聯多個下載任務
想關聯多少就關聯多少

00:12:35.889 --> 00:12:40.661
請謹記 系統只能在完成所有
關聯任務後纔會喚醒應用

00:12:42.863 --> 00:12:45.966
要開始下載數據
請不要忘記調用重新啓動

00:12:48.602 --> 00:12:51.672
返回時間線
我們在過程中下載了URL

00:12:51.738 --> 00:12:55.375
所以完成任務
和使應用休眠是很安全的

00:12:56.076 --> 00:12:58.445
系統將繼續下載數據

00:12:58.512 --> 00:12:59.813
當我們被掛起時

00:13:01.248 --> 00:13:04.351
當數據下載完成後
URLSession會創建一個任務

00:13:04.418 --> 00:13:06.253
並再次喚醒應用

00:13:06.720 --> 00:13:09.489
但是 到底什麼是喚醒應用呢？

00:13:10.791 --> 00:13:14.061
具體地說 喚醒應用的意思就是

00:13:14.127 --> 00:13:18.932
在WKExtensionDelegate上調用
新的處理後臺任務方法

00:13:20.400 --> 00:13:21.635
除了這個調用

00:13:21.702 --> 00:13:25.239
我們還將收到是否在可見視圖
控制器上激活調用

00:13:26.673 --> 00:13:30.344
系統合併任務
並提交給我們一個任務集

00:13:30.777 --> 00:13:33.247
我們需要處理
這個任務集中的所有任務

00:13:33.313 --> 00:13:35.349
讓我們開始依次處理吧

00:13:36.283 --> 00:13:39.253
對於每個任務來說
我們可以使用一個內聯任務

00:13:39.319 --> 00:13:41.622
來得到我們想得到的類型的對象

00:13:42.823 --> 00:13:45.425
在這個例子中 要處理一個
URLSession任務

00:13:45.492 --> 00:13:50.430
那麼我們需要使用
和任務關聯的標識符再次加入會話

00:13:52.232 --> 00:13:55.202
URLSession
是一個高度異步API

00:13:55.269 --> 00:13:57.571
我們一定要注意守住任務

00:13:57.638 --> 00:13:59.773
直到完成數據處理

00:14:00.474 --> 00:14:03.076
我們建議你把任務存在一個集合中

00:14:03.143 --> 00:14:04.945
完成後再遣散集合

00:14:05.012 --> 00:14:08.315
完成每個任務
並把它返回給系統

00:14:10.517 --> 00:14:13.654
一定要完成那些
未特別處理的任務類型

00:14:14.188 --> 00:14:16.657
請記住 系統的任務數量有限

00:14:16.757 --> 00:14:18.525
所以要完成你得到的每個任務

00:14:20.327 --> 00:14:22.596
我們已經得到了數據
讓我們更新模型吧

00:14:22.863 --> 00:14:26.099
你可能會考慮
在這個時候一起更新UI

00:14:26.166 --> 00:14:29.203
但我們建議你充分利用
這個快照任務的運行時間

00:14:29.269 --> 00:14:30.437
進行數據處理這樣的工作

00:14:31.271 --> 00:14:33.574
因此 在完成URL任務之前

00:14:33.640 --> 00:14:35.576
要先確保預約創建快照

00:14:37.344 --> 00:14:40.514
預約創建快照後再完成URL任務
就安全了

00:14:40.581 --> 00:14:42.783
並允許應用再次休眠

00:14:44.351 --> 00:14:49.223
很快 系統將通過我們剛預約的
快照任務再次喚醒應用

00:14:49.957 --> 00:14:52.159
現在是時候更新UI了

00:14:52.226 --> 00:14:54.728
並準備好創建新快照所需的東西

00:14:56.597 --> 00:14:59.266
快照有一個獨特的完成處理器

00:14:59.333 --> 00:15:01.435
讓我們來看看這個
完成處理器

00:15:01.502 --> 00:15:03.136
在watchOS上處理快照

00:15:05.005 --> 00:15:08.709
無論什麼時候
每個應用都必須有一個快照

00:15:09.142 --> 00:15:12.012
這是因爲快照既是啓動畫面

00:15:12.346 --> 00:15:14.548
又是在dock中運行時的預覽畫面

00:15:15.415 --> 00:15:17.885
這個規則的意思是當創建快照後

00:15:18.619 --> 00:15:21.555
我們要通知系統
這個快照的有效期

00:15:22.356 --> 00:15:26.159
要考慮數據及數據與用戶
相關性的時間長度

00:15:26.994 --> 00:15:29.663
在這個例子中
我們在八點有一個預約事件

00:15:29.730 --> 00:15:32.399
讓我們把有效時間設爲三十分鐘

00:15:35.235 --> 00:15:37.704
可以在用戶信息中隨意存儲一些
這樣的信息

00:15:37.771 --> 00:15:39.473
比如爲何發起這次請求

00:15:39.740 --> 00:15:43.043
那個數據將爲我們返回
下一個快照任務

00:15:45.746 --> 00:15:48.882
watchOS將給應用提供
的機會

00:15:48.949 --> 00:15:52.452
還原缺省狀態 在休止一個小時後

00:15:53.020 --> 00:15:55.522
你可以告訴系統跳過那個事件

00:15:55.589 --> 00:15:58.825
通過把restoredDefaultState
屬性的值設爲真

00:15:59.626 --> 00:16:03.197
這樣就會使系統瞭解
你已經是缺省狀態了

00:16:03.263 --> 00:16:05.098
不需要額外任務了

00:16:06.066 --> 00:16:08.502
沒有缺省狀態概念的應用

00:16:08.569 --> 00:16:11.405
應該考慮一直把這個屬性設爲真

00:16:13.106 --> 00:16:17.010
完成快照任務後 系統將掛起應用

00:16:17.444 --> 00:16:19.880
然後自動抓取UI

00:16:19.947 --> 00:16:21.682
並用作新的啓動畫面

00:16:22.349 --> 00:16:25.118
這將不會喚醒你的應用

00:16:27.554 --> 00:16:30.257
我們通過 端對端示例實現

00:16:30.324 --> 00:16:34.194
常見後臺刷新模式
和所關聯代碼

00:16:34.862 --> 00:16:36.163
提醒一下

00:16:36.230 --> 00:16:39.099
雖然我們看到時間線上是五分鐘

00:16:39.533 --> 00:16:43.070
我們的應用總共
也只能活躍15秒

00:16:44.037 --> 00:16:45.205
通過任務鏈

00:16:45.272 --> 00:16:48.675
我們可以最大限度地
利用系統資源

00:16:49.977 --> 00:16:53.580
現在 你應該對這個新API
是什麼有了更好的理解

00:16:54.581 --> 00:16:56.183
爲什麼要使用它

00:16:56.250 --> 00:16:58.252
以及怎麼使用它

00:16:59.720 --> 00:17:02.422
接下來 讓我們歡迎
Austen Green上臺

00:17:02.489 --> 00:17:04.023
給大家深入介紹

00:17:04.090 --> 00:17:06.393
預約是如何在後臺運作的

00:17:09.396 --> 00:17:10.430
祝你好運

00:17:13.834 --> 00:17:15.569
大家好
我是Austen Green

00:17:15.636 --> 00:17:17.104
我是一名watchOS工程師

00:17:17.337 --> 00:17:21.675
今天上午 我要跟大家分享一些
的信息

00:17:21.742 --> 00:17:24.243
關於預約如何在後臺運作

00:17:24.645 --> 00:17:27.948
我會提供一些
精挑細選的最佳範例

00:17:28.015 --> 00:17:30.817
我們在我們自己的應用中
使用後臺刷新時

00:17:31.151 --> 00:17:33.554
最後 結束之前
還要做一個快速的案例分析

00:17:33.620 --> 00:17:36.356
是關於如何 應用後臺刷新的

00:17:36.423 --> 00:17:37.691
在我們的股票應用中

00:17:38.859 --> 00:17:39.860
讓我們開始吧

00:17:42.763 --> 00:17:45.499
我要講的第一點是運行時間

00:17:46.233 --> 00:17:49.069
應用在前臺

00:17:50.037 --> 00:17:51.605
一直是運行狀態

00:17:51.939 --> 00:17:55.175
意思是會開始執行你的代碼

00:17:55.242 --> 00:17:59.146
你可以進行像更新模型
和繪製UI這樣的工作

00:17:59.213 --> 00:18:02.082
以及應用可能需要
進行的其他各種任務

00:18:03.317 --> 00:18:05.886
當你的應用進入後臺時

00:18:05.953 --> 00:18:08.655
系統一般會掛起你的應用

00:18:08.889 --> 00:18:12.526
意思是 你的應用不再有機會
執行任何代碼了

00:18:13.927 --> 00:18:16.964
有時候 當應用在後臺時

00:18:17.030 --> 00:18:20.734
系統可能希望應用
能實施一項特定的任務

00:18:20.801 --> 00:18:23.971
此時系統將喚醒應用

00:18:24.037 --> 00:18:27.541
並要求應用實施
它想要應用實施的特定任務

00:18:27.975 --> 00:18:29.276
在watchOS 2中

00:18:29.843 --> 00:18:32.713
系統有許多方式來喚醒應用

00:18:32.779 --> 00:18:36.316
比如處理需要仔細看的通知

00:18:37.017 --> 00:18:39.686
或也許ClockKit會要求應用

00:18:39.753 --> 00:18:41.154
更新complication

00:18:41.788 --> 00:18:44.191
在watchOS 3中
我們增加了更多的方式

00:18:44.258 --> 00:18:46.126
使應用在後臺運行

00:18:50.063 --> 00:18:54.301
系統要限制 時間

00:18:54.368 --> 00:18:56.403
在後臺運行的

00:18:58.071 --> 00:19:00.707
時間的單位是秒

00:19:01.041 --> 00:19:04.578
系統會考慮你所使用的時間

00:19:04.645 --> 00:19:06.980
以及你所使用的CPU

00:19:07.047 --> 00:19:10.050
所以 儘快、
完成工作才能獲得最大利益

00:19:10.117 --> 00:19:11.852
儘可能有效地

00:19:13.053 --> 00:19:16.190
在隨後的種子中
如果你超出了限制

00:19:16.323 --> 00:19:18.125
系統將會扼殺你的應用

00:19:18.525 --> 00:19:19.693
你將得到一份崩潰報告

00:19:19.760 --> 00:19:22.429
從而瞭解是否超出CPU限制

00:19:22.663 --> 00:19:26.733
或時間限制
根據崩潰報告中的異常碼

00:19:28.435 --> 00:19:32.706
我們意識到 不同的任務
可能有不同的需要

00:19:32.840 --> 00:19:34.708
所以ApplicationRefresh任務

00:19:34.775 --> 00:19:38.612
和URLSession任務
的時間限制要長

00:19:38.946 --> 00:19:41.548
比表連通性和快照任務

00:19:52.359 --> 00:19:56.496
那麼在watchOS 2中
complication是

00:19:56.563 --> 00:19:58.932
應用在後臺獲得運行時間的主要方式

00:19:59.967 --> 00:20:01.168
watchOS 3中

00:20:01.235 --> 00:20:04.204
我們要確保你繼續每小時
進行多次更新

00:20:04.271 --> 00:20:06.173
若是帶complication應用

00:20:06.240 --> 00:20:08.709
與在watchOS 2上一樣

00:20:09.510 --> 00:20:13.413
然而 如果你提前向系統
請求運行時間

00:20:13.480 --> 00:20:15.249
更新complication數據

00:20:15.549 --> 00:20:18.118
你現在可請求通過
WKExtension進行更新了

00:20:18.185 --> 00:20:19.987
稍後我會講一下如何實現

00:20:20.988 --> 00:20:22.789
另外 watchOS 3的新功能是

00:20:22.856 --> 00:20:26.493
我們確保有來自
父類iPhone的五十次push

00:20:27.494 --> 00:20:29.229
如果你使用表連通性的話

00:20:29.530 --> 00:20:32.699
利用這個信息可以很簡單地

00:20:32.766 --> 00:20:36.036
確保提供很棒的
complication體驗

00:20:36.103 --> 00:20:38.105
全天候爲你的用戶

00:20:38.639 --> 00:20:40.107
讓我們來看一些代碼

00:20:41.975 --> 00:20:45.646
假如你正運行一個iPhone應用

00:20:46.046 --> 00:20:47.881
並且你注意到模型發生了變更

00:20:48.582 --> 00:20:50.884
你可以查詢WCSession

00:20:50.951 --> 00:20:53.153
remainingComplication
UserInfoTransfers

00:20:53.220 --> 00:20:56.823
來瞭解
你還剩多少高優先級的push

00:20:56.890 --> 00:20:58.725
今天剩下的時間

00:20:59.793 --> 00:21:01.228
你可以利用這個信息

00:21:01.295 --> 00:21:03.564
打造complication體驗

00:21:03.630 --> 00:21:07.100
決定何時是發送
complication數據的最佳時間

00:21:08.035 --> 00:21:09.970
比如說在默認情況下

00:21:10.604 --> 00:21:12.105
你有足夠多的push

00:21:12.673 --> 00:21:14.341
那就立即發送數據

00:21:14.408 --> 00:21:18.478
用戶幾乎會立即看到最相關的數據

00:21:19.479 --> 00:21:21.882
假如你已經push了很多次

00:21:21.949 --> 00:21:24.551
並且運行有點兒慢 傳輸有點兒慢

00:21:24.751 --> 00:21:30.090
你可能會考慮節制發送給表的數據
從而確保

00:21:30.157 --> 00:21:34.061
你的用戶得到
complication的數據更新

00:21:34.127 --> 00:21:35.596
在當天剩餘的時間內

00:21:36.864 --> 00:21:40.801
最後 如果你沒有任何
高優先級的傳輸了

00:21:40.868 --> 00:21:43.971
仍然可以嘗試和發送數據 但是

00:21:44.037 --> 00:21:46.406
數據會以較低的優先級發送

00:21:49.076 --> 00:21:50.711
接下來 我要講

00:21:50.777 --> 00:21:53.247
一些CLKComplication
DataSource方法

00:21:53.313 --> 00:21:56.383
我們想要搬到WatchKit中去的

00:21:57.117 --> 00:22:00.787
如果你
提前向系統請求運行時間

00:22:00.854 --> 00:22:03.056
通過getNextRequestedUpdateDate

00:22:05.926 --> 00:22:10.564
你應該希望系統預約後臺刷新

00:22:10.631 --> 00:22:14.835
的日期跟你之前
通知ClockKit的日期相同

00:22:16.136 --> 00:22:19.706
類似的
當ClockKit想讓你的應用運行時

00:22:19.773 --> 00:22:21.909
它會調用
requestedUpdateDidBegin

00:22:22.676 --> 00:22:25.946
現在 我們希望在應用層級來實現

00:22:26.013 --> 00:22:29.049
通過刷新處理後臺或
處理backgroundTasks

00:22:29.149 --> 00:22:30.617
你會得到一個應用任務

00:22:31.118 --> 00:22:35.189
處理complication
更新和應用更新

00:22:37.658 --> 00:22:41.361
在watchOS 3中
我們引入了dock

00:22:41.428 --> 00:22:45.899
我們認爲這很棒 可以使用戶快速
獲取他們所喜歡的應用的數據

00:22:45.966 --> 00:22:49.436
並方便地查看
他們所關注的所有信息

00:22:50.637 --> 00:22:53.574
我們希望dock中的應用數據
保持最新

00:22:53.640 --> 00:22:56.476
因此我們要保證每小時
至少更新一次

00:22:56.543 --> 00:23:00.113
這適用於快照任務和應用刷新任務

00:23:01.181 --> 00:23:05.719
現在這個預算分散到了
dock中的所有應用

00:23:06.186 --> 00:23:09.122
用戶可以選擇
在dock中放多少應用

00:23:09.623 --> 00:23:12.893
結果就是如果用戶的dock中
應用的數量少

00:23:13.327 --> 00:23:16.163
那麼你的應用某特定小時內就有更多

00:23:16.230 --> 00:23:18.665
在後臺運行的機會

00:23:19.700 --> 00:23:22.269
另外 我們會把應用留在內存中

00:23:22.736 --> 00:23:26.306
可以迅速重新啓動 用戶還可以
跟你的應用互動

00:23:26.373 --> 00:23:28.809
如果用戶停留在你的應用上
儘可能快地

00:23:30.878 --> 00:23:34.281
另外在dock中 我們有一個
最近使用的應用的概念

00:23:35.582 --> 00:23:38.051
這個應用佔據了dock的
最後一個位置

00:23:38.485 --> 00:23:41.555
並且用戶有機會
把它放進dock中

00:23:42.222 --> 00:23:43.257
通過按按鈕

00:23:44.157 --> 00:23:48.695
對這個應用的處理跟
應用的處理方式完全相同

00:23:48.762 --> 00:23:51.031
用戶明確添加到dock中的

00:23:52.065 --> 00:23:55.035
意思就是這個應用

00:23:55.102 --> 00:23:58.138
將收到後臺刷新任務和快照任務

00:23:58.205 --> 00:24:00.073
就像dock中的其他應用一樣

00:24:00.574 --> 00:24:02.976
所以你要確保一直 預約

00:24:03.043 --> 00:24:04.978
跟系統預約 任何應用、

00:24:05.045 --> 00:24:07.681
任何後臺刷新請求 你可能需要的

00:24:09.483 --> 00:24:12.986
有些主屏幕應用不需要定期預約

00:24:14.021 --> 00:24:15.455
請記住這一點

00:24:18.125 --> 00:24:21.828
剛纔Eric也提到了
你應用的快照

00:24:22.663 --> 00:24:27.467
對於watchOS 3上的
dock中的應用體驗來說至關重要

00:24:28.902 --> 00:24:32.506
有時候 系統需要應用快照

00:24:33.340 --> 00:24:34.708
的原因各種各樣

00:24:35.943 --> 00:24:38.111
如果系統要求你的應用

00:24:38.178 --> 00:24:40.714
創建快照是因爲我們認爲
我們需要一個快照

00:24:41.181 --> 00:24:43.016
這些快照將不會計入你的預算中

00:24:43.383 --> 00:24:46.320
並且不含在
所請求的快照數量之內

00:24:46.386 --> 00:24:47.821
你向系統

00:24:48.455 --> 00:24:51.458
有五個觸發器可以導致系統

00:24:51.525 --> 00:24:53.293
嚮應用要求創建快照

00:24:54.761 --> 00:24:56.797
complication時間線更新

00:24:57.764 --> 00:25:00.300
用戶與你的其中一條通知互動

00:25:00.701 --> 00:25:03.704
意思是通知被積極地解除

00:25:03.770 --> 00:25:06.373
並且 如果通知進入通知中心
將不計數

00:25:07.808 --> 00:25:10.077
當應用從前臺進入到後臺時

00:25:10.143 --> 00:25:13.347
然後再一次 一個小時之後再
提供給應用一個返回 的機會

00:25:13.413 --> 00:25:15.549
到缺省狀態 如果適用的話

00:25:16.550 --> 00:25:19.286
最後 爲了讓一切開始運作

00:25:19.353 --> 00:25:22.523
系統會要求你的應用在啓動時
創建一個快照

00:25:23.023 --> 00:25:24.191
這是你的機會

00:25:24.258 --> 00:25:27.628
可以開始預約系統的
其他後臺刷新任務

00:25:31.798 --> 00:25:36.069
現在 我想花點兒時間
分享一些最佳範例

00:25:36.136 --> 00:25:37.638
是我們精心挑選的

00:25:37.704 --> 00:25:40.807
在自己的應用上應用後臺刷新

00:25:43.410 --> 00:25:46.380
首先 系統想要了解

00:25:46.446 --> 00:25:48.649
與你的需求相關的
儘可能多的信息

00:25:48.715 --> 00:25:50.751
所以 如果需要 就頻繁地預約

00:25:51.418 --> 00:25:53.720
應用每獲得一個運行的機會

00:25:53.787 --> 00:25:56.990
你都應該考慮重新評估
後臺刷新需求

00:25:57.057 --> 00:25:59.793
並適當地預約系統任務

00:26:01.328 --> 00:26:03.764
然而 你不應該覺得
你有義務這樣做

00:26:03.830 --> 00:26:06.900
如果系統把你的應用調回來
進行後臺刷新任務

00:26:07.334 --> 00:26:10.204
並沒有任何意義
也許你剛更新過數據

00:26:10.604 --> 00:26:13.540
需要進行其他工作 要儘快完成

00:26:13.974 --> 00:26:14.808
或者最好是

00:26:16.276 --> 00:26:18.111
當你完成那項工作後

00:26:18.178 --> 00:26:22.816
考慮推遲你已經跟系統預約好的
其他任務

00:26:24.218 --> 00:26:26.520
你應該考慮你得到的所有運行時間

00:26:26.587 --> 00:26:29.690
並確保使應用保持最新數據

00:26:29.756 --> 00:26:32.025
意思是 更新模型和UI

00:26:32.092 --> 00:26:34.528
並預約系統的後臺任務

00:26:34.962 --> 00:26:37.598
因此是爲了dock
和前臺激活、通知、

00:26:37.664 --> 00:26:39.499
complication更新
和後臺刷新

00:26:39.566 --> 00:26:43.170
應用獲得運行時間的原因
有很多很多

00:26:43.237 --> 00:26:45.305
你應該全部都考慮到

00:26:45.372 --> 00:26:47.241
當你嘗試和保持應用數據最新時

00:26:48.942 --> 00:26:54.715
應用刷新後臺任務
就是你的切入點

00:26:54.948 --> 00:26:58.118
切入通用的意圖運行時間
當你在後臺時

00:26:58.452 --> 00:27:00.721
我們認爲有一些非常不錯的用例

00:27:00.787 --> 00:27:03.824
你可以執行如
拉動系統數據庫這樣的操作

00:27:04.725 --> 00:27:08.595
也許你想定期讀取HealthKit數據庫
或日曆數據庫

00:27:09.396 --> 00:27:11.565
你可以預約未來的URL會話

00:27:11.632 --> 00:27:13.734
這正是我們在股票應用中所執行的

00:27:14.434 --> 00:27:16.170
如果你已經知道時間過渡

00:27:16.236 --> 00:27:19.039
你可以告訴系統你認爲

00:27:19.106 --> 00:27:21.542
運行應用最佳的確切日期

00:27:21.742 --> 00:27:25.512
比如 日曆應用或旅行應用可能有

00:27:25.712 --> 00:27:28.982
定義良好的時間過渡

00:27:29.816 --> 00:27:32.986
最後 如果你
提前得到後臺運行時間

00:27:33.053 --> 00:27:35.789
通過ClockKit API
我們希望你能進入

00:27:35.856 --> 00:27:39.059
WatchKit API觸發
complication更新

00:27:42.563 --> 00:27:45.599
現在讓我們講一些快照的最佳範例

00:27:47.668 --> 00:27:50.437
快照是一個系統自有的 緩存

00:27:50.504 --> 00:27:53.273
應用數據 跟普通的緩存一樣

00:27:54.107 --> 00:27:55.576
數據也會失效

00:27:55.776 --> 00:27:58.378
因此 系統想了解
數據什麼時候會失效

00:27:59.146 --> 00:28:02.816
你可以 通知系統快照需要更新

00:28:02.883 --> 00:28:05.319
通過預約新快照請求

00:28:06.653 --> 00:28:09.556
現在 你應該考慮重大的內容變更

00:28:09.623 --> 00:28:11.525
當你嘗試使快照無效時

00:28:11.892 --> 00:28:15.028
你並不想頻繁失效

00:28:15.529 --> 00:28:19.366
比如 在倒計時應用中

00:28:19.433 --> 00:28:22.369
你一定不想每秒鐘都更新快照

00:28:22.436 --> 00:28:23.537
那樣沒有任何意義

00:28:23.604 --> 00:28:26.673
相反 你肯定希望通知系統
更新你的快照

00:28:26.740 --> 00:28:29.643
當發生重大事件時 比如計時結束時

00:28:32.746 --> 00:28:34.081
我知道這很複雜

00:28:34.147 --> 00:28:38.919
我想分享一個我認爲很棒的
數據流

00:28:38.986 --> 00:28:40.521
關於如何管理這種複雜性

00:28:41.622 --> 00:28:44.024
假如你有一些外部事件

00:28:44.324 --> 00:28:47.027
也許是表連通性
也許是NSURLSession

00:28:47.194 --> 00:28:49.596
也許應用碰巧在前臺運行

00:28:49.663 --> 00:28:51.365
因爲用戶啓動了你的應用

00:28:51.665 --> 00:28:55.035
基本上是導致你更新
模型的所有事件

00:28:57.137 --> 00:28:59.907
我們想要你爲後臺刷新做的所有操作

00:29:00.274 --> 00:29:03.410
是爲了迴應模型的變更

00:29:03.977 --> 00:29:06.046
比如 更新complication

00:29:06.113 --> 00:29:07.614
請求創建新快照

00:29:08.081 --> 00:29:10.884
然後評估下一次後臺刷新需求

00:29:10.951 --> 00:29:12.853
無論是後臺URLSession

00:29:12.920 --> 00:29:15.989
或者僅僅是跟後臺刷新API
預約任意一個運行時間

00:29:21.495 --> 00:29:24.131
現在watchOS 3中
有了dock

00:29:24.598 --> 00:29:26.967
我們認爲用戶會

00:29:28.202 --> 00:29:31.872
我們認爲用戶會出入很多應用

00:29:31.939 --> 00:29:34.107
比watchOS 2上要頻繁地多

00:29:34.675 --> 00:29:37.511
在watchOS 2中 你必須準備

00:29:37.578 --> 00:29:40.848
隨時進入前臺或後臺

00:29:41.014 --> 00:29:43.750
但我們認爲現在這些轉換
發生的頻率要高得多

00:29:45.185 --> 00:29:48.121
因此你應該確保
完成所有後臺任務

00:29:48.188 --> 00:29:50.724
當處於前臺激活狀態時儘快

00:29:52.159 --> 00:29:54.094
當應用在前臺被激活時

00:29:54.161 --> 00:29:56.864
你一定不想實施任何額外的工作

00:29:56.930 --> 00:29:59.132
你只想做一些有用的工作

00:29:59.199 --> 00:30:01.134
向用戶顯示UI

00:30:01.702 --> 00:30:05.706
類似的 當應用從前臺進入後臺時

00:30:05.939 --> 00:30:09.543
你應該儘快完成所有的前臺工作

00:30:09.877 --> 00:30:13.046
現在我們意識到
你可能需要一點兒時間

00:30:13.113 --> 00:30:14.581
來完成所有的前臺工作

00:30:14.648 --> 00:30:18.619
你可以通過使用NSProcessInfo
.performExpiringActivity實現

00:30:19.386 --> 00:30:24.291
去年的WWDC有一場不錯的演講
是“WatchKit技巧與陷阱”

00:30:24.358 --> 00:30:28.529
教你如何使用NSProcessInfo
.performExpiringActivity

00:30:29.296 --> 00:30:32.299
最後 我還要提一下數據保護

00:30:33.100 --> 00:30:37.137
一般來說
用戶是早晨戴上表

00:30:37.604 --> 00:30:40.307
解鎖 然後表一整天都是解鎖狀態

00:30:40.374 --> 00:30:43.177
直到晚上再脫下表 放回充電器

00:30:45.345 --> 00:30:48.749
完全不能獲取到
表上某些類型的數據

00:30:48.815 --> 00:30:50.717
當設備爲鎖定狀態時

00:30:50.984 --> 00:30:54.588
比如 其中一個最著名的案例是
HealthKit數據庫

00:30:55.222 --> 00:30:58.959
因此 你一定要考慮
你有什麼解決方案

00:30:59.026 --> 00:31:01.695
如果數據不可用
不能創建快照的話

00:31:05.766 --> 00:31:08.402
然後我想分享一些測試技巧

00:31:09.636 --> 00:31:12.573
模擬器對於迭代開發來說
是個不錯的工具

00:31:12.639 --> 00:31:15.042
我之前提過 我們有一些預算

00:31:15.108 --> 00:31:17.845
但在模擬器中
我們不會強制實施任何預算

00:31:17.911 --> 00:31:21.615
所以 你一般會根據
你想要調用任務的日期

00:31:21.682 --> 00:31:23.584
在模擬器中調用任務

00:31:25.252 --> 00:31:27.154
類似的 當在設備上時

00:31:27.621 --> 00:31:29.456
我們可能仍然需要應用一些預算

00:31:29.523 --> 00:31:31.391
但 你將獲得最佳體驗

00:31:31.458 --> 00:31:32.526
當在充電器上時

00:31:35.395 --> 00:31:38.298
你要確保你對啓動路徑和重新啓動
路徑都進行了測試

00:31:38.365 --> 00:31:41.168
系統會盡可能
把你的應用放在內存中

00:31:42.102 --> 00:31:43.770
但如果有引導程序

00:31:43.837 --> 00:31:45.806
系統將啓動你的應用

00:31:45.873 --> 00:31:48.342
以便請求初始快照

00:31:49.843 --> 00:31:51.912
要驗證已完成所有任務

00:31:52.446 --> 00:31:54.615
在隨後的種子中
你將得到一個崩潰報告

00:31:54.681 --> 00:31:56.617
如果你不能按時完成任務的話

00:31:57.084 --> 00:31:59.853
超級重要的一點是
你的應用並不會崩潰

00:31:59.920 --> 00:32:03.357
因爲我們希望你的應用
儘可能地響應用戶

00:32:04.691 --> 00:32:06.760
最後 一旦你認爲你已經

00:32:06.827 --> 00:32:09.096
實現了後臺刷新策略

00:32:09.162 --> 00:32:10.264
你的應用應該已經被激活了

00:32:10.364 --> 00:32:11.798
確保你得到了 體驗

00:32:11.865 --> 00:32:13.500
你希望你的用戶能得到的

00:32:14.134 --> 00:32:17.304
你應該改變dock中的應用數量

00:32:18.739 --> 00:32:21.575
確保對最好的和最壞的情況
進行充分測試

00:32:21.642 --> 00:32:22.943
當你得到預約時

00:32:23.277 --> 00:32:27.514
現在 我想分享一個案例研究
關於我們如何 應用後臺刷新

00:32:27.581 --> 00:32:28.882
在我們的股票應用中

00:32:30.817 --> 00:32:33.620
在我們開始寫代碼之前

00:32:34.288 --> 00:32:38.425
我們先退一步思考一下

00:32:38.492 --> 00:32:40.627
進行後臺刷新的有趣特徵

00:32:40.694 --> 00:32:41.995
爲我們的股票應用

00:32:43.764 --> 00:32:47.067
我們使用URLSession
取回服務器數據

00:32:49.570 --> 00:32:51.338
且要做一個complication

00:32:51.772 --> 00:32:54.141
意思就是 我們知道 有多個視圖

00:32:54.208 --> 00:32:55.843
系統中的數據

00:32:55.909 --> 00:32:58.145
通過complication、快照

00:32:58.745 --> 00:33:01.281
以及激活應用

00:33:04.084 --> 00:33:08.255
我們知道 我們想要週期性地運行

00:33:08.755 --> 00:33:11.592
我們要定期更新應用

00:33:12.659 --> 00:33:14.728
然後 我們瞭解了數據中一些有趣的東西

00:33:14.795 --> 00:33:19.233
就是一旦股市關閉 我們的數據
在當天剩餘的時間內是沒什麼問題的

00:33:19.299 --> 00:33:20.767
根本不會發生變化

00:33:21.201 --> 00:33:24.037
嗯 讓我們講一下應用的運行

00:33:25.005 --> 00:33:27.741
假如我們的設備啓動

00:33:27.808 --> 00:33:30.978
系統會要求
我們的應用創建一個快照

00:33:31.712 --> 00:33:34.348
因此 我們加載最新數據
並準備好UI

00:33:34.414 --> 00:33:36.383
但在完成快照任務之前

00:33:36.450 --> 00:33:39.453
我們要預約一個
後臺的URLSession任務

00:33:40.420 --> 00:33:43.724
這是我們開始後臺刷新週期
的機會

00:33:44.691 --> 00:33:48.128
並確保爲用戶下載最新數據

00:33:49.496 --> 00:33:53.300
現在 我們要使用
NSURLSessionDownloadTask

00:33:53.634 --> 00:33:58.472
給系統提供我們想要下載
哪種數據的信息

00:33:58.539 --> 00:34:01.175
系統可以讓我們的應用休眠

00:34:01.241 --> 00:34:02.843
並在後臺下載數據

00:34:04.077 --> 00:34:08.949
URLSessionDataTask
的確能在後臺會話中運行

00:34:09.248 --> 00:34:11.518
然而 如果應用在後臺

00:34:11.585 --> 00:34:15.889
或當應用被掛起時 它會失敗

00:34:17.424 --> 00:34:19.893
因爲後臺刷新有時間限制

00:34:19.960 --> 00:34:23.964
你的應用很可能會在
得到數據之前就被掛起了

00:34:24.031 --> 00:34:26.667
所以我們建議使用下載任務

00:34:28.402 --> 00:34:32.239
稍後 系統會喚醒我們的應用

00:34:32.306 --> 00:34:33.873
因爲我們已經完成了下載

00:34:34.908 --> 00:34:38.011
我們會更新我們的模型
因爲我們已經更新了模型

00:34:38.078 --> 00:34:39.612
我們有三件事要去做

00:34:39.913 --> 00:34:41.982
觸發complication更新

00:34:43.250 --> 00:34:46.954
通過請求
通知系統快照已經失效

00:34:47.020 --> 00:34:48.487
立即創建新快照

00:34:49.556 --> 00:34:53.025
並評估
下一次後臺刷新需求

00:34:54.460 --> 00:34:56.964
計劃好下一次的運行時間

00:34:57.030 --> 00:34:58.432
並把這個時間通知給系統

00:35:00.033 --> 00:35:03.337
稍後 我們開始運行後臺刷新

00:35:03.403 --> 00:35:06.940
我們所要做的就是預約
下一次的URLSession下載

00:35:07.741 --> 00:35:11.745
我們一天之內要完成多個
這樣的週期

00:35:12.746 --> 00:35:15.649
就是爲了保證應用的數據
是最新的 系統會創建快照

00:35:15.716 --> 00:35:17.451
若用戶在dock中
瀏覽我們快照

00:35:17.518 --> 00:35:21.288
我們的快照會顯示最新的數據

00:35:22.956 --> 00:35:25.526
嗯 假如用戶從dock中
激活了我們的應用

00:35:26.093 --> 00:35:27.361
我們應用會變成全屏顯示

00:35:28.061 --> 00:35:30.764
並且我們想確保我們的用戶
有最新的數據

00:35:30.831 --> 00:35:34.368
所以我們將再次下載最新數據

00:35:34.434 --> 00:35:35.936
因爲我們已經進入前臺

00:35:37.237 --> 00:35:40.707
一旦完成模型的更新
我們仍然要完成三件事

00:35:40.774 --> 00:35:42.676
我們要請求
complication更新

00:35:42.910 --> 00:35:44.278
還要請求創建新快照

00:35:44.978 --> 00:35:47.915
然後還要再次預約
稍後的後臺刷新

00:35:48.182 --> 00:35:49.883
在這裏 我要指出兩點

00:35:50.250 --> 00:35:53.854
首先 雖然我們已經進入前臺
但我們仍然正在請求創建新快照

00:35:54.354 --> 00:35:57.724
這絕對沒問題
而且我們也期待你們這樣做

00:35:57.791 --> 00:36:00.727
我們希望只要模型發生變更
就請求創建新快照

00:36:00.794 --> 00:36:03.964
系統非常智能
它知道你的應用何時處於前臺

00:36:04.031 --> 00:36:07.267
以及何時不適合
給你發送快照任務

00:36:08.335 --> 00:36:11.271
第二點 因爲我們是在前臺運行

00:36:11.905 --> 00:36:13.106
並更新了模型

00:36:13.407 --> 00:36:16.443
我們得評估
下一次的後臺刷新需求

00:36:16.910 --> 00:36:19.913
如果我們知道
我們很可能會在十分鐘後運行

00:36:19.980 --> 00:36:21.648
但我們只下載了數據

00:36:22.416 --> 00:36:26.653
我們可以推遲創建快照
或者推遲後臺刷新請求

00:36:26.720 --> 00:36:30.791
使運行時間最大化

00:36:32.326 --> 00:36:34.728
要使應用運行的機率最大化

00:36:37.264 --> 00:36:40.100
最後 股市關閉之前
做最後一次更新

00:36:41.301 --> 00:36:43.303
我們知道 當天的數據將不會再發生變化

00:36:44.304 --> 00:36:45.973
但是我們會像往常一樣完成更新

00:36:46.039 --> 00:36:48.008
意思是更新complication

00:36:48.542 --> 00:36:49.977
請求創建新快照

00:36:50.577 --> 00:36:53.113
然後評估後臺刷新需求

00:36:54.882 --> 00:36:57.718
因爲我們知道
當天的數據會停止更新

00:36:57.784 --> 00:37:01.154
我們不能在complication
或快照中保留失效的數據

00:37:02.623 --> 00:37:05.025
我們可以等待
直到股市下一次開市

00:37:05.092 --> 00:37:07.160
獲得下一次後臺刷新的機會

00:37:08.762 --> 00:37:12.432
這就使我們的應用避開系統

00:37:12.499 --> 00:37:14.668
並且不用完成任何不必要的工作

00:37:15.002 --> 00:37:16.870
意思就是
會獲得更多的刷新任務

00:37:16.937 --> 00:37:18.539
系統上的其他應用

00:37:21.208 --> 00:37:25.312
總之 一定要完成任務

00:37:25.412 --> 00:37:27.748
完成任務非常重要

00:37:27.814 --> 00:37:29.483
如果沒有完成任務
在隨後的種子中

00:37:29.550 --> 00:37:31.652
系統會扼殺你的應用

00:37:31.718 --> 00:37:33.654
如果系統扼殺了你的應用

00:37:33.720 --> 00:37:38.825
用戶在dock中就不會得到
他們所期待的快速響應時間

00:37:38.959 --> 00:37:41.061
並且用戶將
把你的應用從dock中移除

00:37:42.763 --> 00:37:45.132
要有效地利用運行時間

00:37:45.199 --> 00:37:48.468
考慮前臺激活、
通知、ClockKit

00:37:48.535 --> 00:37:51.738
當然還有後臺刷新機會

00:37:52.039 --> 00:37:53.540
無論什麼時候獲得運行時間

00:37:53.774 --> 00:37:56.877
都一定要考慮保持最新的模型

00:37:56.944 --> 00:37:59.580
並評估後臺刷新需求

00:38:01.281 --> 00:38:03.383
當數據發生變更時要通知系統

00:38:04.218 --> 00:38:06.887
你的complication
和你的應用快照

00:38:06.954 --> 00:38:11.558
都是系統自有的應用數據緩存

00:38:12.659 --> 00:38:16.129
系統需要了解何時數據失效

00:38:16.496 --> 00:38:19.132
以便我們不會
給用戶顯示錯誤的數據

00:38:19.600 --> 00:38:22.269
用戶期待看到一致的數據

00:38:22.636 --> 00:38:25.038
無論他們用什麼方式
瀏覽應用數據

00:38:26.673 --> 00:38:29.076
最後 你需要 來決定應用策略

00:38:29.142 --> 00:38:30.744
具體分析

00:38:30.811 --> 00:38:32.513
沒有適合所有情況的解決方案

00:38:32.579 --> 00:38:36.016
你一定要考慮用戶
是如何使用應用的

00:38:36.283 --> 00:38:38.352
以及數據的有趣性特徵

00:38:38.418 --> 00:38:40.721
從而決定如何計劃後臺刷新策略

00:38:42.122 --> 00:38:44.858
要了解更多信息
你可以訪問這個網站

00:38:45.392 --> 00:38:49.796
今天下午3點還有一場
非常不錯的演講

00:38:49.863 --> 00:38:55.068
構造watchOS 3上的性能
我們將具體闡述股票應用的實現

00:38:55.135 --> 00:38:56.270
謝謝大家