00:00:19.353 --> 00:00:21.421
iOS 10中UICollection
的新特性

00:00:21.488 --> 00:00:22.322
早上好

00:00:25.692 --> 00:00:27.561
我叫Steve Breen

00:00:27.928 --> 00:00:29.730
我叫Peter Hajas

00:00:29.796 --> 00:00:32.833
我們都是
UIKit框架團隊的工程師

00:00:34.234 --> 00:00:37.304
我們很高興跟大家分享
CollectionView上的新特性

00:00:38.438 --> 00:00:39.840
讓我們開始吧

00:00:41.108 --> 00:00:43.510
我們今天早晨要講三個話題

00:00:44.077 --> 00:00:47.347
第一個話題是平滑滾動

00:00:48.315 --> 00:00:52.553
每個iOS應用都希望
有一個不錯的滾動體驗

00:00:53.053 --> 00:00:54.922
在CollectionView上
我們添加了一些了不起的新功能

00:00:54.988 --> 00:00:57.157
幫助你的應用比以前任何
時候都能更好地滾動

00:00:57.591 --> 00:01:00.260
其中最精華的部分是
很多改進

00:01:00.327 --> 00:01:03.197
在你的應用中
不需要或只需要少量工作

00:01:05.299 --> 00:01:09.069
接下來 我們會講
自動調整單元格中的改進

00:01:09.570 --> 00:01:12.506
我們在iOS 8中
引入了這個API

00:01:12.940 --> 00:01:15.442
我們在iOS 10中
做了很多不錯的改進

00:01:15.509 --> 00:01:17.244
使它更易用

00:01:18.645 --> 00:01:22.583
最後 我們會回顧一下
交互式重排序

00:01:23.083 --> 00:01:26.119
去年在iOS 9中
我們引入了這個API

00:01:26.520 --> 00:01:29.857
在iOS 10中
我們又改善了很多功能

00:01:30.824 --> 00:01:33.160
讓我們從平滑滾動開始講吧

00:01:34.628 --> 00:01:38.065
iOS設備體驗的一個標誌是

00:01:38.398 --> 00:01:41.668
對用戶的觸摸
立即響應

00:01:43.136 --> 00:01:46.507
響應式用戶體驗的
一個重要部分

00:01:46.974 --> 00:01:51.378
是確保我的手指
在屏幕上滾動

00:01:51.678 --> 00:01:55.682
這種對象在屏幕上的移動
就像在真實的世界中移動一樣

00:01:56.416 --> 00:02:00.921
這對於使用戶全神貫注於應用
非常重要

00:02:01.855 --> 00:02:03.957
我們要討論一下
平滑滾動

00:02:04.124 --> 00:02:07.060
及我們在UI CollectionView上
所做的改進

00:02:07.761 --> 00:02:10.163
通過討論一個演示應用

00:02:10.764 --> 00:02:14.902
正如你即將看到
這個應用滾動效果並不是那麼好

00:02:14.968 --> 00:02:17.404
我們想像黃油一樣滾動
但目前

00:02:17.471 --> 00:02:20.007
需要太多滾動
就像一塊花生醬

00:02:20.374 --> 00:02:21.475
讓我們看看iPad

00:02:25.779 --> 00:02:27.114
我要切換到iPad上

00:02:29.449 --> 00:02:32.753
澄清一點
藍色方塊通常消耗較少

00:02:32.953 --> 00:02:34.855
但是我們故意把這些變慢了

00:02:35.455 --> 00:02:36.957
想象一下若更復雜會怎麼樣

00:02:37.024 --> 00:02:39.193
比如
也許它們有兩種顏色

00:02:40.260 --> 00:02:41.128
無論如何...

00:02:42.362 --> 00:02:44.264
有了CollectionView
我們可以看到

00:02:44.331 --> 00:02:47.901
滾動已經加載了內容
很好 很快

00:02:48.602 --> 00:02:49.970
但是 讓我們仔細查看一下

00:02:50.037 --> 00:02:51.338
Steve 請注意看

00:02:51.872 --> 00:02:53.407
當我再往下滾動時

00:02:54.508 --> 00:02:55.576
哦 哎呦

00:02:55.943 --> 00:02:57.444
一顆星 不能買

00:02:59.346 --> 00:03:00.914
我也不會買

00:03:01.014 --> 00:03:04.718
這種用戶體驗
是我們要極力避免的體驗

00:03:05.185 --> 00:03:06.386
這是怎麼回事？

00:03:06.920 --> 00:03:10.824
嗯 我們之前說過 這些是
非常簡陋的藍色方塊

00:03:11.024 --> 00:03:14.795
在你的應用中
模擬高消耗的複雜單元格

00:03:15.429 --> 00:03:17.564
遇到CollectionView時

00:03:18.265 --> 00:03:21.235
加載單元格
的時間恰好是它們請求被加載的時候

00:03:21.668 --> 00:03:22.836
讓我演示一下

00:03:23.971 --> 00:03:25.405
我們要在這兒重新加載數據

00:03:25.606 --> 00:03:26.673
我會打開一個視圖

00:03:26.740 --> 00:03:29.977
這個視圖將顯示在
CollectionView中加載的所有單元格

00:03:30.844 --> 00:03:33.647
這樣你可以看到那些底部的單元格
超出了

00:03:33.947 --> 00:03:35.182
可見的邊界

00:03:35.816 --> 00:03:37.718
現在看看當我滾動時會發生什麼

00:03:39.853 --> 00:03:42.923
我們一下帶入了
一整行單元格

00:03:43.290 --> 00:03:46.326
這就是導致
滾動體驗磕磕絆絆的原因

00:03:47.561 --> 00:03:49.429
在性能術語中

00:03:49.496 --> 00:03:52.799
我們可以稱之爲
應用掉幀

00:03:53.367 --> 00:03:55.702
讓我們再切回幻燈片
瞭解更多的信息

00:03:56.403 --> 00:03:59.840
我們究竟要表達什麼意思呢
當提到掉幀時

00:04:00.307 --> 00:04:02.209
在你的應用中

00:04:02.476 --> 00:04:04.711
用戶期待
平滑的滾動體驗

00:04:04.778 --> 00:04:07.614
意思是你的應用要達到
那個神奇的數字

00:04:07.814 --> 00:04:09.383
每秒60幀

00:04:10.484 --> 00:04:11.585
讓我們算一下

00:04:11.652 --> 00:04:14.121
這意味着每次
刷新時

00:04:14.688 --> 00:04:17.457
我們需要在16毫秒內顯現那個窗口

00:04:18.425 --> 00:04:20.293
好了 讓我們看幾幀

00:04:20.360 --> 00:04:23.764
我們這兒有一個圖表
顯示了三個不同的幀

00:04:25.232 --> 00:04:26.300
在第一幀中...

00:04:28.068 --> 00:04:29.503
我們幾乎不需要做什麼

00:04:29.770 --> 00:04:31.405
正如Peter剛提到的那樣

00:04:31.605 --> 00:04:34.541
我們在顯示屏中上下移動當前內容

00:04:34.875 --> 00:04:37.044
這是iOS上的一個高度優化的情形

00:04:37.110 --> 00:04:38.378
所以速度超快

00:04:38.445 --> 00:04:39.713
不需做很多工作就能達到

00:04:39.780 --> 00:04:42.649
我們獲得了這個很棒的五星級
滾動體驗

00:04:43.016 --> 00:04:43.917
這幀不錯

00:04:44.618 --> 00:04:45.786
掉幀剖析

00:04:46.086 --> 00:04:48.989
但是在演示中
並不總那麼好

00:04:50.357 --> 00:04:54.127
偶爾 會有這樣的情況
我們需要做大量的工作

00:04:54.361 --> 00:04:58.899
不僅裝載當前幀
還會摻雜下一幀

00:05:00.701 --> 00:05:02.269
這是我們的廣告幀

00:05:02.336 --> 00:05:04.104
我們掉了一幀 一顆星

00:05:06.206 --> 00:05:08.442
讓我們以一種不同的視角來看它

00:05:08.775 --> 00:05:12.613
在這個圖中
我們可以看到有兩個不同的區

00:05:13.113 --> 00:05:16.316
頂部有一個區
我們把它叫做紅區

00:05:16.884 --> 00:05:18.819
這是我們失了一幀的地方

00:05:18.886 --> 00:05:21.955
我們比那個神奇的16毫秒線高了

00:05:23.156 --> 00:05:25.392
讓我們查看一下
座標軸上的標籤

00:05:25.692 --> 00:05:27.294
那麼 在我們的y軸上

00:05:27.361 --> 00:05:30.197
我們要用圖表示出
主線程上的CPU時間

00:05:30.964 --> 00:05:31.798
x軸

00:05:32.065 --> 00:05:36.170
顯示滾動發生時的最新事件

00:05:36.870 --> 00:05:38.138
好的 讓我們看一個圖表

00:05:39.339 --> 00:05:40.741
好吧 那麼在這個圖表中

00:05:40.908 --> 00:05:42.976
顯示了Peter
剛剛闡述過的內容

00:05:43.043 --> 00:05:45.445
這些訪問進入
到紅區了

00:05:45.512 --> 00:05:46.613
丟幀的地方

00:05:46.680 --> 00:05:49.716
但最重要的是
看看這些平靜時期

00:05:49.917 --> 00:05:52.252
CollectionView
幾乎什麼都沒做

00:05:52.986 --> 00:05:55.055
然後 我們在最後
又一次進入到紅區

00:05:55.122 --> 00:05:58.692
如果我們稍微改變一下
這種現象會怎麼樣呢

00:05:58.759 --> 00:06:01.094
並且降低我們的工作量

00:06:01.328 --> 00:06:02.563
當用戶滾動時

00:06:04.031 --> 00:06:04.965
好的 酷 請看

00:06:05.032 --> 00:06:08.769
現在 這些不再進入到紅區了

00:06:09.570 --> 00:06:11.138
並且形成了平靜週期

00:06:11.205 --> 00:06:13.040
我們讓工作量均勻分佈

00:06:13.106 --> 00:06:14.975
我們平攤了時間

00:06:16.610 --> 00:06:17.611
爲了幫助討論

00:06:17.678 --> 00:06:20.881
如何把這些峯值變平
以及如何拉起這個谷值

00:06:21.114 --> 00:06:23.650
來打造一個美好的、
始終如一的體驗

00:06:24.184 --> 00:06:26.920
我想談一下
單元格生命週期

00:06:27.187 --> 00:06:29.122
在iOS 9上的

00:06:29.690 --> 00:06:32.526
我們要討論的是
單元格的整個生命週期

00:06:32.893 --> 00:06:33.760
很漂亮

00:06:34.394 --> 00:06:36.296
讓我們加入
CollectionView單元格

00:06:37.130 --> 00:06:40.367
我們滾動時 可以說是
我們需要加入一個新的單元格

00:06:41.702 --> 00:06:45.239
我們把它從重用隊列中拿出來
叫做prepareForReuse

00:06:46.240 --> 00:06:50.577
這就給了單元格一個
把自己重設爲預設狀態的機會

00:06:50.911 --> 00:06:53.313
準備接收來自應用的新數據

00:06:54.214 --> 00:06:58.485
接下來 我們繼續調用
其餘的cellForItemAtIndexPath

00:06:59.319 --> 00:07:02.890
這是你要做大量工作的地方
填充單元格

00:07:03.357 --> 00:07:05.993
你要建立數據模型
在單元格上設置數據模型

00:07:06.226 --> 00:07:07.928
然後再把數據模型帶回系統

00:07:08.929 --> 00:07:11.965
在那個單元格即將在屏幕上顯示之前

00:07:12.165 --> 00:07:14.268
我們會調用
willDisplayCell

00:07:15.402 --> 00:07:20.140
這可以給應用一個機會
完成最後一刻要做的工作

00:07:20.407 --> 00:07:22.209
當單元格在屏幕上顯示之前

00:07:23.010 --> 00:07:26.713
對於即將要顯示的單元格
我們會調用didEndDisplayingCell

00:07:28.015 --> 00:07:29.950
好的 這就是單元格生命週期

00:07:30.250 --> 00:07:31.652
iOS 10之前的版本

00:07:32.619 --> 00:07:35.255
現在 讓我們查看一下
在iOS 10上是怎麼樣的

00:07:35.889 --> 00:07:38.692
我們有跟 Peter剛提過的
佈局相同類型的佈局

00:07:38.759 --> 00:07:41.595
單欄
很適合演示用

00:07:42.362 --> 00:07:44.531
那麼現在 當用戶向上滾動時

00:07:44.731 --> 00:07:45.632
請注意這裏

00:07:45.832 --> 00:07:48.836
就在這個單元格
要顯示在屏幕上之前

00:07:48.902 --> 00:07:50.971
我們要把它從重用隊列中拿進去

00:07:51.605 --> 00:07:54.341
然後按照Peter剛講的
那個熟悉的模式

00:07:54.408 --> 00:07:56.543
我們會給它發送一個
prepareForReuse

00:07:56.910 --> 00:07:59.513
然後 構造單元格中餘下的內容

00:07:59.580 --> 00:08:01.415
用cellForItemAtIndexPath

00:08:01.481 --> 00:08:05.252
當用戶繼續滾動時
這裏有點不一樣了

00:08:05.986 --> 00:08:09.189
我們不調用willDisplayCell
當我們創建這個單元格時

00:08:09.256 --> 00:08:12.492
我們有個遲疑 延遲
然後就在它要顯示時

00:08:12.559 --> 00:08:14.628
我們會調用
willDisplayCell

00:08:15.462 --> 00:08:17.698
好的 現在用戶繼續滾動

00:08:18.899 --> 00:08:22.402
我們會讓其他單元格淡出
聚焦在這個單元格的生命週期上

00:08:22.803 --> 00:08:24.471
現在這個單元格要退出

00:08:24.538 --> 00:08:26.540
可見的邊框
從CollectionView中

00:08:26.607 --> 00:08:29.610
那麼我們會給它發送
didEndDisplayingCell

00:08:30.110 --> 00:08:33.280
Peter談的是iOS 9
此時

00:08:33.480 --> 00:08:36.082
單元格進入重用隊列
然後就結束了

00:08:36.582 --> 00:08:39.119
要使這個單元格再次顯示數據

00:08:39.385 --> 00:08:41.855
我們得重新開始
一個單元格的生命週期

00:08:41.922 --> 00:08:44.191
並且調用cellForItemAtIndexPath

00:08:45.158 --> 00:08:48.328
但在iOS 10中 我們會讓那個單元格
保留較長的時間

00:08:49.029 --> 00:08:51.732
因此 若用戶稍微向上滾動
然後說 “哦 等一會兒

00:08:51.798 --> 00:08:54.468
那是我妹妹剛生的小孩的照片
我要滾動回來”

00:08:55.102 --> 00:08:58.839
我們將繼續保留那個單元格並再次發送
willDisplayCell

00:08:59.406 --> 00:09:01.842
然後 內容將繼續在單元格中顯示出來

00:09:21.361 --> 00:09:25.966
請注意 Steve在這裏展示的東西
同樣適用於多欄佈局

00:09:26.700 --> 00:09:29.536
我們要一次一個地引入單元格

00:09:29.603 --> 00:09:32.206
而不是一次全部引入
以便獲得更好的滾動體驗

00:09:32.272 --> 00:09:33.941
你說的對 Peter 請注意

00:09:34.007 --> 00:09:36.643
這些單元格實際上還
不能在屏幕上顯示出來

00:09:36.710 --> 00:09:38.078
它們仍然在屏幕外

00:09:38.378 --> 00:09:40.848
現在 我們發送
我們DQ的第二個單元格

00:09:41.014 --> 00:09:44.651
cellForItemIndexPath
並向上滾動兩個單元格

00:09:44.718 --> 00:09:47.521
現在我們要發送
willDisplayCellMessage

00:09:47.588 --> 00:09:50.224
給那兩個單元格
就在它們在屏幕上顯示之前

00:09:51.358 --> 00:09:53.493
這聽起來像是一個很微妙的變化

00:09:53.694 --> 00:09:55.596
實際效果要明顯得多

00:09:56.096 --> 00:09:59.099
通過在iOS 10中應用這個新生命週期

00:09:59.333 --> 00:10:02.069
我們獲得了自動的、
更快的滾動體驗

00:10:02.302 --> 00:10:03.504
讓我們回到iPad上

00:10:06.373 --> 00:10:08.275
我要切回iPad

00:10:10.611 --> 00:10:15.082
你可以看到跟剛在iOS 9上看到的
相同的CollectionView

00:10:15.616 --> 00:10:19.353
請記住 滾動當前內容
很好 很快

00:10:19.686 --> 00:10:21.388
但當我們引入更多單元格時

00:10:22.422 --> 00:10:23.824
就開始不流暢了

00:10:24.224 --> 00:10:26.193
準備CollectionView時

00:10:26.460 --> 00:10:29.496
我們同時也在烤箱裏準備了一個CollectionView
正在iOS 10下烤着呢

00:10:30.063 --> 00:10:31.398
我要轉到那個CollectionView

00:10:33.100 --> 00:10:35.736
在此 我們已經有了兩個完全相同的
CollectionView

00:10:36.003 --> 00:10:40.207
有同樣的高消耗
在iOS 10上運行的藍色方塊

00:10:41.475 --> 00:10:43.944
我們可以看到滾動當前內容

00:10:44.178 --> 00:10:46.680
仍然很好 很快 很流暢

00:10:46.880 --> 00:10:48.849
-但請仔細看 Steve
-好吧

00:10:48.916 --> 00:10:50.551
當我再滾動時

00:10:51.518 --> 00:10:53.620
哦 很棒 五顆星

00:10:54.087 --> 00:10:55.222
就是這樣

00:11:01.228 --> 00:11:04.331
這是因爲我們使用了
這個新的單元格生命週期

00:11:04.565 --> 00:11:06.300
我們並沒有對應用做出任何變更

00:11:07.167 --> 00:11:08.769
我要打開那個相同的視圖

00:11:08.836 --> 00:11:11.638
展示CollectionView
加載的所有單元格

00:11:11.805 --> 00:11:13.407
幫助我們瞭解這個不同點

00:11:14.942 --> 00:11:15.976
打開那個視圖

00:11:16.610 --> 00:11:20.380
在這裏 你可看到底部的單元格行
已經準備好了

00:11:20.747 --> 00:11:22.783
但是請看當我快速滾動時
會怎麼樣

00:11:23.250 --> 00:11:25.719
並不是一次一行引入單元格

00:11:26.520 --> 00:11:28.922
我們讓工作量均勻分佈
在滾動過程中

00:11:29.156 --> 00:11:32.226
這是促成更平滑的滾動體驗的原因

00:11:32.359 --> 00:11:33.193
這樣是不是很好

00:11:38.765 --> 00:11:41.168
要了解更多信息
讓我們切回幻燈片

00:11:45.138 --> 00:11:46.206
相當不錯

00:11:46.807 --> 00:11:51.111
今天我們很高興地發佈一個新UI
CollectionView Cell Pre-Fetching

00:11:52.713 --> 00:11:56.083
是默認開啓的
當你在iOS 10上編譯你的應用時

00:11:57.484 --> 00:11:58.385
不需要任何步驟

00:11:59.853 --> 00:12:01.054
現在無論什麼原因

00:12:01.121 --> 00:12:05.192
你想用iOS 10之前
版本上的舊生命週期行爲

00:12:05.259 --> 00:12:06.593
選擇關閉非常簡單

00:12:07.160 --> 00:12:09.463
只需把UICollectionView
的新屬性設爲

00:12:09.530 --> 00:12:12.065
默認值isPrefetchingEnabled即可

00:12:14.735 --> 00:12:17.804
我們有這個新技術應用相關的最佳範例

00:12:18.972 --> 00:12:20.674
我們要談的第一點是

00:12:20.807 --> 00:12:23.677
我們想在cellForItemAtIndexPath中
完成所有繁重的工作

00:12:23.744 --> 00:12:25.879
所有 給單元格創建的所有內容

00:12:25.946 --> 00:12:29.316
在cellForItemAtIndexPath中
無論什麼都應該居中

00:12:30.684 --> 00:12:31.518
此外

00:12:31.585 --> 00:12:33.587
我們想確保
做最少量的工作

00:12:33.654 --> 00:12:36.757
在willDisplayCell
和didEndDisplayCell中

00:12:38.592 --> 00:12:40.661
最後 很重要的一點是

00:12:41.228 --> 00:12:42.996
cellForItemAtIndexPath

00:12:43.063 --> 00:12:45.566
很可能還預備了一個單元格
這個單元格實際上永遠不會被顯示出來

00:12:45.933 --> 00:12:47.234
用戶可能已滾動到別處了

00:12:47.301 --> 00:12:49.603
在那個單元格有機會
被顯示出來之前

00:12:51.271 --> 00:12:52.739
這很棒

00:12:53.307 --> 00:12:55.475
只需在iOS 10中進行重新編譯即可

00:12:55.542 --> 00:12:57.477
並且做好你很可能已經在做的

00:12:57.544 --> 00:13:00.647
在cellForItemAtIndexPath中的
大部分工作

00:13:00.981 --> 00:13:04.451
你自然而然會免費獲得更好的
滾動體驗

00:13:05.586 --> 00:13:07.654
但是 我們想再進一步

00:13:08.155 --> 00:13:10.424
我們知道
有一大類應用

00:13:10.591 --> 00:13:13.660
對於預備CollectionView
有個小問題

00:13:14.127 --> 00:13:17.264
我該怎麼處理
高消耗的數據模型呢？

00:13:18.398 --> 00:13:19.800
事實的真相是

00:13:19.933 --> 00:13:21.535
很多CollectionView
單元格

00:13:21.668 --> 00:13:24.938
需要使用高消耗的
數據模型來創建

00:13:25.539 --> 00:13:27.040
我指的是像這樣的東西

00:13:27.374 --> 00:13:30.077
解碼圖片、
和數據庫通訊、

00:13:30.143 --> 00:13:32.212
或在覈心數據存儲之外加載

00:13:32.746 --> 00:13:35.549
我們知道
對於這類應用

00:13:36.083 --> 00:13:38.218
我們並不想顯示
像模板單元格這樣的東西

00:13:38.285 --> 00:13:39.786
當我們在做
異步網絡請求時

00:13:41.622 --> 00:13:45.659
爲了解決這個問題
我們在iOS 10中引入了新API

00:13:45.726 --> 00:13:48.962
可以告知
數據模型如何加載內容

00:13:50.097 --> 00:13:51.465
自從引入它之後

00:13:51.565 --> 00:13:55.402
就存在兩種伴生對象：

00:13:55.969 --> 00:13:58.038
數據源和委託

00:13:58.539 --> 00:14:02.276
在iOS 10中
我們增加了第三個伴生對象

00:14:02.543 --> 00:14:05.812
它是可選的
叫做prefetchDataSource

00:14:06.713 --> 00:14:08.682
只有一個必需的方法

00:14:08.916 --> 00:14:10.684
用起來很簡單

00:14:11.451 --> 00:14:14.721
ColletionView
prefetchItemsAt indexPaths

00:14:15.622 --> 00:14:18.458
這將會在預取數據源上調用

00:14:18.692 --> 00:14:22.930
當從異步模型中預加載內容時

00:14:23.797 --> 00:14:28.035
那個參數索引路徑
是一個索引路徑的有序數組

00:14:28.635 --> 00:14:31.672
因此 那個數組中越靠前的項
越先顯示出來

00:14:32.306 --> 00:14:35.843
你可以用此改變
異步模型讀取

00:14:36.743 --> 00:14:39.213
在這個協議中 還有第二個可選方法

00:14:39.646 --> 00:14:43.550
CollectionViewcancel
PrefetcingForItemsAtindexPaths

00:14:45.619 --> 00:14:48.222
將在預取數據源上調用

00:14:49.289 --> 00:14:51.124
當我們決定
不再

00:14:51.191 --> 00:14:53.660
滾動一組索引路徑時

00:14:54.528 --> 00:15:00.367
你可以用這個來取消或降低
任何待加載的優先級

00:15:01.301 --> 00:15:04.872
有一個關於此API的重要信息
我想強調一下

00:15:05.639 --> 00:15:09.042
這並不是替代
現有的數據模型

00:15:09.343 --> 00:15:13.647
而是要跟現有的異步方案共同使用

00:15:13.814 --> 00:15:16.383
你已在應用中爲加載數據創建的

00:15:17.684 --> 00:15:20.487
你要做的就是把這個
當作額外提示

00:15:21.021 --> 00:15:23.223
內容何時加載
在CollectionView中

00:15:26.260 --> 00:15:28.395
讓我們演示一下 把它們聯繫起來

00:15:28.462 --> 00:15:31.598
這個演示包含我們目前提到的所有概念

00:15:31.732 --> 00:15:34.001
而且我們要引入
一點兒技術分析

00:15:36.336 --> 00:15:38.672
來看看這個
Steve會做一件非常神奇的事兒

00:15:39.439 --> 00:15:40.307
是技術分析 同志們

00:15:44.311 --> 00:15:46.513
好的 我們要切回演示應用

00:15:46.580 --> 00:15:47.648
我們之前看到的

00:15:50.817 --> 00:15:52.953
好的 那麼這是我們正在看的演示應用

00:15:53.020 --> 00:15:56.256
但我們隱藏了這個很棒的功能
我們把它叫做技術分析面板

00:15:56.857 --> 00:15:58.692
好的 那麼 我現在要打開它

00:15:59.359 --> 00:16:02.396
好的 那麼我們有兩個
不同的區 對吧

00:16:02.462 --> 00:16:04.798
我們有紅區
一顆星 是個不好的區域

00:16:04.865 --> 00:16:07.301
然後
底部有很好很大塊的綠區

00:16:07.701 --> 00:16:10.437
我們可以在這個區域獲得超級
平滑的滾動體驗

00:16:11.338 --> 00:16:12.439
我現在要做的是

00:16:12.506 --> 00:16:15.976
運行
iOS 9版本的應用

00:16:16.710 --> 00:16:19.279
我要再現一個

00:16:19.346 --> 00:16:20.414
我之前記錄的滾動會話

00:16:20.814 --> 00:16:23.050
展示它是如何運作
以及如何執行技術分析的

00:16:24.051 --> 00:16:25.118
好的 現在開始吧

00:16:26.186 --> 00:16:28.188
滾動 執行技術分析

00:16:29.523 --> 00:16:30.357
咔 咔

00:16:31.391 --> 00:16:32.459
好的 看這是什麼？

00:16:33.360 --> 00:16:34.695
讓我們看看這個圖表

00:16:35.095 --> 00:16:38.832
我們進入了八次紅區
有八次掉幀

00:16:40.000 --> 00:16:42.970
但同時 我們也可以看到我們有
很長的平靜週期

00:16:43.036 --> 00:16:44.371
就像我們之前提到的那樣

00:16:44.805 --> 00:16:47.074
因此 圖表區域中
都是這種又大又尖的東西

00:16:47.441 --> 00:16:49.142
然後讓我們再看一下谷底

00:16:49.376 --> 00:16:51.078
看看在iOS 10中是怎麼樣的

00:16:53.847 --> 00:16:55.449
好的 切回iOS 10模式

00:16:55.516 --> 00:16:57.150
Peter之前提到過的

00:16:57.384 --> 00:17:00.721
現在 我要重現
相同的滾動會話

00:17:00.787 --> 00:17:02.122
哇 看啊 Peter

00:17:02.523 --> 00:17:04.925
-平滑多了 Steve
-是啊 看起來好多了

00:17:05.559 --> 00:17:06.627
看看我們的成果

00:17:07.027 --> 00:17:08.194
嘿 看那個

00:17:08.529 --> 00:17:09.762
沒有失幀

00:17:13.133 --> 00:17:13.967
非常棒

00:17:16.036 --> 00:17:19.373
看看我們在這圖表曲線下得到了什麼

00:17:19.806 --> 00:17:22.643
這些峯值並沒有上天
並且與平靜週期

00:17:22.876 --> 00:17:26.280
融合在了一起
現在 我們得到了這種平滑的效果

00:17:26.512 --> 00:17:29.283
使應用在主線程上更積極地響應

00:17:29.917 --> 00:17:32.452
好的 你準備好了嗎Peter？

00:17:32.953 --> 00:17:34.254
-準備好了
-讓我們開始吧

00:17:35.122 --> 00:17:38.058
好的 現在我們要
看看iOS 10版本

00:17:38.125 --> 00:17:39.693
但我們要使用API

00:17:39.760 --> 00:17:41.762
Peter之前提到過的
預取API

00:17:41.828 --> 00:17:43.931
我們要把這些用到
這個應用中

00:17:44.031 --> 00:17:46.099
好的 我已經準備好了演示應用

00:17:46.567 --> 00:17:48.569
我要重現
相同的滾動會話

00:17:49.536 --> 00:17:50.504
哇 Peter 看

00:17:50.771 --> 00:17:53.140
-現在是黃油式的滾動了 Steve
-看起來很不錯

00:17:53.707 --> 00:17:54.541
五顆星

00:17:55.876 --> 00:17:57.044
技術分析也表明足以達到五顆星

00:18:04.017 --> 00:18:06.653
好的 但Peter
這裏有點兒不一樣了 是吧

00:18:06.720 --> 00:18:09.890
曲線上的區域中的
主隊列活動

00:18:10.123 --> 00:18:11.658
和之前的版本不一樣了

00:18:11.725 --> 00:18:13.527
曲線下降了不少
發生了什麼？

00:18:13.994 --> 00:18:17.164
那麼 如果我們正確地使用預取API

00:18:17.431 --> 00:18:19.533
我們很可能把數據模型讀取移動到

00:18:19.600 --> 00:18:22.302
後臺隊列上
釋放主隊列

00:18:23.203 --> 00:18:25.639
就是這樣
就是這麼回事

00:18:25.706 --> 00:18:28.208
現在 我們把所有工作都挪到了
後臺隊列上

00:18:28.275 --> 00:18:30.911
我們不必再
擾亂主線程了

00:18:31.345 --> 00:18:32.713
讓我們切回幻燈片

00:18:39.953 --> 00:18:41.455
接下來 我想談一點兒

00:18:41.522 --> 00:18:43.557
預取API的小技巧

00:18:43.624 --> 00:18:46.426
以最合適的方式使你的應用
使用這個API

00:18:48.428 --> 00:18:51.064
首先
當你調用預取時

00:18:51.131 --> 00:18:54.368
你想要保證立即在後臺隊列上
完成所有工作

00:18:54.935 --> 00:18:57.037
現在 我們有兩種很棒的
技術可以實現：

00:18:57.271 --> 00:18:59.973
GCD和NSOperationQueue

00:19:03.677 --> 00:19:07.581
還有一點很重要
預取是一種自適應技術

00:19:07.648 --> 00:19:09.650
自適應技術是什麼意思呢？

00:19:10.217 --> 00:19:12.719
嗯 記得我們談到
那些平靜週期

00:19:12.786 --> 00:19:14.755
和預取如何
利用那些的嗎

00:19:14.888 --> 00:19:16.056
通過額外工作

00:19:17.558 --> 00:19:21.261
在應用中 有時候
用戶滾動太快

00:19:21.328 --> 00:19:22.629
沒有平靜時間

00:19:23.163 --> 00:19:26.099
在這種情況下 當我們不得不
很頻繁地更新顯示時

00:19:26.333 --> 00:19:28.001
我們將不進行預取

00:19:28.468 --> 00:19:29.536
這樣是正確的

00:19:31.038 --> 00:19:34.141
最後
使用cancelPrefetchingAPI

00:19:34.374 --> 00:19:36.910
來適應用戶的焦點轉移

00:19:36.977 --> 00:19:40.314
現在 可能用戶向上移動到了
CollectionView

00:19:40.380 --> 00:19:42.015
並且正與內容一起滾動

00:19:42.082 --> 00:19:44.384
但然後 他們改變了主意
開始向另一個方向滾動

00:19:44.685 --> 00:19:47.221
我們將通過取消消息把這個事件通知給你

00:19:47.487 --> 00:19:49.923
這樣你就可以忽略那些優先的內容

00:19:49.990 --> 00:19:53.227
聚焦在視圖即將要滾動到的新內容上

00:19:54.795 --> 00:19:57.130
對於CollectionView來說
這真的很棒

00:19:57.564 --> 00:20:01.034
你什麼也不用做
就能得到更好的滾動體驗

00:20:01.201 --> 00:20:03.136
只需要做一點兒工作

00:20:03.370 --> 00:20:05.472
使用你已經寫好的類

00:20:05.639 --> 00:20:07.641
你就能得到更好的滾動體驗

00:20:08.442 --> 00:20:10.477
若你使用UITableView
請別擔心

00:20:10.544 --> 00:20:11.712
一點兒都不重要

00:20:11.879 --> 00:20:14.815
我們也在表視圖中
引入了完全一樣的API

00:20:22.055 --> 00:20:26.627
有一個類似的可選
預取數據源伴生對象

00:20:27.494 --> 00:20:30.464
有一個類似的方法 只有一個方法

00:20:31.265 --> 00:20:34.368
TableView
prefetchRowsAt indexPaths

00:20:34.701 --> 00:20:37.504
索引路徑也是個數組

00:20:37.704 --> 00:20:40.974
按照優先級排序
在表的可見區域

00:20:41.375 --> 00:20:43.911
越靠前的索引路徑
越先顯示出來

00:20:44.745 --> 00:20:46.847
跟CollectionView API一樣

00:20:46.914 --> 00:20:50.651
你可以用此來通知
異步數據模型讀取

00:20:51.251 --> 00:20:54.788
還有相同的第二個
可選委託方法

00:20:55.589 --> 00:20:59.026
表視圖 cancelPrefetchingForRowsAt
indexPaths

00:21:00.027 --> 00:21:02.896
就像Steve剛提到的那樣
你可以用此

00:21:03.063 --> 00:21:07.634
來取消或降低任何待定數據模型
加載的優先級

00:21:08.502 --> 00:21:10.270
這是最棒的一點

00:21:10.704 --> 00:21:12.840
就跟CollectionView API一樣

00:21:13.073 --> 00:21:16.977
這也要跟當前異步模型方案一起使用

00:21:17.344 --> 00:21:19.046
你不必丟掉任何東西

00:21:19.146 --> 00:21:22.783
相反 使用這個通知你正在做的加載

00:21:23.317 --> 00:21:25.986
那麼這就是iOS 10中的單元格預取

00:21:32.526 --> 00:21:34.528
我們非常激動
引入了這個技術

00:21:34.595 --> 00:21:37.931
我們迫不及待要看到實際的應用
有更平滑的滾動體驗

00:21:39.967 --> 00:21:43.670
接下來 我們要講講
我們今年所做的一些改進

00:21:43.737 --> 00:21:45.639
針對自動調整單元格

00:21:45.939 --> 00:21:47.908
我們在iOS 8中引入了這個API

00:21:48.208 --> 00:21:50.110
今年我們又做了一些改進

00:21:50.177 --> 00:21:52.613
使它更容易地應用到你的應用中

00:21:53.480 --> 00:21:56.917
在我們講這個之前
我想回顧一下現有的API

00:21:56.984 --> 00:21:58.151
簡單聊一下

00:22:01.154 --> 00:22:05.225
在CollectionView中
我們發佈了一個具體佈局類

00:22:05.292 --> 00:22:07.261
叫做
UICollectionViewFlowLayout

00:22:07.995 --> 00:22:10.931
並且完全支持
這個類自動調整單元格

00:22:11.932 --> 00:22:14.001
要開啓這個功能 我們只需要設置

00:22:14.067 --> 00:22:17.538
預估尺寸
把它設置爲一些非零CG尺寸

00:22:17.871 --> 00:22:20.407
這就會告訴CollectionView
你想 計算

00:22:20.474 --> 00:22:23.410
動態佈局
在顯示內容時

00:22:25.479 --> 00:22:27.814
現在 獲得
單元格的實際尺寸

00:22:27.881 --> 00:22:30.117
有三種不同的方法
可以實現

00:22:30.918 --> 00:22:33.053
第一種方法是使用自動佈局

00:22:33.654 --> 00:22:37.157
如果你可以完全把
層級的內容視圖限制到

00:22:37.224 --> 00:22:39.593
CollectionView
單元格的內容視圖中

00:22:39.660 --> 00:22:42.896
我們就會請求自動佈局系統計算
單元格的尺寸

00:22:43.163 --> 00:22:44.231
並使用那個值

00:22:46.033 --> 00:22:48.969
如果你不使用自動佈局
或你需要更多手動控制

00:22:49.436 --> 00:22:51.805
你可以重寫sizeThatFits

00:22:53.874 --> 00:22:55.709
最後 實現最終控制

00:22:56.109 --> 00:22:59.479
你可以重寫 preferredLayout
AttributesFittingAttributes

00:22:59.546 --> 00:23:03.050
不僅提供尺寸信息
還可以調整屬性

00:23:03.116 --> 00:23:04.818
比如阿爾法和變形

00:23:06.186 --> 00:23:10.123
因此 指定單元格尺寸
使用三種機制中的一種

00:23:10.390 --> 00:23:11.325
非常簡單

00:23:11.725 --> 00:23:14.695
大部分應用使用自動佈局
但對於不使用自動佈局的應用

00:23:14.761 --> 00:23:18.465
可以通過第二個機制
實現更多的手動控制

00:23:19.333 --> 00:23:22.202
但是我們發現
對於某些類型的佈局

00:23:22.536 --> 00:23:26.406
選擇一個適當的預估尺寸
非常有挑戰性

00:23:26.974 --> 00:23:29.042
因爲有時候很難猜測

00:23:29.943 --> 00:23:32.079
我的意思是有時候你要用哪個？

00:23:32.312 --> 00:23:35.215
50乘50、100乘100 等等

00:23:35.382 --> 00:23:36.383
很難說

00:23:37.384 --> 00:23:40.354
對於這種類型的佈局來說
很酷的是

00:23:40.754 --> 00:23:43.390
如果流佈局能適應它的預期尺寸

00:23:44.157 --> 00:23:48.695
然後使用這個數
而不是計算預估尺寸

00:23:48.862 --> 00:23:51.765
通過我們已經訂好的內容的實際尺寸

00:23:52.966 --> 00:23:56.603
在iOS 10中 我們有個新API
可以在流佈局中實現那個功能

00:23:57.804 --> 00:24:00.941
你要做的就是將流
layout.EstimatedItemSize設置爲

00:24:01.008 --> 00:24:05.379
新常量 UICollectionView
FlowLayoutAutomaticSize

00:24:11.785 --> 00:24:15.255
通過將預估尺寸設爲自動調整尺寸

00:24:15.489 --> 00:24:17.724
這就表示
CollectionViewFlowLayout

00:24:17.791 --> 00:24:19.293
會替你計算

00:24:19.726 --> 00:24:23.397
它將保留一個已訂好尺寸的
全部單元格的流水賬

00:24:23.864 --> 00:24:27.267
並使用那個流水賬來影響
之後的尺寸預估值

00:24:28.101 --> 00:24:29.169
等會兒就看到了

00:24:29.469 --> 00:24:31.872
這使得流佈局更精確

00:24:31.939 --> 00:24:33.941
當指定CollectionView
單元格的尺寸時

00:24:34.007 --> 00:24:37.077
以獲得更好的性能
和更精確的佈局

00:24:37.144 --> 00:24:38.078
在我們指定尺寸時

00:24:38.712 --> 00:24:42.216
我們要做一個演示來展示

00:24:42.282 --> 00:24:45.719
UICollectionViewFlowLayout
自動調整尺寸的好處

00:24:50.490 --> 00:24:52.192
我要切回到iPad

00:25:00.334 --> 00:25:03.504
在這裏我們有一個使用流佈局的
CollectionView

00:25:04.104 --> 00:25:07.541
每個單元格代表文本運行中的一個詞

00:25:08.442 --> 00:25:11.645
澄清一下 我們不提倡
創建文本查看器

00:25:11.712 --> 00:25:13.647
或使用UICollectionView編輯器

00:25:14.314 --> 00:25:15.983
但作爲演示效果很好

00:25:17.050 --> 00:25:18.986
我要把應用放在模式中

00:25:20.120 --> 00:25:24.091
可以觀察到流佈局
當給每個單元格指定尺寸時

00:25:24.858 --> 00:25:26.393
用戶永遠不會看到這些

00:25:26.793 --> 00:25:30.631
但這種方式可以很好地瞭解
這個新API的優點

00:25:31.331 --> 00:25:35.435
讓我們以固定的預估值開始吧
就像我們在iOS 9上使用的那樣

00:25:36.069 --> 00:25:37.771
那麼 我要打開模擬器

00:25:39.206 --> 00:25:41.775
在這裏 你可以看到
我們已經給每個單元格填充了

00:25:41.875 --> 00:25:45.479
初始預估尺寸
就像我們剛剛猜想的那樣

00:25:46.346 --> 00:25:50.417
在文本運行中我要給第一個詞
Lorem指定一下尺寸

00:25:51.018 --> 00:25:52.152
看看會怎麼樣

00:25:54.555 --> 00:25:57.724
那麼 我們給Lorem制定了尺寸
現在已經是正確的尺寸了

00:25:57.991 --> 00:26:01.261
請注意CollectionView
實際上並不接近

00:26:01.528 --> 00:26:03.830
應有的目標佈局尺寸

00:26:04.431 --> 00:26:07.267
我們並沒有使用那個預估值
來影響任何東西

00:26:07.634 --> 00:26:11.305
一切都還是那麼大
跟我們傳過來的初始預估值一樣

00:26:13.841 --> 00:26:17.377
現在 這種情況會持續發生
當我們分別給每個單元格制定尺寸時

00:26:17.511 --> 00:26:18.712
在CollectionView中

00:26:19.713 --> 00:26:24.251
請注意 實際上我們並不能把
任何其他單元格的尺寸

00:26:24.451 --> 00:26:26.887
調整爲我們之前計算好的尺寸

00:26:27.754 --> 00:26:29.122
很明顯

00:26:29.423 --> 00:26:32.960
在文本運行中 當我們給
最後一個詞Fusce制定尺寸時

00:26:33.760 --> 00:26:35.329
當我們要給這個詞制定尺寸時

00:26:36.763 --> 00:26:39.366
你會注意到 我們向上滑動了
所有其他單元格

00:26:39.433 --> 00:26:41.101
使它們的y-位置失效

00:26:42.035 --> 00:26:45.038
我們沒有使用第一行文本的信息

00:26:45.539 --> 00:26:48.275
來影響任何其他單元格的尺寸

00:26:49.510 --> 00:26:52.779
現在我要把設備調成
iOS 10模式

00:26:53.313 --> 00:26:56.750
使用UICollectionViewFlowLayout
自動調整尺寸

00:26:57.351 --> 00:26:58.318
讓我們切換一下

00:26:59.419 --> 00:27:00.988
好的 切換好了
我們已填充

00:27:01.054 --> 00:27:04.791
相同的初始尺寸
幫助你觀察不同之處

00:27:05.692 --> 00:27:07.828
我要給第一個詞Lorem定個尺寸

00:27:08.161 --> 00:27:09.530
看看會發生什麼

00:27:11.098 --> 00:27:14.001
哇哦 我們給第一個單元格重定了尺寸

00:27:14.067 --> 00:27:17.371
並使用那個單元格尺寸
作爲所有其他CollectionView單元格

00:27:17.437 --> 00:27:19.506
運行中的預估值

00:27:20.073 --> 00:27:22.209
現在佈局還不是那麼精確

00:27:22.609 --> 00:27:25.612
但請注意 已經非常貼近
最終的結果了

00:27:25.979 --> 00:27:29.416
事實上 y-位置的高度
非常正確

00:27:30.651 --> 00:27:33.387
請注意 當我給這個文本運行
重新制定尺寸時

00:27:33.453 --> 00:27:37.424
我們實際上是正使它越來越精確

00:27:37.791 --> 00:27:39.893
全面地爲CollectionView單元格調整預估尺寸

00:27:42.062 --> 00:27:44.898
請注意 在文本運行中
給最後一個詞重定尺寸時

00:27:45.832 --> 00:27:49.403
不再使
其他單元格的y-位置失效

00:27:49.937 --> 00:27:52.372
這很棒
可以很大程度上幫助我們

00:27:52.439 --> 00:27:55.275
當你做這樣的操作時
比如scrollToItemAt indexPath

00:27:56.176 --> 00:27:58.011
現在 由於這個API的性質

00:27:58.312 --> 00:28:00.347
你將得到最貨真價實的東西

00:28:00.414 --> 00:28:01.782
使用自動調整尺寸

00:28:02.182 --> 00:28:05.385
如果你的單元格有
相似的寬或高

00:28:05.986 --> 00:28:09.289
這就是自動調整
在iOS 10上的改進

00:28:09.356 --> 00:28:10.524
讓我們再返回去看幻燈片

00:28:18.065 --> 00:28:20.501
這就是
自動調整單元格

00:28:20.567 --> 00:28:24.338
並且現在 我們要談一下
關於我們去年引入的API的信息

00:28:24.838 --> 00:28:26.340
交互式重排序

00:28:28.008 --> 00:28:31.512
這是個很熟悉的用戶體驗
對於表視圖單元格用戶來說

00:28:31.578 --> 00:28:34.815
他們希望用戶能抓住
一段內容然後移動它

00:28:34.882 --> 00:28:37.584
並在你的表視圖中
垂直地重新排列

00:28:38.318 --> 00:28:41.021
去年我們的技術引入了
CollectionView

00:28:41.288 --> 00:28:43.323
通過一個新的交互式重排序API

00:28:43.657 --> 00:28:45.158
讓我們再回到iPad

00:28:45.225 --> 00:28:47.194
看看在演示中是什麼樣的

00:28:57.571 --> 00:28:58.739
切回iPad

00:28:58.805 --> 00:28:59.806
好的
切換好了

00:29:00.240 --> 00:29:03.110
好的 那麼我們有一個非常
漂亮的自定義佈局

00:29:04.545 --> 00:29:05.812
哦 快看這個滾動 Peter

00:29:06.580 --> 00:29:08.182
我們很可能應用了預取

00:29:08.248 --> 00:29:10.317
-非常簡單
-很可能是

00:29:10.584 --> 00:29:11.485
好的 讓我們看一下

00:29:11.552 --> 00:29:14.922
假如用戶喜歡這個內容
但他們想要重新排列這個內容

00:29:15.289 --> 00:29:17.224
可能會用手指拖拽

00:29:17.524 --> 00:29:20.127
在CollectionView中
平滑地移動內容

00:29:20.294 --> 00:29:22.396
請注意 它是如何自動迴流的

00:29:23.063 --> 00:29:26.166
不只是那樣 如果我們改成
一個有着不同尺寸的項

00:29:26.433 --> 00:29:28.001
你也可以進行以上操作

00:29:28.869 --> 00:29:31.371
現在 當用戶完成重新排序後
他們可能會鬆手

00:29:31.672 --> 00:29:34.241
平滑地嵌入
就是這樣

00:29:35.008 --> 00:29:37.611
讓我們再切回幻燈片
讓Peter演示一下API

00:29:38.712 --> 00:29:42.449
這就是iOS 9上的交互式重排序

00:29:42.816 --> 00:29:43.717
這個API

00:29:43.784 --> 00:29:44.885
非常簡單

00:29:46.186 --> 00:29:49.790
要開始一個交互式移動
你要先調用CollectionViews

00:29:49.957 --> 00:29:53.060
beginInteractiveMovement
ForItematindexPath

00:29:53.694 --> 00:29:57.364
索引路徑體現的是
單元格的索引路徑

00:29:57.531 --> 00:29:58.866
我們想要移動的

00:29:59.533 --> 00:30:01.602
如果你這樣做是爲了
響應某個手勢

00:30:01.869 --> 00:30:04.238
你可以點擊測試
CollectionView

00:30:04.838 --> 00:30:07.207
使用本地項的索引路徑

00:30:08.041 --> 00:30:10.577
接下來 手勢每次更新時

00:30:10.878 --> 00:30:13.146
我們都想
更新單元格的位置

00:30:13.213 --> 00:30:14.781
響應手指的操作

00:30:15.449 --> 00:30:19.386
爲此 我們要調用updateInteractive
MovementTargetPosition

00:30:19.953 --> 00:30:24.091
在CollectionView
的座標空間傳遞手勢的位置

00:30:25.893 --> 00:30:28.762
接下來 當我們想結束
交互式移動

00:30:28.896 --> 00:30:30.230
並確認重新排序時

00:30:30.464 --> 00:30:34.134
我們要在CollectionView上
調用endInteractiveMovement

00:30:35.402 --> 00:30:37.504
CollectionView
會釋放單元格

00:30:37.571 --> 00:30:39.673
正確處理所有佈局屬性

00:30:40.007 --> 00:30:42.342
然後 返回一條信息
給應用的數據源

00:30:42.809 --> 00:30:45.412
這樣你可以在模型中實現真正的重新排序

00:30:47.381 --> 00:30:48.215
現在

00:30:48.649 --> 00:30:49.683
如果手勢取消了

00:30:49.750 --> 00:30:52.119
或你不允許重新排序
此時

00:30:52.553 --> 00:30:55.622
你可調用CollectionView的
cancelInteractiveMovement

00:30:56.356 --> 00:30:58.892
在這裏 我們會把一切恢復成
原來的樣子

00:30:59.560 --> 00:31:01.328
並且我們不會調用數據源

00:31:02.396 --> 00:31:05.299
現在對於使用了UICollection
ViewController的人來說

00:31:05.632 --> 00:31:07.568
你的使用更加方便

00:31:08.235 --> 00:31:10.604
你只需要設置
安裝交互式移動

00:31:10.671 --> 00:31:13.273
標準手勢屬性爲真

00:31:13.941 --> 00:31:17.010
CollectionViewController
將添加一個手勢

00:31:17.077 --> 00:31:19.746
替你調用這些方法

00:31:20.113 --> 00:31:23.116
你要做的就是
實現數據源部分

00:31:24.618 --> 00:31:27.955
這就是我們去年在iOS 9中
發佈的API

00:31:29.256 --> 00:31:33.193
今年 我們非常驕傲地宣佈
我們即將在這個功能中添加分頁支持

00:31:33.293 --> 00:31:36.997
現在 沒有新API
就是最好的API

00:31:37.064 --> 00:31:40.300
自CollectionView
從UIScrollView中衍生出來之後

00:31:40.367 --> 00:31:41.335
你所要做的就是

00:31:41.568 --> 00:31:44.271
設置isPagingEnabled
屬性

00:31:44.338 --> 00:31:46.707
ScrollView的交互式屬性
爲真

00:31:46.940 --> 00:31:48.375
這樣就會開啓新API

00:31:49.009 --> 00:31:50.978
讓我們切回iPad
在演示中看一下

00:31:51.945 --> 00:31:55.315
在這裏 我們有一個水平滾動的
CollectionView

00:31:56.416 --> 00:32:00.053
當前並沒有使用分頁
而是連續的

00:32:00.287 --> 00:32:02.523
看那個平滑的
滾動體驗

00:32:02.689 --> 00:32:03.524
耶

00:32:04.224 --> 00:32:07.928
那麼在重新排序中
當我們連續滾動時

00:32:08.495 --> 00:32:10.163
我們選擇CollectionView單元格

00:32:10.497 --> 00:32:12.599
並把它移動到屏幕的邊緣

00:32:12.799 --> 00:32:15.502
然後我們就得到了非常好的
自動滾動行爲

00:32:15.802 --> 00:32:19.673
許多基於CollectionView
的應用用戶應該很熟悉這個操作

00:32:21.074 --> 00:32:23.377
現在 我要開啓分頁支持

00:32:24.044 --> 00:32:27.748
我們可看到CollectionView
現有了頁面尺寸遞增

00:32:28.182 --> 00:32:31.285
對於某些類型的CollectionView來說
這非常自然

00:32:31.852 --> 00:32:33.086
這是新增的功能

00:32:34.121 --> 00:32:36.156
我們調用的是相同的重排序API

00:32:36.523 --> 00:32:40.994
但iOS 10中的新特性是
重排序能和分頁可以同時使用

00:32:41.628 --> 00:32:44.097
所以 當我把單元格移動到
屏幕邊緣時

00:32:46.266 --> 00:32:49.336
我們將以頁面尺寸遞增值自動滾動

00:32:50.771 --> 00:32:54.741
這可以使應用獲得真正的
主屏幕式重排序體驗

00:32:54.975 --> 00:32:56.877
我鬆開手 就是這樣

00:33:03.717 --> 00:33:04.952
讓我們再返回幻燈片

00:33:11.058 --> 00:33:12.526
這有點兒像內部戰術

00:33:12.593 --> 00:33:15.829
那麼 我們早期開發iOS 10時

00:33:16.263 --> 00:33:19.099
他經常來我的辦公室
熱情高漲

00:33:19.766 --> 00:33:22.069
“Steve 我正做一個很棒的功能

00:33:22.135 --> 00:33:23.804
開發人員會蹦起來的”

00:33:24.271 --> 00:33:25.105
他當時也蹦起來了

00:33:26.540 --> 00:33:27.741
我同意這種說法 這是個很棒的功能

00:33:27.808 --> 00:33:30.010
我要迫不及待地展示
給開發人員

00:33:30.477 --> 00:33:32.746
那麼在WWDC期間

00:33:32.813 --> 00:33:35.682
他找到了一個能展示這個功能的地方

00:33:35.749 --> 00:33:37.751
於是我們討論這個功能
並跟人們一起分享

00:33:38.552 --> 00:33:40.387
那麼 就在前幾天

00:33:40.487 --> 00:33:42.489
他又說了
“我們必須這樣做 ”

00:33:43.023 --> 00:33:44.358
我說 “好的 沒問題 ”

00:33:44.691 --> 00:33:48.295
兩個幻燈片 九十秒
Peter 你能搞定嗎？

00:33:48.395 --> 00:33:50.397
謝謝Steve
只需要一分鐘

00:33:50.664 --> 00:33:53.233
另一個令我非常激動的功能

00:33:53.300 --> 00:33:55.769
iOS 10中CollectionView的新功能

00:33:55.836 --> 00:33:57.704
就是UIRefreshControl！

00:33:58.038 --> 00:34:01.208
就是這個！
UIRefreshControl現在可以直接

00:34:01.275 --> 00:34:02.743
在CollectionView
的內部支持

00:34:05.779 --> 00:34:08.415
但不只是如此
還可以直接在

00:34:08.482 --> 00:34:12.452
UITableView內部支持 而無需
使用UITableViewController！

00:34:12.619 --> 00:34:16.456
不只是這樣 還由
UIScrollView內部支持

00:34:16.623 --> 00:34:19.960
因爲RefreshControl
現在只是一ScrollView屬性！

00:34:25.565 --> 00:34:27.434
非常簡單易用

00:34:27.835 --> 00:34:30.804
你所要做的就是創建
RefreshControl

00:34:31.438 --> 00:34:33.873
把自己添加爲它的一個目標
通過動作

00:34:34.373 --> 00:34:36.043
然後在CollectionView
上進行設置

00:34:36.109 --> 00:34:38.411
你將實現
立即刷新

00:34:38.712 --> 00:34:40.080
非常感謝Steve
這對於我來說意義重大

00:34:40.147 --> 00:34:41.014
嘿 做的不錯

00:34:41.614 --> 00:34:42.482
幹得好

00:34:46.887 --> 00:34:48.621
就像是我們今天談話的一個總結

00:34:48.688 --> 00:34:52.192
我們回顧了全新的
UICollectionView單元格預取功能

00:34:52.259 --> 00:34:55.495
我們迫不及待地想看到你們
如何在你們的應用中進行應用

00:34:56.196 --> 00:34:58.999
然後我們又談了
新的預取數據源API

00:34:59.066 --> 00:35:00.868
Collection和表視圖

00:35:02.636 --> 00:35:04.972
接下來 我們談了
自動調整單元格的改進

00:35:05.038 --> 00:35:07.241
通過新的自動調整尺寸常量

00:35:09.042 --> 00:35:10.043
然後我們順帶談了

00:35:10.110 --> 00:35:13.046
在iOS 9中引入的API
交互式重排序

00:35:13.113 --> 00:35:15.949
以及在iOS 10上的新的分頁支持

00:35:17.451 --> 00:35:19.386
如果你想查看
示例代碼和其他資源

00:35:19.453 --> 00:35:20.921
關於這個應用和這場演講

00:35:20.988 --> 00:35:23.490
你可以看開發者網站上的這個地址

00:35:24.992 --> 00:35:28.161
我們有一些
與這些技術相關的不錯的演講

00:35:28.495 --> 00:35:29.796
我們再次感謝大家的到來

00:35:29.863 --> 00:35:31.398
-希望你們度過美好的——
-非常感謝