00:00:19.653 --> 00:00:25.692
瞭解Swift功能

00:00:26.226 --> 00:00:29.229
大家好
歡迎參加“瞭解Swift功能”演講

00:00:29.329 --> 00:00:30.397
我是Kyle

00:00:30.831 --> 00:00:34.735
今天能跟大家一起探討Swift
我和Arnold都很激動

00:00:35.435 --> 00:00:39.940
作爲開發人員 Swift提供了廣闊而
強大的設計空間等待我們去探索

00:00:40.474 --> 00:00:43.143
Swift有各種各樣的頭等類型

00:00:43.210 --> 00:00:46.146
以及各種代碼複用和動態機制

00:00:46.880 --> 00:00:49.183
語言中的所有特性都能

00:00:49.283 --> 00:00:51.285
以一種有趣、迅捷的方式結合在一起

00:00:51.451 --> 00:00:55.088
那麼我們該如何縮小這個設計空間

00:00:55.355 --> 00:00:57.191
併爲我們的項目選擇
合適的工具呢？

00:00:57.691 --> 00:01:00.360
嗯 首先 你要考慮到

00:01:00.427 --> 00:01:04.531
Swift的多種抽象機制的建模意義

00:01:04.965 --> 00:01:07.668
值或引用語義是否恰當？

00:01:08.235 --> 00:01:10.871
這個抽象需要有多動態？

00:01:12.306 --> 00:01:14.842
嗯 今天我和Arnold也想使你們

00:01:15.042 --> 00:01:17.444
用性能來縮小設計空間

00:01:17.611 --> 00:01:21.248
以我的經驗來說 考慮性能影響

00:01:21.515 --> 00:01:24.251
總會有一個
更順暢的方案

00:01:25.519 --> 00:01:27.855
那麼 我們主要關注的是性能

00:01:27.921 --> 00:01:29.489
我們會接觸點兒建模

00:01:29.656 --> 00:01:32.960
但我們去年做了一些很不錯的
演講 今年我們也會繼續努力

00:01:33.026 --> 00:01:35.963
主要內容是在Swift中
爲項目建模的強大技巧

00:01:36.063 --> 00:01:37.798
如果你想充分利用本場演講

00:01:37.865 --> 00:01:40.734
我強烈建議你們至少參加
一場這類演講

00:01:41.301 --> 00:01:45.005
好了 那麼
我們想用性能來縮小設計空間

00:01:45.272 --> 00:01:48.141
嗯 理解
性能影響的最好方式是

00:01:48.208 --> 00:01:50.077
Swift抽象機制的

00:01:50.244 --> 00:01:52.646
理解它們的優先執行

00:01:52.713 --> 00:01:54.414
這就是我們今天要講的主題

00:01:55.115 --> 00:01:56.984
我們從識別 開始

00:01:57.050 --> 00:01:59.286
不同的維度

00:01:59.353 --> 00:02:02.356
當評估不同的抽象機制選項時

00:02:02.422 --> 00:02:04.625
其中的每一項 我們都會
演示一些代碼

00:02:04.691 --> 00:02:06.493
用結構和類

00:02:06.560 --> 00:02:09.229
深化我們的心智模型
所涉及到的總開銷

00:02:09.596 --> 00:02:11.365
然後 看看如何應用我們所學的技術

00:02:11.431 --> 00:02:13.600
來清理和加速一些Swift代碼

00:02:14.468 --> 00:02:15.969
在演講的後半場

00:02:16.036 --> 00:02:19.473
我們要評估
面向協議程序設計的性能

00:02:19.540 --> 00:02:22.609
我們要看一下
高級Swift功能的實現

00:02:22.676 --> 00:02:24.478
如協議和泛型

00:02:24.611 --> 00:02:26.113
來更好地理解

00:02:26.180 --> 00:02:28.749
它們的建模和性能影響

00:02:29.049 --> 00:02:32.786
免責聲明：我們要看一下
內存表現

00:02:32.853 --> 00:02:34.655
和所生成代碼的表現

00:02:34.721 --> 00:02:37.257
當Swift編譯和執行
你的代碼時

00:02:37.624 --> 00:02:39.626
這些必然要被簡化

00:02:39.693 --> 00:02:41.962
但我和Arnold認爲
已達到了很好的平衡

00:02:42.029 --> 00:02:44.231
在簡易和準確之間

00:02:44.498 --> 00:02:47.501
這是一個很好的推理出
代碼的心智模型

00:02:48.068 --> 00:02:50.904
好了 讓我們從識別

00:02:50.971 --> 00:02:52.973
性能的不同維度開始吧

00:02:53.440 --> 00:02:57.444
那麼 當你在創建一個抽象
並選擇一個抽象機制時

00:02:57.611 --> 00:02:59.213
你應該問問自己

00:02:59.279 --> 00:03:02.683
我的實例要分配給堆棧還是堆？

00:03:03.350 --> 00:03:05.085
當我傳遞這個實例時

00:03:05.452 --> 00:03:08.288
我要產生多少計算開銷？

00:03:08.722 --> 00:03:10.624
當我在這個實例中調用方法時

00:03:10.791 --> 00:03:13.660
要靜態還是動態發送？

00:03:14.127 --> 00:03:17.531
當我們想快速地寫Swift代碼時
我們就要避免

00:03:17.598 --> 00:03:21.335
爲我們不能利用的動態
和運行時間付出代價

00:03:22.936 --> 00:03:26.306
我們需要學習何時以及如何在

00:03:26.373 --> 00:03:29.376
這些不同維度之間切換
來獲得更好的性能

00:03:30.010 --> 00:03:32.346
好了 我們要講一下每種維度

00:03:32.412 --> 00:03:34.581
一個一個地講 從分配開始

00:03:36.183 --> 00:03:39.586
Swift會替你自動分配內存
並取消內存配額

00:03:39.853 --> 00:03:42.122
有些內存會分配給堆棧

00:03:42.589 --> 00:03:44.591
堆棧是一種非常簡單的數據結構

00:03:44.658 --> 00:03:48.362
你可以推到棧底 並彈出棧底

00:03:48.629 --> 00:03:51.398
因爲你能只添加或移除棧底

00:03:51.465 --> 00:03:54.468
所以我們可以
實現堆棧或實現入棧和出棧

00:03:54.535 --> 00:03:56.770
僅僅通過在棧底放一個指針

00:03:58.172 --> 00:04:00.974
意思是 當我們調用函數時
或不如說

00:04:01.041 --> 00:04:03.844
我們把棧底的指針叫做堆棧指針

00:04:03.911 --> 00:04:07.848
當我們調用函數時 我們
分配我們需要的內存

00:04:08.015 --> 00:04:11.585
僅僅通過遞減堆棧
指針數值獲得空間

00:04:12.186 --> 00:04:14.154
當函數執行完畢之後

00:04:14.221 --> 00:04:16.423
我們可以釋放內存

00:04:16.589 --> 00:04:19.326
只需要把堆棧指針增加至原來
的數值即可

00:04:19.392 --> 00:04:20.961
調用這個函數之前

00:04:21.228 --> 00:04:24.097
現在 如果你並不那麼熟悉
堆棧或堆棧指針

00:04:24.164 --> 00:04:26.033
我想讓你從這個幻燈片中看到

00:04:26.099 --> 00:04:28.135
堆棧分配是多麼快

00:04:28.368 --> 00:04:30.804
字面意思其實是
分配一個整數的消耗

00:04:31.972 --> 00:04:33.941
那麼 這就與堆形成了對比

00:04:34.074 --> 00:04:36.977
堆更動態化 但比堆棧效率低

00:04:37.144 --> 00:04:39.112
堆可以讓你實現堆棧
所不能實現的功能

00:04:39.179 --> 00:04:41.481
比如以動態週期分配內存

00:04:42.282 --> 00:04:44.518
但那需要更高級的數據結構

00:04:44.585 --> 00:04:46.386
那麼 如果你要在堆上分配內存

00:04:46.453 --> 00:04:48.789
你實際上要搜索堆數據結構

00:04:48.856 --> 00:04:51.391
尋找閒置的
適當大小的內存塊

00:04:51.692 --> 00:04:53.660
用完之後要釋放內存

00:04:53.727 --> 00:04:57.397
你要重新把那個內存
插入適當的位置

00:04:58.232 --> 00:04:59.867
很明顯 這涉及的東西更多

00:04:59.933 --> 00:05:02.536
相對於我們在堆棧中實現的
僅僅分配一個整數來說

00:05:02.870 --> 00:05:06.139
但這些不見得是涉及
堆分配的必要的主消耗

00:05:06.540 --> 00:05:10.210
因爲同時可以給多線程分配內存

00:05:10.277 --> 00:05:13.013
堆需要使用鎖
來保護它的完整性

00:05:13.080 --> 00:05:14.915
或其他同步機制

00:05:15.215 --> 00:05:16.650
這是一個很大的消耗

00:05:17.050 --> 00:05:18.886
如果你今天不注意

00:05:19.086 --> 00:05:21.955
你的程序何時及在何處
在堆上分配內存

00:05:22.022 --> 00:05:23.490
僅僅需要多考慮那麼一點兒

00:05:23.557 --> 00:05:26.159
你就能顯著地改善性能

00:05:26.527 --> 00:05:27.528
好了

00:05:27.594 --> 00:05:30.931
讓我們來看一些代碼
看Swift都替我們做了什麼

00:05:31.164 --> 00:05:34.334
在這裏 我們有一個點結構
有x和y存儲屬性

00:05:34.668 --> 00:05:36.336
還有draw方法

00:05:37.004 --> 00:05:39.239
我們用(0, 0)構造點

00:05:39.540 --> 00:05:41.909
把point1賦值給point2
複製一下

00:05:42.109 --> 00:05:44.444
並給point2.x賦一個爲5的值

00:05:44.645 --> 00:05:47.681
然後 我們要開始
使用point1和point2了

00:05:48.015 --> 00:05:49.383
讓我們來看一下

00:05:49.583 --> 00:05:54.354
我們進入這個函數
在我們執行任何代碼之前

00:05:54.421 --> 00:05:59.059
我們已爲point1和point2
實例在堆棧上分配了一個空間

00:05:59.126 --> 00:06:00.661
因爲點是一個結構

00:06:00.794 --> 00:06:04.431
而x和y屬性被存儲在堆棧線中

00:06:04.831 --> 00:06:08.135
那麼 當我們用x爲0
和y爲0來構造點時

00:06:08.202 --> 00:06:10.170
我們所要做的就是
初始化那塊 內存

00:06:10.237 --> 00:06:12.105
我們已經分配到堆棧上的

00:06:12.573 --> 00:06:14.575
當把point1
賦值給point2時

00:06:14.641 --> 00:06:19.713
我們僅僅是複製了那個點
並初始化了point2的內存 也是

00:06:19.780 --> 00:06:21.748
我們已經分配到堆棧上的內存

00:06:21.882 --> 00:06:25.285
請注意 point1和point2
是獨立的實例

00:06:25.352 --> 00:06:28.922
意思就是 當我們給point2.x
賦一個爲5的值時

00:06:28.989 --> 00:06:32.259
point2.x是5
但point1.x仍然是0

00:06:32.326 --> 00:06:34.161
這就是值語義

00:06:34.528 --> 00:06:37.598
然後我們繼續
使用point1 使用point2

00:06:37.664 --> 00:06:39.733
並完成函數的執行

00:06:40.100 --> 00:06:43.670
那麼 我們就可以來釋放
point1和point2的內存

00:06:43.737 --> 00:06:46.006
僅僅通過把堆棧指針的值增至

00:06:46.073 --> 00:06:48.775
我們進入函數之前的值

00:06:49.376 --> 00:06:51.778
跟同樣的代碼比較

00:06:51.879 --> 00:06:54.715
這段代碼僅使用了一個點
該點是一個類 而不是一個結構

00:06:56.183 --> 00:06:58.485
好了 那麼
我們進入這個函數

00:06:58.552 --> 00:07:01.021
就跟剛纔一樣
我們給堆棧分配內存

00:07:01.088 --> 00:07:04.758
但並不實際存儲點的屬性

00:07:04.825 --> 00:07:08.061
我們要給point1和point2
分配內存引用

00:07:08.629 --> 00:07:11.131
引用我們要分配到堆上的內存

00:07:11.198 --> 00:07:13.600
那麼 我們用(0, 0)構造點

00:07:13.667 --> 00:07:16.403
Swift會鎖住堆
並搜索數據結構

00:07:16.470 --> 00:07:18.839
尋找適當大小的閒置內存塊

00:07:19.006 --> 00:07:22.309
然後 得到內存塊後
我們要以x爲0 進行初始化

00:07:22.376 --> 00:07:25.279
y爲0 並且我們要
把point1引用初始化

00:07:25.412 --> 00:07:28.582
用內存地址
到那個堆上的內存

00:07:29.183 --> 00:07:30.918
請注意 當我們在堆上分配時

00:07:31.018 --> 00:07:35.255
Swift其實是爲我們的點類
分配了四個字的存儲

00:07:35.489 --> 00:07:39.493
這跟當我們的點是結構時
所分配的兩個字形成了對比

00:07:39.660 --> 00:07:43.897
這是因爲 現在的點是個類
除了爲x和y存儲的之外

00:07:43.964 --> 00:07:47.067
我們又分配了兩個字
Swift將替我們進行管理

00:07:47.134 --> 00:07:50.904
那些字通過堆圖中的
這些藍色框來指示

00:07:51.505 --> 00:07:53.173
當我們把point1
賦值給point2時

00:07:53.240 --> 00:07:55.209
我們並不是要複製點的內容

00:07:55.275 --> 00:07:56.743
不像當point1是一個結構時所做的那樣

00:07:56.810 --> 00:07:58.412
相反 我們要複製引用

00:07:58.512 --> 00:08:00.681
point1和point2其實指的

00:08:00.747 --> 00:08:03.116
正是堆上的同一個實例

00:08:03.550 --> 00:08:06.420
意思是 當我們給point2.x
賦一個爲5的值時

00:08:06.787 --> 00:08:09.389
point1.x和
point2.x的值都爲5

00:08:09.890 --> 00:08:13.894
這就是引用的語義
可導致非計劃的狀態共享

00:08:14.294 --> 00:08:16.797
然後 我們要使用point1
使用point2

00:08:16.930 --> 00:08:19.433
然後Swift會替我們
釋放這個內存

00:08:19.499 --> 00:08:22.870
鎖住堆 再分配閒置
內存塊到適當的位置

00:08:22.936 --> 00:08:24.438
然後我們就可以出棧了

00:08:25.205 --> 00:08:27.174
好了 我們剛看到了什麼？

00:08:27.508 --> 00:08:30.811
我們看到類的構造
比結構的構造消耗更多

00:08:30.878 --> 00:08:33.480
因爲類需要堆式分配

00:08:35.414 --> 00:08:38.818
由於類是在堆上分配的
並且有引用語義

00:08:39.253 --> 00:08:43.890
所以類有一些強大的特性
如一致性和間接存儲

00:08:44.291 --> 00:08:46.760
但是 如果我們的抽象
不需要這些特性

00:08:47.194 --> 00:08:49.263
我們最好還是用結構

00:08:51.031 --> 00:08:56.703
而且結構不會導致像類那樣的
非計劃的狀態共享

00:08:57.137 --> 00:08:58.338
那麼 我們該如何應用

00:08:58.405 --> 00:09:00.574
以便改善某些Swift代碼的性能呢

00:09:01.141 --> 00:09:04.344
這兒有個例子
是我正在做的一個消息應用

00:09:05.279 --> 00:09:08.348
那麼 從根本上說
這來自視圖層

00:09:08.515 --> 00:09:10.417
我的用戶們發送一條短信

00:09:10.918 --> 00:09:14.288
在那條短信末端
我想畫一個漂亮的氣球

00:09:14.521 --> 00:09:17.157
我的makeBalloon函數
是生成這個圖片的函數

00:09:17.324 --> 00:09:19.092
並支持不同的配置

00:09:19.159 --> 00:09:21.929
或不同氣球的整體配置空間

00:09:21.995 --> 00:09:25.299
比如說 這個氣球
我們看到是藍色的

00:09:25.365 --> 00:09:27.201
方位向右 有個尾部

00:09:27.467 --> 00:09:29.736
我們還支持 比如說 灰色氣球

00:09:29.970 --> 00:09:32.072
方位向左 帶氣泡

00:09:33.340 --> 00:09:37.110
makeBalloon函數執行要快
因爲我會 頻繁地調用它

00:09:37.177 --> 00:09:39.713
在啓動分配和用戶滾動過程中

00:09:39.880 --> 00:09:43.116
所以 我添加了這個緩存層
那麼 對於任何給定的配置

00:09:43.183 --> 00:09:46.854
我從不兩次生成氣球圖片

00:09:46.920 --> 00:09:49.056
如果我已生成了一次
我只需要從緩存中取出即可

00:09:49.590 --> 00:09:53.927
我的實現方式是通過把顏色、
方位和尾部序列化

00:09:53.994 --> 00:09:55.562
到一個鍵中 這個鍵是個字符串

00:09:56.430 --> 00:09:58.599
這裏有一些不妥當的地方

00:09:59.233 --> 00:10:02.336
字符串不見得是這個鍵的
健壯類型

00:10:03.103 --> 00:10:05.272
我用它來呈現這個配置空間

00:10:05.339 --> 00:10:08.108
但我只是把我的狗的名字
放在了那個鍵中

00:10:08.542 --> 00:10:10.110
所以 那兒不是很安全

00:10:10.177 --> 00:10:12.546
而且字符串可以代表很多東西

00:10:12.646 --> 00:10:16.617
因爲它實際上把它的字符內容
間接地存儲在堆上了

00:10:16.683 --> 00:10:19.553
意思是我們每次
調用makeBalloon函數時

00:10:19.620 --> 00:10:22.823
即使我們有緩存命中
我們也會引發堆的分配

00:10:23.690 --> 00:10:24.992
看看是否可以做得更好

00:10:25.259 --> 00:10:28.061
嗯 在Swift中
我們可以只用一個結構

00:10:28.128 --> 00:10:31.365
來表示這個配置空間的
顏色、方位和尾部

00:10:32.099 --> 00:10:35.836
這是一個比字符串更安全地
呈現配置空間的方式

00:10:35.903 --> 00:10:38.372
因爲結構在Swift中是頭等類型

00:10:38.438 --> 00:10:40.707
可以用作我們字典中的鍵

00:10:41.608 --> 00:10:43.877
當調用makeBalloon函數時

00:10:44.011 --> 00:10:46.813
如果我們有緩存命中
就不會有內存消耗

00:10:46.947 --> 00:10:49.783
因爲構造一個
像屬性一這樣的結構

00:10:49.850 --> 00:10:53.187
不需要任何堆式分配
可以在堆棧上進行分配

00:10:54.188 --> 00:10:57.090
更安全 也更快

00:10:57.791 --> 00:11:02.563
讓我們繼續講下一個
性能維度：引用計數

00:11:03.730 --> 00:11:07.234
當我們談堆式分配時
我隱瞞了一個詳細信息

00:11:07.301 --> 00:11:10.237
Swift如何瞭解何時釋放

00:11:11.605 --> 00:11:13.207
在堆上分配的內存是安全的呢？

00:11:13.407 --> 00:11:17.177
嗯 答案是Swift會保持一個
引用個數的總計數

00:11:17.344 --> 00:11:20.681
到堆上任何的實例中
並把它存儲在實例本身

00:11:20.747 --> 00:11:22.816
當你添加引用或移除引用時

00:11:22.883 --> 00:11:25.485
就會增加或減少引用計數

00:11:25.652 --> 00:11:29.022
當計數爲零時
Swift就知道沒有指向

00:11:29.089 --> 00:11:32.893
堆上的這個實例的引用
而且釋放那個內存很安全

00:11:33.627 --> 00:11:35.529
引用計數的關鍵點是

00:11:35.596 --> 00:11:38.932
這是個非常頻繁的運算
實際上

00:11:38.999 --> 00:11:41.502
比只增加和減少一個整數更復雜

00:11:41.668 --> 00:11:44.171
首先
涉及到成對出現的間接層級

00:11:44.638 --> 00:11:48.175
來執行增加和減少

00:11:48.342 --> 00:11:50.911
但更重要的是
跟堆式分配一樣

00:11:51.044 --> 00:11:54.114
需要考慮線程的安全性

00:11:54.214 --> 00:11:57.284
因爲引用能被添加或移除到
任何堆實例

00:11:57.351 --> 00:11:59.019
多線程上的 同時

00:11:59.086 --> 00:12:02.422
我們實際上要自動增加
和減少引用計數

00:12:02.723 --> 00:12:06.426
由於引用計數運算的頻率高
會增加消耗

00:12:07.561 --> 00:12:11.131
讓我們返回去看點類和程序

00:12:11.265 --> 00:12:13.800
看看Swift替我們做了什麼

00:12:14.902 --> 00:12:19.306
那麼 在這裏
我們有用來對比的一些僞代碼

00:12:19.573 --> 00:12:22.776
我們看到 我們的點獲得了
一個附加屬性refCount

00:12:23.210 --> 00:12:26.747
並且Swift添加了一對調用
來保留–

00:12:26.813 --> 00:12:29.049
或一個調用保留
和一個調用釋放

00:12:29.216 --> 00:12:31.518
保留會自動增加
我們的引用計數

00:12:31.618 --> 00:12:34.188
釋放會自動減少
我們的引用計數

00:12:34.288 --> 00:12:36.256
這樣 Swift就可以追蹤

00:12:36.323 --> 00:12:39.826
堆上的點上有多少激活的引用

00:12:41.428 --> 00:12:43.363
好了 如果我們進行快速追蹤

00:12:43.430 --> 00:12:46.466
我們可以看到
在堆上構造點之後

00:12:46.533 --> 00:12:48.402
那個點就被初始化爲
引用計數爲1

00:12:48.468 --> 00:12:51.471
因爲我們有一個
那個點的實時引用

00:12:51.905 --> 00:12:55.742
我們查看整個程序
並把point1賦值給point2

00:12:55.809 --> 00:12:59.046
我們現在就有兩個引用了
那麼Swift已經添加了一個調用

00:12:59.112 --> 00:13:02.716
來自動增加點實例的引用計數

00:13:02.916 --> 00:13:05.919
繼續執行
一旦我們不再使用point1

00:13:07.955 --> 00:13:10.958
Swift會添加一個調用
來自動減少引用計數

00:13:11.024 --> 00:13:13.527
因爲point1不再是
一個激活的引用了

00:13:13.594 --> 00:13:14.862
它所關注的

00:13:15.095 --> 00:13:17.064
同樣地
一旦我們不再使用point2

00:13:17.130 --> 00:13:20.067
Swift會添加另一個
自動減少引用計數

00:13:20.133 --> 00:13:22.636
在這個點上 沒有引用被 使用

00:13:22.703 --> 00:13:24.938
我們的點實例
所以Swift就知道很安全

00:13:25.005 --> 00:13:28.709
會鎖住堆
並把那個內存塊返回給它

00:13:31.545 --> 00:13:32.913
如果是結構會怎麼樣呢？

00:13:33.213 --> 00:13:35.582
結構是否涉及引用計數呢？

00:13:35.649 --> 00:13:37.851
嗯 當我們構造點結構時

00:13:38.218 --> 00:13:39.853
不會涉及任何堆式分配

00:13:40.287 --> 00:13:42.489
當我們複製時
也不會涉及任何堆式分配

00:13:42.556 --> 00:13:44.558
每個步驟都不會涉及引用

00:13:44.625 --> 00:13:48.562
所以 點結構沒有引用計數

00:13:50.330 --> 00:13:52.533
那更復雜的結構呢？

00:13:53.166 --> 00:13:55.302
在這裏 我們有一個
包含文本的標籤結構

00:13:55.369 --> 00:13:58.238
類型爲字符串類型
字體爲UIFont

00:13:58.605 --> 00:14:01.175
我們剛纔提到過字符串
實際上是把它的

00:14:01.241 --> 00:14:03.277
字符內容存儲在堆上

00:14:03.343 --> 00:14:05.112
所以需要引用計數

00:14:05.179 --> 00:14:06.680
字體是一個類

00:14:06.747 --> 00:14:08.482
也需要引用計數

00:14:08.849 --> 00:14:12.219
我們看一下內存表現
標籤有兩個引用

00:14:12.386 --> 00:14:15.422
當我們複製它時
我們實際上增加了兩個引用

00:14:15.489 --> 00:14:18.492
另一個文本存儲
另一個字體

00:14:18.825 --> 00:14:20.294
Swift的追蹤方式是

00:14:20.360 --> 00:14:23.630
這些堆式分配是通過
添加保留和釋放的調用來實現的

00:14:24.398 --> 00:14:26.767
那麼在這裏 我們看到
標籤實際上會引發

00:14:26.834 --> 00:14:29.937
兩倍於那個類應有的引用計數

00:14:31.471 --> 00:14:35.742
好了 總之
由於類是在堆上分配的

00:14:36.310 --> 00:14:38.912
Swift得管理那個
堆式分配的使用期限

00:14:38.979 --> 00:14:40.814
這是通過引用計數實現的

00:14:42.015 --> 00:14:44.117
這並不容易
因爲引用計數運算

00:14:44.218 --> 00:14:47.955
相對頻繁
另外引用計數具備原子性

00:14:48.989 --> 00:14:50.824
這也是不願使用結構的
另一個原因

00:14:51.758 --> 00:14:54.094
但是 如果結構包含引用

00:14:54.228 --> 00:14:56.697
也會進行引用計數

00:14:56.763 --> 00:14:58.665
事實上 結構會
進行引用計數

00:14:58.732 --> 00:15:01.502
相應地與它們所包含的
引用數量成比例地

00:15:01.568 --> 00:15:03.537
所以 如果它們有一個
以上的引用

00:15:04.171 --> 00:15:07.007
它們會保留一個類以上的
引用計數

00:15:07.174 --> 00:15:10.077
讓我們看看如何
把鏈應用到另一個示例

00:15:11.311 --> 00:15:13.914
從我那個假設的消息應用中

00:15:14.448 --> 00:15:17.351
那麼 我的用戶們
不願意只發送文本消息

00:15:17.417 --> 00:15:20.521
他們還想發送附件 如圖片

00:15:20.821 --> 00:15:24.791
那麼 這個結構附件
在應用中是一個模型對象

00:15:24.858 --> 00:15:26.460
有fileURL屬性

00:15:26.527 --> 00:15:30.063
即在磁盤上存儲
這個附件的數據路徑

00:15:30.430 --> 00:15:33.700
有一個通用的唯一標識符
是一個唯一的、隨機生成的標識符

00:15:33.867 --> 00:15:35.802
這樣 我們就可以
識別這個附件了

00:15:35.869 --> 00:15:38.272
在客戶端和服務器端
以及不同的客戶設備上

00:15:38.338 --> 00:15:40.307
還有一個mimeType 用於存儲

00:15:41.208 --> 00:15:45.546
這個附件所使用的數據類型
如JPG、PNG或GIF

00:15:46.113 --> 00:15:47.381
很可能的情況是 唯一重要的代碼

00:15:47.447 --> 00:15:50.284
這個示例中
可能導致初始化失敗 會檢測

00:15:50.417 --> 00:15:52.686
mimeType是否爲
應用所支持的文件類型中的一個

00:15:52.753 --> 00:15:55.189
因爲我並不支持
所有mimeType

00:15:55.255 --> 00:15:57.925
如果不支持 我們就會失敗

00:15:57.991 --> 00:16:01.762
反之 我們會初始化fileURL、
唯一標識和mimeType

00:16:03.463 --> 00:16:05.799
那麼 我們注意到有很多引用計數

00:16:06.800 --> 00:16:09.703
並且 如果我們看一下
這個結構的內存表現

00:16:09.770 --> 00:16:12.439
屬性引發了引用計數

00:16:12.506 --> 00:16:14.408
當傳遞屬性時

00:16:14.474 --> 00:16:17.344
由於在每個結構的底層
有進行堆式分配的引用

00:16:18.345 --> 00:16:19.313
我們可以做得更好

00:16:20.013 --> 00:16:21.915
首先 就像我們剛看到的

00:16:22.716 --> 00:16:24.885
唯一標識是一個
意義明確的概念

00:16:25.052 --> 00:16:29.523
它是一個隨機生成的標識符
有128個位元

00:16:30.123 --> 00:16:33.393
而且我們絕對不想讓你隨意
在唯一標識字段放入任何東西

00:16:33.527 --> 00:16:35.495
且作爲一個字符串
其實你是可放入任何東西的

00:16:35.662 --> 00:16:38.832
嗯 今年 Foundation
增加了一個新的數值類型

00:16:39.499 --> 00:16:44.004
爲唯一標識 這很棒 因爲它會
存儲那128個位元

00:16:44.271 --> 00:16:46.039
直接在結構線中

00:16:46.273 --> 00:16:47.708
讓我們用一下那個新數值類型

00:16:48.242 --> 00:16:50.177
它要實現的是

00:16:50.244 --> 00:16:51.879
移除所有引用計數所帶來的消耗

00:16:51.945 --> 00:16:54.014
爲唯一標識字段
就是那個字符串

00:16:54.314 --> 00:16:55.949
我們將獲得更好的安全性

00:16:56.016 --> 00:16:58.819
因爲我們不能在這兒隨意
放東西了 我們只能放唯一標識

00:16:58.986 --> 00:16:59.953
棒極了

00:17:00.287 --> 00:17:01.555
讓我們看一下文件類型

00:17:02.389 --> 00:17:04.825
以及如何實現文件類型檢測

00:17:05.092 --> 00:17:08.628
今天 我實際上只支持了
文件類型的一個閉集

00:17:08.962 --> 00:17:11.131
JPG、PNG、GIF

00:17:11.999 --> 00:17:14.134
我們都知道
Swift有強大的抽象體系

00:17:14.201 --> 00:17:17.905
來表現固定集合 這是個枚舉

00:17:18.271 --> 00:17:19.839
我要把那個switch語句

00:17:19.906 --> 00:17:21.708
放到可能導致
初始化失敗的程序中

00:17:21.842 --> 00:17:26.480
並把那些mimeType
映射到枚舉中合適的案例中

00:17:26.646 --> 00:17:29.883
那麼 現在 我得到了
更多的mimeType枚舉值

00:17:30.083 --> 00:17:33.220
而且我還獲得了更優化的性能
因爲我不需要 存儲

00:17:33.287 --> 00:17:34.988
在堆上間接地
這些不同的案例

00:17:35.589 --> 00:17:37.958
Swift實際上有一個
非常簡潔、有效的方式

00:17:38.025 --> 00:17:39.393
來寫這段代碼

00:17:39.560 --> 00:17:42.362
就是使用
由原始字符串值支持的枚舉

00:17:42.529 --> 00:17:45.199
所以 這就是有效的代碼
完全一樣

00:17:45.299 --> 00:17:47.034
除了更強大之外

00:17:47.134 --> 00:17:50.204
有同樣的性能特徵
但寫起來更便利

00:17:50.404 --> 00:17:52.272
我們現在看一下附件結構

00:17:52.573 --> 00:17:53.674
該方式使類型更安全

00:17:53.740 --> 00:17:56.109
我們得到了類型非常強大的
唯一標識和mimeType字段

00:17:56.176 --> 00:17:58.812
我們也不用做那麼多引用計數

00:17:58.879 --> 00:18:02.783
因爲唯一標識和mimeType
不需要進行引用計數或堆式分配

00:18:03.884 --> 00:18:07.354
好了 讓我們繼續看
最後一個性能維度

00:18:07.588 --> 00:18:08.655
方法調度

00:18:09.690 --> 00:18:11.825
在運行過程中
當調用一個方法時

00:18:12.092 --> 00:18:14.428
Swift需要執行正確的實現

00:18:15.195 --> 00:18:18.732
是否能在編譯時確定
要執行的實現

00:18:18.799 --> 00:18:20.367
這就是著名的靜態調度

00:18:20.434 --> 00:18:21.935
在運行過程中 我們只能直接跳到

00:18:22.002 --> 00:18:23.904
正確的實現

00:18:24.171 --> 00:18:25.339
這很酷

00:18:25.405 --> 00:18:28.876
因爲編譯器實際上可以看到

00:18:28.942 --> 00:18:31.078
要執行哪些實現

00:18:31.245 --> 00:18:32.446
並且也可以

00:18:32.513 --> 00:18:36.116
強行優化這個代碼
包括一些像內聯的東西

00:18:36.750 --> 00:18:38.919
這跟動態調度形成了對比

00:18:39.953 --> 00:18:41.021
動態調度

00:18:41.955 --> 00:18:44.157
在編譯時我們不能直接決定

00:18:44.224 --> 00:18:45.726
要執行哪個實現

00:18:45.859 --> 00:18:48.795
在運行過程中
我們實際上需要查找實現

00:18:49.763 --> 00:18:50.697
然後跳到那兒

00:18:50.764 --> 00:18:52.533
那麼 對於實現本身 動態調度

00:18:52.599 --> 00:18:54.902
比靜態調度的消耗
並不多

00:18:54.968 --> 00:18:56.470
只有一個間接層級

00:18:56.537 --> 00:18:59.773
沒有一個線程同步像我們之前

00:18:59.840 --> 00:19:02.176
引用計數和堆式分配中的那樣

00:19:02.476 --> 00:19:06.213
但是這個動態調度阻塞了
編譯器的可見性

00:19:06.280 --> 00:19:09.883
所以 編譯器可以
實現所有很酷的優化

00:19:09.950 --> 00:19:11.251
爲靜態調度

00:19:11.318 --> 00:19:15.088
動態調度
編譯器不能推理通過

00:19:16.123 --> 00:19:18.625
那麼 我提到了內聯
什麼是內聯？

00:19:19.092 --> 00:19:22.663
嗯 讓我們返回去看
我們熟悉的點結構

00:19:23.330 --> 00:19:25.599
有一個x和y
還有一個draw方法

00:19:25.666 --> 00:19:27.868
我還添加了這個
drawAPoint方法

00:19:28.202 --> 00:19:31.471
drawAPoint方法在點中應用
只調用draw

00:19:31.705 --> 00:19:32.706
很有意思

00:19:32.773 --> 00:19:35.609
我的程序用(0,0)構造了一個點

00:19:35.676 --> 00:19:37.411
並把那個點傳給drawAPoint

00:19:37.644 --> 00:19:41.181
嗯 drawAPoint函數
和point.draw方法

00:19:41.448 --> 00:19:42.983
都是靜態調度

00:19:45.185 --> 00:19:47.120
意思就是編譯器完全瞭解

00:19:47.187 --> 00:19:49.556
要執行哪些實現

00:19:49.656 --> 00:19:52.793
所以它實際上只要
把drawAPoint調度

00:19:53.193 --> 00:19:56.930
替換爲drawAPoint的實現

00:19:57.431 --> 00:19:59.900
然後再把point.draw方法

00:20:00.000 --> 00:20:01.602
因爲它是個靜態調度

00:20:01.668 --> 00:20:04.071
替換爲實際的 實現即可

00:20:04.137 --> 00:20:05.305
point.draw的

00:20:05.539 --> 00:20:08.342
那麼 當我們在運行過程中
執行代碼時

00:20:08.408 --> 00:20:09.877
我們可以只構造點

00:20:11.411 --> 00:20:13.547
然後運行實現 就完成了

00:20:13.714 --> 00:20:17.818
我們不需要那兩個靜態調度

00:20:17.885 --> 00:20:20.988
以及設置和銷燬
相關聯的堆棧調用

00:20:21.121 --> 00:20:22.322
這很酷

00:20:22.389 --> 00:20:25.626
這就回答了爲什麼是靜態調度
以及靜態調度

00:20:25.692 --> 00:20:27.528
比動態調度要快多少的問題

00:20:28.996 --> 00:20:32.299
然而 就像單一靜態調度
與單一動態調度形成對比一樣

00:20:32.366 --> 00:20:35.802
並沒有太多不同
但是一個完整的靜態調度

00:20:35.869 --> 00:20:38.639
編譯器可以看到整個調度

00:20:38.705 --> 00:20:40.440
因此 動態調度鏈

00:20:40.507 --> 00:20:43.377
要在推理的每一步中被阻塞

00:20:43.443 --> 00:20:44.611
在沒有它的較高層級上

00:20:44.678 --> 00:20:46.213
所以編譯器要能

00:20:46.280 --> 00:20:48.282
分解靜態方法調度鏈

00:20:48.348 --> 00:20:49.983
就像沒有調用棧的

00:20:50.050 --> 00:20:52.553
單一實現

00:20:52.819 --> 00:20:54.154
這很酷

00:20:54.454 --> 00:20:57.558
我們究竟爲什麼要這個
動態調度呢？

00:20:58.025 --> 00:21:01.061
嗯 原因之一是它可以
啓動很強大的東西

00:21:01.261 --> 00:21:02.829
比如多態

00:21:03.063 --> 00:21:05.265
我們看一個傳統的
面向對象的程序

00:21:05.465 --> 00:21:07.968
有一個可繪製的抽象超類

00:21:08.402 --> 00:21:11.905
我可以定義一個
點子類和線子類

00:21:12.039 --> 00:21:14.541
用自定義實現來覆蓋draw

00:21:14.608 --> 00:21:17.711
然後我有個程序
可以多態地

00:21:18.579 --> 00:21:20.581
創建繪製的數組

00:21:20.647 --> 00:21:24.284
可能包含線 可能包含點
可以分別調用draw

00:21:24.952 --> 00:21:26.486
那麼是如何實現的呢？

00:21:27.187 --> 00:21:32.059
嗯 因爲
可繪製的點和線都是類

00:21:32.125 --> 00:21:35.028
我們可以創建一個數組
大小都一樣

00:21:35.095 --> 00:21:37.231
因爲我們在數組中
通過引用來存儲

00:21:37.798 --> 00:21:40.367
然後
當我們查看每一個數組的時候

00:21:40.467 --> 00:21:41.702
在數組上調用draw

00:21:43.103 --> 00:21:47.474
我們明白或者希望
我們有一些直覺

00:21:47.674 --> 00:21:51.178
爲什麼編譯器
不能在編譯時做出決定

00:21:51.245 --> 00:21:53.113
哪個是要執行的正確的實現

00:21:53.380 --> 00:21:57.184
因爲這個d.draw可以是個點
可以是條線

00:21:57.284 --> 00:21:58.585
這是不同的代碼路徑

00:21:58.652 --> 00:22:00.587
那麼 如何決定調用哪個呢？

00:22:00.654 --> 00:22:03.690
嗯 編譯器向類中添加了
另一個字段

00:22:03.790 --> 00:22:06.927
是那個類的信息類型的指針

00:22:06.994 --> 00:22:08.428
存儲在靜態內存中

00:22:08.729 --> 00:22:10.898
因此 當我們調用draw時

00:22:11.031 --> 00:22:14.768
編譯器實際上替我們
生成的是一個對類型的查詢

00:22:14.968 --> 00:22:17.004
查找一個虛擬方法表

00:22:17.070 --> 00:22:19.573
在類型和包含
指針的靜態內存上

00:22:19.640 --> 00:22:21.475
找到要執行的正確的實現

00:22:21.742 --> 00:22:23.744
所以
如果我們修改了這個d.draw

00:22:23.877 --> 00:22:25.412
編譯器替我們做的是

00:22:25.812 --> 00:22:28.549
我們看到
實際是查詢虛擬方法表

00:22:28.615 --> 00:22:30.984
找到要執行的正確的draw實現

00:22:31.151 --> 00:22:34.488
然後把那個實際的實例
作爲隱藏的自-參數傳過來

00:22:36.857 --> 00:22:38.892
好了 那麼 我們看到了什麼？

00:22:40.327 --> 00:22:43.897
嗯 類默認動態地
調度它們的方法

00:22:44.498 --> 00:22:46.633
這對於它本身並沒有什麼不同

00:22:46.767 --> 00:22:50.704
但是如果形成方法鏈或其他形式
可以防止

00:22:51.572 --> 00:22:54.208
內聯優化 並且可以累計

00:22:54.408 --> 00:22:57.444
但是 並不是所有類
都需要動態調度

00:22:57.578 --> 00:23:00.147
如果你從未打算
給一個類創建子類

00:23:00.447 --> 00:23:03.851
你可以把它標記爲最終類
傳給隨後的同事

00:23:03.917 --> 00:23:06.687
和未來的你 那是你的打算

00:23:07.054 --> 00:23:08.355
編譯器會注意到這一點

00:23:08.422 --> 00:23:10.757
並動態地調度這些方法

00:23:11.024 --> 00:23:13.927
此外 如果編譯器
可以推理和證明

00:23:13.994 --> 00:23:16.663
你從不打算在應用中
給類建立子類

00:23:16.730 --> 00:23:19.233
它將適時地替你
把那些動態調度返回

00:23:19.299 --> 00:23:20.934
到靜態調度

00:23:21.235 --> 00:23:23.871
如果你想了解更多實現方式

00:23:24.071 --> 00:23:27.674
請參考去年關於
優化Swift性能的演講

00:23:29.510 --> 00:23:31.078
好了 我們講到哪兒了？

00:23:33.013 --> 00:23:35.883
在演講的上半場
我想讓你瞭解的是

00:23:36.016 --> 00:23:37.584
問你自己的這些問題

00:23:37.951 --> 00:23:39.953
無論何時 當你讀和寫Swift代碼時

00:23:40.554 --> 00:23:42.222
你都應該看和思考

00:23:42.322 --> 00:23:44.625
“這個實例要在堆棧中
還是在堆中分配？”

00:23:45.559 --> 00:23:47.027
當我傳遞這個實例時

00:23:47.160 --> 00:23:49.429
我要引發多少引用計算？

00:23:49.863 --> 00:23:51.498
當我在這個實例中調用方法時

00:23:51.598 --> 00:23:53.967
是動態調度還是靜態調度？

00:23:54.334 --> 00:23:56.136
如果我們不需要執行動態調度

00:23:56.236 --> 00:23:58.038
會影響我們的性能

00:23:58.705 --> 00:24:02.109
如果你是Swift新手
或是使用代碼庫

00:24:02.176 --> 00:24:04.411
從objective C
移植到Swift

00:24:04.478 --> 00:24:08.182
你很可能會更好地利用結構

00:24:08.315 --> 00:24:12.786
就像我們今天在例子中所看到的
爲什麼我使用結構而不是字符串

00:24:14.721 --> 00:24:16.356
有一個問題是

00:24:16.690 --> 00:24:19.526
“如何用結構寫多態代碼？”

00:24:19.593 --> 00:24:20.794
我們還沒有講

00:24:21.428 --> 00:24:23.297
嗯 答案是面向協議程序設計

00:24:23.564 --> 00:24:26.867
現在讓我們歡迎Arnold
來到臺上給大家講解

00:24:31.638 --> 00:24:32.472
去吧

00:24:32.940 --> 00:24:33.774
謝謝Kyle

00:24:34.675 --> 00:24:36.210
大家好 我叫Arnold

00:24:37.010 --> 00:24:39.112
讓我們一起來看一下

00:24:39.246 --> 00:24:42.716
協議類型和通用代碼的實現

00:24:43.183 --> 00:24:45.352
先講協議類型
我們要看如何

00:24:45.485 --> 00:24:49.823
存儲和複製協議類型的變量
以及方法調度的運作

00:24:51.525 --> 00:24:53.627
讓我們再回到我們的應用中

00:24:53.694 --> 00:24:56.463
這次 我們要用
協議類型來實現

00:24:57.297 --> 00:24:59.833
這次我們不再用可繪製的抽象基類

00:25:00.133 --> 00:25:04.304
我們要用聲明瞭draw方法的
可繪製協議

00:25:05.172 --> 00:25:08.141
並且我們有數值類型的點結構

00:25:08.442 --> 00:25:11.278
和遵循協議的線結構

00:25:12.513 --> 00:25:16.750
請注意 我們還有一個
遵循協議的SharedLine類

00:25:17.351 --> 00:25:20.621
然而 我們決定不再讓
由於非計劃共享

00:25:20.754 --> 00:25:24.458
而使類所具有的引用語義

00:25:24.525 --> 00:25:26.426
出現 讓我們停止它

00:25:30.163 --> 00:25:32.032
我們程序仍然是多態的

00:25:32.499 --> 00:25:38.939
我們可以
存儲點類型和線類型的值

00:25:39.339 --> 00:25:41.708
在可繪製的協議類型數組中

00:25:42.142 --> 00:25:45.279
然而 跟以前相比
有一個不同點

00:25:47.047 --> 00:25:49.449
請注意
我們的線數值類型結構

00:25:49.716 --> 00:25:53.787
和點結構並不共享一個
共同的繼承關係

00:25:55.189 --> 00:25:58.825
做V-表調度所必須的
就是Kyle剛展示給我們的機制

00:25:59.359 --> 00:26:03.163
那麼 Swift是如何
調度正確的方法的呢？

00:26:03.997 --> 00:26:06.066
在這個例子中
是通過徹底審查數組實現的

00:26:07.434 --> 00:26:10.938
這個問題的答案是
一個基於表的機制

00:26:11.104 --> 00:26:12.739
叫協議證明表

00:26:13.473 --> 00:26:16.043
每種類型都有一張表

00:26:16.410 --> 00:26:19.379
會在你的應用中實現協議

00:26:20.347 --> 00:26:22.149
並且表中的條目

00:26:22.549 --> 00:26:25.552
會鏈接到類型中的一個實現

00:26:27.921 --> 00:26:30.824
好了 那麼 現在我們瞭解
如何找到那個方法了

00:26:31.491 --> 00:26:33.227
但是仍然有個問題

00:26:33.393 --> 00:26:37.364
“如何把元素從數組中拿到表中？”

00:26:38.232 --> 00:26:39.466
還有另一個問題

00:26:40.467 --> 00:26:44.137
請注意 我們現在有
數值類型的線和點

00:26:44.905 --> 00:26:47.241
線需要四個字

00:26:48.642 --> 00:26:50.143
點需要兩個字

00:26:50.577 --> 00:26:52.179
它們的大小不一樣

00:26:52.746 --> 00:26:56.283
但數組需要
一致地存儲元素

00:26:56.416 --> 00:26:59.620
在數組中以固定的偏移量
那是如何實現的呢？

00:27:01.889 --> 00:27:06.026
這個問題的答案是
Swift使用一個特殊存儲佈局

00:27:06.360 --> 00:27:08.262
叫存在容器

00:27:09.863 --> 00:27:10.831
裏邊有什麼呢？

00:27:13.200 --> 00:27:16.470
存在容器內的前三個字

00:27:16.870 --> 00:27:19.039
是留給valueBuffer的

00:27:20.574 --> 00:27:24.645
小類型 比如我們的點類型
只需要兩個字

00:27:24.711 --> 00:27:26.580
剛好能放進valueBuffer中

00:27:26.680 --> 00:27:30.050
現在 你可能會說
“等一下 那線呢？

00:27:30.350 --> 00:27:32.786
它需要四個字
我們該把它放哪兒去？”

00:27:33.720 --> 00:27:37.324
嗯 在這種情況下
Swift會在堆上分配內存

00:27:38.058 --> 00:27:41.628
並把值存入內存 而且會
給那個內存存一個指針

00:27:42.996 --> 00:27:45.666
在存在容器中

00:27:46.500 --> 00:27:50.003
現在 你看到了
點和線之間的不同點

00:27:50.204 --> 00:27:53.674
因此 存在容器無論如何
得管理這個不同點

00:27:53.907 --> 00:27:55.075
那麼該如何實現呢？

00:27:56.543 --> 00:28:00.948
嗯 答案是 還是
基於表的機制

00:28:01.348 --> 00:28:04.017
在這個示例中
我們叫它值證明表

00:28:05.152 --> 00:28:09.690
值證明表會管理值的有效期

00:28:10.224 --> 00:28:12.960
在程序中
每種類型都有一張表

00:28:14.228 --> 00:28:17.264
現在 讓我們來看一下
局部變量的有效期

00:28:17.331 --> 00:28:19.533
看這個表是如何運作的

00:28:20.334 --> 00:28:24.071
那麼 在協議類型的
局部變量的有效期的開始

00:28:24.137 --> 00:28:27.608
Swift在那個表內部
調用了分配函數

00:28:28.575 --> 00:28:32.880
在這個函數中 因爲這個例子
有一個線值證明表

00:28:32.980 --> 00:28:36.016
我們將在堆上分配內存並
給該內存存一個指針

00:28:36.083 --> 00:28:38.519
存在容器的valueBuffer內

00:28:39.853 --> 00:28:42.322
下一步 Swift要把複製

00:28:42.689 --> 00:28:44.658
值從賦值源代碼中

00:28:44.725 --> 00:28:46.593
初始化局部變量的

00:28:46.727 --> 00:28:48.962
到存在容器中

00:28:49.263 --> 00:28:50.564
我們在這裏有一個線

00:28:51.198 --> 00:28:54.368
所以值證明表的複製條目

00:28:54.601 --> 00:28:58.071
會做出正確的判斷並把它
複製到valueBuffer中

00:28:58.972 --> 00:29:00.140
在堆中分配的

00:29:00.941 --> 00:29:03.076
好了 程序繼續

00:29:03.610 --> 00:29:06.480
我們現在是在局部變量
有效期的最後階段

00:29:06.547 --> 00:29:10.551
Swift會調用值證明
表的破壞條目

00:29:10.784 --> 00:29:14.388
這將遞減可能包含在類型中的

00:29:14.454 --> 00:29:16.123
值的引用計數

00:29:16.924 --> 00:29:19.793
線並沒有任何引用計數
所以這裏沒什麼需要注意的

00:29:20.093 --> 00:29:21.261
然後 在最後

00:29:21.562 --> 00:29:24.431
Swift會調用表中的
解除分配函數

00:29:24.598 --> 00:29:26.767
再說一次
我們有一個線的值證明表

00:29:26.834 --> 00:29:31.238
這將釋放
在堆上爲值分配的內存

00:29:32.439 --> 00:29:34.808
好了 那麼 我們已經看到了

00:29:34.975 --> 00:29:38.679
Swift處理不同種類的值的一般性機制

00:29:38.979 --> 00:29:41.415
但無論如何
它仍需要進入這些表 對吧？

00:29:42.883 --> 00:29:44.952
嗯 答案很明顯

00:29:45.419 --> 00:29:48.255
值證明表的下一條
是一個引用

00:29:48.722 --> 00:29:50.958
在存在容器中對值證明表的

00:29:51.258 --> 00:29:52.526
一個引用

00:29:53.627 --> 00:29:56.864
最後
如何進入協議證明表呢？

00:29:56.930 --> 00:30:00.968
嗯 它是 再說一次
在存在容器中進行引用的

00:30:02.035 --> 00:30:03.370
我們已經看到那個機制

00:30:03.770 --> 00:30:10.611
關於Swift是如何管理
協議類型的值

00:30:10.944 --> 00:30:13.847
讓我們來看個例子

00:30:13.914 --> 00:30:15.883
看看運行中的存在容器

00:30:18.118 --> 00:30:22.689
在這個例子中 我們有一個函數

00:30:22.756 --> 00:30:25.759
把協議類型參數當做局部參數

00:30:26.593 --> 00:30:28.795
並在局部參數上執行draw方法

00:30:29.396 --> 00:30:31.632
然後 我們的程序會創建一個
局部變量

00:30:32.099 --> 00:30:36.837
可繪製的協議類型的
並用點對其進行初始化

00:30:37.571 --> 00:30:40.007
然後把這個局部變量傳給

00:30:40.374 --> 00:30:43.243
一個drawACopy函數調用
作爲它的參數

00:30:44.678 --> 00:30:48.916
爲了顯示Swift編譯器
爲我們生成的代碼

00:30:49.650 --> 00:30:54.388
在這個例子中
我將使用Swift作爲僞代碼註釋

00:30:54.621 --> 00:30:57.925
那麼 對於存在容器而言
我有一個結構

00:30:58.358 --> 00:31:02.829
存儲valueBuffer的三個字

00:31:03.030 --> 00:31:05.899
還有一個值證明表
和協議證明表的引用

00:31:07.501 --> 00:31:10.237
當drawACopy函數調用執行時

00:31:10.838 --> 00:31:16.476
它會接收實參並把它傳給函數

00:31:17.211 --> 00:31:19.012
在生成的代碼中我們看到

00:31:19.179 --> 00:31:21.515
Swift把存在容器傳給了

00:31:21.582 --> 00:31:23.450
實參的函數

00:31:27.087 --> 00:31:28.956
當函數開始執行時

00:31:29.022 --> 00:31:32.593
函數爲那個形參
創建了一個局部變量

00:31:33.894 --> 00:31:35.262
並給它賦了一個實參

00:31:36.330 --> 00:31:38.031
在所生成的代碼中

00:31:40.701 --> 00:31:44.805
Swift將在堆上分配
一個存在容器

00:31:46.139 --> 00:31:50.010
下一步 它將
讀取值證明表和協議證明表

00:31:50.344 --> 00:31:52.779
從實參存在容器中

00:31:53.614 --> 00:31:57.484
並在局部實參容器中
對字段進行初始化

00:31:59.686 --> 00:32:02.456
下一步 它將調用值證明函數

00:32:02.556 --> 00:32:05.859
分配緩衝區 如果必要的話
還會複製值

00:32:06.927 --> 00:32:08.896
在這個例子中 我們傳了一個點

00:32:09.263 --> 00:32:12.099
所以就不需要
任何動態堆式分配了

00:32:12.933 --> 00:32:16.403
這個函數只是從實參中把值複製

00:32:17.171 --> 00:32:20.073
到局部存在容器的
valueBuffer中

00:32:20.841 --> 00:32:23.911
然而 如果我們傳一個線

00:32:24.344 --> 00:32:28.682
這個函數將會分配緩衝區
並在緩衝區中複製值

00:32:31.118 --> 00:32:32.953
下一步執行draw方法

00:32:33.320 --> 00:32:35.989
Swift會從存在容器字段中

00:32:36.356 --> 00:32:38.692
查詢協議證明表

00:32:39.426 --> 00:32:43.096
在那個表的固定偏移中
查詢draw方法

00:32:43.263 --> 00:32:44.932
並跳到那個實現

00:32:45.365 --> 00:32:46.333
但是稍等一下

00:32:47.835 --> 00:32:50.604
還有另一個值證明調用
就是projectBuffer

00:32:50.671 --> 00:32:51.605
它爲什麼會在那兒？

00:32:53.373 --> 00:32:57.711
嗯 draw方法把值的地址
當成了它的輸入

00:32:59.780 --> 00:33:03.884
請注意 這取決於值是否爲

00:33:03.951 --> 00:33:06.920
正好能放進內聯緩衝區的小值
決定了這個地址是否爲

00:33:07.154 --> 00:33:08.655
存在容器的開始

00:33:09.389 --> 00:33:14.061
或若我們有一個大值不適合放進
內聯valueBuffer

00:33:14.361 --> 00:33:17.164
那個地址就是在堆上分配的內存

00:33:17.231 --> 00:33:19.233
的開始

00:33:20.133 --> 00:33:24.004
那麼 這個值證明函數
把這個不同點抽象化了

00:33:24.071 --> 00:33:25.405
根據類型

00:33:26.907 --> 00:33:30.143
然後執行draw方法 執行完畢

00:33:30.310 --> 00:33:32.112
現在 我們是在函數的末端

00:33:32.179 --> 00:33:36.183
意思就是 爲形參創建的
局部變量超出了適用範圍

00:33:37.150 --> 00:33:38.519
所以Swift調用

00:33:38.585 --> 00:33:41.421
一個值證明函數來破壞值

00:33:41.722 --> 00:33:43.624
這將遞減引用計數

00:33:44.157 --> 00:33:45.959
如果值中有引用的話

00:33:46.026 --> 00:33:48.996
並且如果分配了緩衝區
會釋放緩衝區

00:33:50.063 --> 00:33:56.203
函數執行完畢 移除了堆棧

00:33:56.270 --> 00:33:59.106
也移除了在堆棧上創建的

00:33:59.173 --> 00:34:00.507
局部存在容器

00:34:01.942 --> 00:34:05.078
好了 這個工作量很大

00:34:06.113 --> 00:34:06.980
是吧？

00:34:08.047 --> 00:34:10.583
我想告訴你們的是

00:34:10.717 --> 00:34:14.955
這項工作是使結合的值類型

00:34:15.054 --> 00:34:19.359
如結構線和結構點還有協議

00:34:19.659 --> 00:34:22.362
獲得動態行爲、動態多態性

00:34:22.429 --> 00:34:25.032
我們可以 存儲一條線和一個點

00:34:25.465 --> 00:34:29.536
在可繪製的協議類型的數組中

00:34:31.271 --> 00:34:34.574
如果你需要這個多態性
一切都值得你付出

00:34:35.442 --> 00:34:38.612
跟使用類相比

00:34:38.978 --> 00:34:41.315
就像Kyle在示例中
給我們演示的一樣

00:34:41.614 --> 00:34:43.684
因爲類也要查詢V-表

00:34:43.817 --> 00:34:49.456
並且類還有附加的引用計數

00:34:50.924 --> 00:34:55.762
好了 我們已經瞭解
如何複製局部變量

00:34:55.963 --> 00:34:59.233
以及方法調度
如何處理協議類型值

00:35:00.801 --> 00:35:02.402
讓我們看一下存儲屬性

00:35:04.605 --> 00:35:06.773
那麼在這個例子中
我們有個對兒

00:35:07.107 --> 00:35:10.410
包含兩個存儲屬性
第一個和第二個屬性

00:35:11.545 --> 00:35:13.580
即可繪製的協議類型的

00:35:15.215 --> 00:35:18.418
Swift是如何存儲
這兩個存儲屬性的呢？

00:35:19.353 --> 00:35:23.357
嗯 是封閉結構的內聯

00:35:24.124 --> 00:35:27.828
那麼 我們看一下-
當我們分配一個對兒時

00:35:28.161 --> 00:35:31.498
Swift將存儲這兩個
非常必要的存在容器

00:35:31.899 --> 00:35:35.502
對於在封閉結構內聯中存儲
那個對兒來說

00:35:36.770 --> 00:35:39.540
然後 我們的程序就開始執行
並初始化 這個對兒

00:35:39.606 --> 00:35:42.309
線和點
正如我們之前所看到的

00:35:42.709 --> 00:35:45.179
對於線
我們將在堆上分配一個緩衝區

00:35:45.279 --> 00:35:48.482
把點放到內聯valueBuffer
並把它內聯存儲

00:35:48.849 --> 00:35:50.884
到存在容器中

00:35:52.553 --> 00:35:56.390
現在 這種呈現允許
在後面的程序中

00:35:56.823 --> 00:35:58.225
存儲一個不同類型的值

00:35:58.492 --> 00:36:01.495
那麼 程序繼續執行
把線存入第二個元素

00:36:01.628 --> 00:36:04.665
沒什麼問題
但我們現在有兩個堆式分配了

00:36:05.499 --> 00:36:07.234
好的 兩個堆式分配

00:36:07.701 --> 00:36:10.003
嗯 讓我們用另外一個程序

00:36:10.370 --> 00:36:12.472
來說明堆式分配的消耗

00:36:13.807 --> 00:36:15.809
那麼 再一次 我們創建一個線

00:36:16.944 --> 00:36:20.514
然後創建一個對兒
並用線對這個對兒進行初始化

00:36:21.014 --> 00:36:23.817
那麼 我們有一個、
兩個堆式分配

00:36:24.251 --> 00:36:27.087
然後我們再一次複製那個對兒

00:36:27.588 --> 00:36:31.058
堆棧中有兩個存在容器
然後有兩個堆式分配

00:36:32.159 --> 00:36:33.160
現在 你可能會說

00:36:33.427 --> 00:36:35.929
“Kyle剛告訴我們說
堆式分配的消耗很大”

00:36:36.296 --> 00:36:37.731
四個堆式分配？

00:36:38.131 --> 00:36:40.634
嗯 我們能做點什麼嗎？

00:36:42.736 --> 00:36:43.737
嗯

00:36:45.339 --> 00:36:49.943
請記住
存在容器能容納三個字

00:36:50.477 --> 00:36:52.713
可以把引用放進

00:36:52.779 --> 00:36:55.849
那三個字中
因爲引用基本上是一個字

00:36:56.416 --> 00:37:00.454
那麼
如果我們用類代替線來實現

00:37:02.322 --> 00:37:05.659
並且類是個引用語義
因此它們

00:37:05.959 --> 00:37:09.296
通過引用存儲 該引用可放入
valueBuffer中

00:37:11.498 --> 00:37:15.802
當我們把第一個引用複製

00:37:16.203 --> 00:37:19.673
到對兒的第二個字段時
只複製了引用

00:37:20.340 --> 00:37:24.311
我們消耗的只是
附加的引用計數增量

00:37:25.612 --> 00:37:27.314
現在 你可能會說 “等一下

00:37:27.614 --> 00:37:31.118
我們剛纔不是聽說
引用語義會引發

00:37:31.785 --> 00:37:33.787
非計劃的狀態共享嗎？”

00:37:34.188 --> 00:37:38.825
那麼 如果我們
存儲到x1字段

00:37:39.226 --> 00:37:42.229
通過對兒的第二個字段

00:37:42.529 --> 00:37:44.498
第一個字段可以觀察到變更

00:37:45.199 --> 00:37:47.568
這並不是我們想要的結果

00:37:47.634 --> 00:37:49.203
我們想要的是值語義 對吧？

00:37:49.636 --> 00:37:51.605
嗯 我們能做點什麼呢？

00:37:53.073 --> 00:37:56.577
嗯 有一種技術叫複製並寫入

00:37:57.311 --> 00:37:59.079
可以幫助我們處理這個問題

00:38:00.113 --> 00:38:04.318
那麼 在我們寫入類之前

00:38:04.518 --> 00:38:05.986
我們要先查看它的引用計數

00:38:06.887 --> 00:38:07.888
我們已經瞭解到

00:38:07.955 --> 00:38:11.491
當同一實例有一個以上的
明顯引用時

00:38:11.725 --> 00:38:13.794
引用計數將大於一

00:38:13.927 --> 00:38:15.562
二、三、四或五

00:38:15.829 --> 00:38:19.967
如果是這種情況
在我們寫入實例之前

00:38:20.200 --> 00:38:23.370
我們先複製實例
然後寫入那個副本

00:38:23.437 --> 00:38:25.439
這將削弱狀態

00:38:26.740 --> 00:38:30.210
好了 讓我們以線爲例
看看是如何實現的

00:38:34.715 --> 00:38:38.218
我們不直接在線的內部
實現存儲

00:38:38.552 --> 00:38:40.554
創建一個
叫LineStorage的類

00:38:40.888 --> 00:38:43.023
這個類有線結構的所有字段

00:38:43.991 --> 00:38:47.127
然後線結構引用這個存儲

00:38:48.295 --> 00:38:50.097
無論何時
當我們要讀取值時

00:38:50.230 --> 00:38:53.901
我們只需要
從那個存儲內讀取值

00:38:54.735 --> 00:38:57.804
然而 當我們想要修改、
改變值時

00:38:58.272 --> 00:39:00.040
我們首先要查看引用計數

00:39:00.107 --> 00:39:01.341
是否大於一？

00:39:01.808 --> 00:39:05.846
這是Uniquely
Referenced調用要實現的

00:39:06.046 --> 00:39:08.182
它只有一個功能
就是查看引用計數

00:39:08.248 --> 00:39:10.617
是否大於或等於一？

00:39:11.985 --> 00:39:14.188
如果引用計數比一大

00:39:14.688 --> 00:39:15.889
大於一

00:39:16.256 --> 00:39:19.560
就創建一個線存儲的副本
並修改這個副本

00:39:21.061 --> 00:39:27.334
好了 那麼 我們已經瞭解
如何結合一個結構和一個類

00:39:28.368 --> 00:39:30.704
使用複製和寫入獲得間接存儲

00:39:30.771 --> 00:39:34.208
讓我們再回過來看例子
看看發生了什麼

00:39:35.542 --> 00:39:37.611
這次 我們使用間接存儲

00:39:38.846 --> 00:39:40.247
我們再創建一個線

00:39:40.647 --> 00:39:43.483
這將在堆上創建一個線存儲對象

00:39:43.817 --> 00:39:46.420
然後 我們用那個線
對對兒進行初始化

00:39:46.920 --> 00:39:51.258
這次 只複製線存儲的引用

00:39:54.695 --> 00:39:56.263
當我們複製線時

00:40:00.033 --> 00:40:03.804
只會複製引用
引用計數會遞增

00:40:03.871 --> 00:40:06.907
這比堆式分配的消耗小多了

00:40:07.140 --> 00:40:08.642
這是個不錯的交易

00:40:15.516 --> 00:40:20.787
好了 我們已經瞭解如何複製和存儲
協議類型的變量

00:40:20.888 --> 00:40:23.790
以及方法調度的運作方式

00:40:24.124 --> 00:40:27.227
讓我們看一下
這些對於性能的意義

00:40:28.462 --> 00:40:31.431
如果協議類型包含能放進存在容器的
內聯valueBuffer中

00:40:31.698 --> 00:40:33.667
的小值

00:40:33.734 --> 00:40:37.171
那麼就不存在堆式分配

00:40:38.305 --> 00:40:40.607
如果結構不包含引用

00:40:40.807 --> 00:40:44.011
也就無所謂引用計數了
所以 這真的是一種快速編碼

00:40:44.545 --> 00:40:47.014
然而 由於間接

00:40:47.881 --> 00:40:51.451
查詢值證明表和協議證明表

00:40:51.718 --> 00:40:56.690
我們得到了完整的動態調度

00:40:57.624 --> 00:41:00.494
這就允許動態的多態行爲

00:41:03.397 --> 00:41:06.934
跟大值比較
大值會引發堆式分配

00:41:07.034 --> 00:41:10.337
無論什麼時候初始化
或賦予協議類型的變量

00:41:12.439 --> 00:41:13.941
可能也將引發引用計數

00:41:14.074 --> 00:41:16.643
如果大值結構包含引用的話

00:41:19.713 --> 00:41:21.348
然而 我演示了一種技術

00:41:21.415 --> 00:41:24.685
就是使用
可複製和寫入的間接存儲

00:41:24.885 --> 00:41:28.255
承擔堆式分配的部分消耗

00:41:32.059 --> 00:41:33.794
這適用於消耗較少的引用計數

00:41:35.596 --> 00:41:40.834
請注意 與使用類相比
很有優勢

00:41:41.468 --> 00:41:43.370
類還會引發引用計數

00:41:46.106 --> 00:41:48.475
並在初始化時進行分配

00:41:50.277 --> 00:41:51.778
這是筆好交易

00:41:53.747 --> 00:41:58.018
好了 那麼 我們回顧一下
簡而言之

00:41:58.085 --> 00:42:02.589
協議類型提供
多態的動態形式

00:42:03.257 --> 00:42:06.760
值類型可以跟協議一起使用

00:42:07.361 --> 00:42:12.566
並可以在協議類型的數組內
存儲線和點

00:42:13.400 --> 00:42:16.103
這是通過協議 實現的

00:42:16.170 --> 00:42:19.006
和值證明表以及存在容器

00:42:19.973 --> 00:42:23.844
複製大值會引發堆式分配

00:42:23.911 --> 00:42:26.680
然而 我講了一種
如何解決這個問題的技巧

00:42:26.747 --> 00:42:30.350
即通過用間接存儲
及複製和寫入實現結構

00:42:32.586 --> 00:42:36.256
好了 讓我們再回到應用中

00:42:36.924 --> 00:42:39.826
那麼 在我們的應用中
我們需要draw一個函數

00:42:39.893 --> 00:42:43.030
以協議類型爲形參

00:42:43.997 --> 00:42:45.666
然而 我們的使用方式是

00:42:45.966 --> 00:42:48.902
我們要一直在具體類型上使用

00:42:49.536 --> 00:42:51.104
在這裏 我們要在線上使用

00:42:52.139 --> 00:42:54.808
稍後 我們會在點上使用

00:42:55.943 --> 00:42:57.010
然後我們會想“嗯

00:42:58.979 --> 00:43:00.581
我們能在此使用通用代碼嗎？”

00:43:01.248 --> 00:43:02.349
嗯 是的 我們能

00:43:02.950 --> 00:43:04.084
讓我們看一下

00:43:04.284 --> 00:43:08.589
在演講的最後
我要談一下

00:43:08.889 --> 00:43:12.559
通用類型的變量如何存儲和複製
以及變量與方法調度的運作方式

00:43:12.926 --> 00:43:17.531
那麼 再返回我們的應用
這次 我們要使用通用代碼來實現

00:43:17.598 --> 00:43:21.168
DrawACopy方法把一個
泛型參數限制變得可繪製

00:43:22.202 --> 00:43:24.071
程序的其它部分保持不變

00:43:26.507 --> 00:43:31.745
那麼 跟協議類型
有什麼不同呢？

00:43:33.914 --> 00:43:37.484
通用代碼支持多態的
更靜態的形式

00:43:37.551 --> 00:43:39.419
也叫做參數多態性

00:43:39.720 --> 00:43:41.455
每種調用情境都有一種類型

00:43:42.322 --> 00:43:45.492
這是什麼意思呢？
嗯 讓我們看這個例子

00:43:46.994 --> 00:43:48.262
我們有foo函數

00:43:49.229 --> 00:43:52.199
這個函數把泛型參數T限制
變得可繪製

00:43:52.733 --> 00:43:55.435
並把這個參數傳給bar函數

00:43:56.236 --> 00:43:58.839
這個函數再一次取走泛型參數T

00:43:59.339 --> 00:44:01.141
然後 我們的程序創建一個點

00:44:01.308 --> 00:44:03.510
並把這個點傳給foo函數

00:44:04.344 --> 00:44:06.213
當函數執行時

00:44:07.481 --> 00:44:12.252
Swift會把泛型類型T綁定到

00:44:12.719 --> 00:44:18.125
本次調用中所使用的類型
在這個例子中是點

00:44:19.426 --> 00:44:21.795
當foo函數帶着這個綁定執行時

00:44:22.729 --> 00:44:25.966
它會進入bar的函數調用

00:44:27.367 --> 00:44:31.171
局部變量的類型是剛發現的
也就是點

00:44:31.505 --> 00:44:34.541
那麼 泛型參數T再次

00:44:34.608 --> 00:44:37.878
在這個調用情境中
通過點類型進行綁定

00:44:38.278 --> 00:44:42.249
我們可以看到 在調用鏈中
類型隨着參數被取而代之

00:44:42.816 --> 00:44:44.151
這正是我們的用意...

00:44:45.385 --> 00:44:48.589
通過更靜態的多態形式
或參數化的多態性

00:44:48.689 --> 00:44:51.558
那麼 讓我們看看Swift
是如何在後臺實現的

00:44:53.660 --> 00:44:56.597
讓我們再次回到
drawACopy函數

00:44:58.599 --> 00:45:00.400
在這個例子中
我們傳遞了一個點

00:45:04.938 --> 00:45:08.775
就像我們使用協議類型時一樣
有一個共享的實現

00:45:10.711 --> 00:45:13.247
這個共享的實現
如果我可以給你展示它的代碼

00:45:13.313 --> 00:45:17.050
就像之前展示的協議類型的
代碼一樣 兩者的代碼看起來很相似

00:45:18.418 --> 00:45:20.487
可以使用協議和值證明表

00:45:20.554 --> 00:45:24.157
在函數內部執行運算

00:45:26.493 --> 00:45:29.897
然而 因爲每種調用情境
都有一個類型

00:45:30.030 --> 00:45:32.533
所以
Swift不會在這裏使用存在容器

00:45:34.535 --> 00:45:38.672
相反 它可以傳遞值證明表

00:45:38.739 --> 00:45:40.607
和協議證明表– 點的

00:45:40.674 --> 00:45:43.710
在這次調用中使用的類型的

00:45:43.777 --> 00:45:45.712
作爲函數的附加參數

00:45:47.080 --> 00:45:49.082
因此 在這個例子中
我們看到點和線的

00:45:49.149 --> 00:45:50.651
值證明表被傳過去了

00:45:51.218 --> 00:45:53.520
在那個函數的執行過程中

00:45:53.587 --> 00:45:57.858
當我們爲參數創建局部變量時

00:45:59.092 --> 00:46:01.328
Swift將使用值證明表

00:46:01.428 --> 00:46:04.598
在堆上分配可能必要的緩衝區

00:46:04.831 --> 00:46:10.170
並根據目的地
執行賦值源代碼的副本

00:46:11.138 --> 00:46:15.309
當在局部參數上執行
draw方法時 很相似

00:46:15.375 --> 00:46:18.178
它將使用所傳遞的協議證明表

00:46:18.512 --> 00:46:21.348
在表中查詢
固定偏移的draw方法

00:46:21.415 --> 00:46:22.983
並跳到那個實現

00:46:25.619 --> 00:46:28.822
我剛剛說過了
這裏沒有存在容器

00:46:29.590 --> 00:46:33.160
那麼 Swift是如何
給局部參數

00:46:33.227 --> 00:46:36.330
給爲這個參數創建的
局部變量

00:46:36.430 --> 00:46:38.599
分配所需要的內存呢？

00:46:39.867 --> 00:46:44.037
嗯 它在堆棧上
分配一個valueBuffer

00:46:44.104 --> 00:46:46.573
該valueBuffer仍是三個字

00:46:47.040 --> 00:46:50.444
像點這樣的小值
會放進valueBuffer

00:46:51.712 --> 00:46:56.950
像線那樣的大值
仍然會存在堆上

00:46:57.117 --> 00:47:01.288
並且我們在局部存在內存裏
存了一個指示器

00:47:04.324 --> 00:47:07.628
所有這些都是爲了使用值證明表

00:47:09.096 --> 00:47:12.199
現在 你可能會問
“這樣會更快嗎？這樣會更好嗎？”

00:47:12.699 --> 00:47:16.970
“我可不可以不只使用協議類型？”

00:47:18.105 --> 00:47:23.043
嗯 多態的靜態形式
可以使編譯器優化

00:47:23.710 --> 00:47:25.846
叫做泛型特化

00:47:25.913 --> 00:47:26.880
讓我們具體看一下

00:47:27.481 --> 00:47:29.449
這是我們的drawACopy函數

00:47:29.516 --> 00:47:33.720
取走泛型參數
我們把一個點傳給

00:47:33.787 --> 00:47:35.689
那個函數調用方法

00:47:37.591 --> 00:47:41.428
我們有靜態多態
調用時有一種類型

00:47:41.595 --> 00:47:46.500
Swift使用那個類型
在函數中替換泛型參數

00:47:46.567 --> 00:47:50.070
並創建那個類型專用的

00:47:50.337 --> 00:47:51.939
函數的一個版本

00:47:52.739 --> 00:47:55.309
那麼 在這裏 我們現在有點函數
的drawACopy了

00:47:55.676 --> 00:47:58.712
取走點類型的參數

00:48:01.148 --> 00:48:04.918
函數內部的代碼
仍然是那個類型專用的

00:48:06.053 --> 00:48:09.289
就像Kyle給我們的展示的一樣
這是非常迅捷的編碼

00:48:10.757 --> 00:48:15.963
Swift將給程序中的調用
所使用的每個類型都創建一個版本

00:48:16.029 --> 00:48:19.900
那麼 如果我們在點中
調用線上的drawACopy函數

00:48:19.967 --> 00:48:23.770
它將特化並創建
那個函數的兩個版本

00:48:24.271 --> 00:48:26.006
現在 你可能會問“等一下

00:48:26.073 --> 00:48:29.109
這可能會大量增加代碼量 對嗎？”

00:48:30.210 --> 00:48:32.913
但是 由於靜態類型信息

00:48:32.980 --> 00:48:37.451
不能使編譯器優化

00:48:37.918 --> 00:48:41.021
Swift實際上可能會減少代碼量

00:48:41.221 --> 00:48:45.125
那麼 比如說
它將內聯點函數的drawACopy

00:48:45.425 --> 00:48:48.962
然後進一步優化代碼
因爲現在有更多的情境了

00:48:49.730 --> 00:48:54.568
因此 那個函數調用
基本上可以爲這一條線

00:48:54.635 --> 00:48:58.138
而正如Kyle所說的
這可以進一步減少爲

00:48:58.338 --> 00:49:00.374
draw的實現

00:49:01.141 --> 00:49:04.711
現在 不再引用
點方法的drawACopy了

00:49:04.811 --> 00:49:06.513
編譯器也將把它移除

00:49:06.580 --> 00:49:09.683
並在線示例中執行類似的優化

00:49:09.750 --> 00:49:11.752
因此 幾乎不太可能發生

00:49:11.852 --> 00:49:15.289
編譯器優化會增加代碼量

00:49:15.689 --> 00:49:17.858
有可能發生
但不一定是在這種情況下發生

00:49:20.794 --> 00:49:23.463
好的 那麼 我們已經瞭解特化

00:49:23.664 --> 00:49:26.366
但還有一個問題
“何時進行？”

00:49:28.702 --> 00:49:31.371
嗯 讓我們看一個小例子

00:49:31.438 --> 00:49:36.243
那麼 我們定義了一個點
然後創建了那個點類型的局部變量-

00:49:36.310 --> 00:49:39.513
把它初始化到一個點
然後把那個點傳給

00:49:39.680 --> 00:49:43.617
drawACopy函數

00:49:44.184 --> 00:49:47.221
爲了特化這個代碼 Swift需要

00:49:47.287 --> 00:49:50.123
在這次調用中推斷出類型

00:49:51.091 --> 00:49:53.994
它是可以實現的
因爲它可以看到那個局部變量

00:49:54.294 --> 00:49:55.896
再返回去看它的初始化

00:49:55.963 --> 00:49:58.665
然後就會看到
它被初始化成了一個點

00:50:01.735 --> 00:50:03.937
Swift還需要有
在特化過程中所使用的類型

00:50:04.137 --> 00:50:07.107
的定義

00:50:07.274 --> 00:50:10.677
和通用函數自身

00:50:10.744 --> 00:50:13.747
這裏的情況是這樣的
在一個文件中進行了所有定義

00:50:16.116 --> 00:50:19.786
這個文件能在很大程度上
提高整個模塊優化

00:50:19.987 --> 00:50:21.655
的優化機率

00:50:22.322 --> 00:50:23.924
讓我們看看這是爲什麼

00:50:26.193 --> 00:50:31.465
比如說
我把點的定義挪到另一個文件中

00:50:32.432 --> 00:50:34.868
如果我們分別編譯那兩個文件

00:50:36.703 --> 00:50:39.640
當我編譯UsePoint文件時

00:50:39.973 --> 00:50:42.476
點的定義就不再可用了

00:50:42.543 --> 00:50:45.212
因爲編譯器已經
分別編譯了那兩個文件

00:50:45.646 --> 00:50:47.981
然而 對於整個模塊優化

00:50:48.916 --> 00:50:52.519
編譯器將把兩個文件
作爲一個單元一起進行編譯

00:50:53.020 --> 00:50:57.491
洞悉點文件的定義

00:50:58.058 --> 00:51:00.093
並進行優化

00:51:00.727 --> 00:51:04.798
因爲這能很大程度地
提高優化機率

00:51:04.865 --> 00:51:08.936
現在 我們在Xcode 8中
啓動了默認整體模塊優化

00:51:14.842 --> 00:51:17.778
好的 讓我們
再返回來看我們的程序

00:51:18.545 --> 00:51:24.418
那麼 在我們的程序中
我們有可繪製的協議類型的對兒

00:51:26.420 --> 00:51:29.056
並且 我們再次意識到
要如何使用它

00:51:31.091 --> 00:51:34.094
無論什麼時候我們要創建
一個對兒時 我們實際上是想

00:51:34.161 --> 00:51:36.029
創建同一個類型的對兒

00:51:36.163 --> 00:51:39.800
比如一對兒線或一對兒點

00:51:43.537 --> 00:51:48.242
請記住 一對兒線的存儲表示

00:51:48.308 --> 00:51:50.043
會消耗兩個堆式分配

00:51:52.846 --> 00:51:55.048
當我們看這個程序時

00:51:55.115 --> 00:51:59.520
我們注意到
我們可以在這裏使用泛型類型

00:52:00.754 --> 00:52:03.257
如果我們把對兒定義爲泛型

00:52:04.324 --> 00:52:08.695
然後那個泛型類型的第一個
和第二個屬性有這種泛型類型

00:52:08.762 --> 00:52:10.998
那麼 編譯器實際上可以強制

00:52:11.365 --> 00:52:15.302
我們只能創建同一個類型的對兒

00:52:16.003 --> 00:52:21.975
此外 我們也不能在後面的程序中
把點存儲到一對兒線中

00:52:23.076 --> 00:52:24.711
這的確是我們想要的結果

00:52:25.879 --> 00:52:30.117
但是這樣的表示對於性能來說
是好是壞呢？

00:52:30.651 --> 00:52:31.852
讓我們看一眼

00:52:34.221 --> 00:52:35.422
那麼 在此我們有對兒

00:52:35.489 --> 00:52:38.926
這次 存儲屬性是泛型類型的

00:52:39.693 --> 00:52:43.230
請記住我剛纔說過的
不能在運行過程中改變類型

00:52:45.699 --> 00:52:49.203
對於生成的代碼來說 這意味着

00:52:49.269 --> 00:52:53.640
Swift可以分配
閉合類型的存儲內聯

00:52:54.875 --> 00:52:56.810
那麼 當我們創建一對兒線時

00:52:57.945 --> 00:53:02.115
給線分配的內存實際上
將被分配給內聯的閉合對兒

00:53:02.916 --> 00:53:05.118
不需要任何額外的堆式分配

00:53:06.486 --> 00:53:07.621
這很酷

00:53:09.890 --> 00:53:15.095
然而 就像我所說的
你不能再向不同類型的值中存儲

00:53:15.162 --> 00:53:16.964
那個存儲屬性了

00:53:17.030 --> 00:53:18.332
但這正是我們想要實現的

00:53:23.170 --> 00:53:26.940
好的 我們已經瞭解了
非專用代碼如何使用

00:53:27.007 --> 00:53:29.042
值證明表和協議證明表

00:53:30.511 --> 00:53:34.381
以及編譯器如何
通用函數的指定類型的版本

00:53:34.448 --> 00:53:37.784
特化代碼創建

00:53:38.552 --> 00:53:40.554
讓我們看一下它的性能

00:53:41.588 --> 00:53:46.994
首先看包含結構的
特化通用代碼

00:53:47.794 --> 00:53:49.830
在這種情況下
我們有性能特性

00:53:49.897 --> 00:53:53.100
與使用結構類型相同
因爲正如我們所看到的

00:53:53.367 --> 00:53:55.002
從本質上說 通用代碼

00:53:55.068 --> 00:53:58.739
看起來就好像是
你按照結構來寫的這個函數

00:53:58.906 --> 00:54:02.242
當我們複製結構類型的值時

00:54:02.342 --> 00:54:04.178
不需要任何堆式分配

00:54:05.112 --> 00:54:06.280
也不需要引用計數

00:54:06.780 --> 00:54:09.049
如果結構不包含任何引用的話

00:54:10.350 --> 00:54:12.386
而且我們有靜態方法調度

00:54:12.519 --> 00:54:14.922
進一步地優化編譯器

00:54:14.988 --> 00:54:19.193
並減少運行—執行時間

00:54:21.862 --> 00:54:26.300
如果我們使用類類型
那麼跟類類型相比

00:54:26.767 --> 00:54:30.237
我們有跟類相似的特性

00:54:30.304 --> 00:54:33.507
堆式分配、
創建實例和引用計數

00:54:33.574 --> 00:54:35.843
是爲了傳遞值

00:54:35.943 --> 00:54:37.845
並對V-表進行動態調度

00:54:39.046 --> 00:54:43.517
現在讓我們看看
包含小值的非特化通用代碼

00:54:43.951 --> 00:54:47.321
不必給局部變量進行堆式分配
正如我們所看到的

00:54:47.387 --> 00:54:52.326
因爲小值可以放入分配到
堆棧中的valueBuffer

00:54:53.493 --> 00:54:56.897
如果值不包含任何引用
也不會有引用計數

00:54:57.831 --> 00:55:01.235
然而 我們在所有潛在的調用情境中

00:55:01.969 --> 00:55:04.304
通過使用證明表

00:55:04.571 --> 00:55:08.141
共享一個實現

00:55:13.780 --> 00:55:16.917
好了 今天我們這場研討會講了

00:55:17.384 --> 00:55:21.088
結構和類的性能特性

00:55:21.588 --> 00:55:26.093
以及通用代碼
和協議類型的運作方式

00:55:26.860 --> 00:55:28.896
我們學到了什麼？

00:55:30.464 --> 00:55:32.299
哦 嗯 就這樣吧

00:55:32.366 --> 00:55:34.535
我忘了該講哪個笑話了

00:55:34.601 --> 00:55:39.773
如果我們使用大值和通用代碼

00:55:39.873 --> 00:55:41.441
就會引發堆式分配

00:55:41.508 --> 00:55:43.343
但我之前展示過
那個技巧 也就是

00:55:43.410 --> 00:55:47.314
使用間接存儲方案

00:55:48.282 --> 00:55:50.350
如果大值包含引用的話

00:55:52.019 --> 00:55:53.353
然後還有引用計數

00:55:53.420 --> 00:55:55.956
然後
我們再一次實現了動態調度

00:55:56.023 --> 00:55:58.659
意思是 我們可以
共享一個通用實現

00:55:59.059 --> 00:56:00.961
在代碼中

00:56:03.664 --> 00:56:04.598
好了

00:56:04.665 --> 00:56:07.167
最後讓我們看一下簡述

00:56:07.601 --> 00:56:09.603
總結

00:56:09.770 --> 00:56:14.208
爲應用中的實體
選擇合適的抽象

00:56:14.441 --> 00:56:17.878
動態運行時間要儘可能少

00:56:19.112 --> 00:56:22.916
這將啓動靜態類型的檢測
編譯器可以確保

00:56:22.983 --> 00:56:28.155
編譯過程中程序的正確性 此外

00:56:28.355 --> 00:56:31.291
編譯器有更多的信息
來優化代碼

00:56:31.391 --> 00:56:32.960
從而得到更迅捷的代碼

00:56:33.560 --> 00:56:36.129
那麼 如果你可以在程序中
使用值類型 如結構和枚舉

00:56:36.296 --> 00:56:39.633
表達實體

00:56:39.967 --> 00:56:42.536
你將得到值語義 這很棒

00:56:42.603 --> 00:56:44.271
不會出現非計劃的狀態共享

00:56:45.038 --> 00:56:47.140
並且你將獲得高度優化的代碼

00:56:49.843 --> 00:56:52.179
如果你因爲需要 使用類 比如

00:56:52.279 --> 00:56:55.682
一個實體或你正在使用
一個面向對象的框架

00:56:56.350 --> 00:57:00.020
Kyle給我們展示瞭如何減少
引用計數的消耗的一些技巧

00:57:02.756 --> 00:57:06.927
如果你的部分程序可以使用
一個更靜態的多態形式來表達

00:57:06.994 --> 00:57:10.063
你可以把通用代碼
和值類型結合起來

00:57:11.198 --> 00:57:15.202
並獲得非常迅捷的代碼

00:57:15.435 --> 00:57:18.238
但共享那個代碼的實現

00:57:19.506 --> 00:57:23.076
如果你需要動態多態 比如

00:57:23.143 --> 00:57:26.180
在我們的可繪製協議類型
示例的數組中

00:57:26.947 --> 00:57:30.684
你可以把協議類型
和值類型相結合

00:57:30.784 --> 00:57:36.623
得到跟使用類得到的代碼
同樣迅捷的代碼

00:57:38.058 --> 00:57:40.561
但你仍然可以停留在值語義內

00:57:42.896 --> 00:57:45.799
如果你遇到了堆式分配問題

00:57:46.066 --> 00:57:49.770
因爲你在協議類型或泛型類型內複製值

00:57:49.870 --> 00:57:53.173
我也給你們展示了一種技巧 也就是

00:57:53.240 --> 00:57:56.677
使用可複製和寫入的
簡潔存儲來處理

00:57:58.812 --> 00:58:03.417
好的 那麼 這裏有一些與建模和性能

00:58:03.817 --> 00:58:05.018
相關的演講

00:58:05.085 --> 00:58:07.988
我強烈推薦你們參加
今天下午的一場演講

00:58:08.121 --> 00:58:11.525
“UIKit應用中以協議和
值爲導向的編程”

00:58:11.692 --> 00:58:12.526
謝謝大家