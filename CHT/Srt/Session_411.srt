00:00:19.353 --> 00:00:21.755
深入系統追溯

00:00:29.963 --> 00:00:33.200
早安 這是演講411
“深入系統追溯”

00:00:33.267 --> 00:00:34.301
我的名字是Chad Woolf

00:00:34.368 --> 00:00:35.669
我是Joe Grzywacz

00:00:36.036 --> 00:00:38.505
我們是Apple的性能工具工程師

00:00:39.273 --> 00:00:42.442
去年的“深入”演講中
我們談了時間分析器

00:00:42.709 --> 00:00:46.280
我們向你展示瞭如何分析你的應用
直到反彙編水平

00:00:46.346 --> 00:00:49.583
我們的目標是向你展示
如何使你的代碼變得儘量迅速

00:00:50.250 --> 00:00:54.321
有時你也許想讓你的優化代碼
運行在多個CPU上

00:00:54.388 --> 00:00:56.256
以完成更多工作

00:00:56.890 --> 00:00:59.626
但這麼做的同時會增加系統負荷

00:01:00.160 --> 00:01:01.962
隨着系統負荷增加

00:01:02.296 --> 00:01:05.832
一些次級反應開始顯現
例如搶佔的增加

00:01:05.899 --> 00:01:08.235
鎖競爭和虛擬內存活動

00:01:08.602 --> 00:01:11.271
這三者任何一個都足以抵消

00:01:11.338 --> 00:01:13.907
你通過時間分析
獲得的優化

00:01:14.775 --> 00:01:17.377
在今天的演講
我們展示如何通過系統追溯

00:01:17.444 --> 00:01:19.980
分析次級反應

00:01:20.414 --> 00:01:22.549
我們也會展示如何有效地加載系統

00:01:22.616 --> 00:01:24.952
同時維持最佳性能

00:01:26.053 --> 00:01:29.022
我們今天的演講是這樣的
我們會談到一些關於系統追溯的內容

00:01:29.089 --> 00:01:31.291
以及爲什麼它適用於應用開發者

00:01:31.525 --> 00:01:33.560
之後我和Joe會帶你瞭解系統追溯

00:01:33.627 --> 00:01:36.363
我們會談到線程 指示

00:01:36.430 --> 00:01:37.931
一點關於虛擬內存的內容

00:01:38.398 --> 00:01:41.335
以及展示一些最佳實例
告訴你如何儘可能利用工具

00:01:42.636 --> 00:01:45.038
爲何應用開發者需要系統追溯？

00:01:45.472 --> 00:01:48.642
當你的應用成爲設備的焦點

00:01:48.942 --> 00:01:51.478
從用戶的角度 它就是系統

00:01:52.112 --> 00:01:55.616
他們不把你的應用
與全部這些系統服務和守護進程相等同

00:01:55.682 --> 00:01:58.952
共同爭奪共享資源
如CPU時間和內存

00:01:59.453 --> 00:02:00.554
他們只會看到你的應用

00:02:00.654 --> 00:02:04.157
如果你的應用出現卡頓
因爲緊張的虛擬內存活動

00:02:04.224 --> 00:02:06.593
或是因爲錯誤優先的線程

00:02:06.827 --> 00:02:09.096
他們會找你以尋找解決方案

00:02:09.596 --> 00:02:10.697
這就是壞消息

00:02:11.698 --> 00:02:12.799
好消息是

00:02:12.866 --> 00:02:15.269
當你的應用成爲設備的焦點

00:02:15.335 --> 00:02:17.504
它是整個設備最重要的

00:02:17.804 --> 00:02:19.206
操作系統知道這一點

00:02:19.273 --> 00:02:22.509
它會毫無保留儘可能多地分配給你
CPU時間和內存

00:02:22.876 --> 00:02:24.845
當我們談到通過系統追溯優化

00:02:25.012 --> 00:02:28.715
我們不是指優化系統
而是優化你的應用

00:02:28.782 --> 00:02:30.617
使用分配所得的資源

00:02:31.752 --> 00:02:33.554
系統追溯
是Instruments的模板之一

00:02:33.620 --> 00:02:35.722
它可以在我們全部四個平臺完美運行

00:02:36.557 --> 00:02:37.724
當你使用它記錄

00:02:37.791 --> 00:02:39.993
它把內核設置成特別的追蹤模式

00:02:40.527 --> 00:02:43.964
記錄全部調度活動 系統調用

00:02:44.398 --> 00:02:46.633
以及發生的虛擬內存操作

00:02:46.900 --> 00:02:50.070
它會隨時間累積
產生大量數據

00:02:50.137 --> 00:02:52.439
所以我們對Instruments 8
的改進之一

00:02:52.506 --> 00:02:55.275
是我們把模板默認地設置成
Windowed Mode

00:02:55.843 --> 00:02:59.012
這代表我們只保留前五秒左右的數據

00:02:59.746 --> 00:03:02.216
優勢是

00:03:02.282 --> 00:03:04.785
你可以開始記錄 設置你的應用

00:03:04.852 --> 00:03:07.888
隨便花多久時間來複現性能問題

00:03:08.021 --> 00:03:10.257
當它復現 按停止鍵

00:03:10.324 --> 00:03:13.393
然後你得到了前五秒的可行動數據

00:03:14.294 --> 00:03:16.330
這是這五秒數據可能的樣子

00:03:16.396 --> 00:03:18.098
追溯記錄會很密集

00:03:18.498 --> 00:03:22.569
我們發現它會很有用
如果你可以把這數據

00:03:22.636 --> 00:03:25.372
和你的應用裏的高級活動相關聯

00:03:25.439 --> 00:03:27.441
比如我是否在更新表視圖

00:03:27.508 --> 00:03:29.443
後臺是否在進行下載

00:03:29.510 --> 00:03:31.979
我是否在更新圖表
這類高級活動

00:03:32.713 --> 00:03:35.115
今年在Instruments 8
我們新增了

00:03:35.182 --> 00:03:36.783
興趣點工具

00:03:37.584 --> 00:03:40.954
興趣點工具其實是一個空白的畫布

00:03:41.021 --> 00:03:43.757
你可以告訴Instruments
你感興趣的地方

00:03:43.824 --> 00:03:45.592
然後我們會爲你把它放進圖表中

00:03:46.226 --> 00:03:48.862
通過你的代碼中使用Signpost
來實現這一功能

00:03:50.130 --> 00:03:52.065
Signposts已經發布一段時間了

00:03:52.132 --> 00:03:56.370
不過以往的使用方法是
調用這個直接系統調用

00:03:56.436 --> 00:03:58.472
從頭文件提取這些宏

00:03:58.539 --> 00:04:01.108
然後把它們放在一起 這有點臃腫

00:04:01.708 --> 00:04:03.744
不僅臃腫

00:04:03.810 --> 00:04:06.680
在今天的Swift世界裏
它甚至無法運行

00:04:06.747 --> 00:04:09.082
我們會拋棄這個方法

00:04:09.850 --> 00:04:12.619
不過在新的操作系統裏
我們增加了這些新的函數

00:04:12.686 --> 00:04:15.856
它們的功能完全一樣
kdebug_signpost

00:04:15.923 --> 00:04:18.591
它們可以在C
Objective-C C++運行

00:04:18.659 --> 00:04:19.860
現在還可以在Swift裏運行

00:04:21.261 --> 00:04:24.665
首先 最簡單的方法是
把一個點事件放入時間軸

00:04:24.731 --> 00:04:26.433
就是這裏的紅色標誌

00:04:26.500 --> 00:04:30.437
你要做的僅僅是
調用kdebug_signpost

00:04:31.104 --> 00:04:33.140
在我們的Mouse Down事件中
每當我們點擊Mouse Down

00:04:33.207 --> 00:04:35.442
你會看到時間軸上出現一個標誌

00:04:36.043 --> 00:04:38.712
它接受一些參數
第一個是代碼

00:04:39.079 --> 00:04:42.683
它只是一個0到16383之間的整數

00:04:42.883 --> 00:04:44.885
用來幫你確定Signpost

00:04:45.419 --> 00:04:48.388
另外四個參數也是整數
可以是你想要的任何數值

00:04:48.455 --> 00:04:51.225
默認情況下 Instruments
會把它帶到UI

00:04:52.392 --> 00:04:53.594
現你可命名這些東西

00:04:53.660 --> 00:04:56.830
切換到Instruments
的配置部分

00:04:57.331 --> 00:04:58.465
然後加入到表視圖

00:04:58.532 --> 00:05:01.535
現在代碼5代表Mouse Down

00:05:01.602 --> 00:05:03.170
下次當我記錄時

00:05:03.237 --> 00:05:06.273
我可以看到那些興趣點
變成了Mouse Downs

00:05:07.407 --> 00:05:09.910
如果你喜歡興趣點工具
你也會喜歡興趣區域工具

00:05:09.977 --> 00:05:13.280
它們基本上是一樣的
只不過它們用來記錄狀態和動作

00:05:13.347 --> 00:05:15.382
或是發生在一段時間裏的事件

00:05:16.016 --> 00:05:19.152
它稍微複雜些
因爲你需要兩次調用而非一次

00:05:19.219 --> 00:05:20.454
你有一個開始和一個結束

00:05:20.821 --> 00:05:23.590
在Instruments裏
還有一個配對規則

00:05:23.991 --> 00:05:26.994
默認情況下規則很簡單
只是使用代碼

00:05:27.060 --> 00:05:28.462
你只需要

00:05:28.729 --> 00:05:30.831
在開始和結束提供相同的代碼

00:05:31.899 --> 00:05:34.268
我們知道這不適用於所有應用

00:05:34.334 --> 00:05:36.970
因爲有些應用會產生一堆開始事件

00:05:37.037 --> 00:05:38.539
緊接着一堆結束事件

00:05:38.839 --> 00:05:42.109
這會導致...
在Instruments內

00:05:42.176 --> 00:05:44.845
如何把它們配對會模糊不清

00:05:44.945 --> 00:05:46.780
所以我們允許你改變配對規則

00:05:46.847 --> 00:05:48.482
來到設置頁

00:05:48.916 --> 00:05:52.419
你可以選擇代碼和第一參數
或是代碼和線程

00:05:53.654 --> 00:05:56.924
代碼和第一參數
代表你的開始和結束

00:05:56.990 --> 00:05:59.726
需要有一樣的代碼和第一個參數

00:06:00.294 --> 00:06:03.964
在這個例子中我們並行開始了
一堆URL下載

00:06:04.331 --> 00:06:07.401
我們用了URL下載任務指針

00:06:07.467 --> 00:06:09.570
作爲第一個參數
你可以看到

00:06:09.636 --> 00:06:12.372
Instruments時間軸上的
這些並行下載

00:06:13.807 --> 00:06:15.075
如果你使用
代碼和線程

00:06:15.742 --> 00:06:17.678
你必須讓

00:06:17.744 --> 00:06:20.614
相同代碼的開始和結束
在同一個線程上產生

00:06:21.048 --> 00:06:22.749
這是一個例子

00:06:23.116 --> 00:06:25.752
不過你可看到它發生在
dispatch_apply塊內

00:06:25.819 --> 00:06:30.490
現在我們的圖表裏有四個興趣區域

00:06:30.557 --> 00:06:32.893
每個線程或工作線程一個

00:06:34.394 --> 00:06:37.431
目前你看到的興趣區域都是紅色的

00:06:37.497 --> 00:06:38.565
非常單調

00:06:38.632 --> 00:06:40.467
如果你願意犧牲最後一個參數

00:06:40.534 --> 00:06:41.668
你可以來到這裏

00:06:42.069 --> 00:06:45.038
勾選這個方格
用最後的參數代表顏色

00:06:46.473 --> 00:06:48.509
在你的第四個參數
你只需提供

00:06:48.575 --> 00:06:51.211
0到4之間的數字

00:06:51.278 --> 00:06:53.413
代表Instruments裏的
五個基本顏色

00:06:53.614 --> 00:06:54.715
在這例子中

00:06:54.781 --> 00:06:56.884
當我的下載任務成功

00:06:56.950 --> 00:06:58.051
我把它設置爲綠色

00:06:58.352 --> 00:07:01.321
如果完成時產生了錯誤
我把它設置爲紅色

00:07:01.388 --> 00:07:04.191
這樣可以清楚地區分成功和失敗

00:07:05.826 --> 00:07:07.060
我們把這全部放在一起

00:07:07.127 --> 00:07:09.496
你可以看到這是多麼簡單

00:07:09.563 --> 00:07:14.368
把我之前展示的巨大複雜的追溯數據
和你應用中的高級活動關聯起來

00:07:15.068 --> 00:07:18.472
比如 你可以看到
這一堆活動其實是

00:07:18.739 --> 00:07:20.574
我們的下載任務創建的

00:07:21.975 --> 00:07:23.944
我們來說說今天的演示應用

00:07:24.244 --> 00:07:27.681
今天研究的是我們給你們寫好的一款
叫做Graphasaurus 2的應用

00:07:27.748 --> 00:07:31.485
它是去年演講中
Graphasaurus的靈魂繼承者

00:07:31.852 --> 00:07:35.022
和去年的演講一樣
我們會研究現實的問題

00:07:35.088 --> 00:07:38.425
這是我們優化
Instruments 8時遇到的問題

00:07:38.625 --> 00:07:41.828
我們決定把它們放進一個
iOS應用進行演示

00:07:42.596 --> 00:07:43.797
這是一個新的圖形風格

00:07:43.864 --> 00:07:46.600
更像你在Instruments
所看到的狀態界面的風格

00:07:46.667 --> 00:07:49.303
因爲這是我們今年優化的東西

00:07:49.870 --> 00:07:51.305
另一個和去年不一樣的是

00:07:51.371 --> 00:07:55.142
我們會假設我們的代碼
已被時間分析了

00:07:55.209 --> 00:07:57.611
它已經是在目前條件約束下最優的了

00:07:57.678 --> 00:07:59.980
和去年一樣 圖表的生成

00:08:00.047 --> 00:08:01.748
通過Core Graphics
在CPU上進行

00:08:03.217 --> 00:08:06.687
我們首先要做的是初始計時

00:08:07.254 --> 00:08:09.423
我們發現生成全部四個圖表

00:08:09.489 --> 00:08:11.825
總共會花費20毫秒

00:08:12.059 --> 00:08:14.127
這是在全部放大的最壞情況下的

00:08:14.661 --> 00:08:17.331
它超過了16毫秒的限制

00:08:17.397 --> 00:08:19.166
如果我們想達到每秒60幀

00:08:19.233 --> 00:08:22.769
我們決定需要引入些並行運行

00:08:23.270 --> 00:08:24.471
因爲我們知道

00:08:24.538 --> 00:08:27.474
四個圖表可以各自獨立生成

00:08:27.541 --> 00:08:29.843
最壞情況下需要5毫秒

00:08:29.910 --> 00:08:32.880
如果我們把所有任務放到dispatch裏

00:08:32.946 --> 00:08:35.015
我們有完美的擴展性

00:08:35.082 --> 00:08:36.750
那麼在我們的雙核iPad上

00:08:36.817 --> 00:08:38.919
應該可以把任務時間縮短一半

00:08:39.686 --> 00:08:40.654
爲了看看效果如何

00:08:40.721 --> 00:08:43.155
向你展示如何使用系統追溯
我會交給Joe

00:08:43.222 --> 00:08:44.224
好的 謝謝你Chad

00:08:49.997 --> 00:08:51.431
你現在看到的是

00:08:51.498 --> 00:08:54.835
Quick Time上的鏡像
顯示的是我使用的iPad Pro

00:08:54.902 --> 00:08:58.772
你看到就像在Instruments裏
你可以順暢地滑動

00:08:58.972 --> 00:09:01.108
不過當我放大的時候

00:09:01.175 --> 00:09:04.144
動畫變得有些延遲

00:09:04.211 --> 00:09:06.847
不算糟糕 不過可以更好

00:09:07.247 --> 00:09:09.917
我要做的是找出爲何如此

00:09:09.983 --> 00:09:11.652
現在打開Xcode

00:09:12.686 --> 00:09:15.889
按下並長按Run按鈕
並選擇Profile

00:09:16.857 --> 00:09:18.792
那會編譯發佈版本的應用

00:09:19.092 --> 00:09:20.394
在設備上安裝

00:09:20.861 --> 00:09:22.462
然後Instruments會出現

00:09:22.529 --> 00:09:25.332
同時還有模板選擇器
你可以選擇想要使用的工具

00:09:25.699 --> 00:09:28.335
我們繼續 雙擊選擇
System Trace模板

00:09:29.803 --> 00:09:32.005
在這裏我開始記錄前

00:09:32.506 --> 00:09:35.809
我增加了一些
kdebug_signpost的起止點

00:09:35.876 --> 00:09:37.044
到我的代碼裏

00:09:37.311 --> 00:09:40.247
我要設置它們
在Instruments裏出現的方式

00:09:40.314 --> 00:09:42.482
你需要到右下角

00:09:43.083 --> 00:09:44.151
在Record設置裏

00:09:44.218 --> 00:09:47.521
開始時 我要用第一個參數設置顏色

00:09:47.588 --> 00:09:50.524
我在kdebug_signpost
添加了一些不同的數字

00:09:51.024 --> 00:09:53.627
並添加了三個不同的代碼

00:09:54.294 --> 00:09:58.365
代碼0是CADisplayLink

00:09:58.632 --> 00:10:01.768
它是用於驅動動畫的60Hz計時器

00:10:01.835 --> 00:10:04.404
基本上這個區域
符合我的幀時間

00:10:04.471 --> 00:10:06.440
因爲這是我做所有渲染的地方

00:10:07.274 --> 00:10:11.411
下一個是代碼1 它是...
我稱之爲CreatePath

00:10:11.478 --> 00:10:13.247
這是我實際創建CGPath的地方

00:10:13.313 --> 00:10:16.683
屏幕上出現的長方形和標籤

00:10:17.518 --> 00:10:21.321
最後代碼2叫做
RenderGraph

00:10:21.555 --> 00:10:22.956
指的是我把那些CGPath

00:10:23.023 --> 00:10:25.559
實際渲染成CGBitmapContext

00:10:25.626 --> 00:10:27.227
然後在屏幕上顯示

00:10:28.095 --> 00:10:30.564
最後因爲我的代碼會並行運行

00:10:30.631 --> 00:10:32.999
它們會產生同樣的代碼

00:10:33.200 --> 00:10:35.402
我必須告訴Instruments
如何分辨它們

00:10:35.469 --> 00:10:38.839
這個情況 線程足夠了
因爲它們會運行在不同的線程

00:10:39.373 --> 00:10:41.208
好的 我完成了全部的配置

00:10:41.275 --> 00:10:44.645
我不想每次打開Instruments
重複做這個

00:10:44.711 --> 00:10:47.414
所以點擊文件目錄
然後選擇保存爲模板

00:10:47.848 --> 00:10:49.583
設置一個具有描述性的名字

00:10:51.718 --> 00:10:54.254
Graphasaurus System Trace
按下Save

00:10:54.521 --> 00:10:56.924
比如你關閉了這個文件
關閉了Instruments

00:10:56.990 --> 00:11:00.294
一星期後 你來到模板選擇器

00:11:00.727 --> 00:11:02.496
選擇Custom標籤

00:11:03.297 --> 00:11:04.998
你的模板就在那裏可供使用

00:11:05.465 --> 00:11:08.402
你不用重新設置
直接點擊Record即可

00:11:09.736 --> 00:11:12.105
Instruments會等我復現問題

00:11:12.172 --> 00:11:14.908
所以我會雙指張開 就像你之前看的

00:11:15.475 --> 00:11:17.177
張開到產生問題爲止

00:11:17.244 --> 00:11:20.347
我只需復現問題幾秒鐘

00:11:20.414 --> 00:11:23.617
這樣它可以在視窗緩衝區
填充我感興趣的數據

00:11:23.684 --> 00:11:25.619
做完後我停止記錄

00:11:25.953 --> 00:11:29.656
現在Instruments
會從設備下載全部數據

00:11:29.723 --> 00:11:31.124
然後開始分析它

00:11:31.291 --> 00:11:34.428
因爲這是窗口模式錄製
你只會得到最後幾秒的數據

00:11:34.494 --> 00:11:36.763
確保在你復現問題後

00:11:36.830 --> 00:11:38.599
立即停止記錄

00:11:38.665 --> 00:11:40.100
不然 新的事件會出現

00:11:40.167 --> 00:11:42.669
擠掉你感興趣的事件

00:11:43.737 --> 00:11:46.707
我們等待Instruments完成分析

00:11:53.514 --> 00:11:54.348
好了

00:11:54.581 --> 00:11:56.650
我們看到有很多東西

00:11:56.783 --> 00:12:00.020
我們放大一些
這樣就能看到發生了什麼

00:12:01.021 --> 00:12:04.858
好的 第一個選擇的工具
是新的興趣點工具

00:12:04.925 --> 00:12:08.428
隨便放大這裏的一個區域

00:12:09.963 --> 00:12:13.033
我們可以看到那些都是我創建的代碼

00:12:13.100 --> 00:12:15.869
我看到DisplayLink
CreatePath RenderGraph

00:12:15.936 --> 00:12:17.004
如我想的一樣

00:12:17.070 --> 00:12:20.874
這有一個大的藍色的
CADisplayLink時間

00:12:20.941 --> 00:12:24.511
以及四對綠色和紫色的
CreatePath和RenderGraph

00:12:24.778 --> 00:12:25.879
看起來很好

00:12:26.246 --> 00:12:28.949
不過當我移動鼠標到這個部分

00:12:29.016 --> 00:12:30.717
你看到一個小工具提示顯示你

00:12:30.784 --> 00:12:33.487
你提供的參數和時段

00:12:33.787 --> 00:12:36.523
這裏我實際運行了接近30毫秒

00:12:36.590 --> 00:12:38.992
是我希望的速度的一半

00:12:39.059 --> 00:12:39.993
這可不太好

00:12:40.894 --> 00:12:42.529
這還只是一幀
我渲染了很多很多

00:12:42.963 --> 00:12:44.765
累積起來會是什麼樣子的？

00:12:44.831 --> 00:12:48.101
我們看這個詳表

00:12:48.168 --> 00:12:51.371
現在顯示的是按時間排序的所有區域的列表

00:12:51.438 --> 00:12:54.975
你可以瀏覽這個巨大的列表
看看參數等等

00:12:55.576 --> 00:12:59.079
我們做了一個表爲你彙總

00:12:59.146 --> 00:13:02.082
叫做KDebug Interval
Signposts by Code列表

00:13:02.950 --> 00:13:04.017
當我選擇它

00:13:04.084 --> 00:13:06.553
這是所有Graphasaurus 2產生的代碼

00:13:06.954 --> 00:13:09.022
可以看到這是我的
CADisplayLink

00:13:09.089 --> 00:13:11.358
我渲染了152幀

00:13:11.692 --> 00:13:14.261
它們平均花費28毫秒

00:13:14.328 --> 00:13:16.263
所以平均運行並不好

00:13:16.330 --> 00:13:19.533
你可以看到最小值最大值
標準差之類的

00:13:19.800 --> 00:13:22.436
你可以通過代碼旁邊的聚焦按鈕查看詳情

00:13:22.870 --> 00:13:25.405
它會給你全部數據的表

00:13:25.472 --> 00:13:28.809
這些事件都是我的
CADisplayLink事件

00:13:29.376 --> 00:13:32.212
在這裏你可以隨意排序

00:13:32.279 --> 00:13:35.249
不同參數 任何對你的應用重要的

00:13:35.315 --> 00:13:37.050
這裏我根據持續時間排序

00:13:38.418 --> 00:13:40.354
我要做的是

00:13:40.420 --> 00:13:43.590
選擇中間某個地方的一條數據

00:13:44.157 --> 00:13:47.327
我想指出的是當我點擊其中一行

00:13:47.394 --> 00:13:49.029
上面的圖表會移動

00:13:49.596 --> 00:13:55.802
它會顯示我感興趣的區域

00:13:55.869 --> 00:13:56.703
就是這裏

00:13:56.904 --> 00:13:59.940
我把藍色視察頭標放在那區域的開端

00:14:00.007 --> 00:14:02.242
你把下面點擊的項目

00:14:02.309 --> 00:14:04.111
和上面追蹤視圖中
它出現的位置關聯了起來

00:14:04.745 --> 00:14:06.280
我正在看這一幀

00:14:06.380 --> 00:14:11.351
你也可以按住Ctrl點擊那一行
並選擇設置時間過濾器

00:14:11.885 --> 00:14:15.355
它會把所有詳細視圖中在時間範圍之外
的事件變成灰色

00:14:15.422 --> 00:14:17.858
上面的跟蹤視圖同樣如此

00:14:17.925 --> 00:14:20.627
你可以用它過濾出你要的數據

00:14:20.694 --> 00:14:24.031
或者作爲視覺上的提示

00:14:24.698 --> 00:14:25.966
現在完成了

00:14:26.333 --> 00:14:27.601
我正在看這一幀

00:14:27.668 --> 00:14:30.070
我可以看到我的
CADisplayLink在此開始

00:14:30.137 --> 00:14:32.840
在這裏結束
我不知道爲什麼會這樣

00:14:32.906 --> 00:14:35.409
它只會告訴你何時開始 何時結束

00:14:35.475 --> 00:14:38.178
你不知道你的應用是在運行
還是進入了睡眠狀態

00:14:38.245 --> 00:14:39.746
從圖表你無法得知

00:14:39.947 --> 00:14:41.281
我們必須更深入

00:14:42.416 --> 00:14:44.918
在Instruments工具欄的右上角

00:14:45.185 --> 00:14:47.254
我們目前在
Instruments策略

00:14:47.321 --> 00:14:50.257
也就是這個模板裏全部的工具列表

00:14:50.490 --> 00:14:54.561
你可以點擊這個線程數據
查看你應用中的全部線程

00:14:55.195 --> 00:14:56.230
另外

00:14:56.296 --> 00:14:59.666
假設我們已經在詳細視圖裏深入查看線程

00:14:59.733 --> 00:15:01.268
如果你按着選項並點擊

00:15:01.335 --> 00:15:04.538
你會看到這些可以按下的超鏈接

00:15:04.805 --> 00:15:06.773
選擇線程策略顯示

00:15:07.107 --> 00:15:11.545
它會把你帶到線程策略
併爲你預先選擇那個線程

00:15:11.945 --> 00:15:14.548
我們可以看到這裏
放大它一點

00:15:16.049 --> 00:15:17.751
它爲我們選擇了主線程

00:15:18.118 --> 00:15:21.255
如果我看這裏
還有許多其它的dispatch工作線程

00:15:21.321 --> 00:15:23.724
它們正在運行 特別是這兩個

00:15:24.458 --> 00:15:27.494
這個和它下面的這個 正在運行很多工作

00:15:27.794 --> 00:15:31.198
這些都是那些出現的紅點

00:15:32.099 --> 00:15:36.003
如果我按住選項並拖拽
以放大其中一個區域

00:15:36.503 --> 00:15:38.505
我們其實可以開始看到它們是什麼

00:15:38.572 --> 00:15:39.673
通過把鼠標停留在它們上面

00:15:40.474 --> 00:15:44.278
這是一個ulock_wake系統調用
它從某種鎖被喚醒

00:15:44.411 --> 00:15:47.915
這是ulock_wait系統調用
它正在某個鎖上等待

00:15:48.148 --> 00:15:51.018
如果你一直把鼠標放在它們上面
你會看到這個模式一直重複

00:15:51.084 --> 00:15:53.620
有很多ulock_wait
和waking正發生

00:15:54.254 --> 00:15:57.357
如果你點擊鼠標
你可以把視察頭標定在那點

00:15:57.824 --> 00:16:01.228
如果你來到
我們稱爲線程和描述視圖的地方

00:16:02.296 --> 00:16:04.698
在這張表的下面 它會給你展示

00:16:04.765 --> 00:16:06.967
在我點擊的上面那張圖裏

00:16:07.034 --> 00:16:08.969
在這個時刻線程在做些什麼

00:16:09.036 --> 00:16:11.138
這是一個顯示了線程做的所有事的列表

00:16:11.205 --> 00:16:12.840
線程生命週期的故事

00:16:13.173 --> 00:16:16.944
這裏我們可以看到wait調用之一
好的 那它是在哪裏產生的？

00:16:17.477 --> 00:16:20.180
如果可能 Instruments
會生成一個回溯表

00:16:20.247 --> 00:16:22.015
串聯這些系統事件

00:16:22.449 --> 00:16:23.584
你可以在這裏找到它們

00:16:24.084 --> 00:16:26.954
這邊右側的擴展詳情視圖

00:16:27.988 --> 00:16:31.792
我們可以看到一些Swift代碼
用於創建路徑

00:16:32.025 --> 00:16:35.529
這裏其實它是在創建
NSAttributedString

00:16:36.029 --> 00:16:40.501
好的 在它下面的幾幀裏
它在獲取鎖

00:16:40.901 --> 00:16:44.137
我沒想到在NSAttributedString
裏面會出現鎖

00:16:44.204 --> 00:16:45.305
不過確實有

00:16:45.639 --> 00:16:47.741
那麼後果是什麼？

00:16:48.175 --> 00:16:50.277
回到線程描述視圖

00:16:50.344 --> 00:16:51.378
看看發生了什麼

00:16:51.512 --> 00:16:54.615
僅僅獲取鎖就花了109微秒

00:16:54.848 --> 00:16:57.951
然後我們又被阻塞了6微秒

00:16:58.385 --> 00:17:00.954
今年很酷的是 它會給你展示

00:17:01.021 --> 00:17:03.123
哪個線程使你的線程可執行

00:17:03.190 --> 00:17:05.826
基本上就是釋放鎖的線程
以便你可以獲取它

00:17:05.959 --> 00:17:12.432
可以看到 一個Graphasarus線程
0x8468b讓它進入可執行狀態

00:17:12.499 --> 00:17:16.236
好的 我們可以看見就算鎖被釋放了

00:17:16.569 --> 00:17:20.307
在我們實際切換回CPU之前
還等待了98微秒

00:17:21.308 --> 00:17:23.343
我們看看其它線程在做什麼

00:17:23.410 --> 00:17:25.045
爲什麼它釋放了鎖？

00:17:25.345 --> 00:17:28.048
按下選項點擊它
選擇在線程策略中顯示

00:17:28.882 --> 00:17:31.185
這會選中上面的那個線程

00:17:31.518 --> 00:17:33.420
然後在描述視圖的下面

00:17:33.487 --> 00:17:35.622
我們會看到線程那時在做什麼

00:17:35.689 --> 00:17:37.791
我們看見
它正調用ulock_wake

00:17:37.858 --> 00:17:39.526
它正在釋放鎖

00:17:39.726 --> 00:17:40.761
合情合理

00:17:40.827 --> 00:17:43.931
我們可以看見這兩個線程在並行執行

00:17:43.997 --> 00:17:45.832
除了它們正在這個鎖上競爭

00:17:45.899 --> 00:17:49.236
它們實際做了很多事情 而不是隻在運行

00:17:49.837 --> 00:17:53.974
另一個查看方式是
在上面的跟蹤視圖裏

00:17:54.842 --> 00:17:57.444
這裏可以看到線程的狀態

00:17:57.511 --> 00:18:00.681
我把它放大一點
如果你懸停在這個線程狀態

00:18:00.747 --> 00:18:04.017
你看見它運行了這段時間 64微秒

00:18:04.184 --> 00:18:06.053
然後它被阻塞了一會兒

00:18:06.286 --> 00:18:09.990
然後很長時間它處於可運行狀態
這代表它其實沒有在運作

00:18:10.057 --> 00:18:11.525
最終它得以運行

00:18:11.592 --> 00:18:13.060
如果我們繼續查看

00:18:13.126 --> 00:18:15.629
我們會看到這個模式不停重複

00:18:15.796 --> 00:18:17.497
很清楚的是

00:18:17.564 --> 00:18:19.466
這兩個線程正在這個鎖上競爭

00:18:19.533 --> 00:18:22.035
在這期間 我創建了很多字符串

00:18:22.469 --> 00:18:24.972
如果這佔用了這麼多時間
並且這麼重要

00:18:25.038 --> 00:18:27.341
爲何我不能在時間分析器
裏看到它們

00:18:27.474 --> 00:18:30.878
說實話若你回去查看時間分析器
它確實出現了

00:18:30.944 --> 00:18:35.015
不過僅僅是百分之四或五左右
沒有以紅色大旗標的形式突出

00:18:35.082 --> 00:18:37.484
一個主要原因是這些線程

00:18:37.551 --> 00:18:40.053
很長時間處於被阻塞和可執行的狀態

00:18:40.120 --> 00:18:43.290
時間分析器只是採樣
真正在CPU上運行的東西

00:18:43.690 --> 00:18:45.325
所以它不會在那裏出現

00:18:45.592 --> 00:18:48.762
爲了解決問題 我需要意識到

00:18:48.829 --> 00:18:52.332
我只是在狀態圖上放了一些屬性字符串

00:18:52.399 --> 00:18:54.768
其實沒有那麼多需要顯示的狀態

00:18:54.835 --> 00:18:56.303
我應該提前緩存它們

00:18:56.370 --> 00:18:58.305
然後在字典上查找它
不需要用到鎖

00:18:58.372 --> 00:19:00.641
一切都會運行的更加順暢

00:19:00.874 --> 00:19:02.142
爲了展示它看起來是什麼樣的

00:19:02.409 --> 00:19:03.277
我交回給Chad

00:19:10.717 --> 00:19:14.154
好的
Joe看到是一個標準的鎖競爭

00:19:14.221 --> 00:19:17.090
我們有兩個線程正在執行

00:19:17.157 --> 00:19:18.992
它們正在爭奪共享資源

00:19:19.059 --> 00:19:21.962
在屬性字符串創建鎖的代碼附近

00:19:22.296 --> 00:19:25.432
就算我們只持有那個鎖幾毫秒

00:19:25.499 --> 00:19:28.602
性能的折損也遠比那大得多

00:19:28.669 --> 00:19:32.172
Joe向你展示了一些
不過我還要多說幾句

00:19:33.273 --> 00:19:37.678
當你的線程處於執行狀態
代表線程在CPU上

00:19:37.744 --> 00:19:38.979
它正在全速執運行

00:19:39.046 --> 00:19:41.915
你使用時間分析器
所做的所有性能優化

00:19:41.982 --> 00:19:42.983
現在有回報了

00:19:43.684 --> 00:19:45.786
在某些時刻
你調用ulock_wake

00:19:45.853 --> 00:19:49.590
在一小時段後
它把線程變成了阻塞狀態

00:19:49.923 --> 00:19:52.492
這裏發生的是
ulock_wait系統調用

00:19:52.559 --> 00:19:56.430
發覺那個鎖正被另一個線程持有

00:19:56.496 --> 00:19:59.199
所以它請求內核把它移出CPU

00:19:59.399 --> 00:20:03.237
當它實際獲得到了鎖時
再放回CPU

00:20:03.670 --> 00:20:07.841
3.42微秒之後這確實發生了
我們進入了可運行狀態

00:20:08.675 --> 00:20:09.910
但現在在可運行狀態中

00:20:09.977 --> 00:20:13.013
這是回到CPU所消耗的時間

00:20:13.714 --> 00:20:16.416
你看我們在可運行狀態
持續了約7微秒

00:20:16.483 --> 00:20:20.320
這是競爭鎖的時間的兩倍左右

00:20:20.721 --> 00:20:22.756
這裏的額外開銷太大

00:20:23.123 --> 00:20:27.160
另一種定量查看的方式是
你可以進入線程策略視圖

00:20:27.227 --> 00:20:28.161
選擇線程

00:20:28.462 --> 00:20:31.298
像Joe展示的一樣
創建一個時間過濾器

00:20:31.598 --> 00:20:35.335
接着把詳細視圖部分
從描述切換成線程概述

00:20:35.669 --> 00:20:39.373
它會展示給你
每個線程狀態所花費的時間總和

00:20:39.773 --> 00:20:42.509
在這個例子裏
我們可以看到我們的線程

00:20:42.576 --> 00:20:44.244
只有82%的時間在運行

00:20:45.045 --> 00:20:48.048
這意味我們從多核還是有所收益

00:20:48.115 --> 00:20:49.616
我們做到了一些改進

00:20:49.683 --> 00:20:51.318
但這個擴展仍然不是

00:20:51.385 --> 00:20:53.954
我們所期待的完美的線性擴展

00:20:54.087 --> 00:20:55.722
還是浪費了一些時間

00:20:56.857 --> 00:21:00.594
當Joe採取他說的解決措施時

00:21:00.661 --> 00:21:02.162
會發生兩件事情

00:21:02.229 --> 00:21:05.065
第一是UpdateGraph區域

00:21:05.132 --> 00:21:07.434
會變短一些
因爲我們需要做的工作變少了

00:21:07.501 --> 00:21:09.136
我們對這些字符串進行了緩存

00:21:09.203 --> 00:21:10.304
但更重要的是

00:21:10.370 --> 00:21:12.840
線程沒有佔用100%的時間運行

00:21:12.906 --> 00:21:14.708
所以你可以獲得完美的擴展性

00:21:14.775 --> 00:21:17.077
所以 當你把CPU的數量增加一倍

00:21:17.144 --> 00:21:19.046
那段代碼的運行時間
會變成一半

00:21:19.112 --> 00:21:19.947
這非常棒

00:21:20.013 --> 00:21:23.217
所以 如果你有這樣的一個解決方案
一定要設法用上它

00:21:24.451 --> 00:21:25.919
我們再來講講搶佔

00:21:26.186 --> 00:21:28.288
在我們的例子中沒有看到任何搶佔

00:21:28.355 --> 00:21:31.892
但它在系統追蹤裏也十分常見

00:21:32.426 --> 00:21:38.398
搶佔指的是
非自願地把你的線程挪出CPU

00:21:38.832 --> 00:21:42.836
也就是說 有些其他的
更高優先級的工作需要CPU

00:21:42.903 --> 00:21:45.806
但現在沒有可用的
於是你的線程不得不讓步

00:21:46.406 --> 00:21:47.975
有一個例外情況

00:21:48.041 --> 00:21:51.512
你可能會看到
自願性的搶佔

00:21:51.678 --> 00:21:53.347
它出現在自旋鎖的內部

00:21:53.413 --> 00:21:56.517
當一個自旋鎖發現
它的工作沒有任何推進

00:21:56.583 --> 00:21:58.785
它可以產生線程切換系統調用

00:21:59.119 --> 00:22:02.589
最終放棄它佔用的
鎖持有者的時間片

00:22:03.423 --> 00:22:06.627
在系統追蹤的線程描述裏

00:22:06.693 --> 00:22:08.795
你會看到它調用了
thread_switch

00:22:08.862 --> 00:22:13.233
搶佔的描述會說
它主動放棄了CPU

00:22:13.300 --> 00:22:16.003
而不是被移出CPU

00:22:17.938 --> 00:22:21.675
另一種更輕量級的搶佔
叫做中斷狀態

00:22:22.042 --> 00:22:25.045
中斷狀態指的是
當你的線程在CPU上執行時

00:22:25.112 --> 00:22:28.549
CPU必須處理一個硬件中斷

00:22:28.882 --> 00:22:30.350
所以你的線程被掛起

00:22:30.417 --> 00:22:33.253
中斷處理程序運行
然後你的線程重新開始

00:22:33.453 --> 00:22:35.355
此時 你線程的優先級
起不到任何作用

00:22:35.422 --> 00:22:38.025
你可以具有最高優先級
但這也沒有用

00:22:38.091 --> 00:22:40.561
中斷始終更加優先

00:22:40.727 --> 00:22:41.562
好消息是

00:22:41.628 --> 00:22:44.097
這些通常是短暫的 幾微秒而已

00:22:44.164 --> 00:22:46.400
通常它們不會給你的應用

00:22:46.466 --> 00:22:48.802
帶來任何內部的性能問題

00:22:48.869 --> 00:22:51.405
但它們的確會出現
這就是爲什麼我想提一下

00:22:51.872 --> 00:22:55.909
Instruments 8的另一功能是
全新的系統負載工具

00:22:56.743 --> 00:23:01.114
這個工具可以幫助你找到系統追蹤中的
一些高負載事件

00:23:01.181 --> 00:23:04.284
比如會導致丟幀的事件

00:23:04.885 --> 00:23:07.988
它通過兩種方式顯示
第一種是下面的表視圖

00:23:08.222 --> 00:23:12.292
它會給你展示一張圖表
顯示了調度狀態的樣子

00:23:12.359 --> 00:23:16.463
在藍色審視線的下方
列出了所有可執行的線程

00:23:17.431 --> 00:23:20.601
你可以知道在這個時間點
有三個線程

00:23:20.667 --> 00:23:23.170
一個是內核線程 另兩個是
Graphasaurus線程

00:23:23.237 --> 00:23:26.006
它們是未被阻塞的線程
正在嘗試運行

00:23:26.073 --> 00:23:28.542
你可以看到它們的核心任務

00:23:29.610 --> 00:23:31.345
這個工具的另一個功能

00:23:31.411 --> 00:23:33.680
稱爲可交互負載平均圖

00:23:34.314 --> 00:23:38.886
這裏每一個豎條
代表一個時間10毫秒的窗口

00:23:39.086 --> 00:23:40.287
豎條的高度

00:23:40.354 --> 00:23:44.157
是在10毫秒期間的活動線程的平均數

00:23:44.458 --> 00:23:49.062
這些線程處於執行 可執行
被搶佔或者被中斷狀態

00:23:49.129 --> 00:23:50.898
就是所有沒有被阻塞的線程

00:23:51.265 --> 00:23:53.667
由於它是可交互負載平均

00:23:53.734 --> 00:23:57.604
我們只包括
優先級大於或等於33的線程

00:23:57.905 --> 00:24:01.675
因爲這些線程的優先級

00:24:01.742 --> 00:24:04.311
足以對服務類的
用戶交互的質量產生影響

00:24:04.745 --> 00:24:06.680
更明白的說

00:24:06.747 --> 00:24:09.850
當線程變成橘色
這說明你的平均負載

00:24:09.917 --> 00:24:12.819
已經超過了該設備上的核心數

00:24:13.187 --> 00:24:15.289
所以當你看到一片橘色

00:24:15.355 --> 00:24:17.724
你可以預測會有個丟幀發生

00:24:17.791 --> 00:24:19.560
你可能想放大

00:24:19.860 --> 00:24:21.929
這些橘色的區域

00:24:21.995 --> 00:24:24.097
確保正在執行的線程

00:24:24.164 --> 00:24:26.466
在服務質量水平上相互平衡

00:24:27.968 --> 00:24:29.336
當Joe修改時

00:24:29.403 --> 00:24:32.206
最終給負載留有了一些空間
我們可以添加一項新的功能

00:24:32.272 --> 00:24:34.541
這個新功能是懸浮標籤

00:24:34.608 --> 00:24:36.944
類似你在Instrument
看到的懸浮標籤

00:24:37.010 --> 00:24:39.346
除了Graphasaurus
你進行長按

00:24:39.413 --> 00:24:41.515
懸浮標籤會跟隨你的手指

00:24:41.582 --> 00:24:44.785
爲了展示這個特性
我把演講交換給Joe

00:24:50.157 --> 00:24:50.991
謝謝 Chad

00:24:51.124 --> 00:24:53.460
所以我添加了
NSAttributedString的解決方案

00:24:53.527 --> 00:24:55.762
回到了每秒60幀 看起來不錯

00:24:55.863 --> 00:24:57.898
增加了新一代的Tool Tips事件

00:24:57.965 --> 00:24:59.433
再次慢了下來

00:24:59.499 --> 00:25:02.536
你可以看到這裏和那裏掉了幾幀

00:25:02.603 --> 00:25:04.071
查看時間分析器

00:25:04.204 --> 00:25:07.875
沒有什麼是明顯我能刪除的
我也沒有做什麼額外的工作

00:25:07.941 --> 00:25:10.711
於是我回去 檢查系統追溯
也就是你們現在正看到的

00:25:11.078 --> 00:25:12.045
在我查看追溯之前

00:25:12.346 --> 00:25:14.882
我新添加了一個Signpost代碼
代碼爲3

00:25:14.948 --> 00:25:17.084
它代表GenToolTips事件

00:25:17.150 --> 00:25:19.186
你可以看到上面以紅色顯示

00:25:19.753 --> 00:25:22.256
我們來放大其中的一個區域

00:25:26.994 --> 00:25:30.697
好的 現在我們可以看到
這是我們新的紅色柱狀圖

00:25:30.764 --> 00:25:32.065
這些GenToolTips

00:25:32.266 --> 00:25:35.369
我必須介紹一下我的算法的原理
這非常重要

00:25:35.435 --> 00:25:38.172
基本上每當這個
CADisplayLink區域開始

00:25:38.338 --> 00:25:39.773
對於界面上每一個圖

00:25:39.840 --> 00:25:43.510
我對它調用異步渲染

00:25:43.577 --> 00:25:47.214
同時我異步生成Tool Tip字典
用於查詢

00:25:47.814 --> 00:25:50.517
對於界面裏的每一張圖
我都做同樣的事情

00:25:50.751 --> 00:25:53.187
但後來我做了一個巧妙的實現

00:25:54.254 --> 00:25:56.123
爲了調用我的渲染

00:25:56.190 --> 00:25:59.159
我實際上並不需要
等待Tool Tip完成

00:25:59.326 --> 00:26:02.429
所以我創建了調度組
讓它們只等待渲染工作

00:26:02.729 --> 00:26:05.199
我們可以看到
它實際在這裏運行地非常好

00:26:05.265 --> 00:26:07.835
這是我的幀的起點
CADisplayLink時間

00:26:07.935 --> 00:26:10.204
我們可以看到一些
Tool Tip在這工作

00:26:10.404 --> 00:26:11.705
我向右滑動一些

00:26:11.772 --> 00:26:13.373
你可以看到
實際上它們中有一個

00:26:13.440 --> 00:26:15.676
直到我的渲染幀完成
纔剛剛開始啓動

00:26:15.742 --> 00:26:18.111
看起來我的工作做得很好
我拍拍我的背

00:26:18.178 --> 00:26:19.146
這看起來不錯

00:26:20.314 --> 00:26:24.218
然而當我看這裏的
CADisplayLink時間

00:26:25.652 --> 00:26:28.422
它花費了17.4毫秒

00:26:28.522 --> 00:26:31.725
非常接近了
但還不是我想要的16.6毫秒

00:26:32.292 --> 00:26:34.361
同樣 這只是一個區域

00:26:34.428 --> 00:26:36.897
我們來看看彙總起來怎麼樣

00:26:37.164 --> 00:26:40.033
我們回到
KDebug Interval Signpost by Code表

00:26:40.567 --> 00:26:44.171
這裏可以看到我們的
CADisplayLinks執行了大概260次

00:26:44.238 --> 00:26:47.274
比我們之前要多
聽起來不錯

00:26:48.242 --> 00:26:51.478
16毫秒的平均水平
比我的16.6還要少

00:26:51.545 --> 00:26:53.480
這聽起來相當不錯

00:26:53.814 --> 00:26:57.117
但是 這個最大值
仍然是19.27左右

00:26:57.584 --> 00:26:59.920
如果我們看所有的單個事件

00:27:01.288 --> 00:27:03.957
按花費時間從長到短排列

00:27:04.324 --> 00:27:05.993
我們可以看到這個19毫秒的

00:27:06.059 --> 00:27:07.728
一堆18毫秒的

00:27:07.794 --> 00:27:09.396
這裏是一些17毫秒的

00:27:09.463 --> 00:27:10.831
很多17毫秒的

00:27:10.898 --> 00:27:12.165
更多的是16毫秒（近17毫秒）的

00:27:12.232 --> 00:27:15.335
所以我們還有一些幀
實際渲染得太慢

00:27:15.402 --> 00:27:17.504
慢的不多 但還是慢了

00:27:17.571 --> 00:27:19.373
這意味着我們會丟幀

00:27:20.073 --> 00:27:22.142
這次我們該何去何從？

00:27:22.609 --> 00:27:25.179
我們重新深入線程策略

00:27:25.245 --> 00:27:27.781
觀察我們所有的線程 系統調用
VM事件

00:27:27.848 --> 00:27:29.716
線程事件之類的

00:27:30.350 --> 00:27:31.552
但只要有可能

00:27:32.119 --> 00:27:33.987
這個系統跟蹤模板

00:27:34.054 --> 00:27:36.557
有一堆工具
它們可以給你提供

00:27:36.623 --> 00:27:40.694
更高級別的彙總信息
一開始看看它們會很有幫助

00:27:40.761 --> 00:27:44.064
所以在你深入到那
100,000多個事件之前

00:27:44.331 --> 00:27:46.533
看看這些更高層次的聚合信息

00:27:46.700 --> 00:27:50.504
我要做的是看看這個
用戶交互負載圖

00:27:50.571 --> 00:27:52.739
這是該系統負載工具之一

00:27:53.707 --> 00:27:57.644
我們繼續
縮小一點至合適大小

00:27:57.711 --> 00:28:00.113
現在我們又可以在屏幕上
看到所有數據

00:28:01.114 --> 00:28:04.218
做好這些後
我放大這裏

00:28:05.085 --> 00:28:07.855
你可以看到
這個圖裏有非常多的橘色

00:28:07.921 --> 00:28:09.156
再放大一點

00:28:09.223 --> 00:28:11.725
你可以看到
這裏有非常多的橘色

00:28:11.792 --> 00:28:15.262
這表示正在運行的用戶交互線程
要比核心數多

00:28:15.329 --> 00:28:18.098
這些線程說
我有很多活 現在就要做

00:28:18.165 --> 00:28:18.999
給我一個CPU

00:28:19.867 --> 00:28:25.138
可是我們沒有CPU了
所以這裏纔會是橘色

00:28:25.205 --> 00:28:26.306
我們放大這裏

00:28:26.373 --> 00:28:29.042
一大片橘色的地方

00:28:29.843 --> 00:28:32.779
你可以看到數值
只需懸停在一個區域上

00:28:33.280 --> 00:28:34.281
放大一點點

00:28:35.249 --> 00:28:37.951
在這個10毫秒塊裏

00:28:38.018 --> 00:28:41.088
平均有2.84個用戶交互線程
在嘗試運行

00:28:41.154 --> 00:28:42.589
再次 在雙核的機器上

00:28:42.656 --> 00:28:46.393
有0.8個線程
缺乏CPU時間

00:28:46.460 --> 00:28:47.861
這就是爲什麼這是橙色的

00:28:47.928 --> 00:28:52.032
平均來看
有很多區域太大

00:28:52.099 --> 00:28:53.033
這裏實際上是四

00:28:53.100 --> 00:28:55.903
我們在嘗試運行
兩倍於核心數量的線程

00:28:56.203 --> 00:28:58.639
我們來看看
該區域的更多細節

00:28:58.705 --> 00:29:01.542
我把它挪過來一點
這樣你就能看到了

00:29:02.142 --> 00:29:03.610
正如Chad所說

00:29:03.677 --> 00:29:07.281
你可以看到
這段時間裏哪些線程在嘗試運行

00:29:07.347 --> 00:29:09.449
點擊並按住上面這裏的尺標視圖

00:29:09.516 --> 00:29:11.618
你可以來回移動這個藍色標誌頭

00:29:11.685 --> 00:29:13.020
Instruments會告訴你

00:29:13.086 --> 00:29:16.690
那個時間點我們在嘗試運行
哪些線程

00:29:17.558 --> 00:29:18.959
如果我們看看下面這張表

00:29:19.526 --> 00:29:20.994
我按照優先級排序

00:29:21.461 --> 00:29:23.063
我們可以看到 在這裏

00:29:23.130 --> 00:29:26.466
有兩個Graphasaurus線程
正在運行 不錯

00:29:28.001 --> 00:29:32.105
有兩個location D線程
在嘗試運行 它們優先級稍低

00:29:32.172 --> 00:29:33.640
這是真實系統的一部分

00:29:33.707 --> 00:29:36.543
你會看到系統守護進程進來
並試圖做好自己的工作

00:29:36.610 --> 00:29:39.213
但沒關係
它們的優先級比我們的稍低

00:29:39.279 --> 00:29:40.981
所以我仍然持有CPU
看起來不錯

00:29:41.315 --> 00:29:45.052
我還有第三個線程在同時運行

00:29:45.319 --> 00:29:46.887
嘗試在同一時間運行

00:29:46.954 --> 00:29:48.989
但它沒有得到任何CPU資源

00:29:49.756 --> 00:29:53.327
我知道這些線程是什麼了
其中兩個是我的渲染工作

00:29:53.393 --> 00:29:56.663
然後我讓這第三個線程嘗試
完成我的Tool Tip生成工作

00:29:56.730 --> 00:30:00.234
所以發生的是
它們其中之一沒能獲得CPU

00:30:01.101 --> 00:30:04.605
我們又能看到這個了
如果我們查看 比如 我們的一幀

00:30:04.872 --> 00:30:06.974
讓我們回到那個興趣點區域

00:30:07.975 --> 00:30:11.278
我們可以看到
我們在幀內進行渲染

00:30:11.345 --> 00:30:15.148
ToolTips的產生也是在這裏
所以它得到了一點CPU時間

00:30:15.983 --> 00:30:19.653
但當它獲得的CPU時間時
是從我的渲染這裏分走的

00:30:20.153 --> 00:30:24.791
所以基本上我錯誤調度了我的工作
因爲當我停下來想想

00:30:25.225 --> 00:30:27.694
我需要渲染現在就進行

00:30:27.761 --> 00:30:29.763
站在用戶交互的級別非常有意義

00:30:29.830 --> 00:30:32.833
因爲我希望它完美而流暢
60幀每秒

00:30:33.033 --> 00:30:35.736
但這些Tool Tip
它們的優先級不夠高

00:30:35.802 --> 00:30:37.037
我確實很希望它們能儘快完成

00:30:37.104 --> 00:30:39.006
因爲我希望
當用戶長按屏幕的時候

00:30:39.072 --> 00:30:40.107
它們能立即出現

00:30:40.607 --> 00:30:43.010
但它們其實
並沒有渲染工作重要

00:30:43.076 --> 00:30:46.580
你可以清楚的看到
它們拿走了一部分時間

00:30:46.647 --> 00:30:50.317
從CPU的給渲染分配的資源
現在渲染被延遲了

00:30:50.384 --> 00:30:53.287
就是拖慢CADisplayLink
時間的原因

00:30:54.021 --> 00:30:57.491
對於此的解決方案
其實非常簡單

00:30:57.558 --> 00:30:58.692
我們回到Xcode

00:30:58.926 --> 00:31:00.527
這裏我有個
ViewController類

00:31:00.594 --> 00:31:03.363
它做的事情之一是
創建一個Tool Tip隊列

00:31:03.430 --> 00:31:05.899
我們可以看到它就創建在下面這裏

00:31:06.600 --> 00:31:09.903
這是我處理所有Tool Tip工作的地方
創建它的同時還包含了些屬性

00:31:09.970 --> 00:31:11.738
其中之一是
它是並行的 很不錯

00:31:11.805 --> 00:31:14.107
所以它們能在多個CPU上執行
如果存在的話

00:31:14.174 --> 00:31:17.110
它被設置爲用戶交互的QOS類

00:31:17.177 --> 00:31:18.912
這個QOS類

00:31:18.979 --> 00:31:22.015
和我正在進行的渲染工作相同
所以它們互相競爭資源

00:31:22.382 --> 00:31:24.985
如我所說的
它實際上不是那麼重要

00:31:25.052 --> 00:31:26.687
所以我要改變這個類

00:31:26.920 --> 00:31:29.590
你可以在頭文件中讀到不同的類

00:31:30.090 --> 00:31:33.760
我把它降低幾個級別
使用Utility級別的類

00:31:33.827 --> 00:31:37.231
這會讓CPU優先做我的渲染工作

00:31:37.531 --> 00:31:41.068
然後當CPU有一點空閒時間
比如每一幀的結尾或者其它時間

00:31:41.134 --> 00:31:42.436
Tool Tip就會開始工作

00:31:42.503 --> 00:31:45.539
它們仍然處於足夠高的優先級
當用戶點擊屏幕

00:31:45.606 --> 00:31:46.840
它們應該準備好隨時運行

00:31:47.007 --> 00:31:49.042
爲了給你們展示這是什麼樣子的
我們交還給Chad

00:31:56.283 --> 00:31:59.486
好的 當Joe做了這個修改
圖表會是這個樣子

00:31:59.553 --> 00:32:02.155
我們會發現我們的
CADisplayLink時間

00:32:02.222 --> 00:32:05.559
降低到了平均12.7毫秒

00:32:05.626 --> 00:32:07.094
是比以前好多了

00:32:07.160 --> 00:32:13.133
但更好的是
我們的最大持續時間僅爲14.6毫秒

00:32:13.200 --> 00:32:17.804
所以我們不會丟失任何幀
同時我們達到了16毫秒的限制

00:32:18.739 --> 00:32:23.210
即使系統仍然處於過載狀態
我們仍然能夠達成

00:32:23.277 --> 00:32:26.647
如果你想想看
我們仍然在運行三個不同的線程

00:32:27.147 --> 00:32:29.850
但是因爲我們已經
正確地安排了工作的優先級

00:32:29.917 --> 00:32:33.387
我們的GenToolTips代碼
在下面這裏 以優先級四運行

00:32:33.453 --> 00:32:36.690
它不會阻擋用戶交互代碼

00:32:37.024 --> 00:32:39.793
我們仍然在CPU上做了很多事情

00:32:39.860 --> 00:32:41.962
我們仍然有一個非常高的系統負載

00:32:42.329 --> 00:32:46.900
但與此同時
我們仍然得到了完美流暢的用戶體驗

00:32:48.569 --> 00:32:50.137
什麼是服務質量真正的意義

00:32:50.204 --> 00:32:52.105
服務質量
如果你還沒有看到它

00:32:52.172 --> 00:32:56.109
是你附加到塊 隊列以及線程上的屬性

00:32:56.577 --> 00:32:58.946
基本上它用於告訴內核

00:32:59.012 --> 00:33:01.815
你願意獻出多少系統資源

00:33:01.882 --> 00:33:04.585
以便讓某一工作快速完成

00:33:05.319 --> 00:33:09.523
不同的QOS類
會限制優先級的範圍

00:33:09.590 --> 00:33:13.093
所以你可看到我們的Utility類
把它的優先級降到了四

00:33:13.160 --> 00:33:16.864
所以我們的用戶交互代碼
在三十多四十多的高優先級運行

00:33:17.464 --> 00:33:21.468
但QOS類還是可以
限制類似IO這類工作

00:33:21.535 --> 00:33:24.271
以及代碼運行的CPU頻率

00:33:24.872 --> 00:33:27.307
所以當你爲你的代碼
選擇QOS時

00:33:27.374 --> 00:33:29.409
請非常詳細地閱讀文檔

00:33:29.476 --> 00:33:32.579
並確保它
與你正在做的工作種類相匹配

00:33:33.847 --> 00:33:36.083
另一件能影響你應用性能的是

00:33:36.149 --> 00:33:37.518
虛擬內存錯誤

00:33:38.051 --> 00:33:42.289
隨着內存壓力的增加
它們的負載表現會變差

00:33:42.689 --> 00:33:44.791
但好消息是 它們是可控的

00:33:45.926 --> 00:33:50.297
系統跟蹤擁有所有
爲了分析虛擬內存故障所需的工具

00:33:50.364 --> 00:33:51.732
在線程策略裏

00:33:51.798 --> 00:33:54.268
虛擬內存錯誤以這種
藍色小膠囊的形式出現

00:33:54.768 --> 00:33:58.238
在線程描述裏面
它會報告虛擬內存錯誤

00:33:58.305 --> 00:34:01.208
甚至附上一個回溯表
表明產生錯誤的位置

00:34:01.275 --> 00:34:02.176
在代碼內的什麼地方

00:34:03.710 --> 00:34:07.314
我們也有一個工具
專門用來分析虛擬內存錯誤

00:34:07.381 --> 00:34:09.550
舉個例子 你可以看到

00:34:09.616 --> 00:34:13.620
你的代碼的哪些部分
容易產生特定的錯誤而不是其它錯誤

00:34:13.687 --> 00:34:15.621
比如你有一段代碼

00:34:15.688 --> 00:34:19.326
需要進行更多的零填充
或者寫時複製

00:34:20.893 --> 00:34:23.297
下一個你需要知道的
關於虛擬內存錯誤的事情是

00:34:23.362 --> 00:34:26.867
錯誤是在訪問時發生的
而不是分配時

00:34:27.501 --> 00:34:29.703
所以你可以向內核
請求一大片內存

00:34:29.770 --> 00:34:31.205
比方說500M

00:34:31.438 --> 00:34:34.341
但實際上你並不需要
把它轉化成物理內存

00:34:34.408 --> 00:34:35.775
直到你開始修改或訪問

00:34:35.842 --> 00:34:38.545
進程中分配的相關頁面

00:34:38.612 --> 00:34:41.782
這是你分配內存時
需要想到的

00:34:43.250 --> 00:34:45.686
另一需要知道的重要的事情是
虛擬內存錯誤

00:34:45.752 --> 00:34:47.454
可以通過代碼內聯解決

00:34:47.521 --> 00:34:50.257
所以你不需要進行顯式調用

00:34:50.324 --> 00:34:51.824
來解決一個虛擬內存錯誤

00:34:52.226 --> 00:34:55.228
你需要做的是修改頁面內

00:34:55.295 --> 00:34:57.464
任何被標需要錯誤處理的字節

00:34:57.898 --> 00:35:00.133
內核會獲得你的線程控制權

00:35:00.200 --> 00:35:03.437
解決​​故障
然後把控制權交還給你

00:35:03.704 --> 00:35:05.205
當你看到這些藍色膠囊

00:35:05.272 --> 00:35:07.608
在你線程策略的系統追蹤裏

00:35:07.674 --> 00:35:08.775
這就是會發生的事情

00:35:10.244 --> 00:35:13.614
如何處理你的應用內的
虛擬內存錯誤？

00:35:14.481 --> 00:35:16.583
最簡單的是
不好意思

00:35:16.917 --> 00:35:19.419
最簡單的是消化掉它們

00:35:20.020 --> 00:35:23.457
我的意思是
在性能預算上留足夠的空間

00:35:23.824 --> 00:35:27.694
便於你處理一定數量的
虛擬內存錯誤

00:35:27.761 --> 00:35:29.329
在你達到限制之前

00:35:29.730 --> 00:35:31.698
這會使你的負荷更有彈性

00:35:31.765 --> 00:35:33.433
隨着內存壓力的增大

00:35:33.500 --> 00:35:35.636
如果你的預算足夠大
你有足夠的空間

00:35:35.769 --> 00:35:38.172
你不會發現性能上的差別

00:35:38.238 --> 00:35:39.473
現在我們發現

00:35:39.540 --> 00:35:41.975
有些人不設置這種鬆散的限制

00:35:42.042 --> 00:35:43.777
在其UI生成方面

00:35:44.545 --> 00:35:48.682
所以另一種選擇是
嘗試在後臺線程解決錯誤

00:35:49.049 --> 00:35:51.151
比如說你有個遊戲

00:35:51.451 --> 00:35:53.754
你的玩家玩到了第一關的結尾

00:35:53.820 --> 00:35:55.556
他們馬上就要進入第二關

00:35:56.123 --> 00:36:00.260
你可以做的是
異步分配到後臺隊列

00:36:00.861 --> 00:36:04.665
然後在後臺隊列裏
創建與第二關內容相關的頁面

00:36:04.965 --> 00:36:09.102
這樣當你的渲染線程
開始獲取這些新內容時

00:36:09.169 --> 00:36:10.704
不會有延遲

00:36:11.305 --> 00:36:14.708
關於使用這種方法
我們在這裏要給你一個警告

00:36:14.775 --> 00:36:17.711
確保只創建一定會用到的頁

00:36:17.778 --> 00:36:20.414
因爲如果你開始創建比所需更多的頁面

00:36:20.480 --> 00:36:22.683
實際上會使問題變得更糟

00:36:24.384 --> 00:36:26.086
這就是今天的會談內容了

00:36:26.720 --> 00:36:30.424
我們相信系統跟蹤器
是時間分析器的絕佳搭檔

00:36:30.791 --> 00:36:32.626
時間分析器可以讓你的代碼更快

00:36:32.693 --> 00:36:36.830
但系統跟蹤可以讓你的應用
更易擴展到更高的負載

00:36:37.231 --> 00:36:40.033
我們鼓勵你在自己的應用中
嘗試使用系統跟蹤

00:36:40.100 --> 00:36:42.236
我們知道當使用
Instrument檢測我們的應用時

00:36:42.302 --> 00:36:44.671
總能找到值得修補的地方

00:36:45.038 --> 00:36:47.140
如果過去你用過系統跟蹤

00:36:47.207 --> 00:36:50.244
請你到Instruments 8
重新看看它

00:36:50.310 --> 00:36:52.079
因爲我們做了一些重要的改進

00:36:52.145 --> 00:36:54.581
包括易用性和功能性

00:36:54.648 --> 00:36:57.217
我們相信它會是你的工具箱中
又一新的利器

00:36:58.385 --> 00:37:01.321
欲瞭解更多信息
這是我們411號演講的鏈接

00:37:02.222 --> 00:37:03.590
我們今天有一些相關演講

00:37:03.657 --> 00:37:06.393
在這一週以及週五也同樣有

00:37:07.127 --> 00:37:08.295
剩下的上午時光過得愉快