00:00:19.953 --> 00:00:23.023
使用TVMLKit開發應用

00:00:23.090 --> 00:00:24.024
好的

00:00:27.261 --> 00:00:31.932
大家下午好 歡迎來到
TVMLKit應用開發的第二部分

00:00:33.300 --> 00:00:35.235
有許多優秀的應用

00:00:35.335 --> 00:00:37.938
使用TVMLKit開發出來
放在App Store上

00:00:38.805 --> 00:00:41.241
一些應用使用自定義樣式

00:00:41.341 --> 00:00:44.745
帶給用戶與衆不同的體驗
同時擴大了應用的知名度

00:00:46.046 --> 00:00:49.016
今天我格外的高興

00:00:49.416 --> 00:00:52.553
同你們進行交談 並且告訴你們如何

00:00:52.719 --> 00:00:54.888
提升應用到另一個水平

00:00:55.989 --> 00:00:58.792
這需要通過擴展TVMLKit

00:00:59.259 --> 00:01:00.694
擴展接口

00:01:01.094 --> 00:01:04.197
同時也需要JavaScript
中提供的功能來實現

00:01:05.199 --> 00:01:08.435
通過上述方式
基本上能讓你的應用脫穎而出

00:01:08.802 --> 00:01:10.737
甚至會有屬於自己的品牌

00:01:13.373 --> 00:01:17.511
TVMLKit是一個功能完備的框架

00:01:18.445 --> 00:01:20.013
我們也試圖確保

00:01:20.080 --> 00:01:23.483
你在思考如何構建你的想法時

00:01:23.884 --> 00:01:27.187
你只需要考慮兩個擴展點即可

00:01:28.121 --> 00:01:29.456
在上半場演講中

00:01:29.957 --> 00:01:32.326
我將告訴大家如何

00:01:32.392 --> 00:01:35.596
在TVMLKit中通過擴展模板的方式
來擴展用戶界面

00:01:37.130 --> 00:01:38.265
下半場演講

00:01:38.799 --> 00:01:40.801
我的同事Christopher將會講解

00:01:40.868 --> 00:01:44.638
如何增強你的應用通過添加程序功能

00:01:45.172 --> 00:01:47.474
到JavaScript引擎
支持TVMLKit的JavaScript引擎

00:01:50.444 --> 00:01:52.679
讓我們談論擴展模板的內容

00:01:54.748 --> 00:01:56.984
首先第一件事情每一個人都會遇到的是

00:01:57.050 --> 00:01:59.820
他們使用的TVMLKit就是模板的概念

00:02:00.254 --> 00:02:03.557
模板在TVML中定義 就是TV標記語言

00:02:04.925 --> 00:02:08.829
他們使用XML描述屏幕上顯示的內容

00:02:09.496 --> 00:02:11.031
當人們看到了這裏

00:02:11.431 --> 00:02:12.733
他們會說嘿

00:02:12.866 --> 00:02:15.435
我知道它 它是瀏覽器

00:02:16.136 --> 00:02:19.339
我敢向你保證那絕對不是瀏覽器

00:02:20.107 --> 00:02:23.677
TVMLKit是一個功能強大的模板引擎

00:02:24.478 --> 00:02:27.648
但那並不意味着你只能使用
我們提供的模板

00:02:28.782 --> 00:02:33.353
實際上 Apple自家的應用
同樣使用TVMLKit

00:02:33.420 --> 00:02:34.655
但是以巧妙的方式擴展

00:02:35.055 --> 00:02:36.890
使它可以和原先的

00:02:36.957 --> 00:02:40.794
框架共存仍能良好的運行在tvOS上

00:02:42.462 --> 00:02:45.399
讓我們看一個例子

00:02:46.033 --> 00:02:47.434
這是App Store上的應用

00:02:48.368 --> 00:02:50.437
App Store的主題有一個要求

00:02:50.504 --> 00:02:52.706
一個shelf中
只能存在一個cell

00:02:53.874 --> 00:02:57.277
你能看到他們複用了
TVMLKit提供的

00:02:57.344 --> 00:02:58.846
一個圖片控件和三個文本控件

00:02:59.513 --> 00:03:01.448
除了這些他們還有自定義佈局

00:03:01.615 --> 00:03:03.483
使用了自定義的聚焦動作

00:03:05.819 --> 00:03:07.988
另一個例子是我們非常熟悉的

00:03:08.055 --> 00:03:09.857
是對於購買按鈕的印象

00:03:10.524 --> 00:03:12.459
App Store的主題要求

00:03:12.526 --> 00:03:16.797
購買按鈕必須反映出
應用程序的不同安裝狀態

00:03:17.698 --> 00:03:19.433
你是否正在購買應用

00:03:19.499 --> 00:03:21.902
應用是否被安裝或者已經下載

00:03:22.569 --> 00:03:25.706
所有的這些都通過複用
TVMLKit提供的模板來實現

00:03:26.273 --> 00:03:28.475
這些主題就是
今天我想特意展示給你們的

00:03:29.476 --> 00:03:31.879
儘可能複用TVMLKit

00:03:32.312 --> 00:03:35.082
並且儘可能的擴展
我們沒有在模板中提供給你的樣式

00:03:36.884 --> 00:03:38.619
這就是模板

00:03:40.020 --> 00:03:45.959
如果你已經使用了TVMLKit
它遵循一系列的路徑

00:03:46.627 --> 00:03:49.463
當你把TVMLKit注入到框架中
最後會在屏幕上顯示

00:03:50.163 --> 00:03:53.066
TV標記語言由許多元素組成

00:03:53.333 --> 00:03:54.701
命名各不相同

00:03:55.402 --> 00:03:58.539
當它進入到框架中後會被傳遞到
TVElementFactory

00:03:58.906 --> 00:04:00.507
TVElementFactory
是註冊中心

00:04:01.141 --> 00:04:02.676
它記錄着所有的元素

00:04:02.743 --> 00:04:05.012
它能夠將元素翻譯爲相應的數據結構

00:04:05.112 --> 00:04:07.147
框架能夠識別的數據結構

00:04:08.382 --> 00:04:11.351
我們使用TVInterfaceFactory類

00:04:11.451 --> 00:04:13.153
生成用戶界面

00:04:13.687 --> 00:04:15.322
然後將他們顯示在屏幕上

00:04:16.255 --> 00:04:19.660
這就是TVML如何顯示到屏幕的過程

00:04:20.627 --> 00:04:24.231
讓我們看一下擴展模板的過程中會發生什麼

00:04:27.367 --> 00:04:31.805
當提到模板的擴展
就像添加你自己的標記那樣簡單

00:04:31.872 --> 00:04:33.841
在TVML中將標記發送給框架

00:04:34.441 --> 00:04:35.843
它會經歷相同的處理過程

00:04:35.909 --> 00:04:38.712
它會進入到TVElementFactory
緊接着被轉譯

00:04:39.413 --> 00:04:41.949
但是當自定義的元素碰到
TVInterfaceFactory

00:04:42.015 --> 00:04:44.585
因爲框架不瞭解你的用戶界面

00:04:44.651 --> 00:04:45.953
框架會針對自定義元素詢問你

00:04:46.887 --> 00:04:48.989
當你將界面給框架後

00:04:49.056 --> 00:04:51.925
TVInterfaceFactory
將把自定義的元素顯示在屏幕上

00:04:53.093 --> 00:04:53.927
就是如此的簡單

00:04:55.028 --> 00:04:57.731
現在你知道每個過程是如何工作的

00:04:58.165 --> 00:04:59.700
讓我們來看一下它們的具體實現

00:05:00.300 --> 00:05:02.169
你需要考慮三個步驟

00:05:02.236 --> 00:05:03.770
當你想擴展模板的時候

00:05:03.837 --> 00:05:06.273
首先是定義標記符號

00:05:07.841 --> 00:05:10.210
標記在TVML中
基本上就是XML

00:05:11.245 --> 00:05:12.980
你有一個想法

00:05:13.046 --> 00:05:15.249
就是你的用戶界面在屏幕上會怎樣顯示

00:05:16.283 --> 00:05:18.352
你必須將它轉譯爲一種結構

00:05:18.452 --> 00:05:19.686
一些類似於

00:05:19.753 --> 00:05:22.823
使用標記本身就可以標識什麼應該顯示在屏幕上

00:05:23.824 --> 00:05:27.427
在我們的例子中 我們想在
stackTemplate上顯示一個banner

00:05:29.196 --> 00:05:31.798
banner會有一個動畫背景

00:05:31.865 --> 00:05:35.536
假如你想有能力控制動畫你可以在TVML中
使用一個開關

00:05:36.436 --> 00:05:41.041
因此 myBanner這個元素會有
一個animated屬性

00:05:42.276 --> 00:05:44.811
除此之外 我們再添加一個按鈕

00:05:45.312 --> 00:05:48.515
但是因爲不需要額外的功能

00:05:48.582 --> 00:05:50.417
我們可以使用TVML提供的按鈕

00:05:50.918 --> 00:05:52.853
這就是按鈕的一種形式

00:05:54.688 --> 00:05:58.559
現在你會構想自己的用戶界面

00:05:58.625 --> 00:06:00.160
在標記中會如何顯示

00:06:00.227 --> 00:06:02.462
你需要告訴框架

00:06:02.930 --> 00:06:06.900
這就像將你元素的唯一標識
註冊到框架中那樣簡單

00:06:08.168 --> 00:06:11.872
在應用控制器啓動之前註冊操作需要執行一次

00:06:11.939 --> 00:06:13.674
以便框架能夠意識到

00:06:13.740 --> 00:06:15.008
所有的元素需要特別處理

00:06:16.410 --> 00:06:18.812
上面的過程很簡單就像告知
TVElementFactory

00:06:18.879 --> 00:06:22.115
你想要關聯一個
TVViewElement類到

00:06:22.983 --> 00:06:25.519
你自定義的元素上

00:06:26.587 --> 00:06:30.591
TVViewElement
是基礎的數據結構

00:06:30.657 --> 00:06:32.659
用來轉譯你的標記

00:06:32.726 --> 00:06:34.828
讓框架能識別這些標記

00:06:35.262 --> 00:06:36.964
除TVViewElement外

00:06:37.030 --> 00:06:39.266
我們還可以使用它的兩個子類

00:06:39.833 --> 00:06:42.269
TVImageElement
用於處理圖像

00:06:42.336 --> 00:06:45.272
TVTextElement
用來處理文本

00:06:47.708 --> 00:06:50.611
既然我們已經註冊了這些元素

00:06:51.345 --> 00:06:54.815
現在處理第二步 第三步時
你那邊會有小部分工作

00:06:55.449 --> 00:06:58.585
但是我們試圖讓事情保持簡單
接下來只有兩個步驟

00:06:59.553 --> 00:07:03.123
你要做的第一件事是
創建一個建造者接口

00:07:03.423 --> 00:07:06.426
創建的接口必須遵循
TVInterfaceCreating協議

00:07:06.860 --> 00:07:08.328
這個特別的對象會

00:07:08.395 --> 00:07:10.998
提供你的用戶界面
當框架需要的時候

00:07:11.465 --> 00:07:14.268
有一些回調函數你需要實現

00:07:14.334 --> 00:07:16.203
這些函數需要遵循
TVInterfaceCreating

00:07:16.270 --> 00:07:20.140
協議聲明返回你想要的UI類型

00:07:22.643 --> 00:07:26.313
下一步是當你調用你建造類的接口時

00:07:26.813 --> 00:07:29.816
框架會對你的界面進行配置
然後將界面返回給我們

00:07:31.018 --> 00:07:34.888
像我之前強調的
儘可能複用TVMLKit

00:07:34.955 --> 00:07:36.823
我們已經做了很多工作去保證

00:07:36.890 --> 00:07:41.128
在tvOS上運行時
內置元素在性能、外觀和體驗上的表現是良好的

00:07:41.728 --> 00:07:43.263
讓我們來看一個例子

00:07:43.330 --> 00:07:45.299
建造者的接口是什麼樣子

00:07:47.000 --> 00:07:49.069
在這裏我們有一個
MyInterfaceCreator類

00:07:49.136 --> 00:07:51.205
這個類遵循
TVInterfaceCreating協議

00:07:52.472 --> 00:07:55.108
因爲我們僅對特定的視圖更感興趣

00:07:55.175 --> 00:07:57.845
我們可以去實現makeView元素

00:07:57.911 --> 00:08:00.113
還需要實現
existingView的回調方法

00:08:01.315 --> 00:08:04.318
一旦實現這個類後 你需要做的是

00:08:04.384 --> 00:08:07.554
使用TVInterfaceFactory
註冊這個類的實例

00:08:10.324 --> 00:08:12.426
讓我們具體看一下makeView
這個元素

00:08:13.093 --> 00:08:15.562
我們可以看到TVMLKit

00:08:15.629 --> 00:08:18.866
給你提供了一個元素和
一個可選的existingView

00:08:19.366 --> 00:08:20.901
在這個例子的banner中

00:08:21.301 --> 00:08:23.637
我們只需要檢查這個元素自身的名字

00:08:25.506 --> 00:08:27.708
我們需特別注意
myBanner這個元素

00:08:27.774 --> 00:08:29.510
當我們發現和它類似的元素時

00:08:30.143 --> 00:08:31.745
我們要創建這個視圖的實例

00:08:33.113 --> 00:08:35.381
因爲myBanner有一個元素屬性

00:08:35.916 --> 00:08:38.018
我們可以很容易的篩選到這個元素

00:08:38.085 --> 00:08:40.020
利用這個元素提供的回調函數

00:08:40.787 --> 00:08:42.688
然後將這個元素轉換到視圖上

00:08:44.024 --> 00:08:46.226
我們在這個視圖上還有一個按鈕

00:08:46.760 --> 00:08:49.229
因爲它是一個TVMLKit按鈕

00:08:49.630 --> 00:08:51.098
這樣做是簡單的就像

00:08:51.164 --> 00:08:53.767
爲特定的元素調用
TVInterfaceFactory

00:08:54.134 --> 00:08:56.770
然後會爲myBanner元素
返回它所需要的視圖

00:08:57.638 --> 00:08:59.773
最後當然也會返回你需要的視圖

00:09:01.375 --> 00:09:03.744
在框架默認方法中

00:09:03.810 --> 00:09:05.512
必須返回nil

00:09:07.114 --> 00:09:10.284
我們已經談論了很多視圖的內容
視圖控制器的內容呢？

00:09:11.685 --> 00:09:15.022
TVMLKit提供視圖控制器樣式是

00:09:15.088 --> 00:09:16.723
一個shelf有很多lockup

00:09:16.790 --> 00:09:18.592
用這種樣式進行水平方向擴展

00:09:18.992 --> 00:09:20.661
或者是網格垂直方向上的擴展

00:09:21.962 --> 00:09:24.331
使用TVMLKit的回調函數

00:09:24.398 --> 00:09:27.367
返回這些視圖控制器

00:09:27.434 --> 00:09:29.236
你可以使用你自己的視圖控制器
替換默認的視圖控制器

00:09:30.804 --> 00:09:34.641
這種用法類似於makeView

00:09:34.708 --> 00:09:38.345
在這個實例中我們仍然提供相應元素的
existingViewController

00:09:38.412 --> 00:09:41.682
我們希望最終返回的是
existingViewController

00:09:43.483 --> 00:09:45.185
現在你會想原來如此

00:09:46.520 --> 00:09:47.754
本質上就是視圖的集合

00:09:48.355 --> 00:09:51.225
視圖的集合是許多帶有cell的視圖

00:09:51.925 --> 00:09:54.761
這就是如何對自己的
lockup進行定義

00:09:56.730 --> 00:09:57.998
這個例子夠深刻嗎？

00:09:59.333 --> 00:10:02.536
App Store有一個特殊的要求

00:10:03.103 --> 00:10:07.941
一個佈局僅有一個cell
和特定的行爲

00:10:08.575 --> 00:10:11.512
就像你看到的
其他的東西是UMLKit的擴展

00:10:12.145 --> 00:10:13.580
標題的上下浮動依賴於

00:10:13.647 --> 00:10:16.350
焦點是否位於元素的範圍內

00:10:17.618 --> 00:10:21.121
在將要推出的tvOS 10中

00:10:21.188 --> 00:10:23.924
我們允許你指定
自定義視圖集合的cell

00:10:24.858 --> 00:10:27.094
允許你爲cell自定義佈局

00:10:27.160 --> 00:10:29.930
最重要的是你可以攔截焦點事件

00:10:29.997 --> 00:10:31.465
當cell獲得焦點的時候

00:10:32.299 --> 00:10:34.334
爲了達到這種效果你需要做兩件事情

00:10:34.868 --> 00:10:37.738
首先是用我們最新的API

00:10:37.804 --> 00:10:40.941
它允許你對我們視圖集合的
CellClass進行設置

00:10:41.008 --> 00:10:43.076
當我們使用特定元素的時候

00:10:44.178 --> 00:10:46.413
我們在屏幕上構建用戶界面

00:10:46.947 --> 00:10:49.616
框架通過使用makeView
來允許你進行自定義

00:10:49.883 --> 00:10:52.819
對相關的cell進行配置
返回界面給我們

00:10:53.520 --> 00:10:57.791
我們提供可自定義的視圖集合cell

00:10:57.925 --> 00:10:59.459
將視圖集合的條目加入隊列中

00:10:59.526 --> 00:11:03.463
使用已有視圖自身的參數

00:11:05.432 --> 00:11:07.668
接下來我將請Parry上臺

00:11:07.734 --> 00:11:10.504
爲你們展示上面提到的界面
是如何工作的 Parry

00:11:10.904 --> 00:11:14.007
視圖集合條目的自定義展示

00:11:16.009 --> 00:11:16.910
謝謝你Jeremy

00:11:17.277 --> 00:11:20.914
大家好 我是Parry
我將給大家展示

00:11:21.114 --> 00:11:23.283
如何在TVMLKit自定義cell

00:11:24.451 --> 00:11:26.086
自定義cell是簡單的

00:11:26.153 --> 00:11:29.690
如果你想像多個shelf那樣
使用TVMLKit集合

00:11:29.756 --> 00:11:32.492
還有網格 但你想添加自己的cell

00:11:32.893 --> 00:11:37.397
通過自定義佈局和
聚焦機制來展示你的內容

00:11:38.665 --> 00:11:42.336
我將向你展示一個基於
TVMLKit製作的簡單應用

00:11:43.270 --> 00:11:44.404
稍後

00:11:44.638 --> 00:11:47.374
我將使用自定義cell對它進行擴展

00:11:48.375 --> 00:11:50.177
使得應用的顯示效果更好

00:11:52.312 --> 00:11:53.347
讓我們開始吧

00:11:55.949 --> 00:11:58.352
我把屏幕轉接到我的電腦上

00:12:02.055 --> 00:12:05.893
我使用Xcode打開我的應用

00:12:06.360 --> 00:12:08.228
我會基於TVMLKit進行編碼

00:12:08.695 --> 00:12:10.531
讓我們看看這個應用

00:12:11.265 --> 00:12:15.502
這個應用可以使用戶瀏覽他們的相冊

00:12:18.305 --> 00:12:23.610
應用中使用到的JavaScript
和同XML相關的文件

00:12:23.877 --> 00:12:25.746
都存儲在我的電腦上

00:12:26.046 --> 00:12:28.348
我們可以大體瀏覽下這些文件

00:12:29.650 --> 00:12:32.753
現在顯示的是應用的一個頁面

00:12:33.687 --> 00:12:36.156
這個頁面會把用戶的相冊展示出來

00:12:37.224 --> 00:12:39.259
你可以看到
stackedtemplate

00:12:40.994 --> 00:12:43.163
還有一個不錯的banner

00:12:43.430 --> 00:12:44.765
背景圖

00:12:46.133 --> 00:12:49.503
它有一個shelf是用來展示相冊的

00:12:51.438 --> 00:12:54.842
每個相冊其實通過lockup呈現

00:12:55.809 --> 00:13:01.448
每一個lockup嵌入了
來自相冊的圖片

00:13:02.516 --> 00:13:03.717
最後相冊展示出來

00:13:05.519 --> 00:13:09.223
除了使用一些自定義樣式
使得lockup變得大一點

00:13:09.356 --> 00:13:11.491
我沒有自定義TVMLKit

00:13:12.226 --> 00:13:16.864
現在它是沒有TVMLKit的應用

00:13:18.332 --> 00:13:22.202
運行程序看一下它的展示效果

00:13:25.239 --> 00:13:27.841
接下來我將在Apple TV上運行

00:13:32.246 --> 00:13:36.783
這就是我在stackedtemplate
文件中提到過的應用

00:13:37.084 --> 00:13:39.052
別緻的banner在頂端

00:13:39.920 --> 00:13:41.355
它的shelf在底部

00:13:41.788 --> 00:13:46.293
我覺得超出範圍的那部分還是挺不錯的

00:13:47.060 --> 00:13:50.797
這是奏效的較大的lockup
能使得它看起來不一樣

00:13:52.533 --> 00:13:55.068
我覺得還能做得更好一點

00:13:59.373 --> 00:14:01.675
考慮這種情況

00:14:02.509 --> 00:14:05.546
除了從相冊中取一張照片

00:14:05.979 --> 00:14:08.215
顯示在當前的頁面上

00:14:09.650 --> 00:14:12.419
要是我們選擇多張相片

00:14:12.719 --> 00:14:14.621
選中的照片來自於相冊

00:14:14.888 --> 00:14:18.892
使用那種方式將
相冊放到文檔上會怎樣？

00:14:19.927 --> 00:14:23.363
讓我們想一下

00:14:23.463 --> 00:14:27.134
如何構建圖像的拼圖

00:14:27.601 --> 00:14:29.069
當相冊沒有被選中

00:14:30.804 --> 00:14:34.975
或者當相冊沒有獲得焦點時
將圖片加入到九宮格中

00:14:35.909 --> 00:14:36.810
那聽起來挺酷

00:14:37.911 --> 00:14:39.012
但不止於此

00:14:39.580 --> 00:14:44.084
它將關於相冊的上下文信息傳遞給用戶

00:14:44.885 --> 00:14:48.388
用戶可以看到相冊中的許多圖片

00:14:51.258 --> 00:14:56.330
真是一個使用TVMLKit
自定義cell的不錯例子

00:14:57.497 --> 00:14:58.765
讓我展示如何使用它

00:15:00.434 --> 00:15:04.605
我將切回我的電腦

00:15:05.639 --> 00:15:07.574
我想做的第一件事情是

00:15:07.641 --> 00:15:11.144
像我剛纔所說的創建一個特定的標記

00:15:12.279 --> 00:15:16.049
它是視覺表現的呈現形式

00:15:16.116 --> 00:15:17.718
對你的用戶界面來說

00:15:18.085 --> 00:15:21.321
根據XML的規則使得
TVMLKit可以被理解

00:15:22.322 --> 00:15:24.391
所以我將在這裏

00:15:25.559 --> 00:15:29.363
就像你看到的 它也是一個帶有shelf
的stackedtemplate

00:15:30.464 --> 00:15:36.069
但是除了lockup之外
它還有有一個新的元素

00:15:36.136 --> 00:15:38.138
就是我剛纔創建的
叫做FlyoutCell

00:15:38.539 --> 00:15:40.340
展示的就是我剛纔創建的那個條目

00:15:40.774 --> 00:15:43.911
我稱它爲flyout
因爲圖片看着像從裏面飛出了一樣

00:15:46.013 --> 00:15:48.248
就像描述中提及的

00:15:48.549 --> 00:15:52.019
我想在cell裏放多張圖片

00:15:52.819 --> 00:15:53.687
因此

00:15:53.754 --> 00:15:57.758
cell裏面有多個圖片子元素

00:16:00.294 --> 00:16:02.296
有一點需要注意

00:16:02.596 --> 00:16:04.765
對所有自定義的cell來說

00:16:05.365 --> 00:16:09.303
它們需要有三種樣式

00:16:10.637 --> 00:16:15.375
它們是寬和高

00:16:16.543 --> 00:16:19.379
在tvOS 10中添加新的樣式

00:16:19.446 --> 00:16:21.215
是TV focus margin

00:16:22.883 --> 00:16:27.487
TVMLKit使用寬和高

00:16:27.888 --> 00:16:31.625
在集合視圖中給cell適合的邊框

00:16:32.860 --> 00:16:35.128
使用TV focus margin
作爲默認大小

00:16:36.129 --> 00:16:39.399
當元素獲得焦點時
便可以知道將邊緣擴大多少

00:16:40.601 --> 00:16:42.736
它使用這個信息創建

00:16:43.370 --> 00:16:45.172
適合的間隔在兩個shelf之間

00:16:46.340 --> 00:16:48.542
也會去重新調整
shelf header

00:16:49.910 --> 00:16:52.079
當移動到cell下它便獲得焦點

00:16:54.681 --> 00:16:57.818
現在我們有了規格
那下一步該做什麼？

00:17:00.454 --> 00:17:05.025
需要將新元素加入到TVMLKit中

00:17:05.192 --> 00:17:06.527
讓我們快點做

00:17:07.261 --> 00:17:09.829
讓我們看一下AppDelegate

00:17:10.897 --> 00:17:14.501
在應用中有
didFinishLaunchingWithOptions方法

00:17:16.502 --> 00:17:19.106
我將刪除這些代碼

00:17:19.173 --> 00:17:22.910
我之前寫的 就像上面那樣

00:17:26.012 --> 00:17:29.783
使用我剛添加的
FlyoutCell元素

00:17:31.385 --> 00:17:34.821
使用TVMLKit中的
TVElementFactory

00:17:37.324 --> 00:17:41.395
TVMLKit希望我們對
建造者的接口做出提升

00:17:42.062 --> 00:17:46.800
通過對它進行擴展
以便我可以對cell進行配置

00:17:47.734 --> 00:17:50.370
對吧？所以讓我們快點完成它

00:17:57.778 --> 00:18:00.380
這就是TVMLKit要求的全部配置

00:18:00.447 --> 00:18:03.650
讓我們看一下這些類的實現

00:18:04.084 --> 00:18:07.688
從ExtendedInterfaceCreator開始

00:18:09.990 --> 00:18:13.527
對於自定義的cell
你需要實現兩個API

00:18:15.095 --> 00:18:15.929
首先

00:18:17.531 --> 00:18:19.633
collectionViewCellClass類

00:18:21.235 --> 00:18:24.004
要求用它映射你的自定義元素

00:18:24.071 --> 00:18:27.608
到你使用的
collectionViewCellClass類

00:18:29.977 --> 00:18:34.882
第二個是makeView要求

00:18:34.982 --> 00:18:37.918
使用你的元素配置你的cell

00:18:40.020 --> 00:18:41.889
讓我們快速填充空白的地方

00:18:43.690 --> 00:18:46.426
用我以前寫過的一部分代碼

00:18:46.860 --> 00:18:50.330
對自定義的cell進行映射

00:18:51.832 --> 00:18:55.636
利用collectionViewCellClass類

00:18:58.605 --> 00:18:59.773
同樣的

00:19:04.645 --> 00:19:09.516
利用映射去配置
collectionViewCell類

00:19:10.250 --> 00:19:14.588
特別注意的是已存在視圖的參數

00:19:14.655 --> 00:19:15.989
總是有效的

00:19:16.190 --> 00:19:18.759
因爲TVMLKit將它加入隊列

00:19:18.825 --> 00:19:21.962
從視圖集合中爲了使它顯示出來

00:19:22.029 --> 00:19:26.300
對於自定義的cell
它將會出現在這裏

00:19:28.068 --> 00:19:31.405
在跳轉到flyoutcell配置前

00:19:31.772 --> 00:19:35.075
讓我們看一下
Flyoutcell類本身

00:19:38.278 --> 00:19:41.081
這就是
FlyoutCollectionViewCell類

00:19:41.148 --> 00:19:44.284
我使用它展現flyoutCell

00:19:44.551 --> 00:19:46.954
你可以看到 它就是

00:19:47.020 --> 00:19:48.355
UICollectionViewCell的子類

00:19:49.389 --> 00:19:53.126
在類內部
沒有使用TVMLKit做任何事情

00:19:54.127 --> 00:19:55.429
它僅僅是cell的類

00:19:55.495 --> 00:19:58.498
我可以在原生應用或其它應用中使用它

00:20:00.167 --> 00:20:03.337
需要指出的是它接受

00:20:03.971 --> 00:20:07.541
圖片視圖的數組

00:20:07.608 --> 00:20:10.777
那些數組用來顯示視圖的內容

00:20:12.679 --> 00:20:15.749
這些圖片是我們想要展示的

00:20:15.816 --> 00:20:20.487
在我們擴展TV視圖元素的接口中

00:20:23.557 --> 00:20:28.095
讓我們回到要擴展接口的地方
補全這些代碼

00:20:36.570 --> 00:20:39.540
這就是需要展示的內容 不是太多

00:20:40.974 --> 00:20:43.944
但是挺重要的

00:20:45.979 --> 00:20:50.250
我遍歷所有的子元素

00:20:51.785 --> 00:20:54.588
提取出圖像元素

00:20:55.489 --> 00:21:00.661
簡單的重複使用TVMLKit
爲我們創建圖像

00:21:00.761 --> 00:21:03.597
現在除了沒有顯示圖像之外
它是相當棒的

00:21:03.664 --> 00:21:08.068
因爲我們使用的是網絡圖片

00:21:09.136 --> 00:21:13.106
它允許我們對圖像進行縮放裁剪
來使用給出的範圍

00:21:13.173 --> 00:21:15.209
以便用戶界面可以更好的展示

00:21:16.276 --> 00:21:20.380
它同樣做了緩存以便我可以在
其他地方重複使用這些圖片

00:21:21.448 --> 00:21:27.154
因此複用TVMLKit的視圖
和其他的功能是很有好處的

00:21:27.855 --> 00:21:29.122
我建議你們使用它

00:21:30.624 --> 00:21:33.994
我們已經對代碼進行了完善

00:21:34.061 --> 00:21:36.530
並且和TVMLKit相關的類
能理解我們的元素

00:21:36.830 --> 00:21:39.132
還有一件事情需要去做

00:21:39.333 --> 00:21:42.803
回到我剛纔展示的
stacked文本中

00:21:43.470 --> 00:21:47.407
將所有的lockup替換爲
我們剛添加的FlyoutCell

00:21:48.809 --> 00:21:50.177
我現在回到了那個地方

00:21:51.512 --> 00:21:53.714
移除掉這些lockup

00:21:59.152 --> 00:22:01.355
添加FlyoutCell

00:22:07.027 --> 00:22:10.631
現在有三個相冊
有三個FlyoutCell進行填充

00:22:10.697 --> 00:22:13.233
每一個FlyoutCell有...

00:22:15.202 --> 00:22:16.336
四張圖片在它裏面

00:22:17.704 --> 00:22:21.241
當你添加這些cell的時候
不要忘記添加樣式

00:22:21.308 --> 00:22:24.011
那是強制的要求

00:22:30.083 --> 00:22:34.288
我們添加了所有的東西然後回到應用中

00:22:34.721 --> 00:22:36.523
看一下修改之後的樣子

00:22:38.425 --> 00:22:40.561
我將切換到Apple TV

00:22:46.733 --> 00:22:48.268
上面是flyoutcell

00:22:55.709 --> 00:23:01.515
你可以看到現在比
展示一張圖片的效果更好了

00:23:01.915 --> 00:23:04.785
它看起來更生動

00:23:05.752 --> 00:23:10.023
特別注意cell
只是適用於TVMLKit

00:23:10.090 --> 00:23:13.927
間隔是合適的 甚至相冊的封面

00:23:15.529 --> 00:23:19.533
隨着cell獲得焦點視圖
會進行上下移動

00:23:22.469 --> 00:23:26.907
感覺像是TVMLKit內置的控件
然而它的確是你添加的

00:23:28.775 --> 00:23:29.977
你的界面實現了

00:23:31.178 --> 00:23:33.347
自定義cell的確是非常容易實現

00:23:34.648 --> 00:23:39.520
它允許你添加許多數值到你的應用中

00:23:39.586 --> 00:23:42.155
通過複用TVMLKit提供的

00:23:42.656 --> 00:23:47.127
同時會允許你使用你的方法進行展示

00:23:48.262 --> 00:23:49.129
謝謝

00:23:54.701 --> 00:23:56.136
謝謝你Parry

00:23:56.803 --> 00:23:59.473
我認爲Parry花了很多時間
構建FlyoutCell

00:23:59.540 --> 00:24:02.209
比實際中利用TVMLKit進行顯示

00:24:03.210 --> 00:24:07.414
在繼續進行之前
讓我們快速回顧下前面的內容

00:24:07.981 --> 00:24:11.051
最開始提到了擴展模板

00:24:11.118 --> 00:24:13.987
定義一個標記去描述你的用戶接口

00:24:15.155 --> 00:24:18.592
用TVElementFactory
註冊上面的接口

00:24:18.659 --> 00:24:21.762
然後將它轉譯成視圖元素

00:24:23.163 --> 00:24:27.334
提供可擴展建造者的接口
以便你能聲明自己的用戶接口

00:24:27.401 --> 00:24:30.204
可以隨時停止在屏幕上構建的UI

00:24:32.072 --> 00:24:33.407
更重要的是

00:24:33.473 --> 00:24:37.711
使用TVViewElement
的屬性和特性

00:24:37.778 --> 00:24:41.348
去配置你的用戶界面在顯示到屏幕之前

00:24:43.417 --> 00:24:45.819
這就是關於擴展模板的全部內容

00:24:45.886 --> 00:24:47.321
挺簡單的

00:24:48.322 --> 00:24:52.192
我們看到你們用它
構建自己的應用挺興奮的

00:24:53.427 --> 00:24:58.599
在繼續之前
我們要告訴你一些需要注意的事情

00:25:02.536 --> 00:25:07.140
你的用戶界面通過TVML中的
元素展示出來

00:25:08.008 --> 00:25:10.511
這個文件可以在任意時間更新

00:25:11.144 --> 00:25:16.316
舉個例子 帶有lockup的
shelf在搜索模板裏

00:25:16.917 --> 00:25:21.922
當你進行搜索時 shelf會使用
JavaScript進行更新

00:25:22.189 --> 00:25:23.790
顯示的內容會改變

00:25:24.157 --> 00:25:26.293
這就是內容的更新

00:25:27.427 --> 00:25:28.428
現在

00:25:28.896 --> 00:25:33.433
當我們重新構建用戶界面
文檔的更新就會發生

00:25:33.800 --> 00:25:36.803
我們需要調用接口的建造者

00:25:37.471 --> 00:25:42.009
你需要在元素中查看更新的類型

00:25:42.276 --> 00:25:44.044
並且能看出什麼地方進行了更新

00:25:45.412 --> 00:25:47.714
舉例來說 孩子有可能會變得淘氣

00:25:47.981 --> 00:25:49.183
作爲稱職的父母

00:25:49.249 --> 00:25:51.318
你不想放棄你的孩子

00:25:51.385 --> 00:25:52.886
因爲那樣做不太好

00:25:54.054 --> 00:25:58.358
相應的
儘可能複用cell 複用視圖

00:26:01.028 --> 00:26:04.364
在我們返回banner的那個例子中

00:26:04.932 --> 00:26:08.035
在TVMLKit生態系統中
我們不是好公民

00:26:08.101 --> 00:26:09.703
我們沒有複用所有視圖

00:26:10.571 --> 00:26:12.206
讓我們看看能否改變這種局面

00:26:13.640 --> 00:26:16.043
挺簡單的就更改兩行代碼

00:26:17.544 --> 00:26:22.382
在這個例子中我們把
existingView看作回調的一部分

00:26:22.749 --> 00:26:26.620
我們盡力做出我們期望的視圖

00:26:26.687 --> 00:26:28.589
在MyBanner視圖中

00:26:29.423 --> 00:26:33.126
如果不是我們期望的
實例化一份新的拷貝

00:26:34.361 --> 00:26:38.866
因爲我們有TVMLKit按鈕
基於TVMLKit

00:26:39.433 --> 00:26:41.435
我們也必須做正確的事情

00:26:41.502 --> 00:26:47.641
通過傳遞到
TVInterfaceFactory進行復用

00:26:47.975 --> 00:26:49.977
現有視圖參數

00:26:51.278 --> 00:26:52.846
在特殊的例子中

00:26:52.913 --> 00:26:55.415
因爲MyBanner
是一個比較簡單的視圖

00:26:55.482 --> 00:26:57.918
在任何時間更新它都是沒問題的

00:26:58.218 --> 00:27:00.020
我們不需要去看更新的類型

00:27:00.854 --> 00:27:03.824
除非你的視圖 結構是相當複雜的

00:27:04.191 --> 00:27:06.593
出於性能的原因 我們建議你

00:27:06.660 --> 00:27:09.696
看一下更新的類型找出更新的部分

00:27:12.633 --> 00:27:13.667
這是...

00:27:15.002 --> 00:27:18.071
你需要改變的第一行

00:27:19.806 --> 00:27:20.774
現在

00:27:21.241 --> 00:27:25.679
在tvOS 10的新特性
就是明暗的視覺表現

00:27:26.113 --> 00:27:28.916
若你使用TVMLKit自定義的視圖

00:27:29.550 --> 00:27:34.221
你可以去監聽這些特徵
來做出或明或暗的變化

00:27:36.456 --> 00:27:40.994
我們有闡述tvOS新特性的演講
還會告訴你需要做的

00:27:41.128 --> 00:27:43.096
我建議你們仔細看看

00:27:43.664 --> 00:27:44.932
外觀的適配

00:27:45.365 --> 00:27:48.902
在這個例子中
你需要了解TVMLKit的規則

00:27:49.069 --> 00:27:52.372
複用我們的組件 謝謝你

00:27:53.207 --> 00:27:56.777
我建議你檢核樣式更新的提示

00:27:56.844 --> 00:27:58.345
從元素更新類型過程中

00:27:59.112 --> 00:28:01.682
它會告訴你視圖

00:28:01.748 --> 00:28:03.650
是明或是暗的表現形式

00:28:04.351 --> 00:28:06.386
複用文檔靈活更新

00:28:06.453 --> 00:28:09.356
對你來說是僅有的方法

00:28:09.423 --> 00:28:12.526
來更新你的視圖展示或明或暗的效果

00:28:13.760 --> 00:28:16.630
因爲他們是你需要
複用的TVMLKit組件

00:28:17.531 --> 00:28:21.001
更重要的是我們需要轉到
TVInterfaceFactory

00:28:21.068 --> 00:28:22.603
這樣才能完成這些顯示工作

00:28:25.806 --> 00:28:31.445
如果你有原生的應用
又或者你有自己的視圖控制器

00:28:32.246 --> 00:28:34.314
你在應用中使用了TVMLKit

00:28:34.848 --> 00:28:37.184
你可以讓框架混合使用它們

00:28:38.085 --> 00:28:40.988
這就像定義一個模板元素那樣簡單

00:28:43.023 --> 00:28:46.293
再次強調 通過元素工廠註冊它

00:28:47.327 --> 00:28:52.032
通過加載特定的模板
構建我們的用戶界面

00:28:52.232 --> 00:28:55.502
返回你的視圖控制器
所有的設置就完成了

00:28:58.672 --> 00:29:02.976
另一種方法在你已存在的
原生應用使用TVMLKit

00:29:03.410 --> 00:29:07.981
是獲得我們提供子應用的導航控制器

00:29:09.950 --> 00:29:12.920
你已經學習了
如何創建TV應用的控制器

00:29:13.187 --> 00:29:17.658
我要強調的是
在這個例子中你不用指定一個窗口

00:29:17.858 --> 00:29:19.526
因爲我們已經有一個窗口了

00:29:20.127 --> 00:29:24.031
選擇你要在導航控制器中
顯示的視圖控制器

00:29:25.032 --> 00:29:27.301
一旦你有了TV應用的控制器

00:29:27.801 --> 00:29:30.470
獲得它的導航控制器並且展示它

00:29:32.706 --> 00:29:37.144
另一種方法是
使用UIWindow的實例

00:29:37.978 --> 00:29:42.850
在這個例子中你需要指定窗口參數

00:29:43.917 --> 00:29:47.487
一旦JavaScript啓動
或者應用邏輯執行了

00:29:47.554 --> 00:29:52.125
TVMLKit做正確的事
將你窗口的鍵值隱藏

00:29:54.161 --> 00:29:57.531
接下來Christopher
將會和大家談論

00:29:57.598 --> 00:30:00.100
如何擴展應用的功能

00:30:00.167 --> 00:30:02.102
通過調用JavaScript

00:30:02.469 --> 00:30:03.370
Chris

00:30:08.208 --> 00:30:09.142
謝謝Jeremy

00:30:09.243 --> 00:30:13.247
大家好 我是Christopher
TVMLKit的工程師

00:30:14.147 --> 00:30:19.219
剛剛我們看了如何在
TVMLKit中擴展模板引擎

00:30:19.586 --> 00:30:21.221
使用自定義的標記

00:30:21.388 --> 00:30:25.492
實現我們自己的視圖和視圖控制器

00:30:25.659 --> 00:30:27.528
還有視圖集合的cell

00:30:28.095 --> 00:30:31.899
你也可擴展TVMLKit的腳本引擎

00:30:31.965 --> 00:30:34.201
通過使用
JavaScriptCore實現

00:30:34.401 --> 00:30:38.438
實現你自己應用中的特定功能

00:30:38.505 --> 00:30:41.275
在JavaScript中
或暴露給JavaScript

00:30:42.176 --> 00:30:46.547
有三種方式來將代碼注入到
JavaScript的運行環境

00:30:46.613 --> 00:30:48.515
在你的TVML應用中

00:30:48.582 --> 00:30:49.516
讓我們看一下

00:30:51.318 --> 00:30:56.290
首先 你可以在運行時
加載額外的JavaScript庫

00:30:58.559 --> 00:31:03.197
第二 你可以使用原生代碼直接交互

00:31:03.263 --> 00:31:05.966
同JavaScript的上下文
在你的應用中

00:31:06.066 --> 00:31:11.038
觸發JavaScript中的函數
或者傳遞數據

00:31:11.104 --> 00:31:12.472
在兩個運行環境之間

00:31:13.640 --> 00:31:17.044
第三 你可以使用原生類

00:31:17.444 --> 00:31:20.347
將原生類傳遞到JavaScript

00:31:20.714 --> 00:31:24.618
通過簡單的類約定
使你的腳本可以訪問它們

00:31:24.685 --> 00:31:25.919
在JavaScriptCore中

00:31:27.154 --> 00:31:29.756
讓我們詳細的瞭解下這些方法

00:31:29.823 --> 00:31:31.391
從最簡單的開始

00:31:32.659 --> 00:31:33.794
JavaScript庫

00:31:33.861 --> 00:31:38.031
當你的應用開始加載
最先發生的事情是

00:31:38.098 --> 00:31:40.601
TVMLKit會加載
JavaScript文件

00:31:40.667 --> 00:31:43.604
文件裏面會包含
app.onlaunch回調

00:31:43.670 --> 00:31:47.674
應用的控制權會交給你TVML
應用的JavaScript

00:31:48.342 --> 00:31:52.880
啓動過程必須等待直到
application.js文件加載運行

00:31:53.013 --> 00:31:56.450
在app.launch執行完成之前

00:31:56.850 --> 00:32:00.954
如果說你的應用比較龐大
你可以對代碼進行切割

00:32:01.021 --> 00:32:03.991
把代碼放到許多獨立的文件中
加速啓動時間

00:32:05.626 --> 00:32:09.263
這是TVMLKit普遍支持的形式

00:32:09.329 --> 00:32:11.765
允許你加載額外的
JavaScript

00:32:12.533 --> 00:32:14.768
在應用運行時的任何時候

00:32:16.103 --> 00:32:20.440
你的JavaScript庫
其中可以定義變量

00:32:20.507 --> 00:32:24.411
和函數並且可以被所有的腳本使用

00:32:26.947 --> 00:32:33.287
讓我們看一下TVMLKit JS
提供的全局函數

00:32:33.887 --> 00:32:38.091
一般情況下你能在
app.onlaunch上進行調用

00:32:38.158 --> 00:32:40.027
你也可以在其他的地方進行調用

00:32:40.861 --> 00:32:47.067
這個函數使用腳本URL的數組
和完整的回調函數作爲參數

00:32:48.068 --> 00:32:50.871
當回調函數執行後

00:32:51.238 --> 00:32:53.774
你可以使用變量和函數

00:32:53.841 --> 00:32:55.475
我們在腳本庫中定義的

00:32:56.376 --> 00:32:58.312
但是還有一些事情需要注意

00:33:01.381 --> 00:33:03.550
當你調用執行腳本的時候

00:33:04.151 --> 00:33:07.254
TVMLKit JS會執行這些代碼

00:33:07.321 --> 00:33:10.390
在你的JavaScript文件中
會調用其它函數

00:33:11.358 --> 00:33:15.729
所以在相同的文件中
不要多次調用執行腳本

00:33:16.363 --> 00:33:20.133
同樣要注意如果你的腳本
依賴其它的腳本

00:33:20.200 --> 00:33:22.135
你需要以正確的順序加載它們

00:33:24.905 --> 00:33:29.443
執行腳本會併發的
根據URL下載腳本文件

00:33:30.244 --> 00:33:32.946
然後會一次執行它們

00:33:33.380 --> 00:33:37.985
如果其中任何一個腳本沒有獲取到
其它腳本也不會執行

00:33:38.051 --> 00:33:42.890
當回調完成後要檢查成功的參數來確保

00:33:42.956 --> 00:33:45.592
JavaScript庫是可獲取到的

00:33:47.995 --> 00:33:50.430
最後 我想告訴大家

00:33:50.531 --> 00:33:55.169
儘管TVMLKit
提供了許多類似網頁的接口

00:33:55.235 --> 00:33:58.238
可是你的TVML應用不是網頁瀏覽器

00:33:58.472 --> 00:34:02.643
可能發現許多JavaScript庫
能很好的幫助你開發網頁應用

00:34:02.709 --> 00:34:04.811
但在TVMLKit中
有可能出現不兼容的情況

00:34:04.878 --> 00:34:07.314
尤其是你依賴瀏覽器功能的時候

00:34:07.381 --> 00:34:11.518
比如全局的window對象
或者全局的document對象

00:34:12.319 --> 00:34:13.587
記住那些就可以了

00:34:15.989 --> 00:34:17.591
但是不要限制你自己

00:34:17.658 --> 00:34:20.527
在你的TVML應用中
使用JavaScript

00:34:20.860 --> 00:34:24.264
你能進入到
JavaScript運行環境

00:34:24.364 --> 00:34:25.831
從原生的代碼中

00:34:26.500 --> 00:34:31.505
可以將應用的UI事件
傳遞到JavaScript中

00:34:31.605 --> 00:34:34.741
或者在JavaScript和
原生之間上傳和拉取數據

00:34:37.678 --> 00:34:43.583
TVML中 你JavaScript
運行環境是被TVMLKit

00:34:44.451 --> 00:34:47.654
的一個叫作
TVApplicationController類管理着

00:34:48.388 --> 00:34:51.324
JavaScript
在單獨的線程中執行

00:34:51.391 --> 00:34:53.659
所以你需要對進行交互的時機進行調度

00:34:54.761 --> 00:34:57.331
最簡單的形式是
你只需要簡單的調用函數

00:34:57.397 --> 00:35:01.768
在TVApplicationController上
然後將block傳遞進去並執行

00:35:04.338 --> 00:35:08.942
當block執行後
你將獲得JS上下文環境的引用

00:35:09.209 --> 00:35:13.080
在這裏你可將字符串當做
JavaScript代碼執行

00:35:13.747 --> 00:35:16.583
你可以在對象上觸發函數

00:35:16.817 --> 00:35:21.855
你可獲取和設置JavaScript
的屬性使用原生的變量

00:35:23.190 --> 00:35:26.827
你不能持有JSContext

00:35:26.927 --> 00:35:28.962
或者在block之外的任何地方使用

00:35:31.632 --> 00:35:34.768
由於JavaScript運行在
單獨的線程中

00:35:34.835 --> 00:35:38.972
你需要注意你不能執行任何阻塞操作

00:35:39.039 --> 00:35:40.807
當你執行block的時候

00:35:41.041 --> 00:35:43.043
否則會在主線程中出現死鎖

00:35:44.011 --> 00:35:48.682
獲得關於JSContext和
JavaScriptCore更多信息

00:35:48.749 --> 00:35:53.520
請訪問 WWDC 2013中
JavaScriptCore部分

00:35:55.289 --> 00:35:59.760
讓我看這個例子是如何調用
JavaScript代碼的

00:36:00.194 --> 00:36:01.862
從Swift應用中

00:36:02.696 --> 00:36:07.367
這個顯示的Swift代碼是
TVML應用代理裏面的

00:36:07.901 --> 00:36:11.839
我們已爲UIApplication
的代理方法實現了一個stub

00:36:11.905 --> 00:36:14.508
來處理自定義的URL方案

00:36:16.910 --> 00:36:20.647
如果我們想把URL
傳遞到JavaScript中

00:36:20.781 --> 00:36:25.252
需要讓appController
去執行block

00:36:25.352 --> 00:36:27.054
在JavaScript的執行環境中

00:36:29.456 --> 00:36:34.995
當block執行完之後
我們將得到JSContext的引用

00:36:35.195 --> 00:36:37.564
從這兒我們可以訪問相應的屬性

00:36:37.631 --> 00:36:41.235
直接在JavaScript的
全局對象上

00:36:42.903 --> 00:36:48.842
我們可以得到原生的變量和對象且
能將其作爲JavaScript屬性

00:36:48.909 --> 00:36:51.278
或者就像這個例子中 作爲函數的參數

00:36:52.145 --> 00:36:56.283
我們觸發打開URL的全局函數

00:36:56.350 --> 00:37:01.822
函數在JavaScript中
定義然後將URL字符串傳遞進去

00:37:01.889 --> 00:37:04.791
URL來自
UIApplication代理回調

00:37:06.593 --> 00:37:09.897
我們暴露新的函數

00:37:09.963 --> 00:37:12.065
在我們的TVMLKit應用中

00:37:12.165 --> 00:37:14.768
並且將應用的事件
傳遞到JavaScript中

00:37:18.005 --> 00:37:19.973
接下來 讓我們談論橋接

00:37:20.674 --> 00:37:25.112
使用本地變量是如此的簡單

00:37:25.345 --> 00:37:30.450
在JavaScript中
使用這些變量就像使用字符串

00:37:30.517 --> 00:37:32.553
數字和數組那樣簡單

00:37:32.619 --> 00:37:35.355
這些已經在
JavaScriptCore處理了

00:37:36.890 --> 00:37:39.359
如果你想使用自己的類

00:37:40.060 --> 00:37:43.697
你所要做的是遵循類之間一些簡單協議

00:37:43.764 --> 00:37:47.267
JavaScriptCore
也會爲你的類進行連接

00:37:47.668 --> 00:37:48.569
讓我們看一下

00:37:50.337 --> 00:37:52.139
這兒有三個主要的步驟

00:37:53.106 --> 00:37:59.546
首先你必須聲明一個自定義擴展
自JSExport的協議

00:37:59.613 --> 00:38:01.481
JSExport存在於
JavaScriptCore中

00:38:03.350 --> 00:38:08.622
第二 我們需要使用
Swift定義我們的類

00:38:08.755 --> 00:38:13.594
擴展這個協議後然後將它暴露給原生類

00:38:14.761 --> 00:38:18.699
第三 對我們的類進行實例化

00:38:18.765 --> 00:38:21.802
或者將這個類本身暴露出來

00:38:21.869 --> 00:38:26.273
在TV應用控制器的代理上進行回調

00:38:26.373 --> 00:38:30.511
在控制權被交到JavaScript
之前準備JSContext

00:38:30.577 --> 00:38:31.912
在應用啓動期間

00:38:34.314 --> 00:38:38.418
讓我們看一個方法如何去

00:38:38.485 --> 00:38:42.689
對StoreKit進行包裝

00:38:42.756 --> 00:38:45.392
如果我們想把購買的函數暴露給

00:38:46.093 --> 00:38:47.194
給JavaScript

00:38:49.496 --> 00:38:52.599
我們開始定義我們的協議

00:38:53.367 --> 00:38:56.737
在這裏我們會指定屬性和方法

00:38:56.803 --> 00:39:00.073
使用JavaScriptCore
爲我們提供連接

00:39:02.242 --> 00:39:04.378
這裏 我將把它作爲stub

00:39:04.444 --> 00:39:10.017
看到我們擴展了JSExport且定義了
StoreKitWrapperProtocol的協議

00:39:11.985 --> 00:39:16.590
下一步我將爲
StoreKit創建一個包裝類

00:39:16.657 --> 00:39:20.627
擴展自NSObject
並且實現自定義的協議

00:39:21.528 --> 00:39:23.997
再次強調 我保留了存根的細節

00:39:24.064 --> 00:39:27.100
但是你要在存根出定義你的原生函數

00:39:27.167 --> 00:39:29.203
這函數你在
JavaScript中調用

00:39:31.972 --> 00:39:37.177
最後 我們實現
TVApplicationControllerDelegate方法

00:39:37.578 --> 00:39:40.547
在執行應用的
JavaScript上下文環境中

00:39:41.148 --> 00:39:44.785
這些會在app.onlaunch
執行之前調用

00:39:44.852 --> 00:39:48.789
並且允許我們去暴露我們自己的函數

00:39:48.856 --> 00:39:51.658
在將控制權移交給
JavaScript之前

00:39:52.926 --> 00:39:54.528
這就是關於原生語言調用
JavaScript的全部內容

00:39:55.028 --> 00:39:57.431
我們定義了一個原生類

00:39:57.497 --> 00:39:59.399
我們使用使用上述步驟
使這個類可訪問

00:39:59.466 --> 00:40:01.902
對我們TVML應用
JavaScript來說

00:40:04.938 --> 00:40:09.476
在這個會議上 我們已看到
如何利用原生功能

00:40:09.543 --> 00:40:12.212
提升你的TVML應用

00:40:13.580 --> 00:40:16.817
你可以使用自定義的標記擴展模板

00:40:17.317 --> 00:40:20.187
爲你自己的視圖和視圖集合cell

00:40:20.687 --> 00:40:25.425
在你的原生應用中
你可以獲得TVMLKit

00:40:25.492 --> 00:40:29.630
或者在TVMLKit中
使用你的原生視圖控制器

00:40:31.098 --> 00:40:34.868
你甚至可以在TVMLKit中
擴展腳本的環境

00:40:35.035 --> 00:40:38.705
連接原生類 應用程序事件

00:40:39.206 --> 00:40:41.141
和加載額外的庫

00:40:42.009 --> 00:40:46.847
我們已經展示給大家
它是多麼的簡單去構建應用的特定功能

00:40:46.914 --> 00:40:50.050
在你的TVMLKit應用中
自定義自己的品牌

00:40:50.918 --> 00:40:54.988
在構建複雜應用時TVMLKit
提供的API是比較簡單的

00:40:55.055 --> 00:40:57.891
構建高質量的應用和小的開銷

00:40:59.760 --> 00:41:02.629
我希望你能看一下TVML指南

00:41:02.696 --> 00:41:05.566
還有TVML目錄下的應用實例

00:41:05.632 --> 00:41:09.403
獲取更多的關於擴展和
使用TVMLKit的信息

00:41:10.070 --> 00:41:12.372
你也可以訪問Apple開發者網站

00:41:12.439 --> 00:41:15.843
查看編程指南 示例代碼和文檔

00:41:19.446 --> 00:41:24.484
還可以留意今年 WWDC 2016
的其他演講內容

00:41:24.551 --> 00:41:28.222
特別是使用TVMLKit
開發應用的第一部分

00:41:28.288 --> 00:41:32.226
裏面展示了構建一個完整應用的全過程

00:41:33.126 --> 00:41:36.964
謝謝 希望大家在WWDC 2016
餘下的演講中玩得愉快