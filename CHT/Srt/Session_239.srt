00:00:19.419 --> 00:00:24.925
製作現代化Cocoa應用

00:00:35.235 --> 00:00:38.071
大家好 歡迎來到
“製作現代化Cocoa應用”

00:00:38.438 --> 00:00:39.473
我是Corbin Dunn

00:00:39.540 --> 00:00:41.975
我將和同事Jeff一起來做本次演講

00:00:42.042 --> 00:00:43.977
我們都是AppKit的軟件工程師

00:00:44.545 --> 00:00:47.080
讓我們直入正題
今天我們將會討論什麼呢？

00:00:47.147 --> 00:00:49.082
我們將涉及一大捆的話題

00:00:49.149 --> 00:00:51.251
我們來談論下
創建一個現代化外觀

00:00:51.318 --> 00:00:55.455
如何正確拖放
容器視圖控制 表視圖

00:00:55.989 --> 00:00:59.293
使用系統外觀
storyboard設計

00:00:59.359 --> 00:01:01.161
和其他一些酷酷的Mac特性

00:01:01.361 --> 00:01:02.429
非常多的東西

00:01:02.796 --> 00:01:05.232
我們快速通過一個演示應用來強調

00:01:05.299 --> 00:01:06.800
就像我們看到的這個截圖

00:01:07.267 --> 00:01:10.337
它如何使用新特性或者
如何使用已存在的特性

00:01:11.772 --> 00:01:13.874
所有的這些技術

00:01:14.107 --> 00:01:18.345
大多數你早已可在MacOSX 10.10
或10.11使用了

00:01:18.612 --> 00:01:22.749
10.12中的
任何新技術我們都會重點指出

00:01:23.217 --> 00:01:25.619
關於這個演示應用
我們希望你能下載

00:01:25.686 --> 00:01:27.988
儘管這個應用還不能下載
不過很快就可以

00:01:28.055 --> 00:01:29.723
並且該應用和這次演講有關聯

00:01:31.058 --> 00:01:32.626
讓我們進入正題

00:01:32.693 --> 00:01:35.829
討論一下如何用現代化視圖

00:01:35.896 --> 00:01:38.232
構建一個現代化外觀並且你可以做什麼

00:01:39.733 --> 00:01:43.504
現代化外觀意味着現代化窗口
和現代化工具欄

00:01:43.737 --> 00:01:45.606
就像這裏展示的演示應用

00:01:46.640 --> 00:01:50.777
其中一個你需要做的是
使用全尺寸內容視圖

00:01:51.345 --> 00:01:53.046
這個全尺寸內容視圖

00:01:53.514 --> 00:01:55.482
允許你的內容視圖進行延伸

00:01:55.749 --> 00:01:59.286
在工具欄下面的區域
這裏我用白色標記強調

00:01:59.686 --> 00:02:03.257
這意味着全尺寸內容視圖

00:02:03.323 --> 00:02:06.093
自動地在工具欄和標題欄旁模糊

00:02:06.226 --> 00:02:07.928
不需要你做任何事

00:02:09.463 --> 00:02:11.832
使用全尺寸內容視圖非常簡單

00:02:12.032 --> 00:02:13.600
只是一個窗口樣式的掩碼

00:02:13.667 --> 00:02:17.137
你可以使用.fullSizeContentView位
設置它

00:02:18.005 --> 00:02:19.806
或若你使用
Interface Builder

00:02:19.873 --> 00:02:23.210
你可直接在勾選框中的
全尺寸內容視圖上打勾 就可應用它了

00:02:24.912 --> 00:02:27.181
所以如果你要使用全尺寸內容視圖

00:02:27.681 --> 00:02:31.552
你可能需要抵消在它下面的內容

00:02:32.286 --> 00:02:33.954
例如 假如說

00:02:34.655 --> 00:02:37.524
我們想讓一些東西在工具欄
或者標題欄下面

00:02:38.392 --> 00:02:40.394
我們可能會

00:02:41.195 --> 00:02:42.429
在那裏放一個標籤或什麼

00:02:43.797 --> 00:02:45.666
若我們想把標籤放那裏
如何來完成

00:02:45.866 --> 00:02:47.734
在工具欄或標題欄下面

00:02:47.801 --> 00:02:50.737
如果有 比如
動態高度改變

00:02:51.572 --> 00:02:55.309
並且我們不想讓這個標籤擁有
一個寫死的Y位移

00:02:55.375 --> 00:02:57.544
因爲寫死的位移
實在是太糟糕了

00:02:58.612 --> 00:03:00.247
所以我們要的是

00:03:00.447 --> 00:03:02.616
NSWindow的
contentLayoutRect屬性

00:03:03.116 --> 00:03:06.553
這是一個可觀測的鍵值
一個可觀測的KVO屬性

00:03:07.020 --> 00:03:09.756
任何時候你可用它發現
contentLayoutRect

00:03:09.823 --> 00:03:11.658
藍綠色的區域改變

00:03:12.192 --> 00:03:14.228
在這基礎上 你可以把你的視圖

00:03:14.294 --> 00:03:16.129
直接放到標題欄或工具欄下面

00:03:18.165 --> 00:03:20.734
但是我們也鼓勵使用自動佈局

00:03:20.801 --> 00:03:22.236
並且如果你使用自動佈局

00:03:22.736 --> 00:03:26.507
你可以使用contentLayoutGuide
一個NSWindow上的屬性

00:03:27.574 --> 00:03:30.844
例如 在NSViewController子類裏

00:03:30.911 --> 00:03:33.680
你可能重寫updateViewConstraints

00:03:34.281 --> 00:03:35.883
並且你想創建一個約束

00:03:36.049 --> 00:03:38.318
你得到window的
contentLayoutGuide

00:03:39.219 --> 00:03:42.289
爲它標記上錨點
並且你會得到一個文本區域

00:03:42.756 --> 00:03:45.425
然後應該創建了一個約束

00:03:45.592 --> 00:03:49.229
在這個文本區域的頂部錨點
並且激活它

00:03:49.796 --> 00:03:50.964
如果你這樣做

00:03:51.031 --> 00:03:54.635
在文本視圖會自動
在標題欄或者工具欄下面的區域

00:03:54.902 --> 00:03:56.436
不用你做任何事

00:03:56.837 --> 00:03:58.005
十分容易

00:03:59.773 --> 00:04:04.611
接下來 關於現代化的應用
你該用一個流線型工具欄

00:04:05.145 --> 00:04:07.648
這是一個常規應用的截圖

00:04:08.182 --> 00:04:11.451
值得注意的是這裏有一個明顯標題欄

00:04:11.652 --> 00:04:14.388
或者 抱歉
它在頂部有一個明顯的標題

00:04:14.855 --> 00:04:16.490
並且在那應該有一個圖標

00:04:16.557 --> 00:04:18.725
若這個應用確實有一個
關於這個文檔的圖標

00:04:19.593 --> 00:04:23.530
如果使用一個流線型的工具欄
那個標題會消失

00:04:24.464 --> 00:04:26.500
這個工具欄將會向上移動一點

00:04:27.201 --> 00:04:30.003
並且窗口按鈕 關閉按鈕等等

00:04:30.737 --> 00:04:33.373
會和標題欄或者工具欄區域
在一條直線上

00:04:34.675 --> 00:04:37.010
做到這些十分容易

00:04:37.277 --> 00:04:40.714
你需要做的僅僅是設置一下標題的
visibility屬性

00:04:40.981 --> 00:04:41.915
爲.hidden

00:04:42.349 --> 00:04:43.717
那麼標題將會被隱藏

00:04:43.984 --> 00:04:46.687
工具欄將會被向上推
並且所有的東西都會在一條線上

00:04:47.054 --> 00:04:47.888
你何時想做這些？

00:04:47.955 --> 00:04:51.325
你可能想爲應用做這些
例如shoebox應用

00:04:51.391 --> 00:04:53.760
例如地圖 日曆

00:04:53.961 --> 00:04:56.864
系統設置 具有這類屬性

00:04:56.930 --> 00:05:00.934
像是這些一個窗口的應用
都非常適用這種風格

00:05:03.670 --> 00:05:08.742
還有其他的事可以做嗎？
好吧 你也許想完善

00:05:08.909 --> 00:05:10.644
標題欄或工具欄的區域

00:05:10.711 --> 00:05:12.679
用輔助視圖控制器

00:05:13.347 --> 00:05:14.214
例如

00:05:14.748 --> 00:05:17.084
你可能想有一個輔助視圖控制器

00:05:17.150 --> 00:05:18.952
就在標題欄下面

00:05:19.586 --> 00:05:22.623
通過這樣做你想讓它自動變模糊

00:05:22.689 --> 00:05:24.224
你不用做任何事

00:05:24.725 --> 00:05:27.861
尺寸將會跟隨窗口的尺寸自動改變

00:05:28.629 --> 00:05:31.064
不需要你做任何事
如何做到這些？

00:05:32.132 --> 00:05:35.002
這十分簡單
我們有一個視圖控制器子類

00:05:35.169 --> 00:05:37.871
叫做NSTitlebar
AccessoryViewController

00:05:38.472 --> 00:05:40.440
你可以給這個視圖控制器
設置視圖

00:05:40.807 --> 00:05:43.076
除此之外
它還暴露了一個佈局屬性

00:05:43.577 --> 00:05:46.780
所以佈局屬性可被
設置爲.bottom 意思是

00:05:46.847 --> 00:05:50.317
這個輔助將會在標題區域的底部

00:05:51.084 --> 00:05:53.620
注意出現在它下面的文本因爲

00:05:53.687 --> 00:05:57.191
我們使用符合內容佈局指導的
合適的內容佈局

00:05:57.424 --> 00:05:58.792
不需要做任何事

00:06:00.427 --> 00:06:01.662
除了設置在底部

00:06:02.429 --> 00:06:05.666
佈局屬性還可以設置在leading
或者trailing

00:06:06.166 --> 00:06:10.637
意思是你可以有一個
輔助視圖控制器在標題區域上面

00:06:10.971 --> 00:06:13.140
例如一個註冊按鈕

00:06:13.207 --> 00:06:15.275
或者其它你想添加的

00:06:15.976 --> 00:06:19.780
macOS X 10.12上的新特性是
使用leading和trailing的能力

00:06:20.180 --> 00:06:23.317
和之前發佈的
left和right相反

00:06:24.017 --> 00:06:27.921
我們更推薦你使用leading和trailing
因爲它讓你窗口運作得更好

00:06:28.155 --> 00:06:30.757
當你使用從右到左的本地化

00:06:31.191 --> 00:06:32.059
這樣 例如

00:06:32.125 --> 00:06:34.828
如果我僅僅
在從右向左的模式下運行

00:06:35.262 --> 00:06:38.832
你可以看到輔助視圖控制器自動反轉

00:06:38.899 --> 00:06:41.134
到另一邊
什麼都不用做的情況下

00:06:43.737 --> 00:06:45.739
接下來我們 系統

00:06:45.806 --> 00:06:49.409
可能添加我們的
輔助視圖控制器到你的窗口

00:06:49.676 --> 00:06:53.180
例如 我們可能爲了
創造標籤窗口而使用它

00:06:53.247 --> 00:06:54.882
我們聚集多個窗口

00:06:55.182 --> 00:06:56.984
到一個類似虛擬窗口

00:06:58.318 --> 00:07:01.555
我們如何實現窗口分頁
並且你作爲一個開發者應做什麼？

00:07:01.989 --> 00:07:03.423
你不需要做任何事情

00:07:03.490 --> 00:07:05.158
若你命令一個窗口前

00:07:05.626 --> 00:07:08.862
我們做的是尋找和那個窗口
相似的窗口

00:07:09.429 --> 00:07:12.999
相似是說尋找
tabbing identifier屬性

00:07:13.500 --> 00:07:15.335
如果它有相同的
tabbing identifier

00:07:15.502 --> 00:07:17.504
我們優先聚集起這些窗口

00:07:17.571 --> 00:07:19.273
到一個單獨被做了標籤的窗口

00:07:20.374 --> 00:07:22.209
這些窗口都被認爲是可視的

00:07:22.276 --> 00:07:23.977
即使它可能是一個隱藏的標籤

00:07:24.378 --> 00:07:26.880
但我們實際將它們隱藏
在覈心圖像中

00:07:27.614 --> 00:07:30.684
若你使用NSDocument
大量的東西 如plus按鈕

00:07:30.817 --> 00:07:34.321
在標籤欄裏面的將會自動工作
不需要你的任何支持

00:07:34.922 --> 00:07:38.392
但若你不使用NSDocument
你可以實現一個響應鏈方法

00:07:38.458 --> 00:07:40.961
新標籤窗口來創建一個新文檔

00:07:41.028 --> 00:07:42.596
或在plus按鈕上的新窗口

00:07:43.664 --> 00:07:46.433
欲知更多信息
請觀看“Cocoa的新特性”

00:07:46.967 --> 00:07:48.569
來瞭解更多的細節

00:07:51.939 --> 00:07:53.674
關於標題欄的更多信息

00:07:53.807 --> 00:07:57.411
關於輔助視圖控制器
及它們怎麼和全屏幕交互的

00:07:57.644 --> 00:08:00.080
我強烈推薦你們去
看一下2015年的演講

00:08:00.380 --> 00:08:02.549
“改善全屏幕窗口體驗”

00:08:05.118 --> 00:08:08.488
接下來我們會談論下
核心動畫

00:08:09.256 --> 00:08:10.624
什麼是核心動畫？

00:08:10.724 --> 00:08:14.695
它是一個圖形渲染引擎

00:08:14.761 --> 00:08:17.431
在GPU上做大量工作
而不是在CPU上

00:08:17.831 --> 00:08:21.568
所以任何東西都可以非常快地
滾動

00:08:22.269 --> 00:08:24.404
所以我們可以很快並且很流暢的動畫

00:08:25.506 --> 00:08:27.875
它的一個基礎結構
是一個CA layer

00:08:29.510 --> 00:08:34.280
我們實際上是怎麼
使用圖層創建佈局和視圖的

00:08:34.581 --> 00:08:35.749
或者視圖本身呢

00:08:36.216 --> 00:08:40.621
這是一個你可能用到背景圖層的
動畫實例

00:08:40.687 --> 00:08:43.690
一箇中間的圖層 再來一個前面的圖層
做一個動畫

00:08:44.424 --> 00:08:47.160
你想用多個子視圖中合成你的視圖

00:08:47.661 --> 00:08:48.829
來創造一個最終的畫面

00:08:50.931 --> 00:08:53.400
讓我們看一下核心動畫的屬性

00:08:53.467 --> 00:08:58.138
CALayer允許你創建
你可以在屏幕上看到的內容

00:08:59.506 --> 00:09:02.009
說到內容 CALayer
有一個contents屬性

00:09:02.376 --> 00:09:05.812
這個contents屬性可以是NSImage
或CGImageRef

00:09:06.213 --> 00:09:07.915
恰好呈現出你所看到的

00:09:08.515 --> 00:09:09.917
在那個層的contents裏

00:09:10.350 --> 00:09:12.619
但你也可以
在CALayer上設置其它屬性

00:09:12.686 --> 00:09:14.721
比如背景顏色

00:09:14.788 --> 00:09:16.456
比如邊框的顏色 邊框的寬度

00:09:16.623 --> 00:09:18.125
比如圓角弧度

00:09:18.458 --> 00:09:20.827
你還可以在CALayer上
發現更多的屬性

00:09:20.894 --> 00:09:23.697
看到其他可操作東西
並且學會如何來操作

00:09:24.231 --> 00:09:26.200
這有些基礎的方式

00:09:26.567 --> 00:09:29.536
用來創建一個CALayer的外觀

00:09:29.903 --> 00:09:32.673
對此 我們稍後再談

00:09:34.474 --> 00:09:37.878
你應該使用一個置爲底層的視圖

00:09:38.579 --> 00:09:40.347
所以你將會用NSViews

00:09:41.148 --> 00:09:42.616
僅需設置層爲“是”

00:09:43.016 --> 00:09:44.785
接下來我將爲你們演示如何操作

00:09:45.385 --> 00:09:47.554
它將會爲你隱式創建一個層

00:09:48.422 --> 00:09:51.758
意思是你可以通過draw方法
提供層的內容

00:09:52.759 --> 00:09:56.163
但如果你要使用層
我們有兩個更重要的方法

00:09:56.230 --> 00:09:58.365
updateLayer和
wantsUpdateLayer

00:09:58.932 --> 00:10:01.268
接下來我將告訴你這些如何實現

00:10:01.335 --> 00:10:02.836
何時你想使用它們

00:10:04.137 --> 00:10:07.040
我們用核心動畫來做什麼

00:10:07.107 --> 00:10:09.576
該何時用核心動畫
和置爲底層？

00:10:09.776 --> 00:10:13.013
我們建議你將
窗口內容視圖置爲底層

00:10:13.881 --> 00:10:15.983
當你將某特定視圖置爲底層時

00:10:16.049 --> 00:10:19.486
所有子層也將自動變爲底層

00:10:19.753 --> 00:10:23.790
不用你爲每一個子視圖選擇一個層

00:10:25.392 --> 00:10:27.094
我們推薦你將視圖置爲底層

00:10:27.561 --> 00:10:30.898
並且不要直接把CALayer
作爲子層添加

00:10:31.265 --> 00:10:34.034
因爲它自動爲你做事

00:10:34.568 --> 00:10:38.472
例如當在一個層
在視網膜顯示屏上顯示時

00:10:38.772 --> 00:10:41.408
我們將會做更多的設置
來完成這個工作

00:10:44.478 --> 00:10:46.380
打開“置爲底層”非常簡單

00:10:46.880 --> 00:10:50.350
在窗口的內容視圖 可將
wants layer設爲真並編碼

00:10:51.151 --> 00:10:54.021
或者 當然你可以在界面文件夾裏

00:10:54.087 --> 00:10:56.456
勾選CoreAnimationLayer

00:10:56.723 --> 00:10:57.591
在最頂部的視圖上

00:11:00.460 --> 00:11:02.496
所以 一個重要的屬性

00:11:02.796 --> 00:11:07.201
置底層視圖屬性是
layerContentsRedrawPolicy

00:11:07.835 --> 00:11:11.238
你可以設置值爲.onSetNeedsDisplay

00:11:11.805 --> 00:11:14.208
它並不是NSView的默認值

00:11:15.075 --> 00:11:17.978
意思是 作爲一個開發者的你無論何時

00:11:18.045 --> 00:11:21.114
想改變層中的
內容或改變視圖

00:11:21.748 --> 00:11:23.283
你都得調用
SetNeedsDisplay

00:11:24.151 --> 00:11:27.421
這與普通的視圖工作方式在語意上
稍微不同

00:11:27.654 --> 00:11:30.524
當它們移動時它們可能會重新顯示
在那裏

00:11:31.925 --> 00:11:33.026
改變框架的原點

00:11:34.261 --> 00:11:36.463
這是一些你需要明確選擇的

00:11:36.530 --> 00:11:39.266
這尤其可以讓動畫效果更出色

00:11:41.635 --> 00:11:44.037
所以如何使內容放到層呢？

00:11:44.872 --> 00:11:46.240
你的視圖是需要刷新的

00:11:46.373 --> 00:11:47.574
你標記爲
setNeedsDisplay

00:11:48.242 --> 00:11:49.076
並且

00:11:49.409 --> 00:11:52.112
我們問你的視圖 嘿

00:11:52.479 --> 00:11:54.248
你爲wantsUpdateLayer
做了什麼？

00:11:54.314 --> 00:11:56.517
給wantsUpdateLayer
的答案是什麼？

00:11:56.850 --> 00:11:57.851
在這裏出現分支

00:11:57.918 --> 00:12:00.020
若wantsUpdateLayer爲是

00:12:00.187 --> 00:12:02.289
我們會調用
wantsUpdateLayer

00:12:03.257 --> 00:12:05.792
若回答否
我們會調用drawRect

00:12:06.059 --> 00:12:07.427
所以這是一個完整的分支

00:12:07.661 --> 00:12:08.595
必須要二選一

00:12:10.497 --> 00:12:12.232
然後你可能會奇怪

00:12:12.633 --> 00:12:16.136
“好吧 何時該選擇updateLayer
或drawRect呢”

00:12:17.304 --> 00:12:21.375
這回到我給你們演示核心動畫
和NSLayer屬性的位置

00:12:21.942 --> 00:12:25.879
所以如果你可以代表你視圖的表現

00:12:26.246 --> 00:12:28.715
直接通過設置CALayer屬性

00:12:29.116 --> 00:12:31.218
這時你該使用updateLayer

00:12:31.485 --> 00:12:33.053
這將會更高效

00:12:33.353 --> 00:12:35.222
若你可以設置分層內容

00:12:35.489 --> 00:12:37.591
層背景顏色 更傾向於做這些

00:12:38.325 --> 00:12:39.293
如果不可以

00:12:39.359 --> 00:12:43.030
這裏你該重寫draw
或者drawRect

00:12:43.697 --> 00:12:47.734
在子類裏做手動繪製

00:12:48.335 --> 00:12:51.438
每一個實現drawRect的事件

00:12:51.505 --> 00:12:55.442
將有它們自己特有的backing score
你可把其看作圖片

00:12:55.676 --> 00:12:58.345
因此如果這種東西太多

00:12:58.412 --> 00:12:59.680
它將會佔用太多內存

00:13:02.983 --> 00:13:04.685
讓我們快速看一個例子

00:13:04.751 --> 00:13:06.820
用updateLayer
你如何使用它

00:13:07.754 --> 00:13:10.023
首先 你將重寫
wantsUpdateLayer

00:13:10.257 --> 00:13:11.291
你會有一個

00:13:11.625 --> 00:13:14.528
updateLayer回調
通過返回真

00:13:15.295 --> 00:13:17.297
然後將得到一個
updateLayer回調

00:13:17.364 --> 00:13:19.166
你可以設置層屬性

00:13:19.233 --> 00:13:22.302
所以我們得到視圖的屬性
self.layer內容

00:13:22.703 --> 00:13:24.171
還有self.layer
backgroundColor

00:13:24.238 --> 00:13:27.374
或者任何其他的你想設置的東西
這次你可以設置

00:13:31.178 --> 00:13:33.247
我們再談論一下現代視圖

00:13:33.313 --> 00:13:35.849
和如何爲標題欄和工具欄
創建一個現代化的外觀

00:13:36.183 --> 00:13:39.419
來說一下拖放和
來做一些事件跟蹤

00:13:40.888 --> 00:13:42.422
對於現代化的拖放

00:13:43.357 --> 00:13:46.260
你需要採用的是
drag flocking

00:13:46.326 --> 00:13:47.794
像視頻中展示的這樣

00:13:48.262 --> 00:13:50.664
Drag flocking
是每一個獨立的項目

00:13:50.998 --> 00:13:55.002
獨立的移動
但是會聚集在一起或同時散開

00:13:55.702 --> 00:13:57.004
當你將鼠標放開以後

00:13:57.070 --> 00:14:00.207
它們將會散回到初始的位置

00:14:01.708 --> 00:14:05.145
你只需要使用NSView的方法
來用drag flocking

00:14:05.512 --> 00:14:06.747
beginDraggingSession

00:14:07.147 --> 00:14:08.382
當傳遞一個數組

00:14:08.715 --> 00:14:11.818
包含實際你想拖拽的項目

00:14:12.786 --> 00:14:13.854
這十分簡單

00:14:15.822 --> 00:14:18.458
關於更多的複合控制
像一個表視圖

00:14:18.959 --> 00:14:22.429
對集合視圖
我們提供代理方法供你使用

00:14:22.829 --> 00:14:25.966
對於表視圖你應該優先使用代理方法

00:14:26.400 --> 00:14:28.468
tableView pasteboardWriterForRow

00:14:28.969 --> 00:14:32.539
可提供一獨立
NSPasteboard編輯項目

00:14:32.906 --> 00:14:35.209
爲表視圖的每一個被拖動的項目

00:14:35.676 --> 00:14:39.279
與老方法相反
tableView writeRowsWith

00:14:39.646 --> 00:14:40.480
到一粘貼板

00:14:40.714 --> 00:14:43.717
你編輯的所有東西將會在一塊到
粘貼板上

00:14:45.953 --> 00:14:48.021
同樣 集合視圖

00:14:49.356 --> 00:14:51.859
有兩個代理方法和這個非常相似

00:14:51.992 --> 00:14:53.894
對於集合視圖
你該優先使用

00:14:53.961 --> 00:14:57.965
pasteboardWriter ForItemAt版本
而非其它版本

00:15:00.300 --> 00:15:01.702
對於drag flocking

00:15:01.869 --> 00:15:05.606
macOS X 10.12上的新功能是
對drag file promises的支持

00:15:06.106 --> 00:15:09.443
這就是你現在才用
drag flocking的原因

00:15:10.010 --> 00:15:13.881
並且你可以用NSFile PromiseReceiver
和NSFile PromiseProvider

00:15:13.947 --> 00:15:15.983
來讀和寫文件promises

00:15:16.717 --> 00:15:17.718
看下這次的演講

00:15:17.784 --> 00:15:20.821
“Cocoa的新特性”
瞭解更多信息和細節

00:15:23.624 --> 00:15:25.826
讓我們看一下事件跟蹤

00:15:25.926 --> 00:15:27.661
假如你有一個窗口

00:15:28.061 --> 00:15:30.130
並且頂部有一個按鈕

00:15:30.864 --> 00:15:31.932
所以你有這個按鈕

00:15:32.332 --> 00:15:33.600
你想讓它發生的是

00:15:33.901 --> 00:15:36.370
當你點擊這個按鈕時

00:15:36.970 --> 00:15:38.939
從上到下它都像常規按鈕一樣工作

00:15:39.006 --> 00:15:41.375
你將做什麼來表現一個彈出

00:15:42.743 --> 00:15:45.879
但是你也想弄清楚你點擊的按鈕

00:15:46.146 --> 00:15:49.349
並且如果你拖動鼠標拖拽一個窗口

00:15:50.017 --> 00:15:52.019
所以怎樣使這些行爲聚到一塊呢

00:15:52.286 --> 00:15:55.989
在現代系統上新特性中
以恰當現代的方法？

00:15:57.724 --> 00:15:59.493
好吧 讓我們討論一下
事件追蹤

00:15:59.560 --> 00:16:01.261
和如何追蹤事件來做到這個

00:16:02.062 --> 00:16:04.998
這個窗口有個方法
跟蹤事件匹配掩碼

00:16:05.065 --> 00:16:06.633
用一個超時模式處理器

00:16:07.167 --> 00:16:09.102
並且這個處理器是一個塊回調

00:16:10.070 --> 00:16:12.806
我們更希望你用這個方法
而不是用老方法

00:16:12.873 --> 00:16:13.874
在NSApplication

00:16:14.641 --> 00:16:16.944
它是nextEvent
matchingMask

00:16:17.578 --> 00:16:19.913
用過去的方法你創建自己的循環

00:16:20.380 --> 00:16:23.650
在新的方法中你僅需使用一個塊
回調就可以完成工作了

00:16:26.220 --> 00:16:29.022
看下這塊回調
比如在那個按鈕中

00:16:29.223 --> 00:16:31.525
我們將mouseDown
分成子類並重寫

00:16:33.393 --> 00:16:35.829
首先我們應在mouseDown做的

00:16:35.963 --> 00:16:38.031
是調用窗口跟蹤事件

00:16:38.265 --> 00:16:41.902
我們想爲drag和
leftMouseUp追蹤所有事件

00:16:44.271 --> 00:16:46.740
如果用戶點擊 然後後退

00:16:47.174 --> 00:16:49.610
我們需要停止

00:16:49.877 --> 00:16:51.078
我們會說

00:16:51.311 --> 00:16:53.180
我們需要調用super

00:16:53.380 --> 00:16:56.183
因爲通過那方式 每件事都會像
NSButton一樣正常工作

00:16:56.917 --> 00:16:58.218
但這有額外的部分

00:16:58.519 --> 00:17:00.554
比如 你點擊並拖拽

00:17:00.888 --> 00:17:02.823
並且如果在按鈕裏點擊和拖拽

00:17:03.156 --> 00:17:05.259
我們會判斷你是否拖拽得足夠遠

00:17:05.492 --> 00:17:06.560
如果拖拽得足夠遠

00:17:07.261 --> 00:17:10.830
將不再只作爲一個窗口而是去
完成一個performDrag

00:17:12.366 --> 00:17:13.967
意思是

00:17:14.268 --> 00:17:17.069
當你傳遞窗口
performDrag時

00:17:17.471 --> 00:17:21.040
窗口和系統將會在那一點
接替這個拖拽窗口

00:17:21.974 --> 00:17:24.211
不能拖拽和移動窗口

00:17:24.278 --> 00:17:26.547
通過在窗口一次次
調用set frame

00:17:27.681 --> 00:17:29.016
如果你傳遞給系統

00:17:29.349 --> 00:17:30.684
一旦你傳遞

00:17:30.951 --> 00:17:32.219
如果你的應用卡住了

00:17:32.719 --> 00:17:33.554
然後

00:17:33.620 --> 00:17:35.956
這個窗口將繼續可被移動

00:17:36.523 --> 00:17:38.225
即使應用正在運行

00:17:38.892 --> 00:17:40.894
除此之外 其它系統特性將運行

00:17:41.428 --> 00:17:42.963
像空間切換

00:17:43.297 --> 00:17:46.200
當你移動到窗口頂端
空白欄將會向下移動

00:17:46.500 --> 00:17:48.135
窗口捕捉 窗口對齊

00:17:48.702 --> 00:17:50.304
任何其它新加入的系統特性

00:17:50.370 --> 00:17:53.974
在窗口的移動下會自動工作
不需要你做任何事

00:17:54.374 --> 00:17:55.943
所以我們希望你向下傳給系統

00:17:56.510 --> 00:17:58.512
通過調用performDrag

00:18:01.715 --> 00:18:04.751
剛纔討論了拖拽和事件處理

00:18:04.818 --> 00:18:07.187
讓我們談論一下
容器試圖控制

00:18:07.588 --> 00:18:09.056
和如何適當的使用這些

00:18:10.057 --> 00:18:11.959
容器視圖控制
我們應該使用

00:18:12.025 --> 00:18:13.760
基於表視圖的視圖

00:18:14.061 --> 00:18:17.197
你通過使用代理方法tableView
viewFor: row: 來做這些

00:18:17.598 --> 00:18:21.001
或者你可以在Interface
Builder裏設置一些東西

00:18:21.535 --> 00:18:23.270
直接通過Interface
Builder本身

00:18:25.405 --> 00:18:28.175
這樣做的原因是你可以像視頻中
我們看到的那樣

00:18:28.275 --> 00:18:30.344
新特性 例如滑動刪除

00:18:30.577 --> 00:18:32.779
這僅僅存在於基於表視圖的視圖裏

00:18:34.348 --> 00:18:36.183
通過滑動來刪除非常簡單的

00:18:36.583 --> 00:18:37.918
這有一個表視圖方法

00:18:38.418 --> 00:18:39.520
rowActionsForRow

00:18:40.020 --> 00:18:40.988
在一個特殊的邊緣

00:18:41.054 --> 00:18:43.824
在左邊或右邊的邊緣 抱歉
應該是在頂部和底部的邊緣

00:18:44.758 --> 00:18:48.495
並且你可以返回一個數組一個或多個
或沒有或更多行的操作

00:18:49.062 --> 00:18:51.231
在NSTableView的行操作中

00:18:52.032 --> 00:18:56.637
允許你給按鈕的標題創造一個字符串值

00:18:57.237 --> 00:18:59.606
和一個處理方法

00:19:00.073 --> 00:19:02.342
當用戶點擊時才觸發的代碼

00:19:02.476 --> 00:19:04.411
或者滑動屏幕足夠遠才觸發的代碼

00:19:07.714 --> 00:19:11.585
接着我們談論下滾動視圖
和它的複合控制

00:19:11.985 --> 00:19:14.454
到目前爲止我們談論的技術

00:19:15.055 --> 00:19:18.759
例如滾動視圖...
比如我們獲取窗口

00:19:19.259 --> 00:19:22.930
和設置窗口
標題欄顯示透明

00:19:23.263 --> 00:19:25.332
它使標題欄看上去透明

00:19:25.432 --> 00:19:27.701
如Messages這類應用
充分利用該特性

00:19:28.435 --> 00:19:30.304
允許內容在下部顯示

00:19:30.370 --> 00:19:32.306
我們來看一下發生了什麼

00:19:32.372 --> 00:19:37.477
在一邊的滾動視圖顯示

00:19:37.544 --> 00:19:40.914
在標題欄/工具欄下部區域的內容
並會自動將其變模糊

00:19:41.348 --> 00:19:42.816
但是這呈現出兩難處境

00:19:43.550 --> 00:19:46.887
如何使滾動視圖被自動插入

00:19:47.287 --> 00:19:49.590
以致你不需要添加一個空行

00:19:49.656 --> 00:19:50.924
或其他什麼奇怪東西？

00:19:52.292 --> 00:19:54.194
做這些十分方便和簡單

00:19:54.261 --> 00:19:55.662
滾動視圖有個方法

00:19:55.896 --> 00:19:57.965
或屬性
叫contentInsets

00:19:58.365 --> 00:20:01.168
允許你將內容稍微向下移動一點

00:20:01.969 --> 00:20:03.737
實際上 我們讓它自動實現

00:20:04.071 --> 00:20:06.707
我們有個屬性
automaticallyAdjust ContentInsets

00:20:07.241 --> 00:20:08.642
如果你設置它爲真

00:20:08.876 --> 00:20:11.411
然後我們
讓滾動視圖使用KVO

00:20:11.478 --> 00:20:14.381
之前說的跟蹤
contentLayoutRect

00:20:14.848 --> 00:20:16.750
自動設置
內容插圖

00:20:16.950 --> 00:20:18.552
爲一個合適的值

00:20:20.554 --> 00:20:24.224
但作爲開發者 你可能想更自由控制
內容插圖

00:20:24.691 --> 00:20:26.560
你可能想讓它更向下

00:20:26.827 --> 00:20:28.462
來添加一切其他的幫助控件

00:20:28.529 --> 00:20:30.731
比如一個搜索區域或者其它東西

00:20:31.632 --> 00:20:34.134
在我們的系統中的一個例子是

00:20:34.401 --> 00:20:37.671
Mail向下了一點
添加了排序指示器

00:20:38.772 --> 00:20:41.909
這就是我們在系統應用中的使用方式

00:20:43.977 --> 00:20:45.979
下面說說自動佈局

00:20:46.813 --> 00:20:48.248
你應該使用自動佈局

00:20:48.582 --> 00:20:50.551
你也應該使用
base localization

00:20:51.385 --> 00:20:54.288
你所有的nymphs都
該在base.lproj中

00:20:54.354 --> 00:20:58.325
除了使用多個不同文件夾和本地化副本

00:20:58.959 --> 00:21:00.994
你不應該使用固定寫法

00:21:01.395 --> 00:21:05.032
你想用控制去得到內在的內容大小

00:21:05.532 --> 00:21:06.867
而不是寫死大小

00:21:07.601 --> 00:21:08.902
優先使用堆視圖

00:21:09.303 --> 00:21:12.306
使用leading和
trailing屬性 這些都正確

00:21:12.372 --> 00:21:14.441
對於創建一個合理的本地化應用

00:21:15.709 --> 00:21:18.579
我們看一下IB中的本地化選項

00:21:19.313 --> 00:21:22.716
尤其文本方向、
佈局和鏡像部分

00:21:23.784 --> 00:21:26.286
文本方向有三個值

00:21:26.687 --> 00:21:29.389
自然的 從左到右 從右到左

00:21:30.057 --> 00:21:31.425
自然的意思是

00:21:31.959 --> 00:21:34.862
實際的控制器將根據字符串值

00:21:34.928 --> 00:21:38.131
你給你這個控制器設置的 如文本域
根據字符串值

00:21:38.732 --> 00:21:41.435
如果字符串是從右向左的

00:21:42.236 --> 00:21:45.205
我們將實際把方向設置爲從右向左

00:21:45.639 --> 00:21:48.175
如果是從左到右的字符串
我們將設置爲從左到右

00:21:49.276 --> 00:21:52.880
或者你可以手動設置爲
從左到右或者從右到左

00:21:54.147 --> 00:21:57.150
下一個屬性是
userInterface LayoutDirection

00:21:58.085 --> 00:21:59.453
對於佈局非常重要

00:22:00.354 --> 00:22:02.422
它可以從左到右或者從右到左

00:22:03.757 --> 00:22:06.326
系統控制如表視圖要參考這個屬性

00:22:06.393 --> 00:22:09.263
還可能做自動反轉表的列之類的事

00:22:09.329 --> 00:22:10.664
當設置爲從右向左時

00:22:11.865 --> 00:22:13.867
默認值根據應用值來定

00:22:14.902 --> 00:22:18.138
有趣的是鏡像屬性

00:22:18.205 --> 00:22:19.673
因爲它有點迷惑

00:22:19.973 --> 00:22:21.975
若一個鏡像被設爲自動

00:22:22.276 --> 00:22:24.244
然後userInterface
LayoutDirection

00:22:24.311 --> 00:22:25.979
剛纔我們看的最後一個屬性

00:22:26.513 --> 00:22:29.183
會自動由從左到右變爲從右到左

00:22:29.650 --> 00:22:31.518
當它是從右到左的本地化

00:22:32.219 --> 00:22:33.053
反之亦然

00:22:34.855 --> 00:22:37.457
它還會反轉自動其他屬性

00:22:37.591 --> 00:22:39.793
像按鈕單元圖像的位置

00:22:40.093 --> 00:22:42.829
按鈕的圖像在左面 我們會反轉它

00:22:42.896 --> 00:22:44.898
會自動放到右面

00:22:45.999 --> 00:22:49.136
我們不會反轉的一個屬性是文本對齊

00:22:49.469 --> 00:22:51.471
若你設爲居中
兩端對齊或自然

00:22:51.538 --> 00:22:54.541
反轉它們沒有意義所以我們不會反轉

00:22:55.375 --> 00:22:57.211
你可能會想

00:22:57.277 --> 00:22:59.880
“我什麼時候不需要設置鏡像？”

00:23:00.013 --> 00:23:03.050
你可能想設置鏡像爲否

00:23:03.116 --> 00:23:06.353
在你想要一個控制器
有一個非常實際的代表

00:23:06.420 --> 00:23:09.356
像一個播放按鈕 快進按鈕或快退按鈕

00:23:11.225 --> 00:23:12.059
然後

00:23:12.392 --> 00:23:15.996
這些是關於Interface Builder的
那麼在代碼裏你該怎麼做？

00:23:16.430 --> 00:23:19.533
在代碼裏你必須參考控制器值

00:23:19.600 --> 00:23:22.936
關於userInterfaceLayoutDirection
如果它設置爲從左向右

00:23:23.237 --> 00:23:25.038
你必須說“嘿 按鈕

00:23:25.205 --> 00:23:29.276
我想讓圖片在左面
當從左到右本地化時

00:23:29.476 --> 00:23:32.846
我想設置圖像在右面
當從右向左本地化”

00:23:32.913 --> 00:23:34.615
你必須手動完成設置它

00:23:36.517 --> 00:23:38.652
在10.12中 這個更容易了些

00:23:39.086 --> 00:23:41.021
我們給按鈕添加了一個快捷方法

00:23:41.088 --> 00:23:44.291
一個初始化方法可以傳入一個字符串

00:23:44.358 --> 00:23:46.860
一個圖片 一個目標和一個動作

00:23:46.927 --> 00:23:49.530
還有自動反轉

00:23:52.432 --> 00:23:54.968
這是我講的第一部分

00:23:55.035 --> 00:23:56.870
下面讓Jeff講講外觀

00:23:56.937 --> 00:23:59.039
storyboards和
其他一些Mac特性

00:23:59.106 --> 00:23:59.940
謝謝大家

00:24:05.279 --> 00:24:06.480
好的 謝謝 Corbin

00:24:06.780 --> 00:24:09.183
在這個課程我們有大量的內容去講

00:24:09.249 --> 00:24:11.618
所以現在我說說系統外觀

00:24:12.986 --> 00:24:13.987
這裏是我們的應用

00:24:14.421 --> 00:24:16.256
我們剛纔已經看了一會兒

00:24:16.323 --> 00:24:19.560
我們想提升下我們的UI

00:24:20.227 --> 00:24:23.797
我們已經決定採用這個花哨的黑色外觀

00:24:25.065 --> 00:24:27.401
這通常是高級應用的外觀

00:24:27.734 --> 00:24:30.737
我們要對我們這個小演示程序有點野心

00:24:32.172 --> 00:24:34.374
但看看這個
這個看起來確實很複雜

00:24:34.441 --> 00:24:37.811
我們有一個完全不同的系統
Window Chrome

00:24:38.178 --> 00:24:42.549
我們要所有控制器artwork改變
片段控制器 按鈕 滑塊

00:24:43.116 --> 00:24:44.885
所有的文本標籤

00:24:45.185 --> 00:24:47.921
需要從黑色字體變爲淺色字體

00:24:49.089 --> 00:24:50.591
看起來有很多工作

00:24:50.657 --> 00:24:54.294
但實際上餓哦們可以用一行代碼實現
通過使用NSAppearance

00:24:55.095 --> 00:24:58.098
我們需要做的是創建一個系統外觀

00:24:58.165 --> 00:24:59.099
賦值給窗口

00:24:59.166 --> 00:25:01.568
會自動的應用所有的工作

00:25:01.969 --> 00:25:05.472
你可以認爲外觀是一種顏色調節盤

00:25:05.839 --> 00:25:07.074
我們用來解決

00:25:07.140 --> 00:25:09.977
繪製所有的標準系統控制器

00:25:10.043 --> 00:25:12.179
還包括所有我們命名的顏色

00:25:12.246 --> 00:25:14.748
像標籤顏色 控制器顏色

00:25:15.382 --> 00:25:19.086
由於這個原因
適時使用這些顏色很重要

00:25:19.152 --> 00:25:22.289
不僅更適合整個系統主題

00:25:22.656 --> 00:25:25.259
同時 如果以後主題變了
仍然適合

00:25:25.325 --> 00:25:27.394
或者以後你改變了你的外觀

00:25:28.428 --> 00:25:29.630
我們仔細的看看

00:25:30.097 --> 00:25:30.964
這裏有個面板

00:25:31.031 --> 00:25:33.667
有許多很棒的標籤
控制器等等在上面

00:25:34.635 --> 00:25:36.870
我們只需應用暗色外觀

00:25:36.937 --> 00:25:38.605
我們看到了相當戲劇性的變化

00:25:38.972 --> 00:25:40.507
控制器artwork變了

00:25:40.574 --> 00:25:43.477
當然其他所有的標籤由深色到淺色轉變

00:25:44.478 --> 00:25:46.213
我們可以再進一步

00:25:46.280 --> 00:25:48.348
應用這些很酷的活力效果

00:25:48.982 --> 00:25:50.450
你剛可能已注意到一個幻燈片

00:25:50.517 --> 00:25:53.053
那個我們應用過的外觀叫做活力黑

00:25:53.120 --> 00:25:55.422
不是說你有義務使用“活力”

00:25:55.489 --> 00:25:58.692
而是說artwork在充滿活力的
上下文中看起來很棒

00:25:59.126 --> 00:26:00.994
想要這種外觀 你只需要

00:26:01.195 --> 00:26:04.798
添加你所有控制器
作爲NSVisualEffectView的子視圖

00:26:05.299 --> 00:26:07.467
你會自動獲得這個
很棒的窗口後模糊

00:26:07.534 --> 00:26:10.237
還有在這上面所有的
很酷的渲染效果

00:26:11.471 --> 00:26:13.574
現在 你可能認爲這很棒

00:26:13.674 --> 00:26:16.210
但我的設計師有很酷的

00:26:16.276 --> 00:26:18.679
特定顏色針對我們的文本標籤

00:26:19.012 --> 00:26:20.714
所以我不會使用標籤顏色

00:26:21.248 --> 00:26:24.818
我也不會把其從暗變淺或者反過來

00:26:24.885 --> 00:26:26.119
我很好 是的 我很安全

00:26:27.154 --> 00:26:29.056
我們加點東西

00:26:30.123 --> 00:26:33.594
我們檢查下
可訪性面板

00:26:33.660 --> 00:26:36.597
我們會打開中間叫做
增加對比度的設置

00:26:36.663 --> 00:26:38.565
看看會對UI帶來什麼影響

00:26:39.733 --> 00:26:42.069
在左面我們有標準的面板

00:26:42.636 --> 00:26:43.637
但是右面我們有

00:26:44.071 --> 00:26:46.139
增加對比度開啓的面板

00:26:46.740 --> 00:26:49.309
雖然我們沒有反轉所有顏色

00:26:49.376 --> 00:26:51.512
這個轉換很像

00:26:51.879 --> 00:26:53.780
有淺變深的轉換

00:26:54.281 --> 00:26:57.150
你可以看到窗口背景色變淺了

00:26:57.317 --> 00:26:58.986
在每一個層級文本都變暗了

00:26:59.286 --> 00:27:01.788
我們的控制器有很棒的加粗輪廓

00:27:02.356 --> 00:27:04.424
讓它和背景區分更明顯 更立體

00:27:04.958 --> 00:27:07.227
現在 當你用一個寫死的顏色值

00:27:07.628 --> 00:27:10.964
我們就不能猜測
我們不能像這樣調整設置

00:27:11.498 --> 00:27:12.332
所以

00:27:13.133 --> 00:27:16.003
如果你沒有像標籤顏色

00:27:16.069 --> 00:27:18.772
第二選擇標籤顏色
你可能在幫倒忙

00:27:18.839 --> 00:27:22.543
對想要在他們Mac上設置
像增加對比度的用戶

00:27:24.144 --> 00:27:27.347
現在說我剛暗示的視覺效果和活力

00:27:27.814 --> 00:27:30.417
我們現在不會深入那個API

00:27:30.484 --> 00:27:32.819
但是你可以參考我們2014年的演講

00:27:33.120 --> 00:27:36.390
“採用OS X Yosemite
新UI的高級特性”

00:27:37.558 --> 00:27:38.659
那是外觀

00:27:38.725 --> 00:27:40.827
是設置你應用主題的簡單方式

00:27:41.128 --> 00:27:44.464
同時能和整個運作系統的外觀保持和諧

00:27:45.465 --> 00:27:46.500
下一個話題storyboards

00:27:48.268 --> 00:27:50.871
Storyboards
是一種可以讓你設計

00:27:50.971 --> 00:27:52.639
不僅是單個組件的技術

00:27:52.706 --> 00:27:54.975
和構成你應用的其他視圖

00:27:55.042 --> 00:27:58.278
並且在視覺上設計這些組件間的關係

00:27:59.146 --> 00:28:00.781
在這個例子中 當我說部件時

00:28:00.848 --> 00:28:02.683
storyboards操作的控制器

00:28:02.749 --> 00:28:05.285
是我們的窗口控制器和視圖控制器

00:28:05.586 --> 00:28:07.921
我們用這些segues把它們連起來

00:28:07.988 --> 00:28:10.057
在我的截圖上的那些箭頭

00:28:10.524 --> 00:28:12.993
segues抽象所有的膠水代碼

00:28:13.493 --> 00:28:15.229
讓這些部件放在一起

00:28:15.295 --> 00:28:18.031
就像添加子視圖 添加約束

00:28:18.398 --> 00:28:20.901
創建彈出框一樣方便

00:28:24.571 --> 00:28:25.405
現在

00:28:25.873 --> 00:28:29.510
一個我們需要考慮的
關於storyboards的是

00:28:30.143 --> 00:28:31.979
當我們有可分離的組件時
如這些

00:28:32.045 --> 00:28:35.115
我有一個拆分視圖
storyboard創建的

00:28:35.182 --> 00:28:37.384
所有這些小組件做它們自己的事

00:28:38.352 --> 00:28:42.022
每一部分UI都有些數據需要用

00:28:42.256 --> 00:28:43.490
或者修改

00:28:43.824 --> 00:28:48.529
我們不能僅從一個到另一個場景
拖拽outlets或actions

00:28:48.595 --> 00:28:49.863
當然 如果我們這麼做了

00:28:50.130 --> 00:28:51.765
它們就不是可分離的組件了

00:28:51.832 --> 00:28:54.635
然後我們就破壞這件事的本來目的

00:28:56.136 --> 00:28:57.671
有時 我們用的數據

00:28:57.738 --> 00:29:00.307
不是呈錐形存在於場景中

00:29:00.374 --> 00:29:02.176
在下面的葉子節點

00:29:02.376 --> 00:29:05.445
有時它可能存在在窗口或者文檔中

00:29:05.779 --> 00:29:07.247
所以我們如何傳遞數據

00:29:07.481 --> 00:29:10.584
從上直到葉子節點？

00:29:12.319 --> 00:29:14.054
好的 我們有幾個經驗法則

00:29:14.288 --> 00:29:15.489
不是硬性的規則

00:29:15.856 --> 00:29:19.159
僅是幾個主意
我們認爲對處理這個有幫助

00:29:20.260 --> 00:29:21.094
第一個

00:29:21.395 --> 00:29:23.830
依賴應該大體級聯向下

00:29:24.231 --> 00:29:25.332
如果你想

00:29:25.399 --> 00:29:27.134
如果你需要某些法則

00:29:27.201 --> 00:29:29.469
在segues中跟隨箭頭

00:29:30.470 --> 00:29:31.805
如果沒有其它
這讓你

00:29:31.872 --> 00:29:34.641
在應用中有很好的單向信息流

00:29:34.875 --> 00:29:36.877
這讓人很容易理解

00:29:38.312 --> 00:29:41.515
另一個是儘量減少UI結構的假設

00:29:41.582 --> 00:29:43.917
你寫死到代碼裏的

00:29:44.751 --> 00:29:47.955
你設計完UI和storyboard

00:29:48.589 --> 00:29:49.957
若你在代碼裏寫死了一些假設

00:29:50.023 --> 00:29:52.426
關於結構是如何放到一起的

00:29:52.559 --> 00:29:54.895
當你想要改變storyboard時

00:29:54.962 --> 00:29:55.863
你得來來回回

00:29:55.929 --> 00:29:57.531
修改代碼和storyboard

00:29:57.598 --> 00:29:59.266
現在你和自己過不去

00:29:59.333 --> 00:30:00.234
我們不要那麼做

00:30:00.400 --> 00:30:02.469
讓我們把代碼集中在數據上

00:30:02.936 --> 00:30:05.639
集中在設計界面和Interface Builder上

00:30:06.507 --> 00:30:08.909
一個我們可以用來解決該問題的技巧是

00:30:09.109 --> 00:30:12.913
使用符合協議貫穿UI

00:30:14.414 --> 00:30:15.415
這裏有個例子

00:30:15.716 --> 00:30:18.619
假設有一個屬性
在窗口控制器上

00:30:18.685 --> 00:30:20.954
我們想自動提供那個屬性

00:30:21.121 --> 00:30:23.557
給我們視圖階梯中理解它的任何東西

00:30:24.024 --> 00:30:24.858
在didSet中

00:30:25.425 --> 00:30:27.528
我們會調用propagate方法

00:30:27.995 --> 00:30:29.930
我們得到了在屏幕外
定義的協議

00:30:29.997 --> 00:30:31.698
叫作photoControllerConsumer

00:30:32.266 --> 00:30:35.335
這代表我知道如何使用
photoController

00:30:36.603 --> 00:30:39.006
且若我們看看
childViewController

00:30:39.072 --> 00:30:41.942
會發現它遵守了
我們可以設置屬性的協議

00:30:42.442 --> 00:30:46.513
同時我們自動遞歸傳遞給其所有子項

00:30:49.616 --> 00:30:50.651
但是像

00:30:51.685 --> 00:30:54.621
彈出或者表單展示

00:30:54.688 --> 00:30:56.156
這些必須嗎？

00:30:56.657 --> 00:30:59.726
當你設置這樣的屬性的時候
這些可能不存在

00:31:00.160 --> 00:31:02.563
我們根據需要來給
他們提供數據

00:31:03.130 --> 00:31:04.498
在他們出現在屏幕之前

00:31:05.132 --> 00:31:07.768
即prepare for
segue方法的作用

00:31:08.435 --> 00:31:11.738
它會在展示視圖控制器或
窗口控制器的時候被調用

00:31:11.805 --> 00:31:13.674
當展示發生時

00:31:14.174 --> 00:31:15.008
在這個例子中

00:31:15.409 --> 00:31:19.413
除了做像檢查或者segue標識符

00:31:19.479 --> 00:31:22.816
強制轉換成我們希望的控制器類

00:31:22.883 --> 00:31:24.785
然後做些特定的設置

00:31:25.052 --> 00:31:26.954
這裏我們做相同的事情

00:31:27.387 --> 00:31:29.556
我們檢查什麼協議被遵守

00:31:29.723 --> 00:31:31.792
然後設置合適的屬性

00:31:32.159 --> 00:31:33.694
此舉是

00:31:33.760 --> 00:31:36.096
它改變我們的邏輯從嚴格聚焦

00:31:36.163 --> 00:31:39.466
身份變爲能力

00:31:39.533 --> 00:31:41.134
我們說我有這方面的知識

00:31:41.301 --> 00:31:43.003
任何展現給我的

00:31:43.070 --> 00:31:45.405
可以潛在自動獲得那個知識

00:31:45.472 --> 00:31:46.974
通過一個一致的協議

00:31:47.040 --> 00:31:47.975
這真的很方便

00:31:49.610 --> 00:31:50.577
再講講“動作”

00:31:51.311 --> 00:31:52.513
那很常見

00:31:52.913 --> 00:31:56.083
UI中觸發的處理動作的最佳對象

00:31:56.350 --> 00:31:58.285
實際上並沒有在同一個場景

00:31:58.785 --> 00:32:00.654
那個控制器定義的地方

00:32:01.154 --> 00:32:04.458
這被它們自己的小場景中
菜單單元證明瞭

00:32:05.158 --> 00:32:06.894
完全從你的UI斷開

00:32:07.895 --> 00:32:08.729
同時

00:32:08.862 --> 00:32:11.732
幸運的是我們有一個很棒的機制
來處理這種情況

00:32:11.798 --> 00:32:13.300
就是事件響應鏈

00:32:13.667 --> 00:32:15.569
如果你來自iOS平臺

00:32:15.636 --> 00:32:18.906
你可能不會使用太多的事件響應鏈

00:32:18.972 --> 00:32:21.008
就是那個小的橘黃色立方體

00:32:21.074 --> 00:32:23.177
在每個storyboard場景上面

00:32:23.243 --> 00:32:25.012
它是第一個相應者的代理

00:32:25.612 --> 00:32:29.616
如果你關聯了一個
控制器的動作到代理上

00:32:29.850 --> 00:32:32.186
它會自動的發送給響應鏈

00:32:32.252 --> 00:32:33.520
當控制器被觸發

00:32:34.788 --> 00:32:37.624
如果在響應鏈中沒有對象處理方法
怎麼辦？

00:32:38.325 --> 00:32:40.694
或者在放大的情況下

00:32:41.061 --> 00:32:43.230
發送動作不總是很恰當怎麼辦？

00:32:43.697 --> 00:32:46.066
例如
我們在最大化縮放層級

00:32:46.133 --> 00:32:49.002
我們不想讓放大按鈕不起作用

00:32:49.369 --> 00:32:51.972
在我們動作之前我們可以看到

00:32:52.639 --> 00:32:54.274
這就是UI驗證的作用

00:32:56.210 --> 00:33:00.047
我們看看一段代碼
會自己審查驗證UI

00:33:00.147 --> 00:33:02.149
來判斷一個控制器是否是可操作的

00:33:02.916 --> 00:33:05.352
第一步我們需要做的是
請求NSApp

00:33:05.419 --> 00:33:08.522
獲得一個控制器的目標動作

00:33:09.389 --> 00:33:12.059
這會自動遍歷響應鏈

00:33:12.125 --> 00:33:14.962
尋找實現那個動作的某個對象

00:33:15.295 --> 00:33:18.665
或者可能沒有發現任何動作
甚至沒有發現任何對象

00:33:20.834 --> 00:33:23.237
我們想要看的第一個例子的結果

00:33:23.303 --> 00:33:27.374
是實現NSUserInterface
驗證協議的任何對象

00:33:27.875 --> 00:33:30.277
這意味着你可以主動請求

00:33:30.344 --> 00:33:31.478
一個控制器是否有效

00:33:31.979 --> 00:33:33.847
如果你在等式的另一邊

00:33:33.914 --> 00:33:37.184
並且你有一個控制器某些條件下有效

00:33:37.251 --> 00:33:38.752
你可以實現這個方法

00:33:38.952 --> 00:33:41.288
像NSMenuItem控制器
和工具條單元

00:33:41.355 --> 00:33:43.724
會自動驗證那個方法

00:33:43.824 --> 00:33:45.392
所以我們可以請求那個方法

00:33:46.026 --> 00:33:48.595
然後 當然 有些情況下
某個對象

00:33:48.662 --> 00:33:50.831
無條件處理了那個方法

00:33:50.998 --> 00:33:54.935
或者一個對象也沒有
意味着我們沒有準備好處理那個動作

00:33:56.570 --> 00:33:58.639
這是些專門應對
storyboards的技巧

00:33:59.273 --> 00:34:01.041
現在我們已經討論了很多關於

00:34:01.341 --> 00:34:05.812
創建應用程序設計時間方面的事情

00:34:06.046 --> 00:34:07.848
我們看看一些面向用戶的特性

00:34:07.915 --> 00:34:10.449
可以幫助你充分利用我們的平臺

00:34:11.217 --> 00:34:13.587
首先是用戶活動

00:34:14.955 --> 00:34:16.889
NSUserActivity
是這個對象

00:34:17.123 --> 00:34:20.594
描述了你的應用現正在做什麼

00:34:20.928 --> 00:34:22.728
在看什麼 在編輯什麼

00:34:23.130 --> 00:34:23.964
等等

00:34:24.565 --> 00:34:25.399
並且

00:34:25.465 --> 00:34:29.436
Handoff使用這個對象使
這些活動在各設備間移動

00:34:29.503 --> 00:34:32.239
有點類似把你的整個上下文
在它們之間移動

00:34:34.608 --> 00:34:37.610
我沒時間來深入看整個的API

00:34:37.678 --> 00:34:40.480
我想說這個對象確實比較簡單

00:34:41.348 --> 00:34:43.150
你可用activityType
構造它

00:34:43.250 --> 00:34:46.753
它是描述你正做的
活動的唯一標識符

00:34:46.853 --> 00:34:49.790
同時也有一個密鑰需要
放到info plist中

00:34:49.857 --> 00:34:53.393
聲明我是個好應用
在其他設備上選擇該活動

00:34:54.561 --> 00:34:57.397
然後你填充一些基本的配置信息

00:34:57.464 --> 00:34:58.999
來描述你的活動

00:34:59.633 --> 00:35:02.636
一個好的面向用戶的標題
或者一些用戶信息

00:35:03.504 --> 00:35:07.007
基本上只是基本的必需數據

00:35:07.174 --> 00:35:09.643
稍後跳回到那個任務

00:35:10.244 --> 00:35:13.647
我們想讓這個字典一直保持較小
因爲它需要頻繁無線傳送

00:35:13.714 --> 00:35:16.316
我們也想讓handoff交互快一點

00:35:17.885 --> 00:35:19.753
我們也需要在代理中

00:35:20.087 --> 00:35:23.657
添加關於上下文的絕對最新信息

00:35:23.891 --> 00:35:27.127
在我們執行handoff之前
或前一刻

00:35:27.694 --> 00:35:29.630
它會被調用

00:35:29.696 --> 00:35:31.532
在你標記一個活動來保存後

00:35:31.598 --> 00:35:34.701
我們替你調用這個方法
這樣你可以填上最新數據

00:35:37.471 --> 00:35:40.274
我們如何確定哪個活動
是當前活動？

00:35:40.340 --> 00:35:42.709
因爲 當然 我們當然需要決定

00:35:42.776 --> 00:35:44.545
現在我們在看什麼

00:35:45.078 --> 00:35:47.548
你可通過becomeCurrent
手動管理

00:35:47.614 --> 00:35:49.950
和NSUserActivity上的
resignCurrent方法

00:35:50.551 --> 00:35:53.220
就是說你可能需要跟蹤你的用戶

00:35:53.287 --> 00:35:56.256
在你的應用上
搞清楚他們點擊了什麼

00:35:56.323 --> 00:35:58.125
並嘗試搞清楚他們在做什麼

00:35:58.325 --> 00:35:59.826
AppKit讓這些變更簡單

00:36:00.661 --> 00:36:02.729
通過讓你附上活動

00:36:02.796 --> 00:36:05.032
到響應鏈可以自動管理

00:36:06.466 --> 00:36:07.367
比如

00:36:07.434 --> 00:36:11.171
假如我們創建了一個日曆應用
看起來就像我們的日曆應用

00:36:11.805 --> 00:36:15.342
我們有兩個活動
想要放到響應鏈

00:36:15.776 --> 00:36:19.479
我們有該視圖更高級
的活動

00:36:19.546 --> 00:36:21.448
這整個
這裏的這個日視圖

00:36:21.515 --> 00:36:24.818
然後我們有一個更具體的
活動對這個具體的事件

00:36:24.952 --> 00:36:27.754
我們在這裏看到

00:36:29.256 --> 00:36:31.258
通過添加這個到響應鏈

00:36:31.325 --> 00:36:33.861
當我們點擊的那個事件
讓它成爲第一個響應者

00:36:34.127 --> 00:36:36.029
那個活動變成了最近的一個

00:36:36.196 --> 00:36:38.665
在響應鏈中通過第一響應者

00:36:38.966 --> 00:36:40.701
它自動變成了當前的

00:36:42.135 --> 00:36:42.970
現在

00:36:43.537 --> 00:36:47.708
你之前可能沒考慮使用Handoff
或NSUserActivity API

00:36:48.008 --> 00:36:50.177
你可能沒有iOS配套應用

00:36:50.244 --> 00:36:53.514
或者你不認爲
Handoff特別引人注目

00:36:53.714 --> 00:36:55.782
對你的應用和你的特定的需求

00:36:56.216 --> 00:36:58.652
但活動不僅
Handoff使用

00:36:59.353 --> 00:37:01.288
Sierra新特性中
我們在Mac上引入了Siri

00:37:01.655 --> 00:37:05.325
Siri使用當前活動
提供上下文命令

00:37:06.093 --> 00:37:09.429
例如 若你說
在某個日期提醒我這事

00:37:10.197 --> 00:37:12.733
Siri會推斷這個
是指當前活動

00:37:13.033 --> 00:37:15.536
其實它甚至會用
這個活動並把它嵌入

00:37:15.769 --> 00:37:18.705
到你的提醒裏
然後你可以在未來找到它

00:37:19.206 --> 00:37:21.408
所以我們認爲
活動是一種通用機制

00:37:21.475 --> 00:37:24.478
爲了描述這一類信息
不僅僅是爲了Handoff

00:37:26.079 --> 00:37:28.081
現在
關於Handoff API的信息

00:37:28.148 --> 00:37:30.217
我推薦大家看看2014的講座

00:37:30.484 --> 00:37:32.586
“在OS X與iOS中
採用Handoff”

00:37:33.820 --> 00:37:35.856
它涉及到許多高級話題

00:37:35.923 --> 00:37:39.560
像持續流可以讓你在設備間
傳遞更多數據

00:37:42.696 --> 00:37:44.231
下一個特性 恢復

00:37:44.531 --> 00:37:46.500
我們有時叫狀態恢復

00:37:46.934 --> 00:37:50.070
它是Mac最棒的特性之一
當你退出一個應用

00:37:50.137 --> 00:37:53.407
然後重新啓動它
它會回到你離開它時候的樣子

00:37:54.041 --> 00:37:55.342
實際上 這個也會恢復

00:37:55.676 --> 00:37:57.678
如果你的應用崩潰或者重啓了機器

00:37:57.744 --> 00:38:00.180
所有的東西恢復到之前的樣子

00:38:00.948 --> 00:38:02.683
現在 實現這個效果

00:38:04.184 --> 00:38:05.018
我們需要

00:38:06.286 --> 00:38:07.721
保存所有的UI狀態

00:38:08.088 --> 00:38:09.156
隨着時間的推移積累

00:38:09.756 --> 00:38:11.758
然後恢復它
當應用重新啓動時

00:38:12.759 --> 00:38:14.895
明確說我們不想在模型裏保存狀態

00:38:14.962 --> 00:38:16.530
它並不真正屬於那裏

00:38:17.564 --> 00:38:20.067
所以一個狀態恢復API給你

00:38:20.133 --> 00:38:22.903
一個明確的地方單獨保存UI狀態

00:38:22.970 --> 00:38:26.373
它給你一個好的地方恢復那個狀態
當你啓動應用時

00:38:26.673 --> 00:38:28.675
但是在你的UI在屏幕上展示出來之前

00:38:29.776 --> 00:38:31.311
基本上你可在每個窗口啓用它

00:38:31.645 --> 00:38:34.081
那相當簡單
設置isRestorable爲真

00:38:34.715 --> 00:38:36.683
然後你提供一個恢復類

00:38:37.050 --> 00:38:40.888
處理創建你窗口的事件

00:38:41.255 --> 00:38:42.489
從編碼的數據中

00:38:42.956 --> 00:38:46.426
好消息是若你用NSDocument
NSDocument會處理這些

00:38:48.262 --> 00:38:49.997
我們想要恢復什麼樣的狀態？

00:38:50.597 --> 00:38:52.666
我們可能選擇保存

00:38:53.066 --> 00:38:55.536
當前應用中激活的工具

00:38:56.436 --> 00:38:59.439
我們還可能想保存側邊欄的狀態

00:38:59.506 --> 00:39:01.942
我們選擇了什麼 我們滑動了多少位移

00:39:03.410 --> 00:39:04.244
我們如何來做？

00:39:04.978 --> 00:39:08.382
好吧 若你之前用過NSCoding
那是非常非常簡單

00:39:09.550 --> 00:39:13.387
第一個方法
帶有編碼器的encodeRestorableState

00:39:14.221 --> 00:39:16.423
你可以在任何
NSResponder方法上實現

00:39:16.490 --> 00:39:19.927
並且就像使用NSCoding一樣
但是這是爲了控制器的高效率

00:39:22.629 --> 00:39:25.666
另一個重要的調用是
invalidateRestorableState

00:39:26.466 --> 00:39:29.136
這就是說無論如何我的
支持數據是什麼

00:39:29.570 --> 00:39:32.406
對encodeRestorableState
已經在某種程度上改變了

00:39:33.040 --> 00:39:35.442
我們將安排確保再一次保存狀態

00:39:35.509 --> 00:39:36.610
在未來的某時

00:39:38.512 --> 00:39:40.214
並且最終簡單的恢復

00:39:40.280 --> 00:39:43.183
這確實像你想的一樣
非常像initWithCoder

00:39:43.951 --> 00:39:45.352
你只需調用super

00:39:45.686 --> 00:39:48.422
解碼您已編碼的所有已編碼的數據

00:39:48.856 --> 00:39:52.025
然後根據你已編碼的信息
設置你的UI

00:39:54.328 --> 00:39:57.397
現在 這太容易了
但是可以使它變得更容易

00:39:57.998 --> 00:40:01.635
你只需實現一個類方法
restorableState KeyPaths

00:40:02.169 --> 00:40:04.671
請求一下super
因爲這是有禮貌的行爲

00:40:04.738 --> 00:40:06.974
但接着
也得添加我們的關鍵路徑

00:40:07.441 --> 00:40:10.410
並且這是你希望的可以自動恢復的屬性

00:40:10.677 --> 00:40:13.180
或者通過系統存儲和恢復

00:40:13.714 --> 00:40:15.182
這些屬性需爲KVC

00:40:15.415 --> 00:40:18.452
這些鍵值編碼可以訪問
就像我們通過關鍵路徑訪問

00:40:18.519 --> 00:40:21.421
並且它們也需要有可觀察性
以便於我們可以隨時觀察它們

00:40:21.855 --> 00:40:23.824
當它們變得無效或者狀態改變時

00:40:25.692 --> 00:40:27.060
這是狀態恢復

00:40:27.928 --> 00:40:31.131
我們接下來看第三個和最後一個技術
在雲端的文件

00:40:32.165 --> 00:40:33.667
很久以前

00:40:34.168 --> 00:40:35.769
在雲端選擇文件

00:40:35.836 --> 00:40:38.605
不得不主動選擇並創建一個容器

00:40:39.106 --> 00:40:42.342
但伴隨着iCloud Drive
尤其現iCloud Desktop

00:40:42.409 --> 00:40:43.777
和文檔的發展

00:40:44.111 --> 00:40:46.613
很可能你的應用正使用文檔

00:40:46.680 --> 00:40:47.648
存於雲端

00:40:48.515 --> 00:40:50.617
這很重要
因爲10.12版本新特性中

00:40:51.151 --> 00:40:54.188
本地的文件可能因爲要騰出空間
而被移除

00:40:54.555 --> 00:40:57.257
這意味着你可能會正在使用一些

00:40:57.558 --> 00:40:59.359
並不是真的在本地硬盤上的文件

00:41:00.761 --> 00:41:02.930
我們如何處理這問題呢？
這看起來非常可怕

00:41:04.331 --> 00:41:06.400
幸運的是
若你使用NSDocument

00:41:06.466 --> 00:41:08.902
它將爲你處理一切因此
你無需擔心

00:41:09.736 --> 00:41:12.739
如果你沒有使用
你需要確定你正使用文件協調器

00:41:13.240 --> 00:41:15.709
若你將自己註冊爲
文件演示者

00:41:15.776 --> 00:41:17.144
通過文件協調器API

00:41:17.511 --> 00:41:20.514
我們將確認文件沒有被程序移除

00:41:20.914 --> 00:41:21.882
這是一件好事

00:41:22.583 --> 00:41:24.484
接下來如果你使用文件協調器

00:41:24.785 --> 00:41:27.421
來協調文件IO

00:41:27.821 --> 00:41:31.525
我們將會確保方便安排你的IO

00:41:31.658 --> 00:41:33.827
當這個文件被完全下載以後

00:41:35.729 --> 00:41:37.264
這些在雲裏的文件

00:41:37.664 --> 00:41:40.400
這有一些技術我們沒有時間詳細論述

00:41:40.467 --> 00:41:42.436
但是我確實想要給你們一個提示

00:41:42.669 --> 00:41:44.271
首先是資源目錄

00:41:44.705 --> 00:41:47.608
比在你包裏鬆散資源更快更小

00:41:47.908 --> 00:41:51.044
它們也可以幫助你
比如廣色域和從右向左

00:41:51.745 --> 00:41:54.147
可訪問性 十分重要

00:41:54.515 --> 00:41:57.184
Cocoa搭載了功能確實強大的
可訪問性技術

00:41:57.251 --> 00:41:59.353
你的應用輕鬆擁有的技術

00:41:59.586 --> 00:42:02.389
你得確保

00:42:02.456 --> 00:42:05.559
學着使用voice over和
所有這些可訪問技術十分重要

00:42:05.626 --> 00:42:07.661
確保你的應用做正確的事情

00:42:07.794 --> 00:42:11.098
你永遠不應該發佈一個
用戶界面有問題的應用

00:42:11.164 --> 00:42:15.002
所以不要讓一個UI有問題的應用上市

00:42:16.670 --> 00:42:19.439
沙盒和XPC服務

00:42:20.007 --> 00:42:22.476
兩個不同的但有關連的技術

00:42:22.676 --> 00:42:24.444
這兩個技術可以幫你隔離代碼

00:42:24.511 --> 00:42:26.947
從系統的其他部分和其他進程中

00:42:27.047 --> 00:42:29.816
沙盒對於Mac
App Store是強制性的

00:42:29.883 --> 00:42:31.818
但它對每一個應用都是合適的

00:42:32.786 --> 00:42:35.489
XPC服務 可以幫助你分離出代碼

00:42:35.556 --> 00:42:36.990
到分離的進程中

00:42:38.158 --> 00:42:39.993
這是非常棒的對一些事 如

00:42:40.060 --> 00:42:43.363
處理一些不可信網絡的數據

00:42:43.430 --> 00:42:45.465
或者做一些分析工作

00:42:46.667 --> 00:42:49.136
我們都認爲我們的代碼是最棒的

00:42:49.369 --> 00:42:51.271
但是如我們開車時系安全帶

00:42:51.572 --> 00:42:54.541
這樣在發生問題時我們會有保障

00:42:56.844 --> 00:43:01.114
我們在短短的時間內講了大量的內容

00:43:01.181 --> 00:43:04.151
所以我想帶你們重溫一下重點內容
確保你們都還記得

00:43:04.418 --> 00:43:05.686
就像我們剛剛談論的

00:43:06.353 --> 00:43:09.623
我們以創造一個“現代化外觀”開始

00:43:10.224 --> 00:43:12.359
通過我們的現代化視圖與窗口管道

00:43:12.426 --> 00:43:14.828
確保你可以做出流暢的動畫

00:43:15.095 --> 00:43:17.698
接下來我們講了拖放與事件追蹤

00:43:17.764 --> 00:43:20.901
確保你得到一個非常酷的拖動羣集效果

00:43:20.968 --> 00:43:22.669
現代化拖動
file promises

00:43:23.370 --> 00:43:26.340
接着我們講了容器視圖
像是滾動視圖和表視圖

00:43:26.406 --> 00:43:28.509
並且確保可以正確將其本地化

00:43:29.910 --> 00:43:32.813
然後我們講了系統的外觀
storyboards

00:43:33.013 --> 00:43:35.616
還有一些現代的Mac特性

00:43:35.682 --> 00:43:38.519
使Mac平臺炫目 並且確實有益

00:43:39.219 --> 00:43:42.923
這有我們演講的永久鏈接
你應該可以從這裏找到相關資源

00:43:42.990 --> 00:43:45.692
包括我們的演示應用下載

00:43:45.759 --> 00:43:47.327
一旦該應用就緒

00:43:48.462 --> 00:43:50.030
所有相關演講已結束

00:43:50.097 --> 00:43:51.431
我希望你出席了那些演講

00:43:51.498 --> 00:43:54.601
如果沒有
希望你一定要在線觀看視頻

00:43:55.802 --> 00:43:57.404
就這樣
謝謝大家的參與