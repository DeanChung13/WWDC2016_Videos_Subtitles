00:00:19.920 --> 00:00:23.924
GameplayKit的新特性

00:00:27.961 --> 00:00:28.795
大家早上好

00:00:30.163 --> 00:00:31.164
我是Bruno Sommer

00:00:31.231 --> 00:00:33.066
我是Apple的遊戲技術工程師

00:00:33.133 --> 00:00:35.235
“GameplayKit的新特性”

00:00:37.070 --> 00:00:38.872
去年 我們介紹了
GameplayKit

00:00:38.939 --> 00:00:41.008
是Apple的一個高級遊戲框架

00:00:41.642 --> 00:00:43.110
GameplayKit是一個集合

00:00:43.177 --> 00:00:47.214
包含一些常用的架構模式
數據結構和算法

00:00:47.781 --> 00:00:49.917
這允許我們的開發者
開發很棒的

00:00:49.983 --> 00:00:52.119
引人入勝的玩法
在他們開發的遊戲中

00:00:53.287 --> 00:00:56.156
GameplayKit
作爲你的工具箱

00:00:56.223 --> 00:00:57.357
爲了很棒的遊戲體驗

00:00:57.758 --> 00:00:59.359
所以不管你要開發
什麼類型的遊戲

00:00:59.426 --> 00:01:02.629
不管它是遊戲平臺
還是RPG或城市建設者

00:01:03.864 --> 00:01:07.000
你總可以在GameplayKit中
找到能方便開發的東西

00:01:07.100 --> 00:01:08.869
並讓你的遊戲更加健壯

00:01:11.271 --> 00:01:12.973
去年我們引入了
GameplayKit

00:01:13.040 --> 00:01:14.908
它由七個主要系統構成

00:01:14.975 --> 00:01:17.744
比如實體和組件 狀態機

00:01:17.911 --> 00:01:19.646
以及我們的遊戲質量無規源

00:01:21.181 --> 00:01:25.118
今年 我們在尋路 代理
和遊戲AI方面進行了提升

00:01:26.386 --> 00:01:29.690
還向GameplayKit中引入
三個新的主要系統

00:01:30.257 --> 00:01:32.659
我們有一個很強大的
區域分割系統

00:01:32.726 --> 00:01:34.394
這將允許你獲得很好的表現

00:01:34.461 --> 00:01:36.730
在遊戲的運行時查詢中

00:01:38.298 --> 00:01:40.434
你必須有一個很強大的
過程生成系統

00:01:40.501 --> 00:01:43.070
來製作引人入勝
的運行時內容

00:01:44.538 --> 00:01:46.840
今年 我們也集成了

00:01:46.907 --> 00:01:48.876
GameplayKit
在Xcode遊戲編輯器中

00:01:48.942 --> 00:01:51.678
所以許多曾經只能在代碼中
使用的工作流

00:01:51.778 --> 00:01:55.349
現在可以直接在數據編輯器中使用
不需要重新編譯

00:01:56.950 --> 00:01:58.185
所以我們今天內容很多

00:01:58.252 --> 00:02:01.421
我打算直接說尋路中的新功能

00:02:03.390 --> 00:02:05.425
去年 我們介紹了障礙物圖

00:02:05.492 --> 00:02:07.528
這些是我們的圖類型
它們負責處理

00:02:07.594 --> 00:02:09.596
你的遊戲世界中
不可同行的障礙物的集合

00:02:10.430 --> 00:02:12.633
在名字之下 我們使用
了一系列視野算法

00:02:12.699 --> 00:02:14.968
來在障礙物之間
繪製可通行區域

00:02:16.236 --> 00:02:17.738
現在這個方法很強大

00:02:17.804 --> 00:02:19.640
它生成了質量很高的路徑

00:02:20.174 --> 00:02:21.875
但是對較大的遊戲世界而言

00:02:21.942 --> 00:02:24.044
以及障礙物數量較大的遊戲世界

00:02:24.111 --> 00:02:26.513
計算過程強度很高

00:02:26.780 --> 00:02:29.283
在計算並保存結果時

00:02:30.517 --> 00:02:32.519
所以今年 我們提供給
大家另一個選擇

00:02:32.586 --> 00:02:34.588
我們要引入GKMeshGraph

00:02:35.589 --> 00:02:37.391
現在 這很類似
我們的障礙物圖

00:02:37.457 --> 00:02:40.661
再一次 我們要處理
遊戲世界中不可通過的障礙物

00:02:40.727 --> 00:02:43.730
但是現在我們不再使用
視野直線來計算可通行區域

00:02:43.797 --> 00:02:45.065
在這些障礙物之間

00:02:45.132 --> 00:02:47.201
我們要將這個區域分成三角形

00:02:47.267 --> 00:02:49.036
我們由之計算出
一個三角形網狀圖

00:02:49.136 --> 00:02:50.571
這樣每一個可通行的點

00:02:50.637 --> 00:02:53.807
在你的遊戲世界中
由僅僅一個三角形代表

00:02:55.409 --> 00:02:58.812
這個新的三角化方法
一樣會生成很高質量的路徑

00:02:58.879 --> 00:03:01.748
而且附加好處是
計算起來很快

00:03:01.815 --> 00:03:05.319
保存起來成本很低
尤其是對很大的遊戲世界

00:03:06.653 --> 00:03:08.488
此外 它的靈活性很高
在計算節點

00:03:08.555 --> 00:03:10.757
應該處在網狀圖的哪個位置時

00:03:10.958 --> 00:03:13.861
你可以把它們放在三教中心
三角的定點上

00:03:13.927 --> 00:03:16.296
與三角形的邊上
以及所有存在的組合

00:03:18.465 --> 00:03:20.100
讓我們看一個小代碼示例

00:03:20.200 --> 00:03:22.603
展示GameplayKit中
用網狀圖的樣子

00:03:22.970 --> 00:03:24.638
你們會對它的樣子很熟悉

00:03:24.705 --> 00:03:25.906
和曾經的障礙物圖相較

00:03:25.973 --> 00:03:28.075
它們都在以不同方式解決同樣的問題

00:03:29.376 --> 00:03:31.812
在這裏的最上端
我要製作我的網狀圖

00:03:31.879 --> 00:03:33.814
我要傳入的緩存半徑爲10

00:03:33.881 --> 00:03:36.984
這裏的緩存半徑關聯於
你的代理的尺度

00:03:37.050 --> 00:03:39.152
它們負責在你的世界中
進行尋路工作

00:03:39.219 --> 00:03:42.589
我們要手工的在後臺
提高你的障礙物的尺寸

00:03:42.656 --> 00:03:44.424
來彌補代理尺寸

00:03:45.926 --> 00:03:49.062
現在我要傳入兩點(0, 0)
和(1000, 1000)

00:03:49.129 --> 00:03:52.566
這是我的網狀圖要代表的
遊戲世界的跨度

00:03:54.701 --> 00:03:57.571
下一步 我要設置我的網狀圖
的三角化模式

00:03:57.671 --> 00:03:59.640
這就是節點放置的靈活性所在

00:03:59.706 --> 00:04:01.074
即我剛纔所提到的

00:04:01.475 --> 00:04:03.911
現在我要具體地
將節點放在

00:04:03.977 --> 00:04:06.480
三角形的定點上
以及三角形的中心

00:04:08.382 --> 00:04:10.751
最後 我們要將
障礙物集合添加到網狀圖中

00:04:10.851 --> 00:04:13.120
我們有一個障礙物集合
與我們的遊戲世界關聯

00:04:13.520 --> 00:04:14.988
而後我們要調用三角化

00:04:15.255 --> 00:04:17.391
這會將這些障礙圖託付給圖

00:04:17.724 --> 00:04:19.892
它負責運行背後的
三角化算法

00:04:20.194 --> 00:04:21.428
而後就完成了

00:04:21.495 --> 00:04:24.164
這個圖已經可以
在我們的遊戲中進行尋路了

00:04:27.167 --> 00:04:28.335
除了我們的網狀圖之外

00:04:28.402 --> 00:04:30.871
今年我們還介紹了尋路中
定製節點類別

00:04:31.839 --> 00:04:34.508
我們的一些圖會
自動的實例化它們的節點

00:04:34.575 --> 00:04:37.778
這就是我們的格子圖
障礙圖和網狀圖

00:04:38.579 --> 00:04:39.813
在實例化的時候

00:04:39.880 --> 00:04:43.550
你可以選擇指定一個
自定義節點類別來讓它們實例化

00:04:44.084 --> 00:04:46.420
這將會大有用處
如果你需要附加任何自定義數據

00:04:46.486 --> 00:04:48.355
或邏輯在你的節點上
這有時會很有用

00:04:48.422 --> 00:04:49.890
取決於你想要製作的遊戲

00:04:51.191 --> 00:04:52.192
我們要調用合適的init()

00:04:52.259 --> 00:04:54.795
在我們生成了我們的
原始節點類型時

00:04:55.729 --> 00:04:58.498
還有 這些所有類型的圖現都支持
Object-C和Swift屬性

00:04:58.565 --> 00:05:02.002
所以你在訪問自定義節點
時不需要類型轉換

00:05:04.972 --> 00:05:07.140
這就是今年尋路中的新特性

00:05:07.708 --> 00:05:09.710
現在讓我們繼續說說
代理中的新特性

00:05:11.612 --> 00:05:14.581
說些GameplayKit中
有關代理的令人振奮的事情

00:05:14.648 --> 00:05:16.550
他們是自動運動的實體

00:05:17.351 --> 00:05:19.453
被一系列的目標和行爲控制

00:05:19.520 --> 00:05:22.289
它們也被一系列現實的
物理限制所侷限

00:05:22.356 --> 00:05:26.960
比如速度 質量 躲避障礙和尋路

00:05:28.395 --> 00:05:29.863
在此右側 你看到一系列目標

00:05:29.930 --> 00:05:32.900
供你使用 來達到你在
你的遊戲中想要的行爲

00:05:32.999 --> 00:05:36.803
比如尋找與躲避或者漫遊與逃跑

00:05:39.573 --> 00:05:41.808
原來 代理是純2D的

00:05:41.875 --> 00:05:44.611
今年 我們很激動地宣佈
我們要將其帶入3D

00:05:45.345 --> 00:05:47.114
相關類叫GKAgent3D

00:05:47.814 --> 00:05:50.551
用戶界面與2D的變形很像

00:05:50.617 --> 00:05:53.687
主要的區別在於
其位置是三個浮點

00:05:54.121 --> 00:05:57.057
旋轉也是三階矩陣流

00:05:57.324 --> 00:05:59.593
所有的目標和行爲都被支持

00:06:00.661 --> 00:06:02.663
有關這次改變要提到幾點

00:06:02.796 --> 00:06:06.400
我們改了GKPath來同時
支持2D和3D點

00:06:06.466 --> 00:06:08.669
考慮到遵從路徑的目標

00:06:09.903 --> 00:06:12.639
考慮到躲避障礙物目標
中的障礙物

00:06:12.706 --> 00:06:16.143
如果你要使用3D的障礙
它們依然存在於一個平面上

00:06:16.210 --> 00:06:18.712
所以你要選擇一個平面
對你的遊戲有意義

00:06:20.581 --> 00:06:22.349
除了將代理帶入3D以外

00:06:22.416 --> 00:06:24.985
今年我們還引入了行爲成分

00:06:25.586 --> 00:06:29.089
我們引入新類GKCompositeBehavior
它是GKBehavior的子類

00:06:29.790 --> 00:06:31.658
這是一個行爲的加權集合

00:06:31.725 --> 00:06:35.996
這和剛纔行爲與目標
的關係很像

00:06:36.063 --> 00:06:37.898
行爲是一個目標的加權合集

00:06:39.533 --> 00:06:41.034
它是完全可嵌套的
所以你現在可以完成

00:06:41.101 --> 00:06:44.638
很有趣的嵌套行爲
在你的遊戲中的行爲

00:06:44.705 --> 00:06:47.140
這也使得它們更易於維護
尤其當你在完成

00:06:47.207 --> 00:06:49.877
你的遊戲中的很多的行爲時

00:06:51.512 --> 00:06:55.082
讓我們很快地看看代碼示例
關於實際情況下的行爲成分

00:06:55.282 --> 00:06:57.718
在這裏的最上
我要創建一個羣聚行爲

00:06:58.018 --> 00:07:00.954
通過結合隊列 黏合
與分離這三個目標

00:07:02.689 --> 00:07:04.892
下一步 我要些障礙物
和敵人添加到遊戲中

00:07:04.958 --> 00:07:06.393
我需要我的代理來躲避

00:07:06.460 --> 00:07:07.861
我們要製作一個躲避行爲

00:07:07.928 --> 00:07:11.131
通過結合avoidObstacles
和avoidEnemies目標

00:07:13.133 --> 00:07:16.403
然後我要結合這兩個行爲
成爲一個新的合併行爲

00:07:16.470 --> 00:07:18.205
很高效地合二爲一

00:07:19.973 --> 00:07:21.542
最終 我要製作我的代理

00:07:21.608 --> 00:07:24.711
我要將我的組合行爲
設置爲代理的行爲

00:07:25.279 --> 00:07:26.113
現在可以運行了

00:07:26.180 --> 00:07:29.449
下一次我們更新這個代理時
它同時會正確地嘗試

00:07:29.516 --> 00:07:32.252
來達到這兩個子目標
或是子行爲

00:07:35.923 --> 00:07:37.591
這就是今年代理的新特性了

00:07:37.658 --> 00:07:40.327
讓我們繼續說說
我們的全新空間分割系統

00:07:43.397 --> 00:07:45.299
先介紹一點空間分割的背景知識

00:07:45.365 --> 00:07:47.034
可能對你的遊戲很重要

00:07:47.367 --> 00:07:50.337
經常在我們完成高級遊戲編程時

00:07:50.571 --> 00:07:52.973
我們會問好多有關
遊戲世界的空間問題

00:07:53.240 --> 00:07:55.642
比如 有多少敵人離玩家較近？

00:07:55.709 --> 00:07:58.145
或是 在我的世界中
所有的物品都在哪裏？

00:07:58.478 --> 00:08:00.747
或是在這一幀中
哪個拋射體會擊中玩家？

00:08:02.082 --> 00:08:03.550
尤其對於更大的遊戲世界

00:08:03.617 --> 00:08:06.286
或是有大量遊戲物體的遊戲世界

00:08:06.587 --> 00:08:08.956
回答這類問題可能開銷很大

00:08:10.324 --> 00:08:13.227
在遊戲編程中 我們往往
加速這一類的空間查詢

00:08:13.293 --> 00:08:16.296
通過使用一種叫空間分割的緩存

00:08:18.665 --> 00:08:20.534
總覽我們所提供的

00:08:20.601 --> 00:08:22.302
在我們的空間分割系統中

00:08:22.402 --> 00:08:24.838
這是一個樹狀數據
結構集合 能讓你

00:08:24.905 --> 00:08:26.807
基於空間緩存遊戲物體

00:08:26.940 --> 00:08:28.775
你將物體添加到
這些樹狀數據結構中

00:08:28.842 --> 00:08:31.912
它們在底層會聚集爲
層級與桶

00:08:32.212 --> 00:08:35.315
然後未來查詢這些物體時
效率就會高得多

00:08:36.582 --> 00:08:39.186
今年 我們引入了
三個這樣的數據結構

00:08:39.253 --> 00:08:40.988
供大家進行空間劃分所需

00:08:41.188 --> 00:08:43.924
我們有R-trees、
quadtrees和octrees

00:08:45.759 --> 00:08:47.361
讓我們深入這些數據結構分析

00:08:47.427 --> 00:08:48.695
先說R-tree

00:08:50.230 --> 00:08:52.366
R-tree是一個樹狀數據結構

00:08:52.432 --> 00:08:54.668
內有一系列的層級桶

00:08:55.202 --> 00:08:59.673
每當你向一個R-tree添加
一個對象時 它會進入其中一個桶

00:09:00.107 --> 00:09:03.343
所有這些桶都
附帶一個包圍盒與之關聯

00:09:04.044 --> 00:09:08.248
它是該桶中所有的子對象
的包圍盒的總和

00:09:09.216 --> 00:09:10.450
R-tree有一個特定的規則

00:09:10.517 --> 00:09:13.253
每當這些桶變得太大時
就需要被分割

00:09:13.954 --> 00:09:17.591
這些桶的最大尺寸
是一個由用戶配置的參數

00:09:18.358 --> 00:09:20.527
我們還有一系列策略供使用

00:09:20.594 --> 00:09:22.462
來決定這些桶應當如何分割

00:09:22.829 --> 00:09:25.265
我們可以很簡單的分割
或是嘗試進行線性優化

00:09:25.332 --> 00:09:29.636
與二次的距離
或是嘗試降低桶之間的重疊

00:09:30.938 --> 00:09:32.606
我將給大家一個
很快的視覺樣例

00:09:32.673 --> 00:09:34.374
關於構建簡單的
R-tree是什麼樣子的

00:09:34.441 --> 00:09:38.245
比如說 我有一個太空遊戲
裏面有一些宇宙飛船和小行星

00:09:38.745 --> 00:09:42.082
我要將一個宇宙飛船添加到
R-tree中 它進入了一個桶

00:09:42.149 --> 00:09:44.351
它就是那個飛船的包圍盒

00:09:45.018 --> 00:09:47.020
然後我要添加兩個
小行星到桶中

00:09:47.087 --> 00:09:50.090
你可以看到它變大了
來容納這些物體

00:09:51.758 --> 00:09:53.760
我在這個R-tree中指定了規則

00:09:53.827 --> 00:09:56.697
當這些桶超過三個物體時
需要進行分割

00:09:57.097 --> 00:09:59.299
所以我要再向這個桶中
添加第四個物體

00:09:59.499 --> 00:10:01.835
現在這個桶太大了
它需要被分割

00:10:02.302 --> 00:10:04.471
我們要進行一個
簡單的線性距離分割

00:10:04.538 --> 00:10:06.373
最後結果是兩個桶

00:10:07.708 --> 00:10:10.210
再一次 我向右側的桶
中添加了兩個物體

00:10:12.312 --> 00:10:14.248
這個桶又變得太大
需要被分割開

00:10:14.314 --> 00:10:17.484
再一次 我們要完成一次
線性分割 得到兩個桶

00:10:17.718 --> 00:10:20.087
這就是R-tree在
底層的運作模式了

00:10:24.424 --> 00:10:26.860
讓我們繼續說
quadtree和octree

00:10:27.227 --> 00:10:28.629
我將這兩個一起說

00:10:28.695 --> 00:10:31.965
因爲它們都在解決同樣的問題
只不過quadtree解決2D

00:10:32.032 --> 00:10:33.100
而octree解決3D

00:10:33.166 --> 00:10:34.568
界面是一樣的

00:10:35.702 --> 00:10:39.273
這些有一系列等級和層次
的樹狀數據結構

00:10:39.606 --> 00:10:41.942
在每一層中
空間也被均等的分割

00:10:42.009 --> 00:10:44.244
在右側
我有一個quadtree的示例

00:10:44.545 --> 00:10:47.314
你可以在左上側看到
我已經將這個扇形區域細分過了

00:10:47.381 --> 00:10:51.185
在新的被分割扇形的左上側
我再一次進行分割

00:10:52.819 --> 00:10:55.556
所以quadtree和octree
都有個與之關聯最大單元扇形尺寸

00:10:55.622 --> 00:10:58.258
這控制了這些樹的
最大成長深度

00:10:58.325 --> 00:11:00.394
以及這些單元扇形的細分極限

00:11:01.461 --> 00:11:03.397
現在 當你向quadtree
與octree中添加對象時

00:11:03.463 --> 00:11:06.867
它會被放在一個
它能佔滿的最小隔間中

00:11:08.235 --> 00:11:10.070
關於該最大隔間尺寸
給大家一小貼士

00:11:10.137 --> 00:11:13.073
它的關聯度很高
這個值很重要 尤其關於

00:11:13.140 --> 00:11:15.242
這些數據結構的表現性能

00:11:15.309 --> 00:11:16.910
所以你應該選擇一個隔間尺寸

00:11:17.244 --> 00:11:19.079
或一個最大隔間尺寸
對遊戲最有意義

00:11:19.146 --> 00:11:20.581
一般來說 這個關聯於

00:11:20.647 --> 00:11:23.317
你的遊戲世界中
一些較小的遊戲物體

00:11:24.451 --> 00:11:26.820
我給大家一個
構建quadtree的視覺示例

00:11:27.321 --> 00:11:29.089
同樣的示例 宇宙飛船和小行星

00:11:29.156 --> 00:11:31.158
我向quadtree中
插入一宇宙飛船

00:11:31.258 --> 00:11:34.294
被放置在兩層下的
左邊的扇形區域中

00:11:35.362 --> 00:11:38.365
我要添加一些更大的物體
它們被放置在更上一層

00:11:39.600 --> 00:11:41.101
這裏注意左邊的小行星

00:11:41.168 --> 00:11:43.470
它有些跨越了扇形的邊界

00:11:43.537 --> 00:11:44.872
它事實上需要處在更高一層

00:11:44.938 --> 00:11:47.608
因爲它不能很好地
安放在任何一個隔間中

00:11:48.842 --> 00:11:50.444
最終 我再添加一些更小的物體

00:11:50.511 --> 00:11:52.846
你可以看到
它們處在向下三層的位置

00:11:55.382 --> 00:11:57.818
這就是底層的運作模式了

00:11:57.918 --> 00:11:59.920
當你使用quadtree
或是octree時

00:12:01.188 --> 00:12:03.390
實際情況中
quadtree的代碼示例

00:12:04.525 --> 00:12:06.460
最上部
我要創造我的quadtree

00:12:06.527 --> 00:12:09.363
我要傳入一個quad
這是我的遊戲世界中的區域

00:12:09.429 --> 00:12:10.964
我想讓這quadtree代表

00:12:11.031 --> 00:12:16.003
我們要覆蓋遊戲世界中(0, 0)
和(1000, 1000)間的區域

00:12:17.137 --> 00:12:19.273
我要指定最小隔間尺寸爲100

00:12:19.339 --> 00:12:22.242
這個quadtree中沒
哪個隔間可以小於100個單位

00:12:24.278 --> 00:12:25.746
我在遊戲世界中還有一些敵人

00:12:25.812 --> 00:12:28.115
我要將它們添加到
我的quadtree中

00:12:28.382 --> 00:12:31.285
要注意這些敵人也有
一個quad與他們關聯

00:12:31.351 --> 00:12:33.520
這就是我們的遊戲世界
中的敵人所處的地方

00:12:33.587 --> 00:12:35.923
也是它們將在quadtree中
終止的地方

00:12:37.658 --> 00:12:40.060
最後 我要在quadtree
中進行一次查詢

00:12:40.160 --> 00:12:42.229
我要讓quadtree
給我所有的物體

00:12:42.296 --> 00:12:46.066
在quadtree的(0, 0)
和(1000, 1000)之間

00:12:46.133 --> 00:12:47.801
在我的遊戲世界中

00:12:47.868 --> 00:12:50.370
結果我的三個敵人
都在這個範圍中

00:12:50.504 --> 00:12:52.806
我要在查詢後獲得
這所有三個敵人

00:12:54.374 --> 00:12:56.677
這就是GameplayKit中
空間劃分了

00:12:56.977 --> 00:12:59.746
讓我們繼續說說
我們的過程生成系統

00:13:02.082 --> 00:13:04.184
先說說一點背景知識
有關爲什麼過程生成

00:13:04.251 --> 00:13:05.519
可能對你很重要

00:13:06.854 --> 00:13:09.356
我相信大家都很熟悉
遊戲中的預製內容

00:13:09.423 --> 00:13:11.758
這是我們在遊戲運行前
我們製作的內容

00:13:11.825 --> 00:13:13.360
甚至是在遊戲上市之前

00:13:13.627 --> 00:13:16.730
這些包括 藝術家設計
或是設計師設計的水平

00:13:16.797 --> 00:13:19.333
或藝術家開發的
結構或特質

00:13:20.801 --> 00:13:23.470
這些是很棒的資產
它們對許多遊戲很有好處

00:13:23.537 --> 00:13:26.373
但對於其他的遊戲
以及特定的題材

00:13:27.207 --> 00:13:30.244
你會遇到一些問題
因爲這些資產是靜態的

00:13:30.310 --> 00:13:32.212
它們在運行時不怎麼變化

00:13:32.279 --> 00:13:34.781
所以尤其當我在尋找
一種隨機的感覺時

00:13:34.848 --> 00:13:36.750
需要每次玩遊戲時
都感覺到新

00:13:37.818 --> 00:13:40.187
我就不能使用這種
靜態的資產了

00:13:40.521 --> 00:13:42.089
所以我需要的是過程內容

00:13:42.155 --> 00:13:44.124
比如隨機生成的世界

00:13:44.391 --> 00:13:47.027
過程生成的結構或高度地圖

00:13:50.297 --> 00:13:53.100
我們要製作遊戲中的
這些過程內容

00:13:53.433 --> 00:13:56.670
我們真正需要的是
一種連貫的隨機性的來源

00:13:56.737 --> 00:13:59.606
我所嘗試製作的許多這種
隨機元素都存在於自然中

00:13:59.673 --> 00:14:02.643
比如世界 結構和高度地圖

00:14:03.911 --> 00:14:06.046
我們需要一種隨機性
能在空間上具有意義

00:14:06.113 --> 00:14:08.549
能有一個潛在的
空間模式與之對應

00:14:09.850 --> 00:14:10.684
現在 你可能對自己說

00:14:10.751 --> 00:14:12.486
可以直接使用隨機數生成器對嗎？

00:14:12.586 --> 00:14:14.922
我可以從隨機數生成器中獲取一些數值

00:14:14.988 --> 00:14:17.090
來製作我的隨機內容
然後就完成了

00:14:18.025 --> 00:14:21.094
所有嘗試這麼做的人
很快就會遇到障礙

00:14:21.728 --> 00:14:24.364
隨機數生成器的輸出波動很大

00:14:24.431 --> 00:14:28.101
連續的調用結果很難有
空間上有意義的聯繫

00:14:28.435 --> 00:14:30.604
嘗試決定論也是很有挑戰性的

00:14:30.671 --> 00:14:34.808
每當我隨機生成內容時
我希望它能展示同樣的內容

00:14:34.875 --> 00:14:36.210
如果我給它同樣的種子

00:14:37.544 --> 00:14:39.246
我們要的來源應提供一致的隨機性

00:14:39.313 --> 00:14:42.049
有一種這樣的來源叫噪聲

00:14:43.650 --> 00:14:48.222
噪聲是一個函數
它接收一個輸入 並輸出數值

00:14:48.555 --> 00:14:50.524
但這個關聯之間
還有一些規則

00:14:51.158 --> 00:14:53.827
對於輸入中的微小變化
輸出的變化也很小

00:14:54.361 --> 00:14:56.930
如果輸入變化很大
我就會得到隨機的

00:14:56.997 --> 00:15:00.234
但依然在空間上
有意義的輸出變化

00:15:00.300 --> 00:15:03.070
在這個噪聲來源中
有一些隱含的模式

00:15:04.037 --> 00:15:07.040
噪聲函數對於整個
輸入域來說是無窮的

00:15:07.107 --> 00:15:09.443
它無窮地伸展
而且它們具有確定性

00:15:09.510 --> 00:15:11.612
給定同樣的輸入
我總是會獲得同樣的輸出

00:15:13.847 --> 00:15:16.984
所以一旦你使用這個噪聲函數
我們可以在特定間隔處取樣

00:15:17.050 --> 00:15:20.220
間隔與我要製作的遊戲
與其內容類型相關

00:15:20.287 --> 00:15:21.922
所以如果我要隨機生成世界時

00:15:21.989 --> 00:15:25.359
它可能是座標或是瓦片索引
或是生物指數

00:15:25.726 --> 00:15:27.327
如果我要隨機生成材質時

00:15:27.394 --> 00:15:29.696
它可以是貼圖像素
或是像素等等

00:15:33.100 --> 00:15:34.701
概述一下我們所提供的

00:15:34.768 --> 00:15:38.005
通過我們的過程生成系統
和我們的噪聲系統

00:15:39.006 --> 00:15:42.676
你有一系列的噪聲來源
供你使用與取樣

00:15:42.743 --> 00:15:44.077
來製作遊戲中有意義的內容

00:15:44.144 --> 00:15:45.913
這些是類似於比較
隨機的噪聲

00:15:45.979 --> 00:15:48.315
比如Perlin噪聲
和Voronoi噪聲

00:15:48.549 --> 00:15:50.884
還有幾何噪聲源
比如巨浪

00:15:50.951 --> 00:15:53.187
與球體 脊與圓柱

00:15:54.321 --> 00:15:56.924
以及一些常量噪聲源
比如西洋棋跳盤模式

00:15:56.990 --> 00:15:58.859
或是常量噪聲函數

00:16:00.427 --> 00:16:03.030
然後你就可以組合這些
噪聲源成爲一個噪聲物體

00:16:03.096 --> 00:16:05.299
並在其上展示一系列的變換

00:16:05.832 --> 00:16:07.634
這些包括結合噪聲源

00:16:07.701 --> 00:16:10.304
或是轉化 度量 旋轉噪聲源

00:16:11.905 --> 00:16:15.209
一旦我們以某種有意義的
方式將它們結合成一個噪聲物體時

00:16:15.275 --> 00:16:19.046
我們而後可以對隱含的
一個區域的噪聲地圖 噪聲函數取樣

00:16:19.346 --> 00:16:23.550
在噪聲地圖中 我們獲取採樣
然後製作我們的遊戲內容

00:16:25.452 --> 00:16:28.355
讓我們再深入一下
聊聊我們的噪聲源

00:16:29.056 --> 00:16:32.793
現在 我們所有的噪聲源
輸出值在負1與1之間

00:16:32.926 --> 00:16:35.162
我們一會針對這個再多說一些

00:16:36.263 --> 00:16:39.032
它們接收參數來調整
它們的不同的噪聲輸出

00:16:39.099 --> 00:16:40.934
在這些噪聲函數之下

00:16:41.068 --> 00:16:44.104
所以對於我們隨機性與一致性
較強的噪聲源 如Perlin和Voronoi

00:16:44.171 --> 00:16:46.507
它們可以使用
GKRandomSource作爲種子

00:16:46.573 --> 00:16:49.943
它們可以接收一系列參數
來調整它們隱含的模式

00:16:50.711 --> 00:16:53.981
對於偏幾何的噪聲源
可以接收參數來修改形狀

00:16:54.047 --> 00:16:58.852
比如球體和圓柱體的尺寸
或是脊與巨浪的頻率

00:17:00.954 --> 00:17:02.556
一旦我們有了合適的噪聲源

00:17:02.623 --> 00:17:04.758
我們就可將它們結合
爲一個GKNoiseObject

00:17:05.659 --> 00:17:10.063
它擁有所有必要的函數
以進行變換 組合和修改

00:17:10.130 --> 00:17:12.398
我們的噪聲源
以及許多常用的數學

00:17:12.465 --> 00:17:14.535
與支持的邏輯操作

00:17:14.867 --> 00:17:18.571
如果我嘗試組合噪聲源
我可以做加法 乘法 取最大最小值

00:17:19.439 --> 00:17:21.040
但若我要變換單一的噪聲源時

00:17:21.108 --> 00:17:23.410
我可以縮放、旋轉、變換

00:17:23.477 --> 00:17:27.013
或者我可以通過取絕對值
取極限 取相反數來進行修改

00:17:29.383 --> 00:17:31.351
一旦我們找到了喜歡的噪聲

00:17:31.418 --> 00:17:34.188
而後我們可以對該噪聲的
一個區域進行取樣

00:17:34.254 --> 00:17:37.357
對隱含的噪聲函數
通過一個GKNoiseMap對象

00:17:38.258 --> 00:17:39.893
你指定一個起源與尺度

00:17:39.960 --> 00:17:43.096
這就是我們要取樣的
隱含的噪聲圖的區域

00:17:43.163 --> 00:17:44.731
你還需要指定一個樣本數量

00:17:44.798 --> 00:17:47.301
我們要在這個區域中
對該噪聲函數進行幾次取樣？

00:17:47.367 --> 00:17:49.770
我取樣的保真度是多高？

00:17:51.171 --> 00:17:53.207
當我們對區域完成取樣後

00:17:53.273 --> 00:17:56.343
我們就可以獲得該噪聲圖
上任意位置的值

00:17:56.410 --> 00:17:59.880
再說一次 我剛纔提到了
範圍是負1到1

00:18:00.314 --> 00:18:02.816
在運行時 你可以選擇
按需覆蓋某些值

00:18:02.883 --> 00:18:03.984
若你的遊戲世界改變

00:18:05.886 --> 00:18:07.120
這些理解起來並不輕鬆

00:18:07.187 --> 00:18:10.224
我認爲解釋清楚這些的
最佳方式是給出視覺例子

00:18:11.191 --> 00:18:13.727
假設我要爲我的遊戲
隨機生成一個地圖

00:18:14.094 --> 00:18:16.797
我要根據地球的生物
羣系來對其建立模型

00:18:16.930 --> 00:18:18.432
我想讓它看起來很真實

00:18:18.498 --> 00:18:21.668
沙漠 樹林 北極區
諸如此類

00:18:23.437 --> 00:18:25.772
第一 這是你爲了完成需求
可以使用的一種方法

00:18:25.839 --> 00:18:28.075
這裏我生成了兩個Perlin噪聲圖

00:18:29.843 --> 00:18:31.512
我將左邊的稱爲溼度圖

00:18:31.578 --> 00:18:33.981
在我的遊戲世界的任何一點
我都可以找到這張圖

00:18:34.047 --> 00:18:37.017
來決定我的遊戲世界應有
多潮溼或說多幹燥

00:18:37.885 --> 00:18:39.753
我將右邊的圖稱爲溫度圖

00:18:39.820 --> 00:18:42.656
在我的遊戲世界的任意一點
我可以找到這張圖

00:18:43.056 --> 00:18:45.626
來決定我的遊戲世界
有多熱或說有多冷

00:18:47.294 --> 00:18:49.229
在這裏需要提到
我們將來還要回到這裏

00:18:49.296 --> 00:18:53.133
在溼度圖中 你可以看到
我在右側有一個很乾燥的點

00:18:53.200 --> 00:18:56.170
那就是黑斑
是左側的一個很乾燥的區域

00:18:56.470 --> 00:18:59.206
再說一次 這些顏色
代表我所說的輸出

00:18:59.273 --> 00:19:03.610
這裏黑色是負1
白色是正1

00:19:05.045 --> 00:19:07.214
在右側 注意到我
在頂部有一個很冷的點

00:19:07.281 --> 00:19:08.415
那又是一個黑斑

00:19:08.482 --> 00:19:11.885
還有一個很熱的
在我的噪聲圖的右側

00:19:13.720 --> 00:19:16.423
我要指定在組合這些
時的一些規則

00:19:16.490 --> 00:19:18.158
以對我的遊戲產生意義

00:19:18.992 --> 00:19:20.294
這裏我有一個簡單2D圖

00:19:20.360 --> 00:19:25.532
在縱軸中 我有溼度
在橫軸中是溫度

00:19:26.166 --> 00:19:30.103
我可以使用這些規則
來決定這兩個圖的交界

00:19:30.170 --> 00:19:33.140
如果我有一個點
它有很高的溫度和很低的溼度

00:19:33.207 --> 00:19:35.242
我就會獲得一個沙漠

00:19:35.576 --> 00:19:38.078
或者如果我有一個點
溫度很高 溼度很高

00:19:38.145 --> 00:19:39.913
我就會獲得一個熱帶雨林

00:19:40.314 --> 00:19:42.449
所以在這裏
在冷的那一端

00:19:42.516 --> 00:19:44.351
我有凍土和北極區

00:19:44.551 --> 00:19:47.187
在中間 我有更加溫和的地帶

00:19:47.254 --> 00:19:49.623
比如森林 大草原和牧場

00:19:51.525 --> 00:19:54.695
這兩個圖一起使用
我基於這些規則將它們組合

00:19:56.029 --> 00:19:57.364
就獲得了這樣的東西

00:19:58.532 --> 00:20:02.336
你可以看到它有一個
很好很真實的感覺 還有一點

00:20:02.402 --> 00:20:04.304
在右側 可以看到我們有很大的沙漠

00:20:04.371 --> 00:20:07.708
漸漸變爲牧場
而後變爲森林地區

00:20:08.108 --> 00:20:10.811
這與我們溼度圖的乾燥點相符

00:20:10.911 --> 00:20:13.080
以及在我們的溫度圖
中的那個很熱的點

00:20:13.814 --> 00:20:15.649
在左上方 你看到我們有

00:20:15.716 --> 00:20:17.651
一個很大的凍土與冰冷的點

00:20:18.151 --> 00:20:21.522
在右上方與左下方
我們有一些小的熱帶雨林

00:20:21.588 --> 00:20:24.391
與很高的溫度與溼度相符

00:20:26.260 --> 00:20:29.029
所以這只是很基本的例子
有關你可以完成的很酷的東西

00:20:29.096 --> 00:20:30.264
通過過程生成

00:20:30.330 --> 00:20:32.165
這裏我們只使用了兩個簡單的噪聲圖

00:20:32.232 --> 00:20:36.170
並通過很簡單的規則將它們組合
獲得了很漂亮很好的結果

00:20:38.438 --> 00:20:40.374
我想邀請同事
Michael Brennan上臺

00:20:40.440 --> 00:20:42.342
來向大家分享遊戲AI中的新特性

00:20:42.442 --> 00:20:43.277
Michael？

00:20:49.950 --> 00:20:51.084
謝謝 Bruno

00:20:51.718 --> 00:20:53.453
大家好
我是Michael Brennan

00:20:53.520 --> 00:20:56.023
我是Apple的遊戲技術工程師

00:20:56.190 --> 00:20:57.558
我很高興今天能與大家分享

00:20:58.091 --> 00:21:00.794
我們爲遊戲AI在
GameplayKit中進行更新

00:21:03.497 --> 00:21:06.900
去年與GameplayKit一起
我們介紹了Minmax策略

00:21:07.367 --> 00:21:10.103
這是一個對於各種遊戲的
很棒的AI方案

00:21:10.537 --> 00:21:13.907
可以保證對你的遊戲狀態
有最佳的搜索

00:21:15.309 --> 00:21:18.445
它之所以能保證
是通過對狀態空間進行大量搜索

00:21:18.879 --> 00:21:24.051
同時組合你對遊戲中每種狀態
所提供的得分函數

00:21:24.117 --> 00:21:28.088
來提供給你你的一個實體
在某一點的最佳行爲

00:21:29.089 --> 00:21:31.024
但是Minmax策略的高消耗本質

00:21:31.091 --> 00:21:35.262
使它對於那些狀態空間較大
的遊戲並不合適

00:21:35.362 --> 00:21:37.297
比如圍棋和象棋

00:21:38.832 --> 00:21:43.237
這就是爲何今年我很高興向大家
介紹Monte Carlo策略

00:21:44.505 --> 00:21:48.041
Monte Carlo策略是一個對
狀態空間的最佳首次搜索

00:21:48.108 --> 00:21:51.044
與對狀態空間的隨機取樣結合

00:21:51.111 --> 00:21:53.780
來計算出你的對手的最佳行爲

00:21:55.015 --> 00:21:57.718
它完成這一點
是通過首先選擇一個玩家行爲

00:21:58.151 --> 00:22:02.122
使用勘探開採算法
來選擇該行爲

00:22:02.789 --> 00:22:05.392
然後從該行爲開始
模擬新的遊戲

00:22:05.692 --> 00:22:09.596
直到它達到結束狀態
不論是勝利 失敗或是平局

00:22:10.097 --> 00:22:12.533
而後繼續沿着樹迭代

00:22:15.202 --> 00:22:18.939
它不能保證如Minmax一樣
的最佳行爲

00:22:19.006 --> 00:22:21.308
但是它趨近於最佳行爲

00:22:23.877 --> 00:22:25.612
Monte Carlo策略速度快

00:22:25.746 --> 00:22:28.615
它能保證很好的表現
即使是對一些遊戲

00:22:28.682 --> 00:22:31.585
有很大的狀態空間
比如說圍棋

00:22:32.319 --> 00:22:34.821
由於它只需要最終情況

00:22:35.322 --> 00:22:37.491
這需要讓你的遊戲提供

00:22:37.691 --> 00:22:39.793
這在你的遊戲中很容易實現

00:22:40.460 --> 00:22:41.895
它幾乎是最佳的

00:22:41.962 --> 00:22:45.098
雖然它可能不是Minmax
所找到的最佳行爲

00:22:45.165 --> 00:22:49.002
它們幾乎是一樣的
並且會隨着時間增加越來越趨近

00:22:52.139 --> 00:22:54.041
讓我們說說你需要
用到的元素

00:22:54.208 --> 00:22:56.076
來在你的遊戲中集成這一點

00:22:57.144 --> 00:22:59.913
使用GKMonteCarloStrategist時
你需要提供一個預算

00:23:00.180 --> 00:23:03.317
這是它完成我們剛纔說到的
四個步驟所要花費的時間

00:23:03.951 --> 00:23:06.687
你需要提供探索參數

00:23:06.753 --> 00:23:10.157
現在 這是一個在0與1之間
的值 代表要不要

00:23:10.224 --> 00:23:13.794
選擇一個行爲時
探索沒有到達過的節點

00:23:14.461 --> 00:23:18.932
或是你想讓它開拓
它去過與發現的節點來最大化優勢

00:23:19.833 --> 00:23:21.635
你當然還需要提供遊戲模型

00:23:21.702 --> 00:23:25.539
若你使用過GKMinmaxStrategist
你就應該對這很熟悉了

00:23:26.874 --> 00:23:28.475
現讓我們看一很簡單的代碼示例

00:23:29.543 --> 00:23:31.745
獲取了遊戲模型
GoGameModel

00:23:31.812 --> 00:23:33.547
我們要持有它的一個引用

00:23:33.614 --> 00:23:34.948
及我們的Monte Carlo策略

00:23:35.015 --> 00:23:37.384
我們要將其實例化
並持有一個引用

00:23:37.918 --> 00:23:40.387
我們先設置Monte Carlo
策略遊戲模型

00:23:40.454 --> 00:23:42.256
來指向我們的遊戲模型

00:23:43.590 --> 00:23:45.359
下一步 我們要對其指定預算

00:23:45.626 --> 00:23:46.727
設置在100左右

00:23:46.793 --> 00:23:51.231
這意味着它要完成四個步驟
模擬與迭代100次

00:23:51.565 --> 00:23:53.467
然後我們要將探索
參數設置爲1

00:23:53.534 --> 00:23:56.203
這意味着我們想讓它
儘可能地探索

00:23:58.438 --> 00:24:01.842
然後我們只需要獲取
活動玩家的最佳行爲

00:24:01.909 --> 00:24:06.346
在該遊戲狀態中 找到最佳行爲
並將其應用到遊戲模型中

00:24:06.613 --> 00:24:07.748
就是這麼簡單

00:24:09.850 --> 00:24:12.019
今年 我很激動地告訴大家
我們還允許

00:24:12.085 --> 00:24:13.554
製作自己自定義的策略

00:24:14.488 --> 00:24:16.890
我們實現了新協議
叫GKStrategist

00:24:16.957 --> 00:24:19.560
你只需要遵守它
給出遊戲模型

00:24:19.626 --> 00:24:21.728
遊戲模型更新與遊戲模型玩家

00:24:22.829 --> 00:24:25.766
並實現找到玩家的最佳行爲

00:24:25.999 --> 00:24:30.637
你可以使用這個策略
就像你使用我我們提供的策略一樣

00:24:32.639 --> 00:24:33.941
這就是我們在策略方面提供的新功能

00:24:34.007 --> 00:24:35.542
現在讓我們說點別的

00:24:36.243 --> 00:24:37.244
決策制定

00:24:40.113 --> 00:24:42.149
有許多方法來對你的
遊戲中的邏輯建模

00:24:42.316 --> 00:24:44.818
其中許多已經被
GameplayKit所支持

00:24:45.552 --> 00:24:49.356
你的敵人需要制定決策
來考慮大量的狀態

00:24:49.423 --> 00:24:51.825
他們需要能很快的
制定決策

00:24:53.126 --> 00:24:55.762
你可以在這裏看到
我們有這個很小的按鈕跳躍遊戲

00:24:56.230 --> 00:24:59.099
就算是在這個簡單的遊戲中
你的對手需要考慮

00:24:59.199 --> 00:25:02.469
你的位置 其他敵人的位置
和按鈕的位置

00:25:02.703 --> 00:25:04.638
在某個時間點誰
擁有按鈕

00:25:04.705 --> 00:25:07.174
他們是否在跳躍
敵人是否在跳躍

00:25:07.608 --> 00:25:08.809
他們在一層的哪個位置

00:25:08.876 --> 00:25:10.444
還是要考慮不少事情的

00:25:12.980 --> 00:25:16.250
一個簡單的制定決策的
方法是決策樹

00:25:16.817 --> 00:25:20.420
它們是樹狀的數據結構
使決策更易於觀察與除錯

00:25:20.954 --> 00:25:22.923
它們可以是製作的
或是學習得到的

00:25:25.859 --> 00:25:30.130
GKDecisionTree讓你在
決定行爲時能有較小的開銷

00:25:30.797 --> 00:25:32.900
它是完全可序列化的
靈活性也很強

00:25:33.300 --> 00:25:34.735
允許你創造節點

00:25:34.801 --> 00:25:38.105
能隨機進行決策
並對分支委派權重

00:25:38.172 --> 00:25:41.675
或是基於特定分支的值
如果這個值是真或假的話

00:25:41.742 --> 00:25:43.544
或是均等的滿足描述

00:25:43.610 --> 00:25:46.180
它非常的靈活
允許你完成許多事情

00:25:48.382 --> 00:25:49.983
讓我們看一個簡單的代碼示例

00:25:50.851 --> 00:25:52.452
你可以在這裏看到
我們有一個樹

00:25:52.519 --> 00:25:54.821
我們要通過一個根元素
對它進行初始化

00:25:54.888 --> 00:25:56.557
查詢是否我們接近按鈕

00:25:57.724 --> 00:26:00.327
然後我們要獲取該根元素節點
的引用以備後用

00:26:01.962 --> 00:26:05.432
在此之後 我們只需要從
該根元素出發創建分支

00:26:05.499 --> 00:26:11.004
一個是我們接近該按鈕的情況
這種情況下我們就要跳

00:26:11.138 --> 00:26:14.708
另一個是我們並不接近的情況
這種情況下我們要選擇遊走

00:26:14.942 --> 00:26:17.578
我們也要獲取到該
遊走節點的引用

00:26:19.179 --> 00:26:21.582
通過那個遊走節點
我們就可以創建一些分支

00:26:21.782 --> 00:26:25.185
一個權重是9
意爲在該點向左走

00:26:25.252 --> 00:26:26.620
另一權重是1
意爲我們要向右走

00:26:26.687 --> 00:26:27.554
現在 這個權重是疊加的

00:26:27.621 --> 00:26:31.625
意思是對於左側分支而言
我們走的權重是9

00:26:31.692 --> 00:26:35.329
因爲總權重是10
所以向左走的概率是90%

00:26:35.696 --> 00:26:38.599
向右走則有10%的概率發生

00:26:40.801 --> 00:26:43.637
然後我們要將狀態
打包到字典中

00:26:43.770 --> 00:26:47.608
並將其傳入樹的findActionForAnswers
方法來獲得我們的行爲

00:26:49.510 --> 00:26:51.311
決策樹也可以被建模

00:26:51.678 --> 00:26:53.714
你只需要提供遊戲數據

00:26:54.114 --> 00:26:56.817
它就會在數據中尋找到
進行決策的行爲

00:26:56.884 --> 00:26:59.853
並對該制定決策的行爲
找到一個合適的樹

00:27:01.922 --> 00:27:05.392
在我們的方陣中你可以看到
最上的一行是深灰色的

00:27:05.559 --> 00:27:06.793
那就是屬性

00:27:07.294 --> 00:27:09.663
內部的矩陣是我們的樣例

00:27:10.063 --> 00:27:12.999
那就是我們在遊戲中
不同的遊戲點的樣子

00:27:13.433 --> 00:27:16.303
在右側 我們有進行的動作

00:27:16.470 --> 00:27:19.406
這只是我們在遊戲的不同點
中進行的操作

00:27:20.574 --> 00:27:23.210
你將它傳入GKDecisionTree
的構造方法中

00:27:23.377 --> 00:27:26.980
它就會找到一個決策樹
來適應你所記錄的遊戲數據

00:27:28.815 --> 00:27:30.851
讓我們看看這在遊戲中的樣子

00:27:33.053 --> 00:27:37.357
這裏我有一個玩家
淺綠色到青綠色的玩家

00:27:37.424 --> 00:27:38.792
對抗深藍色玩家

00:27:38.859 --> 00:27:41.094
使用我們剛纔展示的
手動創建的決策樹

00:27:41.195 --> 00:27:43.130
如你所見 它遺漏掉了一些

00:27:43.197 --> 00:27:45.032
我們進行的操作
這樣我們表現會變好

00:27:47.167 --> 00:27:48.902
讓我們看另一個例子

00:27:49.670 --> 00:27:53.841
這裏你可以看到它的行爲
更像我們剛纔的行爲

00:27:54.308 --> 00:27:56.476
如我所說 你只需要記錄
你的遊戲數據

00:27:56.543 --> 00:27:59.947
將其傳入 你就能模擬行爲
就像你自己的行爲一樣

00:28:02.082 --> 00:28:04.751
即在GameplayKit中
今年新引入的遊戲AI

00:28:05.219 --> 00:28:07.054
它很棒
我很激動能與大家分享

00:28:07.120 --> 00:28:10.123
現在我要邀請我的同事
Sri Nair上臺

00:28:10.190 --> 00:28:13.093
介紹更多有關Xcode
集成Gameplay

00:28:13.727 --> 00:28:14.595
Sri？

00:28:18.765 --> 00:28:19.766
謝謝Michael

00:28:22.236 --> 00:28:23.136
大家好

00:28:23.770 --> 00:28:24.838
我是Sri Nair

00:28:24.905 --> 00:28:27.608
我是Apple的一個遊戲技術工程師

00:28:30.110 --> 00:28:32.446
去年介紹GameplayKit時

00:28:32.946 --> 00:28:35.082
它只能由代碼驅動

00:28:36.016 --> 00:28:38.485
你需要創建構造器
完成所有的連接工作

00:28:39.353 --> 00:28:42.289
並改變屬性和值
全在代碼中完成

00:28:43.257 --> 00:28:46.193
這可能會很低效
原因顯而易見

00:28:47.628 --> 00:28:51.031
我很高興能告訴大家
我們對這個問題進行了優化

00:28:51.398 --> 00:28:55.102
通過向GameplayKit引入
更加由數據驅動的工作流

00:28:56.003 --> 00:28:59.173
通過在Xcode和
SpriteKit編輯器中集成它

00:29:00.707 --> 00:29:04.545
如你所知 編輯器整合
可以更快的提高

00:29:04.611 --> 00:29:06.647
你的遊戲功能的體驗

00:29:07.881 --> 00:29:10.384
它們還有助於分離
工程師工作流

00:29:10.551 --> 00:29:11.952
和設計工作流

00:29:14.388 --> 00:29:17.324
所以現在編輯器有
四個主要的新特性

00:29:17.457 --> 00:29:19.826
幫大家加速
GameplayKit開發

00:29:21.295 --> 00:29:23.764
第一個 實體和組件編輯器

00:29:24.765 --> 00:29:26.767
第二個 導航圖編輯器

00:29:27.301 --> 00:29:29.236
第三個 場景輪廓視圖

00:29:29.970 --> 00:29:32.005
第四個 狀態機快速查看

00:29:32.940 --> 00:29:35.375
讓我們細說這四個特性

00:29:35.909 --> 00:29:37.511
什麼是組件編輯器呢？

00:29:38.545 --> 00:29:42.516
讓我們回想一下
實體和組件系統是一個設計模式

00:29:43.417 --> 00:29:45.986
其中一個遊戲物體是通過實體展示

00:29:46.520 --> 00:29:51.225
而它們的行爲則是通過
更小的獨立組件展示

00:29:52.025 --> 00:29:55.395
這能提供更好的代碼架構
與代碼易用性

00:29:56.463 --> 00:30:00.334
它們也會更易於維護和擴展

00:30:01.502 --> 00:30:06.440
所以現在通過組件編輯器
你可以將實體與組件賦給

00:30:06.507 --> 00:30:08.308
在編輯器中的節點

00:30:10.177 --> 00:30:13.280
並在編輯器中修改屬性
編輯器提供

00:30:13.380 --> 00:30:15.916
一個基於編輯器的
數據驅動的工作流

00:30:17.918 --> 00:30:21.255
編輯器與代碼緊密整合

00:30:21.321 --> 00:30:24.992
並支持組件類和屬性的自動查找

00:30:25.559 --> 00:30:28.996
舉個例子 假設你要寫一個
運動組件類

00:30:29.296 --> 00:30:31.965
它派生自GKComponent
添加了幾個屬性

00:30:32.199 --> 00:30:36.136
並由新引入的
GKInspectableKeyword註解

00:30:36.537 --> 00:30:38.472
來展示在UI中

00:30:39.907 --> 00:30:43.710
組件編輯器會自動探測到

00:30:43.777 --> 00:30:46.280
這些你已經添加並展示在
UI中的組件

00:30:46.346 --> 00:30:49.683
現在你只需要選擇你需要的組件

00:30:49.750 --> 00:30:51.285
並賦給節點

00:30:52.085 --> 00:30:56.023
一旦你添加了組件
屬性就被自動填充了

00:30:57.291 --> 00:30:59.126
基於相應的數據類型

00:30:59.993 --> 00:31:03.530
現在你只需修改這些屬性
並在編輯器中直接預覽變更

00:31:03.864 --> 00:31:06.133
無需退出編輯器

00:31:06.200 --> 00:31:09.136
或是重新編輯代碼
來使遍歷更快

00:31:11.538 --> 00:31:16.677
並且這些所有的更新
都保存在SKS文件下的一個JKC中

00:31:18.145 --> 00:31:21.815
所有未被改變的屬性值
都使用默認設置代碼

00:31:23.784 --> 00:31:27.788
與節點連接相關聯的GKEntity
是在後臺生成的

00:31:27.855 --> 00:31:29.790
通過一個GKSKComponent

00:31:31.491 --> 00:31:34.628
UI支持所有的
常用屬性類型

00:31:34.862 --> 00:31:37.631
比如浮點 整形 布爾等等

00:31:40.067 --> 00:31:41.235
這就是組件編輯器了

00:31:41.301 --> 00:31:44.004
現在 讓我們繼續說
導航圖編輯器

00:31:45.172 --> 00:31:46.607
Bruno剛纔提到了

00:31:46.673 --> 00:31:50.410
導航圖 也就是GKGraph
是用於尋路的目的

00:31:51.011 --> 00:31:54.848
來找到一個物體從A到B的最佳路徑

00:31:56.884 --> 00:31:59.353
通過導航圖編輯器

00:31:59.820 --> 00:32:02.556
現在你可以直接在
編輯器中創建GKGraph

00:32:03.490 --> 00:32:08.095
你可以添加或修改節點
在其間添加連接

00:32:08.161 --> 00:32:10.831
只需要在一個窗口中
點擊並拖拽

00:32:12.032 --> 00:32:15.569
這些GKGraph保存在
GKScene中

00:32:15.636 --> 00:32:18.672
你可以在之後通過代碼獲取
並用於尋路

00:32:21.441 --> 00:32:25.646
還有一個我們在SpriteKit編輯器中
一個很有用的特性

00:32:25.712 --> 00:32:28.749
對Gameplay Kit
開發也很有用

00:32:28.815 --> 00:32:30.484
叫做場景輪廓視圖

00:32:33.220 --> 00:32:37.257
它繪出場景元素的輪廓
它們的父子層級關係

00:32:39.226 --> 00:32:42.729
這裏支持大多數
標準的操作

00:32:42.796 --> 00:32:47.534
比如添加 編輯 重排 刪除等等

00:32:49.736 --> 00:32:53.440
你在你的場景中添加的導航圖
也會在這裏展示

00:32:53.507 --> 00:32:55.075
在場景輪廓圖中

00:32:56.743 --> 00:33:00.914
它還可以用於鎖定節點
與修改可見性

00:33:01.415 --> 00:33:05.752
它同時附帶一個上下文菜單
來進行選項特定的操作

00:33:06.153 --> 00:33:07.187
很好用

00:33:08.622 --> 00:33:11.859
最後同樣重要的
狀態機快速查看

00:33:13.427 --> 00:33:16.630
回憶一下 我們去年
引入了GKStateMachine

00:33:16.697 --> 00:33:21.168
它允許你在遊戲中
表示一種執行流

00:33:21.401 --> 00:33:23.537
它在遊戲中有許多應用

00:33:23.604 --> 00:33:27.841
比如AI、動畫、UI、
等級序列等等

00:33:29.510 --> 00:33:32.980
直到現在
你都不能預覽

00:33:33.046 --> 00:33:35.082
這些狀態機的樣子

00:33:36.316 --> 00:33:39.553
很難理解這些狀態之間的關聯

00:33:39.620 --> 00:33:43.757
執行流 或是其當前所在的狀態

00:33:44.324 --> 00:33:48.428
爲了解決這個問題
我們整合了一個狀態機預覽工具

00:33:49.263 --> 00:33:52.299
直接在Xcode Debugger
的快速查看功能中

00:33:53.800 --> 00:33:55.802
這允許你在代碼中設置斷點

00:33:56.103 --> 00:34:01.942
在你想查看狀態機的地方
並點擊快速查看圖標

00:34:02.109 --> 00:34:06.313
就會彈出一個當前狀態機
的視覺展示

00:34:06.847 --> 00:34:08.982
它會展示狀態
以及其間關聯

00:34:09.049 --> 00:34:11.083
當前的狀態被高亮

00:34:13.387 --> 00:34:17.958
這裏有幾個關於快速查看
狀態機的例子

00:34:21.594 --> 00:34:26.733
通過這些 我想演示
GameplayKit中 基於編輯器的工作流

00:34:35.108 --> 00:34:40.080
這裏我要搭建一個簡單的遊戲

00:34:40.147 --> 00:34:45.752
其中一個玩家撿起氣球
將其塗色並扔到敵人那裏

00:34:45.819 --> 00:34:51.358
這是由遊戲AI模擬的
敵人也可以做同樣的事

00:34:51.425 --> 00:34:54.127
所以我們有一個基本的場景

00:34:54.194 --> 00:34:56.196
你可以在場景輪廓視圖中看到

00:34:56.463 --> 00:35:00.534
我們有一個背景和一個玩家
和一些氣球

00:35:02.903 --> 00:35:07.407
所以首先 我們要嘗試添加
這很簡單 沒有進行什麼行爲

00:35:08.141 --> 00:35:09.443
這是一個很靜態的場景

00:35:09.510 --> 00:35:13.747
我們通過使用鍵盤向玩家
添加一些行爲作爲開始

00:35:14.281 --> 00:35:16.950
對於這一點 我已經添加了一些組件

00:35:17.050 --> 00:35:20.621
我們要看看剛纔提到的
行動組件

00:35:20.687 --> 00:35:24.758
有幾個屬性來幫助行動
比如速度

00:35:25.392 --> 00:35:26.960
摩擦 加速等等

00:35:27.160 --> 00:35:30.764
你使用GKInspectable
對其註解

00:35:30.831 --> 00:35:34.168
這樣你就可以在以後
在UI中處理這些屬性

00:35:35.202 --> 00:35:37.738
類似的 我又一個玩家輸入組件

00:35:38.338 --> 00:35:43.911
我們要將這些賦值給玩家

00:35:43.977 --> 00:35:47.781
通過進入場景
並在組件編輯器中尋找

00:35:47.848 --> 00:35:50.517
在右側檢查區中

00:35:50.584 --> 00:35:53.187
我有一個新引入的組件編輯器

00:35:53.487 --> 00:35:57.991
現在 我可以選擇玩家
並點擊加按鈕

00:35:58.058 --> 00:36:00.494
來將這些組件添加到節點

00:36:00.561 --> 00:36:04.498
我們下面要添加用戶輸入組件

00:36:04.831 --> 00:36:06.633
與運動組件

00:36:09.703 --> 00:36:12.973
而後我們會看到結果

00:36:13.040 --> 00:36:18.278
我期待用戶可以通過鍵盤移動

00:36:18.345 --> 00:36:23.317
太棒了 它可以在任何方向運動

00:36:23.851 --> 00:36:26.453
除了可以之外
你還能發現它不會在邊界停下來

00:36:26.520 --> 00:36:29.790
因爲我沒有對玩家
添加任何碰撞

00:36:30.324 --> 00:36:32.759
但我的確添加了一個
碰撞組件

00:36:32.826 --> 00:36:36.263
它主要是給玩家節點
添加了物理軀體

00:36:36.330 --> 00:36:41.168
我下面要將其賦給玩家

00:36:41.768 --> 00:36:45.072
在完成這一點的同時
我還要賦一個戰鬥組件

00:36:45.138 --> 00:36:49.109
我已經添加過了
能允許你撿起氣球並扔出

00:36:49.710 --> 00:36:53.747
讓我們看看它的樣子

00:36:57.217 --> 00:37:00.354
太好了 現在我可以撿起氣球
而且它在邊界處停止了

00:37:00.420 --> 00:37:01.488
這很棒

00:37:02.589 --> 00:37:04.258
我們下面要對敵人
進行同樣的操作

00:37:04.324 --> 00:37:08.996
未完成這一點
我在場景中創建了一個敵人物體

00:37:09.062 --> 00:37:11.965
但我將其設爲不可見了

00:37:12.032 --> 00:37:15.235
所以我要在場景輪廓視圖中
設其爲可見

00:37:15.969 --> 00:37:19.473
而後將組件賦值給敵人

00:37:19.606 --> 00:37:22.743
在這裏 區別在於
它是一個敵人輸入組件

00:37:22.809 --> 00:37:25.712
這樣它就使用遊戲AI
而不是使用鍵盤

00:37:26.513 --> 00:37:30.984
類似地 運動組件 碰撞組件

00:37:31.051 --> 00:37:32.686
以及戰鬥組件

00:37:34.855 --> 00:37:39.092
有了這些 我會期待敵人也會

00:37:39.159 --> 00:37:44.097
撿起氣球並

00:37:45.999 --> 00:37:47.367
啊 它贏了我

00:37:47.434 --> 00:37:49.636
這對它太簡單了

00:37:49.703 --> 00:37:52.506
但我們要讓遊戲更加有趣

00:37:52.573 --> 00:37:58.278
通過一個繪製的物體
向場景中投落一些氣球

00:37:58.345 --> 00:38:05.085
所以我有一個繪製的物體
我要將其在場景中設爲可見

00:38:06.553 --> 00:38:09.389
而後添加繪製組件

00:38:09.590 --> 00:38:16.597
能沿一個確定的路徑
投落氣球

00:38:16.830 --> 00:38:20.534
我想要向場景中
添加一個導航圖

00:38:21.034 --> 00:38:23.437
這就像進入物體庫並輸入

00:38:23.504 --> 00:38:26.340
“導航圖”一樣簡單

00:38:26.607 --> 00:38:31.111
現在 你可以簡單的將
導航圖拖拽到場景中

00:38:31.178 --> 00:38:37.017
我們要把導航圖稍稍放大
來解釋這個新特性

00:38:38.051 --> 00:38:40.120
這就是導航圖編輯器

00:38:45.058 --> 00:38:48.262
在我們操作它的同時
我們要修改一些屬性

00:38:49.329 --> 00:38:55.369
我們要設置玩家的健康爲2
還要設置運動

00:38:57.070 --> 00:39:01.708
稍稍加速 讓玩家稍稍佔優勢
只是一個第一等級

00:39:02.176 --> 00:39:06.914
你好歹也是有了一些優勢
敵人的健康值也是2

00:39:08.215 --> 00:39:12.853
讓我們看看結果

00:39:16.490 --> 00:39:19.526
你知道 你可以看到飛機
扔下的氣球

00:39:19.593 --> 00:39:21.662
比如能撿起來扔出去的多

00:39:24.031 --> 00:39:27.301
他贏了我一次 我也贏了一次
讓我們看看

00:39:28.769 --> 00:39:30.137
好 好了

00:39:30.971 --> 00:39:34.308
我確定我的兒子
玩這個遊戲時會很高興

00:39:35.475 --> 00:39:37.578
這解釋了

00:39:38.478 --> 00:39:41.181
GameplayKit中新的
基於編輯器的工作流

00:39:41.315 --> 00:39:42.983
讓我們切換回幻燈片

00:39:45.953 --> 00:39:47.387
來回放一下本期

00:39:51.225 --> 00:39:53.493
今年 我們介紹了很多引人入勝的

00:39:53.727 --> 00:39:55.629
有用的GameplayKit特性

00:39:56.763 --> 00:40:00.567
在最開始 Bruno分享了
新的空間劃分系統

00:40:00.634 --> 00:40:02.903
來在你的遊戲中進行
高效的空間查詢

00:40:04.271 --> 00:40:08.909
新的過程生成系統
使用不同的噪聲函數

00:40:08.976 --> 00:40:11.345
來在你的遊戲中創建
更加動態的內容

00:40:11.745 --> 00:40:16.617
同時對諸如尋路與代理
等現存系統也有提升

00:40:18.285 --> 00:40:21.488
Michael分享了有關
遊戲AI的新特性

00:40:21.755 --> 00:40:25.459
通過遊戲策略和決策樹

00:40:26.527 --> 00:40:30.397
最後我介紹了新引入的
基於編輯器的工作流

00:40:30.664 --> 00:40:32.799
在GameplayKit中
帶來更快遍歷

00:40:33.667 --> 00:40:35.335
希望大家認爲這些新特性很有用處

00:40:35.402 --> 00:40:38.071
我們已經等不及看到
大家下一步的成果了

00:40:39.606 --> 00:40:43.410
這是以後再看這段分享的URL

00:40:43.577 --> 00:40:45.879
608就是本場演講的編號

00:40:47.247 --> 00:40:50.384
還有相關技術的其它演講

00:40:50.450 --> 00:40:51.818
你可能感興趣參加

00:40:51.885 --> 00:40:55.923
SpriteKit、SceneKit、
Rendering、Game Center的新特性

00:40:55.989 --> 00:40:58.058
及Apple Watch的遊戲技術

00:40:59.593 --> 00:41:00.427
感謝大家前來

00:41:00.494 --> 00:41:02.629
我們希望大家在餘下的演講中
度過愉快時光