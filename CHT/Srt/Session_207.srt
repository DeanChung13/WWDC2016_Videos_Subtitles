00:00:19.453 --> 00:00:23.524
Swift Foundation
的新特性

00:00:32.165 --> 00:00:33.033
謝謝

00:00:34.801 --> 00:00:36.904
大家好 歡迎
我是Tony Parker

00:00:36.970 --> 00:00:38.772
我在Apple帶領
Foundation團隊

00:00:38.839 --> 00:00:41.241
今天我在這裏和
Michael LeHew一起討論

00:00:41.308 --> 00:00:42.976
Swift Foundation
的新特性

00:00:44.678 --> 00:00:46.847
這一年來Foundation團隊
付出了很大的努力

00:00:46.914 --> 00:00:49.049
改善你使用Cocoa的方式

00:00:49.116 --> 00:00:51.318
以及Swift中
Cocoa Touch的API

00:00:51.785 --> 00:00:54.488
從Swift API設計指引開始

00:00:55.088 --> 00:00:57.524
隨後 我們研究了
所有Objective-C的代碼

00:00:57.591 --> 00:01:01.428
包括Cocoa SDK使用及
你自己編寫的代碼如何引入Swift

00:01:02.496 --> 00:01:04.131
但是我們知道
我們可以做到更好

00:01:04.197 --> 00:01:07.868
所以 我們引入了一套新的
值類型到Foundation裏

00:01:08.335 --> 00:01:12.005
同時也引入了大量
很棒的針對Swift的新API

00:01:13.207 --> 00:01:15.509
我們繼續從設計指引開始

00:01:17.144 --> 00:01:19.313
我們今年的工作
圍繞着Swift 3 但是

00:01:19.446 --> 00:01:21.949
我們最初設計Swfit的目標
一直沒有變

00:01:22.416 --> 00:01:26.119
我們希望你編寫的代碼
快速 安全 表達性強

00:01:26.854 --> 00:01:28.755
我們創建了標準庫

00:01:28.822 --> 00:01:30.991
以及圍繞這些核心思想的
編程語言

00:01:31.458 --> 00:01:34.228
你們很多人也都
理解了這些原則

00:01:34.428 --> 00:01:36.230
並且根據它們
建立了自己的應用程序

00:01:36.830 --> 00:01:39.533
但是 我們都知道
還有另一部分內容沒有提到

00:01:39.600 --> 00:01:41.034
那就是Cocoa SDK

00:01:41.902 --> 00:01:44.304
你的程序也非常依賴它

00:01:44.371 --> 00:01:46.740
甚至對它的依賴
要大於Swift標準庫

00:01:47.007 --> 00:01:49.543
它需要看起來
屬於同一個生態系統

00:01:50.410 --> 00:01:52.980
因爲SDK在這裏至關重要

00:01:53.046 --> 00:01:55.282
有關我們如何
在自己的平臺上開發應用

00:01:55.349 --> 00:01:59.052
讓語言和庫相互合作
至關重要

00:02:01.088 --> 00:02:03.991
所以今年我們專注於表達性

00:02:04.358 --> 00:02:06.927
我提到表達性這個詞時
有兩層含義

00:02:06.994 --> 00:02:09.295
第一層意思指的是
你作爲應用作者的能力

00:02:09.363 --> 00:02:11.765
你編寫的Swift代碼
能把你的意圖

00:02:11.832 --> 00:02:13.634
傳達給編譯器和庫

00:02:14.134 --> 00:02:15.435
但它還有另一種意思

00:02:15.736 --> 00:02:18.105
庫需要能表達它們自己的目的

00:02:18.172 --> 00:02:19.339
它們的設計模式

00:02:19.406 --> 00:02:23.677
以及它們對於如何讓作爲應用作者的你
能最方便地使用API的想法

00:02:25.546 --> 00:02:27.347
所以在研究指引的時候

00:02:27.414 --> 00:02:29.983
我們注重一致的體驗這一概念

00:02:30.217 --> 00:02:33.187
有關指引的決策
都基於這一概念

00:02:33.253 --> 00:02:35.522
語言和庫密不可分

00:02:35.589 --> 00:02:36.823
它們必須協同工作

00:02:37.224 --> 00:02:40.961
舉個例子
庫帶來了一堆新的特性

00:02:41.261 --> 00:02:44.565
很多你看到的
今年我們新版平臺上的特性

00:02:44.631 --> 00:02:48.535
都源於庫中的新特性
你也可以把它們用到自己的應用裏

00:02:48.635 --> 00:02:50.304
提升你的開發體驗

00:02:51.104 --> 00:02:54.508
這些庫在我們所有的平臺中
都有廣泛應用

00:02:54.575 --> 00:02:57.711
包括今年新的Swift Auto ARC
和Swift Open Source

00:02:58.245 --> 00:03:00.214
我們有Swift Core
Libs Foundation

00:03:00.347 --> 00:03:04.718
把大部分Foundation
API移植到其他平臺 如Linux

00:03:05.786 --> 00:03:08.322
這些庫的實現經受得住考驗

00:03:08.455 --> 00:03:10.724
其中很多自OS X時代
就已經存在了

00:03:10.791 --> 00:03:12.159
有些甚可追溯到更久遠

00:03:13.794 --> 00:03:16.430
得益於Cocoa命名指引
它們還帶來了

00:03:16.496 --> 00:03:17.998
一套悠久傳統

00:03:18.265 --> 00:03:20.667
這意味着
當你看到一套新的API時

00:03:20.934 --> 00:03:24.104
你馬上就能明白
它的工作原理以及功能

00:03:24.838 --> 00:03:26.273
最後重要的一點是

00:03:26.340 --> 00:03:29.142
這些庫在不斷更新中

00:03:29.443 --> 00:03:31.311
除了添加新的特性

00:03:31.378 --> 00:03:34.848
我們還在改進 修復漏洞 等等

00:03:35.048 --> 00:03:38.752
每年發佈新系統
我們都會繼續這樣做

00:03:40.120 --> 00:03:42.589
另一方面 Swift語言

00:03:42.656 --> 00:03:45.459
帶來了一些
Objective-C所沒有的特性

00:03:45.826 --> 00:03:47.895
比如 對泛型的第一類支持

00:03:48.462 --> 00:03:50.297
以及內置的對可變類型的支持

00:03:50.364 --> 00:03:52.666
這些都是Swift語言
安全性的重要部分

00:03:53.901 --> 00:03:55.669
其中包括協議擴展

00:03:55.736 --> 00:03:58.172
函數重載 以及默認參數值

00:03:58.438 --> 00:04:01.842
這些都對如何設計Swift的API
有着重要的影響

00:04:03.043 --> 00:04:05.879
這個清單兩邊都沒有列全
我沒有足夠空間

00:04:05.946 --> 00:04:07.314
可以提到的還有很多

00:04:07.814 --> 00:04:12.219
所以我們提煉了三份關鍵文檔

00:04:12.586 --> 00:04:16.089
第一份是SE-0023
API設計指引

00:04:16.156 --> 00:04:20.027
所有文檔都發送到了Swift
Evolution郵件列表

00:04:20.093 --> 00:04:22.262
給你和Swift社區

00:04:22.329 --> 00:04:25.666
一個機會
參與到語言的設計和進化中

00:04:26.233 --> 00:04:28.735
我們把這些指引
視作統一的文檔

00:04:28.802 --> 00:04:30.804
無論是現在還是將來的Swift庫

00:04:31.205 --> 00:04:32.773
此外我們還有SE-0006

00:04:32.840 --> 00:04:35.576
將這些設計指引
用於標準庫

00:04:35.642 --> 00:04:38.145
提供了一套
一致且可預測的原語集

00:04:38.212 --> 00:04:41.315
我們可以把它們作爲基礎
還有SE-0005

00:04:41.648 --> 00:04:44.785
它大幅提升了Cocoa SDK
的表達性

00:04:45.052 --> 00:04:47.154
通過引入默認參數值

00:04:47.221 --> 00:04:49.389
改進可選集以及編譯屬性

00:04:49.456 --> 00:04:51.892
甚至在一些情況下自動採用協議

00:04:54.661 --> 00:04:55.796
有一期關於此的演講

00:04:55.863 --> 00:04:58.065
你如果沒看過的話
建議你去看看

00:04:58.131 --> 00:05:00.033
Swift API設計指引

00:05:02.369 --> 00:05:06.640
這些已經算得上巨大的進步
但我們知道 還可以更進一步

00:05:07.140 --> 00:05:09.776
因爲Swift的目標
不止於其名

00:05:11.311 --> 00:05:14.882
可變性是這門語言
至關重要的一部分

00:05:15.549 --> 00:05:18.485
所以我們把目光
聚焦於Foundation

00:05:19.953 --> 00:05:22.022
若你在想
爲何選擇Foundation？

00:05:22.589 --> 00:05:24.658
答案是它比較特別

00:05:24.725 --> 00:05:26.827
我這麼說
不是因爲我的工作是關於它的

00:05:27.427 --> 00:05:30.664
Foundation在SDK中
處於一個特別的位置

00:05:30.797 --> 00:05:32.766
它的層級足夠低

00:05:32.833 --> 00:05:35.602
適用於任何我提到過的平臺

00:05:36.203 --> 00:05:38.539
但與此同時
它的層級又足夠高

00:05:38.872 --> 00:05:42.476
足以建立一整套
通用類型和設計模式

00:05:42.543 --> 00:05:45.279
同樣你會發現
它會反映到整個SDK

00:05:45.913 --> 00:05:49.816
我們回顧一下剛纔的圖片
放大這裏的Cocoa SDK

00:05:49.883 --> 00:05:53.520
你會發現很多
應用的日常開發中用到的框架

00:05:53.587 --> 00:05:56.924
從UIKit到SpriteKit
從WatchKit到CoreData

00:05:56.990 --> 00:05:59.560
還有很多其它不適合放於此的
Cores和Kits

00:06:00.394 --> 00:06:02.062
有趣之處在於

00:06:02.129 --> 00:06:04.665
所有這些都建立在
Foundation的基礎上

00:06:05.599 --> 00:06:07.701
因此將Foundation
<c.magnenta>視作一槓桿點

00:06:08.635 --> 00:06:11.772
在Foundation裏的
一小點改動

00:06:12.005 --> 00:06:15.209
會對整個SDK產生巨大的影響

00:06:16.476 --> 00:06:20.547
一定程度上由於很多數值類型
出自Foundation

00:06:21.481 --> 00:06:25.485
所以我們注重
進化勝過徹底改變這一觀點

00:06:25.853 --> 00:06:29.489
我們看到了標準庫
爲你的應用開發帶來的所有東西

00:06:29.590 --> 00:06:32.693
我們不會因爲新語言
而摒棄已有的一切

00:06:32.926 --> 00:06:37.097
我們做的是
讓語言和庫更加緊密

00:06:37.164 --> 00:06:39.166
通過同時改進雙方

00:06:39.700 --> 00:06:43.704
我們今天談論的
正是這一過程的延續

00:06:45.739 --> 00:06:47.975
把這一點放在心上
Foundation團隊

00:06:48.041 --> 00:06:50.878
在Swift Evolution
郵件列表提出了兩個新的提議

00:06:51.178 --> 00:06:53.814
第一個是Foundation中
數值類型的可變性

00:06:54.114 --> 00:06:56.583
把Swift的可變性模型

00:06:56.650 --> 00:06:57.985
應用到Foundation框架上

00:06:59.720 --> 00:07:02.923
另一個是拋棄Swift
Foundation裏的NS前綴

00:07:03.190 --> 00:07:06.193
爲Swift建立通用類型和設計模式

00:07:06.260 --> 00:07:08.729
以適用於任何平臺

00:07:12.099 --> 00:07:15.536
這是我們今年對API
做的一些改進的概述

00:07:15.836 --> 00:07:17.838
第一點最重要的是數值語義

00:07:17.905 --> 00:07:20.908
一套全新的數值類型
在整個SDK隨處可見

00:07:21.375 --> 00:07:23.911
此外我們對命名進行了些改進

00:07:23.977 --> 00:07:26.980
超越了Objective-C
翻譯成Swift能做到的

00:07:27.514 --> 00:07:30.317
我們讓這些類型
採用了很多標準庫協議

00:07:30.384 --> 00:07:34.121
這意味着你的通用算法
現在同樣適用於Foundation類型

00:07:34.688 --> 00:07:38.525
我們額外添加了類型安全性
以及很多針對Swift的新特性

00:07:41.228 --> 00:07:43.130
我們來快速瀏覽一下數值類型

00:07:44.498 --> 00:07:46.633
數值類型和引用類型不同

00:07:46.700 --> 00:07:50.437
主要區別於複製時的行爲

00:07:50.504 --> 00:07:54.474
數值類型在賦值或作爲參數傳遞時
會複製它們的內容

00:07:54.575 --> 00:07:56.476
舉個簡單例子
我有一個點

00:07:57.010 --> 00:08:00.447
我用等號
把這個點賦值給另一個點

00:08:00.514 --> 00:08:03.851
當我修改第二個點的時候
你可以看到 只有副本改變了

00:08:03.917 --> 00:08:08.155
我沒有影響兩個點的內容
因爲CGPoint是數值類型

00:08:09.156 --> 00:08:12.326
另一方面
引用類型默認共享內容

00:08:12.759 --> 00:08:16.330
這裏我用引用類型創建些數據
它們是可變數據

00:08:16.763 --> 00:08:20.567
同樣用等號
把data賦值給otherData

00:08:21.101 --> 00:08:23.704
然而這一次
當我修改第二個數據的時候

00:08:24.004 --> 00:08:26.073
你會發現
它影響到了兩個數據的內容

00:08:27.341 --> 00:08:30.744
重要的是要理解
這兩者沒有好壞之分

00:08:30.811 --> 00:08:32.412
只是使用方式不同

00:08:33.212 --> 00:08:36.517
我喜歡把它們看做
工具箱中的不同工具

00:08:36.582 --> 00:08:39.052
當你需要解決某個問題時
可以使用它們

00:08:41.288 --> 00:08:43.423
所以當你試着決定

00:08:43.924 --> 00:08:46.193
你的類型是數值類型還是引用類型

00:08:46.860 --> 00:08:49.830
你應該從對象身份和存儲內容考慮

00:08:50.597 --> 00:08:52.566
我舉幾個例子來解釋

00:08:54.001 --> 00:08:57.037
Foundation中有個叫
OperationQueue的類

00:08:57.304 --> 00:09:00.307
OperationQueue中有一個單例
叫main OperationQueue

00:09:01.308 --> 00:09:03.310
這個main
OperationQueue

00:09:03.377 --> 00:09:05.946
用於放置
你希望在主線程上完成的工作

00:09:06.013 --> 00:09:09.116
所以它只有一個
這一定程度上代表了身份

00:09:09.383 --> 00:09:13.453
若我能複製main OperationQueue
它就不再是主隊列了

00:09:13.954 --> 00:09:17.357
所以我們相信OperationQueue
是一個引用類型

00:09:18.592 --> 00:09:22.396
另一個例子 Cocoa SDK裏
隨處可見的一種模式就是代理

00:09:23.096 --> 00:09:26.366
這是一個代理
或者說是URLSession的代理之一

00:09:26.433 --> 00:09:30.237
你會發現這個代理協議
有一個參數 就在這兒

00:09:30.304 --> 00:09:34.908
名叫Session
它告訴被委託的對象

00:09:34.975 --> 00:09:37.377
它將以哪個URLSession的名義工作

00:09:37.845 --> 00:09:42.816
這裏的哪個URLSession
同樣暗示了身份

00:09:43.150 --> 00:09:47.054
所以我們相信代理使用的類型
通常是引用類型

00:09:48.989 --> 00:09:52.192
從另一方面 很多類型的重點
在於它們存儲的內容

00:09:52.259 --> 00:09:53.560
比如Date

00:09:53.627 --> 00:09:55.729
這是我們新Foundation
數值類型之一

00:09:56.396 --> 00:09:57.898
Date是一個絕對的時間點

00:09:58.532 --> 00:10:01.301
我們可以有兩個具有相同值的Date

00:10:01.368 --> 00:10:04.538
同樣的絕對時間點
它們是同一個Date

00:10:04.605 --> 00:10:07.508
我們不需要討論那個時間點的引用

00:10:07.574 --> 00:10:09.710
如果我們查看Date的實現

00:10:09.776 --> 00:10:11.879
正如你所見
其實它只是個Double

00:10:12.312 --> 00:10:15.916
Double我們可以本能地認爲
是一個數值類型

00:10:17.050 --> 00:10:18.519
另一個例子就是Data

00:10:18.952 --> 00:10:21.555
Data是另一個
新的Foundation數值類型

00:10:22.055 --> 00:10:24.992
Data 通常情況下
你關心的是Data的內容

00:10:25.125 --> 00:10:28.395
它所包含的字節
而不是NSData對象

00:10:28.495 --> 00:10:31.765
所以Foundation
把Date設爲數值類型

00:10:34.101 --> 00:10:36.970
每次我們把它作爲參數傳遞時
都需要複製數據

00:10:37.037 --> 00:10:38.772
很快開銷會變得很大

00:10:39.006 --> 00:10:41.675
所以我們進行了一種優化
叫做寫時複製

00:10:42.476 --> 00:10:44.178
這裏我建立了一些數據

00:10:44.845 --> 00:10:46.580
看到我建立了一個Struct

00:10:46.647 --> 00:10:48.849
但是在它內部
還有一個引用

00:10:48.916 --> 00:10:51.885
又一個合作提高效率的例子

00:10:51.952 --> 00:10:54.154
我同時使用了引用和數值

00:10:54.221 --> 00:10:56.156
來得到我想要的性能特徵

00:10:56.223 --> 00:10:58.992
以及重要的數值語義

00:10:59.960 --> 00:11:04.064
如果我用等號
把這個數據賦值給另一個數據

00:11:04.131 --> 00:11:06.733
你會發現我得到了另一個Struct

00:11:06.800 --> 00:11:09.469
但其實在內部
它們還是指向同一個類

00:11:10.103 --> 00:11:14.241
但是如果我修改這個數據
那我們就需要複製數據了

00:11:14.408 --> 00:11:17.544
修改副本
我們就有了兩個獨立的Data

00:11:18.812 --> 00:11:20.681
如果我繼續修改第二個數據

00:11:20.914 --> 00:11:23.617
我們可以斷定
Data各有獨自的引用

00:11:23.684 --> 00:11:25.352
而我們也不需要每次都去複製它

00:11:25.953 --> 00:11:29.256
這是一種擴展 或者說
其實就是同樣技術的另一種使用方式

00:11:29.323 --> 00:11:32.226
這個技術我們以前談論過
包括去年談到的

00:11:32.292 --> 00:11:34.328
在Swift裏構建更好的
應用和值類型

00:11:34.394 --> 00:11:37.464
如果你想了解更多它的工作原理
可以去看看

00:11:38.632 --> 00:11:41.435
所以我們調查了
Foundation裏每一個API

00:11:41.602 --> 00:11:45.239
總結出了這份列表
我們認爲它們作爲數值類型很棒

00:11:45.639 --> 00:11:49.610
你會很高興看到
很多你平時使用的類型都在列表上

00:11:49.877 --> 00:11:52.012
包括我剛剛提到的Data和Date

00:11:52.279 --> 00:11:54.815
還有很多別的常用類型
比如URL

00:11:55.115 --> 00:11:58.018
IndexPath
CharacterSet 等等

00:11:58.285 --> 00:12:00.454
它們當中很多不只是變成了數據類型

00:12:00.654 --> 00:12:03.223
還增加了很多很棒的新API

00:12:05.425 --> 00:12:08.629
爲了讓你們瞭解它們是什麼樣的
我想有請Michael上臺

00:12:14.201 --> 00:12:15.102
謝謝你 Tony

00:12:15.636 --> 00:12:19.072
咱們先看看
Foundation枚舉類型的新家

00:12:20.240 --> 00:12:21.909
Objective-C裏的枚舉

00:12:21.975 --> 00:12:24.144
以及選項集合
生存在全局命名空間裏

00:12:24.211 --> 00:12:25.946
和使用它們的類型在一起

00:12:26.113 --> 00:12:30.083
比如NSNumberFormatter
定義了四個枚舉

00:12:30.184 --> 00:12:33.720
包括樣式、行爲、填充位置以及舍入模式

00:12:34.354 --> 00:12:37.324
它們和NumberFormatter
有一定暗中的聯繫

00:12:37.391 --> 00:12:39.760
通過嚴格一致的命名傳統

00:12:39.960 --> 00:12:43.597
在Swift 2中 你也知道
它們同樣在全局命名空間裏

00:12:45.065 --> 00:12:46.934
但這就感覺不像是純粹的Swift

00:12:47.467 --> 00:12:49.336
Swift支持嵌套類型

00:12:49.903 --> 00:12:53.173
所以在Swift 3裏
我們決定改變這些類型的位置

00:12:53.807 --> 00:12:56.443
在它們註定應該在的地方
進行聲明

00:12:56.510 --> 00:12:58.946
現在NumberFormatter
擁有內置的樣式

00:12:59.012 --> 00:13:00.848
行爲、填充位置以及舍入模式類型

00:13:00.914 --> 00:13:02.850
它們的名字不再繁冗

00:13:03.784 --> 00:13:05.719
這極大程度減少了

00:13:05.786 --> 00:13:08.255
Foundation在頂級命名空間
聲明的類型數量

00:13:08.522 --> 00:13:10.524
關係也更加明確

00:13:10.591 --> 00:13:12.993
我們的API表達性變得更強
更易被發現

00:13:14.528 --> 00:13:16.830
還是關於枚舉這個主題

00:13:17.164 --> 00:13:20.868
很多Foundation API
也使用字符串常量家族

00:13:20.968 --> 00:13:24.671
比如Notification Name
和URL Resource Key

00:13:25.472 --> 00:13:30.377
Swift支持建立在
其它原始類型上的枚舉類型

00:13:30.444 --> 00:13:33.413
可以是整型以外的類型
包括字符串類型

00:13:33.847 --> 00:13:36.750
若我們在Objective-C裏
也能做到這些豈不更妙？

00:13:37.317 --> 00:13:40.087
今年 我們可以了
常量現在被定義成了

00:13:40.153 --> 00:13:42.823
類型非常具體的字符串常量

00:13:42.956 --> 00:13:46.326
如Notification Name
及URL Resource Key

00:13:46.727 --> 00:13:47.794
以及很多很多別的

00:13:49.630 --> 00:13:53.867
這些常量保留了可擴展性
無論在Objective-C裏

00:13:54.501 --> 00:13:56.537
還是在Swift裏

00:13:56.603 --> 00:14:02.476
我們都可以對它們進行嵌套
就像對待它們的兄弟整數類型一樣

00:14:03.277 --> 00:14:06.213
這樣在Swift 3中使用它們
非常自然 表達性也很強

00:14:06.813 --> 00:14:10.918
另一個常見的Foundation
設計模式是把狀態和類型聯繫起來

00:14:11.185 --> 00:14:14.087
比如standardUserDefaults

00:14:14.821 --> 00:14:19.560
Swift對於類屬性的支持
可以很好地適用於這裏

00:14:20.694 --> 00:14:24.264
今年我們把類屬性
引入了Objective-C

00:14:24.331 --> 00:14:26.633
它們的定義和對象屬性一樣

00:14:26.700 --> 00:14:29.469
除了現在我們支持這個
酷酷的類別關鍵詞

00:14:29.736 --> 00:14:33.273
由於我們知道它是類屬性

00:14:33.340 --> 00:14:36.543
我們不需再像Swift 2.2那樣
把它作爲函數引入

00:14:36.643 --> 00:14:39.646
它現在可以作爲類屬性出現

00:14:39.713 --> 00:14:42.449
如同你會在Swift裏定義一樣

00:14:43.584 --> 00:14:44.885
但我們沒有止步於此

00:14:46.019 --> 00:14:48.155
有些累贅的詞
在Swift 3中

00:14:48.222 --> 00:14:50.791
我們徹底修改了
Swift代碼的顯示方式

00:14:50.858 --> 00:14:53.093
以及Swift裏
Objective-C代碼的顯示方式

00:14:53.393 --> 00:14:56.597
所以我們的最終API更像這個

00:14:57.164 --> 00:15:00.033
我們知道它是userDefault
通過幫助把Foundation

00:15:00.100 --> 00:15:02.236
變得更像Swift
我們獲取了很多好處

00:15:02.302 --> 00:15:04.304
無論是對於Objective-C
還是Swift

00:15:06.273 --> 00:15:09.943
Tony剛纔說很多Foundation
類型值得變成數值類型

00:15:10.010 --> 00:15:12.546
我談談其中的一些
我們從Date說起

00:15:14.281 --> 00:15:16.316
假設我們要安排一條備忘錄

00:15:16.383 --> 00:15:17.784
提醒我們什麼時候該回家

00:15:17.851 --> 00:15:21.355
我們從Swift 2.2開始
引出我們的例子

00:15:21.555 --> 00:15:25.025
假設我們有一個函數
它會告訴我們什麼時候應該回家

00:15:25.092 --> 00:15:29.963
我們調用它
五分鐘看起來正適合我們的提醒

00:15:30.030 --> 00:15:32.633
我們繼續 你知道的
把它偏移一點

00:15:33.200 --> 00:15:37.538
有一點值得說明 NSDate
是且一直會是一個引用類型

00:15:37.604 --> 00:15:41.375
所以在這裏
實際隱藏着兩個動態分配

00:15:41.842 --> 00:15:43.777
一個在這裏
另一個在這裏

00:15:45.412 --> 00:15:48.215
在Swift 3裏
我們可以使用Date數值類型

00:15:49.249 --> 00:15:53.086
所以現在我們就來使用它
用法和原來類似

00:15:53.153 --> 00:15:56.490
但是這個變量的行爲
和以前大不相同

00:15:56.890 --> 00:15:59.493
特別地 我們允許內聯修改

00:16:00.460 --> 00:16:01.562
我們沒做額外的事情

00:16:02.196 --> 00:16:04.565
這兩個例子做的是一樣的事

00:16:04.631 --> 00:16:09.203
除了對於數值類型
我們不需要額外進行動態分配

00:16:09.436 --> 00:16:10.737
繼續我們的例子

00:16:11.071 --> 00:16:13.073
當然了
我們也可以這樣內聯

00:16:15.075 --> 00:16:17.277
關於提醒事項
只有把它安排在事情發生前

00:16:17.344 --> 00:16:19.513
纔是有意義的

00:16:20.080 --> 00:16:22.416
Swift帶來的最棒的是

00:16:22.482 --> 00:16:28.255
滿足某些條件時
協議會自動被採用

00:16:28.322 --> 00:16:31.625
在這個例子裏Date自動遵從了
Comparable協議

00:16:31.692 --> 00:16:35.863
它賦予了我們使用小於號的能力
我們現在就在使用

00:16:36.797 --> 00:16:39.399
我們可以設定定時器
但首先我們要創建它

00:16:39.466 --> 00:16:42.035
我們要使用另一個今年的新API

00:16:42.336 --> 00:16:45.973
就是這個看起來很棒的
基於閉包的定時器API

00:16:46.306 --> 00:16:48.308
我們用一個閉包初始化定時器

00:16:48.375 --> 00:16:50.577
不再需要selector
和target了

00:16:51.712 --> 00:16:53.580
我們把它安排在主RunLoop上

00:16:59.052 --> 00:17:03.056
我相信線程和RunLoop
也有這樣的方法

00:17:03.123 --> 00:17:05.559
把它安排在主RunLoop上
然後就完成了

00:17:06.460 --> 00:17:09.730
這是個絕佳的例子 它展示了所有熟悉的
Foundation API是如何

00:17:09.796 --> 00:17:12.266
如此優雅地
移植到Swift 3裏的

00:17:12.799 --> 00:17:16.069
這是我能在演示裏展示的最具
Foundation特色的代碼

00:17:16.136 --> 00:17:18.137
我有個RunLoop
一個定時器及幾個日期

00:17:18.204 --> 00:17:21.808
基本上全是Foundation的內容
極少的其他內容

00:17:22.108 --> 00:17:23.977
看不到任何方括號

00:17:25.612 --> 00:17:28.782
另一個新例子
或說Fondation裏另一新類型

00:17:28.849 --> 00:17:30.350
Measurement數值類型

00:17:31.318 --> 00:17:34.788
假設一個新例子
我們關心上下班線路有多長

00:17:34.855 --> 00:17:37.791
而且我們很幸運
我們住的地方距離上班的地方

00:17:37.858 --> 00:17:38.692
只有兩條短街之隔

00:17:39.326 --> 00:17:43.063
Measurement是數值類型
並且Swift支持運算符重載

00:17:43.330 --> 00:17:44.932
它們不僅僅是數值類型

00:17:44.998 --> 00:17:50.838
它們還是Mathematical類型
所以給它們設置運算符有實際意義

00:17:51.405 --> 00:17:54.474
沒人會輕視它或不待見它

00:17:54.541 --> 00:17:56.977
如果我們考慮把它們加起來

00:17:57.044 --> 00:18:00.547
我們就可以計算出它們的總和
甚至對它們進行轉換

00:18:00.614 --> 00:18:01.815
轉換成另一個單位

00:18:02.049 --> 00:18:05.285
假設我們很好奇
想知道去工作路上要花費多久

00:18:05.552 --> 00:18:06.920
這個我們也能做到

00:18:07.287 --> 00:18:10.190
只是在Swift 3裏
如果我們試着編譯這段代碼

00:18:10.257 --> 00:18:12.960
它會失敗的
而且是在編譯的時候失敗

00:18:13.026 --> 00:18:16.563
得益於Swfit 3中
泛型和類型限制的能力

00:18:17.030 --> 00:18:20.267
我們設計成
讓單位的區別

00:18:20.334 --> 00:18:21.869
在編譯的時候就可以看出來

00:18:22.002 --> 00:18:24.004
Swift編譯器可檢測出
然後提醒我們

00:18:24.071 --> 00:18:26.173
我們正在進行無效轉換

00:18:26.707 --> 00:18:30.210
想了解更多Measurement類
單位以及今年新引入類型的

00:18:30.277 --> 00:18:33.180
整個新的生態系統的話
記得去收聽這場演講

00:18:33.247 --> 00:18:37.017
在週五下午 瞭解更多
Measurements和單位

00:18:38.118 --> 00:18:39.953
換一個例子

00:18:41.488 --> 00:18:43.390
我說過這將是一場探索

00:18:43.991 --> 00:18:45.692
假設我們想買幾臺MacBook

00:18:45.826 --> 00:18:48.161
會使用新
URLComponent數值類型

00:18:48.896 --> 00:18:50.564
可以表達性很強地做到

00:18:51.198 --> 00:18:53.300
從描述可變部分開始

00:18:53.367 --> 00:18:55.569
把它作爲下面的模板

00:18:55.802 --> 00:18:58.572
遍歷我們想要購買的產品

00:19:00.140 --> 00:19:03.844
複製我們的模板
然後修改這個副本

00:19:03.911 --> 00:19:06.213
指定我們想要買的產品

00:19:06.980 --> 00:19:09.783
在這裏
我們可以放心地展開這個可選類型

00:19:10.083 --> 00:19:13.287
因爲在我們的模板裏把它設爲了非空

00:19:14.421 --> 00:19:18.358
繼續把我們的URL打印出來
我們發現可以

00:19:20.427 --> 00:19:26.633
不進行任何內存管理
創建我們想要購買的產品的鏈接

00:19:26.967 --> 00:19:30.604
只需聲明我們的意圖
指明是否可變

00:19:30.671 --> 00:19:33.273
然後語言就會爲我們處理好剩下的事

00:19:35.175 --> 00:19:38.979
Swift 3 或者廣泛地說Swift
帶來的另一個特性

00:19:39.046 --> 00:19:42.549
是ProtocolComponents
在很多Foundation類型中 比如Date

00:19:42.683 --> 00:19:46.553
得到了有用的新能力
這得益於新的遵循協議的方式

00:19:46.653 --> 00:19:51.391
比如CharacterSet和IndexSet
現在遵循SetAlgebra協議

00:19:51.458 --> 00:19:54.094
你可以對它們進行並集
交集 對稱差集操作

00:19:54.161 --> 00:19:55.495
根據你的需要

00:19:56.463 --> 00:19:59.032
Data現在遵循
8位無符號整數的

00:19:59.333 --> 00:20:02.803
MutableCollection協議和
MutableRandomAccessCollection協議

00:20:03.403 --> 00:20:05.339
就像你一直認爲的那樣

00:20:06.740 --> 00:20:10.244
我們來看看遵從新的協議後
Data現在能做些什麼

00:20:11.278 --> 00:20:15.482
首先需要一些數據
我手頭上有一些Base64數據

00:20:15.549 --> 00:20:17.885
通過普通的初始化函數
進行解析

00:20:18.785 --> 00:20:23.690
這裏有個顯式展開
我知道這麼做是安全的

00:20:23.757 --> 00:20:27.060
因爲這裏只是個演示
我知道它是有效的Base64值

00:20:28.929 --> 00:20:31.899
你自己使用過程中
可能需要用到try語句

00:20:31.965 --> 00:20:36.670
我喜歡統計
以及看起來很棒的圖表

00:20:36.737 --> 00:20:40.507
當你的統計用直方圖的形式表現時
我們要來建立一個直方圖

00:20:40.574 --> 00:20:43.577
我們需要用到後臺存儲
使用原始的Swift數組

00:20:43.644 --> 00:20:45.012
把它全都初始化爲0

00:20:45.078 --> 00:20:49.783
我們把data裏
每一字節的值作爲索引

00:20:49.850 --> 00:20:51.351
然後維護一個頻率計數

00:20:52.686 --> 00:20:55.489
由於Data是一個
Collection 遍歷它的字節

00:20:55.556 --> 00:20:58.859
很自然且表達性高
我們可通過一個for-in循環做到

00:20:59.560 --> 00:21:02.095
接着我們創建直方圖
來看一看

00:21:02.963 --> 00:21:04.798
這看着絕對像直方圖

00:21:04.865 --> 00:21:06.967
就像所有直方圖一樣
裏面有信號和噪聲

00:21:07.034 --> 00:21:09.303
我在這看到了不少高頻率數據

00:21:09.803 --> 00:21:11.471
我想要把它過濾出去

00:21:11.839 --> 00:21:13.607
幸運的是
Data現在是Collection了

00:21:13.674 --> 00:21:16.143
所以我們可使用到類似Map、
Reduce、Filter的功能

00:21:16.210 --> 00:21:19.146
以及其他你喜歡的
Collection函數

00:21:19.746 --> 00:21:23.517
假設我們想要剔除
所有大於三的數據

00:21:23.717 --> 00:21:26.019
就如同聲明謂詞一樣簡單

00:21:26.453 --> 00:21:29.690
然後我們可以就生成
過濾後的數據了

00:21:30.991 --> 00:21:33.327
作爲一個Collection
Data是可切分的

00:21:33.760 --> 00:21:37.197
這些切片功能上和Mutable
Collection一樣

00:21:37.297 --> 00:21:40.467
或是你在Swift裏見到過的
數值類型Collection

00:21:41.735 --> 00:21:44.338
修改它們會觸發
同樣的寫時複製機制

00:21:44.404 --> 00:21:48.208
正如Tony剛纔描述的
它們的運行方式完全相同

00:21:49.810 --> 00:21:53.347
Data還保留了可擴展性

00:21:53.413 --> 00:21:55.082
通過繼承隱含的引用類型

00:21:55.148 --> 00:21:57.651
這是很重要的一句話
我會詳細講個例子

00:21:57.718 --> 00:21:59.653
來解釋我的意思

00:21:59.987 --> 00:22:04.124
舉個例子 我們先創建一個
自定義的NSData子類

00:22:04.358 --> 00:22:05.726
不給它分配任何存儲空間

00:22:05.859 --> 00:22:08.495
代表一個虛擬的
全是1的Collection

00:22:09.096 --> 00:22:11.598
我們將它名爲
AllOnesData 描述性很強

00:22:11.798 --> 00:22:14.768
這裏我只展示一個方法的實現

00:22:15.269 --> 00:22:20.574
獲取指定的字節getBytes
多少可以實現這個類期望的功能

00:22:20.641 --> 00:22:22.009
我們把所有字節設置爲1

00:22:22.976 --> 00:22:24.511
不需要儲存任何東西

00:22:25.245 --> 00:22:27.981
接着我們創建一個它的只讀對象

00:22:28.849 --> 00:22:31.518
我們不會單純地使用引用
而是會建立一個數值類型

00:22:31.585 --> 00:22:35.656
並把引用包含其中

00:22:35.889 --> 00:22:39.593
我們使用了剛剛創建的
新的初始化方法

00:22:40.227 --> 00:22:42.095
它和你預期的效果一樣

00:22:42.563 --> 00:22:46.900
現在我們的ones數值類型
指向全是1的數據的引用

00:22:46.967 --> 00:22:47.801
它們是虛擬的

00:22:47.868 --> 00:22:50.470
現在不會在內存裏佔用字節

00:22:50.871 --> 00:22:54.474
現在我們來創建一個可變副本
同樣 我們不做任何修改

00:22:54.541 --> 00:22:58.312
所以我們現在不需要分配或管理
任何這些內存中的字節

00:22:59.112 --> 00:23:01.582
我們準備好對bytes進行需改
爲了做到這一點

00:23:01.648 --> 00:23:04.585
要用到一個今年新添的
Foundation API

00:23:04.651 --> 00:23:07.688
它是一個Scoped
Pointer Accessor

00:23:08.989 --> 00:23:10.891
叫做withUnsafeMutableBytes

00:23:11.024 --> 00:23:15.395
這比直接對data本身
調用mutableBytes好得多

00:23:15.462 --> 00:23:19.099
因爲我們把
對這些字節的訪問限制在了

00:23:19.166 --> 00:23:21.068
我們定義的閉包內

00:23:21.635 --> 00:23:23.670
這很好理解

00:23:23.737 --> 00:23:25.372
沒有漫天亂飛的指針

00:23:25.439 --> 00:23:27.975
指針只在這個小的訪問器內部有效

00:23:29.376 --> 00:23:32.679
我們實際進行修改
引起寫時複製機制

00:23:32.746 --> 00:23:34.114
現在這些字節

00:23:34.214 --> 00:23:37.150
這些複製的字節
真正是可見的內存了

00:23:38.852 --> 00:23:41.755
接着下一個例子
我厭倦談論Data了

00:23:42.523 --> 00:23:47.261
我們來說說URL
以及URL屬性

00:23:47.394 --> 00:23:48.562
爲了說明這個例子

00:23:48.629 --> 00:23:52.065
我想先說一說在Swift 2.2中
我們是怎麼做的

00:23:53.100 --> 00:23:56.303
在Swift 2.2我們會請求
NSURL.fileURL

00:23:56.370 --> 00:23:58.005
以my-special-file
爲例

00:23:58.071 --> 00:24:01.375
這個文件太特殊了
我把它放在我的文件系統的根目錄

00:24:02.042 --> 00:24:03.544
我對三個屬性很好奇

00:24:03.610 --> 00:24:07.014
我想知道創建日期
它是否是常規文件

00:24:07.247 --> 00:24:11.218
以及出於某些原因
這個文件所處卷的最大文件大小

00:24:11.885 --> 00:24:15.689
這些在Swift 2.2只是字符串
所以這只是個字符串數組

00:24:16.156 --> 00:24:18.292
而且當我向我的URL
請求資源值的時候

00:24:18.358 --> 00:24:21.295
只會得到個普通的字典類型
不包含任何類型信息

00:24:21.361 --> 00:24:25.799
它只是字符串指向對象
這意味着使用它時

00:24:26.834 --> 00:24:29.803
需要用到很多as某個類
所以我必須

00:24:29.870 --> 00:24:32.439
暗示說它是布爾型
暗示它是整數型

00:24:32.506 --> 00:24:37.077
我一直在不停檢查引用值
來確保我做的是對的

00:24:37.144 --> 00:24:40.047
除此之外
修改只是針對字典類型的

00:24:40.380 --> 00:24:42.416
所以你可以做類似這樣的荒唐事情

00:24:45.285 --> 00:24:48.255
並且每一個錯誤都是運行時錯誤

00:24:49.256 --> 00:24:51.425
我們來看看Swift 3的改進

00:24:52.659 --> 00:24:55.462
在Swift 3中
建立URL的過程也很類似

00:24:56.029 --> 00:24:59.032
但是我們不再使用類工廠方法

00:24:59.766 --> 00:25:02.669
它變成了普通的初始化語法

00:25:03.370 --> 00:25:05.405
我們現在談的依然是
my-special-file

00:25:05.939 --> 00:25:09.243
我們不再請求字符串數組

00:25:09.309 --> 00:25:11.812
而是使用強類型的字符串枚舉

00:25:11.879 --> 00:25:14.615
正如我之前說的一樣
我們要創建它們的集合

00:25:15.482 --> 00:25:17.384
當我們向URL請求資源值時

00:25:17.451 --> 00:25:19.319
我們得到的不再是個字典

00:25:19.520 --> 00:25:23.590
我們會得到一個值
一個新的Foundation數值類型

00:25:23.657 --> 00:25:25.692
我們看看這個
Foundation值的類型是什麼

00:25:25.759 --> 00:25:28.428
針對我們請求的三個屬性

00:25:29.296 --> 00:25:31.698
你可以看到creationDate
是一個Date

00:25:31.865 --> 00:25:33.200
isRegularFile
是一個Bool

00:25:33.267 --> 00:25:35.402
volumeMaximumFileSize
是一個Integer

00:25:37.271 --> 00:25:39.706
而且還有一點需要指出的是

00:25:39.773 --> 00:25:42.276
URLResourceValue
結構本身是惰性的

00:25:42.342 --> 00:25:44.578
它仍然是用字典實現的

00:25:45.045 --> 00:25:47.548
正如Swift 2 API一樣
沒有必要

00:25:47.614 --> 00:25:51.251
這個巨大的Struct會消耗內存

00:25:51.318 --> 00:25:54.388
我請求了三個東西
就會得到三個東西

00:25:54.721 --> 00:25:57.457
如果你有自定義keys
字典還是在那裏

00:25:57.524 --> 00:26:00.527
你請求的不是字符串
而是你所感興趣的

00:26:00.594 --> 00:26:01.995
URLResourceKey

00:26:02.563 --> 00:26:04.665
你可能注意到有很多問號

00:26:04.731 --> 00:26:07.167
原因就是 恩
其實有兩個原因

00:26:07.234 --> 00:26:09.102
第一個原因是你並沒有請求它

00:26:09.469 --> 00:26:11.505
所以這個創建日期就不存在

00:26:11.572 --> 00:26:13.807
這涉及到數據的稀疏性

00:26:14.074 --> 00:26:15.943
第二個它不存在的原因是

00:26:16.009 --> 00:26:19.046
就是屬性本身可能是無效的

00:26:19.279 --> 00:26:21.982
volumMaximumFileSize就是個例子

00:26:22.049 --> 00:26:24.284
我們來看看
兩個關於工作原理的例子

00:26:25.519 --> 00:26:27.654
因爲我們請求的是普通文件

00:26:27.721 --> 00:26:30.724
我們完全可以顯式展開
這個Optional值

00:26:30.958 --> 00:26:32.593
它會出現在此
因爲我們請求了它

00:26:32.659 --> 00:26:35.729
然而 VolumeMaximumFileSize
的文檔裏面說到

00:26:35.796 --> 00:26:37.764
不是所有的卷
或所有的文件系統

00:26:37.831 --> 00:26:41.235
都支持最大文件尺寸這個屬性
所以它可能並不在那兒

00:26:41.435 --> 00:26:45.639
這是Swift裏
使用if let結構的絕佳例子

00:26:45.706 --> 00:26:47.708
有條件的設置局部變量

00:26:49.877 --> 00:26:51.378
現在咱們說說修改

00:26:51.445 --> 00:26:55.482
當然URLResourceValues中
URL的修改API

00:26:55.549 --> 00:26:58.418
與它新的值類型相關
所以當你嘗試這麼做的時候

00:26:58.485 --> 00:27:00.087
儘管這是我的特殊文件

00:27:00.153 --> 00:27:02.689
我非常努力地說它不是常規的

00:27:02.756 --> 00:27:04.925
編譯器會在我編譯的時候就會報錯

00:27:04.992 --> 00:27:07.694
而不是讓我自己在運行時
發現這個問題

00:27:07.828 --> 00:27:12.266
更進一步 文件創建日期也是強類型的
類型爲Date

00:27:12.332 --> 00:27:16.904
如此荒唐的事 在Siri那可能行得通
但寫代碼的時候是不可能的

00:27:19.139 --> 00:27:22.543
關於Foundation的探索
我最後想說的一點

00:27:22.609 --> 00:27:24.778
就是Swift的原始枚舉類型

00:27:24.912 --> 00:27:27.481
然後我們又要再一次
談談數據了

00:27:27.548 --> 00:27:29.449
因爲有個例子真的很不錯

00:27:30.217 --> 00:27:32.719
當data擁有一個
UnsafeMutablePointer時

00:27:32.786 --> 00:27:35.155
你可以選擇設置
一個deallocator

00:27:36.557 --> 00:27:38.492
Data默認支持多種類型

00:27:39.726 --> 00:27:43.463
包括自定義deallocator

00:27:44.231 --> 00:27:48.969
現在 Swift支持
把值和枚舉相關聯

00:27:49.036 --> 00:27:50.938
你經常會看到這些和整數關聯

00:27:51.004 --> 00:27:54.842
你可以在case表達式裏使用它們
這樣你就可以

00:27:54.908 --> 00:27:57.945
用它們做一些很酷的模式匹配
但這裏我們接受的是一個閉包

00:27:58.011 --> 00:28:01.515
因爲我們想把你提供的行爲
包含其中

00:28:01.715 --> 00:28:03.083
我們來實際做一下

00:28:03.183 --> 00:28:05.085
我們從一個簡單的
malloc例子說起

00:28:05.752 --> 00:28:07.087
在Swift
你依然可使用malloc

00:28:07.154 --> 00:28:10.357
儘管你在演示中不常看到它

00:28:10.524 --> 00:28:15.028
使用malloc分配內存
當你把這個指針指向Data時

00:28:15.162 --> 00:28:17.064
你可以把deallocator
設置爲free

00:28:19.032 --> 00:28:23.203
語法和使用集成值一樣簡單

00:28:23.437 --> 00:28:24.805
我們再看一個自定義的例子

00:28:24.872 --> 00:28:28.942
假設我們有一個函數
create_glorious_pointer

00:28:29.009 --> 00:28:31.378
我們想光榮地釋放它

00:28:31.445 --> 00:28:32.479
以免它們受到冒犯

00:28:32.846 --> 00:28:37.618
設置自定義deallocator非常簡單
只需提供一個閉包

00:28:37.684 --> 00:28:40.220
並且確保你進行了想要進行的操作

00:28:41.288 --> 00:28:42.656
這非常強大

00:28:42.723 --> 00:28:46.994
對於框架開發者來說
也是一個很強大的概念

00:28:47.294 --> 00:28:50.664
因爲在別的語言裏 我們不得不

00:28:50.731 --> 00:28:52.933
提供另一個基於函數指針的API

00:28:53.233 --> 00:28:57.938
但在Swift 3裏
我們可以直接提供基於枚舉的API

00:28:58.005 --> 00:29:01.208
它可以簡潔地表達所有內容
非常有表現力

00:29:02.342 --> 00:29:04.311
至此我們的API探索之旅結束了

00:29:04.545 --> 00:29:06.113
但願我們見到了不少奇妙之處

00:29:06.180 --> 00:29:08.949
現在讓Tony給大家
詳細講講Adoption

00:29:16.156 --> 00:29:17.057
謝謝 Michael

00:29:18.692 --> 00:29:21.528
現在你對於可能做到的事情
有了一點大致瞭解

00:29:21.595 --> 00:29:23.664
我們來談談
如何在你的應用中使用

00:29:24.932 --> 00:29:26.700
咱們先來講講橋接

00:29:26.934 --> 00:29:29.369
在這個主題上
我們不斷迭代更新

00:29:29.436 --> 00:29:32.973
我們把Swift 2裏面的一些
你已經熟悉的概念進行了擴充

00:29:33.207 --> 00:29:35.342
用於橋接Objective-C
和Swift

00:29:35.676 --> 00:29:38.111
如果你理解String和
NSString是如何橋接的

00:29:38.178 --> 00:29:40.814
我們把同樣的概念
應用到了Data和NSData上

00:29:40.981 --> 00:29:43.050
以及你看到的
這裏所有的數據類型

00:29:43.851 --> 00:29:48.488
這就表示所有從
Cocoa SDK引入的API

00:29:48.555 --> 00:29:50.724
都會使用這些新的數據類型

00:29:51.091 --> 00:29:54.628
這就是我們形成槓桿的核心思想

00:29:57.130 --> 00:29:59.466
例如 在Swift 2.2
的AppKit中

00:29:59.533 --> 00:30:02.135
你能看到這個類
名叫NSDatePicker

00:30:02.769 --> 00:30:06.440
它允許我們展示一個UI
並讓你的用戶選擇日期

00:30:06.507 --> 00:30:09.209
除去其他屬性
它有兩個能夠控制日期的屬性

00:30:09.510 --> 00:30:11.612
你能在這裏看到
它們被標成了@NSCopying

00:30:11.712 --> 00:30:13.647
它們是NSDate引用類型的

00:30:14.948 --> 00:30:17.184
在Swift 3
不改變AppKit前提下

00:30:17.451 --> 00:30:20.821
我們只改變了Foundation
這個類現在看起來是這樣的

00:30:20.888 --> 00:30:22.756
你看 我們現在有Date結構類型了

00:30:22.823 --> 00:30:27.160
而且我們不需把它標作@NSCopying了
因爲他們是數值類型

00:30:27.227 --> 00:30:28.795
我們會幫你進行復制

00:30:32.132 --> 00:30:34.801
進行橋接可能會有一定的性能折損

00:30:34.868 --> 00:30:37.771
爲了介紹原因
我需要深入講解一下具體細節

00:30:37.838 --> 00:30:39.573
橋接的原理究竟是什麼

00:30:39.873 --> 00:30:42.743
橋接有兩個主要策略
一個針對大型類型

00:30:42.809 --> 00:30:45.445
它會存儲引用
另一個針對小型類型

00:30:45.512 --> 00:30:46.680
它會創建引用

00:30:47.314 --> 00:30:49.550
舉個例子
我們再討論一下數據

00:30:51.118 --> 00:30:52.452
我又創建了一次data

00:30:52.519 --> 00:30:54.755
它是一個結構體
包含了一個引用類型數據

00:30:55.222 --> 00:30:57.324
若調用
Objective-C的API

00:30:57.391 --> 00:31:01.128
將會發生的是 我們把引用交到
Objective-C端處理

00:31:01.261 --> 00:31:03.897
因爲Objective-C
不會處理結構體數據

00:31:03.964 --> 00:31:05.499
它只能看懂NSData

00:31:05.933 --> 00:31:08.168
在這個例子裏
也許對於同步方法調用

00:31:08.235 --> 00:31:11.572
Objective-C的代碼
在任何時間都不會持有這個數據

00:31:11.638 --> 00:31:13.373
它可以訪問它
隨後就忘記它

00:31:13.440 --> 00:31:16.510
僅僅保存一小段時間引用即可

00:31:17.110 --> 00:31:22.416
你會看到
許多API會長時間持有數據

00:31:22.482 --> 00:31:25.953
通常會被標註上Copying屬性

00:31:26.854 --> 00:31:28.789
那樣 在Objective-C中

00:31:29.056 --> 00:31:31.692
Objective-C代碼
會調用數據的複製方法

00:31:32.059 --> 00:31:33.760
因爲它需要保護自己

00:31:33.827 --> 00:31:36.864
以免潛在的對於原始數據的修改

00:31:36.930 --> 00:31:38.332
從一個完全未知的來源

00:31:39.199 --> 00:31:42.469
這意味着 當發生橋接時
可能發生數據的複製

00:31:43.237 --> 00:31:44.371
我們把它翻過來看

00:31:44.471 --> 00:31:47.274
這裏是一段Swift代碼
它調用了Objective-C方法

00:31:47.341 --> 00:31:48.742
並獲取返回的數據

00:31:48.809 --> 00:31:52.779
這裏 Objective-C代碼
創建了NSData類

00:31:52.846 --> 00:31:54.281
當它回到Swift的時候

00:31:54.648 --> 00:31:56.984
我們建立結構體數據
並把引用包含其中

00:31:57.050 --> 00:32:00.354
然後調用複製方法
原因和上一頁演示文檔說的一樣

00:32:00.721 --> 00:32:03.156
這個結構體需要保持
它對這份副本的控制

00:32:03.223 --> 00:32:06.426
這樣它纔可以向你提供
正確的語義

00:32:07.895 --> 00:32:10.330
幸運的是 基本上所有通過這個方式
接收到的來自SDK的數據

00:32:10.397 --> 00:32:12.032
都是不可變的

00:32:12.232 --> 00:32:14.501
這意味着 這份副本在本質上
只用於保持計數

00:32:14.568 --> 00:32:16.403
但是有一點很重要
需要明白

00:32:16.470 --> 00:32:18.872
當橋接的時候
可能會出現複製操作

00:32:19.940 --> 00:32:23.377
對於小的類型 比如Date
你會發現並不存在引用

00:32:23.443 --> 00:32:25.846
我們剛纔看到了它的實現
只有一個Double

00:32:25.913 --> 00:32:30.384
所以在Swift裏 若我調用了一個
Objective-C的函數或方法

00:32:30.851 --> 00:32:35.656
它接受一個Date 我們需通過橋接
分配一個NSDate

00:32:36.323 --> 00:32:39.893
那是因爲Objective-C代碼
只知道如何處理引用類型

00:32:40.194 --> 00:32:41.995
在Objective-C方面
我們採用了很多技巧

00:32:42.062 --> 00:32:44.831
使NSDate分配的開銷很小

00:32:45.132 --> 00:32:49.002
這點很重要 我們要明白
橋接的時候會產生內存分配

00:32:53.473 --> 00:32:56.043
所以我們優化了這些數據類型
以適配Swift

00:32:56.910 --> 00:33:00.814
在你的編碼中
你應該避免來回橋接

00:33:01.748 --> 00:33:04.251
這是因爲我們想讓我們的
編碼默認是安全的

00:33:04.585 --> 00:33:07.087
但是它確實說明
在這裏可能有潛在的複製操作

00:33:07.154 --> 00:33:10.958
這是使用新的數值類型時
需要注意的幾點

00:33:12.059 --> 00:33:13.594
現在咱們來談一談遷移

00:33:14.261 --> 00:33:15.462
先來說說好消息

00:33:16.096 --> 00:33:19.833
我們今天說的新類型
適用於所有Swift部署目標

00:33:20.400 --> 00:33:22.369
這些都是Swift標準庫的一部分

00:33:22.436 --> 00:33:24.204
所以你不需要等待客戶

00:33:24.271 --> 00:33:26.673
升級到我們最新版本的平臺

00:33:26.740 --> 00:33:28.909
一旦Swift 3和
Xcode 8發佈

00:33:28.976 --> 00:33:30.677
你馬上就可以使用它們

00:33:32.112 --> 00:33:34.982
現在 爲了幫助你
我們升級了Migrator

00:33:35.349 --> 00:33:38.585
這就代表當你打開Xcode 8裏
你的項目

00:33:38.652 --> 00:33:42.189
你會看到一個類似這個的對話框
我建議你點擊Convert

00:33:42.489 --> 00:33:45.726
我來展示一下
Migrator可以幫你做的一些事

00:33:47.227 --> 00:33:49.663
現在我們在Swift 2.2中
有一些NSDate

00:33:50.163 --> 00:33:53.066
我們調用它的
dateByAddingTimeInterval方法

00:33:53.400 --> 00:33:56.470
Migrator會把NSDate
這個引用類型

00:33:56.537 --> 00:33:58.505
修改爲結構類型的Date

00:33:59.139 --> 00:34:01.041
然後它會改變方法

00:34:01.241 --> 00:34:04.645
因爲它們已依據最新的Swift 3
API設計指引進行了修改

00:34:04.945 --> 00:34:07.381
無論是針對引用類型
還是數值類型

00:34:08.549 --> 00:34:09.683
我們再來舉一個例子

00:34:10.016 --> 00:34:12.652
我在Swift 2裏創建了一個
NSDateComponents

00:34:12.886 --> 00:34:15.222
然後對它的屬性進行了設定

00:34:15.789 --> 00:34:19.893
我能做到這些是因爲NSDateComponents
永遠是可變的引用類型

00:34:20.561 --> 00:34:23.463
Swift 3裏引入了新的結構體
DateComponents

00:34:23.597 --> 00:34:26.166
所以Migrator
會把引用變成結構

00:34:26.366 --> 00:34:30.469
但是它注意到你對它進行了修改
所以它還會幫你把let改成var

00:34:31.438 --> 00:34:33.540
Migrator可以幫你做很多

00:34:33.806 --> 00:34:36.844
但有些地方
如果你檢查一下它做了什麼

00:34:36.909 --> 00:34:40.347
你自己可以做到更好
利用我們提供的新功能

00:34:40.647 --> 00:34:43.516
該例中DateComponents
有一個新的initializer

00:34:43.583 --> 00:34:45.585
這我們只能在Swift裏做到

00:34:45.786 --> 00:34:49.389
這個initializer爲 DateComponents
裏的每一個屬性提供了參數

00:34:49.456 --> 00:34:51.725
這些都不是必需項
而且都有默認值

00:34:51.792 --> 00:34:54.962
你可只利用自己在乎的值
創建DateComponents

00:34:55.027 --> 00:34:56.463
比如這個例子裏
只提供月和日

00:34:56.697 --> 00:34:58.165
然後把var變回let

00:34:58.232 --> 00:35:01.435
因爲初始化後
你不需要改變它

00:35:03.337 --> 00:35:05.005
最後又要說到我們的朋友
Data類型了

00:35:05.072 --> 00:35:08.075
Swift 2裏我建立了
一個NSMutableData

00:35:08.175 --> 00:35:10.577
它是一個引用類型
然後我給它添加了一些數據

00:35:11.778 --> 00:35:14.581
在Swift 3裏
Migrator會處理好方法名稱

00:35:14.781 --> 00:35:18.218
比如contentsOfURL
以及appendData

00:35:19.319 --> 00:35:21.822
而且它會把NSData
變成Data結構

00:35:22.222 --> 00:35:25.025
但是 它沒有處理
NSMutableData引用類型

00:35:25.459 --> 00:35:27.961
有些情況下 信息量不夠

00:35:28.028 --> 00:35:30.731
Migrator沒辦法
做到我們認爲最佳的選擇

00:35:30.797 --> 00:35:33.267
我們不去管它
它依然能正常運行

00:35:33.700 --> 00:35:37.004
但是如果你回去自己做一些修補

00:35:37.070 --> 00:35:38.605
你可以做到些很酷的事情

00:35:38.672 --> 00:35:41.074
我們可以把MutableData
變成Data結構

00:35:41.575 --> 00:35:43.544
即我們把它從let改爲var

00:35:43.810 --> 00:35:47.447
還可以刪除掉options參數
因爲它現在已經有默認值了

00:35:50.484 --> 00:35:53.820
我們今天談了不少東西
現在讓我們來稍微回顧一下

00:35:54.421 --> 00:35:56.456
相信這些對Foundation的改進

00:35:56.523 --> 00:35:58.525
會讓整個SDK受益

00:35:58.592 --> 00:36:00.928
並提升你的整個Swift開發體驗

00:36:01.328 --> 00:36:03.530
一方面是由於API重命名

00:36:03.897 --> 00:36:06.433
另外我們把握住了機會更進一步

00:36:06.567 --> 00:36:10.470
添加了一套全新的數據類型
以及很多針對Swift的新API

00:36:11.538 --> 00:36:13.473
我們將此視爲一段旅程的開始

00:36:13.540 --> 00:36:16.910
並且在未來
我們也願意繼續成爲支點

00:36:17.311 --> 00:36:19.112
我們要做很多改進

00:36:19.179 --> 00:36:22.082
讓你的Swift應用
更安全 更迅速 表達性更好

00:36:23.217 --> 00:36:25.552
有興趣多瞭解的話
去查看下這個URL結構

00:36:26.453 --> 00:36:29.323
以及這些相關演講 包括

00:36:29.389 --> 00:36:32.426
使用Swift Open Source深入服務器端
Measurement類型和Unit類型

00:36:34.127 --> 00:36:35.028
謝謝大家