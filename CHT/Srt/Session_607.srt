00:00:19.353 --> 00:00:23.090 
Apple TV遊戲輸入控制

00:00:27.094 --> 00:00:27.928 
謝謝大家

00:00:27.995 --> 00:00:32.366 
大家好 歡迎參加Apple TV
遊戲輸入控制研討會

00:00:32.900 --> 00:00:36.103 
我是JJ Cwik
遊戲技術軟件工程師

00:00:38.305 --> 00:00:41.241 
我們在去年九月
重新引入了Apple TV

00:00:41.308 --> 00:00:43.644 
並且提到了10英尺體驗

00:00:44.244 --> 00:00:46.947 
這作爲一種共享的公衆體驗

00:00:47.381 --> 00:00:50.584 
是真正適合遊戲設置中
較長的會話的體驗

00:00:51.385 --> 00:00:52.719 
事實是

00:00:52.786 --> 00:00:55.455 
人們就喜歡在客廳玩兒遊戲

00:00:56.156 --> 00:00:57.824 
Apple TV無疑是理想選擇

00:00:58.358 --> 00:01:00.194 
Apple TV爲你提供所需工具

00:01:00.260 --> 00:01:02.696 
創建引人注目的遊戲體驗

00:01:03.597 --> 00:01:07.334 
今天 我很高興地跟大家
一起探討Siri Remote、

00:01:07.734 --> 00:01:11.805 
MFi遊戲控制器以及如何完美地
將兩者整合到遊戲中

00:01:13.373 --> 00:01:18.078 
在我開始爲大家劇透之前 先來看看
tvOS 10裏增加了什麼新特性

00:01:18.679 --> 00:01:20.013 
正如你們在本週一所瞭解的

00:01:20.981 --> 00:01:25.686 
有些遊戲不是Siri Remote
支持的高級遊戲機制

00:01:26.019 --> 00:01:33.026 
這些遊戲可以把需要遊戲控制器
的需求選擇性地包含進來

00:01:34.661 --> 00:01:38.899 
現在 我們最多能支持四個
MFi遊戲控制器

00:01:39.166 --> 00:01:41.535 
這對於多玩家遊戲來說
無疑是個好消息

00:01:42.903 --> 00:01:46.740 
我們還在本週一發佈了一個
Apple TV遙控器應用

00:01:47.207 --> 00:01:49.610 
用於控制Apple TV

00:01:50.077 --> 00:01:52.412 
並充當遊戲輸入設備

00:01:53.146 --> 00:01:55.649 
我將在本場研討會中逐一談到以上幾點

00:01:55.716 --> 00:01:56.750 
好了 讓我們開始吧

00:01:58.752 --> 00:02:00.687  
tvOS上的應用

00:02:01.655 --> 00:02:04.091  
一般是從聚焦引擎 獲取輸入數據

00:02:05.225 --> 00:02:09.696  
或從觸摸和手勢中

00:02:10.464 --> 00:02:12.533 
但還有第三種方式

00:02:12.599 --> 00:02:15.936 
即從Siri遙控器 直接讀取輸入

00:02:16.003 --> 00:02:19.006 
和使用遊戲控制器框架的遊戲控制器上

00:02:20.774 --> 00:02:24.044 
現在我簡要描述一下游戲控制器框架

00:02:24.111 --> 00:02:25.913 
你們中可能有人沒接觸過它

00:02:26.647 --> 00:02:29.116 
遊戲控制器框架最初

00:02:29.183 --> 00:02:32.452 
用於將第三方遊戲控制器植入到遊戲中

00:02:33.020 --> 00:02:36.423 
我們把這些兼容的遊戲控制器
叫做MFi控制器

00:02:37.391 --> 00:02:39.193 
自從框架更新後

00:02:39.259 --> 00:02:41.461 
框架也支持Siri遙控器了

00:02:43.564 --> 00:02:47.768 
遊戲控制器框架是一個標準化的
簡單API

00:02:47.835 --> 00:02:52.873 
可以獲取所有控制器並使用
相同的API調用

00:02:52.940 --> 00:02:55.409 
而無論控制器的供應商是誰

00:02:56.743 --> 00:02:59.046 
它使控制器的檢測變得標準化

00:03:00.047 --> 00:03:03.183 
它會 無縫處理控制器的連接和斷開

00:03:03.250 --> 00:03:04.618 
在遊戲運行時

00:03:05.552 --> 00:03:08.021 
並允許你控制輸入

00:03:08.088 --> 00:03:10.591 
更確切地說是從控制器中讀取輸入

00:03:10.657 --> 00:03:12.960 
用輪詢或事件驅動模型

00:03:14.194 --> 00:03:18.932 
這在tvOS、iOS和
MacOS上都能用

00:03:19.666 --> 00:03:22.736 
所以 雖然這場演講是面向tvOS的

00:03:22.803 --> 00:03:27.307 
但是大量代碼和概念
都能用在iOS和macOS上

00:03:29.343 --> 00:03:32.079 
現在你應該對框架有了大概的瞭解

00:03:32.145 --> 00:03:34.615 
我再具體說一下

00:03:35.716 --> 00:03:36.984 
有一個核心類

00:03:37.050 --> 00:03:39.553 
在遊戲控制器框架中
叫GCController

00:03:39.853 --> 00:03:41.755 
這代表着實物控制器...

00:03:42.389 --> 00:03:44.591 
Siri遙控器 也是用這個類

00:03:44.658 --> 00:03:46.260 
和MFi遊戲控制器

00:03:48.061 --> 00:03:51.231 
在應用中 你最想做的第一件事可能

00:03:51.632 --> 00:03:54.268 
就是獲得一份當前所有
已連接的控制器的列表

00:03:54.635 --> 00:03:59.072 
你就得在GCController中
使用控制器的類方法

00:03:59.606 --> 00:04:02.709 
這會返回一份當前已連接的控制器列表

00:04:02.776 --> 00:04:05.078 
是GCController實例數組

00:04:05.779 --> 00:04:08.215 
如果沒有的話 就返回一個空數組

00:04:10.717 --> 00:04:13.987 
控制器連接和斷開是常事兒

00:04:14.054 --> 00:04:15.455 
在應用運行時

00:04:16.690 --> 00:04:19.793 
要想知道什麼時候連接和斷開
就需要 添加觀察者

00:04:19.860 --> 00:04:23.830 
給GCCcontrollerDidConnect
Notification

00:04:23.897 --> 00:04:26.533 
和GCControllerDidDisconnect
Notification

00:04:27.568 --> 00:04:29.102 
理想位置是在

00:04:29.169 --> 00:04:32.172 
應用的Did Finish Launching
with Options中添加

00:04:34.241 --> 00:04:36.310 
我們現已知道哪些控制器已連接

00:04:36.376 --> 00:04:39.012 
我要把重心轉移到Siri遙控器上來

00:04:39.546 --> 00:04:43.317 
Siri遙控器 作爲遊戲控制器
充當遊戲觸摸表面

00:04:43.383 --> 00:04:45.786 
通過我剛提到的
GCController類

00:04:47.120 --> 00:04:50.858 
在遊戲控制器框架中
有這種profile的概念

00:04:50.924 --> 00:04:54.127 
以及profiles集合的常見功能

00:04:54.561 --> 00:04:56.730 
Siri遙控器支持
這兩種profile

00:04:57.397 --> 00:05:00.367 
第一個profile
叫GCMicroGamepad

00:05:00.868 --> 00:05:03.537 
用於操作觸摸表面

00:05:03.604 --> 00:05:05.672 
和Siri 遙控器上的按鈕

00:05:07.074 --> 00:05:12.045 
Siri遙控器支持的第二個
profile叫GCMotion

00:05:12.579 --> 00:05:15.082 
用於 獲得陀螺儀

00:05:15.148 --> 00:05:17.251 
和加速計 在Siri 遙控器上

00:05:18.118 --> 00:05:21.655 
請注意 跟iOS上的習慣不一樣

00:05:21.989 --> 00:05:24.525 
在iOS上 動作通過
CoreMotion框架表達

00:05:25.726 --> 00:05:29.062 
而在tvOS上 動作通過
遊戲控制器框架表達

00:05:30.297 --> 00:05:32.633 
那麼 讓我們依次看一下
每種profile

00:05:33.166 --> 00:05:35.502 
首先是GCMicroGamepad

00:05:37.971 --> 00:05:40.274 
Siri遙控器上的觸摸表面

00:05:40.340 --> 00:05:44.011 
會作爲各種虛擬DPAD
在遊戲中體現出來

00:05:44.645 --> 00:05:49.850 
你可以用模擬表示法來
查詢DPAD的值

00:05:49.917 --> 00:05:51.652 
是一個XY座標對

00:05:52.152 --> 00:05:57.524 
或一種數碼輸入 基本上有四個按鈕
分別是上、下、左、右

00:06:00.994 --> 00:06:04.097 
GCMicroGamepad
profile還有一A按鈕

00:06:04.164 --> 00:06:06.433 
相當於點擊遙控器

00:06:07.000 --> 00:06:10.537 
這個非常適合作爲遊戲的原始動作

00:06:10.604 --> 00:06:13.574 
尤其是當豎着拿着遙控器時

00:06:16.009 --> 00:06:18.212 
並且這個profile
還有一個X按鈕

00:06:18.812 --> 00:06:21.615 
這個作爲遊戲中的第二個
動作很有幫助

00:06:22.316 --> 00:06:25.853 
而且當遙控器朝側面傾斜
很自然地

00:06:25.919 --> 00:06:29.923 
和橫向拿着時 大拇指一般會
放在觸摸表面上

00:06:29.990 --> 00:06:31.992 
並且另一個大拇指會
放在X按鈕上

00:06:33.794 --> 00:06:36.797 
請注意 這個遙控器上還有一個
菜單按鈕

00:06:37.231 --> 00:06:39.166 
我們稍後會再談

00:06:39.867 --> 00:06:43.403 
遙控器上的其它按鈕將留作
系統使用

00:06:46.673 --> 00:06:48.876 
這裏有段示例代碼 演示有多麼簡單

00:06:48.942 --> 00:06:50.711 
從按鈕中讀取數據

00:06:51.411 --> 00:06:55.415 
在這裏 我們看到
已經連接了一個控制器

00:06:55.983 --> 00:06:59.019 
這樣我們就可以從MicroGamepad
profile中讀取數據了

00:06:59.786 --> 00:07:02.956 
MicroGamepad profile存儲了
A按鈕和X按鈕屬性

00:07:03.257 --> 00:07:05.959 
我們只看一下isPressed屬性

00:07:06.026 --> 00:07:08.762 
這個屬性將確定是否按了
這些按鈕

00:07:10.030 --> 00:07:12.299 
我們還支持一種事件驅動模型

00:07:12.733 --> 00:07:14.001 
所以 如果你想得知

00:07:14.067 --> 00:07:17.604 
是什麼時候按下按鈕的 若不想做輪詢
你可以使用事件驅動模型

00:07:19.006 --> 00:07:21.275 
這些叫做pressedChangeHandler

00:07:21.708 --> 00:07:25.479 
這個代碼塊會在按鈕變更狀態時運行

00:07:26.246 --> 00:07:29.016 
通常來說按下按鈕的通知會被調用兩次

00:07:29.082 --> 00:07:31.985 
一次是按下去 一次是彈起來

00:07:33.387 --> 00:07:34.555 
以上說的是按鈕

00:07:34.621 --> 00:07:35.956 
現在讓我們來看DPAD

00:07:36.823 --> 00:07:40.994 
我剛纔說過 DPAD可讀取四個按鈕
分別是上、下、左、右

00:07:41.061 --> 00:07:43.530 
有意思的是 還有另外種陳述

00:07:43.597 --> 00:07:46.266 
是兩個座標軸 X軸和Y軸

00:07:46.600 --> 00:07:47.668 
現在讓我們來看一下

00:07:49.436 --> 00:07:52.406 
你可看到MicroGamepad上
有一個DPAD屬性

00:07:52.873 --> 00:07:55.409 
有X軸和Y軸兩個屬性

00:07:55.909 --> 00:07:57.711 
我們可以讀取這兩個屬性的值

00:07:57.778 --> 00:08:02.049 
並返回一個浮動的標準值在0或 抱歉

00:08:02.115 --> 00:08:05.018 
在負1和正1之間的標準值

00:08:06.620 --> 00:08:09.556 
正如你所期待的那樣
我們還有個事件回調可用

00:08:09.623 --> 00:08:13.460 
請注意 在這種情況下
我們使用了值變更處理器

00:08:13.527 --> 00:08:15.062 
或我們提供了一值變更處理器

00:08:15.128 --> 00:08:18.732 
在DPAD上 而不是在X軸和Y軸上

00:08:18.899 --> 00:08:23.537 
這是因爲我們想在任何一個軸
發生變化時都得到通知

00:08:26.206 --> 00:08:29.743 
DAPD遙控器有一些很有意思的地方

00:08:29.810 --> 00:08:31.445 
我想具體談一下

00:08:38.452 --> 00:08:40.921 
第一個是DPAD開窗

00:08:41.621 --> 00:08:43.490 
這是什麼呢 這實際是定義

00:08:43.557 --> 00:08:47.027 
DAPD的X軸和Y軸的原點

00:08:48.095 --> 00:08:51.198 
現在你可能會想
原點不應該總是在中心嗎

00:08:51.265 --> 00:08:54.401 
很多時候 這個問題的答案是
不見得

00:08:54.935 --> 00:08:57.671 
很多時候 玩家並不會太關注

00:08:57.738 --> 00:09:01.175 
他們在觸摸表面上正在觸摸的精確位置

00:09:01.241 --> 00:09:04.178 
他們只是想把大拇指放在
觸摸表面上並相對 移動

00:09:04.244 --> 00:09:05.846 
於他們最開始觸摸的地方

00:09:06.346 --> 00:09:08.248 
DAPD開窗允許你

00:09:08.315 --> 00:09:11.018 
作爲遊戲開發者去挖掘這個相對動作

00:09:11.451 --> 00:09:15.422 
因此會在觸摸表面上的
初始觸摸點創建一個原點

00:09:15.489 --> 00:09:20.093 
然後 從那之後的進一步移動
會有一個DAPD值報告給

00:09:20.160 --> 00:09:22.196 
相對於原點的 遊戲

00:09:22.863 --> 00:09:24.298 
讓我們舉例解釋一下

00:09:25.399 --> 00:09:28.235 
這是觸摸表面
我把我的大拇指按在這兒

00:09:28.435 --> 00:09:31.305 
請注意 我並沒按在觸摸表面的正中央

00:09:32.005 --> 00:09:34.041 
但啓用DPAD開窗以後

00:09:34.675 --> 00:09:39.079 
這裏將作爲X軸和Y軸的原點

00:09:39.680 --> 00:09:42.883 
請注意 有一個虛構的DPAD窗口

00:09:42.950 --> 00:09:45.586 
位於以原點爲中心的區域的外部

00:09:46.386 --> 00:09:49.323 
請看 當我的拇指劃過
觸摸表面時會發生什麼

00:09:51.391 --> 00:09:54.761 
報告給遊戲的值是相對於這個原點的

00:09:54.828 --> 00:09:57.197 
並跟窗口的尺寸成一定比例

00:09:57.898 --> 00:10:01.502 
現在 我繼續在觸摸表面移動拇指

00:10:01.568 --> 00:10:05.005 
會同時拖動窗口和兩個軸一起移動

00:10:06.306 --> 00:10:09.009 
現在 我們已經建立了一個新原點

00:10:09.076 --> 00:10:11.845 
在觸摸表面上的進一步的移動

00:10:11.912 --> 00:10:15.482 
都會有相對於這個新原點的
DPAD值報告給遊戲

00:10:16.116 --> 00:10:17.518 
這就是DPAD開窗

00:10:18.652 --> 00:10:21.588 
如果你想始終接收DPAD的絕對值

00:10:21.655 --> 00:10:26.059 
你可以使用
reportsAbsoluteDpadValues屬性

00:10:26.593 --> 00:10:27.928 
將它設爲真

00:10:28.762 --> 00:10:30.564 
這樣我們總是能將原點

00:10:30.631 --> 00:10:33.300 
定位在觸摸表面的正中央

00:10:34.034 --> 00:10:37.337 
然後 我按下拇指並在觸摸表面上移動

00:10:37.404 --> 00:10:39.573 
所有值都是相對於

00:10:39.640 --> 00:10:41.742 
觸摸表面的正中心的

00:10:43.143 --> 00:10:44.511 
那麼這就是DPAD開窗

00:10:49.249 --> 00:10:50.651 
下一個講旋轉

00:10:51.852 --> 00:10:54.454 
遊戲的DPAD值

00:10:54.521 --> 00:10:59.793 
是以縱向爲前提的 意思就是
當X軸向右 Y軸向上時

00:11:00.827 --> 00:11:02.296 
但是 這可能會導致一個問題

00:11:02.362 --> 00:11:05.165 
如果玩家想橫向玩兒呢？

00:11:05.699 --> 00:11:09.303 
在這種情況下
你的遊戲就需要調換這些值

00:11:09.703 --> 00:11:11.805 
使遊戲在橫向時也能正常運行

00:11:12.673 --> 00:11:16.210 
但是 如果用戶朝相反方向傾斜
遙控器會怎麼樣呢

00:11:16.276 --> 00:11:19.279 
你就需要將這些值調換爲
相反方向時的值

00:11:20.514 --> 00:11:21.849 
那麼 要如何實現呢

00:11:21.915 --> 00:11:24.351 
要麼就強制用戶

00:11:24.418 --> 00:11:26.753 
始終按指定方位玩兒遊戲

00:11:27.221 --> 00:11:29.456 
要麼就得讀取加速計數據

00:11:29.523 --> 00:11:31.525 
並追蹤方位變更

00:11:31.925 --> 00:11:33.694 
但你並不想這麼做

00:11:34.161 --> 00:11:37.531 
所以我們提供了一個叫
allowsRotation的屬性

00:11:37.898 --> 00:11:40.300 
這個屬性的默認設置爲假

00:11:40.701 --> 00:11:44.638 
如果把它設爲真
那麼報告給遊戲的DPAD值

00:11:45.005 --> 00:11:48.575 
會匹配遙控器的任何一種方位

00:11:49.109 --> 00:11:52.546 
當這個屬性設爲真
並當遙控器爲縱向方位時

00:11:52.613 --> 00:11:54.915 
X軸向右 Y軸向上

00:11:56.116 --> 00:11:59.486 
在左橫向方位時
X軸向右 Y軸向上

00:12:00.554 --> 00:12:05.192 
在右橫向方位時 你猜對了
X軸向右 Y軸向上

00:12:06.126 --> 00:12:10.097 
所以 如果你的遊戲要允許玩家
在橫向方位玩兒遊戲

00:12:10.163 --> 00:12:12.065 
就要把允許旋轉設爲真

00:12:12.432 --> 00:12:14.835 
這樣你就不用擔心方位變更

00:12:14.902 --> 00:12:16.603 
或需要自己旋轉DPAD值了

00:12:18.005 --> 00:12:19.139 
那麼這就是旋轉

00:12:19.673 --> 00:12:20.874 
下一個講動作

00:12:22.075 --> 00:12:24.945 
我前面提到過 第二個profile

00:12:25.012 --> 00:12:27.848 
Siri遙控器支持的
叫GCMotion

00:12:28.882 --> 00:12:31.919 
當用戶移動遙控器時 重力

00:12:31.985 --> 00:12:36.690 
由GCMotion profile提供
用戶加速度矢量中的 就會被更新

00:12:38.091 --> 00:12:41.428 
請注意 這些值在接觸遊戲
之前已經被過濾了

00:12:41.695 --> 00:12:43.597 
那麼 如果你有一個tvOS遊戲

00:12:43.864 --> 00:12:46.967 
並且你正在做動作過濾
我們建議你把它移除

00:12:47.034 --> 00:12:50.137 
這樣就不會給遊戲造成
任何不必要的滯後

00:12:51.905 --> 00:12:56.176 
另外 這是混合動作數據
我的意思是

00:12:56.243 --> 00:12:59.947 
加速計和陀螺儀會 加強

00:13:00.013 --> 00:13:01.114 
相互 和矯正

00:13:01.682 --> 00:13:05.586 
就像在iPhone上一樣
重力矢量

00:13:05.652 --> 00:13:09.957 
加速計中的
會矯正陀螺儀中的漂移

00:13:10.757 --> 00:13:12.459 
並且陀螺儀數據會

00:13:12.526 --> 00:13:15.362 
使加速計中的值保持順暢

00:13:15.929 --> 00:13:17.197 
它們相互增強

00:13:18.098 --> 00:13:20.734 
實際上
劇烈運動會淹沒這種作用

00:13:21.168 --> 00:13:25.405 
正因爲如此 我們建議你
在遊戲中避免創建 情境

00:13:25.472 --> 00:13:28.675 
需要用戶劇烈搖動遙控器的

00:13:29.309 --> 00:13:31.912 
因爲這會使數據很難
保持準確性

00:13:31.979 --> 00:13:34.314 
直到傳感器能夠找到機會固定下來

00:13:37.050 --> 00:13:39.920 
接下來 我想說一下菜單按鈕

00:13:43.423 --> 00:13:46.159 
現在 tvOS支持的所有控制器

00:13:46.226 --> 00:13:48.562 
在遊戲控制器框架中
都有一個菜單按鈕

00:13:49.162 --> 00:13:52.799 
跟Siri遙控器 菜單按鈕一樣
行爲也一樣

00:13:52.866 --> 00:13:54.902 
和MFi遊戲控制器上的

00:13:58.872 --> 00:14:01.875 
在tvOS的app中

00:14:01.942 --> 00:14:06.046 
當按下菜單按鈕時 行爲變更

00:14:06.113 --> 00:14:07.514 
是由情境因素決定的

00:14:08.015 --> 00:14:11.351 
有時候按菜單按鈕會最小化應用

00:14:11.785 --> 00:14:13.921 
並返回Apple TV主屏幕

00:14:15.489 --> 00:14:17.824 
通常是在遊戲的主菜單中實現的

00:14:18.692 --> 00:14:22.663 
而其他時候按菜單按鈕會返回 上一級

00:14:22.729 --> 00:14:25.632 
應用菜單級的

00:14:25.699 --> 00:14:27.668 
通常是在子菜單中實現的

00:14:30.237 --> 00:14:33.874 
最後 有時候按菜單按鈕會暫停

00:14:33.941 --> 00:14:35.976 
或重新開始激活的遊戲設置

00:14:38.979 --> 00:14:43.650 
非遊戲應用完全是在UIKit中
進行編碼的

00:14:44.084 --> 00:14:47.888 
在很大程度上 會毫不費力地得到
前兩種行爲 而不用做任何額外的工作

00:14:48.889 --> 00:14:54.428 
但是對於大多數遊戲來說 由於有
自定義UI 必須做一些額外的工作

00:14:54.494 --> 00:14:56.396 
來向系統傳達它們的意圖

00:14:57.164 --> 00:14:58.131 
讓我具體解釋一下

00:15:00.667 --> 00:15:05.439  
在UIKit中
當按下UIKit應用的菜單按鈕時

00:15:05.506 --> 00:15:08.141  
會使子視圖控制器突然離開堆棧

00:15:08.408 --> 00:15:11.478  
這就使你返回菜單的上一級

00:15:12.546 --> 00:15:16.884  
你可以依次執行 每次按下菜單按鈕

00:15:16.950 --> 00:15:19.386  
使子視圖控制器突然離開堆棧

00:15:19.453 --> 00:15:22.356  
然後在某一時刻
你只有一個視圖控制器了

00:15:22.422 --> 00:15:24.491 
就是你的根視圖控制器
它會留在堆棧中

00:15:25.526 --> 00:15:27.995  
當堆棧中只有一個視圖控制器時

00:15:28.061 --> 00:15:30.898  
下一次按下菜單按鈕時
會最小化應用

00:15:30.964 --> 00:15:33.433  
並使你返回Apple TV的主屏幕

00:15:35.002 --> 00:15:38.405  
相比之下
大部分遊戲的結構都不一樣

00:15:38.739 --> 00:15:42.543  
通常遊戲中的UI都是自定義的
這並不是在UIKit中進行編碼的

00:15:43.243 --> 00:15:45.646  
並且遊戲一般有 場景轉換

00:15:45.712 --> 00:15:49.917  
不同部分之間的
這也不能在UIKit中進行編碼

00:15:52.119 --> 00:15:55.155  
正因爲如此 它們一般能 被釋放

00:15:55.222 --> 00:15:57.925  
通過只剩一個視圖控制器
即根視圖控制器

00:15:57.991 --> 00:15:59.760  
在遊戲的整個持續過程中

00:16:00.294 --> 00:16:02.162  
但按照我們剛說的規則

00:16:02.229 --> 00:16:06.133  
因爲在堆棧中只有一個視圖控制器
那麼在遊戲的各個層面上

00:16:06.200 --> 00:16:08.936 
按菜單按鈕將默認彈回

00:16:09.002 --> 00:16:10.270 
Apple TV主屏幕

00:16:10.871 --> 00:16:13.707 
那麼你就需要某種方式向系統傳達

00:16:13.774 --> 00:16:15.943 
何時按菜單按鈕

00:16:16.009 --> 00:16:19.379 
返回Apple TV主屏幕及何時
按菜單按鈕不返回Apple TV主屏幕

00:16:21.014 --> 00:16:23.483 
進入GCEventViewController

00:16:28.055 --> 00:16:31.692 
這是一個爲單一玩家
創建的特殊視圖控制器

00:16:31.758 --> 00:16:35.696 
或更準確地說 是爲有單一視圖
控制器的遊戲控制器遊戲

00:16:36.997 --> 00:16:38.866 
如果你正在做的就是這種遊戲

00:16:39.199 --> 00:16:42.603 
你應該把這個特殊視圖控制器
設爲你的根視圖控制器

00:16:44.271 --> 00:16:46.540 
這個視圖控制器有一個屬性叫

00:16:46.607 --> 00:16:48.775 
controllerUserInteractionEnabled

00:16:48.842 --> 00:16:51.245 
這是控制 的關鍵

00:16:51.311 --> 00:16:54.815 
什麼時候按菜單按鈕返回主屏幕的

00:16:56.717 --> 00:16:59.419 
當它的值爲假時
這個視圖控制器會有效地

00:16:59.486 --> 00:17:01.088 
截止按下菜單按鈕這個行爲

00:17:01.154 --> 00:17:03.824 
並阻止它們建立響應鏈

00:17:03.891 --> 00:17:05.692 
從而有效地讓你繼續待在應用中

00:17:07.728 --> 00:17:11.131 
偶爾也可用來調用控制器暫停處理器

00:17:11.198 --> 00:17:12.699 
我們稍後會講到

00:17:13.634 --> 00:17:15.801 
當這個值設爲真時

00:17:17.137 --> 00:17:19.740 
菜單按鈕事件就會 繼續建立

00:17:19.806 --> 00:17:21.842 
響應鏈 像平常一樣

00:17:22.709 --> 00:17:24.344 
這時應用會被最小化

00:17:24.411 --> 00:17:26.480 
並返回Apple TV主屏幕

00:17:27.414 --> 00:17:30.450 
你作爲遊戲開發者
你的工作是管理 狀態

00:17:30.517 --> 00:17:32.553 
controllerUser
InteractionEnabled的

00:17:32.619 --> 00:17:35.556 
當用戶在遊戲的不同部分
後退和前進時

00:17:36.190 --> 00:17:37.824 
我要給你們看一個方塊圖

00:17:38.125 --> 00:17:40.994 
那麼在Apple TV的主屏幕
我們啓動應用

00:17:41.495 --> 00:17:45.232 
有些遊戲有啓動畫面
而有些則是遊戲介紹

00:17:45.299 --> 00:17:49.870 
但最終 很多遊戲都會在
遊戲內部的主菜單着陸

00:17:50.470 --> 00:17:53.373 
無論是哪一種 用戶的期望是

00:17:53.440 --> 00:17:55.676 
當按菜單按鈕時 它們會立即返回

00:17:55.742 --> 00:17:57.578 
Apple TV的主屏幕

00:17:58.245 --> 00:18:01.448 
因此 要把controller
UserInteractionEnabled設爲真

00:18:02.382 --> 00:18:04.852 
當用戶繼續遊戲的其他部分時

00:18:04.918 --> 00:18:07.321 
比如激活的遊戲設置或在子菜單中

00:18:07.821 --> 00:18:10.757 
用戶的期望是按菜單按鈕後

00:18:10.824 --> 00:18:13.560 
不返回Apple TV的主屏幕

00:18:13.627 --> 00:18:14.561 
那麼在這些情況下

00:18:14.628 --> 00:18:17.364 
就把controllerUser
InteractionEnabled設爲假

00:18:17.998 --> 00:18:21.235 
如果用戶再回到
遊戲內部的主菜單

00:18:21.301 --> 00:18:23.270 
要記得把這個值再設爲真

00:18:25.205 --> 00:18:26.874 
這就是我們的第一個行爲

00:18:26.940 --> 00:18:30.010 
即何時返回Apple TV主屏幕
及何時不返回Apple TV主屏幕

00:18:30.344 --> 00:18:32.012 
我們還有另外兩個行爲

00:18:32.079 --> 00:18:35.082 
我們需要考慮返回子菜單

00:18:35.148 --> 00:18:37.150 
以及暫停和重新開始激活的遊戲設置

00:18:37.518 --> 00:18:40.120 
基本上就是這個圖解中顏色較暗的框

00:18:41.121 --> 00:18:45.225 
好消息是 這些都是在
controllerPausedHandler中得到處理的

00:18:46.360 --> 00:18:50.230 
controllerPausedHandler
是一個代碼塊 你要提供給

00:18:50.764 --> 00:18:54.168 
控制器
或者不如說是每個控制器

00:18:54.334 --> 00:18:57.104 
這個代碼塊會在
按菜單按鈕時運行

00:18:57.171 --> 00:18:59.973 
並不會把你帶回
Apple TV主屏幕

00:19:00.807 --> 00:19:04.344 
用這個代碼塊檢測是個很簡單的事兒

00:19:04.411 --> 00:19:08.949 
你是否在子菜單中需要返回上一級菜單

00:19:09.550 --> 00:19:12.352 
如果你在激活的遊戲設置中
就觸發暫停狀態

00:19:13.320 --> 00:19:17.624 
就這麼簡單 現在
按菜單按鈕的行爲處理地都很得當了

00:19:17.691 --> 00:19:19.526 
無論是在遊戲的哪個位置

00:19:25.032 --> 00:19:27.568 
現在讓我們來談談
MFi遊戲控制器

00:19:28.268 --> 00:19:31.471 
有些遊戲可以充分利用
擴展控制

00:19:31.538 --> 00:19:34.174 
由無線擴展手柄提供的

00:19:34.575 --> 00:19:37.177 
並且這些是玩家
可能會持有的可選附件

00:19:38.011 --> 00:19:42.015 
說到擴展 我們指的是控制佈局

00:19:42.082 --> 00:19:44.418 
而且很可能是你已經
很熟悉的佈局

00:19:44.885 --> 00:19:46.820 
左側有一個DPAD

00:19:47.087 --> 00:19:48.755 
四個面板按鈕

00:19:48.822 --> 00:19:51.992 
以A、B、X、Y出現在這些位置

00:19:52.059 --> 00:19:53.760 
右側有 菱形佈局

00:19:54.428 --> 00:19:57.231 
控制器的前方有兩個搖桿

00:19:57.631 --> 00:20:00.100 
頂部有兩個肩部按鈕和兩個觸發器

00:20:01.134 --> 00:20:03.570 
目前我提到的所有按鈕

00:20:04.004 --> 00:20:06.840 
都是壓敏性按鈕 我稍後再詳細解釋

00:20:07.641 --> 00:20:10.944 
還有剛討論過的菜單按鈕

00:20:11.011 --> 00:20:13.180 
以及四盞LED玩家指示器

00:20:14.982 --> 00:20:19.119 
就像Siri遙控器支持
GCMicroGamepad一樣

00:20:20.420 --> 00:20:24.491 
擴展遊戲控制器支持
GCExtendedGamepad profile

00:20:25.158 --> 00:20:28.662 
你會注意到
左側有一個表列出了所有屬性

00:20:29.496 --> 00:20:33.033 
還要注意數據類型
GCControllerDirectionPad

00:20:33.100 --> 00:20:35.202 
和GCControllerButtonInput

00:20:35.269 --> 00:20:38.038 
這兩個跟你在Siri遙控器上
所使用的數據類型相同

00:20:39.106 --> 00:20:41.742 
有一點我想單獨說一下
就是DPAD

00:20:41.808 --> 00:20:44.745 
和按鈕以及這個表上的
任何一個輸入

00:20:44.811 --> 00:20:46.780 
實際上都是壓敏性的

00:20:47.314 --> 00:20:52.052 
所以 即使我們通常認爲這些按鈕
和輸入只是一些數字

00:20:52.419 --> 00:20:54.521 
在你可能見過的其它控制器中

00:20:54.588 --> 00:20:57.457 
像DPAD和麪板按鈕以及肩部按鈕

00:20:57.958 --> 00:20:59.493 
都是壓敏性的

00:20:59.560 --> 00:21:02.429 
因此可以從模擬感應器
和數字感應器中讀取

00:21:03.664 --> 00:21:06.633 
讓我們看一下那個模擬數字對偶的代碼

00:21:07.234 --> 00:21:09.603 
以A按鈕爲例 第一行是

00:21:09.670 --> 00:21:13.373 
獲取是否按了按鈕的數字狀態

00:21:13.740 --> 00:21:16.543 
所以如果你的遊戲只在指定情況下

00:21:16.610 --> 00:21:19.513 
關注是否按了一個按鈕
你可以使用這行代碼來解決

00:21:21.114 --> 00:21:24.151 
然而 若你關注用了多大力度去按按鈕

00:21:24.785 --> 00:21:26.653 
那就要使用值屬性了

00:21:27.287 --> 00:21:29.890 
這可以給你的遊戲添加
更多的細微控制 效果很好

00:21:30.424 --> 00:21:32.292 
也許你正在創建一款運動遊戲

00:21:32.359 --> 00:21:35.429 
並且允許玩家改變傳遞的速度

00:21:35.495 --> 00:21:38.699 
從輕輕地傳遞到快速地傳遞

00:21:38.765 --> 00:21:41.969 
你可以通過讀取按按鈕的力度來實現

00:21:42.035 --> 00:21:43.170 
值屬性

00:21:44.838 --> 00:21:47.808 
正如你所期待的
我們還提供事件回調函數

00:21:48.275 --> 00:21:50.277 
請注意有一個
pressedChangeHandler

00:21:50.344 --> 00:21:52.446 
是響應按壓屬性的

00:21:52.513 --> 00:21:55.249 
用於變更布爾狀態或數字狀態

00:21:55.816 --> 00:21:59.119 
還有一個值變更屬性用於響應值或

00:21:59.620 --> 00:22:03.457 
抱歉 一個值變更處理器
用於響應值屬性

00:22:04.625 --> 00:22:09.296 
一般來說 按一次按鈕
會多次調用值變更處理器

00:22:09.363 --> 00:22:13.333 
因爲按鈕要被按下去
然後再彈回來

00:22:14.368 --> 00:22:15.869 
而對於想尋求指導的你們來說

00:22:15.936 --> 00:22:18.372 
是否使用輪詢或事件回調

00:22:18.939 --> 00:22:23.010 
並沒有硬性規定 但輪詢有利於

00:22:23.076 --> 00:22:27.347 
讀取那些在較長時間內持續變更的輸入

00:22:27.748 --> 00:22:30.184 
也許就像賽車遊戲中的加速器

00:22:30.250 --> 00:22:32.586 
被關聯到按鈕觸發器

00:22:32.653 --> 00:22:35.022 
或遊戲控制器的觸發器上

00:22:36.523 --> 00:22:39.826 
事件回調有利於

00:22:40.360 --> 00:22:42.963 
處理按鈕的邊緣過度

00:22:43.163 --> 00:22:46.567 
比如你有一款冒險遊戲
玩家揮舞自己的寶劍

00:22:47.034 --> 00:22:49.336 
如果你想 激活揮舞寶劍的動畫

00:22:49.403 --> 00:22:50.971 
在按按鈕的瞬間

00:22:51.071 --> 00:22:52.673 
那就要用到事件回調了
非常好用

00:22:55.976 --> 00:22:58.745 
在這點上 你可能大概瞭解了

00:22:58.812 --> 00:23:03.450 
連接和讀取輸入的機制

00:23:03.517 --> 00:23:05.519 
從Siri遙控器和遊戲控制器中

00:23:06.253 --> 00:23:07.454 
且你很可能會開始思考

00:23:07.521 --> 00:23:10.023 
你的遊戲要支持哪種控制類型

00:23:10.757 --> 00:23:12.526 
要不要只支持Siri遙控器

00:23:13.827 --> 00:23:17.364 
還是Siri遙控器
和MFi遊戲控制器都支持？

00:23:19.533 --> 00:23:21.101 
如你們在本週一所瞭解到的信息

00:23:21.768 --> 00:23:26.373 
Siri遙控器不支持的
高級遊戲機制的遊戲

00:23:26.874 --> 00:23:29.543 
可以要求使用遊戲控制器

00:23:39.052 --> 00:23:42.990 
那麼指定遊戲支持哪種控制器類型

00:23:43.056 --> 00:23:44.224 
是在Xcode中實現

00:23:45.826 --> 00:23:48.962 
在你的目標設定中有個功能選項卡

00:23:49.196 --> 00:23:51.498 
能在這個選項卡中發現遊戲控制器功能

00:23:51.832 --> 00:23:53.333 
啓用這個功能

00:23:53.901 --> 00:23:56.904 
並選擇遊戲所支持的控制器類型

00:23:58.038 --> 00:24:01.642 
與這個GUI的交互將改變鍵和值

00:24:01.708 --> 00:24:04.344 
相應info.plist文件中的

00:24:06.213 --> 00:24:08.749 
這對於應用介紹頁面來說很重要
因爲 所有遊戲

00:24:08.815 --> 00:24:11.919 
鏈接了遊戲控制器框架的 都會

00:24:13.153 --> 00:24:15.923 
更精確地說
都會在應用介紹頁面中找到這些鍵

00:24:15.989 --> 00:24:18.192 
鏈接了遊戲控制器框架的所有遊戲的

00:24:19.259 --> 00:24:22.129 
真正涉及到的是App Store

00:24:22.196 --> 00:24:25.899 
因爲你的用戶們將在
App Store中獲知

00:24:25.966 --> 00:24:28.836 
遊戲是否支持遊戲控制器

00:24:28.902 --> 00:24:30.604 
或需要遊戲控制器

00:24:31.638 --> 00:24:35.375 
此外 用戶可能會收到警告
如果他們嘗試

00:24:35.442 --> 00:24:38.145 
下載一款需要遊戲控制器的遊戲

00:24:39.813 --> 00:24:43.250 
並且之前沒有在那臺Apple TV
上配對過遊戲控制器的話

00:24:44.484 --> 00:24:46.753 
請注意 這只是一種保障措施

00:24:47.287 --> 00:24:49.857 
因爲很可能 的遊戲

00:24:49.923 --> 00:24:52.926 
需要遊戲控制器 可能仍會啓動

00:24:53.427 --> 00:24:55.596 
就算沒有檢測到已連接的遊戲控制器

00:24:57.331 --> 00:24:59.933 
這種情況是你需要說明和處理的

00:25:01.034 --> 00:25:03.370 
很可能用戶只不過是忘記

00:25:03.437 --> 00:25:04.938 
打開遊戲控制器

00:25:05.572 --> 00:25:08.876 
那麼在這種情況下 就要通知玩家

00:25:09.243 --> 00:25:12.846 
沒有檢測到任何遊戲控制器
並要求他們連接一個遊戲控制器

00:25:14.915 --> 00:25:18.952 
否則 用戶可能會覺得奇怪
爲什麼不能控制遊戲

00:25:20.721 --> 00:25:22.656 
還有一個問題你要考慮

00:25:22.723 --> 00:25:24.858 
就是以這種方式通知用戶

00:25:24.925 --> 00:25:26.827 
只適用於控制器斷開連接的情況

00:25:27.060 --> 00:25:29.329 
這是因爲控制器

00:25:30.130 --> 00:25:33.033 
或者更精確地說是可用的控制器
可能會通過你的初步檢測

00:25:33.100 --> 00:25:36.170 
但是在應用運行過程時

00:25:36.236 --> 00:25:38.305 
其中一個遊戲控制器可能會斷開連接

00:25:38.505 --> 00:25:41.108 
如果這是唯一可用的遊戲控制器

00:25:41.608 --> 00:25:44.778 
那麼此時 遊戲就不能再繼續了
因爲至少需要一個遊戲控制器

00:25:44.845 --> 00:25:47.247 
此時 也需要告知用戶

00:25:52.986 --> 00:25:56.356 
要了解更多信息 請查看tvOS設計

00:25:56.590 --> 00:26:00.093 
會話802
獲得更多遊戲控制器的信息

00:26:06.967 --> 00:26:09.903 
現在讓我們談點兒新東西
Apple TV遙控器應用

00:26:10.737 --> 00:26:13.073 
正如你在本週一所瞭解到的信息
這是個新應用

00:26:13.540 --> 00:26:16.777 
可以從developer.apple.com上
下載beta版

00:26:17.778 --> 00:26:20.581 
這個應用可控制你的Apple TV

00:26:20.647 --> 00:26:23.650 
在屏幕中央有一大片觸摸表面

00:26:24.017 --> 00:26:27.855 
而屏幕上的按鈕
跟Siri遙控器上的按鈕相同

00:26:29.523 --> 00:26:33.327 
重點是 它可以充當遊戲輸入設備

00:26:35.896 --> 00:26:38.999 
在tvOS上的實現方式是

00:26:39.600 --> 00:26:42.903 
以一種非常熟悉的方式
通過遊戲控制器框架充當遊戲觸摸表面

00:26:43.337 --> 00:26:45.706 
實際上是一個仿真的Siri遙控器

00:26:46.340 --> 00:26:48.909 
因此它顯示爲一個
GCController實例

00:26:50.043 --> 00:26:52.246 
並支持GCMicroGamepad

00:26:52.312 --> 00:26:55.082 
GCMotion profiles
就跟Siri遙控器一樣

00:26:55.983 --> 00:26:57.951 
事實上 它是不可辨別的

00:26:58.018 --> 00:27:00.687 
在Siri遙控器的遊戲控制器框架中

00:27:02.155 --> 00:27:05.659 
因此你爲Siri遙控器寫的代碼
也可以用在tvOS上

00:27:07.628 --> 00:27:12.266 
這些遙控器默認爲合併

00:27:12.733 --> 00:27:16.069 
因此 如果你有一個Siri遙控器
和一個TV遙控器應用

00:27:16.136 --> 00:27:20.607 
默認會在控制器數組中
作爲一個遊戲控制器出現

00:27:21.575 --> 00:27:25.012 
意思就是 任何一個的按鈕輸入
都會體現在遊戲中

00:27:25.078 --> 00:27:26.647 
就像來自同一個控制器一樣

00:27:27.414 --> 00:27:29.349 
DPAD輸入也一樣

00:27:30.417 --> 00:27:33.921 
但是對於動作
我們並不希望讓動作輸入形成

00:27:33.987 --> 00:27:36.557 
覆蓋並跟另一個動作輸入衝突

00:27:36.623 --> 00:27:39.193 
所以我們從一個控制器中
取出動作 或 抱歉

00:27:39.259 --> 00:27:40.861 
一次只從一個遙控器中取出一個動作

00:27:43.030 --> 00:27:44.898 
我們所取動作的遙控器是

00:27:44.965 --> 00:27:48.101 
最後接收用戶輸入的遙控器無論是滑動

00:27:48.168 --> 00:27:50.771 
在觸摸表面
還是按下A或X按鈕

00:27:52.072 --> 00:27:55.676 
如果你想選擇性地分開這些遙控器

00:27:55.742 --> 00:27:58.045 
並 把它們顯示爲不同的實例

00:27:58.111 --> 00:27:59.446 
在控制器數組中

00:28:00.247 --> 00:28:01.148 
你需要

00:28:02.049 --> 00:28:03.851 
進入info.plist文件

00:28:03.917 --> 00:28:07.955 
添加布爾鍵
GCSupportsMultipleMicroGamepads

00:28:08.355 --> 00:28:14.094 
並把它設爲是 現在Siri控制器和
Apple TV控制器應用將顯示爲

00:28:14.161 --> 00:28:17.931 
在數組中 不同的控制器實例

00:28:22.002 --> 00:28:26.940 
現在我想談一下Apple TV
遙控器應用內部的一個特殊模式

00:28:27.007 --> 00:28:28.442 
叫遊戲控制器模式

00:28:28.509 --> 00:28:32.045 
在此模式下 用戶可以隨意切換出入

00:28:32.112 --> 00:28:34.882 
在連接了遊戲控制器框架的遊戲中

00:28:37.084 --> 00:28:41.788 
這個應用是橫向的 同樣地

00:28:41.855 --> 00:28:46.593 
DPAD值被旋轉了90度
甚至在它們進入應用之前就旋轉了

00:28:47.194 --> 00:28:51.665 
那麼你的應用並不需要做任何
設置或修改來使用這種模式

00:28:53.066 --> 00:28:56.470 
但是請注意
若遊戲是手動把DPAD值旋轉90度

00:28:56.537 --> 00:29:00.474 
那麼你實際上是做了兩次旋轉

00:29:01.241 --> 00:29:04.611 
所以我們的建議是

00:29:04.678 --> 00:29:07.414 
如果允許玩家 橫向地玩兒遊戲

00:29:07.481 --> 00:29:10.083 
用Siri遙控器和遊戲控制器模式

00:29:10.150 --> 00:29:11.852 
就在Apple TV遙控器應用上

00:29:12.653 --> 00:29:16.590 
allowsRotation設爲真
就像我們剛纔談到的那樣

00:29:17.491 --> 00:29:20.794 
然後讓我們爲你處理方位
和DPAD的變更

00:29:22.663 --> 00:29:23.964 
還有一點要注意

00:29:24.198 --> 00:29:26.967 
Apple TV遙控器應用的
遊戲控制器模式

00:29:27.034 --> 00:29:29.870 
會把觸摸表面和A按鈕分離開

00:29:31.605 --> 00:29:33.707 
這點跟Siri遙控器不一樣

00:29:33.774 --> 00:29:37.144 
Siri遙控器是
點擊觸摸表面激活A按鈕

00:29:37.845 --> 00:29:40.247 
但這並不會造成任何麻煩

00:29:40.981 --> 00:29:44.151 
用戶仍然可以在兩者上同步輸入

00:29:44.218 --> 00:29:47.654 
並且你的遊戲代碼仍然會
檢測在兩者上的同步輸入

00:29:48.522 --> 00:29:51.825 
但關鍵點是
如果你的遊戲代碼假設

00:29:51.892 --> 00:29:55.729 
按下A按鈕會同時激活觸摸表面

00:29:55.796 --> 00:29:58.832 
那麼這跟
遊戲控制器模式上的實現方式不一樣

00:29:58.899 --> 00:30:00.300 
Apple TV遙控器應用的

00:30:10.277 --> 00:30:13.080 
最後 我想談一下多控制器

00:30:14.081 --> 00:30:17.751 
總是有人會問Apple TV
能支持多少個控制器

00:30:18.652 --> 00:30:23.423 
答案是在新版tvOS 10中
能支持一個Siri遙控器

00:30:23.490 --> 00:30:28.195 
和四個MFi遊戲控制器
以及Apple TV遙控器應用

00:30:29.596 --> 00:30:32.866 
一般來說 會在多玩家遊戲的
情境中提出這個問題

00:30:33.400 --> 00:30:38.572 
在tvOS 10中增加爲
四個MFi遊戲控制器

00:30:38.639 --> 00:30:40.807 
這對於多玩家遊戲來說無疑是個好消息

00:30:42.042 --> 00:30:44.611 
最初可能並不明顯

00:30:44.678 --> 00:30:47.714 
但這對於單一玩家遊戲來說也很重要

00:30:48.282 --> 00:30:49.216 
讓我解釋一下

00:30:49.983 --> 00:30:51.451 
當應用啓動時

00:30:52.319 --> 00:30:55.889 
你不確定你是否只發現
一個已連接的Siri遙控器

00:30:57.224 --> 00:31:00.427 
或也許你會發現一個
已連接的遊戲控制器

00:31:01.662 --> 00:31:03.230 
或者各發現了一個

00:31:04.565 --> 00:31:06.500 
或者也許你會發現一個Siri遙控器

00:31:06.567 --> 00:31:08.969 
多個遊戲控制器和TV遙控器應用

00:31:09.169 --> 00:31:10.204 
瞭解這種情況吧？

00:31:10.270 --> 00:31:12.806 
那麼此時關鍵點在Apple TV上

00:31:12.873 --> 00:31:16.777 
從多個控制器上接收輸入很常見

00:31:16.844 --> 00:31:18.378 
即使是一個單一玩家的遊戲

00:31:18.812 --> 00:31:21.448 
重要的是 你提前不知道

00:31:21.515 --> 00:31:24.084 
用戶打算使用哪個控制器

00:31:24.818 --> 00:31:28.922 
你不能假設控制器的數組下標爲零的

00:31:28.989 --> 00:31:30.691 
即爲玩家想要使用的
那個控制器

00:31:31.158 --> 00:31:32.426 
那麼 我們該如何處理？

00:31:33.393 --> 00:31:35.195 
嗯 關鍵是

00:31:35.262 --> 00:31:38.398 
玩家可以隨時切換控制器

00:31:38.799 --> 00:31:40.367 
也許他們啓動了應用

00:31:41.068 --> 00:31:43.170 
瀏覽了遊戲菜單

00:31:43.237 --> 00:31:45.839 
然後啓動了角色
這過程一直都用Siri遙控器控制

00:31:46.173 --> 00:31:48.108 
然後 他們切換到MFi遊戲控制器

00:31:48.175 --> 00:31:50.444 
來實際開始控制角色

00:31:53.280 --> 00:31:58.852 
允許玩家 自由和靈活地切換

00:31:58.919 --> 00:32:02.389 
在不同的控制器之間而無需提示用戶

00:32:02.456 --> 00:32:05.192 
用不必要的確認對話

00:32:05.259 --> 00:32:07.794 
或無需要求用戶退出遊戲設置

00:32:07.861 --> 00:32:10.497 
再使用一個不同的控制器
重新進入遊戲設置的遊戲

00:32:11.031 --> 00:32:14.234 
將會打造一種真正了不起的無縫體驗

00:32:15.302 --> 00:32:16.470 
我們該如何實現呢？

00:32:17.604 --> 00:32:20.474 
嗯 一種方式是把

00:32:20.541 --> 00:32:23.877 
輸入所有控制器的
都作爲單一玩家遊戲的有效輸入

00:32:24.778 --> 00:32:27.514 
所以 如果你有個角色
在DPAD屏幕上移動

00:32:27.581 --> 00:32:30.584 
並且允許接入所有已連接的控制器

00:32:30.651 --> 00:32:33.086 
那麼 將允許它們的DPAD
控制角色移動

00:32:34.087 --> 00:32:38.458 
按鈕也一樣 如果角色 跳躍

00:32:38.825 --> 00:32:41.495 
通過按A按鈕
那麼就要允許 所有A按鈕

00:32:41.562 --> 00:32:44.531 
所有已連接的控制器上的控制角色

00:32:45.632 --> 00:32:50.871 
如果某個控制器在遊戲過程中接入

00:32:50.938 --> 00:32:53.373 
那麼你也可開始悄悄地追蹤那個控制器

00:32:53.440 --> 00:32:55.642 
並允許它的輸入控制角色

00:32:57.277 --> 00:32:58.645 
現在 運行起來很順暢了

00:32:58.712 --> 00:33:02.649 
我們要給玩家一個認知

00:33:02.716 --> 00:33:05.419 
即他們可以在多個控制器之間來回切換

00:33:05.485 --> 00:33:08.455 
這實際上是一個手動合併策略

00:33:08.522 --> 00:33:10.190 
我們從Siri遙控器 獲取輸入

00:33:10.257 --> 00:33:13.760 
和遊戲控制器上
並全部提供給我們的單一玩家體驗

00:33:15.896 --> 00:33:19.433 
但是 我在這裏還要說一個極端情況
就是動作

00:33:19.700 --> 00:33:21.235 
我舉例解釋一下

00:33:22.636 --> 00:33:24.938 
如果你的遊戲使用了動作

00:33:25.005 --> 00:33:29.543 
比如用Siri遙控器
控制飛機在空中飛行的姿勢

00:33:30.277 --> 00:33:34.581 
你還可以把那個控制轉移給搖桿
用搖桿控制飛機

00:33:34.648 --> 00:33:36.850 
若玩家正在用遊戲控制器玩兒遊戲的話

00:33:36.917 --> 00:33:38.986 
這完全沒問題 很好用

00:33:40.454 --> 00:33:43.790 
關鍵顧慮是 當你正在手動合併
Siri遙控器和遊戲控制器時

00:33:43.857 --> 00:33:47.227 
你不想讓控制飛機的遊戲杆

00:33:47.294 --> 00:33:51.331 
被任何可能
來自Siri遙控器的動作數據覆蓋

00:33:51.398 --> 00:33:53.133 
當你正在手動合併Siri遙控器
和遊戲控制器時

00:33:53.567 --> 00:33:57.704 
那麼在這種情況下
遊戲中控制飛機姿勢的代碼

00:33:57.771 --> 00:34:00.607 
應該檢測該信息是取自

00:34:00.674 --> 00:34:02.776 
動作還是取自搖桿

00:34:03.443 --> 00:34:05.212 
然後再返回來看我們的例子

00:34:05.279 --> 00:34:07.948 
當我用Siri遙控器控制飛機時

00:34:08.014 --> 00:34:09.815 
如果我換成遊戲控制器

00:34:10.217 --> 00:34:13.152 
那麼那個遊戲控制器上的任何用戶輸入

00:34:13.219 --> 00:34:17.056 
無論DPAD還是搖桿或觸發器或按鈕

00:34:17.123 --> 00:34:20.594 
都將開始忽略來自Siri遙控器動作

00:34:20.893 --> 00:34:22.663 
並使用正確的搖桿來控制

00:34:22.728 --> 00:34:25.933 
飛機姿勢 反過來也一樣

00:34:25.998 --> 00:34:29.469 
如果我換成Siri遙控器
用戶輸入

00:34:29.536 --> 00:34:33.373 
也就是滑動觸摸表面
或按下A或X按鈕

00:34:33.841 --> 00:34:37.811 
將在那一刻起
聽從來自Siri遙控器的動作

00:34:37.878 --> 00:34:38.911 
並切換到Siri遙控器

00:34:39.913 --> 00:34:44.117 
通過這個 我們制定了控制方案
對玩家來說非常靈活

00:34:44.184 --> 00:34:46.753 
可以實現儘可能無縫地切換

00:34:48.155 --> 00:34:52.592 
在研討會結束之前 我想說

00:34:52.659 --> 00:34:55.395 
我在這裏向你們演示的技術

00:34:55.462 --> 00:34:57.264 
可以直接用在你的遊戲中

00:34:58.165 --> 00:35:01.602 
或者也許它們是個良好的開端
你可以進行調整

00:35:01.668 --> 00:35:04.738 
和自定義
使它們完美地適合你的遊戲環境

00:35:05.572 --> 00:35:08.141 
但無論如何 我真的鼓勵你們

00:35:08.208 --> 00:35:12.112 
超越控制器的連接 機制

00:35:12.179 --> 00:35:15.115 
和斷開 以及讀取按鈕值

00:35:15.883 --> 00:35:18.585 
真正思考你要如何

00:35:18.652 --> 00:35:20.787 
把遊戲控制器整合到你的遊戲中去

00:35:21.355 --> 00:35:22.856 
因爲 如果處理得當

00:35:22.923 --> 00:35:26.293 
站在玩家的立場上
用戶就會對遊戲控制器視而不見

00:35:26.660 --> 00:35:29.696 
並真正忘情地投入到遊戲中來

00:35:29.763 --> 00:35:33.500 
享受你所努力營造的遊戲體驗

00:35:34.134 --> 00:35:35.702 
這纔是遊戲的真諦

00:35:38.572 --> 00:35:40.240 
好了 我們今天說了很多

00:35:40.407 --> 00:35:41.775 
總結一下

00:35:41.842 --> 00:35:46.513 
我們談到了Siri遙控器如何
支持GCMicroGamepad profile

00:35:46.580 --> 00:35:48.248 
GCMotion profile中

00:35:48.815 --> 00:35:51.685 
我談到了DPAD開窗
和allowsRotation

00:35:52.886 --> 00:35:54.454 
我還談到了菜單按鈕

00:35:54.521 --> 00:35:57.958 
以及在Apple TV上
所預期的行爲如何進行改變

00:35:58.025 --> 00:35:59.760 
根據你的應用的情境

00:36:00.494 --> 00:36:02.930 
以及如何使用
GCEventViewController

00:36:03.030 --> 00:36:06.200 
和控制或暫停處理器來控制行爲

00:36:07.634 --> 00:36:10.204 
我還談到了MFi遊戲控制器

00:36:10.804 --> 00:36:13.907 
這些控制器使用
GCExtendedGamepad profile

00:36:13.974 --> 00:36:16.043 
並引入壓敏性

00:36:16.844 --> 00:36:20.781 
並且現在可以在遊戲中
要求作爲控制器使用了

00:36:22.950 --> 00:36:24.885 
我還談到了TV遙控器應用

00:36:25.586 --> 00:36:27.354 
它其實是個仿真的Siri遙控器

00:36:27.421 --> 00:36:29.556 
從遊戲控制器框架角度來說

00:36:29.923 --> 00:36:33.093 
而且我還談到了Apple TV
遙控器應用的遊戲控制器模式

00:36:33.527 --> 00:36:35.028 
和設計注意事項

00:36:35.095 --> 00:36:40.033 
以便你的遊戲如你所期待的那樣
能使用Apple TV遙控器應用

00:36:41.001 --> 00:36:44.338 
最後 結束時 我談了多控制器

00:36:44.638 --> 00:36:46.840 
及其對多玩家遊戲的重要性

00:36:46.907 --> 00:36:50.611 
但同樣重要的是
也要考慮到單一玩家遊戲

00:36:50.878 --> 00:36:54.014 
也就是說 允許玩家在遊戲中
儘可能無縫地切換控制器

00:36:54.081 --> 00:36:56.083 
在遊戲中儘可能無縫地

00:36:58.819 --> 00:37:01.622 
這是本場研討會的URL

00:37:01.722 --> 00:37:05.092 
你們可以從這兒觀看視頻、
查看文檔和示例代碼

00:37:05.392 --> 00:37:07.127 
這場是607會話

00:37:08.562 --> 00:37:12.099 
其他相關的會話還有
“掌握tvOS上的UIKit

00:37:12.165 --> 00:37:14.067 
和tvOS設計”

00:37:14.301 --> 00:37:17.371 
還有tvOS實驗室
可以解答你的一般疑問

00:37:18.572 --> 00:37:21.909 
非常感謝你們的關注 祝你們在
接下來的演講中度過一段美好的時光