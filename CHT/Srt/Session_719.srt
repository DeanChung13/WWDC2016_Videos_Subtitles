00:00:19.386 --> 00:00:21.788
性能和電池壽命的I/O優化

00:00:24.758 --> 00:00:25.692
大家好 歡迎

00:00:27.561 --> 00:00:31.365
我叫Kushal Dalmia
我的同事Terry Long

00:00:31.431 --> 00:00:33.800
我將爲大家講解I/O優化

00:00:33.901 --> 00:00:35.469
爲性能和電池壽命

00:00:36.470 --> 00:00:39.139
在本次演講中 我們將講解
什麼是I/O

00:00:39.806 --> 00:00:41.208
它會如何影響你的應用

00:00:41.708 --> 00:00:43.877
以及如何提高應用的性能

00:00:44.144 --> 00:00:45.913
通過提高其I/O性能

00:00:46.980 --> 00:00:47.848
我們現在開始

00:00:49.716 --> 00:00:53.120
衆所周知 每年設備越變越大
越變越好

00:00:54.321 --> 00:00:58.759
屏幕分辨率增加 在過去十年
增加了16倍

00:01:00.160 --> 00:01:02.362
在相機領域也有類似提高

00:01:02.429 --> 00:01:04.864
已經可以拍攝4K HD視頻

00:01:05.065 --> 00:01:08.135
還可以從我們的移動設備裏
拍出令人驚豔的的高畫質相片

00:01:10.137 --> 00:01:14.041
所有這些改進造就
更爲豐富的媒體每天被生產

00:01:14.174 --> 00:01:15.242
和消費

00:01:17.778 --> 00:01:19.146
爲了關注它們的前景

00:01:19.213 --> 00:01:22.382
我們來看看iPhone
壁紙大小的趨勢

00:01:24.251 --> 00:01:27.888
如果跨越設備和時代
來看iPhone壁紙

00:01:28.188 --> 00:01:30.390
可以發現其呈指數增長

00:01:31.458 --> 00:01:34.228
iPhone 6s Plus上的
壁紙大小

00:01:34.428 --> 00:01:37.965
是對應的iPhone 3G的14倍

00:01:38.665 --> 00:01:41.368
所有手機數據都有相似的趨勢

00:01:41.735 --> 00:01:43.770
我們編寫和使用複雜的應用

00:01:43.837 --> 00:01:46.440
在遊戲 信息和社交網絡領域

00:01:47.474 --> 00:01:50.811
我們工作和存儲豐富的文件 如PDF

00:01:52.379 --> 00:01:56.049
我們分享和捕捉
高品質音頻和視頻文件

00:01:59.486 --> 00:02:01.388
現在爲了管理這種數據爆炸

00:02:01.488 --> 00:02:04.725
應用需要在系統資源利用方面
做到非常高效

00:02:05.626 --> 00:02:11.732
主要系統資源有CPU 內存和I/O

00:02:13.967 --> 00:02:17.204
關於CPU和內存 我推薦大家觀看
去年的WWDC演講

00:02:17.271 --> 00:02:19.173
“iOS和watchOS上的性能”

00:02:20.107 --> 00:02:22.009
今天我們將來講解I/O

00:02:24.077 --> 00:02:29.283
I/O 即輸入輸出
是和本地文件存儲進行互動的操作

00:02:29.349 --> 00:02:30.784
或和基於網絡的服務器

00:02:32.553 --> 00:02:35.222
和文件系統互動的操作

00:02:35.289 --> 00:02:38.492
以及處理文件讀寫的操作
都被認爲是一個I/O

00:02:40.727 --> 00:02:44.331
和網絡服務器交流是
基於網絡I/O的很好的範例

00:02:46.834 --> 00:02:49.203
I/O如此有趣的其中一個原因是

00:02:49.269 --> 00:02:52.105
在I/O技術上發生了巨大的變化

00:02:52.406 --> 00:02:54.141
性能特徵上也是如此

00:02:55.809 --> 00:02:58.378
考慮一兆字節的延遲

00:02:58.445 --> 00:03:00.380
當寫入最平常的I/O媒介時

00:03:00.914 --> 00:03:05.986
如SSD 硬盤和普通Wi-Fi網絡

00:03:07.487 --> 00:03:09.656
你可能會注意到 同樣的操作

00:03:09.723 --> 00:03:13.126
大概耗時幾毫秒到幾百毫秒之間

00:03:13.193 --> 00:03:15.429
根據互動的媒介不同

00:03:17.998 --> 00:03:19.566
I/O之所以如此重要的原因

00:03:19.900 --> 00:03:24.204
是應用上I/O性能直接影響用戶體驗

00:03:26.073 --> 00:03:28.976
應用性能的延遲時間的改變

00:03:29.042 --> 00:03:31.011
可以表現爲響應問題

00:03:32.913 --> 00:03:35.182
由於I/O是系統中的共享資源

00:03:35.315 --> 00:03:38.552
你的應用的I/O性能
可能會影響整體系統性能

00:03:40.020 --> 00:03:41.622
我們一會兒將會看到

00:03:41.989 --> 00:03:44.791
I/O也會顯著影響設備上的電池壽命

00:03:47.194 --> 00:03:50.430
爲了幫你們瞭解應用上I/O使用情況

00:03:50.731 --> 00:03:52.833
我們提出了自己的I/O哲學

00:03:54.001 --> 00:03:56.503
該I/O哲學有四個主要支柱

00:03:59.006 --> 00:04:01.141
減少應用裏的I/O用量

00:04:02.876 --> 00:04:05.112
用正確的線程完成這些I/O

00:04:07.181 --> 00:04:10.751
採用合適和高效API完成這些I/O

00:04:11.118 --> 00:04:14.688
最後 對應用中I/O性能測試和測量

00:04:16.223 --> 00:04:17.591
當我們通讀剩下的文檔時

00:04:17.658 --> 00:04:19.860
我們會瞭解其中每一項的更多細節

00:04:23.363 --> 00:04:26.133
提高應用中I/O效率的最好方法

00:04:26.200 --> 00:04:28.268
是減少I/O用量

00:04:30.103 --> 00:04:33.407
每一個I/O操作都和
多個硬件功能相互作用

00:04:33.473 --> 00:04:34.408
在設備上

00:04:35.876 --> 00:04:38.812
這是一個現代設備的簡單框圖

00:04:38.879 --> 00:04:41.915
包含部分功能及它們對電池壽命的影響

00:04:43.784 --> 00:04:47.554
當應用使用I/O時
會在CPU上運行代碼

00:04:48.922 --> 00:04:50.257
訪問內存

00:04:51.091 --> 00:04:53.660
最後從硬盤上讀取或寫入數據

00:04:55.429 --> 00:04:56.830
如果還涉及到網絡

00:04:57.164 --> 00:04:59.700
基於網絡收音機也參與到互動中

00:05:01.502 --> 00:05:04.104
所有這些組件聯合起來的能量消耗

00:05:04.304 --> 00:05:07.341
讓I/O在電池使用方面操作非常沉重

00:05:09.109 --> 00:05:12.412
由於I/O對設備電池壽命的負面影響

00:05:12.746 --> 00:05:15.516
我們來看看可以使用的最好的實踐技巧

00:05:15.716 --> 00:05:17.818
來減少應用上的I/O用量

00:05:19.920 --> 00:05:21.388
首先是緩存

00:05:22.923 --> 00:05:26.426
基本理念是 建立數據的內存副本

00:05:26.627 --> 00:05:29.229
而不是每次操作都訪問磁盤

00:05:31.431 --> 00:05:34.868
爲了決定應用裏的數據是否應該
在內存中建立緩存

00:05:35.202 --> 00:05:37.504
你應該查看數據的訪問模式

00:05:39.239 --> 00:05:41.942
被頻繁寫入或更新的數據

00:05:42.009 --> 00:05:44.545
也許是在應用中建立緩存的好對象

00:05:46.880 --> 00:05:50.951
還有 當從磁盤中讀取
需要昂貴處理步驟的數據

00:05:51.285 --> 00:05:53.153
比如 解壓縮一個圖片文件

00:05:53.220 --> 00:05:55.756
可能是應該緩存的一個好例子

00:05:58.158 --> 00:06:02.062
即便如此 應該注意內存和I/O平衡

00:06:03.363 --> 00:06:07.067
和I/O一樣 內存也是系統中
共享和有限的資源

00:06:07.134 --> 00:06:09.236
應該格外小心用戶需求

00:06:10.304 --> 00:06:12.873
如果決定在應用裏建立緩存

00:06:13.473 --> 00:06:15.843
我們推薦使用NSCache API

00:06:16.543 --> 00:06:19.713
因爲它們可以很好地處理內存壓力條件

00:06:24.451 --> 00:06:27.087
下一個實踐技巧是合併I/O

00:06:28.589 --> 00:06:29.823
基本理念是

00:06:29.890 --> 00:06:33.627
把系統裏的I/O推遲到之後
更爲合適的時間

00:06:35.128 --> 00:06:37.164
由於I/O技術的工作方式

00:06:37.397 --> 00:06:40.534
更大更少的I/O
對系統來說總是更爲有效

00:06:42.269 --> 00:06:43.403
其中一種實現方法是

00:06:43.470 --> 00:06:46.373
是採用應用狀態改變通知

00:06:46.540 --> 00:06:49.910
比如 後臺應用數據來安排I/O

00:06:51.778 --> 00:06:55.449
在macOS 你可以使用
集中任務計劃 API

00:06:55.516 --> 00:06:57.618
來安排維護和備份任務

00:06:57.851 --> 00:07:00.988
系統會找出運行這些任務的最佳時間

00:07:03.590 --> 00:07:05.125
想了解更多這些API的信息

00:07:05.192 --> 00:07:08.095
我們推薦觀看2014年WWDC演講

00:07:08.428 --> 00:07:10.297
“編寫節能高效的代碼”

00:07:12.132 --> 00:07:14.434
我們已經看過一些最佳時間技巧

00:07:14.501 --> 00:07:16.703
來減少應用中的I/O用量

00:07:17.304 --> 00:07:21.108
我想爲大家介紹我們的示例應用
是Terry和我編寫的

00:07:21.575 --> 00:07:23.944
在剩下的演講中
我們會一直使用這個應用

00:07:24.011 --> 00:07:27.414
來演示最佳實踐技巧的實際影響

00:07:28.649 --> 00:07:30.551
這個應用叫ImageBox

00:07:31.485 --> 00:07:35.189
ImageBox是iOS和
macOS上很棒的應用

00:07:35.722 --> 00:07:37.591
讓你可以添加和瀏覽圖片

00:07:39.960 --> 00:07:42.396
對於每一個圖片 它將顯示其縮略圖

00:07:43.363 --> 00:07:46.099
顯示相關標識 比如喜歡

00:07:47.134 --> 00:07:49.970
或者某張特定圖片是否有相關注釋

00:07:51.905 --> 00:07:54.942
當你點擊某特定圖片 將進入詳細視圖

00:07:55.542 --> 00:07:59.079
可以讓你把圖片標記爲喜歡 取消喜歡

00:07:59.646 --> 00:08:00.881
或者爲它添加註釋

00:08:03.116 --> 00:08:04.852
我們編寫了這個應用

00:08:04.918 --> 00:08:07.221
我們想要知道它是否I/O高效

00:08:07.287 --> 00:08:09.189
並且在I/O性能方面也表現良好

00:08:10.123 --> 00:08:12.159
我將來介紹可以使用的工具

00:08:12.226 --> 00:08:14.027
來決定是否在你自己的應用上使用

00:08:15.495 --> 00:08:17.531
該工具叫做Xcode調試儀表

00:08:18.565 --> 00:08:19.900
來看看它如何使用

00:08:21.101 --> 00:08:24.805
爲了使用該工具
只需從Xcode UI中運行項目

00:08:26.240 --> 00:08:29.610
這會在設備或模擬器上
啓動項目或應用

00:08:30.077 --> 00:08:32.145
點擊Xcode調試導航器

00:08:33.947 --> 00:08:37.284
它顯示了應用裏的實時數據

00:08:37.351 --> 00:08:40.419
關於應用正在使用的所有系統資源

00:08:41.154 --> 00:08:45.893
有CPU 內存 能量 網絡和磁盤

00:08:47.628 --> 00:08:51.398
由於我們對應用中I/O活動或
I/O性能感興趣

00:08:51.665 --> 00:08:53.100
我們選中磁盤

00:08:54.735 --> 00:08:57.371
一旦選中 可以注意到會顯示實時數據

00:08:57.437 --> 00:09:00.040
應用中發生的讀取和寫入數據

00:09:00.641 --> 00:09:04.511
看上去該應用每幾秒都進行大量讀寫入

00:09:04.578 --> 00:09:06.680
即使沒有用戶活動時

00:09:06.847 --> 00:09:10.918
爲了進一步調查
我們想進入Instrument

00:09:11.018 --> 00:09:13.287
用Instrument來找出原因

00:09:13.687 --> 00:09:16.156
繼續在Instrument裏
點擊配置

00:09:16.623 --> 00:09:17.858
點擊重啓按鈕

00:09:19.793 --> 00:09:22.763
如此操作時
Instruments提供了組模板

00:09:22.829 --> 00:09:25.999
你可以從中選擇分析應用

00:09:27.167 --> 00:09:29.937
因爲我們對應用裏I/O活動感興趣

00:09:30.070 --> 00:09:34.474
繼續選擇系統使用情況 然後點擊選擇

00:09:36.810 --> 00:09:39.313
將打開新的Instrument模板

00:09:39.479 --> 00:09:42.282
準備記錄應用中的I/O活動

00:09:43.016 --> 00:09:44.718
繼續開始記錄

00:09:48.388 --> 00:09:50.424
注意到在詳細顯示區

00:09:50.624 --> 00:09:54.127
該模板顯示了應用裏所有的系統調用

00:09:54.194 --> 00:09:56.230
爲你進行I/O操作

00:09:57.030 --> 00:10:00.934
還顯示了其他有用信息 比如
實際和請求的字節數

00:10:01.001 --> 00:10:04.705
對於那些讀寫操作以及相關的文件路徑

00:10:05.706 --> 00:10:07.574
現在我將停止記錄

00:10:09.343 --> 00:10:11.912
爲了找到剛纔看到的大量寫入

00:10:11.979 --> 00:10:13.413
在Xcode調試儀表

00:10:13.480 --> 00:10:16.884
我們按照實際讀寫的字節數進行排序

00:10:17.084 --> 00:10:20.020
找出大量寫入 在最上方

00:10:21.955 --> 00:10:25.359
有了這個之後 可以進入擴展詳細視圖

00:10:25.659 --> 00:10:27.261
查看確切的回溯

00:10:27.327 --> 00:10:29.930
關於應用中執行這些I/O的代碼部分

00:10:30.964 --> 00:10:33.400
看上去是應用的委託方法

00:10:35.202 --> 00:10:38.372
雙擊進入源代碼檢查器r

00:10:38.438 --> 00:10:41.408
將顯示執行I/O操作的準確代碼塊

00:10:42.709 --> 00:10:45.078
在源代碼檢查器中點擊Xcode圖標

00:10:45.345 --> 00:10:47.114
將會回到Xcode項目

00:10:47.481 --> 00:10:50.117
併爲你高亮顯示執行該I/O操作代碼

00:10:51.985 --> 00:10:54.588
來看看這段代碼更詳細的情況

00:10:55.789 --> 00:10:59.059
問題出在應用中的實現部分

00:10:59.126 --> 00:11:01.495
委託方法didFinishLaunchingApp

00:11:02.796 --> 00:11:04.131
作爲實現的一部分

00:11:04.198 --> 00:11:06.466
我們新建了一個計時器
DispatchSource

00:11:07.301 --> 00:11:09.603
讓它每5秒記錄一次

00:11:11.271 --> 00:11:13.507
且對於該計時器作爲事件處理的一部分

00:11:13.740 --> 00:11:15.475
我們寫出整個數據存儲

00:11:16.910 --> 00:11:19.646
我們中很多人這樣寫代碼 因爲我們想確保

00:11:19.713 --> 00:11:23.417
應用數據可以持續定期地保存

00:11:24.551 --> 00:11:27.621
然而 還有更爲I/O高效的方法實現

00:11:28.789 --> 00:11:29.990
爲了修改代碼

00:11:30.057 --> 00:11:33.727
首先我們刪除計時器的重複部分

00:11:35.362 --> 00:11:36.430
把這部分刪除

00:11:37.564 --> 00:11:41.034
取而代之 新建一個方法叫
dataStoreDidChange

00:11:41.335 --> 00:11:43.804
在應用中不同的地方被調用

00:11:43.871 --> 00:11:45.772
只要數據存儲發生任何變化

00:11:47.541 --> 00:11:49.076
作爲該實現的一部分

00:11:49.643 --> 00:11:53.247
我們把計時器的調度源往後推15秒

00:11:54.615 --> 00:11:59.086
用這種方法
我們收集應用數據存儲的所有更新

00:11:59.453 --> 00:12:02.155
往後推一段時間 合併寫入

00:12:03.323 --> 00:12:04.958
當計時器最終過期時

00:12:05.259 --> 00:12:08.428
它收集了我們頻繁採用的更新

00:12:08.495 --> 00:12:10.931
我們把其作爲單一的I/O操作寫出

00:12:12.666 --> 00:12:15.335
來看這些代碼在應用中的功能

00:12:16.436 --> 00:12:20.040
再次點擊Xcode UI中的
運行按鈕啓動應用

00:12:21.008 --> 00:12:25.445
進入調試導航儀 選擇磁盤儀表
找到I/O活動

00:12:27.714 --> 00:12:31.552
可以發現應用已經不再進行那些寫入了

00:12:32.152 --> 00:12:34.955
現它完全空閒 用戶也沒和它進行互動

00:12:35.022 --> 00:12:36.590
這就是我們的預期效果

00:12:37.558 --> 00:12:40.794
我們高效地合併了應用中I/O用量

00:12:41.195 --> 00:12:43.263
提高了I/O效率

00:12:45.566 --> 00:12:46.466
使用正確的線程

00:12:46.533 --> 00:12:50.671
在看過了一些最佳實踐技巧
可以減少I/O用量之後

00:12:51.171 --> 00:12:54.875
我們來看看利用這些I/O實踐的趨勢

00:12:55.409 --> 00:12:57.878
我想請Terry上臺爲大家演講

00:12:58.111 --> 00:12:58.946
Terry

00:13:04.518 --> 00:13:05.352
謝謝 Kushal

00:13:05.919 --> 00:13:09.823
我們剛看了一些
可以減少應用中I/O用量的好方法

00:13:09.890 --> 00:13:11.925
避免對電池壽命產生不良影響

00:13:12.860 --> 00:13:15.896
繼續講解我們的哲學的第二大支柱

00:13:16.630 --> 00:13:21.068
我會講解一些方法 可以在應用中
有效使用線程和隊列

00:13:21.435 --> 00:13:23.637
達到更好的I/O性能和效率

00:13:26.206 --> 00:13:31.011
系統中每一個線程或每一個應用
都從一個線程開始 叫做主線程

00:13:31.979 --> 00:13:35.782
該線程很特別 有幾個主要功能

00:13:35.849 --> 00:13:39.186
主線程的第一個功能是處理輸入

00:13:40.254 --> 00:13:42.489
如果點擊應用裏的一個按鈕

00:13:43.156 --> 00:13:45.859
主線程負責處理該輸入

00:13:46.426 --> 00:13:47.528
並作出響應

00:13:49.062 --> 00:13:52.599
此外 主線程還負責
更新界面

00:13:53.300 --> 00:13:57.638
這適用於比如繪製視圖
操作佈局 或動畫

00:13:59.339 --> 00:14:05.779
當主線程空閒時 它隨時備用
響應輸入和更新用戶界面

00:14:07.247 --> 00:14:09.683
但是如果在主線程上執行其他操作

00:14:10.117 --> 00:14:12.819
比如執行長任務

00:14:12.886 --> 00:14:15.856
比如昂貴的圖片處理

00:14:16.423 --> 00:14:18.825
這類的工作將會一直佔用主線程

00:14:19.393 --> 00:14:20.994
也就是說它不會空閒

00:14:21.061 --> 00:14:24.331
則無法響應輸入或更新界面

00:14:25.866 --> 00:14:27.935
此外 我們今天關注的是

00:14:28.402 --> 00:14:30.637
應該避免在主線程上進行I/O

00:14:31.805 --> 00:14:35.609
我們已看到I/O是系統中的昂貴資源

00:14:35.943 --> 00:14:37.578
需要對其正確管理

00:14:38.979 --> 00:14:40.714
如果在主線程上進行I/O操作

00:14:41.215 --> 00:14:44.117
使用應用的用戶會發現問題

00:14:45.686 --> 00:14:48.121
第一個例子是在macOS上

00:14:48.755 --> 00:14:50.390
用戶可能會看到旋轉光標

00:14:51.558 --> 00:14:54.194
旋轉光標意味着主線程繁忙

00:14:54.695 --> 00:14:57.364
則無法和應用進行互動

00:14:58.966 --> 00:15:00.734
此外 在iOS上

00:15:01.168 --> 00:15:05.939
繁忙的主線程可能會造成
應用發生凍結或無法響應

00:15:08.408 --> 00:15:12.479
最後 在主線程上進行I/O
會造成動畫出現問題

00:15:13.347 --> 00:15:16.917
比如 如果在視圖表格裏大幅度滾動

00:15:17.317 --> 00:15:19.987
然後在主線程上進行I/O
加載更多的數據

00:15:21.121 --> 00:15:23.857
應用在做這些操作時

00:15:24.091 --> 00:15:26.593
就無法繼續顯示動畫

00:15:26.860 --> 00:15:28.595
就會造成諸如卡屏的問題

00:15:29.396 --> 00:15:32.132
我想再提一次
Kushal剛纔指出的演講

00:15:32.666 --> 00:15:34.601
iOS和watchOS的性能

00:15:35.335 --> 00:15:39.173
該演講有很多關於
如何有效使用主線程的信息

00:15:41.475 --> 00:15:44.411
現在來看看ImageBox示例應用

00:15:44.645 --> 00:15:46.146
這次在macOS上運行

00:15:47.114 --> 00:15:51.318
我發現 當主集合視圖想添加圖片時
會產生問題

00:15:52.052 --> 00:15:53.353
來看一下

00:15:54.788 --> 00:15:56.924
首先從Xcode 點擊運行按鈕

00:15:58.392 --> 00:15:59.960
Xcode啓動應用

00:16:00.727 --> 00:16:03.263
然後點擊工具欄右邊的添加按鈕

00:16:05.499 --> 00:16:10.003
從打開的面板選中一張圖片 點擊打開

00:16:12.706 --> 00:16:15.242
如你所見 打開的面板並沒有消失

00:16:15.642 --> 00:16:17.010
我們看到了旋轉的光標

00:16:18.812 --> 00:16:21.982
終於 打開的面板消失了

00:16:22.916 --> 00:16:26.119
我們選中的圖片顯示在主集合視圖中

00:16:27.621 --> 00:16:29.022
這裏出了什麼問題？

00:16:32.025 --> 00:16:33.327
我們已經知道

00:16:33.994 --> 00:16:36.697
旋轉光標意味着主線程繁忙

00:16:36.930 --> 00:16:38.765
所以主線程上一定有操作在運行

00:16:38.832 --> 00:16:41.735
讓它無法空閒

00:16:41.935 --> 00:16:44.104
所以我們無法和應用互動

00:16:44.838 --> 00:16:46.473
我們需要找出問題

00:16:46.940 --> 00:16:49.243
因此需要用到Instruments

00:16:50.577 --> 00:16:53.580
回到Xcode 可在“產品”菜單裏
選擇“配置”

00:16:55.182 --> 00:16:57.684
Xcode重新編譯配置文件

00:16:57.818 --> 00:16:59.253
啓動Instruments

00:17:00.254 --> 00:17:02.956
這次我選擇Instruments裏
時間分析器模板

00:17:04.290 --> 00:17:07.426
時間分析器是非常好的工具
用來觀察耗費的時間

00:17:07.493 --> 00:17:09.530
每一部分代碼執行時需要的

00:17:10.030 --> 00:17:12.665
所以我們可以利用它找出
爲什麼主線程繁忙

00:17:14.401 --> 00:17:15.602
點擊選擇

00:17:16.136 --> 00:17:19.806
Instruments打開
全新空白的時間分析器文件

00:17:24.444 --> 00:17:26.880
默認情況下
Instruments時間分析器

00:17:26.946 --> 00:17:30.551
只在CPU活躍執行代碼時顯示耗時

00:17:31.818 --> 00:17:35.556
其他諸如I/O的操作
並沒有在CPU上活躍執行

00:17:36.323 --> 00:17:38.358
CPU會等待I/O結束

00:17:39.493 --> 00:17:43.764
若想在Instruments回溯中
看到此類操作

00:17:44.031 --> 00:17:46.466
首先點擊“記錄等待線程”選項

00:17:46.667 --> 00:17:47.868
在記錄設置目錄下

00:17:48.735 --> 00:17:51.038
現在Instruments也會顯示耗時

00:17:51.104 --> 00:17:53.140
當我們進行其他操作時
比如等待I/O

00:17:54.241 --> 00:17:57.177
我們開始 點擊Instruments中
“記錄”按鈕

00:18:00.013 --> 00:18:03.650
Instruments啓動應用
我會做同樣的操作

00:18:03.717 --> 00:18:05.385
和之前一樣 來重現問題

00:18:07.254 --> 00:18:10.791
首先 點擊“添加”按鈕
選中一張圖片 點擊“打開”

00:18:12.226 --> 00:18:13.393
問題又出現了

00:18:13.527 --> 00:18:15.629
在Instruments裏
點擊“停止”

00:18:15.963 --> 00:18:17.564
看看問題所在

00:18:19.233 --> 00:18:22.503
在繼續講解之前 我想整理一下輸出

00:18:22.903 --> 00:18:25.005
通過只關注我編寫的代碼

00:18:25.305 --> 00:18:26.940
而不是其他系統庫

00:18:27.808 --> 00:18:30.711
要做到這點 首先 點擊顯示選項

00:18:30.811 --> 00:18:32.312
在Instruments右邊

00:18:33.881 --> 00:18:36.350
然後點擊“隱藏系統庫”

00:18:37.484 --> 00:18:40.187
Instruments只顯示
我編寫的代碼

00:18:40.521 --> 00:18:43.223
而不顯示其他可能會調用的系統庫

00:18:45.225 --> 00:18:48.028
現在我們來看
Instruments的主詳細視圖

00:18:48.529 --> 00:18:51.365
Instruments顯示了
應用中所有不同線程

00:18:51.431 --> 00:18:53.834
和它們執行時不同的耗時數

00:18:54.968 --> 00:18:57.804
在本例中 我們只對主線程感興趣

00:18:58.205 --> 00:19:00.307
所以我可以展開主線程部分

00:19:02.376 --> 00:19:03.877
找到最繁忙的棧

00:19:07.281 --> 00:19:12.052
本例中 我看到應用裏有一個
打開的面板回調

00:19:12.119 --> 00:19:14.621
它在數據存儲裏調用一個添加方法

00:19:15.522 --> 00:19:18.926
該添加方法之後
把所有數據存儲存到磁盤上

00:19:20.961 --> 00:19:25.065
Instruments顯示
該存儲操作耗時幾乎爲7秒

00:19:25.632 --> 00:19:26.834
這非常糟糕

00:19:29.136 --> 00:19:32.906
而我剛好知道該存儲方法
正在寫出一個很大的Plist

00:19:33.207 --> 00:19:34.842
這會讓問題更爲嚴重

00:19:36.109 --> 00:19:38.145
Kushal在之後的演講
會提到一些方法

00:19:38.212 --> 00:19:40.681
來優化數據存儲操作

00:19:40.814 --> 00:19:42.316
將使操作速度變得很快

00:19:42.683 --> 00:19:46.420
但現在 我只想關注如何解決這個問題

00:19:46.486 --> 00:19:48.689
使得無論該操作進行多久

00:19:49.223 --> 00:19:51.592
我們的應用響應度都非常高

00:19:53.160 --> 00:19:54.761
爲了實現 來看一下代碼

00:19:56.964 --> 00:19:58.565
這裏是打開的面板回調

00:19:59.933 --> 00:20:01.201
它在等待一個響應

00:20:02.002 --> 00:20:03.871
當接受到該響應

00:20:03.937 --> 00:20:07.341
它將驗證響應是否有一個
指向有效圖片的URL

00:20:09.243 --> 00:20:12.980
然後它爲圖片的集合視圖
新建一個項目

00:20:13.347 --> 00:20:14.948
並試圖把它添加到數據存儲

00:20:17.150 --> 00:20:18.452
如果成功了

00:20:18.852 --> 00:20:21.154
它會告訴主集合視圖重新加載數據

00:20:21.755 --> 00:20:24.858
使得我們可以看見選中的圖片

00:20:27.094 --> 00:20:28.262
如我們之前所見

00:20:28.529 --> 00:20:30.497
Instruments
也驗證了這一點/b&gt;

00:20:30.797 --> 00:20:32.566
調用該添加方法非常昂貴

00:20:32.900 --> 00:20:34.968
因爲它把所有的數據都存到磁盤

00:20:36.803 --> 00:20:38.639
看看如何進行修復

00:20:40.707 --> 00:20:43.810
回憶一下 應用有一個主線程

00:20:44.778 --> 00:20:47.080
主線程正在執行打開面板回調

00:20:48.682 --> 00:20:51.618
該回調在數據存儲中調用添加方法

00:20:51.785 --> 00:20:53.754
這時我們看到旋轉光標

00:20:55.622 --> 00:20:56.723
當所有操作完成

00:20:56.990 --> 00:20:58.959
才終於可以更新主集合視圖

00:21:00.727 --> 00:21:02.529
這顯然不是我們想要的

00:21:03.030 --> 00:21:05.599
在這整個過程中 主線程都是繁忙的

00:21:06.033 --> 00:21:09.636
我們無法和應用進行互動
也無法更新任何界面

00:21:11.939 --> 00:21:16.009
一種解決此問題的方法是
採用中央調度 即GCD

00:21:17.578 --> 00:21:19.913
利用GCD 可以新建調度隊列

00:21:21.448 --> 00:21:22.649
調度隊列

00:21:22.716 --> 00:21:25.152
是在主線程上同時運行代碼的方法

00:21:26.186 --> 00:21:30.524
可以把昂貴的I/O相關操作
移動到該隊列中

00:21:31.024 --> 00:21:32.392
讓主線程空閒

00:21:33.560 --> 00:21:36.396
爲了實現 我們可以
在該隊列上調用async方法

00:21:36.797 --> 00:21:38.298
然後把昂貴的操作推入

00:21:38.799 --> 00:21:40.868
隊列而不是主線程

00:21:43.403 --> 00:21:46.874
最後 由於UI相關操作
必須要返回主線程

00:21:47.808 --> 00:21:52.079
我們可以異步調度返回
最終更新集合視圖

00:21:54.414 --> 00:21:56.016
現在 正是我們想要的

00:21:57.417 --> 00:22:00.521
昂貴的I/O操作正另一個隊列中進行

00:22:00.921 --> 00:22:02.723
因此主線程空閒

00:22:02.789 --> 00:22:05.292
也就是說我們可以跟應用進行互動

00:22:05.359 --> 00:22:06.393
並繼續使用

00:22:08.028 --> 00:22:10.697
來看看在代碼中實現是什麼樣子

00:22:12.833 --> 00:22:15.302
我還使用了之前同樣的
openPanel回調

00:22:16.336 --> 00:22:20.541
首先新建GCD調度隊列

00:22:21.074 --> 00:22:22.543
並提供一個描述標籤

00:22:24.111 --> 00:22:25.846
本例中 我建立了一個隊列

00:22:25.913 --> 00:22:28.515
可以重用所有數據存儲操作

00:22:30.617 --> 00:22:32.486
接下來 把昂貴的操作

00:22:32.553 --> 00:22:34.555
當添加圖片時 移動到這個隊列

00:22:35.022 --> 00:22:39.593
在調度隊列中
把代碼塊提供給async方法

00:22:42.729 --> 00:22:47.868
最後 要更新UI時 可以調用
dispatchqueue.main.async

00:22:48.769 --> 00:22:51.772
傳入包含所有UI相關操作的代碼塊

00:22:54.374 --> 00:22:56.443
完成之後 來看結果

00:22:56.510 --> 00:22:58.779
如果在Xcode裏重新編譯運行

00:23:00.080 --> 00:23:01.615
首先點擊“運行”按鈕

00:23:03.183 --> 00:23:04.785
等待應用啓動

00:23:05.352 --> 00:23:06.920
再次嘗試添加圖片操作

00:23:08.121 --> 00:23:11.425
點擊“添加”按鈕
從打開面板上選中一張圖片

00:23:12.392 --> 00:23:13.360
點擊“打開”

00:23:14.962 --> 00:23:17.965
可以看到 打開面板立即消失

00:23:18.298 --> 00:23:20.667
我們可以繼續和應用進行互動

00:23:20.934 --> 00:23:22.603
添加更多的圖片

00:23:23.904 --> 00:23:27.241
你還會發現 在主視圖上
我添加了一些佔位圖片

00:23:27.307 --> 00:23:30.744
這只是表示 我們正在處理該數據

00:23:30.811 --> 00:23:31.945
並存到磁盤

00:23:33.413 --> 00:23:35.916
當所有數據完成添加和存儲

00:23:36.517 --> 00:23:38.785
所有的圖片都會顯示在主集合視圖

00:23:38.952 --> 00:23:42.389
在整個過程中 主線程都是空閒

00:23:42.689 --> 00:23:44.958
也就是說應用響應極爲迅速

00:23:45.626 --> 00:23:46.960
這個結果正是我們想要的

00:23:49.563 --> 00:23:53.233
現在我們把操作從主線程移到
調度隊列中

00:23:53.567 --> 00:23:57.004
應該考慮告訴系統該操作的內容

00:23:57.070 --> 00:23:59.406
使系統可以爲我們管理資源

00:24:00.407 --> 00:24:03.577
爲了實現 可以採用一種叫
“服務質量”的方法

00:24:05.112 --> 00:24:07.814
服務質量是一種方法 可以告訴系統

00:24:07.881 --> 00:24:09.616
正在執行的操作的內容

00:24:09.983 --> 00:24:13.954
使系統可以正確地管理資源
比如CPU或I/O

00:24:16.356 --> 00:24:17.858
系統管理這些資源

00:24:18.125 --> 00:24:20.527
在系統不同的運行中進程之間

00:24:20.761 --> 00:24:22.896
以及應用內部不同的線程之間

00:24:24.831 --> 00:24:26.667
當使用服務質量時

00:24:26.900 --> 00:24:30.370
請記住正在執行的工作的三個屬性

00:24:31.538 --> 00:24:34.141
可見性 重要性和期待值

00:24:35.776 --> 00:24:37.144
問問自己三個問題

00:24:38.412 --> 00:24:41.949
正在執行的工作
是否對使用應用的用戶可見？

00:24:43.817 --> 00:24:46.286
其次 該工作的重要性是什麼？

00:24:47.087 --> 00:24:51.291
該工作是否必須完成
在別人可以繼續使用應用之前？

00:24:52.726 --> 00:24:56.263
最後 該工作預計需要多久

00:24:56.930 --> 00:25:01.935
是否是立即發生的
還是估計需要很長時間的？

00:25:03.904 --> 00:25:07.774
在繼續之前 我想推薦
去年WWDC上的一個演講

00:25:08.075 --> 00:25:10.978
叫作 用GCD建立響應式
和高效的應用

00:25:11.645 --> 00:25:14.481
該演講講解了很多GCD的細節

00:25:14.748 --> 00:25:16.283
以及如何使用服務質量

00:25:16.550 --> 00:25:18.519
我大力推薦大家觀看

00:25:20.988 --> 00:25:24.191
當我們思考完這三個屬性

00:25:24.658 --> 00:25:28.095
我們準備從四個服務質量類裏選擇一個

00:25:29.796 --> 00:25:31.331
第一個服務質量類

00:25:31.598 --> 00:25:32.766
是用戶互動

00:25:34.001 --> 00:25:36.703
用戶互動被指派給主線程

00:25:37.671 --> 00:25:40.741
爲了完成比如響應輸入和動畫的操作

00:25:42.776 --> 00:25:45.913
所有其他和主線程異步發生的操作

00:25:46.246 --> 00:25:49.750
都應該使用其他三個服務質量類之一

00:25:50.951 --> 00:25:53.687
其中第一個是用戶啓動

00:25:55.055 --> 00:25:58.392
用戶啓動工作對應用用戶可見

00:25:58.458 --> 00:26:01.028
用戶期望得到立竿見影的效果

00:26:01.595 --> 00:26:03.730
用戶可能也需要該工作結束

00:26:04.064 --> 00:26:06.800
在他們可以繼續與應用互動之前

00:26:07.734 --> 00:26:09.002
一個好例子是

00:26:09.069 --> 00:26:12.039
如果我點擊一個按鈕 切換到新視圖

00:26:12.606 --> 00:26:15.309
可能需要在不同的隊列中加載資源

00:26:15.676 --> 00:26:17.010
爲了顯示該視圖

00:26:17.511 --> 00:26:19.913
該工作應該在用戶啓動中進行

00:26:21.648 --> 00:26:23.917
服務類的第三個質量是實用工具

00:26:25.085 --> 00:26:27.855
實用工具服務質量通常和

00:26:27.921 --> 00:26:31.291
有進度條或其他活動顯示器的工作相關

00:26:32.159 --> 00:26:34.461
該工作通常耗費很長的時間

00:26:35.362 --> 00:26:38.532
它也對應用用戶可見

00:26:39.399 --> 00:26:41.335
這方面一個很好的例子是渲染電影

00:26:41.869 --> 00:26:44.538
它不會阻擋任何人

00:26:44.605 --> 00:26:46.607
繼續使用你的應用

00:26:46.773 --> 00:26:49.309
但是它也耗費很長的時間才能完成

00:26:50.911 --> 00:26:53.313
最後一個服務質量類是後臺

00:26:54.047 --> 00:26:57.050
後臺操作對用戶不可見

00:26:57.918 --> 00:27:00.354
其實 用戶甚至根本不知道它正在進行

00:27:01.288 --> 00:27:03.290
這方面的一個好例子就是索引

00:27:03.991 --> 00:27:06.760
索引通常對應用性能十分重要

00:27:07.461 --> 00:27:10.764
但一般用戶不會注意到

00:27:12.866 --> 00:27:16.003
所有這些服務質量類都很重要

00:27:16.770 --> 00:27:19.640
因爲當你選擇服務質量類

00:27:19.706 --> 00:27:22.543
它會幫助通知系統該如何管理資源

00:27:22.976 --> 00:27:26.880
使不太重要的工作 如後臺操作和索引

00:27:27.181 --> 00:27:30.551
不會消極影響重要的工作 如動畫

00:27:31.051 --> 00:27:33.887
即使該工作在不同的進程上進行

00:27:36.056 --> 00:27:38.926
當選擇了一個服務質量類時

00:27:39.426 --> 00:27:40.527
有兩種方法

00:27:40.594 --> 00:27:43.564
可以在應用中指定服務質量

00:27:44.298 --> 00:27:48.368
第一種方法是提供一個可選QOS參數

00:27:48.435 --> 00:27:50.404
給調度隊列的async方法

00:27:51.505 --> 00:27:54.508
本例中 我指定了qos:.background

00:27:55.576 --> 00:27:58.912
也就是說當提供的代碼塊異步運行時

00:27:59.446 --> 00:28:01.748
它將使用後臺服務質量

00:28:03.517 --> 00:28:07.487
此外 若正使用操作隊列或操作API

00:28:07.955 --> 00:28:11.291
這兩者都有一個服務質量屬性
可以對其進行設置

00:28:11.358 --> 00:28:12.226
比如實用工具

00:28:15.863 --> 00:28:18.031
現在我們已經初步瞭解服務質量

00:28:18.098 --> 00:28:19.566
以及如何指定

00:28:19.766 --> 00:28:21.869
讓我們回到ImageBox應用

00:28:22.135 --> 00:28:25.706
看能否爲添加圖片選擇合適的服務質量

00:28:27.040 --> 00:28:30.077
爲了實現這一點 我們可以思考
這項工作的三個屬性

00:28:30.377 --> 00:28:33.514
可見性 重要性和期望值

00:28:35.516 --> 00:28:37.751
添加屬性是可見的操作

00:28:37.818 --> 00:28:39.386
對應用用戶來說

00:28:40.587 --> 00:28:43.156
但它不一定需要完成

00:28:43.457 --> 00:28:45.292
在我們可以繼續做其他事之前

00:28:45.359 --> 00:28:47.928
比如瀏覽圖片或添加更多圖片

00:28:49.563 --> 00:28:52.466
此外 因爲還顯示了佔位圖片

00:28:52.799 --> 00:28:55.269
我們給出了指示 該操作

00:28:55.335 --> 00:28:57.237
可能會耗費較長時間

00:28:58.772 --> 00:29:01.842
出於以上種種原因 服務質量

00:29:02.109 --> 00:29:04.011
可能是該項工作合適的選擇

00:29:07.114 --> 00:29:09.950
現在我們知道了一些方法
可以移動昂貴工作

00:29:10.117 --> 00:29:14.154
比如I/O 讓它們離開主線程
進入另一個調度隊列

00:29:14.621 --> 00:29:17.658
以及如何利用服務質量指定該工作內容

00:29:18.559 --> 00:29:21.495
讓我們來看哲學的第三支柱

00:29:22.229 --> 00:29:24.064
採用適當的API

00:29:25.332 --> 00:29:29.069
首先我要提到的就是 資產目錄

00:29:30.938 --> 00:29:33.307
如果你還不知道 資產目錄是一種方法

00:29:33.373 --> 00:29:36.944
可以簡單地管理應用裏的資源 如圖片

00:29:37.578 --> 00:29:40.480
它們被用來存儲
比如應用圖標和啓動圖片

00:29:41.181 --> 00:29:43.483
以及所支持的不同設備上的所有圖片

00:29:43.550 --> 00:29:47.588
以及比例係數
比如retina或非retina

00:29:49.256 --> 00:29:50.757
用SpriteKit編寫遊戲時

00:29:50.824 --> 00:29:54.294
資產目錄也用來編寫
Sprite Atlases

00:29:55.562 --> 00:29:58.265
可以利用資產目錄來標註資源

00:29:58.465 --> 00:30:00.567
以服務按需資源功能

00:30:02.436 --> 00:30:04.972
另一個使用資產目錄的例子是

00:30:05.038 --> 00:30:07.975
在watch complications裏存儲資源

00:30:10.244 --> 00:30:12.813
爲什麼資產目錄對I/O來說很棒？

00:30:14.481 --> 00:30:17.684
資產目錄有一些很棒的存儲效率性質

00:30:19.052 --> 00:30:22.422
首先 因爲資產目錄存儲所有圖片

00:30:22.489 --> 00:30:24.091
用同一種優化格式

00:30:24.391 --> 00:30:26.593
而不是許多單個文件

00:30:27.928 --> 00:30:31.131
你可以通過使用資產目錄
得到較低的磁盤佔用

00:30:33.267 --> 00:30:36.436
此外 通過iOS上的
如應用切片等功能

00:30:37.004 --> 00:30:39.206
當從App Store下載應用時

00:30:39.640 --> 00:30:41.875
它將利用資產目中的元數據

00:30:42.176 --> 00:30:45.445
決定該下載什麼資源到設備上

00:30:46.680 --> 00:30:49.316
比如
若我下載一個應用到iPhone

00:30:50.083 --> 00:30:52.753
App Store知道
不需要下載任何資源

00:30:52.819 --> 00:30:56.557
準備給iPad或其他
不同屏幕分辨率的iPhone的

00:30:56.924 --> 00:30:59.126
這會在設備上省下不少空間

00:31:01.461 --> 00:31:04.631
此外 資產目錄對性能也很有幫助

00:31:05.566 --> 00:31:08.135
因爲它們存儲用的優化格式

00:31:08.569 --> 00:31:09.870
圖片加載將變得更快

00:31:11.171 --> 00:31:14.141
如果利用它們爲遊戲
編寫Sprite Atlases

00:31:15.142 --> 00:31:18.579
由於用戶可以很好地管理
一個大一點的資源

00:31:18.812 --> 00:31:20.781
而不是很多小的資源

00:31:21.415 --> 00:31:24.351
這些Sprite Atlases
可以加快紋理渲染時間

00:31:25.986 --> 00:31:29.022
最後 如果使用資產目錄

00:31:29.356 --> 00:31:31.391
在運行macOS的硬盤機上

00:31:32.326 --> 00:31:34.228
還可以加快應用的啓動時間

00:31:35.362 --> 00:31:38.665
實際上 我們看過高達百分之十的提高

00:31:38.832 --> 00:31:43.103
在這些機器上的應用啓動時間
只需要切換到資產目錄

00:31:45.772 --> 00:31:49.443
你可能會認爲
要得到這麼大的性能提高

00:31:49.810 --> 00:31:53.280
切換到資產目錄一定很難
或很耗費時間

00:31:54.014 --> 00:31:55.883
而事實上 如果已經使用了

00:31:55.949 --> 00:31:58.852
標準NS圖片和基於UI圖片的API

00:31:59.286 --> 00:32:01.321
切換到資產目錄很簡單

00:32:01.889 --> 00:32:04.658
現在我想爲大家
用一個示例項目來演示

00:32:06.293 --> 00:32:09.363
這裏有一個還沒採用資產目錄的項目

00:32:10.430 --> 00:32:15.068
要開始 首先可從文件菜單選擇新文件

00:32:17.237 --> 00:32:23.977
然後從資源類別 選擇資產目錄
點擊下一步

00:32:25.946 --> 00:32:27.748
Xcode新建了一個 抱歉

00:32:29.049 --> 00:32:32.386
系統提示時 爲資產目錄
添加一個名稱和地址

00:32:33.153 --> 00:32:34.121
然後點擊新建

00:32:34.788 --> 00:32:38.759
現在Xcode爲項目新建了
一個空白的資產目錄

00:32:41.094 --> 00:32:43.163
要移動所有已存資產

00:32:43.230 --> 00:32:45.566
從項目到該新資產目錄

00:32:46.533 --> 00:32:48.869
首先打開屏幕底部的添加菜單

00:32:48.936 --> 00:32:50.504
選擇“從項目導入”

00:32:52.639 --> 00:32:56.009
Xcode會顯示項目中所有圖片列表

00:32:56.577 --> 00:32:57.845
點擊“導入”

00:32:58.645 --> 00:33:02.049
它會把所有這些圖片都移到
全新的空白資產目錄中

00:33:02.683 --> 00:33:04.351
Xcode自動找出

00:33:04.585 --> 00:33:07.621
哪些圖片爲哪些設備準備
以及以什麼比例係數

00:33:09.323 --> 00:33:14.061
現在當重新編譯應用時
它將使用該全新資產目錄

00:33:14.628 --> 00:33:15.462
就這樣

00:33:16.063 --> 00:33:17.197
用了不到一分鐘

00:33:17.497 --> 00:33:19.867
並且不用修改任何一行代碼

00:33:20.467 --> 00:33:22.703
真的很簡單 所以我強烈鼓勵

00:33:22.769 --> 00:33:26.039
大家採用資產目錄 就在今天
如果你還沒用

00:33:28.509 --> 00:33:31.011
關於資產目錄 我還想提一點

00:33:31.078 --> 00:33:34.214
今年有一個新的功能是 圖片壓縮

00:33:36.049 --> 00:33:39.152
默認情況下 資產目錄的圖片
是無損畫質

00:33:40.354 --> 00:33:41.522
但今年新的改變是

00:33:41.588 --> 00:33:45.292
可以選擇一種有損圖片壓縮格式

00:33:46.760 --> 00:33:49.429
這些格式擁有硬件快速解壓

00:33:49.830 --> 00:33:50.931
所以非常快

00:33:51.899 --> 00:33:53.700
因爲有了這些壓縮格式

00:33:53.967 --> 00:33:55.936
可以降低內存佔用

00:33:57.504 --> 00:33:59.573
如果應用中有很多資產

00:34:00.340 --> 00:34:03.377
會在潛在內存和空間節省方面受益良多

00:34:03.443 --> 00:34:04.745
通過使用圖片壓縮

00:34:06.280 --> 00:34:08.014
來看看如何使用圖片壓縮

00:34:08.382 --> 00:34:11.652
回到剛轉化到資產目錄的項目

00:34:13.187 --> 00:34:15.322
首先 點擊目錄裏的一張圖片

00:34:16.857 --> 00:34:19.693
打開右邊的實用工具側欄

00:34:21.128 --> 00:34:23.096
點擊屬性檢查器

00:34:24.565 --> 00:34:27.134
Xcode新包含了一個壓縮彈出菜單

00:34:28.202 --> 00:34:29.303
選中它時

00:34:29.735 --> 00:34:32.706
它會顯示所有可用的圖片壓縮格式

00:34:34.842 --> 00:34:37.411
本例中 我選擇自動有損

00:34:37.777 --> 00:34:40.880
讓Xcode爲我選擇一個好格式

00:34:43.417 --> 00:34:47.420
這是關於如何在應用中
利用資產目錄的一點介紹

00:34:47.487 --> 00:34:50.389
採用它們 使用新的圖片壓縮功能

00:34:51.792 --> 00:34:53.627
現在我把講臺還給Kushal

00:34:54.127 --> 00:34:56.396
他將爲大家講解其他更多的API

00:34:56.463 --> 00:34:58.632
可以用來存儲數據

00:35:06.240 --> 00:35:07.074
謝謝 Terry

00:35:07.574 --> 00:35:09.843
資產目錄是既簡單又高效的方法

00:35:09.910 --> 00:35:11.278
來管理應用中的資產

00:35:12.679 --> 00:35:14.715
我們很多人還會想到的另一件事

00:35:14.781 --> 00:35:17.918
是應用數據在設備上如何存儲
和存儲位置

00:35:20.153 --> 00:35:22.890
我們很多人對序列數據格式很熟悉

00:35:22.956 --> 00:35:25.659
如 Plists XML和JSON

00:35:26.860 --> 00:35:28.795
這些數據格式流行的原因

00:35:29.062 --> 00:35:31.331
是因爲它們簡單好用

00:35:31.865 --> 00:35:35.002
而且它們作爲數據交換格式也流行多年

00:35:35.335 --> 00:35:36.870
在很多基於網絡的服務中

00:35:38.639 --> 00:35:41.842
這些數據格式對少量只讀數據很有用

00:35:41.909 --> 00:35:44.878
比如Info.plist文件中的
配置信息

00:35:46.146 --> 00:35:48.282
然而 它們不是數據庫

00:35:49.349 --> 00:35:51.418
而它們不是數據庫的最大原因

00:35:51.485 --> 00:35:53.420
是這些文件的微小更新

00:35:53.487 --> 00:35:56.356
都會導致整個數據文件寫出到磁盤上

00:35:56.557 --> 00:35:58.425
這非常影響I/O效率

00:35:59.693 --> 00:36:01.195
爲了所有數據的存儲需要

00:36:01.395 --> 00:36:05.065
建議使用Apple SQLite
數據庫框架的核心數據

00:36:07.234 --> 00:36:11.905
核心數據是Cocoa應用開發框架

00:36:12.172 --> 00:36:13.907
用於管理應用數據

00:36:17.644 --> 00:36:21.648
它將通過採用SQLite作爲
後備存儲來處理數據持久化

00:36:23.450 --> 00:36:28.422
它自動管理對象 對象圖形
和對象之間的關係

00:36:28.956 --> 00:36:32.092
讓你更簡單高效地管理數據

00:36:34.228 --> 00:36:35.696
它還進行修改跟蹤

00:36:35.762 --> 00:36:38.899
可以讓你在數據模型中
進行撤銷和恢復操作

00:36:40.968 --> 00:36:44.037
核心數據完全集合在Xcode工具鏈

00:36:44.104 --> 00:36:48.275
因此可以建立和可視化數據模型
直接從Xcode UI

00:36:51.545 --> 00:36:56.416
現在我們知道這個優秀的工具和框架
可以用來設計或編寫數據模型

00:36:56.717 --> 00:36:58.952
讓我們思考該如何設計數據模型

00:37:00.053 --> 00:37:04.458
最好的方法是把數據模型
基於應用的UI需求

00:37:05.993 --> 00:37:07.227
回到ImageBox

00:37:07.294 --> 00:37:09.630
它到現在一直使用巨大的Plist

00:37:09.696 --> 00:37:11.899
來寫出所有文件和所有圖片

00:37:11.965 --> 00:37:13.901
和應用相關的

00:37:14.902 --> 00:37:16.870
現在用核心數據模型來替換它

00:37:18.405 --> 00:37:22.075
仔細思考該應用
ImageBox有兩個實體

00:37:23.010 --> 00:37:25.913
第一個是集合視圖裏的項目列表

00:37:27.047 --> 00:37:30.050
第二個是其中每一項的相關注釋

00:37:31.151 --> 00:37:33.520
我們來把它們放入各自的一張表裏

00:37:35.956 --> 00:37:37.558
第一張表是BoxItem

00:37:37.624 --> 00:37:40.160
表示集合視圖裏的某些特定項目

00:37:40.494 --> 00:37:43.397
第二張表是註釋 表示註釋本身

00:37:44.464 --> 00:37:46.567
BoxItem表格含有一個布爾項

00:37:46.767 --> 00:37:49.236
表示圖片是喜歡還是不喜歡

00:37:49.870 --> 00:37:55.309
還含有全分辨率圖片 你想表示的圖片

00:37:56.643 --> 00:38:00.981
Notes表包含BoxItem裏
所有相關注釋的主體

00:38:01.315 --> 00:38:04.651
我們把這兩張表用
簡單的一對多關係連接起來

00:38:06.587 --> 00:38:10.290
當使用該數據模型時
看看應用的性能表現

00:38:10.357 --> 00:38:13.093
我們發現應用啓動性能非常慢

00:38:14.127 --> 00:38:15.929
我們用Instruments
調查原因

00:38:16.230 --> 00:38:18.832
發現應用耗費了絕大部分時間

00:38:18.899 --> 00:38:21.401
在啓動面板上獲取核心數據模型

00:38:22.536 --> 00:38:25.272
所以我們需要查看應用啓動性能

00:38:25.506 --> 00:38:26.840
從核心數據的角度

00:38:27.875 --> 00:38:30.544
幸運的是核心數據讓我們做到這一點

00:38:31.545 --> 00:38:33.580
它有一個工具集合 幫助你調查

00:38:33.647 --> 00:38:35.582
核心數據運行情況

00:38:36.783 --> 00:38:40.020
比如 你可在應用上設置一個啓動參數

00:38:40.087 --> 00:38:43.023
即com.Apple.CoreData.SQLDebug

00:38:43.090 --> 00:38:46.593
帶着速度級別
讓你觀察覈心數據是如何

00:38:46.660 --> 00:38:48.395
和其SQLite後備存儲進行互動的

00:38:50.364 --> 00:38:54.501
核心數據Instruments模板
讓你觀察任何模式

00:38:54.568 --> 00:38:56.937
關於獲取和加載太多的數據

00:38:59.640 --> 00:39:03.210
最後 SQLite查詢分析工具的
標準集合

00:39:03.377 --> 00:39:05.546
比如 解釋查詢可用

00:39:05.679 --> 00:39:07.848
讓你更深入到某個特定查詢

00:39:07.915 --> 00:39:09.249
查看其性能

00:39:11.652 --> 00:39:13.086
想了解這些工具更詳細信息

00:39:13.320 --> 00:39:16.356
我推薦大家查看去年WWDC文件

00:39:16.423 --> 00:39:17.891
“核心數據的全新功能”

00:39:19.426 --> 00:39:21.528
我們有了這些工具 來使用其中一個

00:39:21.595 --> 00:39:23.597
找到數據模型的問題

00:39:25.032 --> 00:39:27.301
爲了實現這一點 點擊項目

00:39:28.135 --> 00:39:29.169
點擊編輯方案

00:39:36.310 --> 00:39:39.279
在打開的窗口中 選中參數面板

00:39:41.682 --> 00:39:45.986
添加一個新參數
com.Apple.CoreData.SQLDebug

00:39:46.053 --> 00:39:47.921
速度級別選擇最高3

00:39:53.694 --> 00:39:56.597
完成後 繼續點擊關閉

00:39:58.966 --> 00:40:01.702
現在我們從Xcode UI啓動應用

00:40:04.004 --> 00:40:07.674
這樣做將重編譯項目加載並啓動應用

00:40:10.077 --> 00:40:13.013
如你所見 控制檯顯示了各種日誌

00:40:13.080 --> 00:40:16.350
關於數據模型性能的核心數據

00:40:17.584 --> 00:40:18.785
還會注意到的另個地方

00:40:18.852 --> 00:40:21.088
是該應用用了幾秒的時間啓動

00:40:21.154 --> 00:40:22.956
現在還沒有結束啓動

00:40:25.959 --> 00:40:29.062
在日誌輸出中 我們看到更多核心數據

00:40:29.596 --> 00:40:31.398
終於 應用啓動完成

00:40:33.066 --> 00:40:36.270
回到Xcode UI
你可以深入挖掘所有日誌

00:40:36.336 --> 00:40:38.572
找出數據模型的問題所在

00:40:39.206 --> 00:40:41.408
讓我們繼續 在應用中實踐一下

00:40:44.044 --> 00:40:45.846
你在這裏看到的最開始的日誌之一

00:40:45.913 --> 00:40:48.649
是核心數據對所有行進行讀取

00:40:48.882 --> 00:40:52.319
從SQLite數據庫
在BoxItem表格

00:40:52.386 --> 00:40:54.421
這是我們想要的

00:40:55.889 --> 00:41:00.060
然而 下一個日誌告訴我們
該讀取操作耗費了大概9秒

00:41:00.661 --> 00:41:01.595
這非常糟糕

00:41:01.662 --> 00:41:04.731
是應用啓動速度慢的最大原因

00:41:06.366 --> 00:41:09.903
回到之前執行讀取所有這些數據的查詢

00:41:10.137 --> 00:41:11.238
會注意到一點

00:41:11.471 --> 00:41:13.507
我們在讀取全像素圖片

00:41:13.574 --> 00:41:15.876
對於BoxItem表格的每一項

00:41:16.176 --> 00:41:19.079
儘管在啓動屏幕上顯示的只是縮略圖

00:41:20.914 --> 00:41:24.918
繼續 我們還發現
核心數據在進行一個合併操作

00:41:24.985 --> 00:41:27.421
在BoxItem表和Notes表間

00:41:27.654 --> 00:41:30.157
在從BoxItem表裏讀取每一項時

00:41:31.258 --> 00:41:32.593
這麼做的原因是

00:41:32.659 --> 00:41:34.561
因爲是一對多的關係

00:41:34.628 --> 00:41:35.963
在這兩個實體之間

00:41:36.463 --> 00:41:38.999
而且我們需要
在啓動屏幕上顯示一個UI批處理

00:41:39.066 --> 00:41:41.935
來表示BoxItem是否有相關注釋

00:41:44.104 --> 00:41:46.139
讓我們繼續修改數據模型

00:41:48.008 --> 00:41:51.612
首先要修改的是避免兩張表的合併操作

00:41:52.613 --> 00:41:54.948
核心數據又做了合併操作的原因

00:41:55.015 --> 00:41:58.218
是因爲我們需要顯示UI

00:41:58.285 --> 00:42:00.521
對於BoxItem的註釋是否出現

00:42:01.989 --> 00:42:03.090
所以爲了改進該模型

00:42:03.156 --> 00:42:05.926
可以簡單地在
BoxItem表裏添加一個字段

00:42:05.993 --> 00:42:07.394
叫notesPresent

00:42:08.428 --> 00:42:12.799
該特定字段False值存在與否

00:42:12.866 --> 00:42:16.236
告訴我們是否需要
在啓動屏幕上加入UI批處理

00:42:18.872 --> 00:42:20.474
數據模型的下一個問題

00:42:20.707 --> 00:42:22.809
是我們讀取的是全像素圖片

00:42:22.876 --> 00:42:23.844
在啓動屏幕上

00:42:24.811 --> 00:42:26.046
讓我們來修復它

00:42:26.880 --> 00:42:29.082
我們把圖片數據替換爲縮略圖數據

00:42:29.449 --> 00:42:31.752
不再把全像素圖片數據移動到

00:42:31.818 --> 00:42:33.453
它本身的表格

00:42:33.887 --> 00:42:36.890
而是把這兩張表通過
一個簡單的一對一關係連接起來

00:42:38.759 --> 00:42:42.095
如很多人知道的那樣
這些圖片會變得很大

00:42:42.863 --> 00:42:45.132
可能會是個好主意 來把這些圖片

00:42:45.199 --> 00:42:47.234
作爲單獨的文件存儲在文件系統

00:42:47.301 --> 00:42:49.570
而不是把它們放入SQLite數據庫

00:42:51.004 --> 00:42:53.006
所以我們將把全像素圖片

00:42:53.073 --> 00:42:56.944
作爲數據庫本身的一部分
取代爲圖片URL

00:42:57.010 --> 00:42:59.046
並把圖片直接存在磁盤上

00:43:00.747 --> 00:43:04.218
現在來看看應用的啓動性能
在修改完之後

00:43:05.352 --> 00:43:07.354
從Xcode UI運行項目

00:43:07.421 --> 00:43:11.792
採用新的數據模型 編譯 啓動

00:43:15.229 --> 00:43:16.096
如你所見

00:43:16.163 --> 00:43:18.565
應用啓動速度快了四到五倍

00:43:18.632 --> 00:43:20.100
只是修改了數據模型

00:43:21.034 --> 00:43:23.136
所以讓你的數據模型基於UI需求

00:43:23.203 --> 00:43:26.707
可以明顯影響應用的運行和整體性能

00:43:29.776 --> 00:43:32.613
我們已經講解了減少並優化

00:43:32.679 --> 00:43:34.581
應用I/O用量的方法

00:43:34.882 --> 00:43:37.951
我們接下來講解如何測試I/O性能

00:43:40.420 --> 00:43:44.091
其中一點建議是在不同設備上測試應用

00:43:45.259 --> 00:43:47.694
如果應用發生改變 在多個平臺上

00:43:47.961 --> 00:43:50.297
將會是一個好方法 測試你的應用

00:43:50.364 --> 00:43:53.033
在不同的設備 在所有這些平臺上

00:43:54.034 --> 00:43:56.069
即使應用只在一個平臺上發生改變

00:43:56.270 --> 00:43:58.972
跨代測試也是一個好方法

00:43:59.039 --> 00:44:01.241
因爲I/O特性有很大不同

00:44:04.411 --> 00:44:05.646
另一個可能改變的部分

00:44:05.712 --> 00:44:08.682
在你的環境 和應用用戶的環境之間

00:44:08.749 --> 00:44:10.250
是網絡條件

00:44:10.851 --> 00:44:12.853
爲了幫你測試網絡條件

00:44:12.920 --> 00:44:14.688
或者最壞情況的網絡條件

00:44:15.055 --> 00:44:17.357
我們提供了一個工具
叫做網絡連接調節器

00:44:19.193 --> 00:44:21.161
打開網絡連接調節器的方法是

00:44:21.228 --> 00:44:22.229
打開設置應用

00:44:24.932 --> 00:44:28.001
滾動到最底部 找到開發者設置

00:44:31.305 --> 00:44:34.074
點擊開發者設置 進入這個菜單

00:44:35.275 --> 00:44:37.911
可以看到在這裏 是網絡連接調節器

00:44:38.612 --> 00:44:41.348
點擊 打開這個菜單

00:44:41.415 --> 00:44:44.518
顯示了可安裝在設備上的各種配置文件

00:44:45.185 --> 00:44:50.591
有3G 高延遲DNS
以及我最喜歡的 非常糟糕的網絡

00:44:52.559 --> 00:44:55.429
讓我們來看看使用它的情況
選中“非常糟糕的網絡”

00:44:55.896 --> 00:44:58.599
用上方的滑動按鈕開啓它

00:45:00.467 --> 00:45:01.301
就這樣

00:45:01.568 --> 00:45:04.238
現在你的設備會表現的
好像處於非常糟糕的網絡中

00:45:04.304 --> 00:45:06.340
你可以這樣進行測試

00:45:09.176 --> 00:45:12.679
另一個需要記住的事實是
I/O是系統中的共享資源

00:45:13.413 --> 00:45:16.650
應用的I/O性能可能會受到

00:45:16.717 --> 00:45:20.387
其他系統資源的影響
或者其他設備上進行的I/O

00:45:23.290 --> 00:45:27.160
比如 由於多任務
還有其他應用正在運行

00:45:27.394 --> 00:45:29.596
你的應用的I/O性能可能會受到影響

00:45:30.197 --> 00:45:33.634
所以最好能夠測試應用
在有其他應用的情況下

00:45:35.602 --> 00:45:38.505
並且 系統試圖維持公平的平衡

00:45:38.572 --> 00:45:40.674
在內存和I/O使用之間

00:45:41.341 --> 00:45:45.546
在內存緊張情況下
I/O延遲也可能受到影響

00:45:46.413 --> 00:45:49.683
所以我們也建議
在內存緊張情況下測試應用

00:45:51.685 --> 00:45:56.456
最後 系統默認情況下
爲你保留了很多緩存

00:45:56.523 --> 00:45:58.592
爲了讓你更好地訪問和存儲數據

00:45:59.826 --> 00:46:04.798
這些緩存的狀態也可能影響系統
以及應用的I/O性能

00:46:05.632 --> 00:46:07.701
爲了檢測其最壞情況

00:46:07.935 --> 00:46:10.938
我們會建議重啓iOS設備

00:46:11.638 --> 00:46:13.874
及macOS設備
可使用purge命令

00:46:14.141 --> 00:46:18.645
將會刷新所有緩存
爲應用模擬最壞情況

00:46:19.980 --> 00:46:21.081
爲了確保你的應用

00:46:21.148 --> 00:46:24.318
在所有這些環境變化中
保持性能良好

00:46:24.651 --> 00:46:28.155
我們建議遵循I/O哲學
減少和優化I/O

00:46:30.023 --> 00:46:31.992
這裏是本次演講的幾點關鍵

00:46:33.260 --> 00:46:38.232
減少應用的I/O用量
因爲它顯著影響電池壽命

00:46:40.267 --> 00:46:45.706
把繁重的I/O工作量從主線程中移開
讓主線程爲UI和動畫保持空閒

00:46:47.641 --> 00:46:51.812
指定正確的服務質量
爲了指定正在進行的工作內容

00:46:53.947 --> 00:46:57.084
切換到資產目錄
因爲它們是最簡單高效的方法

00:46:57.150 --> 00:46:58.685
來管理應用資產

00:47:00.621 --> 00:47:03.023
爲數據庫需求使用核心數據

00:47:03.924 --> 00:47:06.894
最後 測試和測量應用的I/O性能

00:47:08.562 --> 00:47:10.931
想了解更多信息
請訪問www.developer.apple.com

00:47:10.998 --> 00:47:12.966
本場演講編號爲719

00:47:14.968 --> 00:47:17.171
本週內還會有這些相關演講

00:47:17.237 --> 00:47:20.841
你可以參考更多
我們提到過的API和工具的細節

00:47:21.575 --> 00:47:22.709
謝謝大家