00:00:19.353 --> 00:00:21.355
<c.green>Metal的新特性

00:00:27.261 --> 00:00:28.095
<c.green>歡迎大家的到來

00:00:28.762 --> 00:00:31.765
<c.green>這是Metal的新特性的第二場演講

00:00:32.432 --> 00:00:36.803
<c.green>我叫Charles Brissart
<c.green>是GPU軟件工程師

00:00:37.237 --> 00:00:41.008
<c.green>參加這場演講的還有我的同事
<c.green>Dan Omachi和Ana Tikhonova

00:00:41.475 --> 00:00:43.977
<c.green>我要談一下Metal的一些新特性

00:00:45.445 --> 00:00:51.018
<c.green>但首先 讓我們先回顧一下 WWDC
<c.green>關於Metal的第一場演講

00:00:52.219 --> 00:00:55.389
<c.green>我把這前兩場演講稱作採用Metal

00:00:55.455 --> 00:00:58.325
<c.green>公開了Metal的一些基本概念

00:00:58.759 --> 00:01:01.361
<c.green>以及一些更先進的想法

00:01:02.896 --> 00:01:06.867
<c.green>Metal的新特性演講
<c.green>展示了我們的新特性

00:01:07.968 --> 00:01:11.438
<c.green>最後 高級影子優化演講

00:01:11.972 --> 00:01:15.442
<c.green>將說明如何在不使用
<c.green>着色器的情況下獲得最佳性能

00:01:18.278 --> 00:01:21.782
<c.green>今天早上 你們瞭解了曲面細分、

00:01:21.849 --> 00:01:24.952
<c.green>資源堆、無記憶渲染目標

00:01:25.018 --> 00:01:27.855
<c.green>以及一些GPU工具的改善

00:01:29.556 --> 00:01:32.926
<c.green>今天下午 我們將討論專用函數、

00:01:32.993 --> 00:01:38.098
<c.green>資源讀寫函數、廣顏色範圍、
<c.green>紋理資源

00:01:38.432 --> 00:01:41.935
<c.green>以及Metal性能着色器的
<c.green>一些新增功能

00:01:44.004 --> 00:01:46.540
<c.green>好了 我們先講一下專用函數

00:01:48.775 --> 00:01:51.578
<c.green>它是渲染引擎中的一種常見模式

00:01:52.246 --> 00:01:55.682
<c.green>用於定義一些複雜的主要函數

00:01:55.749 --> 00:01:57.751
<c.green>並用這些主要函數

00:01:57.818 --> 00:02:00.687
<c.green>生成最少的專用簡單函數

00:02:01.688 --> 00:02:07.961
<c.green>理念是主要函數可以防止複製卡

00:02:08.027 --> 00:02:14.101
<c.green>而專用函數由於性能的提高
<c.green>變得更簡單

00:02:15.702 --> 00:02:17.137
<c.green>讓我們看一個例子

00:02:17.204 --> 00:02:19.973
<c.green>假如我們正在寫一個材料函數

00:02:20.040 --> 00:02:22.409
<c.green>你要寫一個主要函數

00:02:22.476 --> 00:02:26.380
<c.green>來執行你可能要用到的
<c.green>所有材料的各個方面

00:02:27.447 --> 00:02:32.152
<c.green>但是 假如你正在實施一種
<c.green>亮晶晶的材料

00:02:32.586 --> 00:02:36.523
<c.green>很可能就不需要反射了
<c.green>但你一定需要鏡面高光

00:02:37.824 --> 00:02:40.561
<c.green>假如你在另一方面實施了
<c.green>一種反射材料

00:02:40.627 --> 00:02:44.865
<c.green>你就要給鏡面高光材料也添加反射

00:02:45.532 --> 00:02:48.735
<c.green>過度材料需要次表面散射

00:02:48.802 --> 00:02:52.139
<c.green>但很可能不需要反射
<c.green>也不需要鏡面高光

00:02:52.706 --> 00:02:54.808
<c.green>諸如此類 你們瞭解的

00:02:56.410 --> 00:02:59.780
<c.green>因此
<c.green>一般都是通過預處理宏來實施

00:03:01.481 --> 00:03:05.452
<c.green>主要函數由一組值進行編譯

00:03:05.519 --> 00:03:07.855
<c.green>使宏創建專用函數

00:03:08.188 --> 00:03:12.426
<c.green>這可以在運行時實現
<c.green>但費用很高

00:03:12.793 --> 00:03:14.428
<c.green>你還可以試試預編譯

00:03:14.494 --> 00:03:17.631
<c.green>預編譯函數的每一個變體

00:03:18.365 --> 00:03:20.267
<c.green>並把它們存儲在Metal中

00:03:20.334 --> 00:03:22.236
<c.green>但這需要大量的存儲空間

00:03:22.302 --> 00:03:24.171
<c.green>因爲可能會有很多變體

00:03:24.238 --> 00:03:26.240
<c.green>或者也許你不知道你需要哪個變體

00:03:27.608 --> 00:03:30.477
<c.green>另一種方法是使用動態常量

00:03:31.612 --> 00:03:34.748
<c.green>動態常量會防止重新編譯函數

00:03:34.815 --> 00:03:36.049
<c.green>然而

00:03:36.116 --> 00:03:39.253
<c.green>你需要在運行時評估常量的值

00:03:40.420 --> 00:03:43.524
<c.green>那會影響着色器的性能

00:03:45.158 --> 00:03:48.395
<c.green>所以 我們提出了一種創建
<c.green>專用函數的新方法

00:03:48.795 --> 00:03:50.831
<c.green>就是用一個叫函數常量的東西

00:03:51.365 --> 00:03:52.833
<c.green>函數常量是一種在Metal着色語言中

00:03:52.900 --> 00:03:57.504
<c.green>直接定義的常量

00:03:58.071 --> 00:04:01.141
<c.green>可編譯到IR並存儲在Metal庫中

00:04:01.875 --> 00:04:05.746
<c.green>運行時可提供常量的值

00:04:05.812 --> 00:04:07.881
<c.green>創建一個專用函數

00:04:09.416 --> 00:04:11.251
<c.green>這種方法的優點是

00:04:11.318 --> 00:04:13.687
<c.green>可以離線編譯主要函數

00:04:13.754 --> 00:04:15.189
<c.green>並把它存在Metal庫中

00:04:15.722 --> 00:04:17.089
<c.green>只需要很少的存儲空間

00:04:17.156 --> 00:04:19.392
<c.green>因爲你只需要存儲主要函數

00:04:19.993 --> 00:04:24.965
<c.green>因爲我們在創建專用函數時
<c.green>運行了快速優化遍數

00:04:25.365 --> 00:04:27.267
<c.green>你仍然能得到最佳性能

00:04:29.603 --> 00:04:31.004
<c.green>讓我們來看個例子

00:04:31.638 --> 00:04:35.776
<c.green>這是個用了預處理宏的主要函數

00:04:36.076 --> 00:04:38.645
<c.green>當然 這個例子很簡單

00:04:38.846 --> 00:04:40.647
<c.green>實際上主函數會更加複雜

00:04:41.181 --> 00:04:43.650
<c.green>正如你所看到的 代碼的不同部分

00:04:43.717 --> 00:04:47.120
<c.green>都被what if語句包圍着

00:04:47.554 --> 00:04:50.257
<c.green>所以你可以消除代碼的那個部分

00:04:51.692 --> 00:04:54.394
<c.green>這是帶函數常量的代碼

00:04:54.728 --> 00:04:58.432
<c.green>你可以看到 我們正在頂部
<c.green>定義一些常量

00:04:58.498 --> 00:05:00.000
<c.green>我們將在代碼中使用這些常量

00:05:00.601 --> 00:05:03.303
<c.green>要定義常量 就要用到常量關鍵字

00:05:03.804 --> 00:05:06.640
<c.green>然後是類型
<c.green>在這個例子中是布爾型

00:05:07.174 --> 00:05:12.312
<c.green>最後是常量的名稱
<c.green>以及函數常量的屬性

00:05:13.247 --> 00:05:16.617
<c.green>函數常量屬性指定了常量的值

00:05:16.683 --> 00:05:19.052
<c.green>不會在編譯時提供

00:05:19.119 --> 00:05:22.623
<c.green>但會在運行中提供
<c.green>就是當我們創建專用函數的時候

00:05:23.323 --> 00:05:25.726
<c.green>你還應該注意到
<c.green>我們正在傳遞一個索引

00:05:26.093 --> 00:05:28.795
<c.green>當我們在運行中創建專用函數時

00:05:28.862 --> 00:05:30.264
<c.green>除名稱之外 索引也可以

00:05:30.330 --> 00:05:33.367
<c.green>識別常量

00:05:34.768 --> 00:05:37.504
<c.green>然後 你就可以在代碼中的
<c.green>任意地方使用這些常量了

00:05:37.571 --> 00:05:39.072
<c.green>就像使用普通常量一樣

00:05:39.339 --> 00:05:41.308
<c.green>這裏我們有一個簡單的if語句

00:05:41.375 --> 00:05:44.178
<c.green>用來限制部分代碼

00:05:45.846 --> 00:05:47.915
<c.green>一旦創建了主要函數

00:05:47.981 --> 00:05:50.250
<c.green>並把它編譯和存儲在Metal庫中

00:05:50.651 --> 00:05:53.554
<c.green>你需要在運行時創建專用函數

00:05:53.620 --> 00:05:56.657
<c.green>所以你需要提供常量值

00:05:57.391 --> 00:06:01.128
<c.green>要提供常量值
<c.green>我們就要用一個MTL函數常量值對象

00:06:01.195 --> 00:06:03.664
<c.green>來解決多常量的值的問題

00:06:04.031 --> 00:06:05.465
<c.green>一旦建好了對象

00:06:05.999 --> 00:06:10.604
<c.green>就可以按名稱、按索引或按名稱

00:06:11.371 --> 00:06:13.140
<c.green>來設置常量的值

00:06:15.809 --> 00:06:17.578
<c.green>一旦創建了對象

00:06:17.644 --> 00:06:20.214
<c.green>我們就能用庫中的名稱和常量

00:06:20.280 --> 00:06:23.016
<c.green>創建專用函數

00:06:23.083 --> 00:06:25.886
<c.green>簡單地編碼新函數

00:06:26.320 --> 00:06:32.626
<c.green>提供主要函數的名稱
<c.green>以及我們剛填好的值

00:06:33.293 --> 00:06:37.764
<c.green>這將返回一個常規的MTL函數
<c.green>可以用於創建

00:06:38.098 --> 00:06:42.002
<c.green>計算管道或渲染管道
<c.green>取決於函數類型

00:06:43.871 --> 00:06:47.941
<c.green>爲了讓你們更好地理解
<c.green>讓我們看一下編譯管道

00:06:49.042 --> 00:06:50.277
<c.green>在構建時

00:06:50.577 --> 00:06:55.782
<c.green>用了主要函數源代碼
<c.green>編譯並存儲到Metal庫中

00:06:56.483 --> 00:07:02.856
<c.green>在運行時 加載了Metal庫
<c.green>創建了一個新函數

00:07:02.923 --> 00:07:08.428
<c.green>並用MTL函數常量值
<c.green>使函數特化

00:07:09.596 --> 00:07:11.465
<c.green>此時此刻 我們要運行一些優化

00:07:11.532 --> 00:07:13.800
<c.green>來剔除不再使用的代碼

00:07:14.368 --> 00:07:17.204
<c.green>然後有一個內函數 可以用來

00:07:17.571 --> 00:07:21.408
<c.green>創建一個渲染管道或計算管道

00:07:24.144 --> 00:07:29.349
<c.green>你可以聲明Metal所支持的任何
<c.green>標量或矢量類型的常量

00:07:29.416 --> 00:07:32.219
<c.green>其中有float、half、
<c.green>int、uint等等

00:07:32.786 --> 00:07:35.622
<c.green>在這裏 我們定義half4顏色

00:07:37.024 --> 00:07:43.030
<c.green>你還可以用函數常量的值
<c.green>創建中間常量

00:07:43.330 --> 00:07:45.732
<c.green>在這裏我們定義一個布爾常量

00:07:45.799 --> 00:07:48.569
<c.green>跟函數常量a的值相反

00:07:49.403 --> 00:07:50.737
<c.green>這裏我們正在計算一個值

00:07:50.804 --> 00:07:53.574
<c.green>是基於值函數常量的值

00:07:55.976 --> 00:07:58.478
<c.green>我們還有可選常量

00:07:58.912 --> 00:08:01.481
<c.green>可選常量是不需要在特化函數時

00:08:01.548 --> 00:08:04.585
<c.green>一直提供值的常量

00:08:04.785 --> 00:08:08.155
<c.green>這跟在代碼中
<c.green>ifdef的作用完全一樣

00:08:08.222 --> 00:08:09.790
<c.green>當使用預處理宏時

00:08:10.791 --> 00:08:14.194
<c.green>要實現此功能
<c.green>就要用if函數內建的常量

00:08:14.261 --> 00:08:17.297
<c.green>如果已提供了值 它將返回真

00:08:17.431 --> 00:08:18.699
<c.green>反之則返回假

00:08:22.269 --> 00:08:27.207
<c.green>你還可以用函數常量向函數中
<c.green>添加或從函數中移除參數

00:08:27.908 --> 00:08:34.014
<c.green>這有利於確定不需要綁定的
<c.green>緩衝區或紋理

00:08:34.081 --> 00:08:35.849
<c.green>如果你已經知道不會用到它的話

00:08:36.283 --> 00:08:39.886
<c.green>還有利於替換參數類型

00:08:40.320 --> 00:08:43.857
<c.green>稍後再詳細介紹

00:08:44.825 --> 00:08:46.326
<c.green>這裏有個例子

00:08:47.461 --> 00:08:50.664
<c.green>這是一個頂點函數 可以執行

00:08:50.864 --> 00:08:54.268
<c.green>剝皮
<c.green>取決於doSkinning常量的值

00:08:56.236 --> 00:09:02.342
<c.green>函數的第一個參數是矩陣緩衝區
<c.green>是否存在

00:09:02.409 --> 00:09:06.380
<c.green>取決於doSkinning常量真假

00:09:06.713 --> 00:09:11.718
<c.green>我們用函數常量參數限制
<c.green>那個參數爲可選參數

00:09:12.786 --> 00:09:17.157
<c.green>在代碼中
<c.green>仍然需要使用相同的函數常量

00:09:17.224 --> 00:09:19.660
<c.green>來保護在參數中使用的代碼

00:09:20.227 --> 00:09:23.230
<c.green>那麼我們在if語句中
<c.green>用了doSkinning

00:09:23.664 --> 00:09:29.136
<c.green>然後就能在代碼中
<c.green>安全地使用矩陣了

00:09:31.004 --> 00:09:33.106
<c.green>你也可以用函數常量

00:09:33.173 --> 00:09:35.943
<c.green>從階段結構中移除參數

00:09:37.077 --> 00:09:39.213
<c.green>在這裏 我們有兩個顏色參數

00:09:39.413 --> 00:09:45.452
<c.green>float4型的第一個顏色參數
<c.green>作爲一個屬性

00:09:45.519 --> 00:09:46.920
<c.green>這是屬性1

00:09:48.121 --> 00:09:50.657
<c.green>第二個是精確度低的顏色

00:09:50.991 --> 00:09:54.127
<c.green>是一種精度不高的顏色half4

00:09:55.362 --> 00:09:57.965
<c.green>但覆蓋了同樣的屬性索引

00:09:58.966 --> 00:10:01.568
<c.green>你可以任選其一

00:10:01.635 --> 00:10:06.306
<c.green>這些專用於在代碼中

00:10:06.373 --> 00:10:07.207
<c.green>變更顏色屬性的類型

00:10:08.976 --> 00:10:11.445
<c.green>函數常量有一些限制

00:10:11.512 --> 00:10:15.849
<c.green>比如 不能在內存中真正
<c.green>變更結構的佈局

00:10:16.783 --> 00:10:19.152
<c.green>這可能成爲一個問題
<c.green>因爲你可能想用

00:10:19.219 --> 00:10:22.723
<c.green>不同的常量定義
<c.green>不同的着色器等等

00:10:23.891 --> 00:10:25.425
<c.green>但你可以迂迴解決

00:10:25.492 --> 00:10:28.462
<c.green>可以添加不同類型的多個參數

00:10:28.996 --> 00:10:31.765
<c.green>那麼在這個例子中
<c.green>我們有兩個緩衝參數

00:10:32.499 --> 00:10:34.501
<c.green>都使用緩衝索引1

00:10:35.235 --> 00:10:38.872
<c.green>它們受函數常量的約束
<c.green>使用常量A和常量B

00:10:41.508 --> 00:10:44.278
<c.green>一般選擇其中一個

00:10:44.378 --> 00:10:46.713
<c.green>請注意 我們...

00:10:48.515 --> 00:10:52.753
<c.green>我們用了一箇中間常量
<c.green>與第一個常量相反

00:10:52.819 --> 00:10:56.356
<c.green>確保在給定時間內
<c.green>只存在一個參數

00:10:56.523 --> 00:10:57.824
<c.green>總的來說

00:10:57.891 --> 00:11:02.663
<c.green>你可在運行時用函數常量創建專用函數

00:11:03.197 --> 00:11:05.299
<c.green>無需前臺編譯

00:11:05.365 --> 00:11:07.501
<c.green>因爲我們只是使用...

00:11:07.568 --> 00:11:11.071
<c.green>並且只用快速優化相來移除
<c.green>不再使用的代碼

00:11:11.538 --> 00:11:13.073
<c.green>存儲量很小

00:11:13.140 --> 00:11:16.543
<c.green>因爲你只需要在庫中
<c.green>存儲主要函數

00:11:17.277 --> 00:11:20.280
<c.green>你不必發行源代碼
<c.green>可以只發行IR

00:11:20.714 --> 00:11:23.217
<c.green>最後 移除不再使用的代碼

00:11:23.283 --> 00:11:25.152
<c.green>會提供最佳性能

00:11:27.888 --> 00:11:30.991
<c.green>現在
<c.green>讓我們談一談資源讀寫函數

00:11:32.960 --> 00:11:35.229
<c.green>我們要介紹兩個新特性

00:11:35.696 --> 00:11:39.499
<c.green>緩衝區讀寫函數和紋理讀寫函數

00:11:40.734 --> 00:11:45.038
<c.green>緩衝區讀寫函數是從任何函數類型中

00:11:45.539 --> 00:11:47.207
<c.green>讀入和寫入緩衝區

00:11:47.908 --> 00:11:51.478
<c.green>以及從任何函數類型中

00:11:51.545 --> 00:11:52.713
<c.green>在緩衝區上使用原子操作

00:11:53.347 --> 00:11:55.449
<c.green>你可能猜想紋理讀寫函數

00:11:55.516 --> 00:11:58.919
<c.green>是從任何函數類型中
<c.green>讀入和寫入紋理

00:12:01.788 --> 00:12:03.323
<c.green>緩衝區讀寫函數

00:12:03.891 --> 00:12:09.496
<c.green>在配有A9處理器的iOS
<c.green>和macOS上都可用

00:12:10.163 --> 00:12:13.901
<c.green>紋理讀寫函數在macOS上可用

00:12:15.502 --> 00:12:18.071
<c.green>現在讓我們講一下
<c.green>緩衝區讀寫函數

00:12:18.172 --> 00:12:19.473
<c.green>有哪些新特性呢？

00:12:19.540 --> 00:12:23.310
<c.green>新特性就是能從分段函數
<c.green>向緩衝區寫入

00:12:23.710 --> 00:12:27.481
<c.green>以及在文本和分段函數中
<c.green>使用原子操作

00:12:28.148 --> 00:12:33.020
<c.green>這些可用於執行像順序無關透明、

00:12:34.021 --> 00:12:37.591
<c.green>創建影響指定瓷磚燈光的列表

00:12:37.958 --> 00:12:39.893
<c.green>或只是調試着色器這樣的事上

00:12:41.662 --> 00:12:43.864
<c.green>讓我們看一個簡單的例子

00:12:43.931 --> 00:12:49.636
<c.green>比如說 我們想寫出正在渲染的
<c.green>可見片段的位置

00:12:50.537 --> 00:12:51.705
<c.green>應該是這樣的

00:12:52.406 --> 00:12:56.343
<c.green>有一個分段函數
<c.green>我們向它傳遞了一個輸出緩衝區

00:12:56.410 --> 00:13:00.214
<c.green>輸出緩衝區就是我們要儲存
<c.green>片段位置的地方

00:13:02.516 --> 00:13:04.585
<c.green>然後有個計數器

00:13:04.651 --> 00:13:07.354
<c.green>這是另一個緩衝區
<c.green>我們開始插入原子

00:13:07.421 --> 00:13:12.359
<c.green>找到位置並放入第一個緩衝區

00:13:12.593 --> 00:13:14.194
<c.green>就是我們要寫入的緩衝區

00:13:15.529 --> 00:13:17.731
<c.green>然後 我們可以用原子預製

00:13:17.798 --> 00:13:20.667
<c.green>計算已經寫入的片段數量

00:13:20.734 --> 00:13:22.402
<c.green>並在緩衝區生成一個索引

00:13:22.836 --> 00:13:26.607
<c.green>然後把片段的位置寫入緩衝區

00:13:27.241 --> 00:13:29.176
<c.green>看起來還不錯 但是...

00:13:29.843 --> 00:13:31.011
<c.green>有個小問題

00:13:33.247 --> 00:13:37.050
<c.green>當寫入緩衝區時
<c.green>深度測試和模板測試

00:13:37.117 --> 00:13:40.120
<c.green>實際上總是在片段着色器之後進行

00:13:41.088 --> 00:13:42.723
<c.green>這是個問題

00:13:42.789 --> 00:13:46.326
<c.green>因爲我們仍然會給緩衝區
<c.green>分配權限

00:13:46.393 --> 00:13:49.363
<c.green>這並不是我們想要的
<c.green>我們只想使片段可見

00:13:50.030 --> 00:13:54.334
<c.green>這也是需要注意的
<c.green>因爲它會影響你的性能

00:13:54.401 --> 00:13:57.437
<c.green>這意味着
<c.green>我們沒有做任何早期的Z優化

00:13:58.005 --> 00:14:01.775
<c.green>所以很可能會在不想展示
<c.green>片段着色器時展示它

00:14:03.277 --> 00:14:07.181
<c.green>幸運的是 我們有個新特性
<c.green>限定詞早期片段測試

00:14:07.915 --> 00:14:10.918
<c.green>用於強制在片段着色器之前執行

00:14:11.285 --> 00:14:13.220
<c.green>深度測試和模板測試

00:14:13.587 --> 00:14:16.456
<c.green>結果是 如果深度測試失敗

00:14:16.924 --> 00:14:19.526
<c.green>我們將跳過片段着色器的執行

00:14:20.327 --> 00:14:22.529
<c.green>因此不會寫入緩衝區

00:14:22.863 --> 00:14:24.398
<c.green>這正是我們所需要的

00:14:24.998 --> 00:14:26.633
<c.green>到達最後一個帶早期片段

00:14:27.034 --> 00:14:29.136
<c.green>測試屬性的函數

00:14:29.570 --> 00:14:32.339
<c.green>否則只當片段可見時

00:14:33.073 --> 00:14:35.042
<c.green>執行函數

00:14:37.211 --> 00:14:40.147
<c.green>現在讓我們談談紋理讀寫函數

00:14:40.614 --> 00:14:44.418
<c.green>新特性是可以從定點函數

00:14:44.484 --> 00:14:46.587
<c.green>和分段函數中創建紋理

00:14:47.154 --> 00:14:52.626
<c.green>以及從單一函數讀入
<c.green>和寫入紋理

00:14:53.293 --> 00:14:54.761
<c.green>可以用於 比如說

00:14:54.828 --> 00:14:57.931
<c.green>在執行後置處理效果時
<c.green>節約內存

00:14:58.298 --> 00:15:01.168
<c.green>通過在輸入和輸出中
<c.green>使用同一種紋理

00:15:04.071 --> 00:15:06.073
<c.green>寫入紋理是非常簡單的

00:15:06.406 --> 00:15:10.344
<c.green>你只需要把紋理定義爲
<c.green>訪問限制符寫入

00:15:10.410 --> 00:15:12.880
<c.green>就可以寫入紋理了

00:15:16.016 --> 00:15:17.217
<c.green>讀寫紋理

00:15:17.284 --> 00:15:21.755
<c.green>是一種能在着色器中
<c.green>讀和寫的紋理

00:15:22.289 --> 00:15:25.526
<c.green>只支持數量有限的幾個格式

00:15:26.260 --> 00:15:27.861
<c.green>要使用讀寫紋理

00:15:28.128 --> 00:15:30.831
<c.green>就要使用讀寫的訪問限制符

00:15:31.698 --> 00:15:36.603
<c.green>然後你就可以在着色器中
<c.green>讀入並寫入紋理了

00:15:38.672 --> 00:15:41.608
<c.green>然而 寫入紋理時得注意一下

00:15:41.675 --> 00:15:47.714
<c.green>如果你想在着色器中再次
<c.green>讀到相同的像素

00:15:48.515 --> 00:15:51.185
<c.green>在這個例子中
<c.green>你需要使用紋理柵欄

00:15:51.518 --> 00:15:55.989
<c.green>紋理柵欄會確保把寫入
<c.green>交付給內存

00:15:56.056 --> 00:15:58.225
<c.green>這樣就能讀取正確的值

00:15:59.726 --> 00:16:03.463
<c.green>在這裏 我們寫入一個給定的像素

00:16:04.064 --> 00:16:09.002
<c.green>然後 我們使用紋理柵欄
<c.green>確保可以再次讀取那個值

00:16:09.636 --> 00:16:11.672
<c.green>再然後 我們最終讀到了值

00:16:12.739 --> 00:16:14.875
<c.green>我們也應該注意紋理柵欄

00:16:14.942 --> 00:16:17.778
<c.green>因爲它們只能在
<c.green>單一SIMD線程上應用

00:16:18.712 --> 00:16:22.049
<c.green>意思就是
<c.green>如果有兩個正在寫入紋理的線程

00:16:23.050 --> 00:16:24.651
<c.green>並且第二個線程

00:16:24.718 --> 00:16:28.422
<c.green>正在讀取由第一個線程寫入的值

00:16:29.590 --> 00:16:32.793
<c.green>就算在紋理柵欄之後讀取
<c.green>也不能讀到

00:16:34.528 --> 00:16:36.563
<c.green>能讀到的情況是每個線程

00:16:36.630 --> 00:16:40.067
<c.green>讀取被各自寫入的像素值

00:16:40.133 --> 00:16:42.736
<c.green>而不能讀取由其他線程寫入的值

00:16:44.538 --> 00:16:45.939
<c.green>這是關於讀取的一個小貼士

00:16:46.006 --> 00:16:48.876
<c.green>我們談了很多寫入緩衝區和紋理

00:16:49.443 --> 00:16:52.980
<c.green>你應該注意頂點函數和分段函數

00:16:53.914 --> 00:16:57.918
<c.green>在這個例子中
<c.green>分段函數正寫入一個緩衝區

00:16:58.318 --> 00:17:01.088
<c.green>而頂點函數正讀取結果

00:17:01.488 --> 00:17:05.092
<c.green>但是這並不能成功
<c.green>因爲它們的RenderCommandEncoder相同

00:17:05.925 --> 00:17:10.364
<c.green>要解決這個問題
<c.green>需要使用兩個RenderCommandEncoder

00:17:11.365 --> 00:17:15.234
<c.green>分段函數寫入第一個
<c.green>RenderCommandEncoder中的緩衝區

00:17:15.402 --> 00:17:18.372
<c.green>而頂點函數寫入第二個
<c.green>RenderCommandEncoder中的緩衝區

00:17:18.438 --> 00:17:21.008
<c.green>最終讀取並獲得正確的結果

00:17:21.508 --> 00:17:26.547
<c.green>要注意的是
<c.green>沒有必要使用計算着色器

00:17:26.613 --> 00:17:29.149
<c.green>可以在同一個計算
<c.green>CommandEncoder中實現

00:17:30.484 --> 00:17:32.920
<c.green>總之 我們引入了兩個新函數

00:17:33.287 --> 00:17:36.823
<c.green>緩衝區讀寫函數和紋理讀寫函數

00:17:37.224 --> 00:17:39.326
<c.green>可以用早期片段測試

00:17:39.626 --> 00:17:42.362
<c.green>來確保在執行片段着色器之前

00:17:42.930 --> 00:17:45.232
<c.green>完成深度測試和模具測試

00:17:45.766 --> 00:17:49.102
<c.green>要從一直在寫入的讀寫紋理中讀取數據

00:17:49.169 --> 00:17:52.673
<c.green>應該使用紋理柵欄

00:17:53.340 --> 00:17:57.177
<c.green>最後 用頂點着色器和片段着色器
<c.green>寫入緩衝區時

00:17:57.711 --> 00:18:00.314
<c.green>就要使用不同的
<c.green>RenderCommandEncoder

00:18:00.380 --> 00:18:02.015
<c.green>要讀取結果

00:18:04.218 --> 00:18:07.888
<c.green>接下來
<c.green>我要把舞臺交給Dan Omachi

00:18:07.955 --> 00:18:09.790
<c.green>他會跟大家談一談廣顏色範圍

00:18:13.760 --> 00:18:14.895
<c.green>謝謝Charles

00:18:15.596 --> 00:18:17.598
<c.green>Charles說過了
<c.green>我叫Dan Omachi

00:18:17.664 --> 00:18:20.567
<c.green>我是Apple GPU軟件架構團隊
<c.green>的一名工程師

00:18:21.368 --> 00:18:24.471
<c.green>我想先從色彩管理談起

00:18:24.738 --> 00:18:29.877
<c.green>實際上 這並不是一個
<c.green>所有開發人員都熟悉的話題

00:18:32.145 --> 00:18:35.582
<c.green>如果你是個美工

00:18:35.649 --> 00:18:40.053
<c.green>無論是爲遊戲創建資源的紋理美工

00:18:40.320 --> 00:18:43.390
<c.green>還是編輯照片的攝影師

00:18:44.057 --> 00:18:46.093
<c.green>你心裏都會有一個特殊的色系

00:18:46.159 --> 00:18:49.496
<c.green>你會很認真地挑選顏色

00:18:50.264 --> 00:18:52.666
<c.green>並且要保持一致性

00:18:53.300 --> 00:18:57.604
<c.green>無論內容會在哪種
<c.green>顯示屏上顯示

00:18:58.505 --> 00:19:01.842
<c.green>作爲開發者和軟件工程師
<c.green>我們有責任

00:19:01.909 --> 00:19:04.178
<c.green>保證這種一致性

00:19:05.412 --> 00:19:07.648
<c.green>如果你正用一種高層框架

00:19:07.714 --> 00:19:11.285
<c.green>比如SceneKit、
<c.green>SpriteKit或核心圖像

00:19:11.718 --> 00:19:13.420
<c.green>那麼大部分工作已經完成了

00:19:13.487 --> 00:19:16.590
<c.green>應用開發人員不需要
<c.green>再考慮一致性的問題了

00:19:17.858 --> 00:19:21.128
<c.green>然而
<c.green>Metal是一個層級低得多的API

00:19:22.729 --> 00:19:26.266
<c.green>這就會提供強化的性能和一些靈活性

00:19:26.633 --> 00:19:30.270
<c.green>但也會把其中一些責任轉到你身上

00:19:31.972 --> 00:19:32.806
<c.green>爲什麼呢？

00:19:33.740 --> 00:19:37.911
<c.green>很多年前 你就已經能用
<c.green>Apple設備上的

00:19:38.378 --> 00:19:40.480
<c.green>不同色彩空間的不同顯示屏了

00:19:41.715 --> 00:19:46.520
<c.green>嗯 去年年底
<c.green>Apple引入了幾臺iMacs

00:19:46.587 --> 00:19:52.326
<c.green>它的顯示屏能在
<c.green>P3色彩空間渲染顏色

00:19:52.759 --> 00:19:57.965
<c.green>今年四月我們引入了
<c.green>9.7英寸的iPad Pro

00:19:58.332 --> 00:20:01.034
<c.green>也有一個P3顯示屏

00:20:01.869 --> 00:20:04.037
<c.green>那麼 什麼是P3色彩空間呢？

00:20:04.104 --> 00:20:06.340
<c.green>嗯 這是一個色度圖

00:20:06.406 --> 00:20:11.545
<c.green>從概念上講
<c.green>這個圖呈現了可見光譜中的所有顏色

00:20:12.112 --> 00:20:15.716
<c.green>換句話說
<c.green>就是普通人肉眼可見的所有顏色

00:20:17.584 --> 00:20:19.820
<c.green>雖然如此 這個三角形內的色彩

00:20:20.087 --> 00:20:25.225
<c.green>是一個標準的sRGB顯示屏
<c.green>所能呈現的色彩

00:20:27.361 --> 00:20:31.765
<c.green>P3顯示屏可以呈現

00:20:31.832 --> 00:20:35.135
<c.green>色度更寬的色彩

00:20:37.171 --> 00:20:39.373
<c.green>這是它在macOS上的應用

00:20:41.108 --> 00:20:44.311
<c.green>我們希望你能在任何
<c.green>色彩空間進行渲染

00:20:45.612 --> 00:20:49.249
<c.green>而且我也提到了
<c.green>高層框架會處理這個

00:20:49.716 --> 00:20:52.252
<c.green>色彩管理的問題

00:20:52.319 --> 00:20:54.922
<c.green>通過執行一種
<c.green>叫做顏色匹配的運算實現

00:20:54.988 --> 00:20:56.990
<c.green>顏色和色彩空間

00:20:57.057 --> 00:21:00.194
<c.green>與顯示屏的色彩空間相匹配

00:21:00.260 --> 00:21:02.829
<c.green>這樣就能在顯示屏上
<c.green>得到相同的亮度

00:21:02.896 --> 00:21:05.399
<c.green>不管你正在處理的色彩空間

00:21:05.599 --> 00:21:06.800
<c.green>是否顯示

00:21:08.202 --> 00:21:13.640
<c.green>Metal視圖默認沒有色彩管理

00:21:14.441 --> 00:21:16.410
<c.green>跳過了這個顏色匹配運算

00:21:17.444 --> 00:21:19.947
<c.green>這一般會強化性能

00:21:21.849 --> 00:21:23.784
<c.green>因此 默認情況是

00:21:24.017 --> 00:21:26.887
<c.green>忽略顯示屏的顏色配置文件

00:21:27.888 --> 00:21:31.458
<c.green>因此 顯示屏會在自己的色彩空間

00:21:32.025 --> 00:21:33.560
<c.green>解釋顏色

00:21:34.862 --> 00:21:37.231
<c.green>意思就是 sRGB顏色

00:21:37.531 --> 00:21:39.600
<c.green>會被解釋爲P3顏色

00:21:39.900 --> 00:21:42.336
<c.green>而兩者之間的渲染將會不一致

00:21:42.402 --> 00:21:46.507
<c.green>如果這是你的應用 帶sRGB繪製

00:21:47.508 --> 00:21:49.676
<c.green>這是顯示屏

00:21:50.644 --> 00:21:56.416
<c.green>嗯 當調用當前的繪製時
<c.green>這些顏色會變得更飽和

00:21:56.950 --> 00:21:58.118
<c.green>爲什麼會這樣呢？

00:21:58.485 --> 00:22:00.587
<c.green>讓我們再回去看色度圖

00:22:02.789 --> 00:22:05.225
<c.green>這是你能在sRGB色彩空間中

00:22:05.292 --> 00:22:08.529
<c.green>呈現的最綠的顏色

00:22:09.062 --> 00:22:11.398
<c.green>在片段着色器中

00:22:12.065 --> 00:22:15.769
<c.green>應該呈現爲紅色通道爲0.0

00:22:15.836 --> 00:22:20.107
<c.green>綠色通道爲1.0
<c.green>而藍色通道爲0.0

00:22:20.841 --> 00:22:24.845
<c.green>嗯 P3顯示屏只取原始值

00:22:25.078 --> 00:22:26.079
<c.green>並做出解釋

00:22:26.580 --> 00:22:29.783
<c.green>從根本上說
<c.green>它認爲那是一個P3顏色

00:22:30.217 --> 00:22:34.955
<c.green>所以你得到的是一個
<c.green>最綠的P3顯示顏色

00:22:35.022 --> 00:22:37.457
<c.green>對於內容創作應用來說

00:22:38.292 --> 00:22:42.329
<c.green>碰巧是一個不同的綠色

00:22:42.596 --> 00:22:44.431
<c.green>把這個搞清楚相當重要

00:22:44.498 --> 00:22:49.203
<c.green>因爲美工們經過深思熟慮

00:22:49.436 --> 00:22:51.338
<c.green>來渲染色彩

00:22:52.472 --> 00:22:56.410
<c.green>對於遊戲來說 效果更微妙

00:22:58.412 --> 00:23:02.783
<c.green>但如果設計師和美工

00:23:02.850 --> 00:23:06.086
<c.green>正在尋找這種黑暗的主題

00:23:06.486 --> 00:23:11.158
<c.green>他們一定會非常失望
<c.green>因爲 看起來要愉快得多

00:23:11.225 --> 00:23:12.726
<c.green>當你在P3顯示屏中插入它時

00:23:13.727 --> 00:23:16.663
<c.green>同時 這個問題可能會更糟糕

00:23:16.897 --> 00:23:21.235
<c.green>因爲產業正在朝更寬的
<c.green>色域顯示屏前進

00:23:24.304 --> 00:23:28.008
<c.green>解決方案真的很簡單

00:23:28.842 --> 00:23:33.647
<c.green>在NSWindow或CAMetal上
<c.green>啓動色彩管理

00:23:33.714 --> 00:23:36.650
<c.green>把色彩空間設置爲
<c.green>你正在使用的色彩空間

00:23:36.717 --> 00:23:38.819
<c.green>很可能是sRGB色彩空間

00:23:39.353 --> 00:23:42.723
<c.green>這會使OS執行顏色匹配

00:23:42.789 --> 00:23:46.527
<c.green>作爲它的窗口服務器的
<c.green>常規影像合成傳輸的一部分

00:23:46.593 --> 00:23:49.997
<c.green>那麼 如果這是你的顯示屏

00:23:50.364 --> 00:23:53.300
<c.green>抱歉 這是帶sRGB繪製的應用

00:23:53.634 --> 00:23:54.868
<c.green>這是顯示屏

00:23:56.436 --> 00:23:59.740
<c.green>當你調用當前繪製時
<c.green>窗口服務器會取走你的繪製

00:24:00.774 --> 00:24:04.578
<c.green>並在把它拍到玻璃上之前
<c.green>執行顏色匹配

00:24:06.980 --> 00:24:09.616
<c.green>好了 那麼現在
<c.green>你已經獲得了一致性

00:24:09.683 --> 00:24:12.386
<c.green>如果你想採用範圍更廣的顏色
<c.green>會怎麼樣呢？

00:24:12.986 --> 00:24:18.358
<c.green>你想有目的地渲染
<c.green>那些更強烈的色彩

00:24:18.425 --> 00:24:21.195
<c.green>廣色域顯示屏只能渲染

00:24:21.995 --> 00:24:25.032
<c.green>嗯 首先 你需要創建一些內容

00:24:25.098 --> 00:24:27.768
<c.green>你需要讓美工
<c.green>創建範圍更廣的內容

00:24:28.769 --> 00:24:31.805
<c.green>爲此 我們建議使用

00:24:31.872 --> 00:24:36.210
<c.green>擴展範圍的sRGB色彩空間

00:24:37.411 --> 00:24:41.882
<c.green>這就允許不能在範圍更廣的
<c.green>顏色中使用的現有資源

00:24:41.949 --> 00:24:44.551
<c.green>能繼續正常使用

00:24:44.618 --> 00:24:48.021
<c.green>而着色器管道
<c.green>不必執行任何額外操作

00:24:49.122 --> 00:24:51.358
<c.green>然而 美工可以創建

00:24:51.425 --> 00:24:54.161
<c.green>新的範圍更寬的色彩資源

00:24:54.261 --> 00:24:56.730
<c.green>可提供更強的色彩

00:24:59.633 --> 00:25:03.303
<c.green>那麼
<c.green>到底什麼是擴展範圍sRGB呢？

00:25:03.370 --> 00:25:07.808
<c.green>嗯 這是sRGB三角
<c.green>而這是P3三角

00:25:10.911 --> 00:25:12.212
<c.green>擴展範圍sRGB

00:25:12.279 --> 00:25:15.115
<c.green>會在各個方位超出無窮大

00:25:15.182 --> 00:25:20.621
<c.green>意思是在着色器中
<c.green>超出0到1的值

00:25:20.888 --> 00:25:24.124
<c.green>代表只能查看的值

00:25:24.391 --> 00:25:28.495
<c.green>在比sRGB色彩顯示屏
<c.green>更廣的色彩顯示屏上

00:25:30.430 --> 00:25:33.667
<c.green>我提到了超出0到1的值

00:25:34.334 --> 00:25:37.905
<c.green>意思就是
<c.green>你需要使用浮點像素格式

00:25:37.971 --> 00:25:39.806
<c.green>來表達這些值

00:25:40.774 --> 00:25:44.611
<c.green>對於紋理源 我們有一些格式建議

00:25:45.045 --> 00:25:48.315
<c.green>你可以使用BC6H浮點格式

00:25:48.415 --> 00:25:51.018
<c.green>這是一種
<c.green>提供高性能的壓縮格式

00:25:51.084 --> 00:25:54.555
<c.green>以及二進制浮點格式
<c.green>和分享指數格式

00:25:55.322 --> 00:25:59.293
<c.green>對於渲染目標
<c.green>可以使用二進制浮點格式

00:25:59.793 --> 00:26:03.697
<c.green>或RGBA半浮點格式

00:26:03.764 --> 00:26:07.267
<c.green>指定更強烈的顏色

00:26:09.269 --> 00:26:12.072
<c.green>iOS上的色彩管理比較簡單

00:26:12.873 --> 00:26:15.843
<c.green>你總是在sRGB色彩空間中
<c.green>進行渲染

00:26:17.377 --> 00:26:19.613
<c.green>即使目標是P3顯示屏也一樣

00:26:19.847 --> 00:26:23.016
<c.green>顏色是自動匹配的
<c.green>沒有性能損失

00:26:24.117 --> 00:26:26.320
<c.green>如果你想使用範圍更廣的顏色

00:26:26.820 --> 00:26:29.923
<c.green>你可以用一些原本就可以

00:26:31.024 --> 00:26:33.560
<c.green>被顯示屏讀取的新像素格式

00:26:34.027 --> 00:26:36.763
<c.green>並不需要任何影像合成運算

00:26:37.798 --> 00:26:40.534
<c.green>它們可以進行伽馬編碼
<c.green>提供效果更好的黑色

00:26:40.601 --> 00:26:43.737
<c.green>並允許你在着色器中
<c.green>進行線性混合

00:26:44.471 --> 00:26:47.808
<c.green>並且它們作爲紋理源
<c.green>是很有效率的

00:26:48.942 --> 00:26:52.145
<c.green>好了 這是新格式的位元佈局

00:26:52.212 --> 00:26:58.585
<c.green>有一個32位元的RGB格式
<c.green>每種通道10個位元

00:26:59.386 --> 00:27:01.722
<c.green>還有一個RGBA格式

00:27:01.788 --> 00:27:05.158
<c.green>每種通道10個位元
<c.green>擴展到了64個位元

00:27:05.826 --> 00:27:10.197
<c.green>現在 這個10位元的值是...

00:27:10.864 --> 00:27:13.267
<c.green>它們可以用
<c.green>超出0到1之間的值來表達

00:27:13.600 --> 00:27:18.172
<c.green>從0到384的值表示負值

00:27:18.438 --> 00:27:22.409
<c.green>往後的510個值 從384到894

00:27:22.476 --> 00:27:24.678
<c.green>代表0和1之間的值

00:27:24.745 --> 00:27:29.516
<c.green>而大於894的值代表
<c.green>這些更強烈的值

00:27:30.350 --> 00:27:34.788
<c.green>請注意 RGBA像素格式

00:27:35.322 --> 00:27:37.291
<c.green>比RGB格式大兩倍

00:27:37.357 --> 00:27:39.393
<c.green>因此也會佔用兩倍的內存

00:27:39.459 --> 00:27:43.964
<c.green>並佔用兩倍的帶寬

00:27:44.631 --> 00:27:47.067
<c.green>一般來說 我們建議

00:27:47.134 --> 00:27:50.704
<c.green>只在CAMetal層中使用

00:27:51.238 --> 00:27:53.507
<c.green>如果你需要不透明度的話

00:27:55.642 --> 00:28:00.314
<c.green>那麼你決定要創建一些
<c.green>廣色域的內容

00:28:02.649 --> 00:28:04.852
<c.green>該如何實現呢？
<c.green>嗯 你有一個美工

00:28:05.185 --> 00:28:11.725
<c.green>作者在macOS上使用
<c.green>支持P3色彩空間的圖片編輯器

00:28:12.059 --> 00:28:13.660
<c.green>比如Adobe Photoshop

00:28:15.162 --> 00:28:20.000
<c.green>你可使用顯示屏的P3色彩配置文件
<c.green>把圖片保存爲每個通道

00:28:20.067 --> 00:28:22.503
<c.green>16個位元的PNG或JPEG

00:28:24.705 --> 00:28:28.976
<c.green>得到這個圖片後
<c.green>要如何創建紋理呢？

00:28:29.676 --> 00:28:31.178
<c.green>有兩種解決方案

00:28:32.112 --> 00:28:35.516
<c.green>第一種是
<c.green>創建自己的資源調節工具

00:28:36.250 --> 00:28:41.054
<c.green>使用每個通道16位元的
<c.green>適應P3顯示模式的圖片實現

00:28:41.555 --> 00:28:42.890
<c.green>你可以通過使用ImageIO

00:28:42.956 --> 00:28:47.427
<c.green>或vImage框架的

00:28:47.995 --> 00:28:51.532
<c.green>擴展sRGB浮點色彩
<c.green>空間進行轉換

00:28:52.366 --> 00:28:55.435
<c.green>然後在macOS上 你可以轉換爲

00:28:55.502 --> 00:28:58.505
<c.green>我之前提到過的
<c.green>浮點像素格式中的一種

00:28:58.639 --> 00:29:00.140
<c.green>在iOS上 你可以轉換爲

00:29:00.207 --> 00:29:03.277
<c.green>我剛提到的那些
<c.green>擴展範圍像素格式中的一種

00:29:04.211 --> 00:29:05.712
<c.green>好了 這是方案一

00:29:06.113 --> 00:29:09.816
<c.green>明確紋理創建的控制

00:29:11.585 --> 00:29:17.024
<c.green>下一個方案是在資源目錄中
<c.green>給紋理使用Xcode支持

00:29:17.491 --> 00:29:19.526
<c.green>這樣會爲有P3顯示屏的設備

00:29:19.593 --> 00:29:24.398
<c.green>自動創建
<c.green>擴展範圍sRGB紋理

00:29:25.566 --> 00:29:29.169
<c.green>我還要說一下資源目錄

00:29:29.436 --> 00:29:32.105
<c.green>你暫時可以

00:29:33.040 --> 00:29:35.909
<c.green>把圖標和圖片

00:29:35.976 --> 00:29:39.413
<c.green>放到Xcode項目的資源目錄中

00:29:40.614 --> 00:29:43.417
<c.green>去年 我們引入了應用瘦身

00:29:43.884 --> 00:29:46.653
<c.green>藉此可以基於設備性能

00:29:46.720 --> 00:29:49.923
<c.green>爲不同的設備創建專用版本

00:29:49.990 --> 00:29:53.460
<c.green>比如內存量、圖形特徵集

00:29:54.094 --> 00:29:55.829
<c.green>或設備類型

00:29:55.896 --> 00:30:01.635
<c.green>無論是iPad、Mac或
<c.green>TV或watch...

00:30:02.002 --> 00:30:03.770
<c.green>當然還有手機

00:30:05.005 --> 00:30:08.075
<c.green>下載應用後

00:30:08.242 --> 00:30:09.643
<c.green>你只下載和安裝了

00:30:09.710 --> 00:30:13.180
<c.green>專爲該設備開發的單一版本

00:30:13.914 --> 00:30:15.849
<c.green>有指定的功能

00:30:16.950 --> 00:30:20.587
<c.green>在線路傳輸中和設備上
<c.green>壓縮了資產

00:30:20.654 --> 00:30:24.691
<c.green>節省了用戶設備上的存儲空間

00:30:25.292 --> 00:30:28.729
<c.green>並且有不計其數的API

00:30:28.795 --> 00:30:31.999
<c.green>可以快速獲取那些資源

00:30:32.599 --> 00:30:37.037
<c.green>現在 我們已經向紋理集中
<c.green>添加了這些資源目錄

00:30:37.604 --> 00:30:39.306
<c.green>這有什麼用呢？

00:30:39.373 --> 00:30:41.975
<c.green>嗯 處理mipmap層級的存儲

00:30:42.342 --> 00:30:45.812
<c.green>紋理不只是2D圖片

00:30:46.547 --> 00:30:50.751
<c.green>你可以在Xcode內部
<c.green>執行離線mipmap生成

00:30:51.952 --> 00:30:55.222
<c.green>這將自動爲這個紋理
<c.green>執行顏色匹配

00:30:55.289 --> 00:30:59.860
<c.green>因此 如果是不同的
<c.green>色彩空間的廣色域紋理

00:30:59.927 --> 00:31:03.163
<c.green>將在sRGB或

00:31:03.430 --> 00:31:07.267
<c.green>擴展範圍sRGB色彩空間
<c.green>執行色彩匹配運算

00:31:07.801 --> 00:31:12.906
<c.green>我認爲最重要的功能是

00:31:12.973 --> 00:31:16.977
<c.green>可以爲每種設備

00:31:17.044 --> 00:31:20.581
<c.green>選擇最理想的像素格式

00:31:20.647 --> 00:31:25.185
<c.green>那麼 在支持ASTC紋理壓縮的
<c.green>新設備上

00:31:25.686 --> 00:31:27.354
<c.green>我們可以使用那種格式

00:31:27.788 --> 00:31:30.023
<c.green>在不支持ASTC紋理壓縮的老設備上

00:31:30.090 --> 00:31:33.627
<c.green>我們可以選擇非壓縮格式

00:31:33.694 --> 00:31:35.629
<c.green>或其他壓縮格式

00:31:36.430 --> 00:31:39.233
<c.green>此外 我們可爲有P3顯示屏的設備

00:31:39.466 --> 00:31:42.035
<c.green>選擇範圍更廣的色彩格式

00:31:44.805 --> 00:31:46.273
<c.green>這就是基本流程

00:31:47.441 --> 00:31:51.245
<c.green>在Xcode內創建紋理集

00:31:51.512 --> 00:31:55.215
<c.green>給集合分配一個名稱
<c.green>作爲唯一標識符

00:31:56.149 --> 00:31:57.351
<c.green>添加一張圖片

00:31:57.417 --> 00:32:00.320
<c.green>並基本指出將如何使用紋理

00:32:00.387 --> 00:32:03.590
<c.green>無論是色彩紋理
<c.green>或是其他類型的數據

00:32:03.657 --> 00:32:06.126
<c.green>如普通地圖或高度圖

00:32:07.127 --> 00:32:11.765
<c.green>然後 創建紋理

00:32:11.832 --> 00:32:15.569
<c.green>Xcode會創建這個紋理
<c.green>並提交給應用

00:32:15.636 --> 00:32:18.238
<c.green>然後 你就可以通過Xcode UI或編程

00:32:18.472 --> 00:32:21.375
<c.green>創建紋理集了

00:32:23.610 --> 00:32:25.379
<c.green>一旦設備上有了紋理

00:32:25.679 --> 00:32:28.382
<c.green>你就可把名稱提供給MetalKit

00:32:28.582 --> 00:32:34.087
<c.green>MetalKit會創建一個紋理
<c.green>一個Metal紋理

00:32:35.822 --> 00:32:38.859
<c.green>我可以跟大家一起
<c.green>逐步執行這個Xcode流程

00:32:38.926 --> 00:32:41.495
<c.green>並向你們介紹一下這些概念

00:32:43.030 --> 00:32:43.864
<c.green>那麼...

00:32:45.365 --> 00:32:51.805
<c.green>首先
<c.green>在項目導航側邊欄中選擇資源目錄

00:32:53.240 --> 00:32:56.276
<c.green>然後點這裏的這個加號按鈕
<c.green>打開這個菜單

00:32:56.543 --> 00:33:00.848
<c.green>這裏就是你要創建
<c.green>各種集合類型的地方

00:33:02.216 --> 00:33:06.887
<c.green>有圖片集、圖標集、通用數據集、

00:33:07.154 --> 00:33:11.725
<c.green>以及紋理集和立方體貼圖紋理集

00:33:12.726 --> 00:33:16.763
<c.green>建好紋理集後 給它命名

00:33:17.998 --> 00:33:21.168
<c.green>你的命名等級
<c.green>沒必要非得是flat型的

00:33:21.235 --> 00:33:24.571
<c.green>如果你有許多叫做基礎紋理的紋理

00:33:24.638 --> 00:33:28.108
<c.green>每個對象都有一個這樣的紋理
<c.green>你可以爲每個對象創建一個文件夾

00:33:28.175 --> 00:33:31.879
<c.green>並把該對象的基礎紋理
<c.green>填充進相應的文件夾

00:33:32.713 --> 00:33:35.916
<c.green>這樣可以實現非常複雜的等級

00:33:38.719 --> 00:33:39.820
<c.green>添加圖片

00:33:41.221 --> 00:33:43.290
<c.green>然後設置解釋

00:33:43.724 --> 00:33:45.359
<c.green>這裏有三個選項

00:33:45.692 --> 00:33:51.164
<c.green>顏色 在NonPremultiplied
<c.green>顏色中執行顏色匹配運算

00:33:52.032 --> 00:33:56.036
<c.green>NonPremultiplied
<c.green>選項會在創建紋理之前

00:33:56.103 --> 00:34:01.241
<c.green>用RGB通道乘以alpha通道

00:34:02.009 --> 00:34:08.482
<c.green>這裏的數據選項用於普通地圖、

00:34:08.549 --> 00:34:15.121
<c.green>高度地圖、粗度地圖、
<c.green>非色彩類型紋理

00:34:15.889 --> 00:34:17.591
<c.green>這就是你需要做的全部工作

00:34:18.058 --> 00:34:19.493
<c.green> Xcode將開始創建

00:34:19.560 --> 00:34:22.862
<c.green>這個紋理的各個版本

00:34:23.263 --> 00:34:27.400
<c.green>並選擇最理想的像素格式

00:34:28.869 --> 00:34:33.440
<c.green>但是 你可以有更明確的控制

00:34:33.739 --> 00:34:36.009
<c.green>你可以選擇許多特性

00:34:37.277 --> 00:34:41.181
<c.green>這些特性會打開很多bucket
<c.green>可以用來自定義

00:34:41.815 --> 00:34:44.818
<c.green>你可以給每個版本
<c.green>添加不同的圖片

00:34:45.085 --> 00:34:47.521
<c.green>你很可能不會使用不同的圖片

00:34:47.588 --> 00:34:49.790
<c.green>而是同一張圖片的不同尺寸

00:34:49.857 --> 00:34:54.728
<c.green>那麼在內存量大的設備上
<c.green>使用較大的紋理

00:34:54.795 --> 00:34:58.565
<c.green>在內存量小的設備上
<c.green>使用較小的紋理

00:35:00.501 --> 00:35:05.239
<c.green>然後
<c.green>可以指定如何或是否想要mipmap

00:35:05.806 --> 00:35:10.177
<c.green>這個“全部”選項將會生成
<c.green>mipmap 一直到1x1級

00:35:10.711 --> 00:35:15.749
<c.green>而“固定”選項
<c.green>將提供一些更明確的控制

00:35:15.949 --> 00:35:19.419
<c.green>比如是否想要使用最大級

00:35:19.486 --> 00:35:24.491
<c.green>以及是否要給每個層級
<c.green>添加不同的圖片

00:35:26.393 --> 00:35:28.095
<c.green>最後 你可以覆蓋

00:35:28.161 --> 00:35:30.731
<c.green>像素格式的自動選擇

00:35:33.166 --> 00:35:36.870
<c.green>我剛纔提到過
<c.green>你可以用程序來創建

00:35:36.937 --> 00:35:38.138
<c.green>這些紋理集

00:35:38.772 --> 00:35:41.241
<c.green>你不見得會一步步
<c.green>按照Xcode UI的流程來

00:35:41.308 --> 00:35:44.178
<c.green>如果你有幾千個資源的話

00:35:44.845 --> 00:35:48.215
<c.green>那麼有一個很簡單的目錄結構

00:35:48.282 --> 00:35:52.319
<c.green>在那個目錄結構內有許多JSON文件

00:35:52.586 --> 00:35:56.089
<c.green>這些文件和目錄結構

00:35:56.156 --> 00:36:02.196
<c.green>被完全記錄在
<c.green>資源目錄參考上

00:36:02.529 --> 00:36:05.299
<c.green>你可以創建自己的
<c.green>資源調節工具

00:36:05.365 --> 00:36:07.968
<c.green>來設置紋理集

00:36:10.470 --> 00:36:14.174
<c.green>在設備上獲得了這個資源後
<c.green>該如何使用它呢？

00:36:14.241 --> 00:36:17.711
<c.green>先創建一個MetalKit紋理加載器

00:36:18.178 --> 00:36:20.047
<c.green>填充到Metal設備中

00:36:21.515 --> 00:36:25.319
<c.green>然後把名稱及其命名法

00:36:25.385 --> 00:36:27.054
<c.green>提供給紋理加載器

00:36:27.120 --> 00:36:29.556
<c.green>MetalKit將開始創建那個紋理

00:36:29.623 --> 00:36:32.492
<c.green>你可以在這裏提供其他選項

00:36:32.559 --> 00:36:35.796
<c.green>比如比例因子 如果你有
<c.green>不同版本的紋理的話

00:36:35.863 --> 00:36:37.431
<c.green>不同比例因子的

00:36:37.698 --> 00:36:39.867
<c.green>或bundle

00:36:40.033 --> 00:36:44.238
<c.green>如果主bundle中沒有資源目錄

00:36:44.505 --> 00:36:47.908
<c.green>你還可以指定一些選項

00:36:49.643 --> 00:36:53.447
<c.green>我真心希望你們能
<c.green>關注一下色彩空間

00:36:53.514 --> 00:36:59.887
<c.green>並通過用範圍更廣的
<c.green>色彩創建內容來分離應用

00:37:00.821 --> 00:37:04.258
<c.green>資源目錄可以幫助你
<c.green>實現那個目標

00:37:04.725 --> 00:37:07.661
<c.green>同樣 它們還提供許多其他功能

00:37:07.728 --> 00:37:11.999
<c.green>你可以利用起來
<c.green>比如最佳的像素格式選擇

00:37:14.468 --> 00:37:17.838
<c.green>接下來 讓我們歡迎我的同事
<c.green>Anna Tikhonova上臺

00:37:17.905 --> 00:37:20.007
<c.green>談一談在Metal性能着色器框架中

00:37:20.073 --> 00:37:22.376
<c.green>一些令人激動的改進

00:37:28.615 --> 00:37:29.616
<c.green>大家下午好

00:37:30.117 --> 00:37:31.718
<c.green>感謝Dan對我的介紹

00:37:31.785 --> 00:37:33.253
<c.green>Dan說過了 我叫Anna

00:37:33.320 --> 00:37:35.422
<c.green>我是GPU軟件團隊中的
<c.green>一名工程師

00:37:35.789 --> 00:37:39.126
<c.green>讓我們談一談
<c.green>Metal性能着色器中的一些新增功能

00:37:41.261 --> 00:37:43.964
<c.green>去年 我們在
<c.green>Metal的新特性的第二場演講中

00:37:44.031 --> 00:37:45.899
<c.green>引入了Metal性能着色器框架

00:37:46.266 --> 00:37:49.303
<c.green>如果你沒參加那場演講
<c.green>你真應該看一下視頻

00:37:50.270 --> 00:37:52.105
<c.green>我在此只給你們一個快速簡明的回顧

00:37:52.539 --> 00:37:55.042
<c.green>Metal性能着色器框架是

00:37:55.108 --> 00:37:58.378
<c.green>爲Metal中的GPU

00:37:58.445 --> 00:37:59.580
<c.green>優化的高性能數據平行算法

00:38:00.814 --> 00:38:03.016
<c.green>算法是針對iOS進行優化的

00:38:03.083 --> 00:38:05.619
<c.green>自iOS 9起可用

00:38:05.686 --> 00:38:08.121
<c.green>可用於A8 現在是A9處理器

00:38:09.489 --> 00:38:13.961
<c.green>可以簡易地把框架
<c.green>整合到Metal應用中

00:38:14.027 --> 00:38:15.562
<c.green>用起來很簡單

00:38:16.730 --> 00:38:19.600
<c.green>應該跟調用庫函數一樣簡單

00:38:21.535 --> 00:38:25.339
<c.green>去年 我們談到了以下這些
<c.green>所支持的圖像運算

00:38:25.906 --> 00:38:30.143
<c.green>你可從視頻中獲得更多詳細信息和示例

00:38:30.644 --> 00:38:33.347
<c.green>但今年我們增加了一些更酷的東西

00:38:34.314 --> 00:38:36.083
<c.green>我們增加了
<c.green>範圍更廣的顏色的轉換

00:38:36.149 --> 00:38:38.118
<c.green>可以用來在不同的色彩空間之間

00:38:38.185 --> 00:38:39.820
<c.green>轉換Metal紋理

00:38:40.420 --> 00:38:45.492
<c.green>可以在RGB、sRGB、灰度、
<c.green>CMYK、C3和你定義的

00:38:45.559 --> 00:38:47.628
<c.green>任何色彩空間之間進行轉換

00:38:49.730 --> 00:38:51.965
<c.green>我們還增加了高斯金字塔

00:38:52.733 --> 00:38:56.270
<c.green>用於在GPU上創建圖片數據的多尺度呈現

00:38:56.336 --> 00:38:59.006
<c.green>從而啓動多尺度算法

00:38:59.706 --> 00:39:03.310
<c.green>還可以用在常見的光流算法、

00:39:03.810 --> 00:39:06.713
<c.green>影像混合和優質mipmap生成中

00:39:08.081 --> 00:39:12.186
<c.green>最後 我們還增加了卷積神經網絡
<c.green>或叫做CNN

00:39:12.519 --> 00:39:15.689
<c.green>用於加快深度學習算法

00:39:16.323 --> 00:39:18.325
<c.green>這是我們今天要重點討論的話題

00:39:18.392 --> 00:39:20.060
<c.green>讓我們開始吧

00:39:21.161 --> 00:39:23.096
<c.green>首先 什麼是深度學習？

00:39:24.264 --> 00:39:26.700
<c.green>深度學習是一種機器學習領域

00:39:26.767 --> 00:39:28.635
<c.green>目標就是這個問題的答案

00:39:29.002 --> 00:39:31.939
<c.green>機器是否可以完成
<c.green>人類能夠完成的任務？

00:39:32.272 --> 00:39:34.274
<c.green>那麼
<c.green>我說的是什麼類型的任務呢？

00:39:35.108 --> 00:39:36.977
<c.green>你們每個人的口袋裏
<c.green>都有一部iPhone

00:39:37.044 --> 00:39:38.979
<c.green>今天你很可能拍了一些照片

00:39:39.346 --> 00:39:42.816
<c.green>我們所有人每天
<c.green>都不斷地暴露在圖片和視頻中

00:39:42.883 --> 00:39:46.153
<c.green>在網頁上、
<c.green>在新聞網站上、在社交媒體上

00:39:47.354 --> 00:39:48.589
<c.green>當你看到一個圖片時

00:39:49.156 --> 00:39:51.291
<c.green>你會立即瞭解它所描繪的內容

00:39:51.725 --> 00:39:53.060
<c.green>你可以檢測人臉

00:39:53.393 --> 00:39:55.229
<c.green>如果你認識這些人
<c.green>你可以標記他們

00:39:55.295 --> 00:39:56.697
<c.green>你可以給這個圖片添加註釋

00:39:57.331 --> 00:39:59.199
<c.green>如果是一張圖片 那沒什麼問題

00:39:59.933 --> 00:40:03.337
<c.green>但是如果有很多圖片
<c.green>甚至是很多很多圖片呢？

00:40:03.704 --> 00:40:06.974
<c.green>再想象一下每天
<c.green>上傳到網頁中的圖片數量

00:40:07.674 --> 00:40:10.177
<c.green>沒有人可以手動地
<c.green>給如此多的圖片添加註釋

00:40:11.044 --> 00:40:14.414
<c.green>所以 深度學習就是爲了
<c.green>解決這種問題而提出的技術

00:40:15.482 --> 00:40:18.285
<c.green>可以用於過濾大量數據

00:40:18.352 --> 00:40:19.820
<c.green>並回答這樣的問題

00:40:19.887 --> 00:40:22.623
<c.green>如 “這張圖片上有誰？”
<c.green>和“這張照片是哪拍的？”

00:40:23.557 --> 00:40:25.792
<c.green>我在這兒用了一個圖片的示例

00:40:25.859 --> 00:40:26.927
<c.green>因爲圖片是可見的

00:40:26.994 --> 00:40:30.097
<c.green>非常適合這種類型的演講

00:40:30.163 --> 00:40:31.598
<c.green>但我只想提一下

00:40:31.665 --> 00:40:34.768
<c.green>深度學習算法也能用於其他類型的數據

00:40:34.835 --> 00:40:39.339
<c.green>比如其他信號類型 如音頻

00:40:39.406 --> 00:40:42.943
<c.green>可以進行語音識別 以及觸覺
<c.green>可以創建觸摸感覺

00:40:45.245 --> 00:40:47.614
<c.green>深度學習算法有兩個階段

00:40:48.115 --> 00:40:50.017
<c.green>第一個階段是訓練階段

00:40:50.384 --> 00:40:53.453
<c.green>讓我們通過一個具體的例子來瞭解

00:40:54.254 --> 00:40:58.258
<c.green>想象一下你想訓練你的系統給圖片分類

00:40:58.625 --> 00:41:00.961
<c.green>這是一張貓的圖片 這是一張狗的圖片

00:41:01.061 --> 00:41:02.462
<c.green>這是一張兔子的圖片

00:41:03.263 --> 00:41:05.399
<c.green>這是一項人工密集型任務

00:41:05.465 --> 00:41:08.135
<c.green>需要大量圖片

00:41:08.769 --> 00:41:12.906
<c.green>手動標記並註解圖片
<c.green>然後劃到每一個類中

00:41:14.141 --> 00:41:17.744
<c.green>比如 如果你想訓練系統識別貓

00:41:18.212 --> 00:41:21.148
<c.green>你需要提供大量貓的圖片

00:41:21.415 --> 00:41:24.084
<c.green>所有圖片都被標記過
<c.green>要識別兔子和你想要系統能識別的

00:41:24.151 --> 00:41:27.754
<c.green>其他動物也一樣

00:41:30.490 --> 00:41:34.728
<c.green>這是個一次性的、需要大量運算的階段

00:41:34.795 --> 00:41:35.796
<c.green>通常是離線實現的

00:41:35.863 --> 00:41:38.432
<c.green>有大量可以利用的訓練包

00:41:39.099 --> 00:41:42.236
<c.green>訓練階段的結果是訓練好的參數

00:41:42.836 --> 00:41:46.673
<c.green>我現在先不談這個 稍後再談

00:41:48.609 --> 00:41:51.245
<c.green>訓練好的參數是下一個階段所需要的

00:41:51.311 --> 00:41:52.779
<c.green>也就是推理階段

00:41:53.514 --> 00:41:54.781
<c.green>這個階段是

00:41:55.282 --> 00:41:57.618
<c.green>給系統提供一張之前從未見過的

00:41:57.684 --> 00:41:58.986
<c.green>新圖片

00:41:59.052 --> 00:42:00.754
<c.green>它需要實時地進行歸類

00:42:00.821 --> 00:42:03.857
<c.green>在這個例子中
<c.green>系統正確地將這個圖片歸類到

00:42:03.924 --> 00:42:04.858
<c.green>貓類的圖中

00:42:06.560 --> 00:42:09.596
<c.green>我們爲推理階段提供GPU加速

00:42:09.997 --> 00:42:12.666
<c.green>尤其是 我們還提供

00:42:12.999 --> 00:42:15.702
<c.green>爲GPU創建推理網絡的構建模塊

00:42:17.171 --> 00:42:20.874
<c.green>接下來讓我們談談什麼是卷積神經網絡

00:42:20.941 --> 00:42:23.210
<c.green>以及我們提供哪些構建模塊？

00:42:25.412 --> 00:42:27.548
<c.green>卷積神經網絡 或叫做CNN

00:42:27.614 --> 00:42:32.186
<c.green>是受生物學啓發模擬視覺皮質

00:42:33.253 --> 00:42:35.355
<c.green>當我們的大腦處理視覺輸入時

00:42:35.722 --> 00:42:38.659
<c.green>接收信息的神經元
<c.green>的第一個等級

00:42:38.725 --> 00:42:43.564
<c.green>從視覺皮質中
<c.green>對特定的邊界、斑點或顏色很敏感

00:42:44.031 --> 00:42:46.834
<c.green>而大腦分區接下來進入視覺管道

00:42:47.301 --> 00:42:51.205
<c.green>響應更復雜的結構
<c.green>比如面部或各種各樣的動物

00:42:51.972 --> 00:42:53.340
<c.green>非常相似地

00:42:54.208 --> 00:42:58.812
<c.green>卷積神經網絡組成了神經元層

00:42:59.479 --> 00:43:02.816
<c.green>被訓練識別越來越多的複雜特徵

00:43:04.751 --> 00:43:08.689
<c.green>所以
<c.green>第一層被訓練爲識別低層特徵

00:43:08.755 --> 00:43:11.225
<c.green>如邊界和色塊

00:43:11.558 --> 00:43:15.229
<c.green>隨後的層被訓練
<c.green>識別較高層的特徵

00:43:15.295 --> 00:43:17.397
<c.green>比如 如果我們正在做人臉檢測

00:43:17.464 --> 00:43:21.368
<c.green>會有識別像鼻子、眼睛、
<c.green>臉頰這樣的特徵的層

00:43:21.435 --> 00:43:25.138
<c.green>然後把這些特徵結合到一起
<c.green>最後構成人臉

00:43:27.241 --> 00:43:30.944
<c.green>最後幾個層會結合所有已生成的信息

00:43:31.178 --> 00:43:33.146
<c.green>生成最終的網絡輸出

00:43:33.213 --> 00:43:35.949
<c.green>比如圖片中很可能有一張人臉

00:43:37.050 --> 00:43:38.619
<c.green>我一直提到特徵

00:43:39.486 --> 00:43:44.224
<c.green>可以把特徵當做一種過濾器
<c.green>過濾那個特徵的輸入

00:43:44.291 --> 00:43:45.158
<c.green>比如鼻子

00:43:45.692 --> 00:43:48.929
<c.green>如果找到那個信息 就傳過來

00:43:49.596 --> 00:43:50.964
<c.green>如果找到那個特徵

00:43:51.265 --> 00:43:54.535
<c.green>就把信息傳給後續的層

00:43:54.902 --> 00:43:57.604
<c.green>當然
<c.green>我們需要發現很多這樣的特徵

00:43:57.671 --> 00:43:59.439
<c.green>如果我們正在做人臉檢測

00:43:59.506 --> 00:44:02.142
<c.green>那麼
<c.green>只尋找鼻子很顯然是遠遠不夠的

00:44:02.209 --> 00:44:04.211
<c.green>我們還需要尋找其他面部特徵

00:44:04.278 --> 00:44:07.714
<c.green>比如臉頰、眼睛
<c.green>然後把這些特徵結合在一起

00:44:07.781 --> 00:44:09.983
<c.green>我們需要很多這樣的
<c.green>特徵過濾器

00:44:11.585 --> 00:44:14.454
<c.green>這就是卷積神經網絡

00:44:14.821 --> 00:44:16.990
<c.green>接下來談一下
<c.green>我們提供的構建模塊

00:44:17.758 --> 00:44:19.826
<c.green>第一個構建模塊是你的數據

00:44:20.661 --> 00:44:24.131
<c.green>我們建議使用
<c.green>MPS圖片和MPS臨時圖片

00:44:24.198 --> 00:44:27.634
<c.green>是我們專門
<c.green>爲支持卷積網絡新增加的

00:44:28.168 --> 00:44:30.604
<c.green>它們會爲數據、
<c.green>爲輸入和中間結果

00:44:30.671 --> 00:44:32.739
<c.green>提供優化佈局

00:44:34.074 --> 00:44:38.178
<c.green>可以把MPS臨時圖片想象成
<c.green>輕量級的MPS圖片

00:44:39.146 --> 00:44:43.183
<c.green>作用於存在時間較短的圖片數據

00:44:44.685 --> 00:44:46.119
<c.green>MPS臨時圖片

00:44:46.887 --> 00:44:49.223
<c.green>是用Metal資源堆創建的

00:44:49.289 --> 00:44:54.595
<c.green>我們在第一場演講中描述過

00:44:56.263 --> 00:44:58.465
<c.green>它們會標記其中一些
<c.green>重複利用的緩衝內存

00:44:59.099 --> 00:45:04.938
<c.green>並避免資源佔用過多
<c.green>和重新分配紋理資源

00:45:05.105 --> 00:45:07.040
<c.green>目標是節約大量內存

00:45:07.474 --> 00:45:10.377
<c.green>並幫助管理中間資源

00:45:11.945 --> 00:45:13.981
<c.green>我們還提供一些層

00:45:14.047 --> 00:45:17.551
<c.green>用於創建推理網絡

00:45:17.918 --> 00:45:19.520
<c.green>但你現在可能在想

00:45:19.586 --> 00:45:22.589
<c.green>“我如何得知
<c.green>實際需要哪個構建模塊

00:45:22.656 --> 00:45:24.558
<c.green>來創建我自己的推理網絡呢？”

00:45:26.760 --> 00:45:28.896
<c.green>答案是訓練好的參數

00:45:29.530 --> 00:45:30.998
<c.green>訓練好的參數...

00:45:31.231 --> 00:45:34.535
<c.green>我在前面提到過
<c.green>當我們談到訓練階段的時候

00:45:34.968 --> 00:45:37.337
<c.green>訓練好的參數會提供
<c.green>關於如何創建推理網絡的

00:45:37.404 --> 00:45:39.439
<c.green>完整方法

00:45:39.840 --> 00:45:43.110
<c.green>它們會告訴你 要有多少個層

00:45:43.177 --> 00:45:45.679
<c.green>是哪些層以及層出現的順序

00:45:45.746 --> 00:45:48.515
<c.green>你還會得到每一層的所有特徵過濾器

00:45:50.184 --> 00:45:52.953
<c.green>我們在底層實現了這一切

00:45:53.020 --> 00:45:56.056
<c.green>以便確保你用這些構建模塊
<c.green>創建的網絡

00:45:56.123 --> 00:45:59.426
<c.green>在所有iOS GPU上
<c.green>都有最好的性能

00:45:59.493 --> 00:46:04.565
<c.green>你要做的就是把你的數據
<c.green>挖掘到我們提供的這個優化佈局

00:46:05.199 --> 00:46:07.301
<c.green>並調用庫函數

00:46:07.367 --> 00:46:09.469
<c.green>創建組成網絡的層

00:46:10.504 --> 00:46:14.241
<c.green>現在讓我們詳細討論一下
<c.green>這些構建模塊

00:46:14.308 --> 00:46:17.177
<c.green>但讓我們通過一個
<c.green>具體的例子來解釋

00:46:20.914 --> 00:46:21.982
<c.green>在這個演示中

00:46:24.451 --> 00:46:27.921
<c.green>我有一個系統被訓練爲識別微笑

00:46:28.655 --> 00:46:31.124
<c.green>我們要實現的是系統將

00:46:32.092 --> 00:46:33.894
<c.green>實時檢測我是否微笑

00:46:33.961 --> 00:46:36.063
<c.green>我先微笑 然後我再皺眉

00:46:36.230 --> 00:46:38.398
<c.green>你將看到系統會給出正確的報告

00:46:40.334 --> 00:46:42.836
<c.green>微笑

00:46:42.903 --> 00:46:43.770
<c.green>沒微笑

00:46:43.837 --> 00:46:45.572
<c.green>微笑

00:46:45.639 --> 00:46:46.640
<c.green>沒微笑

00:46:46.707 --> 00:46:47.541
<c.green>好了

00:46:48.008 --> 00:46:49.576
<c.green>這就是我的演示

00:46:55.048 --> 00:46:58.218
<c.green>好了 現在讓我們來看看

00:46:58.285 --> 00:47:00.988
<c.green>要創建這種網絡所需要的構建模塊

00:47:01.522 --> 00:47:04.892
<c.green>我們要談到的第一個構建模塊是卷積層

00:47:05.592 --> 00:47:08.362
<c.green>是卷積神經網絡中的核心構建模塊

00:47:08.929 --> 00:47:11.532
<c.green>它的目標是識別特徵並輸入

00:47:11.598 --> 00:47:13.100
<c.green>之所以叫卷積層

00:47:13.166 --> 00:47:15.636
<c.green>是因爲它會對輸入執行卷積運算

00:47:15.702 --> 00:47:18.038
<c.green>讓我們回想一下常規的
<c.green>卷積運算是如何計算的

00:47:18.539 --> 00:47:20.107
<c.green>你有輸入和輸出

00:47:20.174 --> 00:47:23.143
<c.green>在這個例子中是一個
<c.green>5x5像素的過濾器 有一些重量

00:47:23.710 --> 00:47:27.014
<c.green>爲了在輸出中計算這個像素的值

00:47:27.080 --> 00:47:29.449
<c.green>你需要用輸入卷積過濾器

00:47:30.651 --> 00:47:31.485
<c.green>非常簡單

00:47:32.019 --> 00:47:33.420
<c.green>卷積層

00:47:33.487 --> 00:47:35.856
<c.green>是常規卷積運算的一個泛指

00:47:36.790 --> 00:47:38.725
<c.green>你可以使用多個過濾器

00:47:39.193 --> 00:47:42.329
<c.green>不同的過濾器
<c.green>獨立應用於輸入中

00:47:42.396 --> 00:47:44.364
<c.green>結果會形成不同的輸出通道

00:47:44.431 --> 00:47:47.801
<c.green>那麼 如果你有16個過濾器
<c.green>意味着你將有16個輸出通道

00:47:48.368 --> 00:47:50.304
<c.green>爲了 獲得這個像素的值

00:47:50.370 --> 00:47:52.272
<c.green>在輸出的第一個通道中

00:47:52.339 --> 00:47:55.843
<c.green>你需要取到第一個過濾器
<c.green>並用輸入對它進行卷積運算

00:47:56.343 --> 00:47:58.846
<c.green>爲了 獲得這個像素的值

00:47:58.912 --> 00:48:01.248
<c.green>在輸出的第二管道中

00:48:01.315 --> 00:48:04.451
<c.green>你需要取到第二個過濾器
<c.green>並用輸入對它進行卷積運算

00:48:06.220 --> 00:48:10.023
<c.green>當然 我們的示例是比較輕微的檢測
<c.green>我們處理的是彩色圖片

00:48:10.090 --> 00:48:13.961
<c.green>意思是
<c.green>你的輸入實際上有三種獨立的通道

00:48:14.528 --> 00:48:17.764
<c.green>正是因爲卷積神經網絡的
<c.green>這種運行方式所導致的

00:48:18.098 --> 00:48:21.034
<c.green>你需要三組過濾器 每組16個

00:48:21.301 --> 00:48:23.871
<c.green>每種輸入通道分別爲一組

00:48:24.872 --> 00:48:28.275
<c.green>然後把不同的過濾器應用到

00:48:29.009 --> 00:48:32.145
<c.green>獨立的輸入通道

00:48:35.616 --> 00:48:39.286
<c.green>並把結果結合起來獲得單一輸出值

00:48:43.290 --> 00:48:46.527
<c.green>這就是如何在我們的框架中

00:48:46.593 --> 00:48:48.161
<c.green>創建卷積層

00:48:48.662 --> 00:48:51.532
<c.green>首先創建一個描述符並制定參數

00:48:51.632 --> 00:48:54.801
<c.green>比如過濾器的寬和高

00:48:54.868 --> 00:48:57.371
<c.green>然後是輸入和輸出通道的數量

00:49:00.140 --> 00:49:03.210
<c.green>然後 從描述符中創建卷積層

00:49:03.610 --> 00:49:08.148
<c.green>併爲特徵過濾器提供從訓練好的

00:49:08.215 --> 00:49:10.250
<c.green>參數中獲取的真實數據

00:49:12.753 --> 00:49:15.222
<c.green>我們要談到的下一個層是匯聚層

00:49:15.856 --> 00:49:17.457
<c.green>匯聚層的作用是

00:49:17.524 --> 00:49:21.528
<c.green>逐步減少網絡的空間規模

00:49:21.595 --> 00:49:24.531
<c.green>從而減少後續層的競爭

00:49:24.665 --> 00:49:25.999
<c.green>通常是在中間連續的卷積層

00:49:26.066 --> 00:49:29.036
<c.green>插入匯聚層

00:49:29.603 --> 00:49:31.471
<c.green>匯聚層的另一個作用是

00:49:31.738 --> 00:49:37.811
<c.green>總結或濃縮輸入區中的信息

00:49:38.612 --> 00:49:40.547
<c.green>應該提供兩種匯聚運算

00:49:40.614 --> 00:49:42.015
<c.green>最大值和平均值

00:49:43.116 --> 00:49:44.151
<c.green>在這個例子中

00:49:44.818 --> 00:49:48.722
<c.green>我們用了一個2x2的像素區
<c.green>進行輸入

00:49:49.456 --> 00:49:53.827
<c.green>我們取到最大值
<c.green>並把它存起來作爲輸出

00:49:56.196 --> 00:49:59.967
<c.green>這是你需在Metal性能着色器
<c.green>框架中使用的API

00:50:00.033 --> 00:50:01.735
<c.green>用於創建匯聚層

00:50:02.402 --> 00:50:04.671
<c.green>一般用的是最大運算

00:50:06.139 --> 00:50:08.175
<c.green>過濾器尺寸是2x2

00:50:11.245 --> 00:50:12.713
<c.green>全連接層

00:50:12.779 --> 00:50:15.282
<c.green>是輸入的每個神經元都被連接到

00:50:15.349 --> 00:50:17.718
<c.green>輸出的每個神經元的層

00:50:18.185 --> 00:50:20.988
<c.green>可以把它看作卷積層的一種特殊類型

00:50:21.488 --> 00:50:24.992
<c.green>過濾器的尺寸與輸入尺寸相同

00:50:25.058 --> 00:50:26.226
<c.green>在這個例子中

00:50:26.293 --> 00:50:29.229
<c.green>過濾器的尺寸與輸入尺寸是相同的

00:50:29.296 --> 00:50:32.099
<c.green>我們對它們進行了卷積運算
<c.green>並獲得了單一輸出值

00:50:33.033 --> 00:50:34.301
<c.green>在這個架構中

00:50:34.902 --> 00:50:38.805
<c.green>卷積層和匯聚層操作的是輸入分區

00:50:38.872 --> 00:50:40.407
<c.green>而全連接層

00:50:40.474 --> 00:50:45.012
<c.green>用於從所有輸入中聚集信息

00:50:45.712 --> 00:50:47.981
<c.green>通常是網絡中最末端的層之一

00:50:48.048 --> 00:50:50.884
<c.green>是做出最終決策的地方

00:50:51.118 --> 00:50:55.389
<c.green>並生成輸出

00:50:55.722 --> 00:50:58.525
<c.green>比如圖片中很可能有笑臉

00:51:01.495 --> 00:51:04.531
<c.green>這就是如何在Metal性能着色器

00:51:04.598 --> 00:51:06.800
<c.green>框架中創建全連接層

00:51:07.100 --> 00:51:08.702
<c.green>首先創建一個卷積描述符

00:51:08.769 --> 00:51:11.371
<c.green>因爲這是卷積層的一個特殊類型

00:51:11.471 --> 00:51:13.574
<c.green>然後從這個描述符中

00:51:14.074 --> 00:51:15.175
<c.green>創建一個全連接層

00:51:16.610 --> 00:51:18.011
<c.green>我們還將提供一些其他的層

00:51:18.078 --> 00:51:21.014
<c.green>我在本次演講中不會披露太多信息

00:51:21.081 --> 00:51:23.383
<c.green>但你們可從文檔中找到相關信息

00:51:23.717 --> 00:51:25.118
<c.green>我們還提供神經層

00:51:25.352 --> 00:51:28.589
<c.green>通常跟卷積層一起結合使用

00:51:28.856 --> 00:51:31.892
<c.green>我們還提供SoftMax層和
<c.green>normalization層

00:51:33.093 --> 00:51:35.462
<c.green>那麼我們已經提到了所有的層

00:51:35.529 --> 00:51:36.864
<c.green>現在讓我們來談談數據

00:51:37.264 --> 00:51:39.600
<c.green>我剛提到你應該用MPS圖片

00:51:39.867 --> 00:51:41.034
<c.green>它們到底是什麼？

00:51:42.436 --> 00:51:45.506
<c.green>你們中絕大多數人
<c.green>都已經熟悉Metal紋理了

00:51:45.572 --> 00:51:50.744
<c.green>那麼這就是一個
<c.green>多通道的2D Metal紋理

00:51:50.811 --> 00:51:53.714
<c.green>每個通道對應着一個
<c.green>顏色通道和alpha

00:51:54.681 --> 00:51:56.383
<c.green>我在之前的示例中曾提到

00:51:56.450 --> 00:52:00.187
<c.green>我們需要用多通道創建圖片

00:52:00.587 --> 00:52:02.122
<c.green>比如 32個通道

00:52:02.189 --> 00:52:04.124
<c.green>如果我們有32個特徵過濾器

00:52:04.191 --> 00:52:08.529
<c.green>我們需要創建
<c.green>有32個通道的輸出圖片

00:52:08.595 --> 00:52:09.596
<c.green>我們該如何實現呢？

00:52:10.764 --> 00:52:12.165
<c.green>MPS圖片

00:52:12.599 --> 00:52:16.370
<c.green>實際上是有多個切片的
<c.green>Metal 2D數組紋理

00:52:16.870 --> 00:52:20.741
<c.green>當你創建MPS圖片時
<c.green>你真正需要注意的是

00:52:20.807 --> 00:52:25.179
<c.green>你正在創建有32個通道的圖片

00:52:26.046 --> 00:52:30.484
<c.green>但有時候 你可能需要
<c.green>把MPS圖片數據返回到CPU

00:52:30.784 --> 00:52:34.087
<c.green>或者你想使用
<c.green>現有的Metal 2D數組紋理

00:52:34.154 --> 00:52:35.756
<c.green>作爲MPS圖片

00:52:35.822 --> 00:52:37.691
<c.green>在這種情況下 你需要了解到

00:52:37.758 --> 00:52:41.728
<c.green>我們爲你的數據
<c.green>使用了特殊的打包佈局

00:52:42.095 --> 00:52:47.367
<c.green>因此結構切片中的每個像素
<c.green>都包含四個通道的數據

00:52:48.735 --> 00:52:52.773
<c.green>所以一張有32個通道的圖片
<c.green>實際應該只有八個切片

00:52:54.575 --> 00:52:56.276
<c.green>這是你在我們的框架中

00:52:56.343 --> 00:52:59.446
<c.green>創建MPS圖片要使用的API

00:52:59.513 --> 00:53:00.814
<c.green>首先創建一個描述符

00:53:00.881 --> 00:53:05.185
<c.green>並制定參數 如數據格式的通道

00:53:05.619 --> 00:53:08.856
<c.green>圖片高度和通道數量

00:53:09.790 --> 00:53:13.193
<c.green>然後從這個描述符中
<c.green>創建一張MPS圖片 非常簡單

00:53:14.928 --> 00:53:17.965
<c.green>當然 如果輸入圖片的尺寸小

00:53:18.031 --> 00:53:20.601
<c.green>那麼你可以批量處理
<c.green>來更好地利用GPU

00:53:21.068 --> 00:53:24.371
<c.green>我們會提供一個簡單的機制
<c.green>來幫助你實現批量處理

00:53:24.738 --> 00:53:28.876
<c.green>在這個例子中 我們創建了一個
<c.green>含有100張MPS圖片的數組

00:53:30.511 --> 00:53:34.615
<c.green>那麼現在 我們已經提到了所有層
<c.green>也提到了數據

00:53:34.715 --> 00:53:37.751
<c.green>接下來 讓我們看一下
<c.green>要進行微笑探測

00:53:38.285 --> 00:53:39.553
<c.green>所需要創建的實際網絡

00:53:40.053 --> 00:53:41.788
<c.green>我們從輸入開始

00:53:41.855 --> 00:53:45.325
<c.green>我們將使用
<c.green>我一直在提的訓練好的參數

00:53:46.026 --> 00:53:47.895
<c.green>來幫助我們創建這個網絡

00:53:48.262 --> 00:53:50.230
<c.green>那麼 訓練好的參數告訴我們

00:53:50.297 --> 00:53:53.901
<c.green>這個網絡的第一層將是卷積層

00:53:53.967 --> 00:53:56.270
<c.green>輸入有三個通道的圖片

00:53:56.336 --> 00:53:58.405
<c.green>並輸出有16個通道的圖片

00:53:59.573 --> 00:54:01.375
<c.green>訓練好的參數還提供

00:54:01.441 --> 00:54:04.611
<c.green>三組過濾器 每組16個

00:54:05.078 --> 00:54:07.848
<c.green>這些富有色彩的藍色圖片

00:54:09.116 --> 00:54:12.286
<c.green>在把過濾器應用到輸入中之後

00:54:12.352 --> 00:54:14.755
<c.green>使輸出通道變得可視化

00:54:16.590 --> 00:54:18.659
<c.green>下一層是匯聚層

00:54:18.725 --> 00:54:23.530
<c.green>通過每一個維度的兩個因子

00:54:23.797 --> 00:54:25.599
<c.green>降低卷積層輸出的空間分辨率

00:54:27.100 --> 00:54:29.336
<c.green>訓練好的參數告訴我們
<c.green>下一層

00:54:29.403 --> 00:54:30.904
<c.green>是另一個卷積層

00:54:30.971 --> 00:54:33.173
<c.green>輸入有16個通道的圖片

00:54:33.240 --> 00:54:35.409
<c.green>並輸出有16個通道的圖片

00:54:35.642 --> 00:54:38.745
<c.green>進一步縮小
<c.green>下一個匯聚層的尺寸

00:54:39.112 --> 00:54:42.583
<c.green>以此類推 直到我們得到輸出

00:54:43.517 --> 00:54:44.518
<c.green>正如你所看到的

00:54:45.152 --> 00:54:48.155
<c.green>這個網絡有一連串的卷積層

00:54:48.222 --> 00:54:49.790
<c.green>每個卷基層後面都跟着一個匯聚層

00:54:50.057 --> 00:54:53.160
<c.green>最後兩層實際上是全連接層

00:54:53.227 --> 00:54:56.597
<c.green>爲網絡生成最終輸出

00:54:58.065 --> 00:55:00.734
<c.green>現在 我們已經瞭解這個網絡
<c.green>應該是個什麼樣的網絡

00:55:00.801 --> 00:55:02.135
<c.green>這樣的網絡在爲推理創建的

00:55:02.202 --> 00:55:04.705
<c.green>卷積神經網絡中很常見

00:55:05.405 --> 00:55:08.709
<c.green>現在 讓我們看一下
<c.green>在框架中創建這種網絡的代碼

00:55:10.711 --> 00:55:12.913
<c.green>第一步是創建層

00:55:13.547 --> 00:55:16.283
<c.green>訓練好的參數再次告訴我們說
<c.green>我們需要

00:55:16.350 --> 00:55:18.886
<c.green>在我們的網絡中 四個卷積層

00:55:19.586 --> 00:55:23.257
<c.green>爲簡單起見 我演示的代碼
<c.green>只創建其中一個卷基層

00:55:23.323 --> 00:55:26.426
<c.green>但正如你所看到的
<c.green>我使用了跟我之前給你們看過的

00:55:26.493 --> 00:55:27.895
<c.green>完全一樣的API

00:55:28.695 --> 00:55:30.697
<c.green>然後 我們需要創建匯聚層

00:55:31.565 --> 00:55:34.535
<c.green>我們只需要一個 因爲我們要一直使用

00:55:34.601 --> 00:55:37.304
<c.green>最大運算 過濾器尺寸爲2x2

00:55:38.071 --> 00:55:40.874
<c.green>我們還需要創建兩個全連接層

00:55:40.941 --> 00:55:44.545
<c.green>爲簡單起見 我只演示一個的代碼

00:55:45.679 --> 00:55:48.382
<c.green>現在 我們需要注意一下輸入和輸出

00:55:48.882 --> 00:55:50.284
<c.green>在這個具體的例子中

00:55:50.784 --> 00:55:54.087
<c.green>假設我們有一個現存的Metal應用

00:55:54.154 --> 00:55:57.558
<c.green>並且你有一些想

00:55:57.624 --> 00:56:01.595
<c.green>用在輸入和輸出中的紋理上

00:56:01.662 --> 00:56:03.397
<c.green>這就是用來創建MPS圖片的API

00:56:04.831 --> 00:56:08.569
<c.green>最後一個階段是從現有的Metal紋理中

00:56:08.635 --> 00:56:10.270
<c.green>按照訓練好的參數所指定的順序

00:56:10.337 --> 00:56:12.840
<c.green>把所有層編碼到一個現有的命令緩衝區

00:56:14.575 --> 00:56:16.510
<c.green>這樣 我們就有了輸入和輸出

00:56:16.577 --> 00:56:20.480
<c.green>現在 我們注意到還需要注意一件事

00:56:21.014 --> 00:56:24.351
<c.green>我們要把第一層的輸出存起來

00:56:24.852 --> 00:56:27.421
<c.green>那麼讓我們用MPS臨時圖片來處理

00:56:28.388 --> 00:56:31.158
<c.green>這是如何創建MPS臨時圖片

00:56:31.425 --> 00:56:33.193
<c.green>正如你所看到的 類似於

00:56:33.260 --> 00:56:35.596
<c.green>你創建普通MPS圖片的方法

00:56:36.697 --> 00:56:40.334
<c.green>我們要立即在第一層的編碼中使用它

00:56:40.801 --> 00:56:43.103
<c.green>臨時圖片就會被清除

00:56:43.170 --> 00:56:45.272
<c.green>提交命令緩衝區

00:56:46.473 --> 00:56:49.009
<c.green>然後我們繼續 創建另一張臨時圖片

00:56:49.510 --> 00:56:51.812
<c.green>來存儲第二層的輸出

00:56:52.079 --> 00:56:54.715
<c.green>以此類推 直到我們得到輸出

00:56:56.016 --> 00:56:56.850
<c.green>就是這樣

00:56:57.751 --> 00:56:59.653
<c.green>只需要把它們連接起來

00:57:00.053 --> 00:57:02.523
<c.green>層的編碼順序

00:57:02.589 --> 00:57:06.260
<c.green>跟我之前演示的
<c.green>網絡圖表上的順序完全一致

00:57:06.527 --> 00:57:09.229
<c.green>從輸入開始 一直到輸出

00:57:10.631 --> 00:57:13.033
<c.green>我們已經演示完了一個非常簡單的例子

00:57:13.267 --> 00:57:15.402
<c.green>現在讓我們來看一個更復雜的例子

00:57:16.937 --> 00:57:20.107
<c.green>我們從張量流中移植原始推理網絡

00:57:20.174 --> 00:57:22.876
<c.green>使用Metal性能着色器框架來運行

00:57:23.410 --> 00:57:25.913
<c.green>這是一個很常用的推理網絡

00:57:25.979 --> 00:57:28.849
<c.green>用於對象檢測 這是完整圖表

00:57:29.550 --> 00:57:30.417
<c.green>這個網絡

00:57:31.285 --> 00:57:33.086
<c.green>正如你們所看到的 這個網絡

00:57:33.153 --> 00:57:35.889
<c.green>比我剛演示的那個更復雜

00:57:36.590 --> 00:57:38.125
<c.green>有100多個層

00:57:38.225 --> 00:57:40.027
<c.green>但我想提醒一下 你們要做的

00:57:40.093 --> 00:57:42.829
<c.green>只是調用一些庫函數來創建這些層

00:57:43.664 --> 00:57:46.633
<c.green>首先讓我們看一下運行中的網絡

00:57:50.771 --> 00:57:53.740
<c.green>這裏我有一些不同對象的圖片集

00:57:54.141 --> 00:57:56.076
<c.green>只要我輕觸這個圖片

00:57:56.376 --> 00:58:00.581
<c.green>我們就會實時運行推理網絡

00:58:00.647 --> 00:58:04.751
<c.green>它將報告關於這是什麼物體的
<c.green>最有可能的五個猜想

00:58:05.118 --> 00:58:07.888
<c.green>那麼最可能的猜想是一匹斑馬

00:58:09.523 --> 00:58:11.525
<c.green>然後是一輛皮卡車

00:58:12.693 --> 00:58:14.428
<c.green>然後是一座火山

00:58:14.494 --> 00:58:17.097
<c.green>看起來很不錯 當然了

00:58:17.531 --> 00:58:20.334
<c.green>讓我們在舞臺上做一個現場演示吧

00:58:20.868 --> 00:58:24.872
<c.green>我們要給這個水瓶拍一張照片

00:58:27.174 --> 00:58:28.642
<c.green>讓我們用這張圖片

00:58:30.277 --> 00:58:31.111
<c.green>水瓶

00:58:40.153 --> 00:58:42.689
<c.green>我想用這個現場演示告訴你們的是

00:58:42.756 --> 00:58:46.527
<c.green>即使是100多層的巨大網絡

00:58:46.593 --> 00:58:49.963
<c.green>也可以用
<c.green>Metal性能着色器框架實時運行

00:58:50.097 --> 00:58:51.064
<c.green>但這並不是全部

00:58:51.698 --> 00:58:54.801
<c.green>我還想要談一下 在演示中

00:58:54.868 --> 00:58:57.538
<c.green>通過使用MPS臨時圖片節約內存

00:58:58.539 --> 00:59:00.307
<c.green>在這個演示的第一個版本中

00:59:00.641 --> 00:59:03.577
<c.green>我們用了MPS圖片
<c.green>來存儲中間結果

00:59:04.211 --> 00:59:07.581
<c.green>我們最終以需要74 MPS圖片結束

00:59:07.648 --> 00:59:12.219
<c.green>整個網絡的總尺寸超過80兆

00:59:12.719 --> 00:59:15.189
<c.green>當然 你不必使用74張圖片

00:59:15.255 --> 00:59:16.156
<c.green>你可以針對如何重新使用

00:59:16.657 --> 00:59:20.294
<c.green>這些圖片提出你自己的體系

00:59:20.527 --> 00:59:23.430
<c.green>但這意味着需要在代碼中
<c.green>管理更多的內容

00:59:23.497 --> 00:59:27.267
<c.green>我們想確保我們的框架
<c.green>儘可能地簡單易用

00:59:27.835 --> 00:59:29.636
<c.green>所以 在演示的第二個版本中

00:59:29.970 --> 00:59:34.208
<c.green>我們用MPS臨時圖片
<c.green>替換了所有MPS圖片

00:59:34.942 --> 00:59:36.743
<c.green>這帶來了一些優勢

00:59:36.910 --> 00:59:40.647
<c.green>第一點是在時間和能源方面
<c.green>減少了CPU消耗

00:59:41.315 --> 00:59:44.852
<c.green>但仍然創建了74張臨時圖片

00:59:44.918 --> 00:59:49.056
<c.green>只有5個底層內存分配

00:59:49.423 --> 00:59:54.294
<c.green>總計只有20兆多一點兒
<c.green>這節省了76％的內存

00:59:54.528 --> 00:59:55.529
<c.green>這個數超級巨大

00:59:57.931 --> 01:00:00.167
<c.green>我用這兩個現場演示的是

01:00:00.234 --> 01:00:03.070
<c.green>Metal性能着色器框架

01:00:03.136 --> 01:00:04.972
<c.green>爲推理創建卷積神經網絡

01:00:05.038 --> 01:00:07.374
<c.green>提供的全力支持

01:00:07.674 --> 01:00:10.043
<c.green>並優化了iOS GPU的使用情況

01:00:10.110 --> 01:00:12.946
<c.green>所以 請使用卷積神經網絡

01:00:13.013 --> 01:00:14.281
<c.green>來建一些很酷的應用吧

01:00:16.383 --> 01:00:18.852
<c.green>以上就是
<c.green>“Metal的新特性”演講的全部內容

01:00:18.919 --> 01:00:20.954
<c.green>如果你沒參加第一場演講

01:00:21.355 --> 01:00:23.223
<c.green>請看一下相關視頻

01:00:23.290 --> 01:00:25.392
<c.green>這樣你就能瞭解這些很酷的新特性

01:00:25.459 --> 01:00:29.463
<c.green>如曲面細分、資源堆和無記憶渲染目標

01:00:29.530 --> 01:00:31.198
<c.green>以及現有工具的改進

01:00:33.100 --> 01:00:37.004
<c.green>在這場演講中 我們談了專用函數

01:00:37.070 --> 01:00:40.874
<c.green>和資源讀寫函數、白色和紋理資源、

01:00:40.941 --> 01:00:43.377
<c.green>Metal性能工具的新增功能

01:00:43.443 --> 01:00:45.846
<c.green>以及卷積神經網絡的簡單介紹

01:00:47.281 --> 01:00:50.384
<c.green>要獲得關於本場演講的更多信息
<c.green>請訪問這個URL

01:00:51.585 --> 01:00:52.653
<c.green>你可以觀看視頻

01:00:52.719 --> 01:00:56.256
<c.green>並獲得相關文檔和示例代碼的鏈接

01:00:57.624 --> 01:01:00.260
<c.green>還有一些相關的演講的信息

01:01:01.028 --> 01:01:05.866
<c.green>你總可以在線查看
<c.green>過往Metal演講的視頻

01:01:05.933 --> 01:01:07.534
<c.green>你還可以參加

01:01:07.601 --> 01:01:10.504
<c.green>今天晚些時候舉辦的
<c.green>高級Metal着色器優化演講

01:01:11.171 --> 01:01:14.575
<c.green>請注意 這場演講的地址
<c.green>改爲了Knob Hill

01:01:15.909 --> 01:01:19.479
<c.green>明天你們將有機會參加白色處理演講

01:01:19.546 --> 01:01:22.049
<c.green>及神經網絡和加速演講

01:01:22.115 --> 01:01:25.018
<c.green>可以瞭解如何爲CPU創建神經網絡

01:01:25.085 --> 01:01:26.720
<c.green>使用加速框架

01:01:27.187 --> 01:01:30.991
<c.green>非常感謝大家來參加本場演講
<c.green>祝你們在WWDC期間度過一段美好的時光