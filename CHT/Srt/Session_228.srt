00:00:19.786 --> 00:00:20.754
窺視3D TOUCH

00:00:20.821 --> 00:00:23.056
爲了下一個維度的TOUCH
增強你的應用

00:00:35.669 --> 00:00:39.473
下午好
歡迎來到“窺視3D TOUCH”

00:00:39.806 --> 00:00:43.544
我是Tyler Fox
稍後同事Peter Hajas會加入我

00:00:43.877 --> 00:00:46.113
我們都是UIKit團隊的
工程師

00:00:46.313 --> 00:00:49.349
我們今天非常激動地
告訴大家

00:00:49.449 --> 00:00:51.151
你們該怎樣採用3D Touch

00:00:51.318 --> 00:00:54.021
來把你應用的用戶體驗
提升到下一個等級

00:00:55.956 --> 00:00:58.292
我們今天
想以回顧一些

00:00:58.358 --> 00:01:00.060
3D Touch基本知識來開始

00:01:00.127 --> 00:01:02.896
並向你們演示
它如何跨系統穿越

00:01:04.031 --> 00:01:08.168
然後我們要談談
主屏幕快捷操作

00:01:08.869 --> 00:01:11.371
主屏幕快捷操作
是今天最簡單的方法之一

00:01:11.438 --> 00:01:13.907
讓你可以把3D Touch
加入你的應用

00:01:14.908 --> 00:01:17.277
它們讓用戶從
主屏幕直接跳到

00:01:17.544 --> 00:01:20.414
你的應用中的
那些關鍵活動

00:01:22.182 --> 00:01:24.985
然後
我們會談談Peek和Pop

00:01:26.119 --> 00:01:30.057
Peek和Pop是讓用戶
在你的應用中

00:01:30.123 --> 00:01:32.593
預覽和瀏覽內容的
無縫方式

00:01:33.393 --> 00:01:36.563
我們想大部分應用
都會從中極爲受益

00:01:36.630 --> 00:01:40.100
即把Peek和Pop
與支持一起加入你的內容中去

00:01:41.635 --> 00:01:43.737
最終 我們也很興奮
可以告訴你們大家

00:01:43.804 --> 00:01:48.342
關於UIPreviewInteraction的一切
這是iOS X中的全新API

00:01:48.709 --> 00:01:52.145
允許你爲你的應用
製作獨一無二的3D Touch

00:01:52.913 --> 00:01:55.649
這是給你們中的那些
想要對3D Touch的交互

00:01:56.016 --> 00:01:57.651
進行高級控制的人的

00:01:58.018 --> 00:02:00.854
並讓你使用與我們爲
Peek和Pop所磨鍊的

00:02:01.088 --> 00:02:03.156
同樣的壓力處理

00:02:03.657 --> 00:02:06.059
但請帶來你自己的
自定義用戶界面

00:02:06.360 --> 00:02:08.695
這真是太棒了
我們等不及要告訴你這一切

00:02:09.630 --> 00:02:14.468
讓我們開始吧
先來談談3D Touch

00:02:16.303 --> 00:02:20.374
支持3D Touch的設備
有一種力量敏感顯示器

00:02:20.974 --> 00:02:22.476
它可精確測量

00:02:22.543 --> 00:02:24.478
屏幕上的觸碰壓力

00:02:25.479 --> 00:02:29.116
現在的iOS一直讓用戶
在用戶界面上

00:02:29.183 --> 00:02:30.250
直接操作內容

00:02:31.251 --> 00:02:32.653
這一直是一個標誌

00:02:32.853 --> 00:02:34.721
因爲原始
iPhone是與其

00:02:35.289 --> 00:02:36.657
多點觸控顯示屏一起被引入

00:02:37.824 --> 00:02:40.127
但3D Touch更進一步
擴展了這一點

00:02:40.561 --> 00:02:45.265
允許用戶更密切的連接到
它們在屏幕上的內容

00:02:48.101 --> 00:02:50.637
讓我們來看看一些
3D Touch

00:02:50.704 --> 00:02:53.640
穿越操作系統所用的方法
首先是主屏幕

00:02:54.608 --> 00:02:56.243
當你按下某個應用圖標時

00:02:56.710 --> 00:02:59.413
我們就揭示
主屏幕快捷操作

00:03:00.314 --> 00:03:03.483
正如你在此用相機所看到的
這些讓你直接跳到

00:03:03.550 --> 00:03:06.053
你來執行的每個應用中的

00:03:06.420 --> 00:03:07.821
一些關鍵活動

00:03:08.055 --> 00:03:10.691
例如 用相機應用自拍

00:03:11.024 --> 00:03:14.361
使用前置攝像頭或用後置攝像頭

00:03:14.428 --> 00:03:15.929
拍張普通的照片

00:03:15.996 --> 00:03:18.365
錄製視頻或慢動作視頻

00:03:19.933 --> 00:03:24.905
現在iOS X中的新特性
如果你的應用提供了一個小工具

00:03:24.972 --> 00:03:27.975
它也將在主屏幕快捷操作
旁邊顯示

00:03:28.075 --> 00:03:30.410
當用戶3D接觸
你的應用圖標時

00:03:31.278 --> 00:03:34.014
另外還要注意的是
當你按下

00:03:34.081 --> 00:03:35.449
每個這樣的應用圖標時

00:03:35.682 --> 00:03:37.918
該設備正在播放
觸覺反饋

00:03:38.118 --> 00:03:40.320
來讓你知道
你何時達到閾值

00:03:40.420 --> 00:03:42.422
快速行動
將在何處彈開

00:03:44.391 --> 00:03:46.593
現在讓我們來看看消息

00:03:47.327 --> 00:03:50.731
從而來看看
Peek和Pop的一個例子

00:03:52.165 --> 00:03:55.135
在信息這裏你可以看到
我在與朋友的對話中

00:03:55.269 --> 00:03:56.737
收到了一張照片

00:03:58.038 --> 00:04:00.574
如果我開始對那張照片
輕輕施加壓力

00:04:01.041 --> 00:04:06.180
我就可以窺視它來揭露出
此內容的大型預覽

00:04:07.247 --> 00:04:10.684
然後如果我繼續施壓
我會直接彈在那張照片上

00:04:10.751 --> 00:04:14.354
這將使它鋪滿全屏
並讓我與它交互

00:04:14.421 --> 00:04:16.290
就像我按壓過它一樣

00:04:16.957 --> 00:04:20.394
Peek和Pop相當好
因爲它可以讓你

00:04:20.459 --> 00:04:23.630
預覽內容以及
也許改變主意

00:04:24.031 --> 00:04:26.333
並釋放你的觸控
而卻實際上不必

00:04:26.400 --> 00:04:28.569
去按壓返回按鈕
然後再返回

00:04:30.003 --> 00:04:31.672
現在這裏有一點要注意的是

00:04:32.306 --> 00:04:35.943
因爲我們爲Peek和Pop
跨越這兩個不同的閾值

00:04:36.643 --> 00:04:39.313
該設備再次
播放觸覺反饋

00:04:39.680 --> 00:04:42.649
來讓你知道
你何時已經達到這兩個閾值

00:04:44.351 --> 00:04:45.853
這就是Peek和Pop

00:04:46.486 --> 00:04:48.722
現在讓我們來看看Mail

00:04:49.489 --> 00:04:53.861
看看相同的交互中的
一些有趣的片段

00:04:54.595 --> 00:04:57.064
我希望你能注意到
3D Touch充分互動

00:04:57.164 --> 00:05:00.100
和中斷的能力

00:05:00.567 --> 00:05:02.569
我在屏幕上調節

00:05:02.636 --> 00:05:04.505
觸控壓力
你會在這裏看到

00:05:05.205 --> 00:05:08.542
我們使用模糊和縮放
效果來讓你知道

00:05:08.609 --> 00:05:11.245
你可以繼續
與此內容互動

00:05:11.645 --> 00:05:14.982
注意整個交互
的流暢性和響應度如何

00:05:15.415 --> 00:05:17.217
這是的標誌特性中的一個

00:05:17.484 --> 00:05:20.888
是它把3D Touch
和傳統觸控

00:05:20.954 --> 00:05:22.589
以及基於手勢的交互區分開的

00:05:24.424 --> 00:05:25.859
所以你可能會想

00:05:26.226 --> 00:05:28.662
我爲何要在我的應用中
支持3D Touch？

00:05:29.496 --> 00:05:31.865
3D Touch最好的
用途之一就是

00:05:32.332 --> 00:05:36.270
是它可以迅速加速
訪問你的應用已經提供了的

00:05:36.336 --> 00:05:37.905
現有功能

00:05:38.372 --> 00:05:41.475
你用主屏幕快捷操作
就此看到了一個很棒的例子

00:05:41.808 --> 00:05:44.144
讓用戶在你的應用裏直接進入那些屏幕

00:05:44.211 --> 00:05:48.015
就像深層鏈接並讓它們

00:05:48.081 --> 00:05:50.417
直接做出嘗試執行的行動

00:05:51.285 --> 00:05:53.887
但關於3D Touch
另一個真正偉大的的東西

00:05:54.321 --> 00:05:58.292
是它使得之前永遠不可能的
全新的身臨其境的交互

00:05:58.358 --> 00:06:00.027
變得有可能

00:06:01.295 --> 00:06:04.164
稍後當我們向你們展示一個很棒的例子

00:06:04.464 --> 00:06:08.068
提及這個新的
UIPreviewInteraction API時

00:06:09.937 --> 00:06:14.408
最後我們在iOS X的整個系統中
都採用了3D Touch

00:06:14.975 --> 00:06:18.612
因此用戶也希望
你們所有的應用都支持它

00:06:23.283 --> 00:06:24.585
讓我們繼續談談你如何

00:06:24.651 --> 00:06:27.020
從今天就開始通過
主屏幕快捷操作

00:06:27.087 --> 00:06:28.655
來採用3D Touch

00:06:29.423 --> 00:06:33.393
而要做到這一點
我想爲你介紹AppChat

00:06:34.361 --> 00:06:37.064
AppChat是一個示例應用
我們一直在努力使它

00:06:37.130 --> 00:06:39.199
在我們的應用中

00:06:39.266 --> 00:06:41.735
突出一些3D Touch的強大功能

00:06:42.936 --> 00:06:44.972
在這裏你可以看到3D Touch

00:06:45.272 --> 00:06:48.609
對不起 AppChat是一個
短消息應用

00:06:49.109 --> 00:06:52.312
你可以拍照並作爲聊天
發送給朋友 在這裏你可以

00:06:52.980 --> 00:06:56.250
看到我已經從朋友們那裏
收到一系列不同的聊天

00:06:56.316 --> 00:07:00.821
我可以按上其中任何一個
並全屏查看聊天記錄

00:07:04.024 --> 00:07:05.092
就這麼簡單

00:07:05.492 --> 00:07:08.462
AppChat是一個非常令人熟悉的
UIKit應用

00:07:09.530 --> 00:07:12.065
我們會向你展示
爲使3D Touch這麼做

00:07:12.132 --> 00:07:16.570
我們增加支持的不同方式
從主屏幕快捷操作開始

00:07:17.237 --> 00:07:19.373
所以當你按下
AppChat應用圖標時

00:07:19.806 --> 00:07:22.342
我們將爲AppChat揭露一些
主屏幕快捷操作

00:07:23.110 --> 00:07:25.345
你會注意到
我可以選擇創建一個新的聊天

00:07:25.412 --> 00:07:27.281
它會打開攝像頭
這樣我就可拍張照片

00:07:27.347 --> 00:07:29.449
然後從我的朋友中選擇一位
將其發送

00:07:30.350 --> 00:07:32.052
但我也可以選擇

00:07:32.119 --> 00:07:36.223
這裏底部的3種快速行動之一
它們是

00:07:36.290 --> 00:07:38.692
將讓我把聊天
直接發送給我的

00:07:38.759 --> 00:07:40.194
前三位朋友的快速行動

00:07:40.561 --> 00:07:42.996
我在AppChat中
交流最多的朋友

00:07:44.565 --> 00:07:46.633
所以實際上
有兩種不同類型的

00:07:46.700 --> 00:07:48.168
主屏幕快捷操作

00:07:48.569 --> 00:07:49.903
現在讓我們來談談它們

00:07:51.772 --> 00:07:54.508
第一類是靜態快捷操作

00:07:55.309 --> 00:07:58.011
這些是由你的應用在構建時
所規定的

00:07:58.745 --> 00:08:00.447
它們對在你的應用中一直可用的

00:08:00.514 --> 00:08:02.416
固定操作來說是很棒的

00:08:03.016 --> 00:08:07.487
例如用AppChat
我們有新聊天快捷操作

00:08:07.721 --> 00:08:09.223
我總能創建一個新的聊天

00:08:09.590 --> 00:08:11.592
然後將其發送到
我的朋友之一

00:08:12.092 --> 00:08:15.062
另一方面
我們有動態快捷操作

00:08:16.997 --> 00:08:19.700
動態快捷操作
也是偉大的 因爲它們允許你

00:08:19.766 --> 00:08:22.936
定製和定做
被顯示給用戶的快速操作

00:08:23.003 --> 00:08:26.106
但是讓我們首先來看看
靜態快捷操作

00:08:27.474 --> 00:08:30.978
靜態快捷操作定義
在你的應用的info.plist文件中

00:08:32.913 --> 00:08:34.147
因此一旦你的應用

00:08:34.214 --> 00:08:37.551
被安裝在用戶的設備上
它們就可用了

00:08:38.719 --> 00:08:40.287
現在讓我們來看看一個例子

00:08:40.354 --> 00:08:43.123
我們如何向AppChat添加
一個靜態快捷操作

00:08:44.057 --> 00:08:47.361
這是我們的info.plist文件
你可以看到只用幾行代碼

00:08:47.561 --> 00:08:49.796
我們就能夠創建

00:08:49.930 --> 00:08:51.765
並添加這個新聊天快捷操作

00:08:52.399 --> 00:08:53.767
我想在這裏
指出幾點

00:08:53.834 --> 00:08:55.903
你會注意到
我們在指定一個類型

00:08:56.436 --> 00:08:58.772
這是一個字符串
你的應用定義

00:08:59.106 --> 00:09:03.010
用戶選擇這些快速操作之一時
稍後你會用哪一個

00:09:03.310 --> 00:09:05.078
從而知道如何處理它

00:09:05.779 --> 00:09:08.782
在這種情況下我們還提供了
一個標題新聊天

00:09:09.583 --> 00:09:14.188
以及一個圖標類型
它是你可以顯示的

00:09:14.254 --> 00:09:16.823
系統提供的圖標之列表中的
一個常量

00:09:17.057 --> 00:09:19.560
這種情況下 我們就這樣
得到那個很好的聊天泡泡

00:09:21.695 --> 00:09:25.499
要記住一點 任何面對
你的信息plist.strings文件中

00:09:25.699 --> 00:09:29.036
字符串的用戶 你都該
使其本地化來作爲最佳實踐

00:09:31.004 --> 00:09:33.073
這就是靜態快捷操作
我們再來看看

00:09:33.140 --> 00:09:35.542
我之前避開談論的動態快捷操作

00:09:36.710 --> 00:09:40.480
因此這些是在運行時
由你的應用所定義的

00:09:40.714 --> 00:09:43.350
也同時從你的應用提供到系統

00:09:44.484 --> 00:09:47.287
其結果就是
它們只在用戶

00:09:47.354 --> 00:09:49.656
最初第一次啓動你的應用時
是可用的

00:09:51.358 --> 00:09:53.894
動態快捷操作

00:09:53.961 --> 00:09:57.231
會在任何靜態快捷操作
之後被顯示 在空間允許的前提下

00:09:57.698 --> 00:09:59.366
你總共只可顯示

00:09:59.433 --> 00:10:01.735
四個快速操作
在主屏幕上

00:10:02.202 --> 00:10:04.137
所以如果你打算確保留有空間

00:10:04.204 --> 00:10:07.441
爲任何動態快捷操作

00:10:09.943 --> 00:10:12.980
你還可以包括
一個可選的系統圖標 即

00:10:13.680 --> 00:10:17.150
使用你的應用中的模板圖像
而製作的自定義圖標

00:10:17.951 --> 00:10:21.922
或者你甚至可以
根據用戶地址簿中的聯繫人

00:10:22.122 --> 00:10:23.457
來創建一個圖標

00:10:24.491 --> 00:10:26.527
這就是AppChat正在做的
用來拉取

00:10:26.593 --> 00:10:29.062
那些漂亮的個人資料照片

00:10:29.129 --> 00:10:31.532
緊挨着這三個動態快捷操作

00:10:31.598 --> 00:10:33.066
排在前三名的朋友們

00:10:33.867 --> 00:10:35.536
讓我們看看
一些代碼

00:10:35.602 --> 00:10:37.671
來看看我們如何能夠
實現這一點

00:10:39.673 --> 00:10:43.076
那麼在這個例子中
我們將以尋找一個聯繫人開始

00:10:43.143 --> 00:10:45.445
該聯繫人應
匹配朋友Lexi Torres

00:10:48.081 --> 00:10:50.884
我們一定要做到的
第一件事情

00:10:51.151 --> 00:10:53.020
向用戶請求訪問聯繫人通訊錄的許可

00:10:53.387 --> 00:10:56.256
假設我們有了這個權限
我們可以繼續前進

00:10:56.990 --> 00:11:00.894
並實際查詢其聯繫人通訊錄
來尋找這位

00:11:01.061 --> 00:11:03.964
我們所感興趣的
姓名與這位朋友相匹配的聯繫人

00:11:04.932 --> 00:11:09.703
如果我們能有至少一個匹配
那麼我們就可以

00:11:10.170 --> 00:11:13.473
把該聯繫人發送給我們的
UIApplicationShortcutIcon初始程序

00:11:14.608 --> 00:11:18.312
這將繼續並創建我們
將以此快速操作而使用的圖標

00:11:19.346 --> 00:11:21.615
但是當然
我們可能沒有收到訪問許可

00:11:22.015 --> 00:11:24.117
來訪問該用戶的聯繫人通訊錄

00:11:24.651 --> 00:11:27.154
或者我們可能沒有
爲這個朋友找到匹配

00:11:27.454 --> 00:11:29.022
所以我們會希望有一個回退

00:11:29.189 --> 00:11:32.326
在這種情況下我們將使用
該系統的消息樣式

00:11:33.060 --> 00:11:34.761
作爲圖標來顯示

00:11:35.896 --> 00:11:37.965
現在我們有了這個圖標
我們就可以去創建

00:11:38.031 --> 00:11:40.267
我們實際的快速操作

00:11:40.767 --> 00:11:42.836
在這種情況下
我們需要指定類型

00:11:43.537 --> 00:11:46.139
這與你看待
靜態開始操作的方法非常相似

00:11:46.874 --> 00:11:49.810
除了副標題
我們還將用發送一個聊天

00:11:50.477 --> 00:11:51.745
然後我們將把所有這些

00:11:51.812 --> 00:11:55.315
發送到我們的
UIApplicationshortcutItem初始程序

00:11:55.382 --> 00:11:57.985
來創建我們第一個動態快捷操作

00:11:59.353 --> 00:12:03.223
從此 我們可以繼續如此操作
並重復無數次

00:12:03.857 --> 00:12:05.826
來創建任何額外的快速操作

00:12:05.959 --> 00:12:08.295
當我們完成後
我們將它們全部打包到

00:12:08.529 --> 00:12:11.131
一個漂亮的陣列中去
並將其發送到

00:12:11.665 --> 00:12:14.434
UIApplicationsShortcutItems
屬性中去

00:12:15.202 --> 00:12:16.103
其效果是

00:12:16.170 --> 00:12:19.673
向系統註冊這些
動態快捷操作

00:12:20.040 --> 00:12:22.276
以便它們可以顯示在主屏幕上

00:12:22.910 --> 00:12:24.077
有一點要記住的是

00:12:24.144 --> 00:12:28.148
這個shortcutItems屬性
只顯示你的應用

00:12:28.448 --> 00:12:31.185
僅包含你的應用的動態快捷項目

00:12:31.251 --> 00:12:32.719
或動態快捷操作

00:12:32.786 --> 00:12:34.855
靜態快捷操作只規定於

00:12:34.922 --> 00:12:37.691
你的info.plist之中
而不會被包含在那個陣列之中

00:12:39.359 --> 00:12:41.595
讓我們來看看
所有這一切

00:12:41.662 --> 00:12:43.030
回到主屏幕上是什麼樣子

00:12:43.730 --> 00:12:46.200
好極了
只需那幾行代碼

00:12:46.466 --> 00:12:49.503
我們能夠創建一個靜態快捷操作

00:12:49.837 --> 00:12:52.606
新聊天以及三個不同的
動態快捷操作

00:12:52.673 --> 00:12:54.808
我們排名前三朋友中的每個人

00:12:56.009 --> 00:12:58.345
然而我們現在
還得做一件事

00:12:58.412 --> 00:13:01.982
當然就是當用戶選擇了一個時
處理這些快速操作

00:13:02.449 --> 00:13:05.152
在此要記住
兩種不同的場景

00:13:05.652 --> 00:13:08.722
第一種是如果你的應用已經在運行

00:13:08.789 --> 00:13:11.091
而且正被激活 這意味着你的應用

00:13:11.158 --> 00:13:13.460
處於非活動狀態或暫停狀態

00:13:14.695 --> 00:13:17.297
在這種情況下
我們將使用回調於

00:13:17.364 --> 00:13:18.732
UIApplicationDelegate

00:13:19.166 --> 00:13:21.735
performActionForShortcutItem應用

00:13:21.802 --> 00:13:22.769
completionHandler

00:13:24.171 --> 00:13:27.307
在這裏我們將使用
shortcutItem 它被引入

00:13:27.708 --> 00:13:29.343
實際用於處理此快速操作

00:13:29.676 --> 00:13:32.012
這可能意味着很多東西
然而它取決於你的應用

00:13:32.079 --> 00:13:33.580
以及你有什麼快速操作

00:13:33.647 --> 00:13:36.350
但總的來說
你可能應該把用戶移動到

00:13:36.416 --> 00:13:38.819
你的應用中的
一個特定的屏幕上

00:13:40.387 --> 00:13:43.857
如果你處理快速操作
你應該確保

00:13:43.924 --> 00:13:46.026
調用completion handler
傳遞一個Bool

00:13:46.093 --> 00:13:49.062
即它應該表明你是否
實際上已經將其處理好了

00:13:50.497 --> 00:13:52.232
太好了 這是第一個場景

00:13:52.332 --> 00:13:54.168
我們考慮的第二個場景
若應用其實是

00:13:54.468 --> 00:13:58.305
作爲一個快速操作的結果
而被啓動的

00:13:58.672 --> 00:14:00.807
在這種情況下
我們的應用並沒有運行

00:14:01.909 --> 00:14:04.845
在這裏我們將在

00:14:04.912 --> 00:14:07.281
使用熟悉的didFinishLaunchingWithOptions
應用回調

00:14:07.347 --> 00:14:08.949
UIApplicationDelegate上

00:14:10.083 --> 00:14:13.520
在裏面我們將訪問
launchOptions字典的

00:14:13.787 --> 00:14:16.323
shortcutItem key
來看看

00:14:16.523 --> 00:14:19.059
我們的應用是否通過快速操作而啓動的

00:14:20.294 --> 00:14:23.463
如果的確如此 那麼我們
將處理這個快速操作

00:14:23.664 --> 00:14:25.566
正如我們以前做過的那樣

00:14:26.133 --> 00:14:29.169
然後我們將確保
用這個方法返回假

00:14:29.536 --> 00:14:32.706
告訴系統我們確實在此
真正處理了快速操作

00:14:33.006 --> 00:14:36.610
而它會阻止調用
上一張幻燈片中的方法

00:14:38.445 --> 00:14:41.448
這幾乎就是所有的一切

00:14:41.715 --> 00:14:45.118
就創建和處理動態與靜態
shortcutItems而言

00:14:45.385 --> 00:14:48.455
讓我們回顧一些最好的實踐
來把它們記住

00:14:49.857 --> 00:14:52.860
首先每一個應用應該提供快速操作

00:14:53.260 --> 00:14:55.395
因爲你在這裏可以看到
它們很容易被創建

00:14:55.495 --> 00:14:57.231
而它們可以提供巨大的價值

00:14:57.831 --> 00:15:00.367
直接顯示在主屏幕 讓用戶直接

00:15:00.434 --> 00:15:02.703
去到你的應用所提供的那些主要活動

00:15:04.505 --> 00:15:07.641
因此你要專注於
向你的應用所提供的

00:15:07.708 --> 00:15:10.444
最高值的任務
提供快速訪問

00:15:10.677 --> 00:15:13.180
記住你只有
4個不同的位置

00:15:13.514 --> 00:15:14.882
來顯示快速操作

00:15:15.282 --> 00:15:17.684
所以要明智決定
該選擇哪些

00:15:19.119 --> 00:15:20.420
我們的建議是

00:15:20.921 --> 00:15:24.625
當讓你的快速操作
保持可被預測非常重要時

00:15:24.691 --> 00:15:27.060
你可能該考慮使用動態快捷操作

00:15:27.995 --> 00:15:31.899
用戶將快速打開你的主屏幕快捷操作
並選擇其一

00:15:32.132 --> 00:15:34.768
如果你正在做諸如改變順序的事情

00:15:34.835 --> 00:15:36.904
這可能會
使你的用戶產生困惑

00:15:37.237 --> 00:15:39.640
他們會有一個
令人沮喪的體驗

00:15:41.909 --> 00:15:44.244
這裏要記住
一件有趣的事情

00:15:44.711 --> 00:15:47.681
你應該準備好去處理動態快捷操作

00:15:47.848 --> 00:15:50.150
你的應用先前版本

00:15:50.951 --> 00:15:52.653
如果你還記得的話

00:15:52.719 --> 00:15:56.356
原因是動態快捷操作
直到你的應用運行才生效

00:15:56.423 --> 00:15:58.725
並有能力
把它們提供給系統

00:15:59.426 --> 00:16:01.895
所以如果你的應用是近期剛剛更新的

00:16:02.262 --> 00:16:04.998
它仍顯示動態快捷操作

00:16:05.199 --> 00:16:06.466
之前版本的

00:16:07.367 --> 00:16:11.171
其結果是如果你的
快速操作的語義發生了變化

00:16:11.438 --> 00:16:14.474
則在處理時記住這一點
會是一個好主意

00:16:14.608 --> 00:16:16.276
而要做到這一點 你可能應該

00:16:16.343 --> 00:16:18.579
考慮把你的應用的版本號

00:16:18.812 --> 00:16:22.316
納入信息plist 抱歉
納入用戶信息字典

00:16:22.382 --> 00:16:25.052
可連同動態快捷操作
一起納入

00:16:26.687 --> 00:16:27.588
最後

00:16:27.921 --> 00:16:31.925
儘量不要添加只可使用
快速操作才能訪問的功能

00:16:32.092 --> 00:16:35.062
請記住並非我們所有的設備
都支持3D Touch

00:16:35.128 --> 00:16:38.899
即使是那些支持的設備
用戶也有選項在

00:16:38.966 --> 00:16:41.168
系統輔助功能設置中
禁用3D Touch

00:16:43.070 --> 00:16:45.138
對此
我想邀請Peter 上臺

00:16:45.205 --> 00:16:47.341
給你們大家講講
Peek和Pop

00:16:47.808 --> 00:16:48.775
Peter

00:16:52.479 --> 00:16:53.847
來吧

00:16:54.948 --> 00:16:56.149
謝謝你 Tyler

00:16:57.050 --> 00:17:01.388
我今天真的很高興
能跟大家講Peek和Pop

00:17:02.689 --> 00:17:07.728
正如之前Tyler給大家展示的一樣
Peek和Pop允許人們

00:17:07.895 --> 00:17:12.232
快速預覽和瀏覽你應用中的內容

00:17:12.799 --> 00:17:15.035
根據我個人的體驗
我可以說

00:17:15.301 --> 00:17:17.671
它會改變
你使用手機的方式

00:17:18.839 --> 00:17:23.410
我們講結合示例應用
來談談Peek和Pop

00:17:23.477 --> 00:17:26.613
示例應用就是指Tyler給你們
展示的AppChat

00:17:28.348 --> 00:17:30.918
正如Tyler給你們展示的一樣
在最後一節

00:17:31.451 --> 00:17:34.121
AppChat是一個標準的
UIKit應用

00:17:34.922 --> 00:17:37.724
所以在表格中
敲擊消息之一

00:17:39.226 --> 00:17:42.930
就會把我帶到該條消息
這樣我就可以全屏檢查了

00:17:44.064 --> 00:17:47.868
把Peek和Pop添加到
你應用的一般經驗法則

00:17:48.502 --> 00:17:52.539
是如果用戶
能夠訪問的內容

00:17:52.806 --> 00:17:54.174
可被按壓來導航

00:17:54.374 --> 00:17:57.244
它也應支持Peek和Pop

00:17:58.278 --> 00:18:00.480
因此讓我們向
AppChat應用該規則

00:18:02.482 --> 00:18:06.486
這意味着當我對此表中的
某個單元格施加壓力時

00:18:07.888 --> 00:18:09.857
我們應該得到一個快速的Peek

00:18:10.958 --> 00:18:14.761
在我們的API中
我們稱此爲預覽

00:18:15.062 --> 00:18:17.497
因爲我們會得到視圖控制器預覽

00:18:17.564 --> 00:18:19.233
而我們可以導航到視圖控制器

00:18:19.933 --> 00:18:22.002
現在如果我們繼續施加壓力

00:18:23.237 --> 00:18:24.738
那會彈出全屏

00:18:25.873 --> 00:18:27.808
我們就可以進行交互

00:18:28.575 --> 00:18:32.012
在我們的API中
我們稱此爲提交

00:18:32.479 --> 00:18:36.049
因爲我們已經提交導航到該視圖控制器

00:18:37.651 --> 00:18:39.920
好的 讓我們看一
Peek和Pop

00:18:40.020 --> 00:18:41.822
的組件吧

00:18:43.657 --> 00:18:46.960
首先且最重要的是我們有已註冊
View Controller

00:18:47.961 --> 00:18:49.296
就是這個視圖控制器

00:18:49.363 --> 00:18:51.765
包含了用戶
交互元素的

00:18:51.999 --> 00:18:53.567
視圖控制器

00:18:54.168 --> 00:18:57.638
在我們的例子裏 這些是
我們的信息表格單元格

00:18:59.339 --> 00:19:03.477
每個註冊了的視圖控制器
都有全系列來源

00:19:04.311 --> 00:19:06.747
它們是每一個

00:19:06.813 --> 00:19:09.516
有自己的視圖控制器
預覽界面元素

00:19:10.284 --> 00:19:15.155
在AppChat中 這自然適應
我們的聊天表格單元格

00:19:16.657 --> 00:19:17.558
最後

00:19:17.925 --> 00:19:20.127
我們有被預覽了的
視圖控制器

00:19:21.428 --> 00:19:24.965
這是將顯示預覽內容的
視圖控制器

00:19:25.365 --> 00:19:28.435
此預覽代表了
我們輸入表中的元素

00:19:29.503 --> 00:19:32.372
通常在按壓此內容後

00:19:32.439 --> 00:19:34.041
這和我們要展示的元素相同

00:19:34.541 --> 00:19:35.943
按壓它

00:19:36.343 --> 00:19:38.612
並通過施加壓力
預覽它

00:19:39.313 --> 00:19:40.714
向我們展示相同的內容

00:19:42.216 --> 00:19:45.219
所以這樣的話
我要一步一步來講一下

00:19:45.619 --> 00:19:48.722
我們用什麼和如何
把Peek和Pop添加到AppChat中去

00:19:48.922 --> 00:19:52.559
這將密切反映你將如何
把Peek和Pop添加到你應用中去

00:20:03.337 --> 00:20:06.240
所以在我們註冊了的
視圖控制器開始

00:20:06.540 --> 00:20:09.209
記住這就是
視圖控制器表格

00:20:09.376 --> 00:20:12.079
其中包含了我們的
演示文稿的源視圖

00:20:14.047 --> 00:20:15.349
我們要遵循

00:20:15.482 --> 00:20:19.520
UIViewControllerPreviewing
Delegate協議

00:20:20.487 --> 00:20:22.222
此代理將在

00:20:22.289 --> 00:20:26.126
Peek和Pop交互中的
不同階段被召回

00:20:26.426 --> 00:20:28.695
來將信息提供給該系統

00:20:29.463 --> 00:20:31.231
這是相當容易實現的

00:20:32.566 --> 00:20:36.003
接下來我們將要確保我們
registerForPreviewing

00:20:36.803 --> 00:20:39.740
進行此操作的很棒時機是
在viewDidLoad中時

00:20:41.441 --> 00:20:43.377
我們要
registerForPreviewing

00:20:43.510 --> 00:20:45.245
並用我們自己做代理

00:20:45.812 --> 00:20:48.448
遞交我們的表視圖
作爲源視圖

00:20:48.982 --> 00:20:51.718
因爲表視圖
是我們想預覽的

00:20:51.952 --> 00:20:55.422
所有接口元素的
共同祖先

00:20:57.457 --> 00:21:02.496
現在讓我們繼續
並在預覽代理協議中實施

00:21:02.663 --> 00:21:04.598
兩種必要的代理方法

00:21:05.365 --> 00:21:06.366
第一種

00:21:08.702 --> 00:21:09.970
是用於提供

00:21:11.638 --> 00:21:13.440
一個預覽
視圖控制器

00:21:14.641 --> 00:21:16.443
提供一個
視圖控制器

00:21:16.510 --> 00:21:20.347
在源視圖內的
一個特定位置

00:21:23.016 --> 00:21:25.352
該方法被稱爲
previewingContext

00:21:25.485 --> 00:21:27.354
ViewControllerForLocation

00:21:28.155 --> 00:21:29.423
而且它是很容易實施的

00:21:30.891 --> 00:21:34.628
首先我們要找到indexPath
它代表了

00:21:34.962 --> 00:21:37.197
我們通過該代理方法
而被遞交的點

00:21:37.865 --> 00:21:40.467
我們可通過點擊
測試表視圖來如此操作

00:21:42.803 --> 00:21:45.606
下一步我們要創建
一個視圖控制器

00:21:45.939 --> 00:21:49.810
使用的模型對象
由indexPath所代表

00:21:50.811 --> 00:21:53.113
這是你可能已經有了的
一種邏輯

00:21:53.180 --> 00:21:55.349
並確實在indexPath中
選擇了行

00:21:57.451 --> 00:21:59.820
其次非常重要的一點是

00:22:00.220 --> 00:22:01.889
我們要設置

00:22:02.022 --> 00:22:03.590
previewingContext的
sourceRect

00:22:04.291 --> 00:22:07.694
請記住源視圖
是整個表視圖

00:22:08.295 --> 00:22:11.298
而我們要確保
從屏幕上僅僅突顯單元格

00:22:11.565 --> 00:22:15.736
用的是Tyler向大家
所展示了的

00:22:15.802 --> 00:22:17.070
模糊效應和規模效應

00:22:17.671 --> 00:22:20.774
通過設置sourceRect
系統會適當地

00:22:20.941 --> 00:22:23.577
切出該元素
然後將其在屏幕上突顯

00:22:23.677 --> 00:22:24.945
它看起來真的很棒

00:22:26.079 --> 00:22:29.816
最後把視圖控制器
返回到系統中去

00:22:31.051 --> 00:22:34.354
現在關於這個代理方法
我想爲你們指出

00:22:34.421 --> 00:22:37.391
兩個相當重要的部分

00:22:39.426 --> 00:22:43.530
第一個是該方法
將在每次

00:22:43.697 --> 00:22:46.233
我們認爲我們將
啓動預覽時被調用

00:22:47.301 --> 00:22:51.772
正如Tyler之前所說的
我們希望保持交互快速與流暢

00:22:52.005 --> 00:22:54.007
所以我們要伺機將其調用

00:22:54.174 --> 00:22:55.742
以確保一切都準備好了

00:22:57.377 --> 00:23:01.348
因此使用此方法返回
一個視圖控制器時

00:23:01.715 --> 00:23:04.151
你需要確保
一定不要花太多時間

00:23:05.085 --> 00:23:07.387
如果你有可以
在後臺做的異步工作

00:23:07.487 --> 00:23:10.891
則在準備此視圖控制器之前

00:23:11.358 --> 00:23:14.294
在後臺做此工作
並不要阻塞主隊列

00:23:15.262 --> 00:23:18.732
這樣當我們

00:23:19.032 --> 00:23:20.567
向你應用中的界面元素施加壓力時

00:23:20.801 --> 00:23:23.003
會有快速、流暢
和反應靈敏的感覺

00:23:24.238 --> 00:23:27.207
我給你們關於此方法的
第二個重要建議

00:23:27.307 --> 00:23:29.676
是它的返回類型

00:23:30.410 --> 00:23:32.813
UIViewControllerOptional

00:23:33.313 --> 00:23:35.182
這意味着我們可以返回零值

00:23:36.116 --> 00:23:37.918
如果你用這個方法返回零值

00:23:38.318 --> 00:23:40.621
我們將不會從屏幕上
突顯任何單元格

00:23:40.821 --> 00:23:43.724
我們將不會做任何模糊處理
我們將不會做任何觸覺反饋

00:23:43.957 --> 00:23:45.325
我們將不會做預覽

00:23:46.593 --> 00:23:48.862
但是你應該確保

00:23:48.929 --> 00:23:52.232
只有當在該位置確實沒東西來預覽時
才返回零值

00:23:54.034 --> 00:23:56.803
你應該確保
你應用中的外觀相似的內容

00:23:57.070 --> 00:23:59.139
可以用相似的方式來預覽

00:23:59.873 --> 00:24:01.942
這樣人們就不必爲了試圖
得到一個預覽

00:24:02.009 --> 00:24:04.711
而擠壓手機
因爲外觀相似的東西

00:24:04.778 --> 00:24:06.747
將被用相似的方式來預覽

00:24:07.781 --> 00:24:09.616
太好了

00:24:10.384 --> 00:24:14.388
這樣我們就已經實現了
這種交互的預覽部分

00:24:23.030 --> 00:24:24.131
但我們還沒全部搞定

00:24:24.464 --> 00:24:27.100
我們需要就此協議
實施第二種所需的方法

00:24:27.167 --> 00:24:30.504
即用於提供提交

00:24:31.605 --> 00:24:33.740
這一種方法更易於實施

00:24:34.808 --> 00:24:38.245
它被稱爲previewingContext
commitViewController

00:24:39.279 --> 00:24:42.182
需要提交時
它將被系統所調用

00:24:42.549 --> 00:24:44.318
我們已經過了此壓力闕值

00:24:44.384 --> 00:24:46.486
我們要設置一些觸覺反饋

00:24:46.553 --> 00:24:49.089
我們在屏幕上
顯示視圖控制器

00:24:51.458 --> 00:24:54.261
在這裏我們要盡一切努力

00:24:54.328 --> 00:24:56.196
使這個視圖控制器
在屏幕上顯示

00:24:56.930 --> 00:25:00.934
AppChat是個使用導航控制器的
簡單的UIKit應用

00:25:01.435 --> 00:25:03.737
所以我們只是要調用顯示

00:25:04.938 --> 00:25:06.840
這將有將

00:25:06.907 --> 00:25:09.543
視圖控制器推送到
導航堆棧的默認效果

00:25:10.010 --> 00:25:12.646
但是這個方法
有一些真的很酷的地方

00:25:13.046 --> 00:25:16.183
UIKit對它的操作
使得你可以在此回調中

00:25:16.250 --> 00:25:19.052
執行任何類型的
視圖控制器轉換

00:25:19.720 --> 00:25:23.690
推送東西到導航堆棧
做一個自定義介紹

00:25:24.057 --> 00:25:27.027
甚把視圖控制器
移動到一自定義容器中

00:25:27.961 --> 00:25:30.831
在你的應用中 盡一切努力

00:25:30.998 --> 00:25:32.833
使這個視圖控制器
在屏幕上顯示

00:25:33.133 --> 00:25:36.036
而UIKit將代表你
來處理動畫方面的事宜

00:25:37.004 --> 00:25:40.641
好 我們已實施了對
視圖控制器的提交

00:25:41.542 --> 00:25:44.778
而現在我們已經得到
這個超讚的提交

00:25:46.013 --> 00:25:48.515
這將使我們能夠
全屏導航

00:25:48.682 --> 00:25:50.851
並開始與內容的交互

00:25:52.886 --> 00:25:55.322
我們已嚮應用
添加了Peek和Pop

00:25:56.089 --> 00:25:58.058
但我們可以做一點點
額外的工作

00:25:58.192 --> 00:25:59.826
來把體驗提升到

00:26:01.161 --> 00:26:02.229
下一個級別

00:26:05.866 --> 00:26:08.302
Peek和Pop的
另一個很酷之處

00:26:08.602 --> 00:26:10.170
是預覽快速操作

00:26:10.671 --> 00:26:13.941
而通過添加這些到你的應用中去
你可以允許用戶

00:26:14.007 --> 00:26:16.410
訪問最常用的一些操作

00:26:16.643 --> 00:26:18.645
並在預覽內顯示內容

00:26:19.413 --> 00:26:21.682
這真的很強大
並可以讓用戶

00:26:21.748 --> 00:26:24.418
以甚至比以前更快的速度
使用你的應用

00:26:25.919 --> 00:26:28.722
如果我們回到我們熟悉的
架構圖

00:26:29.489 --> 00:26:32.326
我們將看到這些
預覽快速操作

00:26:32.526 --> 00:26:34.294
屬於被預覽了的視圖控制器

00:26:35.495 --> 00:26:38.932
這是能夠響應這些操作的視圖控制器

00:26:39.433 --> 00:26:43.103
因其對視圖控制器
所示內容進行操作

00:26:44.104 --> 00:26:45.439
這些都很容易添加

00:26:46.340 --> 00:26:47.441
我們要做的就是在

00:26:47.708 --> 00:26:52.145
UIViewController中
覆寫預覽操作項目功能

00:26:53.146 --> 00:26:56.350
這將返回一個
UIPreviewActionItems陣列

00:26:58.252 --> 00:27:02.089
我們可以創建
UIPreviewActions

00:27:02.155 --> 00:27:04.091
使用你可能已經熟悉了的API

00:27:04.791 --> 00:27:09.296
它類似於UIAlertAction
和UITableViewRowAction

00:27:10.130 --> 00:27:15.736
你只是傳遞標題、風格、和結尾
而我們會

00:27:15.802 --> 00:27:18.939
在用戶選擇該操作時
調用該結尾

00:27:20.440 --> 00:27:22.910
接下來我們就
返回該操作陣列

00:27:22.976 --> 00:27:25.078
到系統中去

00:27:26.180 --> 00:27:29.883
現在我們已經有了
一個使用heart的操作

00:27:30.184 --> 00:27:32.920
但AppChat讓你回覆
一大堆的表情符號

00:27:33.754 --> 00:27:36.523
所以我們真正想要做的是
把這些表情圖案

00:27:36.823 --> 00:27:39.226
分到一組操作中去

00:27:40.527 --> 00:27:44.831
我們對此也有API
通過UIPreviewActionGroup即可

00:27:46.767 --> 00:27:50.537
你所要做的就是創建
一個預覽操作陣列

00:27:51.371 --> 00:27:54.141
在這裏我們有所有的
你可以用於迴應的表情符號

00:27:55.275 --> 00:27:59.780
然後用標題、風格以及
這些操作的陣列

00:28:00.047 --> 00:28:01.982
創建一個操作組

00:28:02.883 --> 00:28:04.284
這是個很棒的方式
你可用它

00:28:04.351 --> 00:28:08.255
來在你的預覽快速操作中
對關聯操作進行分組

00:28:09.790 --> 00:28:11.725
有適用於
預覽操作API的

00:28:12.092 --> 00:28:16.296
兩個其他重要部件
它們也很方便

00:28:20.067 --> 00:28:22.402
這是通過對預覽操作項目的
風格枚舉

00:28:22.503 --> 00:28:23.704
而完成的

00:28:25.239 --> 00:28:27.407
第一個是所選擇的樣式

00:28:27.674 --> 00:28:31.078
這將在此項目旁邊
顯示一個小小的已檢查標記

00:28:31.545 --> 00:28:33.981
讓用戶知道
他們之前可能已經選擇過了

00:28:34.047 --> 00:28:35.449
該選項

00:28:36.149 --> 00:28:38.252
在我們推出beta 1版本之前

00:28:38.352 --> 00:28:40.187
那個已檢查標記
有點害羞

00:28:40.354 --> 00:28:42.956
所以你會注意到它不在
第一個版本中

00:28:43.123 --> 00:28:45.092
但放心
這個錯誤將會被修復

00:28:46.960 --> 00:28:49.129
另一個真的使用起來
得心應手的樣式

00:28:49.196 --> 00:28:52.699
是破壞性的樣式
我們可以用它來指示

00:28:52.766 --> 00:28:55.636
某操作可能
執行一個破壞性行爲

00:28:56.236 --> 00:28:59.106
你可以從我背後的
阻止操作中看到這一點

00:28:59.473 --> 00:29:02.543
通過添加Peek和Pop
並預覽快速操作

00:29:02.776 --> 00:29:05.412
我們已經把你應用中的體驗提升到了

00:29:05.679 --> 00:29:08.549
下一個高度
並加快了你的用戶

00:29:08.615 --> 00:29:09.950
可以擁有的交互

00:29:10.884 --> 00:29:13.220
讓我們回顧一下
把Peek和Pop

00:29:13.353 --> 00:29:15.422
添加到你應用中去的一些最佳實踐

00:29:18.292 --> 00:29:21.428
首先最重要的是
記住經驗法則

00:29:22.396 --> 00:29:27.367
可以被按壓的內容
還應支持Peek和Pop

00:29:27.768 --> 00:29:30.170
你可以看一下Apple的系統應用

00:29:30.437 --> 00:29:32.873
那裏有很棒的提示
來告訴你如何做到這一點

00:29:34.341 --> 00:29:35.209
接下來

00:29:36.043 --> 00:29:38.612
確保始終從代理回調
返回一個

00:29:38.679 --> 00:29:41.849
預覽視圖控制器

00:29:42.616 --> 00:29:47.254
你應用中的外觀類似的內容
應當能被以類似的方式預覽

00:29:49.122 --> 00:29:52.092
在同一預覽背景回調中

00:29:52.559 --> 00:29:54.261
確保不要花太長時間

00:29:54.895 --> 00:29:57.831
請記住我們不想
阻止主隊列

00:29:57.931 --> 00:30:01.602
因爲我們希望這種交互
保持流暢和響應

00:30:03.504 --> 00:30:07.107
確保設置好預覽背景的
sourceRect

00:30:07.508 --> 00:30:11.078
來在屏幕上突出相應的
用戶界面元素

00:30:12.613 --> 00:30:14.781
Peek和Pop
部分就講完了

00:30:15.682 --> 00:30:17.751
現在我想把注意力轉移到

00:30:17.985 --> 00:30:21.421
iOS X中一些超級炫酷的新API

00:30:22.289 --> 00:30:23.790
UIPreviewInteraction

00:30:24.725 --> 00:30:29.196
UIPreviewInteraction讓你
感受Peek和Pop的感覺

00:30:29.730 --> 00:30:32.666
即壓力處理
和觸覺反饋

00:30:33.200 --> 00:30:35.636
但你可以使用
你自己的用戶界面

00:30:36.236 --> 00:30:40.174
正如我們不久就將看到的一樣
這是一個相當強大的概念

00:30:40.674 --> 00:30:41.942
讓我們來看一個例子

00:30:43.644 --> 00:30:46.413
在AppChat中的
我們的聊天細節視圖中

00:30:46.847 --> 00:30:49.783
我們已經在底部有了
這個方便的回覆按鈕

00:30:51.752 --> 00:30:54.221
在沒有啓動3D Touch
功能的設備上

00:30:54.521 --> 00:30:56.490
我們可以按壓此回覆按鈕

00:30:57.224 --> 00:30:59.927
來得到可以用於回覆的
表情符號的完整列表

00:31:01.094 --> 00:31:03.430
然後我們可以按壓
這些表情符號之一

00:31:04.531 --> 00:31:05.933
把它送回給我們的朋友

00:31:09.303 --> 00:31:11.772
但在啓動了3D Touch
功能的設備上

00:31:12.272 --> 00:31:16.109
我們可以把這種交互做得
更流暢和更有趣

00:31:17.477 --> 00:31:20.681
只需使用UIPreviewInteraction
做幾行代碼

00:31:21.782 --> 00:31:23.517
我們就添加了
一些相當整潔的內容

00:31:25.152 --> 00:31:27.821
我們可以
對此回覆按鈕施加壓力

00:31:28.255 --> 00:31:30.624
並以交互方式
展示該表單

00:31:30.958 --> 00:31:33.227
注意模糊效果是如何
淡入淡出的

00:31:34.194 --> 00:31:37.898
然後在保持我的
手指在屏幕下方的同時

00:31:38.398 --> 00:31:42.436
我可以左右滑動來挑選
一個表情符號用於回覆

00:31:43.403 --> 00:31:45.105
但願我們不會選到魔鬼

00:31:45.973 --> 00:31:47.941
然後我們會把它送回給
我們的朋友

00:31:48.876 --> 00:31:51.345
這種類型的一觸式交互

00:31:51.845 --> 00:31:54.448
是3D Touch所完美適用的

00:31:56.116 --> 00:31:58.952
3D Touch可以幫助我們的
另一件事

00:31:59.453 --> 00:32:01.121
是加速

00:32:01.855 --> 00:32:04.258
可更靠近用戶手指的操作

00:32:05.359 --> 00:32:09.229
在iOS 7中
我們增加了滑動收回手勢

00:32:09.363 --> 00:32:11.431
作爲返回按鈕的一種替代

00:32:12.366 --> 00:32:15.102
這就更方便了
因爲它就在你的手指旁邊

00:32:15.169 --> 00:32:17.337
你可以將它移動到屏幕邊緣

00:32:17.404 --> 00:32:19.573
然後向後滑動

00:32:20.507 --> 00:32:23.544
並且通過3D Touch
我們可以把這種便利

00:32:23.644 --> 00:32:25.145
添加到你應用的交互中去

00:32:26.213 --> 00:32:29.349
所以我們可在這張照片中的
任何地方真正應用3D Touch

00:32:30.083 --> 00:32:32.653
來交互地帶出
此回覆表單

00:32:34.121 --> 00:32:37.391
然後我們實際上可以
通過多用力

00:32:37.858 --> 00:32:39.359
來提交此會被打開的回覆表單

00:32:39.893 --> 00:32:42.596
然後再選擇一個
表情符號用於回覆

00:32:44.364 --> 00:32:46.600
這種類型的豐富交互

00:32:47.201 --> 00:32:51.004
它可以讓人有
更流暢更快的感受

00:32:51.405 --> 00:32:54.341
正是我們希望你會用
UIPreviewInteraction

00:32:54.408 --> 00:32:56.109
所構建的東西

00:33:04.651 --> 00:33:08.989
UIPreviewInteraction
採用的Peek和Pop壓力處理

00:33:09.056 --> 00:33:11.425
與我們已通過系統所提供的
Peek和Pop的用戶界面

00:33:11.558 --> 00:33:13.861
所磨練時採用的
Peek和Pop壓力處理相同

00:33:15.028 --> 00:33:18.832
我們在交互的各個階段
移動時的自動觸覺反饋

00:33:18.899 --> 00:33:22.569
但允許你的應用

00:33:22.636 --> 00:33:24.204
使用其自己的用戶界面

00:33:24.771 --> 00:33:26.907
而有關這一點
真正令人興奮的是

00:33:27.307 --> 00:33:31.512
人們現可爲Peek和Pop
構建肌肉記憶

00:33:32.145 --> 00:33:34.181
並將此肌肉記憶應用於

00:33:34.548 --> 00:33:36.950
系統的標準預覽外觀

00:33:37.751 --> 00:33:41.188
並也應用於你將使用

00:33:41.421 --> 00:33:42.923
UIPreviewInteraction
所構建的自定義交互

00:33:43.790 --> 00:33:47.094
而且此肌肉記憶
將是普遍適用的

00:33:47.761 --> 00:33:49.062
這真的很酷

00:33:50.130 --> 00:33:51.932
因此讓我們一步一步

00:33:52.232 --> 00:33:57.604
講解你可以如何
向你應用添加預覽交互

00:33:59.540 --> 00:34:01.775
我們將以遵循

00:34:02.042 --> 00:34:05.546
UIPreviewInteractionDelegate協議
作爲開始

00:34:06.313 --> 00:34:07.915
此代理

00:34:07.981 --> 00:34:10.984
將在預覽交互中的各個階段
被告知

00:34:11.251 --> 00:34:12.619
來讓你知道發生了什麼事情

00:34:13.754 --> 00:34:17.224
接下來我們想要確保
創建我們的預覽交互

00:34:18.525 --> 00:34:21.161
再次 viewDidLoad
是進行此操作的很棒時機

00:34:21.929 --> 00:34:25.666
在這裏我們用源視圖
創建了一個預覽交互

00:34:26.567 --> 00:34:28.534
並設置我們自己
作爲代表

00:34:30.437 --> 00:34:34.408
現在要講的是預覽交互
它純粹是關於狀態轉換

00:34:34.942 --> 00:34:37.511
讓我們講講
這些狀態轉換是如何工作的

00:34:39.146 --> 00:34:40.681
當交互開始時

00:34:41.047 --> 00:34:44.717
如果你的代理實施
可選的預覽交互

00:34:44.952 --> 00:34:46.719
應開始回調

00:34:48.487 --> 00:34:51.091
我們將調用它
或者如果你不這樣做

00:34:51.525 --> 00:34:52.993
我們將開始交互

00:34:53.860 --> 00:34:58.465
現在隨着壓力從交互開始

00:34:58.866 --> 00:35:00.367
向預覽狀態移動

00:35:01.068 --> 00:35:04.571
我們用previewInteraction
向你的代理髮回信息

00:35:04.905 --> 00:35:07.474
didUpdatePreviewTransition:ended

00:35:08.542 --> 00:35:09.376
來查查看

00:35:10.310 --> 00:35:12.713
這些壓力進程更新

00:35:12.779 --> 00:35:15.482
被賦予一個從零到一的歸一化值

00:35:15.983 --> 00:35:17.851
而真正要強調的重點是

00:35:17.918 --> 00:35:21.021
這不僅僅是
壓力的直接轉換

00:35:21.922 --> 00:35:24.424
因爲它使用
我們爲Peek和Pop

00:35:24.491 --> 00:35:28.896
所開發的算法
我們實際上是檢測用戶的意圖

00:35:29.763 --> 00:35:32.733
因此這不僅僅是
簡單的壓力轉換

00:35:34.234 --> 00:35:38.405
當我們在這兩種壓力狀態
之間移動時

00:35:38.472 --> 00:35:41.875
我們將在每一步都
被通過交互而通知以

00:35:42.075 --> 00:35:43.076
我們目前的進度

00:35:43.977 --> 00:35:46.513
而一旦我們達到
預覽的目標狀態

00:35:47.514 --> 00:35:50.350
我們就會得到消息
因爲進度將移動到一

00:35:51.251 --> 00:35:53.720
並且結束參數也將爲真

00:35:55.155 --> 00:35:58.859
而且該裝置也將自動播放
觸覺反饋

00:36:00.127 --> 00:36:03.163
讓我們來看看
此方法施用的一個示例

00:36:05.098 --> 00:36:07.501
同樣的 方法是
previewInteraction

00:36:07.734 --> 00:36:10.270
didUpdatePreviewTransition:ended

00:36:11.471 --> 00:36:14.107
在這裏我們只是
要通過轉換

00:36:14.174 --> 00:36:17.211
來就目前的進度
給自己更新

00:36:18.212 --> 00:36:22.015
現在請注意這其實是即插即用

00:36:22.082 --> 00:36:23.417
對許多UIKit的技術

00:36:24.017 --> 00:36:27.454
我們可用它驅動
UIViewPropertyAnimator

00:36:27.821 --> 00:36:29.923
一個百分比驅動的交互轉變

00:36:30.157 --> 00:36:32.426
或者甚至一個UIKit動態系統

00:36:33.660 --> 00:36:36.563
這些爲狀態轉換
所做的瞬時更新

00:36:36.830 --> 00:36:38.699
適用於所有這些技術

00:36:39.933 --> 00:36:41.869
並且如果交互結束

00:36:42.302 --> 00:36:45.873
我們將希望展示
我們已完成了的預覽外觀

00:36:46.540 --> 00:36:49.209
這是第一個所需的代理方法

00:36:49.443 --> 00:36:50.844
在UIPreviewInteraction上

00:36:51.912 --> 00:36:55.115
第二個是爲了對取消做出響應

00:36:55.716 --> 00:36:59.019
它被稱作
previewInteractionDidCancel

00:37:00.187 --> 00:37:03.423
每當用戶擡起手指
或者如果因爲任何

00:37:03.891 --> 00:37:06.994
其他原因交互應被取消
這都將被調用

00:37:07.194 --> 00:37:13.467
例如我們接到一個電話
在這裏我們將把

00:37:13.667 --> 00:37:16.370
我們的進度設置回零
並重置我們自己至最初的外觀

00:37:17.337 --> 00:37:20.774
但是請注意我們是在
一個動畫包內如此行動的

00:37:21.708 --> 00:37:24.678
我們將要把我們自己
做成動畫回去休息

00:37:24.912 --> 00:37:27.781
從而當我們擡起手指時
我們可以避免東西在周圍閃爍

00:37:29.983 --> 00:37:33.453
所以這就是我們應對
預覽狀態轉換的方法

00:37:34.688 --> 00:37:38.091
但要記住在AppChat中
我們也想對

00:37:38.292 --> 00:37:39.993
提交狀態轉換進行迴應

00:37:40.394 --> 00:37:42.396
來把我們的內容粘在屏幕上

00:37:43.997 --> 00:37:46.533
我們可以採用
可選的代理方法

00:37:47.100 --> 00:37:50.971
previewInteraction
didUpdateCommitTransition:ended

00:37:51.405 --> 00:37:53.774
來通過提交對我們的進度
做出迴應

00:37:55.742 --> 00:37:58.579
所以當我們在
交互之初

00:37:58.946 --> 00:38:00.214
和預覽狀態之間時

00:38:00.914 --> 00:38:04.017
我們會回調
didUpdatePreviewTransition

00:38:05.352 --> 00:38:07.421
一旦我們達到
預覽的目標狀態

00:38:08.255 --> 00:38:12.526
我們就會通過值爲一的進度值
以及一個爲真的結束值

00:38:12.993 --> 00:38:15.362
而我們也將播放
一些觸覺反饋

00:38:16.463 --> 00:38:18.532
然後我們將開始
發送消息

00:38:18.799 --> 00:38:22.970
到didUpdateCommitTransition:ended

00:38:23.270 --> 00:38:25.205
且有預覽進度用於提交

00:38:27.140 --> 00:38:29.443
這是同一類的進度更新

00:38:29.710 --> 00:38:31.712
歸一化值從零到一

00:38:32.679 --> 00:38:35.816
而且一旦我們達到了
提交的目標狀態

00:38:36.517 --> 00:38:40.721
我們會通過讓已經結束的
一個的進度值爲真

00:38:40.888 --> 00:38:44.558
我們會再播放另一條不同的
觸覺反饋

00:38:46.727 --> 00:38:50.230
讓我們來講講
你可能會採用此方法的方式

00:38:52.533 --> 00:38:54.001
那麼在我們實施

00:38:54.434 --> 00:38:58.138
previewInteraction
didUpdateCommitTransition:ended時

00:38:58.939 --> 00:39:01.942
在這裏我們要更新
我們對提交的進度

00:39:02.442 --> 00:39:04.912
同樣這適用於

00:39:05.045 --> 00:39:07.748
整個UIKit中
動畫和動態API套件

00:39:09.049 --> 00:39:11.185
一旦交互結束

00:39:11.685 --> 00:39:14.922
我們將只展示我們
已完成了的提交外觀

00:39:16.123 --> 00:39:18.458
關於UIPreviewInteraction
就講到這裏

00:39:19.493 --> 00:39:23.096
現在如果你正在構建
一個遊戲或繪圖應用

00:39:24.031 --> 00:39:27.367
有一些你可以使用的
低級壓力API

00:39:29.469 --> 00:39:32.506
此API提供標準化的訪問

00:39:32.606 --> 00:39:36.810
給與每個UITouchObject
一起進來的壓力值

00:39:37.211 --> 00:39:39.313
通過UITouch上的兩個屬性

00:39:39.746 --> 00:39:42.516
壓力和maximumPossibleForce

00:39:43.851 --> 00:39:46.653
這些值將被用於填充
所有

00:39:46.720 --> 00:39:50.224
支持3D Touch的設備
以及來自

00:39:50.290 --> 00:39:53.093
支持Apple Pencil的
Apple Pencil觸控

00:39:54.228 --> 00:39:57.631
而在此我們不會進一步
詳細說明 相反

00:39:57.965 --> 00:39:59.633
我鼓勵查看iOS Talk上的

00:39:59.933 --> 00:40:02.769
關於撬動觸控輸入的視頻

00:40:03.036 --> 00:40:06.974
這是一個非常棒的演講
並深入講解了這些API

00:40:08.308 --> 00:40:09.409
現在讓我們回顧一下

00:40:10.477 --> 00:40:12.112
如Tyler之前向你們展示

00:40:12.779 --> 00:40:16.950
主屏幕快捷操作
允許你的用戶直接跳進

00:40:17.251 --> 00:40:20.320
在你的應用內的許多常見活動的操作

00:40:21.154 --> 00:40:23.790
而大多數的應用
將真正受益於

00:40:23.857 --> 00:40:25.893
添加主屏幕快捷操作

00:40:26.994 --> 00:40:32.332
接下來我介紹了
Peek和Pop如何

00:40:32.399 --> 00:40:36.270
前所未有地允許無縫的流暢
且快速的交互並讓用戶

00:40:36.336 --> 00:40:38.772
與你的應用
以一種全新的方式進行交互

00:40:39.773 --> 00:40:43.844
我們認爲許多應用將的確
從添加Peek和Pop受益

00:40:45.812 --> 00:40:49.049
最後 我們檢視了
UIPreviewInteraction

00:40:49.917 --> 00:40:52.786
它可以讓你在新的深度探索
3D Touch這個海洋

00:40:52.853 --> 00:40:56.590
並真的很好的檢視了

00:40:56.723 --> 00:40:59.059
多點觸控的下一個維度

00:41:00.594 --> 00:41:05.632
最後需要注意的很重要的一點
用戶會期望其設備上的

00:41:05.699 --> 00:41:07.835
所有的應用都支持3D touch

00:41:08.368 --> 00:41:11.471
所以我們強烈建議
你採用這些功能

00:41:12.906 --> 00:41:16.677
要了解更多信息
並下載AppChat示例應用

00:41:16.743 --> 00:41:18.745
我們在整個演講中
向你展示了這個應用

00:41:18.946 --> 00:41:20.781
它使用了所有這些技術

00:41:21.148 --> 00:41:22.850
請查看我身後的這個地址

00:41:24.184 --> 00:41:26.086
有幾個相關的演講

00:41:26.553 --> 00:41:29.957
一個是關於新的
UIKitPropertyAnimator API

00:41:30.057 --> 00:41:32.659
它非常適用於
UIPreviewInteraction

00:41:33.126 --> 00:41:37.497
而另一個是關於
在iOS上撬動低級觸控輸入

00:41:38.198 --> 00:41:40.000
就是這樣
十分感謝大家

00:41:40.067 --> 00:41:42.336
祝大家在接下來演講中
也有很大收穫 謝謝