00:00:19.353 --> 00:00:24.625
CloudKit最佳實踐

00:00:29.796 --> 00:00:31.865
早上好
謝謝你們來參加本次演講

00:00:31.932 --> 00:00:35.002
我叫Dave Browning
今天和我一起的還有Nihar Sharma

00:00:35.169 --> 00:00:37.538
我們是CloudKit團隊的工程師

00:00:37.604 --> 00:00:40.140
今天我們跟你們談一些最佳實踐

00:00:40.207 --> 00:00:42.609
來用CloudKit構建你應用

00:00:43.210 --> 00:00:44.978
那麼 我們具體會談些什麼呢？

00:00:48.382 --> 00:00:52.286
這個 首先我要介紹在Apple
我們怎麼使用CloudKit

00:00:53.020 --> 00:00:56.190
我會說一下整個工作流程
還有我們用的一些API

00:00:56.256 --> 00:00:58.625
我們用這些API給顧客們
提供流暢的體驗

00:00:58.692 --> 00:01:01.562
我指的是讓他們可以
一直訪問相同的數據

00:01:01.628 --> 00:01:04.063
在他們所有設備的應用裏

00:01:05.098 --> 00:01:07.668
接着 Nihar會細說

00:01:07.734 --> 00:01:09.837
CKOperation API
的使用

00:01:09.903 --> 00:01:12.973
以及使用時的可配置性和靈活性

00:01:13.774 --> 00:01:17.344
然後 他會聊一下數據建模時
需要考慮的一些東西

00:01:17.444 --> 00:01:20.948
你在CloudKit存什麼 怎樣存
怎樣建立你數據庫的架構

00:01:22.482 --> 00:01:24.384
接下來 他會討論錯誤處理

00:01:24.451 --> 00:01:27.221
我們說過 這對於
CloudKit應用來說至關重要

00:01:27.287 --> 00:01:31.258
他的講話會涵蓋你在用API時
可能會遇到的不同類型的錯誤

00:01:31.558 --> 00:01:35.229
還有怎樣根據你應用的使用情況
考慮應對之策

00:01:36.263 --> 00:01:38.932
給各位提個醒 我們在Apple
創建了CloudKit

00:01:38.999 --> 00:01:41.502
還創建了很多
基於CloudKit的應用

00:01:42.202 --> 00:01:44.404
所以你們應有信心
你們的應用會成長和擴張

00:01:44.471 --> 00:01:47.007
因爲我們已把應用擴展到
擁有數億用戶的規模

00:01:47.708 --> 00:01:50.544
我還想給你們
快速回顧一下概念模型

00:01:50.677 --> 00:01:53.013
在最高層 我們有所謂的容器

00:01:53.080 --> 00:01:55.816
這個一般跟應用一一對應起來

00:01:56.149 --> 00:02:00.320
Photos、Notes和你應用
在CloudKit有一個容器

00:02:01.555 --> 00:02:03.857
在一個容器裏
你有一個公用數據庫

00:02:04.124 --> 00:02:06.760
你可以將所有用戶
可以看到的數據存在這兒

00:02:07.060 --> 00:02:09.196
所以 其中一個實例是WWDC應用

00:02:09.263 --> 00:02:11.832
或iOS裏的News應用
都由CloudKit創建

00:02:11.899 --> 00:02:14.735
它們用公用數據庫來儲存文章、新聞

00:02:14.801 --> 00:02:16.670
這些所有人都能看到的東西

00:02:17.404 --> 00:02:19.072
我們還有私人數據庫

00:02:19.273 --> 00:02:21.642
你在這兒給
一個特定用戶儲存數據

00:02:22.142 --> 00:02:24.711
這個用戶可以在
所有設備上看到其數據

00:02:24.778 --> 00:02:26.313
但別的用戶都看不見

00:02:27.047 --> 00:02:29.616
而今年我們新增了共享數據庫

00:02:29.983 --> 00:02:33.520
關於這個 如果你想了解更多
一定要看昨天演講的視頻

00:02:33.587 --> 00:02:34.855
“CloudKit的新特性”

00:02:34.922 --> 00:02:36.890
深入探討了共享

00:02:37.724 --> 00:02:40.594
接着 在一個數據庫裏
你有一個地帶

00:02:40.661 --> 00:02:43.463
在公用和私人數據庫裏
都有一個默認地帶

00:02:43.730 --> 00:02:46.834
如果你把檔案默認擱在數據庫裏
這就是檔案會去到的地方

00:02:46.934 --> 00:02:51.104
你在私人數據庫裏可以選擇
創建一個或多個自定義地帶

00:02:51.471 --> 00:02:53.307
你便可以在那些地帶儲存東西

00:02:53.707 --> 00:02:56.810
而當一個用戶
分享內容給另一個用戶時

00:02:57.110 --> 00:02:59.813
這份內容就會呈現爲
他們共享數據庫裏的一個共享地帶

00:03:00.113 --> 00:03:01.982
你可以把它的本質想成是一個代理

00:03:02.149 --> 00:03:04.818
是所有者私人數據庫和自定義地帶
的一個代理

00:03:05.586 --> 00:03:08.922
當然 如果多個用戶在
多個自定義地帶跟你分享東西

00:03:08.989 --> 00:03:11.758
你就會見到很多共享地帶

00:03:11.825 --> 00:03:12.960
在共享數據庫裏

00:03:13.227 --> 00:03:17.698
而在整個工作流程中 我演講的重點
會在自定義和共享地帶上

00:03:17.965 --> 00:03:19.633
就是我們剛在這兒談的

00:03:19.733 --> 00:03:22.002
最後在最低級 你有檔案

00:03:22.069 --> 00:03:24.438
這是鍵值結構數據存儲

00:03:24.505 --> 00:03:27.107
一份檔案永遠存在於一個特定地帶

00:03:29.309 --> 00:03:33.046
好 我快速地回顧一下
在高層使用CloudKit的好處

00:03:33.113 --> 00:03:36.650
你可以專注於構建你的應用
而無需爲搭建後臺服務操心

00:03:36.717 --> 00:03:37.551
我們幫你做了這步

00:03:38.385 --> 00:03:41.154
你的用戶能夠進行
所謂的自動認證

00:03:41.488 --> 00:03:44.091
是指若他們在一臺設備上
登錄了iCloud

00:03:44.157 --> 00:03:46.527
你就不用提示他們
註冊、登錄

00:03:46.593 --> 00:03:49.196
或者任何常常會
造成阻礙的東西

00:03:49.263 --> 00:03:50.464
妨礙他們使用你的應用

00:03:50.697 --> 00:03:52.699
他們若用CloudKit
登錄iCloud

00:03:52.766 --> 00:03:56.103
你馬上就有這個用戶的
唯一標識碼

00:03:56.303 --> 00:03:58.372
你就可以替他們
儲存數據了

00:03:59.339 --> 00:04:02.743
最後 也是今天值得強調的
就是你可以得到同樣的數據

00:04:02.809 --> 00:04:05.579
不對 是你用戶可以在
他們所有的設備上得到同樣數據

00:04:05.646 --> 00:04:06.813
若你將數據存於CloudKit

00:04:08.115 --> 00:04:11.018
好 我們現在來說一下
我們看到的常用案例

00:04:11.084 --> 00:04:13.253
以CloudKit爲基礎
構建應用時

00:04:13.787 --> 00:04:16.156
我們看到 你有一個用戶
在運行一個應用

00:04:16.223 --> 00:04:17.991
此案例裏
談論的主角是Notes

00:04:18.058 --> 00:04:19.526
Notes是
基於CloudKit構建的

00:04:19.593 --> 00:04:23.430
假設用戶在iPhone上創建了
一個note並存到了雲端

00:04:23.964 --> 00:04:27.501
當用戶在第二臺設備 比如iPad上
第一次打開Notes的時候

00:04:28.035 --> 00:04:30.404
會感覺數據
神一樣地推送出來

00:04:30.470 --> 00:04:31.872
它已在iPad裏了

00:04:32.105 --> 00:04:33.674
而且 如果他們在iPad編輯

00:04:33.874 --> 00:04:36.343
也會感覺數據神一樣地
向另一個方向推送

00:04:36.410 --> 00:04:39.313
這就是我們想提供給
我們用戶的使用案例

00:04:40.581 --> 00:04:44.751
我們應該這樣想
iCloud服務器是真實數據的來源

00:04:45.319 --> 00:04:48.121
你的設備有這個
真實數據的本地緩存

00:04:48.388 --> 00:04:51.124
而CloudKit API就是
兩者之間的橋樑

00:04:53.427 --> 00:04:55.362
好 所以這個實際上
到底是怎麼運作的呢

00:04:57.264 --> 00:04:59.800
這個基本上就是
當你的應用啓動的時候

00:04:59.867 --> 00:05:04.071
我們推薦的工作流程是
你從服務器獲取數據的變化

00:05:04.304 --> 00:05:05.839
特別是在你應用首次啓動時

00:05:05.906 --> 00:05:08.342
因爲你不知道
有沒有東西已經存在

00:05:08.509 --> 00:05:10.310
用戶從另一臺設備寫了一些東西

00:05:10.410 --> 00:05:13.847
對吧 所以你連接到服務器
獲取任何你還沒有的數據

00:05:14.348 --> 00:05:17.718
然後你確保訂閱了
未來的數據變化

00:05:18.051 --> 00:05:21.455
通過訂閱未來的數據變化
你告訴CloudKit讓服務器

00:05:21.522 --> 00:05:23.023
推送通知

00:05:23.223 --> 00:05:25.526
到用戶其它設備上的你的應用

00:05:26.026 --> 00:05:28.562
接着 當然若你收到一個推送
你應再獲取數據變化

00:05:28.629 --> 00:05:31.965
把用戶其它設備上
產生的新變化下載下來

00:05:33.267 --> 00:05:35.302
好 我們來挖掘
關於這個的更多細節

00:05:35.736 --> 00:05:37.070
訂閱數據變化

00:05:37.171 --> 00:05:40.641
它是這樣運作的
當你的應用第一次運行時

00:05:40.707 --> 00:05:43.710
我們一會兒會探討爲什麼
不過現在 當它第一次運行時

00:05:43.777 --> 00:05:46.280
你設定好訂閱告訴服務器

00:05:46.346 --> 00:05:48.982
這些是我關心和訂閱的數據

00:05:49.283 --> 00:05:51.685
當這些數據發生改變時
服務器就會告訴你

00:05:51.852 --> 00:05:54.555
當你的應用在
另一臺設備上第一次啓動時

00:05:54.621 --> 00:05:57.624
給用戶的訂閱可能
已經存在於服務器上了

00:05:57.691 --> 00:06:00.260
但你的應用並不知道這個
因爲這是它第一次啓動

00:06:00.327 --> 00:06:01.962
所以你要保證
這個訂閱確實存在

00:06:02.262 --> 00:06:05.265
你接下來要做的跟你之前
在另一臺設備做的一樣

00:06:06.433 --> 00:06:10.437
現在 既然你訂閱了數據變更
並且CloudKit會推送通知

00:06:10.504 --> 00:06:13.540
你就要偵聽這些通知
我們來具體看一個例子

00:06:14.141 --> 00:06:15.475
用戶寫一個新筆記

00:06:15.776 --> 00:06:17.978
應用將它存於服務器上

00:06:18.045 --> 00:06:20.647
服務器看了看說
啊哈 這個用戶有訂閱

00:06:20.714 --> 00:06:23.016
當有新數據的時候
它們想第一時間知道

00:06:23.817 --> 00:06:26.987
它說它來自iPhone
所以不用打擾iPhone

00:06:27.054 --> 00:06:28.622
但這個用戶還有一臺iPad

00:06:28.922 --> 00:06:31.992
服務器於是就查找合適的
Apple推送通知服務標記

00:06:32.226 --> 00:06:36.697
幫你跟APNS連接
並且告訴後者發一個推送給iPad

00:06:36.763 --> 00:06:39.099
你於是就用不着
親自在後臺發推送了

00:06:39.166 --> 00:06:41.301
你的iPad終於收到推送

00:06:41.368 --> 00:06:43.170
iPad接着幹嘛呢
我們之前提到

00:06:43.237 --> 00:06:45.873
現在它會向服務器
索取這些新的數據更改

00:06:46.273 --> 00:06:48.909
具體就是iPad經CloudKit
下載新的數據

00:06:48.976 --> 00:06:51.778
更新自己的本地緩存
然後用戶在iPad上打開Notes

00:06:51.845 --> 00:06:54.481
瞧 用戶看到剛在
iPhone上寫的同樣的東西

00:06:56.016 --> 00:06:57.851
好 我們來實踐一下
搭建這個系統

00:06:57.918 --> 00:07:00.587
我們深入到代碼裏
到我們專門用的API裏

00:07:00.654 --> 00:07:01.855
實現一切

00:07:02.189 --> 00:07:04.658
我們首先看到訂閱數據改動

00:07:05.792 --> 00:07:06.827
記得我說過的話

00:07:06.894 --> 00:07:10.564
這是那些只在你應用第一次啓動時
你才需要做的一件事

00:07:10.631 --> 00:07:13.934
所以 你會注意到
在我們代碼頂部有一步審查

00:07:14.001 --> 00:07:16.103
查看我們在這臺設備上
是否本地緩存

00:07:16.170 --> 00:07:18.438
既然我們都已經
設置了這個訂閱

00:07:18.505 --> 00:07:21.341
我們不用每次應用啓動
都執行後面的程序

00:07:21.508 --> 00:07:24.945
你爲自己節省了網絡請求
你也爲用戶節省了一些網絡操作

00:07:25.412 --> 00:07:29.383
好 那麼如果我們之前沒有訂閱
我們來看看代碼是怎麼設置訂閱的

00:07:29.750 --> 00:07:31.151
今年 iOS 10新特性

00:07:31.385 --> 00:07:34.054
CKDatabaseSubscription API

00:07:34.288 --> 00:07:37.758
讓你可以訂閱整個數據庫的任何改動

00:07:37.824 --> 00:07:40.327
而且它可以用在私人數據庫
可以用在共享數據庫

00:07:40.694 --> 00:07:43.330
在這個例子裏
我們來關注新的共享數據庫

00:07:43.630 --> 00:07:48.569
所以你給訂閱賦予一個ID
方便之後查找 我稍後也會談這個ID

00:07:48.635 --> 00:07:51.138
在這個案例裏 因爲我們的對象是
一個共享數據庫

00:07:51.205 --> 00:07:52.639
我們稱數據改動爲共享改動

00:07:53.774 --> 00:07:57.811
接着 你要告訴CloudKit
你想要發送的推送類型

00:07:58.011 --> 00:07:59.580
在訂閱觸發的時候發送

00:07:59.813 --> 00:08:02.115
我們來深入聊聊
你可以用的不同類型

00:08:02.583 --> 00:08:06.053
第一個類型實際上我們用得很多
而且對於大多數用例我們都很推薦

00:08:06.119 --> 00:08:07.688
這是一個靜默推送通知

00:08:08.155 --> 00:08:12.025
要做到這點 在我們的API裏要
關注到一個訂閱對象

00:08:12.092 --> 00:08:16.496
你可以用一個CKNotificationInfo對象
設置notificationInfo

00:08:16.563 --> 00:08:19.700
然後 如果你將should
SendContentAvailable屬性設爲真

00:08:19.766 --> 00:08:22.402
並且只設置這個屬性
你就可以靜默推送了

00:08:22.469 --> 00:08:25.706
後臺就會替你
給這個訂閱發一個靜默推送

00:08:26.440 --> 00:08:30.611
而這個關鍵的一點是
你不需要提示用戶並取得同意

00:08:30.677 --> 00:08:34.648
過去我們有開發者抱怨“嘿
我們有這個訂閱 但它會彈出窗口”

00:08:34.715 --> 00:08:37.384
你們也見過這種情況
對這個應用允許推送通知

00:08:37.451 --> 00:08:39.086
很多人會選不

00:08:39.152 --> 00:08:41.321
沒得推送的話
你就只能靠下載數據了

00:08:41.421 --> 00:08:44.591
如果你這樣做的話
基本上你怎麼樣都不能引起用戶注意

00:08:44.658 --> 00:08:46.460
所以 你不需要徵求用戶接受

00:08:47.594 --> 00:08:51.064
最後 你偵聽這些通知的地方是在
AppDelegate裏的

00:08:51.131 --> 00:08:52.599
RegisterForRemoteNotifications

00:08:53.333 --> 00:08:56.370
而如果你確實想發送一個UI推送
你其實想要的是標記

00:08:56.436 --> 00:09:00.407
橫幅或者發出聲響
你可設置三個設置中的任何一個

00:09:00.974 --> 00:09:04.111
這會告訴CloudKit
給你的用戶發一個UI推送

00:09:04.845 --> 00:09:08.615
而在這個案例裏 因爲你要提醒用戶
所以你需要徵得他們的同意

00:09:08.882 --> 00:09:12.152
你跟以前用一樣的方法登記遠程通知

00:09:13.187 --> 00:09:14.521
一些要注意的細節

00:09:14.588 --> 00:09:16.757
如果你去讀APNS文檔

00:09:16.823 --> 00:09:21.128
它們會告訴你說
推送可以根據設備條件進行合併

00:09:21.728 --> 00:09:25.666
這個指的是 如果一個訂閱觸發了
並且一個推送發到你用戶的設備上

00:09:25.732 --> 00:09:28.368
有很多情況 比如低電量
網絡不穩定等等

00:09:28.435 --> 00:09:29.970
這些情況下
不一定收到推送

00:09:30.304 --> 00:09:33.941
這個合併協定的目的
就是要至少實現其中一個推送

00:09:34.708 --> 00:09:35.676
這意味着

00:09:35.742 --> 00:09:39.613
你不應該認爲推送就是要
告訴你的應用具體“什麼”數據改變了

00:09:39.680 --> 00:09:41.815
因爲如果發了五個推送
而你錯過其中四個

00:09:41.882 --> 00:09:43.617
你只是錯過了
其中四個“什麼”

00:09:43.684 --> 00:09:47.120
取而代之 你應該將推送想作是
告訴你“有些”數據改變了

00:09:47.187 --> 00:09:48.155
一個或多個東西

00:09:48.222 --> 00:09:51.291
這就是爲什麼我們要從服務器那兒
找出哪些數據改變了

00:09:51.358 --> 00:09:53.961
好消息是CloudKit API

00:09:54.027 --> 00:09:56.763
給你提供了一個途徑
詢問哪些東西改變了

00:09:56.830 --> 00:09:59.533
所以你不用下載
你服務器已經有的所有東西

00:10:00.534 --> 00:10:03.570
我們回到我們的程序
記得我們還在創建一個訂閱

00:10:03.637 --> 00:10:06.073
在這個案例中
我們設定了一個靜默推送通知

00:10:06.406 --> 00:10:09.076
通過把
shouldSendContentAvailable設爲真

00:10:09.843 --> 00:10:11.478
現在 我們需要拿這個訂閱

00:10:11.545 --> 00:10:14.014
讓CloudKit客戶端
把它存到服務器上

00:10:14.414 --> 00:10:16.083
你可能熟悉這個

00:10:16.149 --> 00:10:18.485
但你做所有東西
都要用到操作

00:10:18.819 --> 00:10:22.356
而在這個例子裏 我們用到
CKModifySubscriptionsOperation

00:10:22.422 --> 00:10:25.058
我們把剛創建的訂閱告訴它

00:10:25.125 --> 00:10:26.460
而這就是我想儲存的
那個訂閱

00:10:27.895 --> 00:10:31.765
有了CloudKit 因爲客戶端要
通過網絡跟服務器連接

00:10:31.832 --> 00:10:34.568
這可能會耗很多時間
所有東西都是非同步的

00:10:34.635 --> 00:10:37.471
這意味着所有操作
都有完成模塊

00:10:37.538 --> 00:10:40.541
一旦有一個響應回來
這些模塊就會被調用

00:10:40.607 --> 00:10:44.111
在這兒 我們有一個
modifySubscriptionsCompletionBlock

00:10:44.645 --> 00:10:46.647
所有完成模塊裏
你首先要做的是

00:10:46.713 --> 00:10:49.116
檢查錯誤
我知道我們總是說這個

00:10:49.216 --> 00:10:52.319
Nihar會跟你們
更詳細地講解

00:10:52.386 --> 00:10:54.888
不過 在這個案例裏
假設如果我們沒有錯誤

00:10:54.955 --> 00:10:56.924
那我們就知道
訂閱已經儲存好了

00:10:56.990 --> 00:10:59.493
而我可以在本地緩存
我們已經做了這一步的記錄

00:10:59.560 --> 00:11:02.296
這樣下一次我們就不用做了
多虧有程序頂部的錯誤檢查

00:11:03.830 --> 00:11:05.899
順便講一下
Nihar也會談這個

00:11:05.966 --> 00:11:09.736
CKOperation繼承了NSOperation
即Swift 3裏的操作

00:11:10.037 --> 00:11:12.806
所以你可以設置
這個服務質量屬性

00:11:12.873 --> 00:11:14.074
默認值是.utility

00:11:14.141 --> 00:11:16.743
他會講一些設置這個時
要切記的東西

00:11:17.277 --> 00:11:18.145
而最後

00:11:18.412 --> 00:11:22.316
拿這個操作
讓客戶端發送回來的方法

00:11:22.382 --> 00:11:25.385
就是把它加進數據庫的
操作隊列裏

00:11:25.452 --> 00:11:28.555
既然這個例子裏我們做的是
共享數據庫的訂閱

00:11:28.622 --> 00:11:30.891
就把操作加到共享數據庫的
操作隊列裏

00:11:30.958 --> 00:11:32.826
客戶端於是就會把
操作發送到服務器

00:11:34.328 --> 00:11:36.697
好 我們現在訂閱了數據變化

00:11:37.164 --> 00:11:40.067
下一步就是偵聽推送了

00:11:40.434 --> 00:11:44.037
既然CloudKit在另一臺設備的
數據改變時會發推送給我們

00:11:45.672 --> 00:11:48.408
你要確保在Xcode裏
你打開了背景模式

00:11:48.675 --> 00:11:51.411
你要在遠程通知的選項打鉤

00:11:51.478 --> 00:11:52.746
可能還要選後臺獲取

00:11:52.813 --> 00:11:55.349
如果當你應用在背景的時候
你想做這個

00:11:56.016 --> 00:11:59.553
這一步後 AppDelegate
有一個你可能知道的方法

00:11:59.620 --> 00:12:02.122
application
didReceiveRemoteNotification

00:12:02.189 --> 00:12:03.524
fetchCompletionHandler

00:12:04.525 --> 00:12:06.994
你給這方法一個用戶信息字典

00:12:07.594 --> 00:12:09.563
CloudKit就可以讓你很方便地

00:12:09.630 --> 00:12:13.333
看能否從這個字典對象裏獲取
一個CKNotification

00:12:14.835 --> 00:12:17.371
記得推送還可能有別的各種原因

00:12:17.437 --> 00:12:21.175
但若它來自一個CloudKit訂閱
就會有CKNotification

00:12:21.341 --> 00:12:23.677
現在我們可以查訂閱ID

00:12:24.344 --> 00:12:28.615
這一步很重要 因爲你可能會有
一個數據庫訂閱

00:12:28.682 --> 00:12:31.585
在私人或者共享數據庫
可能還有別的東西

00:12:31.852 --> 00:12:35.389
這一步讓你辨別哪個訂閱
觸發了這個推送

00:12:35.689 --> 00:12:38.125
在這個案例裏 我們假設
推送來自我們的共享改動

00:12:38.192 --> 00:12:40.561
現在我們可以去
獲取這些共享數據

00:12:40.894 --> 00:12:42.229
這個流程我們待會兒會探討

00:12:42.362 --> 00:12:44.631
這步完成後 我們調用
完成處理程序

00:12:44.698 --> 00:12:46.166
這個方法的參數之一

00:12:47.534 --> 00:12:50.571
好 現在我們設置好偵聽推送了

00:12:51.004 --> 00:12:53.874
我們假設一段時間後
你的應用收到一個推送

00:12:54.141 --> 00:12:56.076
我們該怎麼辦呢
記得我們剛講的東西

00:12:56.176 --> 00:12:57.578
我們要獲取新的數據變化

00:12:57.811 --> 00:13:00.614
我們來看圖說話
看看這個是怎麼運作的

00:13:01.148 --> 00:13:02.583
我們的設備收到一個推送

00:13:02.649 --> 00:13:04.718
我們說了這個是
共享數據庫的推送

00:13:04.785 --> 00:13:06.753
你需要做下面兩步

00:13:07.087 --> 00:13:10.290
一
你詢問服務器

00:13:10.490 --> 00:13:13.560
共享數據庫裏哪些地帶變動了

00:13:13.927 --> 00:13:15.696
記得我們之前談過地帶

00:13:15.762 --> 00:13:19.132
可能還會有
新地帶出現而你甚至都不知道

00:13:19.199 --> 00:13:21.201
因爲有人跟你分享了一些東西

00:13:21.735 --> 00:13:23.971
你接着發一個服務器變動標記

00:13:24.037 --> 00:13:26.106
告訴服務器你在
數據歷史的哪個位置

00:13:26.173 --> 00:13:27.941
這個我們一會兒也會深入講解

00:13:28.242 --> 00:13:32.312
有了地帶的數字後 第二步就是
你又詢問服務器說 好

00:13:32.379 --> 00:13:35.749
請告訴我在那些具體地帶裏
哪些檔案有改動

00:13:35.983 --> 00:13:38.218
同樣地
對於每個地帶你都有改動標記

00:13:38.285 --> 00:13:40.854
標明你本地的設備緩存在
數據歷史裏的位置

00:13:42.756 --> 00:13:45.459
好 我們來更詳細地
講講這個改動標記

00:13:46.059 --> 00:13:49.563
假設你的用戶有一臺設備
就我們之前說的那臺iPhone吧

00:13:49.630 --> 00:13:52.666
用戶用你的應用
發送了一些改動到服務器

00:13:52.866 --> 00:13:56.236
改動得到認可
服務器在歷史上標明這一點

00:13:56.303 --> 00:13:58.071
這要用到服務器改動標記

00:13:58.138 --> 00:14:00.974
在這個例子裏 爲了簡便
我們標明爲字母A

00:14:01.041 --> 00:14:04.344
這臺設備又發送
另一些得到認可的改動

00:14:04.411 --> 00:14:06.346
這些標爲B 等等 接着就是C

00:14:06.780 --> 00:14:09.983
一段時間後 用戶在
第二臺設備運行你的應用

00:14:10.050 --> 00:14:12.186
假設是我們之前說到的那臺iPad

00:14:12.252 --> 00:14:14.988
iPad首先要做的
記得在應用啓動時

00:14:15.055 --> 00:14:17.291
要做的是索要
任何它沒有的改動

00:14:17.824 --> 00:14:20.827
於是它說
“我想從服務器獲取改動”

00:14:20.894 --> 00:14:23.197
服務器說“拿去吧
這些是我有的”

00:14:23.263 --> 00:14:26.834
最後它說
“你現在位於服務器改動標記C”

00:14:27.100 --> 00:14:29.503
所以二號設備自己
記好了它在歷史上的位置

00:14:30.137 --> 00:14:32.606
現在假設二號設備
接着寫了一些數據

00:14:32.773 --> 00:14:34.908
寫的過程中 一號設備收到推送

00:14:35.342 --> 00:14:37.244
一號設備下載新的變動

00:14:37.311 --> 00:14:40.581
最後 服務器說
“你現在位於改動標記E”

00:14:40.647 --> 00:14:42.916
好 二號設備又改了一些東西

00:14:42.983 --> 00:14:45.919
一號設備收到推送
下載東西

00:14:46.019 --> 00:14:47.554
現在它位於改動標記I

00:14:48.755 --> 00:14:51.592
你會意識到二號設備
還在改動標記C

00:14:51.925 --> 00:14:55.095
你寫數據的時候
你是不會得到改動標記的

00:14:55.195 --> 00:14:57.297
除非你去索取
你是不會得到標記的

00:14:57.364 --> 00:14:59.700
我們假設在二號設備
應用重啓

00:15:00.000 --> 00:15:02.803
或者用戶重啓iPad還是別的什麼
你的應用啓動了

00:15:02.870 --> 00:15:04.071
你去要數據改動

00:15:04.171 --> 00:15:06.840
服務器就會發給你
你從設備寫了的東西

00:15:06.907 --> 00:15:09.977
它不知道你會不會
因爲各種原因而沒有本地緩存

00:15:10.043 --> 00:15:12.312
如果你見到類似的情況
也不要驚訝

00:15:12.379 --> 00:15:15.816
這麼做讓你可以確認
你有這一部分數據

00:15:15.883 --> 00:15:19.319
最後 服務器會
告訴你位於改動標記I

00:15:19.553 --> 00:15:23.390
注意兩臺設備都在同樣的狀態
都有同樣的服務器改動標記

00:15:23.724 --> 00:15:25.893
這就是展示系統
如何運作的一個例子

00:15:27.261 --> 00:15:30.797
好 我們來看看真正寫代碼來
獲取這些變化

00:15:31.231 --> 00:15:34.101
這個案例裏
我們要講解數據庫

00:15:34.301 --> 00:15:38.872
iOS 10一個新API叫
CKFetchDatabaseChangesOperation

00:15:39.373 --> 00:15:42.609
如我們所說 你把我們剛提到的
服務器改動標記作爲參數

00:15:42.776 --> 00:15:46.880
你第一次用它時
它會告訴服務器你啥都沒有

00:15:46.947 --> 00:15:49.516
服務器也會把它的所有東西給你

00:15:50.350 --> 00:15:54.288
接下來
在API以前的版本里

00:15:54.354 --> 00:15:57.691
在這個操作最後
你通常要檢查一個旗標

00:15:57.891 --> 00:16:00.694
看服務器有沒有說
之後還有更多的數據

00:16:01.128 --> 00:16:02.896
我們一會兒也會談論這個

00:16:02.963 --> 00:16:06.533
但通常如果這個設爲真的話
你就要負責在客戶端

00:16:06.600 --> 00:16:08.302
重新觸發這個操作

00:16:09.002 --> 00:16:11.438
但我們加了一個新屬性

00:16:11.638 --> 00:16:13.907
到這些操作裏
叫獲取所有改動

00:16:13.974 --> 00:16:15.175
其默認值爲真

00:16:15.409 --> 00:16:18.045
它做的是
讓CloudKit客戶端

00:16:18.111 --> 00:16:20.814
替你做這個
所以你不用親自動手

00:16:20.881 --> 00:16:22.950
運行了其中一個操作後

00:16:23.016 --> 00:16:25.252
如果客戶端看到
服務器還有更多數據

00:16:25.452 --> 00:16:28.222
它又會幫你自動把
你的操作加入隊列

00:16:28.422 --> 00:16:30.490
當然 順便調用你的回調方法

00:16:30.691 --> 00:16:32.960
所以你再也不用擔心

00:16:33.427 --> 00:16:35.696
然後 你要實現這個
完成模塊

00:16:35.762 --> 00:16:37.965
recordZoneWithIDChangedBlock

00:16:38.232 --> 00:16:40.567
在這裏 你會得知哪些地帶

00:16:40.634 --> 00:16:42.269
在共享服務器裏改動了

00:16:42.736 --> 00:16:44.671
你有收集這些地帶ID

00:16:44.738 --> 00:16:47.007
我們等會兒會講
怎麼處理它們

00:16:47.074 --> 00:16:50.310
再接下來是
recordZoneWithIDWasDeletedBlock

00:16:50.377 --> 00:16:53.146
這個告訴你哪些地帶在
服務器裏已經不復存在

00:16:53.213 --> 00:16:55.716
還可以讓你清理
任何本地緩存數據

00:16:56.049 --> 00:16:57.684
之前位於那些
現在不再存在的地帶裏的緩存

00:16:58.352 --> 00:16:59.686
你會在下面的情形看到這個

00:16:59.753 --> 00:17:02.456
就是有些東西
沒有跟你的用戶分享

00:17:02.656 --> 00:17:05.192
因爲在他們的共享數據庫裏
沒有這個地帶

00:17:05.259 --> 00:17:08.127
另一個新事物是
changedTokenUpdatedBlock

00:17:08.194 --> 00:17:09.363
我們來看一下

00:17:09.730 --> 00:17:14.034
記得之前我們一號設備
寫了一些東西到服務器

00:17:14.401 --> 00:17:16.737
二號設備寫了一些東西

00:17:16.904 --> 00:17:20.207
過了一會兒 這個用戶的
三號設備也加入進來了

00:17:20.406 --> 00:17:21.808
它首先要做的

00:17:21.875 --> 00:17:24.077
是跟服務器連接
並且獲取任何改動

00:17:24.444 --> 00:17:27.580
因爲獲取所有改動爲真
它要下載所有數據

00:17:28.182 --> 00:17:30.551
但我們可能有很多數據
比如這個案例裏面

00:17:30.617 --> 00:17:34.488
服務器會覺得沒必要只在
一個響應裏就將所有數據傳過來

00:17:34.555 --> 00:17:35.656
我們分段來進行

00:17:36.924 --> 00:17:38.859
服務器發給你一部分數據

00:17:39.626 --> 00:17:42.663
CloudKit服務器會看到
服務器還有更多數據

00:17:42.729 --> 00:17:45.666
所以它要替你去設立
另外一個操作

00:17:45.899 --> 00:17:48.836
但它在做這步前
要調用changeTokenUpdated

00:17:48.902 --> 00:17:51.271
並且告訴你
你現在在改動標記C

00:17:52.172 --> 00:17:54.141
這讓你可以跟客戶端配合

00:17:54.208 --> 00:17:55.576
隨之設立操作

00:17:55.642 --> 00:17:57.311
你更新你的本地改動標記

00:17:57.377 --> 00:17:59.346
就用不着重複
你已經做了的一些事情

00:17:59.813 --> 00:18:02.349
比如說這個客戶端替你說

00:18:02.416 --> 00:18:05.385
“還有更多數據要從服務器傳過來
我們去獲取吧

00:18:05.452 --> 00:18:06.286
下載一些新數據”

00:18:06.353 --> 00:18:08.455
結束後再調用
changeTokenUpdated

00:18:08.522 --> 00:18:10.858
看還有沒有新數據
然後又跟服務器連接

00:18:10.924 --> 00:18:12.359
不過這一次會有一個錯誤

00:18:12.893 --> 00:18:16.363
你處理錯誤時可能最終還是
重新調用獲取改動

00:18:16.864 --> 00:18:18.832
但你就不用從頭從A開始了

00:18:18.999 --> 00:18:21.134
因爲你有一個
changeTokenUpdatedBlock

00:18:21.201 --> 00:18:22.803
你的本地改動標記
現在E

00:18:23.070 --> 00:18:24.338
當你調用下一個時

00:18:24.404 --> 00:18:26.139
服務器說
“你只需從F到I的數據”

00:18:26.206 --> 00:18:28.842
你不需要
你已經處理的舊東西

00:18:29.209 --> 00:18:32.246
這就是實現
changeTokenUpdatedBlock的重要性

00:18:32.312 --> 00:18:35.082
你就像正常情況那樣
緩存服務器改動標記

00:18:36.817 --> 00:18:38.452
我們有
完成模塊

00:18:38.519 --> 00:18:41.688
在這個例子裏是 fetchDatabase
ChangesCompletionBlock

00:18:41.989 --> 00:18:43.724
同樣地 你首先要做錯誤處理

00:18:43.790 --> 00:18:45.158
Nihar也會談這個

00:18:45.993 --> 00:18:47.661
然後你會得到
一個最後的改動標記

00:18:47.728 --> 00:18:51.331
如果我們沒有錯誤 最後就會是I

00:18:51.532 --> 00:18:53.200
像正常情況一樣緩存這個標記

00:18:53.400 --> 00:18:57.070
現在我們收集了
在數據庫有變動的地帶

00:18:57.237 --> 00:18:59.306
我們要去獲取有變動的檔案

00:18:59.373 --> 00:19:01.208
這也就是之前
那個圖表的第二步

00:19:01.475 --> 00:19:03.177
我們通過一個新API
來完成這步

00:19:03.243 --> 00:19:06.213
CKFetchRecordZone
ChangesOperation

00:19:06.380 --> 00:19:08.849
它接受地帶ID的集合作爲參數

00:19:09.049 --> 00:19:11.785
所以你不用擔心要根據不同
帶有改動的地帶來調取檔案

00:19:11.852 --> 00:19:14.388
你只需調用一個方法
賦給它所有有變動的地帶

00:19:14.788 --> 00:19:16.990
我們不細看代碼了
不過它大概看起來是這樣

00:19:17.057 --> 00:19:20.694
在處理檔案而非地帶的地方
你會有一些完成模塊

00:19:20.761 --> 00:19:23.063
而且在這個過程中
你會收到改動標記

00:19:24.665 --> 00:19:26.900
好 快速回顧一下
我們講了什麼

00:19:27.601 --> 00:19:31.505
你訂閱了數據改動
告訴CloudKit你想接收推送

00:19:31.572 --> 00:19:33.674
一旦用戶在另一臺設備上
改動了數據

00:19:34.174 --> 00:19:36.143
你偵聽了推送通知

00:19:36.243 --> 00:19:38.645
當你收到推送時
你連接服務器

00:19:38.712 --> 00:19:40.314
獲取變動了的數據

00:19:40.547 --> 00:19:44.051
這麼做的話 你的應用就能提供
流暢的體驗

00:19:44.117 --> 00:19:46.520
給你的用戶使用他們所有的設備

00:19:48.088 --> 00:19:51.792
好 現在Nihar要上來
講一些特別的最佳實踐

00:19:57.097 --> 00:19:58.065
謝謝 Dave

00:19:58.131 --> 00:19:59.933
大家早上好
謝謝大家的到來

00:20:00.400 --> 00:20:03.403
我是Nihar Sharma
CloudKit團隊工程師

00:20:03.470 --> 00:20:07.708
我很高興能夠跟你們
分享一些CloudKit最佳實踐

00:20:07.774 --> 00:20:10.577
我們過去幾年在Apple
領悟到這些操作

00:20:10.644 --> 00:20:13.046
你也可以在你的應用裏利用它們

00:20:13.447 --> 00:20:15.349
我們先來看看
我們要談些什麼

00:20:16.683 --> 00:20:19.920
首先 我想說一下自動認證

00:20:20.120 --> 00:20:23.891
Dave提了一點點
我想更詳細地講講它是什麼

00:20:23.957 --> 00:20:25.526
你怎麼用它

00:20:26.860 --> 00:20:29.830
接着 我要講到
CKOperation API

00:20:29.897 --> 00:20:32.633
這是我們原生CloudKit框架
主要用到的API

00:20:34.635 --> 00:20:37.137
然後 我們會談
你可以牢記的一些點子

00:20:37.204 --> 00:20:39.006
在設計你應用的
數據庫框架時可以用

00:20:39.072 --> 00:20:42.442
它們讓你更有效地利用
CloudKit API

00:20:43.377 --> 00:20:45.345
最後 如我們之前告訴過你們的

00:20:45.412 --> 00:20:49.249
錯誤處理對編寫
一個CloudKit應用至關重要

00:20:49.316 --> 00:20:52.119
我今天在這兒想重申一遍

00:20:52.186 --> 00:20:54.688
並且探討幾個不同類型的錯誤

00:20:54.755 --> 00:20:56.957
還有你的應用應該如何處理它們

00:20:57.090 --> 00:20:58.192
那麼 我們開始吧

00:20:58.659 --> 00:21:01.128
首先是自動認證

00:21:02.062 --> 00:21:05.499
你可能熟悉這樣的一個UI

00:21:05.566 --> 00:21:10.137
第一次啓動時
應用向用戶索要很多私人信息

00:21:10.637 --> 00:21:13.106
用戶甚至都沒開始用這個應用

00:21:13.874 --> 00:21:16.343
而我們覺得在CloudKit
我們有很好的方法

00:21:16.410 --> 00:21:19.646
讓你增加和用戶互動的機會

00:21:19.713 --> 00:21:22.282
不需要開門見山
索要任何私人信息

00:21:23.350 --> 00:21:26.687
我們通過CloudKit用戶記錄
做到這一點

00:21:28.856 --> 00:21:33.627
我提醒你們一下 我們給每個用戶都
自動創建用戶記錄

00:21:33.694 --> 00:21:38.065
用戶第一次用你的應用時
就記錄到了你的iCloud賬戶

00:21:39.399 --> 00:21:42.636
這樣的話 它在每個
CloudKit容器裏都具有唯一性

00:21:43.437 --> 00:21:46.673
也給你提供用戶的
一個可靠的標識符

00:21:47.174 --> 00:21:50.744
對於應用重啓 OS更新等等
都非常可靠

00:21:51.178 --> 00:21:53.313
所以你可以將這個標識符
存在你的服務器上

00:21:53.380 --> 00:21:55.716
並且可以馬上開始
給用戶建立一個檔案

00:21:55.782 --> 00:21:59.219
而當你發現他們
跟你的應用有更多互動時

00:21:59.286 --> 00:22:02.055
你這時就可以向他們徵求
更多信息來充實他們的檔案

00:22:03.257 --> 00:22:05.893
你找到當前用戶的
用戶記錄ID的方法

00:22:05.959 --> 00:22:10.430
是用CKContainer裏的fetchUser
RecordIDcompletionHandler API

00:22:11.131 --> 00:22:13.567
這就是CloudKit自動認證

00:22:15.435 --> 00:22:17.137
我們談談CKOperation

00:22:18.939 --> 00:22:20.674
回顧一下 有兩種主要的方法

00:22:20.741 --> 00:22:24.244
來讓CloudKit框架
將操作呈現給你的應用

00:22:24.845 --> 00:22:29.449
一個是通過調用便利API
它一次針對一個東西

00:22:31.451 --> 00:22:33.687
二則通過
相對應的CKOperation

00:22:33.754 --> 00:22:37.024
這樣 我們呈現的每個
便利API調用

00:22:37.090 --> 00:22:40.360
一次只針對一個東西
都有相對應的CKOperation

00:22:41.495 --> 00:22:43.564
後者則是批量處理

00:22:43.764 --> 00:22:47.534
比如說 我們有
fetchWithRecordID API

00:22:47.601 --> 00:22:49.837
在CKDatabase裏
一次獲取一份檔案

00:22:50.170 --> 00:22:52.806
我們有它對應的
CKFetchRecordsOperation

00:22:52.873 --> 00:22:56.410
它接受一個檔案ID列表
並且批量獲取檔案

00:22:57.945 --> 00:23:00.581
用這個CKOperation API
有一定的優勢

00:23:00.647 --> 00:23:02.850
相對調用
便利API

00:23:03.016 --> 00:23:04.985
我今天要講其中的很多優勢

00:23:05.052 --> 00:23:06.920
首先

00:23:07.654 --> 00:23:10.457
CKOperation是
NSOperation子類

00:23:11.124 --> 00:23:14.294
這意味着
你有全套設備的

00:23:14.361 --> 00:23:17.197
NSOperation API
讓你可以免費使用

00:23:18.432 --> 00:23:21.768
你可以做比如建立你的
CKOperation之間依賴關係

00:23:23.403 --> 00:23:25.205
你可以給它們的
服務質量屬性賦值

00:23:25.272 --> 00:23:27.975
讓系統知道那個
操作對你有多重要

00:23:28.175 --> 00:23:29.610
甚至是管理隊列的優先性

00:23:29.676 --> 00:23:32.145
在你的NSOperation
隊列安排它們時

00:23:33.514 --> 00:23:35.816
你還可以取消
CKOperation

00:23:35.883 --> 00:23:37.618
就是那些已經開始執行的

00:23:39.720 --> 00:23:44.525
我推薦你們回去讀
NSOperation的參考文檔

00:23:44.591 --> 00:23:47.060
來很好地利用
CKOperation API

00:23:47.461 --> 00:23:50.664
一個很好的參考資料是
我們的進階NSOperation

00:23:50.731 --> 00:23:52.966
即我們去年WWDC的演講

00:23:55.235 --> 00:23:57.404
既然我們講到
CloudKit操作

00:23:57.471 --> 00:23:59.740
還有更多東西值得一提

00:23:59.806 --> 00:24:03.043
今天我談其中三個比較重要的

00:24:03.710 --> 00:24:07.447
第一個是CKOperation
給你的可配置性

00:24:08.315 --> 00:24:11.952
第二個是它讓你可以優化資源

00:24:12.019 --> 00:24:14.855
針對系統還有
作爲開發者的你們

00:24:16.857 --> 00:24:19.226
最後 我想說一下壽命管理

00:24:19.293 --> 00:24:21.295
這是我們新開的一個東西
讓你可以

00:24:21.361 --> 00:24:23.530
在iOS 9.3使用

00:24:26.333 --> 00:24:30.437
首先 快速回顧你可以給一個
CKOperation配置些什麼

00:24:31.338 --> 00:24:34.575
操作讓你
可以精確調節使用權利

00:24:34.641 --> 00:24:38.045
調節你想不想讓這個
操作的網絡活動

00:24:38.111 --> 00:24:39.313
通過手機網絡來進行

00:24:40.147 --> 00:24:44.985
你還可以給從服務器下載東西的
操作設置關鍵詞

00:24:45.052 --> 00:24:48.522
如果你想下載部分檔案
而不是全部的檔案

00:24:48.689 --> 00:24:50.824
社區的API不讓你做這個

00:24:52.926 --> 00:24:54.595
你可以限制響應結果的數目

00:24:54.661 --> 00:24:56.630
一個操作
返回的結果

00:24:58.532 --> 00:25:01.869
最後 持續運行的
操作還會給你進度更新

00:25:01.935 --> 00:25:04.204
你可以用這個來
驅動一些UI元素

00:25:05.806 --> 00:25:07.908
現在 我們來說一下資源優化

00:25:09.243 --> 00:25:12.479
你的操作在系統中
用得最多的資源

00:25:12.546 --> 00:25:13.881
是網絡請求

00:25:15.148 --> 00:25:17.084
現在每個
便利API調用

00:25:17.150 --> 00:25:20.087
都轉爲系統中至少一個網絡請求

00:25:21.488 --> 00:25:24.091
所以 當你使用
CKOperation批量API

00:25:24.625 --> 00:25:28.061
你讓系統可以去
最小化所需要的請求數

00:25:28.128 --> 00:25:30.097
來將你的改動發到服務器

00:25:31.031 --> 00:25:33.333
比如 如果你想保存一批檔案

00:25:33.433 --> 00:25:35.802
並且你用的是
CKModifiedRecordsOperation

00:25:35.936 --> 00:25:40.274
系統會拿這批檔案
並且優化需要的請求

00:25:40.340 --> 00:25:41.608
來把這批檔案發到服務器

00:25:44.778 --> 00:25:48.382
這樣 這不僅對系統資源是一件好事

00:25:48.448 --> 00:25:53.887
還幫作爲開發者的你們
優化你們的網絡請求限額

00:25:57.057 --> 00:26:02.863
更進一步 CKOperation
默認讓你的網絡活動

00:26:02.930 --> 00:26:04.364
酌情進行

00:26:05.599 --> 00:26:09.770
我們指的是你讓你的系統
決定一個合適的時間

00:26:09.837 --> 00:26:11.338
來安排你的請求

00:26:12.773 --> 00:26:16.243
欲知更多詳情 推薦看看
酌情處理屬性

00:26:16.310 --> 00:26:18.445
它在
NSURLSessionConfiguration裏

00:26:19.079 --> 00:26:21.448
我們在CKOperation
把它呈現給你的方法

00:26:21.515 --> 00:26:23.617
是通過服務質量屬性

00:26:23.784 --> 00:26:27.554
CKOperation有一個
默認值爲實用的服務質量

00:26:28.622 --> 00:26:30.557
任何是實用或以下的服務質量

00:26:30.624 --> 00:26:32.793
會默認選擇這個酌情進行的行爲

00:26:32.860 --> 00:26:34.962
所以如果你注意到
CKOperation

00:26:35.028 --> 00:26:38.298
花了比你預計的
還要長很多的時間來執行

00:26:38.365 --> 00:26:40.067
很可能就是因爲系統

00:26:40.133 --> 00:26:43.136
覺得現在還不是一個讓你的請求
發出去的好時間

00:26:45.072 --> 00:26:48.008
還有切記的其它幾個行爲

00:26:48.408 --> 00:26:50.444
當你選擇了酌情進行的行爲

00:26:50.844 --> 00:26:53.947
網絡錯誤就會重新嘗試

00:26:55.048 --> 00:26:59.052
與此同時 你默認有一個
七天的資源超時

00:26:59.253 --> 00:27:02.022
你的操作執行的
每個請求都有這個默認超時

00:27:03.457 --> 00:27:05.425
這就是資源優化

00:27:05.826 --> 00:27:08.695
現在 我們來說說
CKOperation壽命管理

00:27:09.696 --> 00:27:10.664
在我們的平臺

00:27:10.731 --> 00:27:14.067
你的應用退出
可能有多重原因

00:27:14.801 --> 00:27:17.671
比如 你的應用在背景可能被中止

00:27:17.738 --> 00:27:20.908
或刪除 或者被用戶強行退出

00:27:21.875 --> 00:27:25.846
當這些事情發生的時候
你可能有一些更新正在運行

00:27:25.913 --> 00:27:27.514
這些更新可能是用戶發起的

00:27:27.581 --> 00:27:30.450
你就應該把它們存到服務器

00:27:30.517 --> 00:27:33.387
不管你的應用是否已經退出

00:27:33.921 --> 00:27:36.190
這些更新也可能因爲
你有更新的運行時間比較長

00:27:36.323 --> 00:27:38.725
但優先度比較低
你想盡快完成它們

00:27:38.792 --> 00:27:40.527
不管你的應用還在不在

00:27:41.662 --> 00:27:44.631
在iOS 9.3裏
爲了達到這個目的

00:27:44.698 --> 00:27:48.168
我們引進了CloudKit
長壽命操作的概念

00:27:49.670 --> 00:27:53.740
這些操作
一旦讓你標爲長壽命

00:27:53.807 --> 00:27:57.077
系統就會替你的應用執行

00:27:57.144 --> 00:27:58.846
不管你的應用還在不在

00:28:00.714 --> 00:28:04.651
我們會緩存從這個操作
得到的任何服務器響應

00:28:04.718 --> 00:28:08.188
並且會給你提供一個
API來重新處理這些響應

00:28:08.255 --> 00:28:09.389
一旦你的應用再回來

00:28:11.458 --> 00:28:14.728
我們來看看我們呈現的API
它能做到這點

00:28:15.929 --> 00:28:18.298
對於CKOperation
這個非常直截了當

00:28:18.465 --> 00:28:20.067
你有一個
isLongLived旗標

00:28:20.334 --> 00:28:22.469
像正常那樣建
一個CKOperation

00:28:22.569 --> 00:28:23.804
一旦你設置了這個旗標

00:28:23.871 --> 00:28:25.939
它就成了一個長壽命操作

00:28:26.974 --> 00:28:29.343
與此同時 你有一個
操作ID

00:28:29.977 --> 00:28:31.945
它是一個系統指定的字符串

00:28:32.112 --> 00:28:34.681
唯一地標識每個
CKOperation

00:28:35.582 --> 00:28:38.385
我們等會兒會看看
爲什麼這個很重要

00:28:39.620 --> 00:28:43.190
下面我們講你怎樣運行一個
長壽命操作的大體架構

00:28:43.557 --> 00:28:46.026
你像正常那樣
初始化一個操作

00:28:46.093 --> 00:28:47.628
設isLongLived旗標

00:28:47.694 --> 00:28:50.797
再加上你的參數和回調來
運行這個操作

00:28:51.298 --> 00:28:52.866
現在 當你想
重新運行它的話

00:28:54.067 --> 00:28:57.938
你可以從CKContainer類
獲取這個長壽命操作

00:28:58.005 --> 00:28:59.573
通過操作ID

00:29:00.741 --> 00:29:03.677
如果你想留意運行的情況
你可以設置回調

00:29:03.844 --> 00:29:05.779
可以再運行一次
這個操作

00:29:06.813 --> 00:29:08.182
我們來看一個例子

00:29:08.649 --> 00:29:12.085
假設我們運行一個長壽命
fetchRecordsOperation

00:29:12.953 --> 00:29:16.156
我們像正常那樣用參數
設置這個操作

00:29:16.657 --> 00:29:18.825
但要記得設置
isLongLived旗標

00:29:19.459 --> 00:29:22.663
並且將操作ID屬性
存入我們的本地緩存

00:29:22.796 --> 00:29:25.599
這樣我們就會記得
這個操作代表了什麼

00:29:27.301 --> 00:29:29.670
我們設置回調
且把操作加入隊列

00:29:29.937 --> 00:29:31.605
現在 當你想要重新運行時

00:29:31.939 --> 00:29:36.476
就用CKContainer裏的
fetchLongLivedOperationwithID API

00:29:36.543 --> 00:29:37.744
獲取操作

00:29:38.812 --> 00:29:40.814
因爲你知道
操作所代表的東西

00:29:40.881 --> 00:29:43.083
通過緩存
所以你可以安全地執行它

00:29:43.650 --> 00:29:45.552
並且設置合適的回調

00:29:46.386 --> 00:29:50.190
你不用再設置參數
或調節其它的操作屬性

00:29:50.257 --> 00:29:51.758
你之前可能設置過

00:29:52.159 --> 00:29:53.794
這樣重啓了操作

00:29:55.095 --> 00:29:59.066
現在 CloudKit會重新處理
我們有的所有緩存響應

00:29:59.132 --> 00:30:00.267
給操作

00:30:00.400 --> 00:30:02.002
讓你跟上進度

00:30:02.069 --> 00:30:04.505
達到你的應用不在時
操作所取得的進度

00:30:04.571 --> 00:30:08.141
或者給你
操作所有的結果

00:30:09.076 --> 00:30:11.945
這也意味着這些操作
會被清理

00:30:12.012 --> 00:30:13.080
這是一個重要的信號

00:30:13.313 --> 00:30:16.016
正常情況下發生在
完成模塊

00:30:16.083 --> 00:30:17.351
被操作調用

00:30:18.619 --> 00:30:22.322
你要記住你的應用
有至少24小時

00:30:22.523 --> 00:30:25.592
重新運行任何他們可能加入隊列的
長壽命操作

00:30:30.330 --> 00:30:33.100
這就是關於CKOperation
API的全部內容

00:30:33.700 --> 00:30:36.270
現在我們轉移到數據建模的話題

00:30:37.437 --> 00:30:39.907
今天我想給你三條主要的點子

00:30:40.174 --> 00:30:42.676
第一條是關於數據庫架構的冗餘

00:30:42.743 --> 00:30:43.944
你可以怎樣利用它們

00:30:44.011 --> 00:30:46.980
還有它們怎樣幫你
更有效利用CloudKit API

00:30:47.648 --> 00:30:50.717
第二條是如何用引用

00:30:50.784 --> 00:30:53.420
來避免你可能遇到的一類錯誤

00:30:53.487 --> 00:30:54.821
在你CloudKit應用中

00:30:55.522 --> 00:30:58.091
最後 我想談一下父級引用

00:30:58.225 --> 00:31:01.361
是我們在這次發佈裏
新加的一種引用

00:31:01.428 --> 00:31:02.963
來支持CloudKit分享

00:31:04.431 --> 00:31:06.533
那麼 我們來說說
數據庫架構的冗餘

00:31:07.568 --> 00:31:11.238
我們用開發照片分享應用的例子

00:31:11.972 --> 00:31:14.708
現在對於這個應用 你在服務器
可能有的第一個東西

00:31:14.775 --> 00:31:16.877
就是給照片的檔案類型

00:31:17.311 --> 00:31:20.747
你可以儲存用戶的高像素照片

00:31:20.814 --> 00:31:25.652
是在我們某款iOS設備上照的
儲存爲CKAsset

00:31:27.955 --> 00:31:30.557
現在 假設用戶第一次啓動應用

00:31:30.624 --> 00:31:33.594
當你像Dave之前
推薦的那樣獲取改動時

00:31:33.660 --> 00:31:36.363
你可能想展示一個縮略圖

00:31:36.430 --> 00:31:38.465
囊括用戶所有最近的照片

00:31:38.732 --> 00:31:41.134
就像這樣
Photos應用就有這個功能

00:31:42.269 --> 00:31:44.805
這樣一來
可能會造成網絡帶寬的巨大浪費

00:31:44.872 --> 00:31:48.175
的一種情形就是
下載全部的高清資源

00:31:48.242 --> 00:31:50.410
每次你打開這個頁面時都下載

00:31:51.211 --> 00:31:54.181
那你該怎麼辦
答案非常簡單

00:31:54.882 --> 00:31:58.285
你可以考慮在檔案裏
加入一個冗餘的域

00:31:58.352 --> 00:32:00.654
代表縮小的資產

00:32:02.856 --> 00:32:07.594
而這可以讓你
配合使用CKOperation

00:32:08.629 --> 00:32:10.998
和我們講過的
所需關鍵詞的屬性

00:32:11.064 --> 00:32:13.200
讓你可以獲取部分檔案

00:32:13.267 --> 00:32:17.137
你現在可以只獲取那些
你需要的關鍵詞 用來驅動UI

00:32:17.204 --> 00:32:18.639
你用戶感興趣的UI

00:32:20.274 --> 00:32:22.342
甚至能用
結果限制的屬性

00:32:22.576 --> 00:32:26.280
來限制你在
一個頁面上顯示的結果數

00:32:28.549 --> 00:32:31.785
這樣 你就可以把
一個優化的下載加入隊列

00:32:32.186 --> 00:32:34.922
能夠將一個動態UI
呈現給你的用戶

00:32:35.255 --> 00:32:38.125
你只在需要的時候取需要的東西

00:32:39.927 --> 00:32:43.163
能用所需關鍵詞屬性的還有新的

00:32:43.230 --> 00:32:45.632
CKFetchRecordZone
ChangesOperation

00:32:45.699 --> 00:32:47.668
和CKFetchRecordsOperation

00:32:47.734 --> 00:32:49.837
兩者都從Cloud給你獲取東西

00:32:51.538 --> 00:32:55.142
我提醒一點 就是這些API
在網上也可以用

00:32:55.209 --> 00:32:56.543
通過CloudKit JS

00:32:58.679 --> 00:33:00.814
通過利用這些工具
你讓你的用戶可以

00:33:00.881 --> 00:33:03.217
在你的應用裏
有更爲動態的體驗

00:33:03.283 --> 00:33:06.286
因爲他們不必
等你完成操作

00:33:06.553 --> 00:33:09.056
來下載他們會用到的數據

00:33:10.757 --> 00:33:15.629
接着 討論CKReferences
我提醒你們這些是什麼

00:33:16.663 --> 00:33:21.034
CloudKit讓你的檔案
可以指向其它檔案

00:33:21.768 --> 00:33:24.938
比如 如果我這兒有兩份檔案
檔案A和檔案B

00:33:25.339 --> 00:33:27.574
我們把引用存在檔案A上

00:33:28.108 --> 00:33:29.743
用檔案B來給它初始化

00:33:30.277 --> 00:33:31.979
創建了CKReference

00:33:33.547 --> 00:33:36.617
現在假設我們想給
我們的照片分享應用添加相冊

00:33:37.050 --> 00:33:38.952
可以涵括多張照片

00:33:39.019 --> 00:33:42.389
我們怎樣可以給
這個一對多的關係建模呢？

00:33:44.424 --> 00:33:46.293
簡單地

00:33:46.360 --> 00:33:49.663
而又天真地 你會覺得
下面的建模方法比較好

00:33:50.264 --> 00:33:54.034
儲存檔案ID
檔案ID用來引用照片檔案

00:33:54.101 --> 00:33:57.738
把ID作爲一個數組直接存在
照片所屬相冊的相冊檔案裏

00:33:59.339 --> 00:34:00.807
這就是概念圖

00:34:02.142 --> 00:34:06.380
現在 我們來瞧瞧當你用戶的多個設備

00:34:06.446 --> 00:34:09.949
嘗試添加照片到
相同的相冊會發生些什麼

00:34:12.152 --> 00:34:14.221
假設我們在Cloud
有一個相冊檔案

00:34:14.288 --> 00:34:15.822
相冊還沒有照片

00:34:17.424 --> 00:34:20.427
現在 記得你的用戶會有多臺設備

00:34:21.762 --> 00:34:23.397
它們都獲取這個相冊記錄

00:34:24.231 --> 00:34:26.733
看到相冊沒有照片
它們很滿意

00:34:28.969 --> 00:34:29.969
設備現在都有了新照片

00:34:30.036 --> 00:34:32.706
它們各自有想加到
同一個相冊的照片

00:34:34.208 --> 00:34:36.476
所以它們把檔案更新加入隊列

00:34:37.110 --> 00:34:38.812
假設iPhone檔案
最先到相冊

00:34:38.879 --> 00:34:41.014
服務器現在知道有一張照片

00:34:41.081 --> 00:34:43.050
對其中一張照片的引用

00:34:44.184 --> 00:34:48.021
當別的新設備加入進來
並且嘗試更新時

00:34:48.121 --> 00:34:51.291
它們更新的不再是
最新的服務器檔案

00:34:52.259 --> 00:34:56.263
所以 在這個案例裏
兩臺設備都會出現錯誤

00:34:56.330 --> 00:34:58.465
CKError
serverRecordChanged

00:34:59.366 --> 00:35:02.970
現在 我推薦你們去看我們的
進階CloudKit演講

00:35:03.036 --> 00:35:07.040
是2014年的WWDC
你會學到更多如何處理這個錯誤的細節

00:35:07.608 --> 00:35:11.211
不過 現在我們來看
可不可以完全避免它

00:35:13.680 --> 00:35:17.618
在這個例子裏 我們知道我們的
相冊檔案會有頻繁的寫操作

00:35:17.985 --> 00:35:21.255
所以 取而代之 如果我們
一對多關係的建模

00:35:21.321 --> 00:35:26.059
用的是一個反向指針
把引用存在照片檔案上

00:35:26.994 --> 00:35:28.428
照片歸屬這個相冊

00:35:28.762 --> 00:35:30.063
這樣我們就徹底排除了

00:35:30.130 --> 00:35:32.766
我們在相冊檔案上的
寫操作糾紛

00:35:34.268 --> 00:35:36.670
在這個情況下
每當你加入新的照片時

00:35:37.004 --> 00:35:40.307
你就設置它引用所屬的相冊的檔案

00:35:40.374 --> 00:35:41.742
並且保存照片檔案

00:35:43.977 --> 00:35:47.781
這麼做的話 你就可以完全
排除掉你之前有的糾紛

00:35:48.415 --> 00:35:50.984
你還會想知道
我怎樣可以獲取所有照片

00:35:51.051 --> 00:35:52.886
這就是我們一開始遇到的問題

00:35:53.187 --> 00:35:55.556
爲了達到這個目的 你可以用請求

00:35:58.559 --> 00:36:02.763
你要獲取歸屬
這個相冊的所有照片記錄

00:36:02.829 --> 00:36:03.997
這非常簡單直白

00:36:04.064 --> 00:36:07.134
你要的就是相冊的引用域

00:36:07.201 --> 00:36:09.236
那兒有你所有的照片檔案

00:36:12.005 --> 00:36:14.074
下面 我們來講父級引用

00:36:15.509 --> 00:36:16.910
今年 在CKRecord

00:36:16.977 --> 00:36:20.214
我們加了新的一類引用
叫父級引用

00:36:20.280 --> 00:36:22.316
幫你給數據建模

00:36:22.382 --> 00:36:24.585
並且更好地支持
CloudKit分享

00:36:25.752 --> 00:36:27.454
我們推薦的是

00:36:27.521 --> 00:36:31.124
如果你的應用支持分享
你就用父級引用

00:36:31.325 --> 00:36:33.627
來建立一個等級制數據模型

00:36:34.695 --> 00:36:36.830
規定好你應用分享的單元

00:36:36.897 --> 00:36:38.799
並且根據情況來設置父級引用

00:36:38.866 --> 00:36:41.268
我們來看看一個例子
來解釋我剛說的內容

00:36:43.971 --> 00:36:47.541
我們的照片和相冊檔案是一個
父級引用的很棒的例子

00:36:48.509 --> 00:36:51.578
相冊很明顯是照片檔案的父親

00:36:51.879 --> 00:36:54.147
我們只需設置父母屬性

00:36:54.515 --> 00:36:57.150
在照片檔案上
指向我們相冊檔案的ID

00:36:58.085 --> 00:36:59.553
並且保存照片檔案

00:37:02.823 --> 00:37:05.526
現在 假設我們在我們
應用裏都用這個模型

00:37:05.826 --> 00:37:08.128
我們有一個像這樣的等級分配

00:37:08.529 --> 00:37:11.732
現在 一個用戶想分享整個相冊

00:37:12.432 --> 00:37:14.134
這種情況下你需要做的只是

00:37:14.201 --> 00:37:17.871
創建一個CKShare
附上相冊檔案作爲組檔案

00:37:18.172 --> 00:37:20.841
你一下子便可以分享整個等級分層

00:37:20.908 --> 00:37:22.876
你就是用父級引用來建立的這個等級

00:37:24.511 --> 00:37:27.781
現在 CloudKit還支持
部分分享的等級制

00:37:28.615 --> 00:37:33.353
這種情況下
比如用戶只想分享照片C

00:37:34.188 --> 00:37:36.557
你可以創建一個分享
只附上照片C

00:37:36.823 --> 00:37:38.025
這樣

00:37:39.193 --> 00:37:42.963
只有照片C
還有它的所有子代

00:37:43.030 --> 00:37:45.566
通過父級設置將加入這個分享

00:37:47.367 --> 00:37:48.969
以上就是數據建模

00:37:50.604 --> 00:37:52.072
我們來談談錯誤處理

00:37:52.873 --> 00:37:55.442
現在 我們有不同類型的錯誤

00:37:55.509 --> 00:37:57.611
而你的應用應該處理它們

00:37:57.678 --> 00:38:00.280
通過幾個主要的不同方法

00:38:00.347 --> 00:38:01.982
我們來看看它們各是什麼樣的

00:38:03.183 --> 00:38:04.685
我們有一個簡單的例子

00:38:04.751 --> 00:38:06.587
假設你的設備

00:38:06.653 --> 00:38:08.689
選擇一個
CKModifyRecordsOperation

00:38:08.755 --> 00:38:10.157
嘗試跟服務器連接

00:38:10.624 --> 00:38:13.760
服務器有可能響應
兩種主要的東西

00:38:14.061 --> 00:38:18.131
它可以說
我一點兒也不喜歡這個請求

00:38:18.198 --> 00:38:19.800
別再試着跟我連接

00:38:20.901 --> 00:38:24.037
或者它可以說你的請求什麼都好

00:38:24.171 --> 00:38:28.208
就是現在的時間不太合適
等會兒再試一次吧

00:38:29.476 --> 00:38:32.412
你們的應用需要
處理這兩種錯誤

00:38:32.479 --> 00:38:35.516
而且要用很不同的方法
我們來仔細看看到底是什麼

00:38:36.884 --> 00:38:39.052
第一種錯誤是致命錯誤

00:38:39.386 --> 00:38:40.621
你基本上無能爲力

00:38:41.922 --> 00:38:44.725
我們有幾個錯誤代碼
表明你遇到的錯誤是嚴重的

00:38:45.425 --> 00:38:49.263
比如內部錯誤
服務器拒絕請求

00:38:50.197 --> 00:38:53.567
非法參數
或者權限失敗

00:38:54.801 --> 00:38:59.273
你要在你的應用裏
給你的用戶顯示合適的UI

00:38:59.339 --> 00:39:02.442
讓他們知道出錯誤了
重試也沒轍

00:39:04.545 --> 00:39:06.513
然而 另外一種錯誤

00:39:06.880 --> 00:39:10.184
服務器讓你歇一會兒再重試

00:39:10.417 --> 00:39:13.954
我們會告訴你
服務器想讓你等的時間

00:39:15.022 --> 00:39:19.526
下面是一系列錯誤代碼
每個裏面都嵌入了時間值

00:39:20.894 --> 00:39:26.066
zoneBusy serviceUnavailable
和requestRateLimited

00:39:27.334 --> 00:39:29.303
當你收到這些錯誤代碼中的
任意一個時

00:39:29.369 --> 00:39:32.372
你要找到
CKErrorRetryAfterKey

00:39:32.439 --> 00:39:34.441
在錯誤的用戶信息字典裏面

00:39:34.908 --> 00:39:39.246
你要等上面說明的時間並且重新初始化
同一個CKOperation

00:39:39.313 --> 00:39:43.283
用相同的參數
並重試這個操作

00:39:44.151 --> 00:39:46.386
下面是一個簡單的例子
還有你需要的所有代碼

00:39:46.453 --> 00:39:48.355
如何等一段時間

00:39:48.422 --> 00:39:51.225
而CKErrorRetryAfterValue
代表了這個時間值

00:39:51.525 --> 00:39:53.894
如何重新初始化
同一個CKOperation

00:39:56.330 --> 00:39:58.565
注意 如果有些時候

00:39:58.632 --> 00:40:01.001
你的操作可能
在設備上出現錯誤

00:40:01.068 --> 00:40:02.703
而甚至還沒連到服務器
怎麼辦？

00:40:03.737 --> 00:40:06.006
我今天講解兩種主要的情況

00:40:06.073 --> 00:40:08.475
CloudKit可能完全用不了

00:40:09.376 --> 00:40:11.845
第一種是設備處於下線狀態

00:40:13.680 --> 00:40:15.549
這種情況下 我們推薦

00:40:15.916 --> 00:40:19.720
你監測可能連到的網絡
就像

00:40:19.786 --> 00:40:21.455
在別的基於網絡的
應用裏做的一樣

00:40:22.923 --> 00:40:26.960
若你用的服務質量
是用戶發起或者更高等級

00:40:27.127 --> 00:40:31.632
而網絡錯誤不會自動爲你重試

00:40:31.698 --> 00:40:35.002
你會看到這個錯誤代碼
CKErrorNetworkUnavailable

00:40:35.903 --> 00:40:37.671
一旦你監測可連接的網絡

00:40:37.738 --> 00:40:40.674
你可以通過SCNetworkReachability
API 做到這點

00:40:40.741 --> 00:40:43.210
比如在系統配置框架裏

00:40:44.578 --> 00:40:46.213
這樣你就可以讓你的用戶知道

00:40:46.280 --> 00:40:50.017
“嘿 這些改動現還傳不到服務器上”

00:40:50.484 --> 00:40:55.122
但我們推薦你讓你的用戶
保持跟應用的互動

00:40:55.189 --> 00:40:56.590
即便設備處於下線狀態

00:40:56.823 --> 00:40:59.626
你應該把這些改動
存在你的本地緩存中

00:40:59.960 --> 00:41:03.330
當可連接性API
告訴你設備重新上線時

00:41:03.530 --> 00:41:07.100
你就可把CloudKit操作
加入隊列並把檔案存到服務器上了

00:41:10.070 --> 00:41:14.208
另一種主要的情況是
當你想給用戶用私人數據庫

00:41:14.274 --> 00:41:16.677
而用戶沒有登錄到
一個iCloud賬戶的時候

00:41:17.411 --> 00:41:21.548
此情況下 返回錯誤代碼
CKErrorNotAuthenticatedTo

00:41:22.816 --> 00:41:25.419
我們推薦的是 對於你所有的應用

00:41:25.485 --> 00:41:30.357
在首次啓動一定要登記偵聽
CKAccountChange通知

00:41:31.892 --> 00:41:36.129
當它觸發時 用 accountStatus
completionHandler API

00:41:36.396 --> 00:41:38.899
來重新獲取
當前用戶的賬戶狀態

00:41:39.266 --> 00:41:42.503
告知他們
一些操作會失敗

00:41:42.569 --> 00:41:44.738
因爲他們沒有登錄
一個iCloud賬號

00:41:47.007 --> 00:41:49.543
我來總結一下
我們今天都看了哪些內容

00:41:51.144 --> 00:41:53.947
我們學習瞭如何訂閱並且獲取改動

00:41:54.014 --> 00:41:56.283
來高效地和服務器同步

00:41:57.718 --> 00:42:01.522
我們領略了使用批量
CKOperation API優勢

00:42:02.022 --> 00:42:04.424
我們推薦你
所有的應用都採用它

00:42:06.126 --> 00:42:08.695
我們也研究了幾個點子
如何設計你的數據庫架構

00:42:08.762 --> 00:42:11.031
來完全避免一類錯誤

00:42:11.098 --> 00:42:13.300
或更有效利用
CloudKit API

00:42:14.935 --> 00:42:18.605
最後 我們探討了
如何處理一些類型的錯誤

00:42:18.672 --> 00:42:20.541
還有如何分辨它們

00:42:21.742 --> 00:42:24.211
還有服務器的意圖 當它返回

00:42:24.278 --> 00:42:26.446
一些特定錯誤代碼 而不是其它代碼

00:42:28.182 --> 00:42:31.051
我們昨天有一個相關演講
如果你沒有去

00:42:31.118 --> 00:42:33.520
我推薦你回去在網上補看回來

00:42:34.254 --> 00:42:37.357
這兒有更多的信息
謝謝你們 祝你們有很棒的一天