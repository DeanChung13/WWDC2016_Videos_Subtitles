00:00:19.453 --> 00:00:24.491 
SWIFT API設計準則
GRAND RENAMING

00:00:30.330 --> 00:00:31.298 
謝謝

00:00:32.999 --> 00:00:34.935 
歡迎 我是Doug Gregor

00:00:35.035 --> 00:00:37.471 
在這裏 我要跟同事
Michael Ilseman

00:00:37.571 --> 00:00:38.672 
談論關於設計的問題

00:00:39.406 --> 00:00:42.442 
因爲好的設計能提高效率

00:00:42.910 --> 00:00:46.813 
而好的API設計
能幫助我們使用Swift語言

00:00:46.980 --> 00:00:49.149 
寫出
清晰 簡練 優美的代碼

00:00:49.583 --> 00:00:52.419 
這一點完全正確
無論是當你在爲上百萬

00:00:52.486 --> 00:00:54.321 
其他開發者編寫API時

00:00:54.388 --> 00:00:57.057 
還是你在自己的應用裏
爲自己寫代碼時

00:00:57.524 --> 00:00:59.459 
因爲好的設計
真的很重要

00:01:00.527 --> 00:01:01.361 
所以...

00:01:02.629 --> 00:01:05.566 
今天我們將介紹
Swift API設計準則

00:01:05.632 --> 00:01:08.468 
這些是我們要介紹的
Swift 3的新準則

00:01:09.269 --> 00:01:11.872 
我們將介紹這些準則
背後的原則

00:01:11.939 --> 00:01:13.874 
對其中一些準則進行討論
從而瞭解

00:01:13.941 --> 00:01:16.743 
如何構建優質的Swift API

00:01:18.345 --> 00:01:22.649 
然後 我們會討論下
Grand Renaming

00:01:23.217 --> 00:01:26.053 
我們將用這個名詞
來指代這些準則

00:01:26.119 --> 00:01:28.922 
在你日常所有API中的應用

00:01:29.223 --> 00:01:30.557 
包括Swift標準庫

00:01:30.624 --> 00:01:32.693 
Cocoa和Cocoa Touch API

00:01:32.893 --> 00:01:36.330 
現在 這個Grand Renaming
將影響你的很多代碼

00:01:37.798 --> 00:01:39.600 
基本上使用Swift 2語言的
所有代碼

00:01:39.666 --> 00:01:41.902 
在Swift 3中都將
有一定程度的改變

00:01:42.436 --> 00:01:44.004 
所以...沒錯！

00:01:46.740 --> 00:01:48.876 
所以 我們將討論下
這對你的代碼意味着什麼

00:01:49.776 --> 00:01:53.347 
以及如何應對
開始適應Swift 3的思維

00:01:54.715 --> 00:01:58.085 
最後 我們將討論下
我們的一些新工具和技巧

00:01:58.418 --> 00:02:01.121 
以便將
C和Objective-C API

00:02:01.188 --> 00:02:03.690 
映射到優美的Swift API

00:02:05.425 --> 00:02:07.728 
這可涉及大量的
概念和原因解釋啊

00:02:08.127 --> 00:02:11.632 
你關於準則的
最大疑問可能是:

00:02:12.332 --> 00:02:13.166 
爲什麼？

00:02:14.635 --> 00:02:16.703 
爲什麼在使用Swift兩年後

00:02:16.770 --> 00:02:19.840 
我們要改變你日常工作
接觸的所有API

00:02:21.008 --> 00:02:24.111 
答案可以歸結爲語言的特點

00:02:24.178 --> 00:02:27.848 
因爲每種編程語言
都有自己鮮明的特點

00:02:28.215 --> 00:02:30.150 
都有自己的句法風格

00:02:31.251 --> 00:02:33.387 
但這又不光是句法

00:02:33.453 --> 00:02:35.355 
也是一種語言選擇做出的

00:02:35.422 --> 00:02:37.191 
一種折衷

00:02:37.291 --> 00:02:40.260 
它是傾向於安全
還是性能？

00:02:41.028 --> 00:02:43.564 
你是更喜歡數學的精煉性

00:02:43.630 --> 00:02:46.967 
還是更喜歡
清晰易讀的東西？

00:02:47.835 --> 00:02:51.605 
你看一下Swift代碼
就能馬上讀懂代碼

00:02:53.640 --> 00:02:56.910 
這裏 你能夠看到Swift
呈現出關於特定事物的觀點

00:02:57.077 --> 00:02:58.879 
它使用結尾閉包

00:02:58.946 --> 00:03:02.683 
所以控制流能很好地
用於庫和API

00:03:03.217 --> 00:03:07.187 
它有可能選項 所以
你必須時刻記住零值的可能性

00:03:07.254 --> 00:03:10.524 
而不能簡單忽略
這種可能性的存在

00:03:11.291 --> 00:03:15.095 
這樣 使用Swift語言時
你會有Swift的感覺

00:03:15.729 --> 00:03:18.165 
但這不光是語言引起的

00:03:18.232 --> 00:03:21.301 
而實際上是
你日夜使用的API引起的

00:03:21.635 --> 00:03:25.239 
而且API必須
與語言的特徵融合

00:03:25.506 --> 00:03:29.409 
這樣 你才能得到優美的
Swift代碼帶來的一致全面的體驗

00:03:31.211 --> 00:03:34.781 
這裏是一些
Cocoa和Cocoa Touch API

00:03:35.616 --> 00:03:40.220 
這些API的設計基於
針對Cocoa的編碼準則

00:03:41.255 --> 00:03:43.156 
你可能之前讀過這些準則
希望你讀過

00:03:43.590 --> 00:03:46.894 
這些準則
提倡在API設計中

00:03:47.361 --> 00:03:48.929 
注重清晰度和一致性

00:03:49.263 --> 00:03:53.267 
而過去十多年
我們已將這些準則

00:03:53.333 --> 00:03:54.868 
應用到成千上萬的API

00:03:55.235 --> 00:03:57.704 
用於開發Cocoa和
Cocoa Touch平臺

00:03:57.771 --> 00:03:59.239 
以及我們使用的絕妙的API

00:03:59.806 --> 00:04:02.109 
現在 而這些準則針對

00:04:02.709 --> 00:04:05.646 
具有不同特徵的另一種語言
設計

00:04:08.282 --> 00:04:11.285 
所以 當你將
爲Objective-C寫的

00:04:11.351 --> 00:04:15.422 
所有API
毫不修改地放到Swift中

00:04:16.290 --> 00:04:18.725 
就會看起來個性不合

00:04:18.791 --> 00:04:21.228 
這些API不怎麼Swifty

00:04:22.429 --> 00:04:23.697 
這又意味着什麼呢？

00:04:24.164 --> 00:04:25.465 
不Swifty？

00:04:26.133 --> 00:04:27.167 
你聽到很多人這麼說

00:04:27.901 --> 00:04:32.306 
不過 本質上
這就是爲什麼在成千上萬

00:04:32.372 --> 00:04:36.076 
開發者使用Swift平臺
兩年後

00:04:36.343 --> 00:04:38.478 
現在是進行重新評估的時候

00:04:38.779 --> 00:04:41.515 
因爲我們擁有更廣大的
開發者社區經驗

00:04:41.582 --> 00:04:44.518 
可以瞭解在Swift代碼中
什麼是有效的

00:04:45.352 --> 00:04:49.289 
所以我們開始設計
API設計準則

00:04:50.591 --> 00:04:53.660 
嘗試規定 怎樣算是構建具有
Swift特徵 即Swifty的API

00:04:53.994 --> 00:04:57.130 
以及幫助所有人
使用我們喜愛的語言

00:04:57.197 --> 00:04:58.932 
構建更加一致和清晰的API

00:05:00.400 --> 00:05:03.971 
現在
你在左下方能看到SE-0023

00:05:04.071 --> 00:05:06.340 
這是Swift的演變提案編號

00:05:06.507 --> 00:05:09.543 
其中包含所有的
API設計準則

00:05:09.643 --> 00:05:12.145 
在整個演講過程
你將看到這些提案編號

00:05:12.212 --> 00:05:14.014 
此外 你可訪問Swift.org

00:05:14.081 --> 00:05:16.416 
查找這個提案代碼
瞭解關於Swift語言

00:05:16.483 --> 00:05:20.053 
這一特定變化的詳細信息

00:05:20.621 --> 00:05:23.524 
不過現在
讓我們討論下準則本身

00:05:24.992 --> 00:05:27.761 
Swift API 設計準則的
主要原則是

00:05:28.195 --> 00:05:31.031 
在使用時清晰明瞭

00:05:31.098 --> 00:05:34.401 
就是你的API在他人代碼中
顯示時能夠清晰明瞭

00:05:36.236 --> 00:05:38.172 
我們喜歡簡練的代碼

00:05:38.572 --> 00:05:40.874 
但清晰明瞭
是最重要的方面

00:05:40.941 --> 00:05:43.310 
這比寫出簡練的代碼
要更重要

00:05:44.444 --> 00:05:47.080 
雖然如此 Swift中確實
也有簡練的代碼

00:05:47.381 --> 00:05:49.316 
Swift代碼確實會
更簡練

00:05:49.383 --> 00:05:50.817 
看到Swift語言時
我們能感到該簡練性

00:05:50.884 --> 00:05:53.420 
而在討論各種導入Swift
或使用Swift寫的應用時

00:05:53.487 --> 00:05:56.823 
我們可以實際衡量
這種簡練性

00:05:57.758 --> 00:06:00.494 
不過這要源於
使用正確的語境線索

00:06:00.994 --> 00:06:04.298 
讓我們更深入地瞭解下
這些準則並看一下一些API

00:06:05.165 --> 00:06:07.668 
現在 我們先討論下使用

00:06:09.336 --> 00:06:10.971 
爲什麼要關注使用站點呢？

00:06:11.238 --> 00:06:13.173 
嗯 一方面
這不過是簡單的數字遊戲

00:06:13.240 --> 00:06:15.042 
你寫你的API只要一次

00:06:15.576 --> 00:06:17.678 
而人們會多次看你的API代碼

00:06:17.845 --> 00:06:21.048 
或者API文檔

00:06:21.481 --> 00:06:25.018 
但API真正重要的
大多情況下

00:06:25.085 --> 00:06:28.655 
API被看到次數最多的時候
將是處在上下文語境中

00:06:28.956 --> 00:06:30.324 
周圍有大量其它代碼

00:06:30.891 --> 00:06:32.659 
當你處在這樣的語境中

00:06:32.726 --> 00:06:35.863 
你就擁有所有額外
豐富的語境信息

00:06:36.430 --> 00:06:40.601 
你擁有局部變量
及其名稱和類型

00:06:41.235 --> 00:06:43.203 
你擁有相關API的使用

00:06:43.403 --> 00:06:46.173 
而你的API的目的
不是站起來說：

00:06:46.440 --> 00:06:49.076 
“嗨 我在這兒
我信譽好 名號大”

00:06:49.510 --> 00:06:52.880 
你的API的目的是
適應其它代碼

00:06:53.180 --> 00:06:54.882 
從而產生完美的結果

00:06:56.116 --> 00:06:59.686 
那麼 當你關注用例時
一定要避免

00:07:00.387 --> 00:07:02.122 
去針對不好的代碼進行優化

00:07:03.290 --> 00:07:05.759 
這一點絕對會發生
有的人寫代碼

00:07:05.826 --> 00:07:08.462 
會對所有的變量
使用A、B和C這樣的名字

00:07:08.695 --> 00:07:10.831 
這樣的代碼不再清晰

00:07:13.433 --> 00:07:16.670 
而僅憑API並不能改善
這種不好的代碼

00:07:18.005 --> 00:07:21.742 
你能做的就只是
讓其它代碼更囉嗦或更不清楚

00:07:22.976 --> 00:07:25.345 
所以請關注適當的用例

00:07:25.412 --> 00:07:28.248 
關注好的代碼
針對好的代碼去調整API

00:07:30.184 --> 00:07:32.286 
這裏 讓我們實際
看一個具體的例子

00:07:32.486 --> 00:07:34.354 
那麼 讓我們首先看一個API

00:07:35.255 --> 00:07:37.224 
從集合中刪除一個項目

00:07:38.458 --> 00:07:40.627 
首先 我們將它命名爲
“removeItem”

00:07:41.261 --> 00:07:43.697 
聽起來不錯
但這是我犯的第一個錯誤

00:07:43.797 --> 00:07:45.465 
這不是用例

00:07:45.532 --> 00:07:47.467 
這只是簡要的名稱

00:07:48.001 --> 00:07:51.004 
那麼 讓我們顯示今天
我想到的一個用例

00:07:51.638 --> 00:07:52.472 
不要問爲什麼

00:07:52.706 --> 00:07:56.944 
他知道 將項目“ted”
從好友列表中刪除

00:07:57.811 --> 00:08:00.514 
現在 你會注意到
該用例中實際有兩個東西

00:08:00.581 --> 00:08:03.617 
指示參數是什麼

00:08:03.684 --> 00:08:05.485 
這兩個東西都試圖
對參數進行描述

00:08:05.552 --> 00:08:07.721 
其中一個是單詞“item”
也是名稱的一部分

00:08:08.722 --> 00:08:10.324 
另一個是參數“ted”

00:08:10.390 --> 00:08:12.526 
即一定類型的某個局部變量

00:08:12.926 --> 00:08:18.332 
這兩個符號中 變量
“ted”實際能更好地描述

00:08:18.398 --> 00:08:19.533 
參數是什麼

00:08:19.900 --> 00:08:21.101 
它是處在語境中的

00:08:21.168 --> 00:08:24.505 
在語境中讀取此調用時
你會知道這個局部變量是什麼

00:08:24.571 --> 00:08:26.673 
它表示一定意義
它具備強類型

00:08:28.008 --> 00:08:29.810 
所以這裏的問題
實際可能是

00:08:30.177 --> 00:08:33.280 
單詞“item”
描述性不夠強

00:08:33.714 --> 00:08:35.315 
也許改爲
“removeObject”

00:08:35.381 --> 00:08:36.950 
我們會覺得舒服點

00:08:38.085 --> 00:08:39.553 
不過
也許事實也不是這樣

00:08:39.620 --> 00:08:41.822 
因爲無論如何
我們很可能用的是值類型

00:08:41.889 --> 00:08:43.657 
所以這只是活躍性的錯誤

00:08:44.057 --> 00:08:46.460 
我們可以改爲
“removeElement”

00:08:46.894 --> 00:08:49.696 
好 Swift語言的集合
也使用element術語

00:08:50.597 --> 00:08:52.900 
不過 這樣也不起作用

00:08:53.667 --> 00:08:56.670 
而且 如果我們開始
寫下不同的用例

00:08:56.870 --> 00:08:59.339 
實際上可能會更不清晰

00:09:00.374 --> 00:09:02.009 
我想將“caffeine”

00:09:02.075 --> 00:09:03.844 
這個元素從有機化合物
列表中移除

00:09:04.411 --> 00:09:05.846 
這是誤導性的
錯誤的

00:09:05.913 --> 00:09:07.181 
“咖啡因”不是元素

00:09:07.481 --> 00:09:09.082 
它是元素組成的化合物

00:09:09.550 --> 00:09:12.186 
所以 這裏我們試圖使用
一些無傷大雅的詞

00:09:12.252 --> 00:09:16.590 
來描述參數 這實際讓我們
寫出了更模糊的用例

00:09:18.225 --> 00:09:19.059 
好

00:09:19.660 --> 00:09:22.329 
所以 可能問題是
我們應該停止

00:09:22.396 --> 00:09:24.665 
將這些看似無傷大雅的
概括詞用在那裏

00:09:24.731 --> 00:09:26.266 
我們應該特別具體

00:09:26.433 --> 00:09:28.836 
將“ted”這個人
從好友列表中移除

00:09:30.337 --> 00:09:31.872 
這句英語有點怪

00:09:32.439 --> 00:09:34.575 
我不會這麼說 我只會說
“remove(ted)”移除ted

00:09:35.209 --> 00:09:36.343 
不過進一步講

00:09:37.444 --> 00:09:40.180 
如果我這麼做了
如果對這種一般性的API

00:09:41.281 --> 00:09:44.985 
我做到了特別具體 那麼
我會期待任何時候都很具體

00:09:45.819 --> 00:09:48.956 
現在 有一個概念性的API
即 只是將某個項目

00:09:49.022 --> 00:09:52.492 
從集合中移除 而該項目
在源數據庫基中有不同的名稱

00:09:53.660 --> 00:09:55.295 
這樣就更難理解了

00:09:55.362 --> 00:09:56.997 
很難識別出
我們實際說的

00:09:57.064 --> 00:09:59.299 
是在不同語境中的
同一樣東西

00:09:59.666 --> 00:10:03.403 
所以 Swift API設計準則
採取了不同的方法

00:10:05.172 --> 00:10:07.341 
略去不必要的單詞

00:10:09.243 --> 00:10:13.113 
如果一個單詞
不能使使用站點更清晰

00:10:13.280 --> 00:10:14.548 
就不用這個單詞

00:10:15.115 --> 00:10:17.017 
所以我們可以只是說
從好友列表中“remove(ted)”

00:10:17.084 --> 00:10:18.385 
這樣讀起來很順

00:10:18.852 --> 00:10:21.822 
這種做法之所以在Swift中
如此出色地實現

00:10:22.656 --> 00:10:25.959 
原因之一是 Swift有
強大的靜態類型系統

00:10:27.227 --> 00:10:30.797 
可以確保你不會寫出
無意義的代碼

00:10:30.864 --> 00:10:32.266 
或者對代碼解釋錯誤

00:10:32.332 --> 00:10:35.269 
所以 強大的
靜態類型系統能確保

00:10:35.335 --> 00:10:37.304 
你允許移除的參數

00:10:37.538 --> 00:10:40.207 
是相應集合中的元素

00:10:41.308 --> 00:10:43.911 
如果你要做出
任何失策的舉動

00:10:43.977 --> 00:10:47.714 
比如 試圖從好友列表中
移除“caffeine”咖啡因

00:10:48.582 --> 00:10:52.019 
你會收到編譯器發出的錯誤消息
告訴你代碼不符合邏輯

00:10:54.621 --> 00:10:58.258 
所以 我們討論了
使用站點的可讀性

00:10:59.359 --> 00:11:01.695 
我們排除了很多的單詞

00:11:01.828 --> 00:11:05.232 
你可能因此覺得
我們追求的是簡練的代碼

00:11:06.066 --> 00:11:07.935 
事實並非如此
我們想要清晰的代碼

00:11:08.936 --> 00:11:09.770 
不過...

00:11:10.304 --> 00:11:13.173 
清晰的代碼
也需要達到適當的平衡

00:11:13.240 --> 00:11:16.076 
不能過短或過長

00:11:16.510 --> 00:11:19.146 
如果想知道
什麼代碼過長

00:11:19.213 --> 00:11:23.750 
過長的代碼是
包含不必要額外信息的代碼

00:11:25.085 --> 00:11:27.654 
過長的代碼
實際會影響清晰度

00:11:27.855 --> 00:11:31.491 
因爲 在讀這種冗長代碼時
你的腦子在做什麼？

00:11:32.159 --> 00:11:35.462 
它在努力篩除
所有額外的噪聲

00:11:35.529 --> 00:11:37.831 
篩除所有冗餘的
不必要的東西

00:11:37.898 --> 00:11:39.533 
從而找到代碼中
實際的信息

00:11:40.868 --> 00:11:43.136 
而這個平衡的另一端
也不可取

00:11:43.203 --> 00:11:44.838 
如果你的代碼過於簡練

00:11:45.138 --> 00:11:47.274 
那麼你可能遺漏必要的信息

00:11:47.608 --> 00:11:50.377 
以致使代碼難以理解

00:11:51.345 --> 00:11:54.448 
什麼表明代碼過於簡練

00:11:54.681 --> 00:11:57.351 
如果你在讀代碼
你發現自己會總是參考

00:11:57.417 --> 00:11:59.520 
API文檔
因爲API本身描述不夠清楚

00:11:59.686 --> 00:12:02.656 
則說明代碼過於簡練

00:12:03.757 --> 00:12:06.159 
所以我們要找到
中間最佳的平衡點

00:12:06.460 --> 00:12:08.462 
使代碼既清晰

00:12:09.730 --> 00:12:11.164 
又簡練

00:12:11.298 --> 00:12:14.201 
這樣 瞭解API和API工作
方式需要的所有信息

00:12:14.268 --> 00:12:17.671 
都在語境信息中

00:12:18.372 --> 00:12:21.008 
這實際上是
Swift語言本身的原則

00:12:21.074 --> 00:12:23.110 
所以 這裏我提供
一些代碼

00:12:24.511 --> 00:12:27.881  
在這些代碼中
實際存在

00:12:28.382 --> 00:12:30.517  
Swift中不需要的
冗長信息

00:12:30.784 --> 00:12:34.154  
就是這些
直白的類型註解

00:12:34.922 --> 00:12:36.957  
這些註解
沒有增強代碼的可讀性

00:12:37.925 --> 00:12:40.827  
僅通過讀API
你就可以瞭解這些類型是什麼

00:12:41.061 --> 00:12:44.231  
實際上 在Swift中
你很可能不會這樣寫代碼

00:12:44.364 --> 00:12:46.900  
你可能會匹配這種類型信息

00:12:46.967 --> 00:12:48.502  
讓靜態類型trebicore

00:12:48.602 --> 00:12:51.238  
幫你作註解
從而使代碼更簡練

00:12:51.405 --> 00:12:53.607  
也仍然清晰可讀

00:12:54.474 --> 00:12:56.243  
當然 類型很重要

00:12:56.310 --> 00:12:57.578  
類型就在那裏

00:12:57.644 --> 00:13:00.280  
如果你需要確定
特定的類型是什麼

00:13:00.347 --> 00:13:01.715  
而這樣能有助於你理解

00:13:01.782 --> 00:13:05.152  
當然 你可以選擇獲取答案
只需在Xcode內單擊

00:13:07.888 --> 00:13:09.489 
那麼 讓我們看一下
另一個API

00:13:09.556 --> 00:13:13.660 
並討論下什麼時候
實際需要一個單詞

00:13:13.894 --> 00:13:15.829 
纔有助於描述參數

00:13:16.797 --> 00:13:19.733 
我們以這個小API爲例
即 將“子視圖”

00:13:20.200 --> 00:13:23.537 
添加到某個“主視圖”中的
某個特定點

00:13:24.104 --> 00:13:25.439 
因此 我們寫出用例

00:13:25.539 --> 00:13:26.974 
記住始終從用例開始

00:13:27.040 --> 00:13:29.476 
想一下用來描述
參數的詞

00:13:29.610 --> 00:13:32.713 
在第一種情況下
單詞“child”用在了

00:13:32.779 --> 00:13:35.315 
這個“視圖”參數中
也就是我們第一參數

00:13:36.049 --> 00:13:37.918 
“child” 表達了什麼信息嗎?

00:13:38.051 --> 00:13:39.586 
嗯 從靜態類型系統中
我們知道

00:13:39.653 --> 00:13:42.422 
邊欄會是
某種視圖

00:13:44.758 --> 00:13:47.494 
但單詞“child”可以說明操作中

00:13:47.561 --> 00:13:49.463 
此參數的作用

00:13:49.530 --> 00:13:53.200 
它表明了
這裏的參數將成爲“child”

00:13:53.333 --> 00:13:55.002 
它建立了層次結構

00:13:55.202 --> 00:13:59.706 
這確實是很重要的信息
便於我們瞭解這個API的作用

00:14:02.543 --> 00:14:07.414 
現在 第二個參數中
存在“atPoint”和“origin”

00:14:07.681 --> 00:14:10.684 
“origin”會是什麼？
嗯 它將會是CGPoint

00:14:10.751 --> 00:14:12.452 
這個API會使用CGPoint

00:14:12.519 --> 00:14:15.289 
這裏除了CGPoint
你也提供不了什麼

00:14:16.957 --> 00:14:18.992 
所以這個單詞
不能表示實際意義

00:14:19.059 --> 00:14:21.395 
它只是在重複說明
強靜態類型系統中

00:14:21.461 --> 00:14:24.464 
已經存在
並將被Swift語言

00:14:24.631 --> 00:14:26.233 
實施的信息

00:14:26.800 --> 00:14:28.368 
所以去掉這個詞
你不需要它

00:14:29.002 --> 00:14:30.771 
現在看看
這裏調用站點的樣子

00:14:30.838 --> 00:14:35.042 
如果大聲讀出來
你在“origin”添加“child”邊欄

00:14:36.443 --> 00:14:37.678 
讀起來語法很對

00:14:38.779 --> 00:14:39.847 
這是這種

00:14:39.913 --> 00:14:43.550 
特定API設計準則的
原則之一

00:14:43.717 --> 00:14:47.020 
即 我們力爭達到
使用點通順並語法正確

00:14:47.688 --> 00:14:50.224 
這裏的例子 從我們的
好友列表中移除“remove(ted)”

00:14:50.724 --> 00:14:51.959 
就具備這種特點

00:14:52.593 --> 00:14:54.661 
現在 讓我們看看
一個非常相關的API

00:14:54.761 --> 00:14:57.731 
這個API
是要移除特定的元素

00:14:58.131 --> 00:15:01.902 
如果我們看 比如
移除特定位置某項目的API

00:15:02.069 --> 00:15:02.936 
讀出來

00:15:03.203 --> 00:15:06.974 
從集合中移除
之前好友的位置

00:15:07.241 --> 00:15:08.108 
讀起來不對

00:15:08.175 --> 00:15:10.511 
這不是位置的集合

00:15:10.777 --> 00:15:12.179 
而是人的集合

00:15:13.814 --> 00:15:18.218 
讓這句話實際讀起來
符合邏輯 我們要說“remove at”

00:15:19.720 --> 00:15:20.654 
讓我們讀出來：

00:15:20.721 --> 00:15:23.457 
在之前好友的位置移除

00:15:23.991 --> 00:15:27.594 
請注意我們
澄清API行爲的方法

00:15:28.929 --> 00:15:31.999 
是放入第一個
參數標籤 以描述

00:15:32.065 --> 00:15:34.801 
參數與該方法的關係

00:15:36.703 --> 00:15:39.406 
這就涉及命名
和命名的概念

00:15:39.640 --> 00:15:43.143 
所以 在Swift中
一個函數的名稱包括

00:15:43.210 --> 00:15:47.080 
所謂的基名稱在這兩個API中
即“remove”

00:15:47.414 --> 00:15:51.218 
以及參數的
所有參數標籤

00:15:51.451 --> 00:15:55.055 
所以這兩個相關的API
它們有相同的基名稱

00:15:55.122 --> 00:15:57.824 
即“remove” 因爲它們屬於
相同操作方法系列

00:15:57.891 --> 00:15:59.526 
即從集合中移除某項目

00:15:59.860 --> 00:16:01.762 
但它們的
參數標籤不同

00:16:02.229 --> 00:16:04.364 
因爲它們
做的事情不同

00:16:04.431 --> 00:16:07.367 
一個是按照身份
移除元素

00:16:07.601 --> 00:16:11.805 
另一個是基於
在系列中的位置移除元素

00:16:12.739 --> 00:16:15.075 
所以略微不同的API
擁有不同的名稱

00:16:15.375 --> 00:16:19.413 
現在 你可以
基於類型信息進行重載

00:16:19.646 --> 00:16:22.683  
如果兩個API
擁有同一複合名稱

00:16:23.150 --> 00:16:24.852  
但只有當API的語義

00:16:25.285 --> 00:16:28.222  
相同時你才能這樣做

00:16:28.522 --> 00:16:30.557  
所以這裏你可以重載

00:16:30.624 --> 00:16:32.993  
沒有參數標籤的附加名稱
從而將字符

00:16:33.060 --> 00:16:34.294  
或字符串附加到
某些文本

00:16:34.528 --> 00:16:36.897  
因爲它們根本上
屬於相同的操作

00:16:36.964 --> 00:16:39.633  
它們只是出於方便起見
被重載到不同的類型上

00:16:41.235 --> 00:16:43.704  
現在
寫出第一參數標籤後

00:16:43.770 --> 00:16:47.641 
同樣 你需要保證
用例讀起來符合語法規則

00:16:47.708 --> 00:16:49.810 
這包括方法的基名稱

00:16:49.910 --> 00:16:51.678 
以及參數標籤

00:16:52.212 --> 00:16:56.283 
所以這是我第一個API：
removeBoxes (withLabel:WWDC)

00:16:57.117 --> 00:16:58.318 
注意這讀起來順不順

00:16:58.585 --> 00:17:02.623 
注意 這個API內
有一個介詞短語

00:17:03.257 --> 00:17:06.393 
所以這有點像英語語法
本質上這個短語是“withLabel”

00:17:06.460 --> 00:17:09.596 
它描述參數
與移除方框的實際操作

00:17:10.097 --> 00:17:12.699 
之間的關係

00:17:12.766 --> 00:17:14.835 
當存在
這些介詞短語中之一時

00:17:14.902 --> 00:17:17.905 
將它放在第一參數標籤上
以描述第一個參數

00:17:19.540 --> 00:17:21.340 
如果你根本
無法構成符合語法規則的短語

00:17:21.407 --> 00:17:23.777 
也可以使用第一參數標籤

00:17:23.844 --> 00:17:25.212 
因爲如果
將第一參數放在那兒

00:17:25.279 --> 00:17:26.914 
具有一定誤導性

00:17:26.980 --> 00:17:30.150 
所以這裏 我們有“viewController”
我們說“dismiss(true)”

00:17:31.451 --> 00:17:34.521 
那是什麼？我不能
把布爾常數到處亂放

00:17:35.989 --> 00:17:38.158 
所以 要讓這句
符合語法規則

00:17:38.325 --> 00:17:40.260 
我需要在那兒
放上一個參數標籤

00:17:40.561 --> 00:17:41.995 
解除“viewController”

00:17:42.262 --> 00:17:44.064 
變成動畫
Animated爲真

00:17:44.231 --> 00:17:46.400 
所以這是
附帶的額外信息

00:17:46.466 --> 00:17:50.370 
第一參數標籤將它分解開
所以讀起來很順

00:17:50.671 --> 00:17:54.508 
而且很清楚 我們解除的
就是實際的視圖控制器

00:17:55.375 --> 00:17:58.111 
你可以訪問Swift.org
閱讀其它若干規則

00:17:58.212 --> 00:18:02.516 
但本質上 你仍會在某些
情況下略去第一參數標籤

00:18:02.683 --> 00:18:05.986  
這些情況下
在API中僅僅是有自變量

00:18:06.053 --> 00:18:07.387  
就讀着很順：

00:18:07.454 --> 00:18:10.490  
在好友的
起始索引處插入“michael”

00:18:11.458 --> 00:18:12.292  
這讀起來很順

00:18:12.359 --> 00:18:14.795  
我們不需要第一參數標籤
使它讀起來通順

00:18:14.862 --> 00:18:15.896  
所以我們將標籤省略

00:18:18.532 --> 00:18:19.566 
好

00:18:20.234 --> 00:18:23.070 
在繼續之前
我們稍稍再介紹下命名

00:18:23.537 --> 00:18:27.941 
在對方法進行命名時
基於方法的副作用命名

00:18:28.242 --> 00:18:31.011 
所以 請使用英語動詞
和命令

00:18:31.078 --> 00:18:33.881 
告訴接收方“做某事”

00:18:34.815 --> 00:18:37.317 
所以這裏 我們可能說
我們有好友集合

00:18:37.384 --> 00:18:39.987 
對它進行反轉
“viewController”　請顯示

00:18:40.053 --> 00:18:42.189 
“Organic compounds”
請附加

00:18:42.623 --> 00:18:44.258 
對吧？這些是採取的操作

00:18:44.458 --> 00:18:46.126 
我們基於採取的操作命名

00:18:46.760 --> 00:18:50.531 
現在 我們有一些方法
其主要作用就僅僅是

00:18:50.664 --> 00:18:52.266 
返回某值

00:18:54.434 --> 00:18:55.903 
我們使用名詞

00:18:55.969 --> 00:18:58.906 
描述返回的東西

00:18:59.373 --> 00:19:02.142 
所以 這裏我們可以
要求獲取按鈕的背景標題

00:19:02.209 --> 00:19:04.378 
或者好友陣列的後綴

00:19:07.147 --> 00:19:09.283 
當你在處理值類型時

00:19:10.551 --> 00:19:12.819 
有時情況是這樣的
你擁有本質上相同操作的

00:19:12.886 --> 00:19:16.123 
轉變和未轉變形式

00:19:16.423 --> 00:19:17.691 
這裏我們喜歡稱作

00:19:17.758 --> 00:19:20.194 
使用我們喜歡稱作
“ed/ing規則”的東西

00:19:21.562 --> 00:19:24.565 
這來自英語語法

00:19:24.631 --> 00:19:27.301 
基本上你要從動詞形式開始

00:19:27.634 --> 00:19:29.603 
所以這裏 我們有
“reverse a collection”

00:19:29.670 --> 00:19:31.905 
你命令X
自身反轉

00:19:33.473 --> 00:19:36.276 
而對於
更像是名詞的其他形式

00:19:36.410 --> 00:19:37.511 
使用“ed規則”

00:19:37.678 --> 00:19:39.913 
我們要求X被反轉

00:19:40.514 --> 00:19:43.217 
我們描述我們想要的結果

00:19:43.584 --> 00:19:45.586 
這就與轉變形式對應

00:19:46.220 --> 00:19:47.721  
而“ed規則”不適用時

00:19:47.788 --> 00:19:49.590  
一般適用“ing規則”

00:19:50.290 --> 00:19:52.392  
通常這時
這裏有一個參數

00:19:52.459 --> 00:19:53.760  
我們有一個文檔目錄

00:19:53.827 --> 00:19:55.495  
我們可以對目錄
附加路徑組件

00:19:55.896 --> 00:19:58.298  
這就是轉變
我們告訴它附加這個

00:19:59.299 --> 00:20:00.701 
現在我們有未轉變形式

00:20:00.767 --> 00:20:04.438 
給我這個文檔目錄
附加這個特定的路徑組件

00:20:06.006 --> 00:20:10.711 
所以這些規則 以及許多
其他規則 在Swift.org上

00:20:10.777 --> 00:20:13.013 
作爲API設計準則文檔的
一部分 都有描述

00:20:13.313 --> 00:20:14.848 
強烈推薦大家
進行閱讀

00:20:15.549 --> 00:20:17.551 
並努力在自己的API中應用

00:20:19.019 --> 00:20:20.954 
不過 當然

00:20:21.421 --> 00:20:24.525 
只有實際廣泛應用了
這些準則纔會變得有趣

00:20:25.025 --> 00:20:28.161 
所以我們要進行
Grand Renaming

00:20:28.729 --> 00:20:31.798 
就是將這些準則

00:20:32.165 --> 00:20:34.034 
應用於Swift標準庫

00:20:34.501 --> 00:20:36.904 
應用於Cocoa
和Cocoa Touch API

00:20:37.371 --> 00:20:39.072 
以及應用於指向性地

00:20:39.306 --> 00:20:41.875 
改進API 如Core Graphics
以及Grand Central Dispatch

00:20:41.942 --> 00:20:45.646 
這些準則可用在所有情況下
讓這些API經過Swifty整容

00:20:45.712 --> 00:20:47.014 
從而在Swift中更美觀

00:20:48.482 --> 00:20:50.851 
我之前稍微提到
Grand Renaming的規模

00:20:50.918 --> 00:20:53.353 
所以 這是一個
小Swift應用的截屏

00:20:53.720 --> 00:20:57.357 
應用叫做Lister
這個應用已經發售幾年了

00:20:57.424 --> 00:21:02.429 
在從Swift 2遷移到Swift 3時
Lister是樣本應用之一

00:21:02.963 --> 00:21:05.832 
大家可以看到左邊
有很多.swift文件

00:21:06.533 --> 00:21:09.770 
基本上 整個項目中
每一個Swift文件

00:21:09.837 --> 00:21:12.339 
都因爲從Swift 2到
Swift 3的過渡而改變了

00:21:13.106 --> 00:21:16.844 
如果你們留意這裏
中間和右側窗格中的一些細節

00:21:17.411 --> 00:21:21.081 
你們可能發現
這些Cocoa API名稱都變了

00:21:23.016 --> 00:21:26.019 
所以 這裏有很多改變
我們將就此進行介紹

00:21:26.386 --> 00:21:30.457 
不過 非常有趣的是
這些你們可能

00:21:30.524 --> 00:21:33.493 
已使用很長時間的Cocoa API
這些API是一樣的

00:21:33.560 --> 00:21:36.763 
但現在 一個特定的API
有兩個不同的名稱

00:21:37.731 --> 00:21:40.000 
一個名稱適用於
Objective-C

00:21:40.701 --> 00:21:42.970 
另一個名稱適用於Swift

00:21:45.005 --> 00:21:48.742 
作爲Swift程序員
大多時候你不必在意這一點

00:21:49.243 --> 00:21:52.145 
你完全可以
在Swift名稱下工作

00:21:52.479 --> 00:21:54.515 
使用你生成的界面和文檔

00:21:54.581 --> 00:21:57.251 
所有材料都將顯示Swift名稱
Swift名稱就是你要應對的

00:21:57.317 --> 00:21:59.786 
不過 有時你跟系統交互
這種情況下

00:22:00.387 --> 00:22:02.155 
你實際上
確實需要Objective-C名稱

00:22:02.222 --> 00:22:04.591 
比如 如果你
要激活目標操作

00:22:04.791 --> 00:22:06.527 
所以 這裏我們實際需要

00:22:06.593 --> 00:22:08.862 
爲目標操作提供選擇器

00:22:09.096 --> 00:22:10.797 
我們有這個字符串參數

00:22:11.431 --> 00:22:12.466 
在這裏寫什麼呢？

00:22:13.767 --> 00:22:16.170 
我不知道
你可以看看生成的界面

00:22:16.303 --> 00:22:19.339 
或者在Twitter之類網站上
問你的Swift編程朋友

00:22:19.473 --> 00:22:21.542 
你能得到答案
這沒問題

00:22:21.675 --> 00:22:23.477 
但是 請不要這樣做

00:22:24.244 --> 00:22:26.647 
因爲這個鏈接
非常非常薄弱

00:22:27.114 --> 00:22:29.883 
這個字符串參數
非常容易輸錯

00:22:30.184 --> 00:22:32.719 
它跟上面你實際想要
調用的方法之間的鏈接很薄弱

00:22:33.253 --> 00:22:37.124 
爲此 在Swift 2.2中
我們引入了#selector

00:22:38.292 --> 00:22:40.794 
#selector非常簡單
就是一個表達式

00:22:41.128 --> 00:22:43.997 
它接收Swift方法的名稱

00:22:44.731 --> 00:22:47.100 
然後產生該方法的
Objective-C名稱

00:22:47.167 --> 00:22:49.603 
你不需關心
Objective-C名稱是什麼

00:22:49.670 --> 00:22:51.071 
編譯器會搞清楚

00:22:51.271 --> 00:22:52.840 
當然 這一點最棒的是

00:22:52.906 --> 00:22:55.142 
Swift確保存在該方法

00:22:55.542 --> 00:22:57.744 
確保該方法
向Objective-C公開

00:22:58.145 --> 00:22:59.479 
並計算出正確的名稱

00:22:59.580 --> 00:23:01.815 
當然
這可防止重構

00:23:01.982 --> 00:23:03.250 
可以使用代碼補全

00:23:03.350 --> 00:23:05.319 
讓你享受
更舒適的開發體驗

00:23:05.385 --> 00:23:08.021 
這意味着你無需擔心
Objective-C名稱

00:23:08.822 --> 00:23:11.959 
在Swift 3中 對此進行了
延伸 你也可以參考屬性的

00:23:12.025 --> 00:23:13.327 
接受方和設置方

00:23:13.560 --> 00:23:14.595 
所以我們完成了

00:23:14.661 --> 00:23:17.164 
實際能計算的
Objective-C方法名設置

00:23:17.364 --> 00:23:18.532 
這使用起來非常簡單

00:23:18.599 --> 00:23:21.134 
你只需輸入參數標籤
設置方或接受方

00:23:21.201 --> 00:23:23.337 
就可以分別獲得
設置方或接受方

00:23:23.504 --> 00:23:25.706 
然後參看
Objective-C屬性

00:23:26.240 --> 00:23:28.108 
當然
編譯器會驗證

00:23:28.175 --> 00:23:30.944 
該屬性是否存在
並向Objective-C公開

00:23:31.011 --> 00:23:33.413 
爲該屬性獲取
正確Objective-C名稱

00:23:34.915 --> 00:23:37.985 
現在 提到Objective-C方法名

00:23:38.051 --> 00:23:40.053 
選擇器並不是
唯一字符串類的東西

00:23:40.320 --> 00:23:43.824 
我們也有項路徑
當作爲字符串參數

00:23:44.825 --> 00:23:48.028 
編寫而沒有任何驗證時
項路徑是出了名的難寫對

00:23:48.562 --> 00:23:52.733 
所以在Swift 3中
我們也將引入#keyPath

00:24:01.275 --> 00:24:03.777 
#keyPath的作用
跟你們料想的一模一樣

00:24:03.911 --> 00:24:07.381  
你可以參考圓點間隔的
屬性訪問序列

00:24:07.681 --> 00:24:10.817  
編譯器會驗證這些屬性
實際上是Objective-C屬性

00:24:11.251 --> 00:24:12.419  
獲取正確的名稱

00:24:12.786 --> 00:24:16.990  
然後生成我們傳遞到
框架中的字符串

00:24:17.057 --> 00:24:19.626  
所以通過#selector
和#keyPath

00:24:19.893 --> 00:24:23.263  
你基本不需要擔心
Objective-C名稱

00:24:23.997 --> 00:24:26.533  
你只需要使用
Swift名稱編程

00:24:26.667 --> 00:24:28.535  
然後停留在
這套Swift名稱裏

00:24:28.602 --> 00:24:30.404  
你無需遊走於邊界兩邊

00:24:31.471 --> 00:24:33.507 
現在 有的情況下
你確實需要考慮

00:24:33.574 --> 00:24:35.309 
Objective-C名稱爲何

00:24:35.409 --> 00:24:37.744 
你可能有一個混合項目
裏面有Objective-C代碼

00:24:37.811 --> 00:24:40.080 
需要關聯到
你Swift代碼中的名稱

00:24:40.314 --> 00:24:43.016  
像這樣的名稱：
“handleDragWithSender4”

00:24:43.083 --> 00:24:45.953  
在Objective-C中時
感覺就是不太對

00:24:46.887 --> 00:24:51.225  
所以這些情況下
你可以使用@objc屬性

00:24:51.425 --> 00:24:54.695  
在圓括號中 輸入你想要的
確切的Objective-C名稱

00:24:55.262 --> 00:24:57.931  
該名稱會體現到
你生成的標頭和所有元數據

00:24:57.998 --> 00:25:01.068  
等等當中
這樣你能夠具體控制

00:25:01.134 --> 00:25:02.836  
Objective-C名稱

00:25:03.303 --> 00:25:06.039  
但是你Swift代碼的
其他部分都無須在意這一點

00:25:07.641 --> 00:25:11.845 
當然 這個@objc
具備名稱 適用於屬性

00:25:11.912 --> 00:25:14.147 
適用於方法、類和協議

00:25:14.214 --> 00:25:17.417 
任何可以從Swift向
Objective-C公開的對象

00:25:17.851 --> 00:25:19.353 
你可以在這裏控制名稱

00:25:19.887 --> 00:25:23.090 
所以對於Swift代碼
你可得到漂亮的Objective-C API

00:25:25.025 --> 00:25:25.859 
好

00:25:26.593 --> 00:25:28.762 
Swift 3 發生了很多改變

00:25:29.897 --> 00:25:32.999 
Swift語言本身
讓你無需考慮

00:25:33.066 --> 00:25:34.468 
Objective-C名稱

00:25:34.535 --> 00:25:37.171 
然而當你確實在意
Objective-C名稱時

00:25:37.237 --> 00:25:39.339 
它又讓你可以獲取
所需的掌控力

00:25:40.874 --> 00:25:42.743 
我們有這些工具幫助你

00:25:43.977 --> 00:25:47.614 
所以Swift 3遷移器進入
Swift 2代碼並將它

00:25:47.681 --> 00:25:49.917 
遷移到Swift 3名稱
和Swift 3語法

00:25:50.150 --> 00:25:51.418 
這涉及很多變化

00:25:52.286 --> 00:25:54.321 
但這些工具可以幫助你
渡過難關

00:25:54.388 --> 00:25:56.123 
適應Swift 3下的工作

00:25:57.090 --> 00:25:59.493 
Swift 3遷移器
是很棒的工具

00:25:59.726 --> 00:26:02.362 
但它不能遷移
你的肌肉記憶

00:26:02.863 --> 00:26:06.600 
當然也無法遷移從堆棧溢出
複製粘貼的所有代碼

00:26:09.136 --> 00:26:11.839 
所以 Swift編譯器
也可以爲你提供幫助

00:26:12.139 --> 00:26:14.508 
Swift編譯器
瞭解所有這些API的

00:26:14.575 --> 00:26:17.344  
Swift 2名稱
和Swift 3名稱

00:26:17.444 --> 00:26:20.647  
所以如果你在一些
Swift 2代碼中編寫或複製

00:26:20.814 --> 00:26:24.585  
編譯器會識別
舊的API名稱並向你提供診斷

00:26:24.651 --> 00:26:27.654  
使用Fix-its更新代碼
幫助你快速適應並工作

00:26:28.989 --> 00:26:31.491  
此外 我們引入了
相近差錯檢測

00:26:31.625 --> 00:26:33.994  
在實施可選協議方法時
可用

00:26:34.094 --> 00:26:36.997 
所以 當你在實施
委託時 這個功能很棒

00:26:37.231 --> 00:26:39.600 
你犯了個小錯誤

00:26:39.666 --> 00:26:41.568 
你想要實施的委託方法
名稱錯了

00:26:41.668 --> 00:26:44.404 
現在你收到警告消息
附帶Fix-it 以便修復名稱

00:26:44.705 --> 00:26:47.341 
這樣你可以放心
你的方法會被準確調用

00:26:49.877 --> 00:26:52.980 
現在 我想將舞臺
交給我的同事Michael

00:26:53.280 --> 00:26:56.950 
他將介紹將C和
Objective-C API映射到Swift

00:27:07.661 --> 00:27:09.062 
所以Swift很了不起

00:27:09.296 --> 00:27:12.499 
但如果你是
Objective-C開發者呢？

00:27:12.666 --> 00:27:14.301 
或者你的項目是
混合項目呢？

00:27:14.868 --> 00:27:17.671 
所有Objective-C API
在Swift中都有

00:27:17.771 --> 00:27:18.839 
它們一直都在那裏

00:27:19.173 --> 00:27:22.643 
但正如Doug解釋的
這些API是針對另一種語言設計的

00:27:22.910 --> 00:27:27.347 
在Swift中 它們日漸顯得
有點格格不入

00:27:28.348 --> 00:27:30.617 
所以今天我將展示
你將如何控制局面

00:27:30.684 --> 00:27:34.521 
使你的Swift用戶獲得
應有的優質API

00:27:36.757 --> 00:27:38.926 
我會先開始展示
幾個Objective-C API

00:27:38.992 --> 00:27:40.661 
它們被導入到了Swift 2中

00:27:41.061 --> 00:27:44.865 
這裏有兩個方法
saveToURL forSaveOperation

00:27:44.932 --> 00:27:46.967 
和revertToContentsOfURL

00:27:47.301 --> 00:27:52.406 
不過這些確實沒有體現
Doug介紹的API設計準則

00:27:52.472 --> 00:27:55.175 
裏面有很多冗餘的類型信息

00:27:55.475 --> 00:27:58.979 
我們沒有有效地利用
第一參數標籤

00:27:59.046 --> 00:28:00.113 
第一參數標籤

00:28:02.082 --> 00:28:04.384 
我會先開始介紹
你在Swift 3編譯器中

00:28:04.451 --> 00:28:05.652 
自動免費獲取的功能

00:28:05.919 --> 00:28:09.489 
Swift 3改進了
Objective-C API的導入方法

00:28:11.425 --> 00:28:15.329 
Swift編譯器將檢查
方法名並使用語法正確的提示

00:28:15.395 --> 00:28:18.498 
以便推斷第一參數標籤

00:28:23.070 --> 00:28:25.305 
Swift編譯器
將檢查名稱

00:28:25.372 --> 00:28:27.508 
從而消除冗餘類型信息

00:28:30.477 --> 00:28:33.480 
編譯器甚至可以推斷一般
Objective-C習慣用語的

00:28:33.547 --> 00:28:36.884 
默認參數
如完成處理程序

00:28:38.085 --> 00:28:39.887 
或選項集

00:28:42.155 --> 00:28:47.094 
同時 有新的值類型
如連接到NSURL的URL

00:28:47.461 --> 00:28:50.097 
所以導入時
我們只需直接導入

00:28:53.033 --> 00:28:55.335 
要了解這些值類型的
詳細信息 請訪問

00:28:55.402 --> 00:28:58.172 
今天隨後的
“Swift基礎的新特性”

00:29:00.207 --> 00:29:02.276 
所以 自動推斷非常棒

00:29:02.342 --> 00:29:04.845 
但根本上
它是啓發式推動的

00:29:04.978 --> 00:29:07.481 
編譯器不懂讀心術

00:29:07.548 --> 00:29:09.216 
它不知道你的意圖

00:29:09.483 --> 00:29:12.819 
經常
你需要指定自己的名稱

00:29:13.587 --> 00:29:15.289 
爲此 我們擴展了
NS Swift名稱

00:29:15.355 --> 00:29:17.391 
現在 自從Swift 2起
NS Swift名稱就存在了

00:29:17.457 --> 00:29:20.661 
但在Swift 3中 我們支持
完整的複合命名

00:29:21.161 --> 00:29:23.897 
複合名稱是基名稱
加參數標籤

00:29:23.997 --> 00:29:25.799 
所以這種情況下
我們有兩個方法

00:29:26.200 --> 00:29:29.269 
它們執行語義
十分相似的操作

00:29:29.369 --> 00:29:32.039 
但它們的不同點基本
在於它們處理參數的方式

00:29:32.105 --> 00:29:34.842 
所以在同樣的基名稱約束下
我們導入它們

00:29:35.108 --> 00:29:38.712 
但我們說我們希望它
等於此定位標記或

00:29:38.779 --> 00:29:40.447 
大於等於此定位標記

00:29:42.683 --> 00:29:45.686 
現在方法名可以推動你
朝向Swifty API行進一大步

00:29:45.853 --> 00:29:47.855 
但行進的距離仍然不夠遠

00:29:48.255 --> 00:29:50.791 
這裏 我有一些簡單的代碼
可以創建標準的

00:29:50.924 --> 00:29:52.259 
格利高裏日曆

00:29:52.793 --> 00:29:56.129 
但如果你看一下這個
這真的不怎麼Swifty

00:29:56.797 --> 00:29:59.766 
尤其是NSCalendarIdentifierGregorian

00:29:59.967 --> 00:30:02.503 
這是個普通的
字符串全局變量

00:30:02.870 --> 00:30:06.306 
普通字符串全局變量
這可不是使用Swift編程的方法

00:30:06.740 --> 00:30:10.677 
這就是我們戲謔爲
字符串型API的東西

00:30:11.678 --> 00:30:13.881 
而這種API使用字符串

00:30:14.481 --> 00:30:16.183 
這一定程度上
導致簡單錯誤的發生

00:30:16.250 --> 00:30:20.220 
沒錯 故障很簡單
開發者可以馬上發現

00:30:20.621 --> 00:30:25.058 
但是此API的用戶必須
記得這是什麼

00:30:25.125 --> 00:30:27.561 
以及這不是
可以用在這裏的有效字符串

00:30:27.628 --> 00:30:30.130 
這樣對用戶造成了
不必要的認知負擔

00:30:31.665 --> 00:30:34.168 
所以 爲什麼這個API是這樣的？

00:30:34.601 --> 00:30:38.172 
我們都知道爲何該API是這樣的
因爲它來自Objective-C

00:30:39.106 --> 00:30:41.542 
但該API來自
Objective-C的事實

00:30:41.608 --> 00:30:43.343 
這是實施信息

00:30:43.410 --> 00:30:45.913 
而這種實施信息泄露了

00:30:46.346 --> 00:30:48.982 
在Apple
我們並不喜歡信息泄露

00:30:51.852 --> 00:30:52.786 
要搞清楚哪裏出錯了

00:30:52.853 --> 00:30:55.222 
讓我們看一下Objective-C
API如何映射到Swift的

00:30:55.289 --> 00:30:58.959 
我們的全局變量作爲
全局變量進入 當然

00:30:59.426 --> 00:31:01.562 
但除了全局變量的
名稱外

00:31:01.828 --> 00:31:02.796 
沒有什麼可以告訴你

00:31:02.863 --> 00:31:07.701 
這是針對特別具體的API
的特別具體的字符串

00:31:08.802 --> 00:31:12.439 
現在 我們可以嘗試添加
typedef以試驗並暗示我們的意圖

00:31:12.773 --> 00:31:14.741 
但是typedef
不過是個類型別名

00:31:14.808 --> 00:31:16.877 
它是舊類型的新名稱

00:31:17.444 --> 00:31:19.780 
所以這實際上
不能解決這裏的問題

00:31:21.348 --> 00:31:23.050 
所以 API會是什麼模樣

00:31:23.116 --> 00:31:25.886 
如果我們要在Swift 3中
重新設計？

00:31:26.653 --> 00:31:30.724 
我們可能會在字符串
周圍形成新的包裝類型

00:31:30.791 --> 00:31:32.426 
從而獲取一些強類型

00:31:32.659 --> 00:31:36.263 
而這些全局變量
相反 會是靜態屬性

00:31:36.330 --> 00:31:39.433 
所以在Swift 3中 我們引入了
僅針對該用例的新屬性

00:31:39.700 --> 00:31:43.470 
你可以通過NS Extensible
String Enum訪問該屬性

00:31:43.570 --> 00:31:45.305 
當你想要告訴Swift編譯器

00:31:45.372 --> 00:31:48.175 
圍繞字符串
形成新的包裝類型時

00:31:50.577 --> 00:31:52.713 
你可將此添加到typedef

00:31:52.946 --> 00:31:57.284  
導入程序將圍繞此
爲你創建新類型

00:31:57.451 --> 00:32:00.354  
任何此類型的全局變量
將作爲此類型的

00:32:00.420 --> 00:32:03.090  
靜態屬性自動導入

00:32:04.925 --> 00:32:07.294  
因爲這是可擴展的
我們在這裏選擇一個結構

00:32:07.361 --> 00:32:10.297  
就是說 其他模塊可能
需要定義自己的結構

00:32:10.564 --> 00:32:13.500 
而如果它們定義了 它們
也將作爲靜態屬性被導入

00:32:13.567 --> 00:32:15.235 
到該結構的延伸部分

00:32:18.305 --> 00:32:22.843 
現在 在幕後
Swift編譯器會直接將此映射到

00:32:22.910 --> 00:32:24.411 
潛在的存儲值中

00:32:24.478 --> 00:32:27.281 
意味着這其中沒有
額外的經費或裝箱

00:32:27.381 --> 00:32:29.349 
或中間過程

00:32:33.720 --> 00:32:35.389 
所以 讓我們關注使用站點

00:32:35.455 --> 00:32:38.792 
因爲好的API設計
始終關注使用站點

00:32:39.359 --> 00:32:40.394 
過去如此...

00:32:41.828 --> 00:32:42.796 
以後也如此

00:32:42.996 --> 00:32:44.865 
因爲類型語境更清楚

00:32:44.965 --> 00:32:47.501 
我們甚至可以
只是說“.gregorian”

00:32:57.578 --> 00:33:00.714 
下次 我會自己
開始領頭鼓掌

00:33:03.817 --> 00:33:07.921 
同樣 在Swift 3 NSCalendar中
現在 它作爲日曆爲我們所知

00:33:07.988 --> 00:33:10.657 
這是個小改進

00:33:10.824 --> 00:33:16.230 
所以 我們有方法名
以及類型

00:33:16.430 --> 00:33:17.464 
我們還有什麼？

00:33:18.165 --> 00:33:21.235 
好 我們有大象

00:33:22.636 --> 00:33:25.305 
就是說 我們在屋內
有大象

00:33:26.540 --> 00:33:28.876 
我們一直假裝看不見它

00:33:28.942 --> 00:33:30.711 
但它始終在那裏

00:33:32.279 --> 00:33:33.413 
它就是C

00:33:35.249 --> 00:33:39.353 
現在 通過Objective-C
API已經面向對象了

00:33:39.419 --> 00:33:43.223 
所以導入時 我們只需
更改幾個字符串 添加幾個類型

00:33:43.290 --> 00:33:44.691 
這相對簡單

00:33:44.758 --> 00:33:46.293 
但是C呢？

00:33:47.427 --> 00:33:49.630 
我將主要介紹核心圖像

00:33:50.097 --> 00:33:52.999 
現在 核心圖像
是一種非常流行的API

00:33:53.066 --> 00:33:54.935 
基本每個Swift應用都會用

00:33:55.202 --> 00:34:00.340 
這是一種強大的API
但它的外觀和感覺都像C

00:34:01.675 --> 00:34:02.876 
讓我們從一些代碼開始

00:34:02.943 --> 00:34:04.211 
我這裏有兩個函數

00:34:04.344 --> 00:34:06.113 
第一個轉換 嗯...

00:34:07.114 --> 00:34:09.750 
進行轉換並旋轉特定偏移量

00:34:10.350 --> 00:34:12.953 
第二個函數跟蹤紅色路徑

00:34:13.320 --> 00:34:15.255 
現在 兩個函數
都不怎麼複雜

00:34:15.322 --> 00:34:16.757 
而且細節並不重要

00:34:16.889 --> 00:34:18.859 
但我只是想看看
這看起來怎麼樣？

00:34:18.926 --> 00:34:19.893 
感覺如何？

00:34:19.993 --> 00:34:21.728 
繼續 等等

00:34:25.264 --> 00:34:28.268 
所以 如果你注意
你會發現代碼完全充斥着

00:34:28.335 --> 00:34:30.603 
全局變量和全局函數

00:34:30.871 --> 00:34:33.340 
當然 我們不怎麼喜歡
全局函數

00:34:34.107 --> 00:34:36.009 
或全局變量

00:34:37.844 --> 00:34:41.815 
所以我們怎麼拿到
一個這樣的API

00:34:42.149 --> 00:34:43.583 
然後使它變Swifty？

00:34:43.650 --> 00:34:45.918 
我們如何使它有Swifty的感覺？

00:34:47.087 --> 00:34:50.690 
好 爲此 我們再次看一下
NS Swift名稱

00:34:50.858 --> 00:34:55.529 
你可以使用NS Swift
Name將全局作爲類型成員導入

00:34:56.362 --> 00:34:58.932  
讓我從全局變量開始
向你展示我的意思

00:34:59.666 --> 00:35:01.702  
在這裏 頂部
有C的定義

00:35:02.169 --> 00:35:04.071  
下面是生成的
Swift界面

00:35:04.137 --> 00:35:05.806  
下面是Swift使用站點

00:35:05.873 --> 00:35:07.474  
將重點關注Swift使用站點

00:35:07.541 --> 00:35:09.276  
並改進Swift使用站點

00:35:10.277 --> 00:35:14.381  
我們添加NS Swift名稱
並使用typename.membername

00:35:14.448 --> 00:35:20.020  
從而告知Swift編譯器
應將kCGColorWhite

00:35:20.087 --> 00:35:22.890  
作爲CGColor上的
靜態屬性導入

00:35:23.190 --> 00:35:27.895  
當然 Swift使用站點現在
可以使用正確嵌套的屬性

00:35:35.536 --> 00:35:37.504 
當然 如果類型語境清楚

00:35:37.671 --> 00:35:39.673 
用戶甚至可以略去CGColor

00:35:41.909 --> 00:35:44.278 
新的核心圖像有很多不同的全局函數

00:35:44.344 --> 00:35:46.880  
可以創建不同類型的
CG Affine Transform

00:35:46.947 --> 00:35:48.916  
這是CGAffineTransform
MakeTranslation

00:35:48.982 --> 00:35:51.485  
以及CGAffineTransform
MakeRotation在所有這些上面

00:35:51.552 --> 00:35:53.754  
但在Swift中
我們更喜歡初始值設定項

00:35:53.820 --> 00:35:57.591  
所以我們使用TypeName.Init
並提供參數標籤

00:35:57.658 --> 00:35:59.159  
以便告知Swift編譯器

00:35:59.226 --> 00:36:01.495  
這應該只是一個
初始值設定項

00:36:01.962 --> 00:36:03.730  
我們使用參數標籤

00:36:03.797 --> 00:36:06.333  
以便明確參數的角色

00:36:09.336 --> 00:36:11.872  
你也可以作爲
實例成員導入

00:36:12.239 --> 00:36:14.675  
使用特殊參數標籤self

00:36:14.741 --> 00:36:16.810  
以告知Swift編譯器

00:36:16.877 --> 00:36:18.712  
將參照self
插到什麼參數中

00:36:20.147 --> 00:36:24.551  
所以現在CGContextFillPath
僅僅是一種方法填充路徑

00:36:24.918 --> 00:36:26.587  
當然
Swift使用站點

00:36:27.421 --> 00:36:28.956  
只是像是方法一樣調用它

00:36:35.863 --> 00:36:37.865 
編譯器將獲取
圓點左邊的內容

00:36:37.931 --> 00:36:41.702 
將其插入相應的參數位置

00:36:41.802 --> 00:36:43.570 
就按照特殊參數標籤self指示

00:36:45.672 --> 00:36:46.940 
我們可編寫更復雜的代碼

00:36:47.274 --> 00:36:50.310  
你可以在Swift名稱前
加上接受方或設置方

00:36:50.377 --> 00:36:53.113  
告訴編譯器將此函數

00:36:53.180 --> 00:36:55.716  
作爲計算的屬性導入
接受方或設置方

00:36:56.316 --> 00:36:57.918  
ArtistGetName

00:36:57.985 --> 00:37:01.021  
ArtistSetName現在就是

00:37:01.088 --> 00:37:02.956  
計算屬性Artist接受和設置方

00:37:04.224 --> 00:37:05.926 
讓我們關注使用站點

00:37:06.059 --> 00:37:09.196 
因爲好的API設計
始終關注使用站點

00:37:09.530 --> 00:37:11.865 
以前 我們會使用
全局函數

00:37:11.932 --> 00:37:13.667 
記住藝術家曾用名

00:37:13.800 --> 00:37:16.370 
並使用另一個全局函數
設置新名稱

00:37:18.238 --> 00:37:22.009 
現在 我們的用戶可以
直接使用計算的屬性

00:37:23.143 --> 00:37:26.613 
所有情況下
經費成本都是零

00:37:26.680 --> 00:37:29.783 
編譯器看到myArtist.Name時
就會將其

00:37:29.850 --> 00:37:32.052 
直接映射到相應的
C函數

00:37:32.186 --> 00:37:35.589 
而不調用任何包裝
或中介或覆蓋

00:37:37.824 --> 00:37:40.627 
你也可以使用
NS Swift名稱嵌套類型

00:37:40.961 --> 00:37:44.498 
還記得先前
我們創建了新的標識符類型嗎？

00:37:47.768 --> 00:37:50.170  
好 你可以使用typeName

00:37:50.604 --> 00:37:52.105  
好 成員名稱

00:37:52.172 --> 00:37:54.074  
嵌套類型名稱
從而嵌套類型名稱

00:37:54.341 --> 00:37:57.311  
所以 這種情況下
我們得到了Calendar.Identifier

00:38:06.019 --> 00:38:08.689 
現在 我們喜歡
新的NS Swift名稱

00:38:11.291 --> 00:38:13.160 
我們這麼喜歡它

00:38:14.328 --> 00:38:19.099 
以致於我們完全
徹底發狂了

00:38:27.908 --> 00:38:29.543 
這裏不要鼓掌

00:38:31.778 --> 00:38:35.649 
僅在覈心圖像中

00:38:35.816 --> 00:38:38.385 
我們就將它用在
超過600個API中 600個

00:38:38.986 --> 00:38:40.120 
現在可以鼓掌了

00:38:43.857 --> 00:38:44.958 
這確實很瘋狂

00:38:45.726 --> 00:38:48.028 
那麼 讓我們再看看
之前的代碼

00:38:48.395 --> 00:38:50.230 
之前 我們的全局變量

00:38:50.297 --> 00:38:54.101 
全局得非常痛苦
現在它成爲成員了

00:38:54.168 --> 00:38:56.136 
而且因爲類型語境
更清楚了

00:38:56.203 --> 00:38:58.172 
我們甚至可以略去類型名稱

00:39:00.674 --> 00:39:04.344 
我們的全局函數
現在是方法

00:39:11.051 --> 00:39:14.054 
實際上 現在我看着這個
我覺得代碼更簡單了

00:39:14.121 --> 00:39:16.190 
我們不需要額外的變量結果

00:39:17.524 --> 00:39:18.926 
所以現在代碼讀起來...

00:39:24.064 --> 00:39:26.767 
讀起來非常美
自然又Swifty

00:39:26.834 --> 00:39:28.302 
我們獲取轉換

00:39:28.368 --> 00:39:29.403 
進行翻譯

00:39:29.469 --> 00:39:31.471 
進行旋轉
然後翻譯回去

00:39:31.538 --> 00:39:32.372 
非常簡單

00:39:32.840 --> 00:39:33.674 
繼續

00:39:33.740 --> 00:39:35.742  
CGColorCreateGenericRGB

00:39:35.809 --> 00:39:39.513  
以及所有其他很多很多
創建顏色的方法

00:39:40.214 --> 00:39:43.450  
這些現在是
帶有參數標籤的初始值設定項

00:39:43.517 --> 00:39:45.853  
當然 先別鼓掌

00:39:45.919 --> 00:39:49.990  
而且 當然
CGContextAddPathContextPath

00:39:50.057 --> 00:39:52.192  
以及所有其它瘋狂冗餘的東西

00:39:53.327 --> 00:39:54.928  
它們現在都是方法

00:40:01.902 --> 00:40:03.837 
我們希望
你們喜歡這些新的API

00:40:04.304 --> 00:40:09.409 
所以 總結下 首先我們
展示了Swift中新的API設計準則

00:40:09.676 --> 00:40:12.746 
好的API設計
始終關注使用站點

00:40:13.180 --> 00:40:15.849 
第二 我們瞭解了
Grand Renaming

00:40:15.916 --> 00:40:19.419 
也是我們熟悉的：
“哦 不！什麼都變了”

00:40:19.620 --> 00:40:21.622 
但是別慌
一切還好

00:40:21.688 --> 00:40:24.024 
名稱改進了
代碼更清楚了

00:40:24.091 --> 00:40:25.592 
你得到遷移工具了

00:40:25.792 --> 00:40:27.794 
最後我們介紹了
Swift編譯器的新功能

00:40:27.861 --> 00:40:31.732 
以便於你擁有自己的
Great Renaming

00:40:33.367 --> 00:40:36.336 
要了解更多信息
請訪問該站點頁面

00:40:36.403 --> 00:40:39.840 
網址爲developer.apple.com
並瀏覽Swift.org

00:40:39.907 --> 00:40:42.009 
開源Swift項目的主頁上

00:40:42.075 --> 00:40:44.211 
你可以看到Swift的所有演變

00:40:44.278 --> 00:40:46.013 
我也顯示了核心圖像

00:40:46.079 --> 00:40:48.849 
不過Grand Central Dispatch
有自己的Great Renaming

00:40:48.916 --> 00:40:51.251 
使用的方法
跟我今天展示的很多相同

00:40:51.318 --> 00:40:55.088 
所以 星期五
請關注Swift 3中

00:40:55.155 --> 00:40:57.457 
使用Grand Central Dispatch技術的
併發程序設計

00:40:57.524 --> 00:40:58.358 
星期五