00:00:19.353 --> 00:00:23.423
SceneKit渲染的進展

00:00:24.925 --> 00:00:25.826
早上好

00:00:28.996 --> 00:00:32.633
歡迎來到
“SceneKit渲染的進展”

00:00:33.634 --> 00:00:36.103
我叫Amaury 很高興在這裏

00:00:36.236 --> 00:00:39.273
爲大家講解如何
讓SceneKit再上一個臺階

00:00:39.339 --> 00:00:40.741
利用藝術圖形狀態

00:00:42.176 --> 00:00:44.077
所以我們今天會講很多東西

00:00:44.144 --> 00:00:46.647
首先對SceneKit做一個簡介

00:00:46.713 --> 00:00:49.616
在討論渲染的新進展之前

00:00:50.384 --> 00:00:55.422
接下來Jean-Baptiste和Sebastien
會和我一起爲大家演示一個很酷的例子

00:00:55.489 --> 00:00:59.059
來解釋該例子是如何編寫出來
併爲大家展示所有新的性能

00:00:59.159 --> 00:01:00.894
比如全新的照相效果

00:01:01.395 --> 00:01:05.732
最後 Nick會爲我們講解
Model I/O的基礎

00:01:07.367 --> 00:01:08.402
簡而言之

00:01:09.937 --> 00:01:14.875
如你所知 SceneKit是
GameKit下的高級API

00:01:14.942 --> 00:01:16.877
主要應用於3D圖形

00:01:17.578 --> 00:01:19.880
它和2D圖形的
Spritkit完美結合

00:01:19.947 --> 00:01:23.183
並且構建在Metal和
OpenGL之上

00:01:24.084 --> 00:01:26.687
你可以把SceneKit
應用於各種情況

00:01:26.753 --> 00:01:28.655
把屏幕上的圖形進行分散

00:01:29.223 --> 00:01:33.026
仔細想會發現
它們被應用到很多領域

00:01:34.228 --> 00:01:37.764
比如 我們剛引進了
Swift Playgrounds

00:01:38.298 --> 00:01:41.101
SceneKit讓其界面更爲可視化

00:01:41.168 --> 00:01:46.740
幫助孩子們邁出學習編程的第一步

00:01:48.308 --> 00:01:50.644
在Xcode
我們用SceneKit建立了

00:01:50.711 --> 00:01:53.947
一個創新並極爲有用的接口

00:01:54.348 --> 00:01:56.884
幫助你編寫應用的視圖結構

00:01:58.352 --> 00:02:02.222
在iBooks和iBooks Author裏
人們可寫出豐富的書本

00:02:02.289 --> 00:02:06.627
利用增強的插圖效果 並且是互動型的

00:02:07.828 --> 00:02:10.097
當然SceneKit也被用在遊戲上

00:02:11.498 --> 00:02:13.534
最後 但不失其重要性的 謝謝你們

00:02:14.034 --> 00:02:17.871
你們爲SceneKit和3D圖形
找到了非常多的用戶用例

00:02:18.272 --> 00:02:22.075
你們在app store裏發佈了
成千上萬基於SceneKit的應用

00:02:22.242 --> 00:02:23.076
所以謝謝你們

00:02:29.483 --> 00:02:33.854
現在 如你所知 SceneKit
和系統緊密結合

00:02:34.288 --> 00:02:36.924
它和所有Apple技術無縫合作

00:02:37.324 --> 00:02:40.060
它充分利用macOS和iOS平臺

00:02:40.527 --> 00:02:42.529
這兩個平臺已經問世多年

00:02:43.630 --> 00:02:48.569
在去年的WWDC上 我們還在
tvOS上引入了SceneKit

00:02:49.870 --> 00:02:55.375
我們在狐狸例子裏所添加的
只是爲遊戲控制器加了兩個端口

00:02:55.642 --> 00:02:58.312
就可以在大屏幕上玩了

00:02:59.313 --> 00:03:02.249
真的非常精彩 能看到同一款遊戲

00:03:02.482 --> 00:03:06.353
和代碼能在macOS、iOS
和tvOS運行

00:03:07.020 --> 00:03:10.924
今年我們畫了一個完整圓 讓
SceneKit進入watchOS

00:03:14.094 --> 00:03:14.928
謝謝

00:03:18.432 --> 00:03:22.269
SceneKit應用到
watchOS是一個非常好的機會

00:03:22.336 --> 00:03:24.605
開始思考新互動

00:03:24.671 --> 00:03:27.040
以及在手腕上展現內容的方法

00:03:27.841 --> 00:03:29.343
如你所想象的

00:03:30.310 --> 00:03:33.046
在Apple Watch編程
有很多可講的內容

00:03:33.213 --> 00:03:35.315
今天無法面面俱到

00:03:35.616 --> 00:03:37.584
但是我們有一個專門的演講

00:03:37.651 --> 00:03:40.888
星期五的
“Apple Watch遊戲技巧”

00:03:41.288 --> 00:03:43.824
你可以瞭解到更多可用功能

00:03:43.891 --> 00:03:46.827
如何利用SceneKit
SpriteKit和其他技術

00:03:48.428 --> 00:03:50.631
如果你是SceneKit新手
想學習更多

00:03:50.697 --> 00:03:56.470
可隨時上網觀看過去幾年WWDC演講
我們講解過基本技巧

00:03:56.570 --> 00:03:59.072
也講過SceneKit中
非常高級的功能

00:04:00.641 --> 00:04:04.611
好的 讓我們開始
看看這個新的渲染技術

00:04:05.646 --> 00:04:09.049
今年 SceneKit把手動渲染

00:04:09.116 --> 00:04:10.584
交到了你們手中

00:04:11.685 --> 00:04:14.087
也就是說 編程者 你們大家

00:04:14.154 --> 00:04:18.192
可以在藝術作品和遊戲中
取得驚人的圖形效果

00:04:19.625 --> 00:04:23.330
這在SceneKits渲染能力裏
是一個顯著進步

00:04:23.430 --> 00:04:24.965
自從它問世以來

00:04:25.532 --> 00:04:30.304
我們在3D圖形最新高級技巧的基礎上
利用了先進的技術

00:04:30.370 --> 00:04:33.540
提供準確的渲染和基於物理着色

00:04:35.275 --> 00:04:38.946
現在 基於物理着色有一些要求

00:04:39.146 --> 00:04:41.715
首先從線性渲染開始

00:04:43.083 --> 00:04:47.721
這裏是一個平滑的輻射圖 從0到1

00:04:47.788 --> 00:04:50.290
如你所見 顯示很完美

00:04:51.124 --> 00:04:52.860
直到你把它壓縮

00:04:52.926 --> 00:04:56.730
想儲存到8寸的磁盤光學映像裏 比如

00:04:57.464 --> 00:05:00.033
可以看到 發生了光度彎曲

00:05:00.133 --> 00:05:04.238
這是因爲我們的眼睛對於變化很敏感

00:05:04.304 --> 00:05:05.472
在深色的影響下

00:05:06.473 --> 00:05:12.379
通過伽馬編碼
可以給該暗圈函數指定更多的值

00:05:13.914 --> 00:05:18.018
比如 這裏的圖例顯示了

00:05:18.085 --> 00:05:22.389
儲存原始像素數據和
利用了伽馬編碼之後的不同

00:05:24.558 --> 00:05:28.161
現在的問題是當着色［聽不清］

00:05:28.228 --> 00:05:32.933
所有的光信息和公式
都在一個線性空間表示

00:05:34.234 --> 00:05:37.371
所以在非線性管道中

00:05:37.437 --> 00:05:40.741
只存在鮮豔的顏色數據
在紋理上進行伽馬編碼後

00:05:41.475 --> 00:05:44.444
並且用線性公式進行處理

00:05:44.511 --> 00:05:48.015
產生的濃縮結果會被
寫入某個紋理或幀緩存中

00:05:48.882 --> 00:05:51.018
如你所想 這是錯誤的

00:05:52.019 --> 00:05:58.091
爲了最終的圖片顯示正確
所有的操作都需要有足夠的空間

00:05:59.760 --> 00:06:05.699
作爲一個演示例子
這是伽馬空間內光照場景

00:06:06.466 --> 00:06:09.803
這是同樣的場景
以線性空間的着色顯示

00:06:10.971 --> 00:06:13.740
如果比較兩者 會發現光照如何消退

00:06:13.974 --> 00:06:17.444
以及邊緣變得粗糙 在線性渲染裏

00:06:18.745 --> 00:06:22.916
線性渲染對於基於物理的渲染十分關鍵

00:06:22.983 --> 00:06:26.520
它實際上被應用於
所有SceneKit光照模型

00:06:26.587 --> 00:06:28.689
因爲從數學角度上很正確

00:06:30.757 --> 00:06:35.062
如你所知
顏色是今年WWDC的重要話題

00:06:35.128 --> 00:06:39.032
除了伽馬糾正

00:06:39.099 --> 00:06:42.769
SceneKit［聽不清］
自動管理顏色和線性渲染

00:06:44.972 --> 00:06:45.973
這代表了什麼？

00:06:46.473 --> 00:06:49.476
它意味着指定給一個紋理的顏色配置

00:06:49.543 --> 00:06:50.844
現在將會［聽不清］

00:06:51.678 --> 00:06:54.948
任何操作 從發生在圖像從磁盤

00:06:55.015 --> 00:06:57.918
被加載 到傳給系統那一刻

00:06:57.985 --> 00:06:59.920
可以顯示在屏幕上

00:06:59.987 --> 00:07:02.623
我們會保持顏色數據的完整性

00:07:04.057 --> 00:07:08.795
基於SceneKit的應用
會產生高度的色彩準確性

00:07:08.862 --> 00:07:11.298
和某些專業照片編輯應用一樣

00:07:12.666 --> 00:07:16.336
如今 如你所知
［聽不清］地圖和普通地圖

00:07:16.870 --> 00:07:21.375
都不再顯示被存儲爲色彩的原始數據

00:07:21.775 --> 00:07:24.912
SceneKit知道這一點
它不會爲此類圖像配色

00:07:26.013 --> 00:07:29.149
爲了幫助你解決這一點
有一個全新的很棒的性能

00:07:29.216 --> 00:07:32.986
在Xcode 8資產目錄裏
就是紋理集合

00:07:34.388 --> 00:07:40.227
在紋理集合裏 可以指定一個圖像
顯示色彩數據或者原始數據

00:07:40.294 --> 00:07:44.731
然後Xcode
可以自動把這些圖像轉換爲

00:07:44.798 --> 00:07:48.368
CPU和GPU高效紋理格式

00:07:49.269 --> 00:07:52.539
關於這點 午飯後我們還有一個演講

00:07:52.606 --> 00:07:53.974
“用廣色域來工作”

00:07:54.241 --> 00:07:56.910
Metal團隊將會講解更多相關細節

00:07:58.979 --> 00:08:04.218
除了紋理 色彩管理也應用於色彩對象

00:08:05.252 --> 00:08:08.121
色彩組件不能再假定爲sRGB

00:08:08.889 --> 00:08:11.191
如果要變成新建色彩

00:08:11.258 --> 00:08:14.428
使用正確的構造器非常重要

00:08:15.495 --> 00:08:18.665
這裏展示了兩個色彩對象

00:08:19.032 --> 00:08:21.568
一個叫Display P3
另一個叫sRGB

00:08:21.902 --> 00:08:24.271
它們是由同一個組件構建出來的

00:08:26.173 --> 00:08:27.808
當使用色彩選擇器時

00:08:27.875 --> 00:08:30.310
請注意選擇的色彩空間

00:08:30.377 --> 00:08:33.780
菜單上可以選擇不同的色彩空間

00:08:34.280 --> 00:08:38.684
包括和設備無關的
比如Display P3和sRGB

00:08:39.352 --> 00:08:42.222
還有一個很方便的選項顯示數值

00:08:42.289 --> 00:08:44.892
以浮點數顯示 而不是整數

00:08:44.958 --> 00:08:47.461
這樣它們可以方便地複製粘貼到代碼中

00:08:48.395 --> 00:08:50.998
講到這裏 如你所知

00:08:51.565 --> 00:08:53.867
着色修改器是
SceneKit非常優秀的性能

00:08:54.034 --> 00:08:57.004
它允許自定義渲染

00:08:58.005 --> 00:09:01.708
如我所說 今年着色出現在線性空間

00:09:02.376 --> 00:09:05.212
所以你必須確保把色彩

00:09:05.279 --> 00:09:08.148
轉換爲線性擴展sRGB色彩空間

00:09:08.549 --> 00:09:11.318
在這些組件被用來［聽不清］

00:09:13.520 --> 00:09:16.323
關於向後兼容性要注意幾點

00:09:18.892 --> 00:09:22.796
線性渲染和色彩管理會自動啓動

00:09:22.863 --> 00:09:25.732
當你把應用和
新的SDKs連接起來時

00:09:26.333 --> 00:09:28.869
啓動不會產生性能下降

00:09:29.002 --> 00:09:32.506
但是會顯著改變舊場景的外觀

00:09:32.940 --> 00:09:37.711
舉例說明 這是去年的演示
並沒有使用線性渲染

00:09:38.478 --> 00:09:41.582
如果對其進行重組會變成這樣

00:09:42.716 --> 00:09:46.220
當然 紋理 光照和陰影修改器

00:09:46.286 --> 00:09:48.822
可以用線性渲染重新進行改寫

00:09:49.523 --> 00:09:53.861
但是如果想把應用部署到舊版本的系統

00:09:53.927 --> 00:09:57.264
或者出於某種原因
想在色彩管理中更新線性渲染

00:09:57.731 --> 00:09:59.066
有一個方法可以實現

00:10:00.467 --> 00:10:04.071
你可以通過指定一個關鍵字

00:10:04.137 --> 00:10:05.839
在應用的info.plist文件

00:10:07.641 --> 00:10:10.210
將會顯示廣域內容

00:10:10.544 --> 00:10:13.714
如你所知 廣域色彩空間

00:10:13.780 --> 00:10:17.851
比如存在擴展sRGB

00:10:17.918 --> 00:10:20.988
對現代硬件設備來說非常重要

00:10:22.723 --> 00:10:26.126
新款帶Retina顯示的
iPad Pro和iMac

00:10:26.193 --> 00:10:29.229
有廣域顯示
SceneKit自動支持

00:10:29.997 --> 00:10:35.068
你只需要取出廣域內容
比如紋理或色彩

00:10:35.435 --> 00:10:38.572
SceneKit可以透明化進入其中

00:10:42.309 --> 00:10:46.747
廣域紋理和幀緩存
需要更多的內存存儲該數據

00:10:46.813 --> 00:10:49.983
從而會帶來更多的帶寬消耗

00:10:50.050 --> 00:10:52.286
如果產生任何性能問題

00:10:52.386 --> 00:10:56.390
我們提供了一種重新上傳的方法
［聽不清］

00:11:01.528 --> 00:11:04.464
下面來看一下色域展示示例代碼

00:11:05.165 --> 00:11:08.402
是和Cocoa和
Cocoa Touch團隊合作編寫

00:11:09.236 --> 00:11:12.272
它是一個基於同步的應用 允許

00:11:12.406 --> 00:11:15.676
可以在色域組件外觀察

00:11:15.742 --> 00:11:19.213
這非常有用 因爲在廣域顯示裏

00:11:19.279 --> 00:11:21.949
你可以看到該顯示情況

00:11:22.049 --> 00:11:24.818
因爲你可以模擬一個非廣域顯示

00:11:26.453 --> 00:11:29.122
從而可以學習利用廣域

00:11:29.189 --> 00:11:35.062
以及如何在色彩空間內轉換色彩組件

00:11:35.128 --> 00:11:37.130
再次說明
今天下午我們會有一個精彩演講

00:11:38.398 --> 00:11:40.467
也可以應用到準確渲染

00:11:40.534 --> 00:11:44.271
也是基於物理渲染的前提

00:11:44.338 --> 00:11:45.572
基於物理渲染

00:11:45.639 --> 00:11:49.276
什麼是基於物理渲染 爲什麼要用它

00:11:50.010 --> 00:11:53.714
人們總是認爲精細的場景

00:11:53.780 --> 00:11:57.017
是帶有很多細節模塊的場景

00:11:57.284 --> 00:11:58.652
的確是這樣

00:11:59.253 --> 00:12:02.322
但是着色才能讓對象有形

00:12:03.257 --> 00:12:06.793
在屏幕上看到的
這幅圖曾經是一組多邊形

00:12:07.694 --> 00:12:12.232
着色是爲屏幕上每個細節
找到正確色彩的過程

00:12:12.466 --> 00:12:18.071
所有的高亮 陰影和深度感
都是從着色而來

00:12:19.940 --> 00:12:24.411
着色就是那個神奇的操作
能夠讓場景栩栩如生

00:12:25.412 --> 00:12:26.747
工作原理是什麼？

00:12:27.381 --> 00:12:30.317
首先有一個光源發出的光

00:12:30.984 --> 00:12:33.086
當光碰到對象

00:12:33.153 --> 00:12:37.591
會根據表面的屬性跟物質發生相互作用

00:12:37.658 --> 00:12:41.895
光發生反射
進入人眼或本例中的一臺相機

00:12:43.797 --> 00:12:47.768
光和物質之間的相互作用非常複雜

00:12:48.368 --> 00:12:50.771
多年來很多數學模型

00:12:50.838 --> 00:12:53.373
都在嘗試對它進行最好的解釋

00:12:54.541 --> 00:12:58.679
基於物理渲染是光傳輸的模擬

00:12:58.745 --> 00:13:01.248
基於這種數學模型之上

00:13:01.315 --> 00:13:04.751
它們考慮到了光和物質的物理性質

00:13:05.385 --> 00:13:08.155
但是 如你所知
SceneKit是高級API

00:13:08.288 --> 00:13:12.092
我們想讓每個人
都從該全新光照模型受益

00:13:12.693 --> 00:13:15.596
所以我們公開了一個超爲簡單的API

00:13:15.963 --> 00:13:19.333
可以讓你利用基於美術師們熱衷的
物理渲染技術

00:13:20.400 --> 00:13:24.371
本次演講結尾 你可以從該渲染

00:13:24.438 --> 00:13:27.341
也是標準渲染 變成基於物理渲染

00:13:29.910 --> 00:13:34.081
在SceneKit
我們從兩個角度導出基於物理渲染

00:13:34.615 --> 00:13:38.585
首先 基於物理材料 以及
基於物理光照

00:13:40.387 --> 00:13:43.457
基於物理材料

00:13:43.524 --> 00:13:45.292
首先 基於物理材料

00:13:47.160 --> 00:13:50.097
這裏描述了表面上的一點

00:13:50.163 --> 00:13:53.166
通常指示方向是空間

00:13:54.334 --> 00:13:57.304
當光照碰到該點 發生兩種反射

00:13:58.172 --> 00:14:00.707
漫反射和鏡面反射

00:14:02.042 --> 00:14:04.444
漫反射通過

00:14:04.511 --> 00:14:06.280
迴應進入表面下面的光

00:14:06.346 --> 00:14:09.316
進行多次反射 並射向各個方向

00:14:09.383 --> 00:14:10.617
看上去均勻

00:14:12.019 --> 00:14:16.924
漫反射的色彩是對象的底色的反照率

00:14:17.658 --> 00:14:20.928
所以在SceneKit中
設計基於物理材料的接口時

00:14:20.994 --> 00:14:23.664
我們需要用到反照率映射圖

00:14:24.698 --> 00:14:27.801
鏡面反射不需要如此

00:14:29.069 --> 00:14:32.906
鏡面反射由從表面彈回的光組成

00:14:32.973 --> 00:14:35.375
所以它的顏色是光源射線的顏色

00:14:36.543 --> 00:14:38.245
這是我們稱作的立方體映射圖

00:14:38.312 --> 00:14:42.149
這是六個空間的集合

00:14:42.216 --> 00:14:44.351
代表3D空間位置的周邊環境

00:14:45.619 --> 00:14:48.055
當我們把一個全鏡面對象

00:14:48.121 --> 00:14:52.159
放入該環境 可以看到它好比一個鏡子

00:14:52.893 --> 00:14:56.463
我們來舉一個更實際的例子 用塑料球

00:14:57.264 --> 00:14:59.600
可以看出 它不是一個完美的鏡子

00:15:00.000 --> 00:15:02.503
中間部分反射很暗

00:15:02.569 --> 00:15:06.039
越向邊緣靠近越亮

00:15:06.440 --> 00:15:09.676
實際上在高角度 所有的光都被反射

00:15:11.111 --> 00:15:14.448
不是所有材料都有相同的反射量

00:15:14.915 --> 00:15:20.254
上方是代表反射值的曲線

00:15:20.320 --> 00:15:23.724
從0到90度入射角的函數

00:15:24.391 --> 00:15:26.760
可以看到這些反射值

00:15:26.827 --> 00:15:29.663
從0到45度時幾乎保持不變

00:15:30.030 --> 00:15:33.934
我們實際上可以利用該值重建整條曲線

00:15:34.768 --> 00:15:36.803
金子是一個很有意思的例子

00:15:37.204 --> 00:15:40.040
因爲它有不同的反射值

00:15:40.107 --> 00:15:42.242
對紅色 綠色和藍色組件

00:15:43.577 --> 00:15:46.513
最後要注意的是 金屬

00:15:46.580 --> 00:15:51.185
比如鋁或金 反射值較高

00:15:51.251 --> 00:15:56.356
而非金屬或絕緣體的反射值較低

00:15:57.958 --> 00:16:01.061
反射值的區別很重要

00:16:01.128 --> 00:16:02.329
對於對象的最終顯示

00:16:02.829 --> 00:16:05.866
所以在SceneKit中
我們想要公開一張金屬性映射圖

00:16:06.400 --> 00:16:12.272
顯示對象的哪些部分是金屬的
哪些不是

00:16:13.841 --> 00:16:17.544
所以除了不同的反射值以外

00:16:17.945 --> 00:16:21.748
要注意金屬也會吸收表面之下的所有光

00:16:21.815 --> 00:16:24.251
而絕緣體將會發生散射

00:16:24.651 --> 00:16:26.320
兩者的視覺效果

00:16:27.654 --> 00:16:33.827
是金屬有廣泛的鏡面反射 沒有漫反射

00:16:33.894 --> 00:16:36.763
絕緣體則有非常多的漫反射

00:16:36.830 --> 00:16:40.901
鏡面反射幾乎只能在高角度看到

00:16:42.302 --> 00:16:47.441
在SceneKit我們會重新使用
發散的Metal屬性

00:16:47.875 --> 00:16:53.447
儲存金屬的反射值和絕緣體的反照率

00:16:54.581 --> 00:16:58.051
對於絕緣體的反射值

00:16:58.118 --> 00:17:01.054
我們只使用一個全局常量

00:17:03.257 --> 00:17:06.993
並且重用金屬屬性diffuse

00:17:07.060 --> 00:17:09.429
我們從其他［聽不清］取得

00:17:10.597 --> 00:17:15.469
最後我要講的一點是表面粗糙度

00:17:16.869 --> 00:17:19.940
你們知道 沒有完全光滑的表面

00:17:20.473 --> 00:17:23.577
從微觀來看 總有小的凸起

00:17:24.044 --> 00:17:26.713
和裂紋將影響鏡面反射

00:17:27.981 --> 00:17:33.053
微觀表面越粗糙 反射越模糊

00:17:33.120 --> 00:17:36.723
因爲光的反射線不再對齊

00:17:37.558 --> 00:17:40.827
所以在SceneKit裏
也會提供粗糙度映射圖

00:17:40.894 --> 00:17:46.466
將會顯示錶面的哪些部分是粗糙的
哪些部分是光滑的

00:17:46.934 --> 00:17:48.936
這是一張灰度圖

00:17:51.505 --> 00:17:56.910
可以看出如何分開三個基本屬性

00:17:57.411 --> 00:17:59.713
每一個屬性都有明確的含義

00:17:59.780 --> 00:18:03.851
都是來自表面的屬性

00:18:04.751 --> 00:18:08.255
在SceneKit中
建立基於物理材料很簡單

00:18:08.722 --> 00:18:12.392
新建一個材料 設置其光照模型

00:18:12.459 --> 00:18:14.461
爲新的基於物理光照模型

00:18:14.928 --> 00:18:16.530
最後提供映射圖

00:18:17.831 --> 00:18:19.733
來看一個例子

00:18:19.800 --> 00:18:23.036
從一臺礦車開始 它只有一張漫反射映射圖

00:18:23.971 --> 00:18:25.706
然後添加粗糙度映射圖

00:18:25.772 --> 00:18:27.908
比如 看一下煤

00:18:28.675 --> 00:18:32.479
煤很粗糙 所以沒有［聽不清］

00:18:33.647 --> 00:18:36.183
隨後我們加一個金屬性映射圖

00:18:36.250 --> 00:18:39.186
比如 看看鐵軌和車輪

00:18:41.622 --> 00:18:42.990
再舉一個例子

00:18:43.056 --> 00:18:44.491
這是一輛消防車

00:18:45.259 --> 00:18:47.160
我們還是從漫反射映射圖開始

00:18:47.895 --> 00:18:49.997
現在添加金屬性映射圖

00:18:51.565 --> 00:18:53.267
最後是粗糙度映射圖

00:18:53.333 --> 00:18:56.170
比如 看看輪胎

00:18:59.139 --> 00:19:02.109
我想要指出一點

00:19:02.809 --> 00:19:05.812
對於金屬度 粗糙度和環境閉合映射圖

00:19:06.280 --> 00:19:08.148
請使用灰度圖像

00:19:08.582 --> 00:19:11.952
使用紅綠藍色彩通道

00:19:12.019 --> 00:19:13.687
只會造成內存浪費

00:19:13.754 --> 00:19:15.956
如果還添加另一個函數 浪費更大

00:19:16.924 --> 00:19:20.594
此外 如果想在整個表面使用相同的值

00:19:20.661 --> 00:19:22.162
可以利用色彩對象

00:19:22.729 --> 00:19:27.234
或更好的方法 因爲對於這些金屬屬性
支持數量已知

00:19:29.169 --> 00:19:33.207
我們看看如何建立簡單而高級的API

00:19:33.273 --> 00:19:35.475
從而建立各種各樣的材料

00:19:36.109 --> 00:19:37.177
這是同一個對象

00:19:37.911 --> 00:19:40.581
在一個軸上 改變粗糙度值

00:19:40.914 --> 00:19:44.251
在另一個軸上 改變粗糙度值

00:19:46.520 --> 00:19:50.290
我們曾經說過 會導出基於物理渲染

00:19:51.091 --> 00:19:54.027
來看一下基於物理光照

00:19:54.895 --> 00:19:57.831
在SceneKit光照分爲三類

00:19:58.966 --> 00:20:02.302
首先是基於圖像光照 IBL,

00:20:02.936 --> 00:20:05.539
然後是光照探測 最後是點光源

00:20:06.773 --> 00:20:08.575
基於圖像關照

00:20:10.444 --> 00:20:14.581
我說過
可以利用一個立方體映射圖描述

00:20:14.781 --> 00:20:17.150
3D空間位置的周邊環境

00:20:18.785 --> 00:20:20.621
當對錶面上的一點進行着色時

00:20:20.687 --> 00:20:24.725
我們可以把終點上方當做完結點
根據它的平均值

00:20:25.125 --> 00:20:27.828
和色彩的正確光照信息

00:20:27.895 --> 00:20:29.863
從立方體映射圖中獲取的

00:20:30.731 --> 00:20:33.033
舉例說明 這裏有一個對象

00:20:33.100 --> 00:20:36.236
只利用圖像光照進行照明

00:20:36.303 --> 00:20:37.771
在該場景中沒有光照

00:20:38.272 --> 00:20:39.406
你可看到根據立方體映射圖的改變

00:20:39.473 --> 00:20:42.876
如何顯著影響了對象的外觀

00:20:44.344 --> 00:20:47.648
對場景內所有對象利用基於圖像光照

00:20:47.714 --> 00:20:50.684
將會帶來一致的觀感 協調合作

00:20:52.085 --> 00:20:55.322
在SceneKit裏
使用基於圖像光照非常簡單

00:20:55.923 --> 00:20:59.226
我們爲場景添加一個
“lightingEnvironment”屬性

00:20:59.927 --> 00:21:02.329
只需把它的內容設置爲
一個立方體映射圖

00:21:03.230 --> 00:21:06.533
很棒的是它和background屬性
完美結合

00:21:07.801 --> 00:21:14.074
比如 如果取一個對象
把其background

00:21:14.141 --> 00:21:16.276
和lightingEnvironment屬性
都設爲相同的圖片

00:21:16.343 --> 00:21:19.346
就可以在上下文中顯示一個對象

00:21:21.348 --> 00:21:26.320
立方體映射圖
可以顯示遠處的環境和藝術

00:21:27.487 --> 00:21:29.356
當對錶面上的一點進行着色時

00:21:29.423 --> 00:21:32.960
有可能這個環境不可見

00:21:33.026 --> 00:21:37.097
因爲你正處於山洞
或它們之間有別的對象

00:21:37.798 --> 00:21:41.268
基於圖像光照應該要考慮到這一點

00:21:41.335 --> 00:21:44.705
所以對封閉對象來說效果沒那麼好

00:21:45.539 --> 00:21:48.542
還好我們對此有解決方案 光照探測器

00:21:49.543 --> 00:21:51.345
光照探測器

00:21:51.411 --> 00:21:55.349
光照探測器是面向場景的局部光照

00:21:55.415 --> 00:21:59.753
它們捕捉局部漫反射

00:22:00.420 --> 00:22:05.926
當着色表面某點時
可以找到四個最近的光照探測器

00:22:05.993 --> 00:22:08.929
然後從這些探測器添加光照

00:22:10.397 --> 00:22:13.567
如我所說 光照探測器
它們是局部光源

00:22:13.634 --> 00:22:15.536
它們可以被認爲是閉合的

00:22:16.370 --> 00:22:18.405
可以用這種方法實現

00:22:18.472 --> 00:22:20.741
它們重量輕 效率高

00:22:21.341 --> 00:22:24.044
可以在場景中放置很多光照探測器

00:22:24.311 --> 00:22:25.812
我們推薦這麼做

00:22:26.680 --> 00:22:30.484
因爲探測器越多 就越精細

00:22:30.551 --> 00:22:33.287
獲取的局部光照信息就越準確

00:22:34.855 --> 00:22:36.490
建立光照探測器很簡單

00:22:37.090 --> 00:22:39.359
新建光照 修改其類型

00:22:40.093 --> 00:22:41.962
可以編寫代碼實現

00:22:42.396 --> 00:22:44.865
也可在Xcode SceneKit
的場景編輯器裏

00:22:46.300 --> 00:22:51.505
和立方體映射圖一樣
光照探測器捕捉靜態光照信息

00:22:52.005 --> 00:22:56.210
該信息可以被很簡單地傳入探測器

00:22:56.276 --> 00:22:59.513
只需用到這個API的
Xcode場景編輯器

00:23:00.781 --> 00:23:06.854
我們看了如何利用IBL或光照探測器

00:23:06.920 --> 00:23:09.256
在場景中進行間接照明

00:23:09.823 --> 00:23:12.125
當然也需要直接照明

00:23:12.192 --> 00:23:14.595
還是可以訪問任何別的光照

00:23:15.762 --> 00:23:19.867
如全向 定向或聚光燈

00:23:19.933 --> 00:23:21.668
都可以運用在基於物理渲染中

00:23:21.735 --> 00:23:26.507
實際上我們還有［聽不清］
可以進行更好的設置

00:23:28.075 --> 00:23:30.844
比如
添加“intensity”屬性

00:23:31.879 --> 00:23:37.050
光照強度通過每千瓦的流明數表示

00:23:37.117 --> 00:23:39.553
和燈泡是一個量級

00:23:40.587 --> 00:23:45.392
我們還添加了溫度屬性 單位是開爾文

00:23:45.459 --> 00:23:47.361
可以用該單位區分顏色

00:23:48.795 --> 00:23:52.999
一個新的性能
我們添加了新的光照種類 IES光照

00:23:54.401 --> 00:23:59.306
IES光照 即光度學光照
可以用於任何衰減形狀

00:24:00.574 --> 00:24:03.610
當聚光燈或全向光

00:24:03.677 --> 00:24:07.080
有一個非常對稱的衰減曲線

00:24:07.147 --> 00:24:11.718
IES光照可以更好積累劇場光照的行爲

00:24:12.653 --> 00:24:15.222
比如可以照一個錐形

00:24:15.289 --> 00:24:16.857
也可以照一個陰影

00:24:17.391 --> 00:24:19.726
如此種種 根據光源的形狀

00:24:20.794 --> 00:24:24.498
在SceneKit裏
建立光度學光照很簡單

00:24:24.865 --> 00:24:26.300
同樣 新建光照

00:24:26.366 --> 00:24:27.568
修改類型屬性

00:24:28.402 --> 00:24:32.573
最後提供一個URL 放入配置文件中

00:24:32.639 --> 00:24:36.810
可以比如 從生產商網站上直接下載

00:24:38.812 --> 00:24:43.517
快速複習一下
我們看到在SceneKit中

00:24:43.584 --> 00:24:45.953
新建基於物理材料多麼簡單

00:24:46.019 --> 00:24:50.190
所有這些屬性都是
從表面屬性中衍生出來

00:24:50.257 --> 00:24:52.392
非常容易理解

00:24:52.459 --> 00:24:56.096
以及如何利用光照在
基於物理的材料之上

00:24:57.397 --> 00:25:01.969
請歡迎Jean-Baptiste
和Sebastien做精彩的演示

00:25:04.104 --> 00:25:05.205
謝謝你 Amaury

00:25:05.272 --> 00:25:10.811
爲大家做了關於SceneKit的
全新渲染技術的演講

00:25:12.746 --> 00:25:16.950
我們在實際操作中看一下
Xcode場景編輯器

00:25:17.718 --> 00:25:21.154
如大家所見
Amaury演示的幾乎一切

00:25:21.221 --> 00:25:26.760
都可以在Xcode
場景編輯器裏直接可用

00:25:27.961 --> 00:25:33.333
可以調整屬性 實時觀察結果

00:25:34.067 --> 00:25:40.908
這裏有一個很簡單的場景
卡車上只有一個光照

00:25:41.608 --> 00:25:45.112
打開材料檢查器

00:25:47.314 --> 00:25:50.083
該對象只有兩個材料

00:25:50.717 --> 00:25:53.120
一個車身 一個配件 等等

00:25:53.187 --> 00:25:55.489
選中這兩個材料

00:25:56.623 --> 00:25:58.926
繼續採用布林光照模型

00:25:58.992 --> 00:26:01.862
切換到基於物理光照模型

00:26:01.929 --> 00:26:05.966
把兩個材料設成金屬

00:26:07.167 --> 00:26:09.102
可以看到有一個問題

00:26:09.169 --> 00:26:13.140
因爲我們沒看到環境反射

00:26:13.540 --> 00:26:17.110
打開場景檢查器

00:26:18.312 --> 00:26:20.781
我們必須要爲項目設置光照環境

00:26:21.448 --> 00:26:24.218
爲此我要使用立方體映射圖

00:26:25.719 --> 00:26:30.290
比如 該停車場立方體映射圖

00:26:33.160 --> 00:26:34.494
作爲光照環境

00:26:41.768 --> 00:26:45.138
接下來將集中講解這三個主要的

00:26:45.205 --> 00:26:47.241
基於物理光照模型的屬性

00:26:48.208 --> 00:26:50.410
現在來看粗糙度值

00:26:51.445 --> 00:26:54.982
粗糙度顯示錶面有多光滑

00:26:55.182 --> 00:26:58.719
可以看到

00:27:00.554 --> 00:27:05.559
表面越粗糙 顯示越模糊

00:27:06.994 --> 00:27:10.831
如果把粗糙度值調到近1

00:27:12.833 --> 00:27:14.568
反射很模糊

00:27:14.635 --> 00:27:17.604
當值到達1時 幾乎沒有反射

00:27:20.474 --> 00:27:24.645
如果調回0 表面就非常光滑

00:27:27.881 --> 00:27:30.651
如你所見 一切

00:27:30.717 --> 00:27:33.287
整個環境都在金屬裏反射

00:27:36.290 --> 00:27:40.661
我只用一個常量值代表粗糙度

00:27:41.662 --> 00:27:46.667
然後爲對象的每一個部分指定一個值

00:27:46.733 --> 00:27:48.802
因此我需要一張粗糙度映射圖

00:27:49.136 --> 00:27:51.271
爲車體提供一張粗糙度映射圖

00:27:59.847 --> 00:28:01.748
以及一張配件粗糙度映射圖

00:28:02.449 --> 00:28:05.219
對於金屬度也是一樣操作

00:28:05.285 --> 00:28:08.856
我們需要指定對象的哪些部分是金屬
哪些不是

00:28:08.922 --> 00:28:10.858
所以我們需要提供金屬度映射圖

00:28:11.291 --> 00:28:15.696
設定配件金屬度映射圖

00:28:17.698 --> 00:28:18.599
還有不同的圖

00:28:22.803 --> 00:28:23.670
給車體

00:28:24.404 --> 00:28:29.076
如你所見 對象的車體部分是非金屬

00:28:29.142 --> 00:28:33.847
前面的散熱器格則完全是金屬

00:28:38.619 --> 00:28:40.354
最後是添加反照率

00:28:49.296 --> 00:28:50.197
就完成了

00:28:55.335 --> 00:28:59.072
就這樣 我們爲該卡車進行了
完整的基於物理渲染

00:28:59.139 --> 00:29:03.577
現在切換到場景編輯器
修改立方體映射圖

00:29:04.211 --> 00:29:08.749
比如
這個都是樹的光照環境的立方體地圖

00:29:09.216 --> 00:29:10.784
可以設定爲背景

00:29:13.554 --> 00:29:14.388
就這樣

00:29:15.222 --> 00:29:18.025
如你所見

00:29:18.091 --> 00:29:22.963
新SceneKit場景細節的
使用十分簡單

00:29:23.330 --> 00:29:26.867
爲了說明這種渲染操作

00:29:26.934 --> 00:29:30.504
我們編寫了一個很酷的演示
現在放給大家

00:29:31.872 --> 00:29:34.241
Sebastien將進行講解

00:29:34.741 --> 00:29:35.576
大家好

00:29:38.145 --> 00:29:39.179
謝謝

00:29:40.647 --> 00:29:44.184
很高興爲大家介紹
今年的新的毛茸茸朋友

00:29:44.451 --> 00:29:45.986
Bub Bub是一頭獾

00:29:46.086 --> 00:29:47.487
它開着一臺採礦車

00:29:47.921 --> 00:29:52.292
它要採集珠寶 用於加速

00:29:54.394 --> 00:29:57.331
你看到的所有場景都採用了新的
SceneKit渲染技術

00:29:58.332 --> 00:30:01.268
所有的材料都是基於物理 光照也是

00:30:02.202 --> 00:30:04.338
我們還採用了平常的

00:30:05.038 --> 00:30:11.845
SceneKit的屬性
比如動作 動畫

00:30:11.912 --> 00:30:15.082
和以前有的對象

00:30:17.251 --> 00:30:21.555
這是Swift應用 可在macOS
iOS和tvOS上運行

00:30:22.689 --> 00:30:27.394
都完全用Swift編寫
大概有700行的代碼

00:30:28.462 --> 00:30:31.331
沿着軌道我們安置了光照探測器

00:30:31.798 --> 00:30:34.835
考慮到局部照明的改變

00:30:36.036 --> 00:30:40.674
請注意光照改變 當進入山洞或隧道時

00:30:41.942 --> 00:30:48.949
還加入了新的特效 比如運動模糊

00:30:49.283 --> 00:30:53.220
當Bub像這樣抓到一個加速獎品時
就可以看到

00:30:55.622 --> 00:30:59.793
我們有一個HGI相機
這就是爲什麼光照發生改變

00:30:59.860 --> 00:31:02.896
當有亮光或環境改變時

00:31:03.931 --> 00:31:08.101
我們還採用IDL（交互式數據語言）
編寫光照環境

00:31:09.469 --> 00:31:13.006
還有一些新的 我們喜歡的運動模糊

00:31:14.274 --> 00:31:18.645
當有亮光時 會有綻放效果

00:31:20.781 --> 00:31:23.951
所有的材料 你所看到的
都完全是PBR效果

00:31:24.384 --> 00:31:26.553
對水晶是全自由反射

00:31:26.620 --> 00:31:29.423
對所有的獎品和寶石也是如此

00:31:30.724 --> 00:31:32.492
在這裏又看到了照明變化

00:31:34.094 --> 00:31:36.964
色調映射實現了這一切 謝謝

00:31:42.135 --> 00:31:43.770
我們現在來看幻燈片

00:31:45.172 --> 00:31:47.040
我會再講解一些關於這個演示的內容

00:31:48.141 --> 00:31:52.346
首先 今年我們十分高興告訴大家的是

00:31:52.412 --> 00:31:54.948
和往年一樣 該演示是一個簡單代碼

00:31:55.382 --> 00:31:57.784
是的 謝謝

00:32:00.187 --> 00:32:04.358
大家可以在開發者網站上下載所有代碼

00:32:04.625 --> 00:32:08.896
調試它 檢查場景代碼
看我們如何編寫

00:32:09.129 --> 00:32:12.065
大約700行的Swift代碼

00:32:12.132 --> 00:32:16.003
我們認爲代碼很容易理解
希望你們能夠欣賞所見

00:32:16.069 --> 00:32:18.572
並從中學到一些東西

00:32:20.174 --> 00:32:25.679
今年我們決定 關於演示
我們和美術師們進行了討論

00:32:26.380 --> 00:32:32.653
我們擬定了一些草稿
考慮已有的設計理念

00:32:33.353 --> 00:32:36.990
當我們就設計理念和流程達成一致時

00:32:37.057 --> 00:32:39.860
美術師開始構建模型世界

00:32:40.360 --> 00:32:44.898
這是一個互動的過程 我們非常需要

00:32:45.165 --> 00:32:48.035
能夠在模型正在構建時取得其信息

00:32:48.101 --> 00:32:52.940
並馬上開始編程
而不用等待最終的資產

00:32:54.107 --> 00:32:56.043
所以在SceneKit中
我們有一個自定義工具

00:32:56.109 --> 00:33:00.747
在命令行工具裏
充分利用SceneKit的強大

00:33:01.215 --> 00:33:06.687
爲了採用DAE文件裏的工具
單位轉換爲米

00:33:06.753 --> 00:33:09.923
且它們可在場景裏自動放置光照探測器

00:33:09.990 --> 00:33:11.792
因爲有200多個光照探測器

00:33:11.859 --> 00:33:16.530
我們不想每一次場景轉換時
需要手動安置它們

00:33:19.633 --> 00:33:21.802
我們採用了基於圖像光照

00:33:22.202 --> 00:33:25.239
所以我們有立方體映射圖作爲背景圖片

00:33:25.305 --> 00:33:27.808
另一張立方體映射圖作爲光照環境

00:33:27.875 --> 00:33:30.310
我們採用了光照環境添加反射

00:33:30.377 --> 00:33:32.713
如你所見 對於戶外場景效果非常好

00:33:34.648 --> 00:33:36.483
我們還採用了光照探測器

00:33:36.550 --> 00:33:40.087
它們顯示在Xcode當中
你可以看到它們

00:33:40.354 --> 00:33:41.822
我們對它們進行了高亮顯示

00:33:41.889 --> 00:33:44.625
可以看到只從這個視圖上就已經有
很多光照探測器

00:33:44.691 --> 00:33:46.994
可以想象整個場景中用了多少

00:33:47.594 --> 00:33:52.399
自定義工具把它們放入環境 開始計算

00:33:53.300 --> 00:33:55.402
也可以在Xcode中手動實現

00:33:55.702 --> 00:33:59.573
但是 當然 光照探測器用的越多
就會越沉悶

00:34:00.440 --> 00:34:01.542
它對室內場景很重要

00:34:01.608 --> 00:34:05.879
但它也爲戶外場景視圖
添加了很好的觸摸效果

00:34:05.946 --> 00:34:08.916
來檢測場景中的微小變化

00:34:11.217 --> 00:34:13.853
我們還對室內場景添加了光照映射圖

00:34:13.920 --> 00:34:17.623
因爲它覆蓋了光照環境

00:34:17.690 --> 00:34:21.094
這對山洞非常重要
因爲光照在山洞裏非常不同

00:34:21.161 --> 00:34:23.730
我們採用探測器和光照映射圖

00:34:23.797 --> 00:34:26.567
在該場景中改變了光照和氛圍

00:34:28.034 --> 00:34:32.371
當然我們也採用了正常的映射圖
爲模型添加細節

00:34:33.639 --> 00:34:36.710
我們還採用了環境閉合映射圖

00:34:36.777 --> 00:34:40.880
產生效果更好的光照視圖和渲染

00:34:42.815 --> 00:34:45.918
我們採用了一個點光源來模擬太陽

00:34:46.186 --> 00:34:48.021
在場景中天空的高處

00:34:48.088 --> 00:34:51.891
我們利用它建立動態陰影
並加強全局光照

00:34:54.293 --> 00:34:59.399
所有在演示中看到的材料都是
100%的基於物理材料

00:35:00.067 --> 00:35:05.205
所以有椰子樹在環境反射下的逼真效果
水晶也是如此

00:35:06.073 --> 00:35:09.076
講到水晶
這是我們編寫非常簡單的材料

00:35:09.476 --> 00:35:12.779
它沒有紋理映射 創建非常簡單

00:35:13.180 --> 00:35:16.183
它是全金屬 完全沒有粗糙度

00:35:16.450 --> 00:35:18.185
只是一個漫反射色彩

00:35:18.418 --> 00:35:21.088
所以它是創建寶石的非常好的方法

00:35:21.154 --> 00:35:23.257
寶石几乎對環境全反射

00:35:24.491 --> 00:35:27.661
光譜另一端 可以看到這座塔

00:35:27.728 --> 00:35:32.533
該對象既有金屬部分又有非金屬部分

00:35:32.699 --> 00:35:38.105
採用金屬度 粗糙度映射圖
和紋理映射圖來創建它

00:35:38.672 --> 00:35:42.576
如你所見 我們還是在普通映射圖上
採用漫反射色彩來添加細節

00:35:45.078 --> 00:35:48.815
基本上該演示使用了
所有SceneKit的新功能

00:35:49.449 --> 00:35:54.087
基於物理着色 所有材料和
光照的SceneKit API

00:35:54.154 --> 00:35:55.856
我們採用了Xcode集成

00:35:56.623 --> 00:36:01.228
以及爲流程新建的自定義工具

00:36:01.628 --> 00:36:04.965
我們認爲這是今年新特性的
非常精彩的展示

00:36:05.032 --> 00:36:08.035
也是非常好的示例代碼
能讓大家學到新知識

00:36:08.101 --> 00:36:09.837
希望你們喜歡

00:36:12.039 --> 00:36:13.073
謝謝

00:36:17.377 --> 00:36:19.580
如你們所見

00:36:19.646 --> 00:36:24.184
今年我們對材料和光照進行了重大升級

00:36:24.718 --> 00:36:28.121
我們也因此必須改變相機的表現

00:36:28.188 --> 00:36:30.624
我們已經有了優秀的材料和光照

00:36:31.291 --> 00:36:32.926
我們也需要更好的相機

00:36:33.594 --> 00:36:37.397
現在我們了現實光照

00:36:37.464 --> 00:36:40.934
我們需要有一個HDR相機
或高動態範圍

00:36:41.802 --> 00:36:44.972
因爲普通的相機是低動態範圍

00:36:45.272 --> 00:36:46.707
是每組件8比特

00:36:46.773 --> 00:36:49.176
我們採用浮點組件

00:36:49.243 --> 00:36:54.681
所以可以有非常亮的光照
比如蠟燭或燈泡

00:36:54.748 --> 00:36:58.552
還可以有比如說 太陽
是非常非常亮的光照

00:36:59.152 --> 00:37:00.754
這樣形成了非常高動態範圍

00:37:00.821 --> 00:37:04.358
需要對屏幕上的動態範圍進行重映射

00:37:04.925 --> 00:37:06.527
我們採用色調映射

00:37:06.593 --> 00:37:10.163
色調映射是把部分渲染重映射

00:37:10.230 --> 00:37:12.399
到低設置設備

00:37:14.835 --> 00:37:16.703
所以我們需要啓用HDR相機

00:37:16.770 --> 00:37:20.574
它不是默認設置裏自動設好的
可以在API或者Xcode裏設置

00:37:21.808 --> 00:37:23.210
可以調試色調映射

00:37:23.277 --> 00:37:25.279
可以改變灰點 白點

00:37:25.445 --> 00:37:27.681
以及曝光的範圍

00:37:28.015 --> 00:37:30.384
還可以固定曝光偏移

00:37:30.484 --> 00:37:33.654
舉例說明 這個場景顯示得很好

00:37:33.720 --> 00:37:38.692
但是你可以進行曝光不足渲染
低調顯示 也可以過度曝光

00:37:38.759 --> 00:37:41.094
只需要改變偏移值 很簡單

00:37:43.263 --> 00:37:46.900
因爲有HDR相機
我們還添加了很棒的視覺效果

00:37:47.334 --> 00:37:49.269
首先是綻放效果

00:37:49.703 --> 00:37:53.073
綻放是模擬很強的光照造成的刺眼效果

00:37:53.340 --> 00:37:55.075
來自場景裏或反射

00:37:55.676 --> 00:38:00.581
可以通過散開

00:38:00.647 --> 00:38:02.482
光照附近的放射像素

00:38:02.749 --> 00:38:04.785
在這個例子可以看到 非常好的效果

00:38:04.852 --> 00:38:09.723
可以看看在塔頂上的反射綻放效果

00:38:10.457 --> 00:38:15.295
這是一種很好的方法
使光照附近的像素暈開

00:38:16.296 --> 00:38:18.699
讓渲染潤色不少

00:38:21.702 --> 00:38:23.937
接着我們添加了運動模糊
已經在演示中看到了

00:38:24.671 --> 00:38:26.139
它讓相機運動變得平滑

00:38:27.007 --> 00:38:30.210
如果把運動模糊加入整個場景

00:38:30.277 --> 00:38:31.111
就變成這個樣子

00:38:31.211 --> 00:38:34.047
有時我們並不想讓所有對象都模糊

00:38:34.114 --> 00:38:39.286
比如 我想讓獾和礦車顯示清晰利落

00:38:39.686 --> 00:38:45.926
所以有一個新API
可以從運動模糊中排出某些對象

00:38:46.493 --> 00:38:50.430
結果帶來目標對象顯示清晰利落的效果

00:38:53.534 --> 00:38:59.806
今年我們在現實生活相機中
加了幾個變化

00:39:00.440 --> 00:39:02.142
首先是漸暈

00:39:02.442 --> 00:39:07.181
漸暈是現實生活鏡頭的誤差

00:39:07.247 --> 00:39:09.816
在圖像角落上形成陰影

00:39:10.417 --> 00:39:14.988
所以你可以把這張圖像換到這張

00:39:15.055 --> 00:39:18.091
也可以改變環境對象 把濾鏡

00:39:18.158 --> 00:39:21.361
從圖像中間調到圖像邊緣

00:39:22.396 --> 00:39:26.633
今年模擬的另一個誤差是彩色邊紋

00:39:26.767 --> 00:39:30.337
彩色邊紋是實際鏡頭中發生的折射

00:39:30.404 --> 00:39:32.005
實際鏡頭的玻璃上

00:39:32.706 --> 00:39:39.613
所以它會在渲染中產生
光照的紫紅色和黃褐色陰影

00:39:39.680 --> 00:39:41.248
就會看到這個樣子變成這個樣子

00:39:41.315 --> 00:39:42.850
這個例子很極端

00:39:43.083 --> 00:39:45.485
可以更加溫和細緻 取得好的效果

00:39:47.521 --> 00:39:50.858
我們還加入了一個
可以改變場景氛圍的好辦法

00:39:50.924 --> 00:39:52.059
就是色彩校正

00:39:52.326 --> 00:39:56.263
可以改變飽和度 達到幾乎黑白效果

00:39:56.330 --> 00:39:58.065
如果你想 也可以讓色彩更誇張

00:39:58.131 --> 00:40:00.634
還可以改變場景對比度

00:40:01.201 --> 00:40:05.539
就會產生正常的圖像或不飽和的

00:40:06.974 --> 00:40:09.643
或過度飽和的圖像 然後改變對比度

00:40:13.146 --> 00:40:17.851
最後一個 有着非常非常棒的效果

00:40:18.018 --> 00:40:19.219
就是調色

00:40:19.286 --> 00:40:22.322
調色讓我們完全重映射

00:40:22.389 --> 00:40:25.259
場景的顏色 變爲完全不同的顏色

00:40:25.692 --> 00:40:28.662
我們採用正方形條形圖片

00:40:28.829 --> 00:40:32.065
構建3D顏色立方體 當作查找表

00:40:32.533 --> 00:40:35.035
來重映射本來的顏色到全新的

00:40:35.102 --> 00:40:37.771
舉個例子 我們重映射

00:40:37.838 --> 00:40:41.475
上面這條的普通顏色 到褐色調

00:40:41.942 --> 00:40:46.680
這就是褐色調的效果

00:40:46.747 --> 00:40:49.616
操作很簡單 我們覺得很棒

00:40:49.683 --> 00:40:50.717
看上去很不錯

00:40:52.486 --> 00:40:55.055
這就是今年對HDR相機的更新

00:40:55.322 --> 00:40:58.125
我們覺得這是非常棒的升級

00:40:58.559 --> 00:41:00.127
期待看到大家使用後的結果

00:41:00.194 --> 00:41:03.764
我們把所有的新效果都集中整合
供用戶使用

00:41:03.830 --> 00:41:06.500
你不用在比如綻放或運動模糊之間選擇

00:41:06.667 --> 00:41:08.168
可以同時使用所有效果

00:41:08.368 --> 00:41:09.269
當然這些是需要付費的

00:41:09.336 --> 00:41:14.875
但是你可以用來做出非常棒的圖片和
看上去非常酷的場景

00:41:15.876 --> 00:41:19.913
現在我把講臺讓給Nick
來講解今年Model I/O的改進

00:41:20.080 --> 00:41:20.981
非常感謝

00:41:28.322 --> 00:41:29.723
好的 大家好

00:41:29.823 --> 00:41:32.025
首先我將稍微講解

00:41:32.092 --> 00:41:37.731
今年模塊輸入輸出和
SceneKit上的改進

00:41:39.166 --> 00:41:43.537
今年SceneKit可以導入模塊

00:41:43.604 --> 00:41:49.042
到自定義格式比如
不一定和以前一樣的三角形

00:41:49.109 --> 00:41:53.747
而是四邊形或任意多邊形的拓撲

00:41:53.814 --> 00:41:57.050
作者最初新建內容的地方

00:41:57.551 --> 00:42:00.320
SceneKit 如果需要
會自動進行三角測量

00:42:00.387 --> 00:42:02.589
從而完成渲染

00:42:02.990 --> 00:42:08.495
問題是如果想要採用全新的鑲嵌設備

00:42:08.562 --> 00:42:12.633
你需要讓鑲嵌有精確的形狀

00:42:12.699 --> 00:42:16.403
所以你需要修改代碼 採用
“preservedOriginalTopology”標識

00:42:16.770 --> 00:42:19.206
該標識和Model I/O標識一致

00:42:19.439 --> 00:42:22.509
把它帶入資產 進行指定

00:42:22.576 --> 00:42:25.479
它將保留所有的孔 折線
以及所有重要的東西

00:42:25.546 --> 00:42:27.915
爲了對象的正確再現

00:42:29.016 --> 00:42:33.620
今年我們還改進了細分算法

00:42:33.754 --> 00:42:37.624
成爲新的體系 來自Pixar的
OpenSubdiv 3

00:42:37.925 --> 00:42:39.293
可以看到在這個例子中

00:42:39.359 --> 00:42:43.130
有之前以三角形方式導入的對象
當進行鑲嵌時

00:42:43.197 --> 00:42:47.334
我們想進行平滑細分的盒子
顯得有點凹凸不平

00:42:47.901 --> 00:42:50.504
如果取出該對象 保持其拓撲結構

00:42:50.771 --> 00:42:57.044
可以看到四邊形形成了均勻的圓形表面

00:42:57.110 --> 00:42:58.111
看上去效果很好

00:42:58.612 --> 00:43:02.583
這是一種非常好的方法 讓輕量對象

00:43:02.649 --> 00:43:06.386
可以根據場景縮放分辨率 諸如此類

00:43:06.854 --> 00:43:12.159
輸入輸出的另一方面 我想要強調的

00:43:12.226 --> 00:43:17.097
是去年我們在Model I/O裏
引入了基於物理材料等

00:43:17.331 --> 00:43:21.235
它們自然連接了
所有SceneKit的內容

00:43:21.301 --> 00:43:25.939
如果在Model I/O裏
指定了高動態範圍相機

00:43:26.006 --> 00:43:28.609
它會四處可用 不會失去任何屬性

00:43:30.711 --> 00:43:32.880
來看Model I/O

00:43:32.946 --> 00:43:34.081
快速複習一下

00:43:34.748 --> 00:43:38.485
如［聽不清］所說
模塊輸入輸出

00:43:38.552 --> 00:43:40.654
在框架和系統裏

00:43:42.289 --> 00:43:45.459
顯然需要它們 把數據在應用之間

00:43:45.526 --> 00:43:48.595
新建對象的地方 以及翻譯對象

00:43:48.662 --> 00:43:52.032
在框架之間 比如SceneKit
和MetalKit 等等

00:43:52.466 --> 00:43:56.670
我們支持很多標準文件格式

00:43:57.004 --> 00:44:01.308
文件格式是一種方法 讓內容

00:44:01.375 --> 00:44:03.310
從成品輸出到工具

00:44:03.377 --> 00:44:05.312
以前存在的格式

00:44:05.379 --> 00:44:08.015
專業範圍很窄

00:44:08.215 --> 00:44:10.651
比如 只是一個模型

00:44:10.717 --> 00:44:12.486
或者只是一大堆數據

00:44:12.986 --> 00:44:18.125
今年很激動人心的是

00:44:18.192 --> 00:44:21.895
我們和Pixar聯袂合作

00:44:21.962 --> 00:44:25.432
引入了對全局場景描述工具的支持

00:44:26.466 --> 00:44:32.105
現在全局場景描述是全新的公開標準

00:44:32.806 --> 00:44:36.877
關於它非常有趣和令人激動的是

00:44:36.944 --> 00:44:41.949
它不僅僅是一個文件系統
和一種格式

00:44:42.182 --> 00:44:47.120
很容易以ASCII讀取
或足夠以二進制加載

00:44:47.588 --> 00:44:51.091
它還包含了一個場景組合引擎

00:44:51.525 --> 00:44:55.262
這讓它真正
從以前的其他格式中區分開來

00:44:55.729 --> 00:44:58.599
它凝聚了多年來的實際操作經驗

00:44:58.665 --> 00:45:00.667
Pixar採用它製作電影

00:45:01.034 --> 00:45:06.840
明天上映的“海底總動員2”
完全從USD文件產生

00:45:07.374 --> 00:45:10.878
現在USD有專門用於場景的數據類型

00:45:11.278 --> 00:45:16.383
並且再一次
除了將此格式作爲開放格式

00:45:16.450 --> 00:45:19.520
還有文件分層 實現併發流程

00:45:19.920 --> 00:45:23.757
併發工作流程非常棒

00:45:25.192 --> 00:45:29.096
這是一個例子 可能在

00:45:29.162 --> 00:45:32.132
在全局場景描述中取得的
關於電影中某個典型場景

00:45:32.699 --> 00:45:37.037
我們有一個取景層
取景被分層

00:45:37.104 --> 00:45:39.439
從組件 從背景 從角色

00:45:39.506 --> 00:45:42.042
角色本身可能包含很多組件

00:45:42.609 --> 00:45:45.913
可以看到該取景層圖片有很多分層

00:45:46.046 --> 00:45:49.349
因爲你不止可以新建一個場景

00:45:49.416 --> 00:45:51.051
由所有這些內容構成的

00:45:51.118 --> 00:45:52.986
你還可以做出改變

00:45:53.053 --> 00:45:57.257
場景描述可以讓你知道 這是第四鏡

00:45:57.324 --> 00:46:00.427
角色可能出來快了些或慢了些

00:46:00.827 --> 00:46:05.732
可以把所有這些變化存入一個文件
爲了審閱

00:46:09.403 --> 00:46:13.941
另一個全局場景描述的特點是

00:46:14.007 --> 00:46:16.710
據我所知 它是唯一的開源文件格式

00:46:17.077 --> 00:46:22.316
允許在對象變化中對類進行指定

00:46:22.716 --> 00:46:26.453
可以想象 可能出現一種情況

00:46:26.520 --> 00:46:28.856
有很多野獸 都想闖進大學

00:46:28.922 --> 00:46:30.090
之類的 那裏有書本

00:46:30.524 --> 00:46:34.261
在傳統的工作流程中 你大概會

00:46:34.328 --> 00:46:37.130
發現自己在編寫書本 編寫程序

00:46:37.231 --> 00:46:39.733
爲每本小書都新建無數文件

00:46:39.800 --> 00:46:44.071
然後把它們放在書架上
然後一本一本取出進行渲染

00:46:44.605 --> 00:46:46.440
真的很枯燥

00:46:46.640 --> 00:46:49.877
在遊戲裏 有一種角色團隊

00:46:49.943 --> 00:46:52.779
可能各個角色有所不同
比如髮型和T恤

00:46:53.180 --> 00:46:55.449
你可能不得不把它們都刪除

00:46:55.516 --> 00:46:57.351
而現在全局場景描述

00:46:57.417 --> 00:47:01.955
允許你在對象的一個單一文件類中
進行指定

00:47:02.022 --> 00:47:05.192
所以一個類在這裏顯然代表了了一本書

00:47:07.761 --> 00:47:08.595
所以

00:47:09.329 --> 00:47:15.068
文件可以代表很多不同幾何形狀的書

00:47:15.335 --> 00:47:18.872
顯然有一本寬的 長的 還有一本厚的

00:47:19.506 --> 00:47:23.777
當你把書實例化 放入書架時

00:47:23.844 --> 00:47:25.746
你可以告訴全局場景描述

00:47:26.013 --> 00:47:29.483
我想要這本書 想讓它這麼寬這麼長

00:47:29.750 --> 00:47:31.618
它會提供你想要的信息

00:47:31.685 --> 00:47:36.723
實例化進入運行 或照片 都可以

00:47:39.526 --> 00:47:46.133
你在一個單一文件內的
改變可以是很多軸上的

00:47:46.433 --> 00:47:48.869
在本例中 我將修改一些着色屬性

00:47:49.002 --> 00:47:51.004
剛纔我有所有這些書

00:47:51.071 --> 00:47:52.840
我可以給它們着任何我想要的顏色

00:47:53.340 --> 00:47:58.312
神奇的地方是 我把書放好
最後我問

00:47:58.412 --> 00:47:59.580
爲了渲染

00:47:59.646 --> 00:48:02.616
在這個地方的書是什麼顏色的？

00:48:02.683 --> 00:48:07.221
它會找出來
根據所有的場景組合的邏輯

00:48:07.287 --> 00:48:11.892
文件和引擎包含的
它應該被表達的方式

00:48:13.060 --> 00:48:18.465
除此以外 你還可以在一個單一文件內

00:48:18.532 --> 00:48:19.666
表達不同的功能

00:48:19.933 --> 00:48:23.537
我將要展示的是在非常低的終端

00:48:23.604 --> 00:48:27.741
比如某個可穿戴設備
可能只顯示低多邊形版本

00:48:27.841 --> 00:48:31.578
同樣的文件可以展示出合適的效果

00:48:32.312 --> 00:48:35.282
在已有功能的最高渲染上

00:48:36.149 --> 00:48:39.820
我們集成了全局場景描述

00:48:39.887 --> 00:48:42.222
跨越所有系統和框架

00:48:42.856 --> 00:48:46.460
所以 在最底層

00:48:46.627 --> 00:48:50.330
如果把一個全局場景描述文件
導入Model I/O

00:48:50.397 --> 00:48:51.965
我不期待你們可以讀懂

00:48:52.165 --> 00:48:55.736
可以獲得一個熟悉的
Model I/O對象層次

00:48:55.802 --> 00:48:58.605
含有所有在全局場景描述文件中的屬性

00:48:58.672 --> 00:49:01.441
精確地表現 所以可以使用我們的工具

00:49:01.508 --> 00:49:05.546
Model I/O所提供的
比如 放置光照探測器

00:49:05.612 --> 00:49:08.048
並且評估它們的最佳位置

00:49:10.284 --> 00:49:15.689
然而 除此之外 比如有一個項目

00:49:15.756 --> 00:49:18.258
你的美術團隊給了你一個
包含很多內容的文件夾

00:49:19.126 --> 00:49:22.596
你可以在Finder裏打開窗口
包含所有內容

00:49:22.663 --> 00:49:25.766
Finder會準備好縮略圖

00:49:25.832 --> 00:49:26.900
因此可以看見裏面有什麼

00:49:27.334 --> 00:49:29.102
快速查找也適用

00:49:29.169 --> 00:49:32.172
你可以選中其中一個對象 按下空格鍵

00:49:32.239 --> 00:49:34.174
它會跳出 你可將其翻來翻去

00:49:34.374 --> 00:49:38.145
當然快速查找一次只能顯示一個對象

00:49:38.312 --> 00:49:40.848
如果你想保留一個對象以進行比較

00:49:40.914 --> 00:49:44.117
或者你的USD文件有多臺相機
或多項內容

00:49:44.184 --> 00:49:48.121
你想逐個檢查 可以用預覽打開

00:49:48.188 --> 00:49:51.792
全局場景描述在那裏實現地非常好

00:49:53.093 --> 00:49:57.331
如果把全局場景文件讀入Xcode

00:49:57.397 --> 00:50:00.667
它通過Model I/O
導入SceneKit

00:50:00.734 --> 00:50:03.136
含有該文件內完全相同的屬性表達

00:50:03.270 --> 00:50:06.507
所以可以在層次瀏覽器上進行查看

00:50:06.673 --> 00:50:07.908
可以查看屬性

00:50:08.141 --> 00:50:11.011
可以移動對象 可以添加相機

00:50:11.078 --> 00:50:13.547
修改場景 返回給USD

00:50:13.614 --> 00:50:16.216
然後你把它發回給美術師們說

00:50:16.283 --> 00:50:17.885
你知道 我做了點修改

00:50:17.951 --> 00:50:19.486
你能不能 你知道該怎麼做

00:50:20.454 --> 00:50:25.325
最後 它歸入SceneKit

00:50:25.392 --> 00:50:30.063
Pixar的朋友爲我們提供了
“海底總動員2”裏的雷先生

00:50:30.631 --> 00:50:33.967
這是SceneKit
最直接可用的功能

00:50:34.034 --> 00:50:37.571
用最新的基於物理着色方法
你剛纔已經全部聽過

00:50:38.005 --> 00:50:43.710
我們只在電影資產中
播放了3秒動畫

00:50:43.777 --> 00:50:45.312
看上去效果非常非常好

00:50:47.147 --> 00:50:50.817
你還需要插件

00:50:50.884 --> 00:50:53.620
才能把全局場景描述集成到工作流程中

00:50:54.087 --> 00:50:57.758
從而激活資產的動作 在人物

00:50:57.958 --> 00:51:00.561
內容創作節目 編寫的應用之間

00:51:01.094 --> 00:51:04.698
所有插件 開源信息

00:51:04.765 --> 00:51:07.801
可用性 時間表等等等等

00:51:07.868 --> 00:51:12.773
都可以在openusd.org
網站上找到 我建議大家訪問

00:51:12.840 --> 00:51:16.777
找出可以在你的管道和進程中
可用到的內容

00:51:18.612 --> 00:51:20.447
這就是全局場景描述

00:51:28.088 --> 00:51:29.089
快速總結一下

00:51:29.923 --> 00:51:34.528
SceneKit在我們的所有系統
和平臺上可用

00:51:34.795 --> 00:51:36.096
這非常令人讚歎

00:51:36.396 --> 00:51:39.833
我們有基於物理渲染
針對任何美術外觀狀態

00:51:39.900 --> 00:51:43.704
以及美術表現狀態 看上去非常美

00:51:43.904 --> 00:51:47.608
HDR相機和效果讓你

00:51:47.674 --> 00:51:51.011
控制如何表現對象
以及外觀 非常高質量

00:51:51.612 --> 00:51:56.049
我們還提供全局場景描述的支持

00:51:56.116 --> 00:51:58.852
我們非常高興能在背後進行支持

00:51:58.919 --> 00:52:01.922
並且認爲將在工作流程裏大顯身手

00:52:01.989 --> 00:52:04.191
在未來的日子裏

00:52:06.760 --> 00:52:10.797
關於本次演講609
更多信息 都可以在網站上找到

00:52:13.534 --> 00:52:15.802
相關演講還有

00:52:15.869 --> 00:52:19.173
Xcode中可視化調試和廣色域
遊戲技術和Apple Watch

00:52:19.239 --> 00:52:22.142
今天和明天可以參加

00:52:22.209 --> 00:52:23.477
非常感謝大家