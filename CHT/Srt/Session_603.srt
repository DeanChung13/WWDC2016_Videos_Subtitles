00:00:19.887 --> 00:00:23.790 
採用Metal技術 第二部分

00:00:30.797 --> 00:00:33.100 
大家好 歡迎來到全球開發者大會

00:00:33.166 --> 00:00:34.935 
希望目前爲止 你們都過得很愉快

00:00:35.002 --> 00:00:36.336 
你們已看過很多優秀的演講

00:00:36.403 --> 00:00:38.505 
我們爲你們準備了非常棒的一週

00:00:38.572 --> 00:00:39.773 
會非常有趣的

00:00:39.840 --> 00:00:40.707 
我是Matt Collins

00:00:40.774 --> 00:00:42.543 
這是我的同事Jared Marsau

00:00:42.609 --> 00:00:45.379 
我們將爲你講解
採用Metal技術 第二部分

00:00:45.445 --> 00:00:47.548 
這裏是603號演講

00:00:48.015 --> 00:00:50.951 
如果你走錯了 你也能看到一些圖像

00:00:53.787 --> 00:00:54.721 
所以 讓我們回憶一下

00:00:55.189 --> 00:00:56.557 
我們共有兩部分
“採用Metal技術”演講

00:00:56.623 --> 00:00:59.226 
希望你們也參加了
Warren的第一部分演講

00:00:59.293 --> 00:01:01.495 
第一部分我們講解了基本概念：

00:01:01.562 --> 00:01:04.998 
基本繪圖 光照 紋理
諸如此類的優秀功能

00:01:05.666 --> 00:01:08.135 
在本次演講中 我們會更上一個層次

00:01:08.202 --> 00:01:09.703 
我們會繪製很多對象

00:01:09.770 --> 00:01:12.272 
我們將會講解如何管理動態數據

00:01:12.339 --> 00:01:13.907 
大量的動態數據

00:01:14.308 --> 00:01:15.909 
GPU-CPU同步

00:01:16.443 --> 00:01:18.879 
我們將會以多線程編碼的話題結束

00:01:20.414 --> 00:01:22.649 
明天我們還有精彩的演講

00:01:22.950 --> 00:01:24.718 
我們會講解Metal的新特性

00:01:25.085 --> 00:01:28.689 
明天的第一個演講
將講解細分曲面 資源堆

00:01:28.755 --> 00:01:30.157 
無記憶幀緩衝

00:01:30.490 --> 00:01:32.326 
和關於我們改進後的工具

00:01:32.392 --> 00:01:34.895 
以真正幫助大家做出最好的應用

00:01:35.128 --> 00:01:37.631 
第二部分 我們將要討論函數專用化

00:01:37.831 --> 00:01:39.633 
以及函數資源讀寫

00:01:40.033 --> 00:01:42.169 
豐富的色彩和紋理資產

00:01:42.870 --> 00:01:45.239 
此外還有Metal性能着色器

00:01:46.540 --> 00:01:47.941 
如果你還想繼續深入

00:01:48.008 --> 00:01:50.978 
我們還會有關於高級着色器優化的
精彩討論

00:01:51.044 --> 00:01:53.947 
着色起性能基礎 調整着色器代碼

00:01:54.281 --> 00:01:56.617 
及更多關於硬件工作原理的細節
將會十分精彩

00:01:56.683 --> 00:01:59.019 
如果你對調整着色器代碼非常感興趣

00:01:59.086 --> 00:02:01.722 
想讓它們達到最佳效果
請關註明天的講座

00:02:04.458 --> 00:02:06.860 
這裏是採用Metal技術的第二部分

00:02:07.394 --> 00:02:09.729 
我們將在第一部分的所學基礎上繼續

00:02:10.030 --> 00:02:11.765 
我們弄清楚如何啓動和運行

00:02:12.266 --> 00:02:14.067 
讓我們看一下你所需要的概念

00:02:14.134 --> 00:02:16.637 
能讓Metal在真實世界
得到最大的應用

00:02:17.337 --> 00:02:20.541 
我們有一個演示
將會把很多內容繪入一個簡單的場景

00:02:20.807 --> 00:02:23.944 
在今天的演講中
我們都會使用該演示作爲上下文

00:02:24.011 --> 00:02:26.313 
並從中學到很多內容

00:02:27.281 --> 00:02:29.983 
我們將會講解數據的理想組織流程

00:02:30.050 --> 00:02:32.352 
如何管理大批量動態數據

00:02:32.553 --> 00:02:36.156 
CPU和GPU同步的重要性

00:02:36.290 --> 00:02:39.026 
以及如我之前所說 一些多線程編碼

00:02:39.693 --> 00:02:41.595 
希望你已對Metal的基礎有所熟悉

00:02:41.662 --> 00:02:42.996 
因爲我們不會再次講解

00:02:43.063 --> 00:02:46.233 
我們預設你已經理解
如何新建Metal隊列

00:02:46.433 --> 00:02:48.902 
新建Metal命令緩衝
如何編碼指令

00:02:49.970 --> 00:02:51.672 
我們在此基礎上進行下一步

00:02:53.240 --> 00:02:57.177 
我們先來看演示
看看我們的目標是什麼

00:02:58.879 --> 00:03:01.348 
現在我們有10,000個立方體

00:03:01.982 --> 00:03:04.418  
它們都在四處旋轉 在空中加載

00:03:04.651 --> 00:03:05.853  
很有趣的畫面

00:03:06.653 --> 00:03:08.689  
Metal允許我們展開無數繪圖調用

00:03:08.755 --> 00:03:09.957  
開銷卻很小

00:03:10.224 --> 00:03:13.293  
所以在此有10,000個立方體和
10,000個繪圖調用

00:03:14.061 --> 00:03:16.029  
你可以看到在底部 有一點陰影

00:03:16.096 --> 00:03:17.331  
我們正使用一個陰影映射

00:03:17.664 --> 00:03:19.933  
它被放在底部
是一些美觀的反鋸齒線

00:03:20.000 --> 00:03:21.235  
產生一些深度暗示

00:03:23.003 --> 00:03:24.471  
當然是所有的立方體

00:03:25.272 --> 00:03:27.508  
所以怎樣才能渲染這樣的畫面？

00:03:27.941 --> 00:03:29.543  
我們有很多對象

00:03:29.610 --> 00:03:33.146  
每一個對象都有自身相關聯的唯一數據

00:03:33.413 --> 00:03:36.617  
我們需要位置 旋轉和顏色

00:03:37.150 --> 00:03:39.386 
每一幀都必須要更新
因爲我們在動畫顯示它們

00:03:39.453 --> 00:03:42.256 
所以這是我們不斷在改變的一組數據

00:03:42.623 --> 00:03:45.225 
不斷重新通知GPU我們正在繪製什麼

00:03:46.159 --> 00:03:47.861 
我們還可以繪製更多的對象

00:03:49.096 --> 00:03:50.097  
還可以再多一點

00:03:51.098 --> 00:03:52.666  
你可以把它們轉動起來

00:03:52.733 --> 00:03:54.668  
看到它們正漂浮在空中

00:03:56.703 --> 00:04:00.541  
所以我們有一個立方體的繪圖調用
和相關數據

00:04:00.774 --> 00:04:03.577 
我們得想想該如何更好地思考這些數據

00:04:03.644 --> 00:04:04.645 
如何管理它們

00:04:04.811 --> 00:04:06.880 
以及如何讓它和GPU通訊

00:04:08.215 --> 00:04:09.316 
讓我們深入看一下

00:04:09.883 --> 00:04:10.784 
謝謝你 Jared

00:04:14.755 --> 00:04:16.089 
管理動態數據

00:04:16.490 --> 00:04:18.992 
這是每一幀都在變化的大量數據

00:04:19.059 --> 00:04:21.361 
可以想像 在一個現代應用裏
比如一個遊戲

00:04:21.495 --> 00:04:24.531 
你也需要每幀都要更新的大量數據

00:04:25.399 --> 00:04:27.434 
所以我們的繪圖基本看上去是這樣

00:04:27.668 --> 00:04:29.937 
我們想遍歷所有在繪圖中感興趣的對象

00:04:30.003 --> 00:04:30.871 
並更新它們

00:04:31.772 --> 00:04:34.441 
然後我們想爲每一個對象編碼繪圖調用

00:04:35.008 --> 00:04:37.277 
然後我們必須提交所有這些GPU指令

00:04:37.678 --> 00:04:38.946 
我們有很多對象

00:04:39.012 --> 00:04:41.448 
我們從10,000個開始 不斷增加

00:04:41.748 --> 00:04:43.417 
直到10萬 20萬個

00:04:44.117 --> 00:04:46.119 
每一個對象都有自己的數據集合

00:04:46.720 --> 00:04:48.989 
我們要找到更新數據的最好方法

00:04:50.924 --> 00:04:53.360 
過去 你可能做過類似這樣的事情

00:04:54.261 --> 00:04:55.929 
你把更新好的數據推送到GPU

00:04:55.996 --> 00:04:57.564 
可能是統一形式或其他

00:04:58.098 --> 00:05:00.567 
綁定一個着色器 一些緩衝 一些紋理

00:05:00.634 --> 00:05:01.535 
然後開始繪製

00:05:02.002 --> 00:05:03.370 
然後你推送更多的數據

00:05:03.770 --> 00:05:05.506 
綁定着色器 緩衝 紋理

00:05:05.572 --> 00:05:06.740 
繪製下一個對象

00:05:07.007 --> 00:05:09.877 
在我們的場景裏 重複1萬 2萬次

00:05:10.410 --> 00:05:12.579 
但是我們想跳出這樣的模式

00:05:12.646 --> 00:05:13.680 
嘗試新的方法

00:05:16.016 --> 00:05:18.252 
如果我們可以預先加載所有數據

00:05:18.552 --> 00:05:22.055 
所有發出的指令 以及數據引用
都已經存在

00:05:22.623 --> 00:05:24.992 
GPU是一個非常強大的處理器

00:05:25.058 --> 00:05:26.393 
它不願意等待

00:05:27.127 --> 00:05:30.831 
如果所有數據都已經就位
只需把GPU指向它即可

00:05:31.064 --> 00:05:32.599 
它會很高興地開始處理

00:05:32.666 --> 00:05:34.101 
爲我們處理所有的渲染

00:05:36.603 --> 00:05:38.071 
我們發出的每一個繪圖調用

00:05:38.138 --> 00:05:41.141 
都可以引用合適的數據
都已經存在了

00:05:41.742 --> 00:05:43.744 
在我們的示例中 這一切很簡單易懂

00:05:43.810 --> 00:05:46.280 
我們有一個繪圖調用 引用了一組數據

00:05:46.580 --> 00:05:49.216 
第一個繪圖調用引用第一組數據

00:05:49.283 --> 00:05:51.885 
第二個 第二組 依此類推

00:05:52.486 --> 00:05:53.921 
但並不是隻有這種方法

00:05:54.221 --> 00:05:55.656 
實際上可以重複使用數據

00:05:56.456 --> 00:05:58.892 
我們有一些數據
如前面的這些 幀數據

00:05:59.693 --> 00:06:01.762 
可以從所有的繪圖調用中引用

00:06:01.895 --> 00:06:03.197 
或者 我們可以有一個繪圖調用

00:06:03.263 --> 00:06:05.732  
在不同的地方引用兩組數據

00:06:06.133 --> 00:06:08.902 
如果你熟悉實例化的概念
其理念是很相近的

00:06:09.203 --> 00:06:12.172 
開始渲染的時候
所有的數據已經準備好

00:06:15.142 --> 00:06:16.577 
Metal是如何做到的？

00:06:17.377 --> 00:06:20.848 
在我們的應用裏
新建一個單一Metal緩衝

00:06:21.014 --> 00:06:22.516 
這是我們的常量緩衝

00:06:22.616 --> 00:06:25.085 
它擁有我們需要用來渲染框架的
所有數據

00:06:25.552 --> 00:06:28.722 
我們想事先就新建好 在渲染循環之外

00:06:28.789 --> 00:06:30.490 
並且在每一次繪製中重新使用

00:06:31.058 --> 00:06:32.459 
我們不需要複製任何數據

00:06:32.893 --> 00:06:35.495 
再次強調
任何繪圖調用可以引用任何數據

00:06:35.996 --> 00:06:37.598 
所以沒有必要複製

00:06:38.465 --> 00:06:41.201 
每一個繪圖調用都會
把一個偏移引用到緩衝

00:06:41.602 --> 00:06:45.105 
它會作一小部分跟蹤處理
從而知道哪個繪圖代表了哪個偏移

00:06:46.106 --> 00:06:48.775 
你可以運用一切繪圖 一切都已經就位

00:06:49.176 --> 00:06:50.811 
我們來看看這部分代碼

00:06:53.213 --> 00:06:54.515 
這是應用裏的代碼

00:06:54.781 --> 00:06:56.750 
你可以認爲我們有兩個數據集合

00:06:56.817 --> 00:06:59.319 
如我之前所講 有一個幀數據集合

00:06:59.887 --> 00:07:01.054 
將在這裏進行更新

00:07:03.357 --> 00:07:05.926 
這是每個對象都發生改變的數據集合

00:07:06.293 --> 00:07:08.562 
這是唯一旋轉位置 等等

00:07:09.796 --> 00:07:11.765 
我們需要把兩組數據都準備好

00:07:16.870 --> 00:07:18.539 
我所說的每幀數據是什麼意思呢？

00:07:19.473 --> 00:07:22.509 
這是每次進行繪圖調用時
都保持一致的數據

00:07:23.377 --> 00:07:26.480 
比如 在本例中 有一個視圖投影矩陣

00:07:26.547 --> 00:07:28.782 
這是個4X4的矩陣 很直觀

00:07:28.849 --> 00:07:30.384 
如果你熟悉圖像處理

00:07:30.450 --> 00:07:32.953 
它代表了照相機變換和投影

00:07:33.420 --> 00:07:35.255 
在框架範圍內將不會發生改變

00:07:35.322 --> 00:07:36.757 
所以我們只需要一份副本

00:07:38.091 --> 00:07:39.993 
我們想要儘可能多地重複使用數據

00:07:40.894 --> 00:07:43.564 
所以我們新建一個副本 放入緩衝內

00:07:43.931 --> 00:07:45.265 
開始填充

00:07:47.234 --> 00:07:50.037 
在這裏 是常量緩衝

00:07:50.103 --> 00:07:52.005 
也就是新建的Metal緩衝

00:07:52.072 --> 00:07:54.775 
通過Contents函數
我們有了一個指向它的指針

00:07:58.545 --> 00:08:01.281 
我們的應用有一個幫助函數
也就是取出幀數據

00:08:01.548 --> 00:08:04.418 
它將返回我剛演示過的主通路結構

00:08:04.484 --> 00:08:06.119 
裏面有視圖轉換

00:08:06.186 --> 00:08:08.188 
視圖投影轉換
不好意思

00:08:08.922 --> 00:08:11.859 
之後只需簡單地把它複製到緩衝的前端

00:08:12.826 --> 00:08:13.994 
然後一切就緒

00:08:15.028 --> 00:08:16.496 
我們的緩衝看上去將會是這樣

00:08:16.563 --> 00:08:19.466 
我們有一個主通路 含有合適的幀數據

00:08:20.133 --> 00:08:22.669 
並且把它放到巨大的常量緩衝的前端

00:08:23.837 --> 00:08:25.973 
所以後面會有這一片空白區域

00:08:26.039 --> 00:08:29.543 
如之前所見
我們需要做1萬次 2萬次的繪圖調用

00:08:29.776 --> 00:08:32.479 
所以需要開始在裏面填充很多信息

00:08:35.249 --> 00:08:37.183 
然後我們有了一組每個對象數據

00:08:37.618 --> 00:08:40.153 
這是繪製單一對象所需要的唯一數據

00:08:40.888 --> 00:08:43.789 
在我們的例子裏
有一個“局部空間到世界空間”轉換

00:08:43.857 --> 00:08:46.493 
它是位置和旋轉的串聯

00:08:46.727 --> 00:08:47.761 
還有顏色

00:08:48.595 --> 00:08:50.931 
這就是每一個繪圖調用所需的數據集合

00:08:56.403 --> 00:08:58.872 
我們會遍歷想要渲染的每一個對象

00:08:59.673 --> 00:09:01.808 
記錄偏移位置到緩衝

00:09:02.309 --> 00:09:04.344 
我們有“更新數據”實用工具函數

00:09:04.411 --> 00:09:06.747 
它將更新旋轉數據

00:09:06.813 --> 00:09:08.348 
然後更新偏移數據

00:09:08.649 --> 00:09:11.652 
這樣將數據緊密封裝
一邊遍歷一邊填充

00:09:11.919 --> 00:09:14.588 
看看“更新數據”函數是什麼樣子

00:09:16.456 --> 00:09:17.391 
它非常簡單

00:09:19.359 --> 00:09:22.329 
動畫效果似乎不是本次演講的範圍

00:09:22.996 --> 00:09:26.600 
有一個小幫助函數 “更新動畫”函數
帶有“增量時間”參數

00:09:26.867 --> 00:09:28.969 
在你的應用裏
可以按照自己的意願編碼

00:09:29.036 --> 00:09:30.204 
而且確實應該這樣做

00:09:30.270 --> 00:09:31.939 
但是也要看你需要什麼樣的動畫

00:09:33.507 --> 00:09:35.943 
在我的例子裏
它返回一個對象數據對象

00:09:36.276 --> 00:09:38.478 
它有局部空間到世界空間轉換和顏色

00:09:39.513 --> 00:09:43.283 
和之前一樣 把它複製到常量緩衝

00:09:48.722 --> 00:09:50.123 
看上去是這個樣子

00:09:50.624 --> 00:09:52.125 
幀數據已經準備完畢

00:09:55.996 --> 00:09:57.097 
還有別的數據

00:09:59.099 --> 00:10:01.635 
其他的數據 還有其他的

00:10:02.603 --> 00:10:05.439  
所有的數據都到位了 我們準備好渲染

00:10:05.939 --> 00:10:07.307 
但是不是還缺了點什麼？

00:10:10.377 --> 00:10:13.046 
確實缺了什麼
我想要提醒你們注意的是

00:10:13.113 --> 00:10:14.615 
我們有一個常量緩衝

00:10:14.815 --> 00:10:17.551 
我說過新建一個Metal緩衝
然後反覆使用

00:10:18.619 --> 00:10:19.753 
這樣做有一個問題

00:10:19.820 --> 00:10:23.724 
CPU和GPU實際上是
兩個不同的平行處理器

00:10:24.057 --> 00:10:26.693 
它們可以同時對同一內存進行讀寫

00:10:27.127 --> 00:10:28.562 
會發生什麼 如果有函數

00:10:28.629 --> 00:10:31.532 
正在讀一塊內存 而另外有函數在寫？

00:10:35.135 --> 00:10:36.236 
資源爭用

00:10:39.039 --> 00:10:40.407 
看上去有點像這樣

00:10:40.974 --> 00:10:43.911 
CPU準備好一個幀數據
寫入一個緩存

00:10:45.779 --> 00:10:47.447 
GPU開始處理

00:10:49.516 --> 00:10:50.717 
它從緩存裏讀取數據

00:10:51.385 --> 00:10:53.387 
而CPU對這一切一無所知

00:10:53.453 --> 00:10:55.422 
它決定 我要準備下一幀數據

00:10:55.489 --> 00:10:57.291 
然後它開始覆蓋相同的數據

00:10:59.526 --> 00:11:01.094 
現在結果變成未定義

00:11:01.161 --> 00:11:02.963 
我們不知道讀入了什麼

00:11:03.030 --> 00:11:05.832 
讀出什麼 或者寫入什麼
數據狀態會是什麼

00:11:08.769 --> 00:11:12.206 
所以認識到在Metal裏
這不是隱式處理 這點很重要

00:11:12.573 --> 00:11:16.543 
CPU和GPU可以隨意
同時寫同樣的數據

00:11:16.944 --> 00:11:18.779 
必須自己同步訪問權限

00:11:19.613 --> 00:11:22.049 
就好像編寫多線程的CPU代碼

00:11:22.649 --> 00:11:25.052 
必須得確保沒有踩到自己

00:11:28.388 --> 00:11:31.692 
這把我們帶到了
CPU-GPU同步的主題

00:11:32.259 --> 00:11:33.260 
讓我們從簡單的開始

00:11:35.195 --> 00:11:38.131 
最簡單的方法就是 等待

00:11:38.198 --> 00:11:40.367 
把指令提交給GPU之後

00:11:41.068 --> 00:11:43.036 
CPU繪圖函數做好所有的工作

00:11:43.103 --> 00:11:45.239 
提交指令 然後就坐在那兒等

00:11:45.305 --> 00:11:47.441 
直到它確保GPU的工作完成

00:11:48.709 --> 00:11:50.644 
這樣我們就知道永遠不會覆蓋

00:11:50.711 --> 00:11:53.981 
因爲我們試圖生產下一幀數據時
GPU是空閒的

00:11:55.115 --> 00:11:56.917 
這種做法不夠快 但很安全

00:11:57.284 --> 00:12:00.220 
所以需要有某種機制
讓GPU通知我們

00:12:00.287 --> 00:12:02.322 
嘿 我工作完成 你開始做你的吧

00:12:04.391 --> 00:12:06.660 
Metal提供了這種機制
以回調的形式

00:12:06.860 --> 00:12:09.596 
我們稱爲處理程序 其中兩種很有意思

00:12:10.697 --> 00:12:11.832 
“添加計劃處理程序”

00:12:12.266 --> 00:12:16.703 
當命令緩衝被計劃在GPU上運行時
將執行該處理程序

00:12:18.739 --> 00:12:22.075 
對我們來說 更有意思的是
“完成處理程序”

00:12:22.442 --> 00:12:23.577 
它將被調用

00:12:23.644 --> 00:12:26.246 
當GPU結束執行一個命令緩衝時

00:12:26.580 --> 00:12:28.615 
命令緩衝完全退休時

00:12:28.782 --> 00:12:31.952 
此時我們確定修改任何資源都是安全的

00:12:32.019 --> 00:12:33.120 
正在使用的任何資源

00:12:34.021 --> 00:12:34.922 
這樣非常完美

00:12:34.988 --> 00:12:37.057 
我們只需要採用某種方法告訴自己

00:12:37.124 --> 00:12:39.026 
嘿 我們完成了 繼續下一步

00:12:41.929 --> 00:12:44.665 
你們當中有多少人熟悉信號量的概念？

00:12:45.232 --> 00:12:46.133 
有誰知道？

00:12:47.034 --> 00:12:47.935 
很好

00:12:48.735 --> 00:12:50.270 
快速介紹一下信號量的背景

00:12:50.337 --> 00:12:51.638 
它們是同步基元

00:12:51.705 --> 00:12:54.575 
被用來控制有限資源的訪問權限

00:12:54.641 --> 00:12:56.076 
應用在此堪稱完美

00:12:56.510 --> 00:13:00.214 
我們有一個常量緩存
它是一個有限資源

00:13:00.280 --> 00:13:03.317 
我們將會新建一個信號量 初始值爲1

00:13:03.383 --> 00:13:04.918 
信號量的值代表

00:13:04.985 --> 00:13:06.653 
有多少想要保護的有限資源

00:13:08.589 --> 00:13:09.756 
新建一個信號量

00:13:09.823 --> 00:13:12.392 
它應該建立在渲染循環以外

00:13:13.360 --> 00:13:15.362 
一旦開始繪圖 第一件要做的事情

00:13:16.363 --> 00:13:17.698 
就是等待信號量

00:13:19.266 --> 00:13:21.168 
Apple裏的信號量
稱爲“等待”

00:13:21.235 --> 00:13:23.403 
有人稱它爲“佔據”
有人稱之爲“倒數”

00:13:23.470 --> 00:13:24.471 
無關緊要

00:13:24.838 --> 00:13:26.473 
理念就是等着它

00:13:26.540 --> 00:13:28.542 
把超時設置爲遙遠的未來

00:13:28.775 --> 00:13:30.644 
也就是說我們會永遠等待下去

00:13:30.744 --> 00:13:32.946 
如果沒有資源可用 線程會進入休眠

00:13:33.046 --> 00:13:34.381 
等着做點什麼

00:13:36.483 --> 00:13:37.484 
我們結束後

00:13:37.751 --> 00:13:40.120 
在完成處理程序裏 我們會通知信號量

00:13:41.021 --> 00:13:44.024 
那將會告訴我們 修改資源又安全了

00:13:45.092 --> 00:13:47.494 
工作已全部完成 可以進行下一步

00:13:50.397 --> 00:13:52.833 
這是一個有點幼稚的同步方法

00:13:52.900 --> 00:13:54.268 
看上去有點像這個樣子

00:13:55.335 --> 00:13:57.004 
我們會把幀數據0寫入緩衝

00:13:58.372 --> 00:14:01.041 
GPU從緩衝讀取

00:14:01.108 --> 00:14:02.276 
CPU將會等待

00:14:02.809 --> 00:14:05.212 
當GPU處理完幀數據0

00:14:05.279 --> 00:14:08.815 
它將發送完成處理程序
幀數據1開始工作

00:14:09.816 --> 00:14:11.685 
並將在CPU上新建一幀數據

00:14:12.953 --> 00:14:14.888 
GPU上會對其進行處理 依此類推

00:14:15.989 --> 00:14:19.193 
這種方法可行 但如你所見
有這麼多等待時間

00:14:19.726 --> 00:14:22.496 
CPU和GPU實際上都有
一半的時間處於空閒

00:14:22.896 --> 00:14:25.265 
看上去並沒有好好利用計算資源

00:14:27.568 --> 00:14:30.637 
我們想要做的是
重疊CPU和GPU的工作時間

00:14:31.338 --> 00:14:34.308 
這樣就可以利用系統固有的並行機制

00:14:35.008 --> 00:14:37.344 
但還是需要想辦法避免踩到數據

00:14:40.314 --> 00:14:42.716 
所以我們理想的工作量看上去是這樣

00:14:44.017 --> 00:14:47.521 
第0幀將會在CPU上做好準備
推到GPU

00:14:47.588 --> 00:14:49.256 
當GPU處理它時

00:14:49.323 --> 00:14:54.595 
CPU開始新建幀數據1 等等
反覆如此

00:14:56.597 --> 00:14:58.065 
在此謹記一點

00:14:58.632 --> 00:15:01.568 
CPU實際上要比GPU超前一點

00:15:01.768 --> 00:15:03.937 
請注意 當幀數據2在CPU上時

00:15:05.572 --> 00:15:07.574 
GPU上只有幀數據0是完成的

00:15:07.641 --> 00:15:08.609 
所以CPU有一點超前

00:15:08.675 --> 00:15:10.577 
也請你一直記住這點

00:15:12.446 --> 00:15:15.415 
來看看演示裏的解決方案
看我們是怎麼做的

00:15:16.683 --> 00:15:19.853  
我們想要重疊CPU和GPU
但我們知道無法做到

00:15:19.920 --> 00:15:21.722  
用一個常量緩衝 而不等待很長時間

00:15:21.989 --> 00:15:24.525  
所以解決方案是新建一個緩衝池

00:15:26.927 --> 00:15:28.228  
所以新建幀數據0

00:15:28.929 --> 00:15:30.197  
把它寫入一個緩衝

00:15:31.198 --> 00:15:32.332  
然後CPU開始工作

00:15:32.399 --> 00:15:35.235  
新建下一個幀數據 寫入另一個緩衝

00:15:36.336 --> 00:15:38.639  
此時 GPU可以自由從緩衝中讀取

00:15:38.705 --> 00:15:40.274  
之前的那個緩衝

00:15:41.742 --> 00:15:43.477  
我們沒有無限的緩衝

00:15:43.544 --> 00:15:45.078  
因爲沒有無限的內存

00:15:45.145 --> 00:15:46.647  
所以緩衝池必須得有個限額

00:15:47.047 --> 00:15:48.882  
在我們的應用中 我們選擇了3個

00:15:49.316 --> 00:15:51.151  
這部分你得自己決定

00:15:51.218 --> 00:15:52.486  
我們無法告訴你怎麼做

00:15:53.320 --> 00:15:55.856  
因爲要考慮延遲的問題

00:15:56.323 --> 00:15:57.858 
想要用多少內存

00:15:58.225 --> 00:16:00.894 
所以我們建議你測試自己的應用
瞭解多少是最合適的

00:16:01.929 --> 00:16:03.697 
本例中 我們選擇3個

00:16:06.033 --> 00:16:08.669 
在這裏 可以看到緩衝池用完了

00:16:08.735 --> 00:16:10.204 
我們準備好3幀數據

00:16:10.270 --> 00:16:11.805 
但GPU只處理完成了一幀

00:16:12.105 --> 00:16:13.207 
所以得等一會兒

00:16:15.609 --> 00:16:17.144 
現在 幀數據0已經完成

00:16:17.211 --> 00:16:20.747 
所以可再次使用池裏的緩衝 如此繼續

00:16:28.388 --> 00:16:29.590 
來看一下代碼

00:16:30.490 --> 00:16:32.492 
同步常量緩衝的訪問權限

00:16:32.759 --> 00:16:34.328 
我們已經有了一個信號量

00:16:34.394 --> 00:16:37.130 
它可以很好地控制有限資源的訪問權限

00:16:37.197 --> 00:16:38.565 
在本例中 我們的限制是3

00:16:39.099 --> 00:16:40.234 
但這個數字可隨意設定

00:16:41.335 --> 00:16:43.637 
在這裏按照限制數字
新建了一個信號量

00:16:44.605 --> 00:16:46.673 
我們不再只新建一個常量緩衝

00:16:46.740 --> 00:16:48.041 
而是新建一個緩衝數組

00:16:50.344 --> 00:16:51.278 
最後

00:16:52.179 --> 00:16:53.380 
需要一個索引

00:16:53.847 --> 00:16:55.516 
我們用這個索引表示

00:16:55.582 --> 00:16:57.851 
當前可用的常量緩衝數

00:16:58.318 --> 00:17:00.521 
我們可以遍歷數組並回返

00:17:00.587 --> 00:17:03.123 
信號量會控制我們的訪問權限
和保護我們

00:17:07.227 --> 00:17:10.364 
所以在繪圖函數裏
我們會立即等待信號量

00:17:11.031 --> 00:17:12.900 
如果沒有可用緩衝 就進入休眠

00:17:14.101 --> 00:17:15.903 
一旦取得信號量 就開始工作

00:17:15.969 --> 00:17:18.204 
我們知道獲取當前的
常量緩衝是安全的

00:17:18.906 --> 00:17:22.108 
在索引中 “當前常量緩衝”
記錄哪個資源可用

00:17:23.710 --> 00:17:26.413 
然後正常填寫幀數據 編碼所有命令

00:17:26.480 --> 00:17:29.283 
進行更新 添加完成處理程序

00:17:30.751 --> 00:17:33.320 
然後我們通知信號量
說嘿 該幀數據處理完了

00:17:33.554 --> 00:17:34.488 
你可以進行下一步了

00:17:35.522 --> 00:17:38.225 
最後要做的是更新索引

00:17:39.293 --> 00:17:41.562 
我們加上1 我們取模進行環繞

00:17:42.196 --> 00:17:44.364 
我們不用擔心覆蓋自身

00:17:44.431 --> 00:17:45.899 
因爲信號量會保護我們

00:17:48.802 --> 00:17:50.437 
這就是演示中的常量緩衝

00:17:51.138 --> 00:17:52.940 
演示裏有一個3個緩衝的數列

00:17:53.407 --> 00:17:55.509 
但我也看過有些應用會跟蹤緩衝

00:17:55.576 --> 00:17:59.079 
把它們標記爲
該緩衝正在被幀數據7讀取

00:17:59.146 --> 00:18:00.881 
該緩衝正在被幀數據5寫入

00:18:01.215 --> 00:18:03.317 
在本模式下 我們不需要這麼做

00:18:03.383 --> 00:18:05.819 
信號量爲你做所有同步的工作

00:18:06.987 --> 00:18:08.355 
而且如果你取得了信號量

00:18:08.422 --> 00:18:11.158 
你可以確認最後正在使用
該資源的幀數據已經結束

00:18:11.225 --> 00:18:12.426 
否則你還會處於休眠

00:18:14.728 --> 00:18:17.698 
所以現在數據都已經準備好
並且受到保護

00:18:19.533 --> 00:18:22.169 
我們想要發出一些繪圖調用

00:18:22.236 --> 00:18:23.570 
在屏幕上顯示一些圖像

00:18:27.140 --> 00:18:29.510 
這就是本演示的基本渲染循環

00:18:30.911 --> 00:18:33.547 
我們有兩個通路：
一個通路繪製陰影映射

00:18:33.981 --> 00:18:35.549 
一個通路讀取該陰影映射

00:18:36.016 --> 00:18:38.852 
我們決定把它們分成
兩個獨立的命令緩衝

00:18:39.319 --> 00:18:40.554 
這樣做有一個很好的理由

00:18:40.921 --> 00:18:43.123 
它讓我們有兩個編碼函數

00:18:43.190 --> 00:18:44.591 
是獨立和唯一的

00:18:45.025 --> 00:18:46.493 
它們不依賴於彼此

00:18:46.793 --> 00:18:49.229 
你編碼陰影通路 你把它傳到命令緩衝

00:18:49.296 --> 00:18:51.498 
以及你已經填寫的常量緩衝

00:18:51.932 --> 00:18:54.501 
它會編碼所有的命令 渲染陰影映射

00:18:55.302 --> 00:18:58.272 
然後你有了一個獨立的編碼函數
可以編碼主通路

00:18:58.338 --> 00:19:00.908 
把它傳到主命令緩衝
以及其他所需數據

00:19:00.974 --> 00:19:02.643 
編碼所有其他的命令

00:19:03.410 --> 00:19:04.878 
編碼結束時

00:19:05.145 --> 00:19:07.748 
調用提交兩個命令緩衝

00:19:07.981 --> 00:19:10.384 
輸出 幀數據處理完畢

00:19:14.221 --> 00:19:17.291 
那麼 如何真正編碼繪製
其中一個立方體？

00:19:17.791 --> 00:19:20.561 
我們需要一組數據
而不僅僅是旋轉數據

00:19:21.295 --> 00:19:23.330 
我們需要立方體的一些幾何數據

00:19:23.530 --> 00:19:24.898 
這非常簡單 你知道

00:19:24.965 --> 00:19:27.968 
把立方體想成是8個頂點
也許還有一個索引緩衝

00:19:29.102 --> 00:19:32.239 
在本例中 我們不需要任何複雜的材料

00:19:32.306 --> 00:19:33.974 
只需用到很簡單的漫反射着色

00:19:34.408 --> 00:19:36.777 
因此我們可以重複使用管道狀態對象

00:19:36.844 --> 00:19:38.011 
在所有立方體範圍內

00:19:39.046 --> 00:19:40.681 
我們之前提到過每幀數據

00:19:40.747 --> 00:19:41.915 
我們需要它的一份副本

00:19:42.282 --> 00:19:44.117 
我們更新它 準備好

00:19:44.818 --> 00:19:46.687 
當然我們還需要 每光學數據

00:19:47.020 --> 00:19:50.457 
以及我們動畫裏展示
的 LocalToWorld和顏色信息

00:19:52.559 --> 00:19:54.094 
所以當發出繪圖調用時

00:19:54.895 --> 00:19:56.663 
我們想確保引用了正確的數據

00:19:57.364 --> 00:19:59.433 
所以編碼器會產生命令

00:19:59.499 --> 00:20:00.801 
把它們放入命令緩衝

00:20:01.168 --> 00:20:02.236 
繪圖調用0

00:20:02.302 --> 00:20:05.873 
將會引用幀數據和我們感興趣的對象

00:20:06.907 --> 00:20:09.576 
繪圖調用1 同樣 將會引用幀數據

00:20:10.410 --> 00:20:12.913 
和對象1數據 依此類推

00:20:14.248 --> 00:20:15.349 
這樣一切都會準備好

00:20:15.415 --> 00:20:18.452 
發出調用 GPU開始處理

00:20:20.888 --> 00:20:22.756 
現在我們有很多調用要發出

00:20:22.923 --> 00:20:25.526 
你知道 在演示中 至少有1萬個

00:20:26.360 --> 00:20:28.629 
我們想盡可能高效地發出調用

00:20:29.530 --> 00:20:31.632 
我們想避免重複的工作

00:20:31.698 --> 00:20:33.667 
不想每一次繪製就進行重設

00:20:33.967 --> 00:20:37.371 
所有共享資源 幾何 管道狀態

00:20:37.504 --> 00:20:40.140 
我們只想設一次 然後保持

00:20:40.974 --> 00:20:42.843 
這樣就可以避免重複的狀態更新

00:20:43.143 --> 00:20:45.045 
並且避免重複的變量表格更新

00:20:46.146 --> 00:20:48.315 
還有一點值得注意

00:20:48.382 --> 00:20:51.151 
頂點和片段變量表是完全分開的

00:20:52.052 --> 00:20:54.021 
你可以將緩衝綁定在頂點階段

00:20:54.087 --> 00:20:55.989 
而不是片段階段 反之同理

00:20:56.590 --> 00:20:58.325 
但若必須要把所有綁定到兩個階段

00:20:58.392 --> 00:21:02.062 
調用“設置頂點緩衝”函數時
可能會調用兩次

00:21:02.129 --> 00:21:03.564 
“設置片段緩衝”函數也是如此

00:21:03.630 --> 00:21:06.633 
這就是爲什麼在本例
沒有使用“設置頂點字節”函數

00:21:07.267 --> 00:21:09.803 
你可以想像
我們有50,000個對象

00:21:10.137 --> 00:21:12.973 
必須把所有那些數據複製兩遍

00:21:13.040 --> 00:21:15.342 
一遍在頂點階段 一遍在片段階段

00:21:15.576 --> 00:21:16.810 
很快工作量會變得很大

00:21:17.678 --> 00:21:19.847 
而如果把所有數據放入一個緩衝
只需引用它

00:21:19.913 --> 00:21:21.181 
我們就不用擔心該問題了

00:21:22.182 --> 00:21:23.884 
最後我想指出的是

00:21:24.718 --> 00:21:25.919 
使用新函數

00:21:26.887 --> 00:21:30.224 
“設置頂點緩衝偏移”和
“設置片段緩衝偏移”

00:21:31.091 --> 00:21:34.328 
這只是把指針指向其中一個緩衝

00:21:36.830 --> 00:21:38.699 
可以看到 在調用這些函數時

00:21:38.765 --> 00:21:41.034 
它們並沒有把引用放入Metal緩衝

00:21:41.401 --> 00:21:44.438 
它們只取出了一個偏移和一個索引

00:21:45.072 --> 00:21:48.375 
因爲你肯定已經設置該指針指向緩衝

00:21:48.876 --> 00:21:50.677 
這樣緩衝內部的指針也隨之改變

00:21:50.944 --> 00:21:52.279 
這就是我們想要實現的

00:21:52.713 --> 00:21:55.282 
我們有一個常量緩衝 正在遍歷

00:21:55.782 --> 00:21:57.451 
所以可以在一開始只設置一次

00:21:57.918 --> 00:22:00.988 
然後每一次繪製時
就調用“設置頂點緩衝偏移”函數

00:22:01.488 --> 00:22:04.458 
並且把下一個繪圖調用
指向緩衝中正確的位置

00:22:05.092 --> 00:22:06.460 
看上去有點像這樣

00:22:07.294 --> 00:22:08.762 
綁定該常量緩衝

00:22:09.329 --> 00:22:11.164 
然後調用“設置頂點緩衝偏移”函數

00:22:12.199 --> 00:22:13.200 
用該偏移量作爲參數

00:22:14.601 --> 00:22:16.937 
然後再次調用 繼續往前

00:22:18.238 --> 00:22:19.606 
再一次往前

00:22:20.274 --> 00:22:22.809 
我們並沒有修改該索引指定的緩衝

00:22:22.943 --> 00:22:24.945 
我們只是修改了緩衝裏的偏移值

00:22:28.148 --> 00:22:29.683 
記住這些原則

00:22:29.750 --> 00:22:31.585 
編碼其實非常簡單

00:22:33.654 --> 00:22:35.289 
可以事先設置好一組數據

00:22:35.589 --> 00:22:37.524 
每幀常量是很顯然的

00:22:37.591 --> 00:22:39.059 
因爲我們知道會修改它

00:22:39.126 --> 00:22:40.027 
所以一起來設置

00:22:41.395 --> 00:22:44.698 
我們將一次設定常量緩衝
因爲它必須要準備好

00:22:44.765 --> 00:22:47.267 
我們才能使用設置頂點緩衝偏移函數

00:22:49.102 --> 00:22:51.705 
還會設置幾何緩衝 和管道狀態

00:22:51.772 --> 00:22:53.874 
我們知道整個立方體範圍內
它們是共享的

00:22:55.609 --> 00:22:58.512 
然後終於可以開始循環
通過想要繪製的對象

00:22:59.980 --> 00:23:01.982 
設置當前繪圖調用

00:23:02.049 --> 00:23:02.916 
常量緩衝的偏移值

00:23:05.052 --> 00:23:06.420 
然後我們真正開始繪圖

00:23:11.325 --> 00:23:14.061 
這裏是 "編碼主要通路"
函數的代碼

00:23:14.261 --> 00:23:15.095 
在例子裏的

00:23:16.463 --> 00:23:18.432 
首先設置頂點緩衝

00:23:18.498 --> 00:23:20.901 
那是幾何和渲染管道狀態

00:23:21.235 --> 00:23:22.870 
也就是光照陰影管道

00:23:25.138 --> 00:23:26.373 
我們將會設置常量緩衝

00:23:26.440 --> 00:23:28.408 
在之後調用
“設置頂點緩衝偏移”函數

00:23:28.575 --> 00:23:32.179 
在本例中把它傳給頂點和片段階段

00:23:34.715 --> 00:23:36.116 
然後設置每幀數據

00:23:38.352 --> 00:23:40.287 
你現在看到
我已設置了一個常量緩衝

00:23:40.354 --> 00:23:43.323 
有兩個分開的索引 和不同的偏移

00:23:43.390 --> 00:23:45.225 
Metal允許你隨意這樣做

00:23:45.826 --> 00:23:48.529 
可以把同樣的常量緩衝設給每一個索引

00:23:48.595 --> 00:23:51.231 
帶有不同的偏移 如果你願意的話
完全取決於你

00:23:54.001 --> 00:23:55.502 
接下來馬上看看緩衝池

00:23:56.436 --> 00:23:59.106 
我們需要追蹤偏移 因爲我們不是

00:23:59.173 --> 00:24:00.774 
在常量緩衝的開始部分開始的

00:24:00.841 --> 00:24:02.142 
還有一些幀數據在那裏

00:24:02.609 --> 00:24:04.945 
所以偏移將會被推回 經過幀數據

00:24:06.747 --> 00:24:09.950 
然後將調用“設置頂點緩衝偏移”
及“設置片段緩衝偏移”函數

00:24:10.884 --> 00:24:13.687 
來把該繪圖調用指向要繪製的正確數據

00:24:15.422 --> 00:24:16.623 
發出繪圖調用

00:24:17.357 --> 00:24:22.095 
然後再次設置偏移 一次完成一個對象

00:24:25.065 --> 00:24:26.400 
繪圖都準備好了

00:24:27.301 --> 00:24:28.569 
這仍然是非常線性

00:24:28.669 --> 00:24:30.304 
我答應做一些多線程編程

00:24:30.671 --> 00:24:31.972 
並且Warren提過

00:24:32.039 --> 00:24:34.208 
可以在Metal裏進行平行編碼

00:24:34.808 --> 00:24:36.009 
該怎麼做？

00:24:37.244 --> 00:24:38.912 
一個理想框架看上應該是這樣

00:24:38.979 --> 00:24:41.982 
渲染線程正在埋頭苦幹
然後它意識到 嘿

00:24:42.049 --> 00:24:44.518 
我得渲染一個陰影映射
還得渲染一個主通路

00:24:44.885 --> 00:24:46.587 
要是我能並行編碼就好了

00:24:47.087 --> 00:24:48.555 
我有很多CPU

00:24:49.056 --> 00:24:52.059 
如果能調度一些工作出去
進行一些編碼

00:24:53.227 --> 00:24:54.795 
然後回來繼續參與渲染線程

00:24:54.862 --> 00:24:57.497 
然後渲染線程把它推給GPU

00:24:57.564 --> 00:24:58.665 
讓GPU做接下來的工作

00:24:58.966 --> 00:24:59.933 
這種方法一定非常好

00:25:03.570 --> 00:25:05.572 
你們中有多少人
用過GCD（大中央調度）？

00:25:07.040 --> 00:25:09.076 
此時非常適合使用大中央調度

00:25:09.142 --> 00:25:12.813 
大中央調度是
Apple的多處理API

00:25:13.280 --> 00:25:15.282 
該API讓你新建隊列

00:25:15.782 --> 00:25:17.818 
這些隊列管理計算資源

00:25:18.252 --> 00:25:19.152 
在你的機器上

00:25:19.720 --> 00:25:21.188 
可以新建兩種類型的隊列

00:25:21.655 --> 00:25:22.823 
一種是串行隊列

00:25:23.357 --> 00:25:25.192 
當你通過串行隊列調度工作時

00:25:25.259 --> 00:25:27.594 
可以保證所有工作都按照順序處理

00:25:28.629 --> 00:25:31.832 
但對我們來說更有意思的是併發隊列

00:25:32.833 --> 00:25:34.701 
當你把工作調度給併發隊列

00:25:35.102 --> 00:25:36.537 
大中央調度會查看系統

00:25:36.603 --> 00:25:38.539 
爲你做出最好的安排

00:25:39.273 --> 00:25:40.107 
這非常完美

00:25:40.174 --> 00:25:42.109 
我們有兩個需要並行的作業

00:25:42.809 --> 00:25:45.812 
所以我們新建這一個隊列
把工作推送給它

00:25:46.213 --> 00:25:47.247 
它會幫我完成

00:25:48.515 --> 00:25:51.084 
有另一個對象你想新建一次
並可以重複使用

00:25:51.518 --> 00:25:53.754 
這裏是一些新建併發調度隊列的代碼

00:25:54.254 --> 00:25:55.789 
你應該始終爲隊列加上標籤

00:25:55.856 --> 00:25:57.925 
在此我使用了
非常具有創造性的標籤隊列

00:25:58.592 --> 00:25:59.993 
但你也許想稱呼它別的名稱

00:26:03.730 --> 00:26:05.499 
所以我們修改了部分代碼

00:26:06.533 --> 00:26:08.468 
一開始還是新建命令緩衝

00:26:09.870 --> 00:26:13.440 
但是既然我們如此聰明
會使用兩個命令緩衝

00:26:13.674 --> 00:26:16.577 
並把編碼函數分成兩個不同的函數

00:26:16.777 --> 00:26:19.379 
我們除了調度工作外
沒什麼別的事情可做

00:26:20.480 --> 00:26:22.115 
所以dispatchQueue.async

00:26:22.549 --> 00:26:25.519 
是大中央調度中用來調度工作的主調用

00:26:25.853 --> 00:26:27.154 
這是一個異步調用

00:26:27.554 --> 00:26:30.357 
它將推送工作 線程將會繼續

00:26:31.425 --> 00:26:34.294 
在這裏我們調度了陰影通路

00:26:36.163 --> 00:26:37.598 
然後我們調度了主通路

00:26:39.299 --> 00:26:40.934 
我們得想辦法提交該工作

00:26:41.535 --> 00:26:43.203 
所以我們調用“調度障礙同步”

00:26:43.837 --> 00:26:47.007 
這將確保此時所有的工作都已經完成

00:26:48.675 --> 00:26:52.012 
最終我們重新加入 提交工作

00:26:52.779 --> 00:26:54.281 
在這裏 順序是很重要的

00:26:54.882 --> 00:26:57.417 
陰影映射必須在我們要引用的時候完成

00:26:57.885 --> 00:27:00.187 
所以必須首先提交陰影命令緩衝

00:27:00.554 --> 00:27:02.122 
之後是主命令緩衝

00:27:04.892 --> 00:27:06.593 
在這裏我還想提出一點

00:27:07.427 --> 00:27:09.630 
你們之中有多少人熟悉“閉包”的概念

00:27:12.232 --> 00:27:13.066 
很好

00:27:13.300 --> 00:27:16.737 
有多少人曾經在閉包捕獲自身時
遇到過問題

00:27:16.904 --> 00:27:18.839 
你以爲自己在引用別的？

00:27:20.507 --> 00:27:22.142 
你們可誠實作答
我們都會發生

00:27:22.943 --> 00:27:24.311 
我只是想提出這一點

00:27:24.478 --> 00:27:25.846 
閉包捕獲自身

00:27:25.913 --> 00:27:29.349 
如果你正在引用一個成員變量
或其中的成員變量

00:27:29.616 --> 00:27:32.019 
而你並沒明確指定self.iVar

00:27:32.286 --> 00:27:34.555 
它還是會引用那個變量

00:27:35.122 --> 00:27:38.792 
如果你想確保引用正確的數據

00:27:39.493 --> 00:27:43.263 
在外部捕獲它是一個好方法
我將會馬上對此進行演示

00:27:45.732 --> 00:27:47.734 
這兩樣東西做的事情不一樣

00:27:48.468 --> 00:27:50.604 
第一個調用中 編碼陰影通路的地方

00:27:50.671 --> 00:27:52.639 
可以看到正在獲取的常量緩衝

00:27:52.706 --> 00:27:55.142 
獨立於self.constantBufferSlot之外

00:27:55.843 --> 00:27:58.745 
我實際上並不知道它執行時會怎麼樣

00:27:59.046 --> 00:28:00.747 
這是真正的異步編程

00:28:00.814 --> 00:28:04.017 
所以當調度正在運行時

00:28:04.351 --> 00:28:05.786 
它已經揹着我發生了改變

00:28:06.386 --> 00:28:08.989 
也許是對的 也許不對 我無法保證

00:28:13.260 --> 00:28:15.195 
所以請謹記這點 不要那樣做

00:28:16.029 --> 00:28:17.865 
相反 我們想捕捉一個引用

00:28:17.931 --> 00:28:19.600 
到我們感興趣的常量緩衝中

00:28:20.167 --> 00:28:22.135 
所以在這裏 取出常量緩衝

00:28:22.536 --> 00:28:23.770 
把它從數列裏拿出去

00:28:24.972 --> 00:28:26.607 
然後再發出調度

00:28:26.974 --> 00:28:29.510 
引用已經獲取的緩衝

00:28:29.576 --> 00:28:32.379 
這樣就能保證
確切知道讀取的是哪個數據

00:28:37.651 --> 00:28:39.052 
這就是多線程編程的趣味

00:28:39.553 --> 00:28:41.555 
示例中的實際代碼看上去是這樣

00:28:42.956 --> 00:28:44.391 
捕捉常量緩衝

00:28:46.593 --> 00:28:50.297 
當使用它時 保證用的是正確的那個

00:28:50.364 --> 00:28:51.798 
是已經捕捉的那個

00:28:52.399 --> 00:28:54.268 
知道正在使用該幀數據的常量緩衝

00:28:56.003 --> 00:28:58.539 
我之前提過“排序”以及它非常重要

00:29:00.007 --> 00:29:02.242 
當新建一個命令緩衝 提交

00:29:03.043 --> 00:29:05.312 
GPU上執行的順序

00:29:06.480 --> 00:29:08.348 
通過你提交到GPU上的順序來表示

00:29:08.415 --> 00:29:10.617 
所以如果先提交陰影命令緩衝

00:29:10.684 --> 00:29:12.286 
再提交主命令緩衝

00:29:12.553 --> 00:29:15.722 
可以確保在GPU先執行陰影

00:29:15.789 --> 00:29:17.457 
接着再執行主命令緩衝

00:29:17.758 --> 00:29:20.294 
有時我們把這稱爲 隱式命令緩衝排序

00:29:22.529 --> 00:29:24.565 
但是可以變得顯式一點

00:29:25.766 --> 00:29:27.634 
Metal提供了“排隊”函數

00:29:27.701 --> 00:29:29.436 
強制執行命令緩衝排序

00:29:30.237 --> 00:29:32.806 
如果有一組命令緩衝 可以把它們排隊

00:29:33.207 --> 00:29:35.242 
這樣可以確保它們按照那個順序被執行

00:29:35.309 --> 00:29:37.611 
不論提交方法和提交時間

00:29:38.579 --> 00:29:40.681 
這是非常酷的方法 因爲它允許你

00:29:40.747 --> 00:29:43.383 
從多重線程上提交命令緩衝
按任何順序

00:29:44.017 --> 00:29:45.285 
而你完全不用爲此操心

00:29:45.619 --> 00:29:48.422 
運行時將會確保運行順序是正確的

00:29:49.890 --> 00:29:51.658 
我們來看看如何在代碼裏實現

00:29:52.926 --> 00:29:54.127 
新加了一些內容

00:29:54.561 --> 00:29:56.163 
當新建命令緩衝時

00:29:56.230 --> 00:29:57.898 
馬上按照順序把它們排隊

00:29:58.265 --> 00:29:59.266 
順序很重要

00:29:59.333 --> 00:30:02.035 
所以我們還是會讓陰影命令緩衝先排隊

00:30:02.536 --> 00:30:03.904 
然後是主命令緩衝

00:30:05.572 --> 00:30:06.907 
但是現在 當我們調度時

00:30:07.241 --> 00:30:09.810 
我們可以從別的線程上提交

00:30:10.277 --> 00:30:12.112 
再次強調 運行時候將會確保

00:30:12.980 --> 00:30:13.814 
順序正確

00:30:13.881 --> 00:30:15.616 
所以我們不用爲此擔心

00:30:16.316 --> 00:30:19.052 
這實際上移除了之前的障礙

00:30:19.286 --> 00:30:22.155 
因爲不必重新加入 再提交命令緩衝了

00:30:22.222 --> 00:30:23.724 
它們已經自己提交了

00:30:26.527 --> 00:30:28.962 
我似乎跳過了所有的同步內容

00:30:29.029 --> 00:30:30.297 
不久前我剛說起過

00:30:30.764 --> 00:30:32.466 
我們還是需要了解 因爲我們還是

00:30:32.533 --> 00:30:34.268 
會自我覆蓋 如果我們不同步的話

00:30:34.801 --> 00:30:37.604 
所以能否把同樣的同步原理

00:30:37.938 --> 00:30:39.840 
應用到這個多線程世界？

00:30:42.109 --> 00:30:45.112 
答案是可以 並且實際上它非常直觀

00:30:46.180 --> 00:30:49.349 
回到友善的信號量 還有常量緩衝數列

00:30:49.416 --> 00:30:51.652 
記住取出你想要的正確緩衝

00:30:52.819 --> 00:30:56.123 
一開始 等待信號量
如果沒有可用緩衝就進入休眠

00:30:57.457 --> 00:31:01.662 
我們已用排隊強制執行了順序 推出去

00:31:03.430 --> 00:31:07.067 
我們知道 主命令緩衝是
框架裏最後的命令緩衝

00:31:07.768 --> 00:31:10.470 
且我們知道要通知幀數據已經處理完畢

00:31:11.171 --> 00:31:14.575 
所以應把完成處理程序加到主命令緩衝

00:31:14.641 --> 00:31:16.944 
可以在調度內部完成

00:31:18.579 --> 00:31:20.914 
主命令緩衝是最終命令緩衝

00:31:20.981 --> 00:31:24.017 
我們爲它添加上完成處理程序
用來通知信號量

00:31:24.084 --> 00:31:27.054 
在調度內部提交它 如之前所做的那樣

00:31:28.121 --> 00:31:31.124 
現在你可能注意到
我引用self.semaphore

00:31:31.391 --> 00:31:33.527 
不久前我剛告訴你要注意這點

00:31:33.961 --> 00:31:34.995 
所以發生了什麼？

00:31:35.596 --> 00:31:38.665 
結果是信號量是一個同步圖元

00:31:39.233 --> 00:31:41.502 
我們確實想要用同一個

00:31:41.568 --> 00:31:42.836 
和所有其他線程一樣

00:31:43.403 --> 00:31:45.172 
所以需要知道信號量的值

00:31:45.239 --> 00:31:46.907 
在線程正在執行的時候

00:31:48.141 --> 00:31:50.944 
所以在本例中確實
需要self.semaphore

00:31:51.011 --> 00:31:52.679 
需要時刻注意

00:31:56.283 --> 00:31:58.585 
這是渲染的方法

00:31:59.419 --> 00:32:02.122 
在渲染函數的開始 等待信號量

00:32:03.390 --> 00:32:05.192 
選擇併發常量緩衝

00:32:06.426 --> 00:32:08.462 
把數據寫入常量緩衝

00:32:08.529 --> 00:32:10.697 
也代表了所有的對象

00:32:11.565 --> 00:32:13.767 
把命令編碼到命令緩衝

00:32:13.834 --> 00:32:16.937 
可以單線程編碼
也可以多線程 隨你所願

00:32:17.704 --> 00:32:20.641 
在最終命令緩衝裏
加上一個完成處理程序

00:32:21.008 --> 00:32:24.344 
用它來通知信號量 完成時通知我們

00:32:24.945 --> 00:32:26.513 
然後提交命令緩衝

00:32:27.548 --> 00:32:29.183 
GPU接過所有

00:32:29.249 --> 00:32:31.018 
開始處理幀數據

00:32:33.020 --> 00:32:35.289 
我們再看看演示 看看最後呈現結果

00:32:38.892 --> 00:32:42.362  
可以看到在左上角
這是單線程編碼模式

00:32:42.429 --> 00:32:44.998  
可以看出正在進行
多少繪圖調用 10,000個

00:32:45.732 --> 00:32:49.303  
右上角 可以看到編碼
一個幀數據的時間

00:32:50.137 --> 00:32:51.939  
我們看到是5毫秒

00:32:53.540 --> 00:32:55.342  
我們可以增加繪圖的數量

00:32:55.876 --> 00:32:58.846  
繪製的東西越多 時間越長

00:33:00.113 --> 00:33:01.648  
這就是單線程模式

00:33:01.715 --> 00:33:04.718  
你們想想看 我們在繪製一個陰影映射

00:33:04.785 --> 00:33:09.056 
也就是說必須在陰影映射內
發出40,000個繪圖

00:33:09.323 --> 00:33:11.325 
當繪製主通路時
意味着我們必須再發出

00:33:11.391 --> 00:33:14.328 
另外的40,000個繪圖來引用

00:33:15.729 --> 00:33:17.531 
但是再次強調 我們可以併發操作

00:33:17.598 --> 00:33:19.566 
所以在演示裏 加了一個並行模式

00:33:22.236 --> 00:33:24.137  
可以看到速度有多麼快

00:33:25.873 --> 00:33:27.574  
看一看正在發生的一切

00:33:29.176 --> 00:33:30.444  
你可再讓它們飛起來一點

00:33:36.650 --> 00:33:40.654  
在這裏 我們有4萬個立方體
獨一無二 各自分離

00:33:40.721 --> 00:33:41.889  
它們隨時都在更新

00:33:42.689 --> 00:33:46.093  
我們使用大中央調度
並行編碼了許多內容

00:33:47.294 --> 00:33:48.262  
我們有兩個命令緩衝

00:33:48.328 --> 00:33:50.364  
一個產生地上的陰影地圖

00:33:50.898 --> 00:33:52.733  
一個爲所有的立方體渲染上色

00:33:54.268 --> 00:33:57.237  
光照很簡單 即漫反射着色 基本上是

00:33:57.304 --> 00:33:59.973  
沃倫之前說過的N.L光照

00:34:02.976 --> 00:34:03.977  
這就是我們的演示內容

00:34:04.044 --> 00:34:06.713  
這些都會作爲示例代碼 供大家參考

00:34:07.214 --> 00:34:09.483  
希望你們可以把它拆開
取得其中的一些想法

00:34:09.550 --> 00:34:11.685  
和思路
並且能夠應用到自己的代碼當中

00:34:12.686 --> 00:34:14.087 
所以我們今天講了什麼？

00:34:15.455 --> 00:34:16.723 
你們走進來的時候

00:34:16.889 --> 00:34:18.625 
希望你們也聽過沃倫的演講

00:34:18.692 --> 00:34:20.226 
可能稍微瞭解一點圖形的知識

00:34:20.293 --> 00:34:22.161 
或者以前有相關編程經驗

00:34:22.795 --> 00:34:25.098 
但帶你們一起了解了
Metal裏的一切

00:34:25.966 --> 00:34:29.069 
Metal的概念性的概覽
它的相關原理

00:34:29.402 --> 00:34:32.438 
是運用API 和硬件相近的API

00:34:32.505 --> 00:34:33.639 
及和驅動相近的API

00:34:35.007 --> 00:34:36.610 
我們學習了Metal設備

00:34:36.677 --> 00:34:39.313 
即Metal的根對象
也是一切的來源

00:34:41.047 --> 00:34:42.783 
稍微討論了加載數據到Metal

00:34:42.850 --> 00:34:45.719 
以及不同的資源類型 和如何使用它們

00:34:46.719 --> 00:34:49.556 
Metal着色語言 即C++的變體

00:34:49.623 --> 00:34:51.024 
可以在GPU上編程

00:34:52.592 --> 00:34:54.494 
我們討論了建立管道狀態

00:34:54.561 --> 00:34:58.565 
事先驗證過的對象 包含兩種函數

00:34:58.632 --> 00:35:00.834 
頂點或片段 或某個計算函數

00:35:01.235 --> 00:35:03.437  
和其他在預先驗證狀態的對象

00:35:03.504 --> 00:35:04.872  
能在運行時節省時間

00:35:05.973 --> 00:35:07.875  
然後我們討論了發出GPU命令

00:35:07.941 --> 00:35:11.178  
創建Metal隊列
創建該隊列的命令緩衝

00:35:11.745 --> 00:35:14.114  
還有創建編碼器填入命令緩衝

00:35:15.215 --> 00:35:17.718  
然後該工作發送給GPU

00:35:18.485 --> 00:35:20.754 
我們帶你瞭解了動畫和紋理

00:35:20.988 --> 00:35:24.091 
以及使用設置頂點字節 發送小位數據

00:35:24.157 --> 00:35:25.325 
以支持動畫效果

00:35:26.994 --> 00:35:28.795 
之後當小位數據不夠時

00:35:28.862 --> 00:35:31.532 
我們講解了管理大批量動態數據

00:35:31.598 --> 00:35:35.102 
使用一個大常量緩衝
以及在不同的地方對其進行引用

00:35:35.402 --> 00:35:38.038 
在系統外反覆使用數據

00:35:38.872 --> 00:35:42.976 
我們討論了CPU-GPU同步
以及確保

00:35:43.043 --> 00:35:45.279 
CPU和GPU不彼此覆蓋

00:35:45.746 --> 00:35:46.880 
及互相協作的重要性

00:35:47.681 --> 00:35:48.849 
最後

00:35:48.916 --> 00:35:51.285 
我們討論了一點關於多線程編碼的內容

00:35:51.351 --> 00:35:55.289 
你如何利用Metal的大中央調度
編碼多命令緩衝

00:35:55.355 --> 00:35:57.090 
同時編碼隊列中的所有緩衝

00:35:59.092 --> 00:36:00.494 
這就是採用Metal技術

00:36:01.028 --> 00:36:02.129 
希望你喜歡本次講座

00:36:02.196 --> 00:36:03.931 
也希望你把其中一部分
應用到自己的應用裏

00:36:03.997 --> 00:36:05.532 
讓應用變得比現在更好

00:36:06.934 --> 00:36:10.504 
如果想了解更多信息 可以訪問網站

00:36:11.104 --> 00:36:14.308 
developer.apple.com/wwdc/603

00:36:15.843 --> 00:36:18.912 
明天我們還有更多的演講
我大力鼓勵你們能夠參與

00:36:19.112 --> 00:36:21.682 
上午11點
有“Metal的新特性 第一部分”

00:36:22.115 --> 00:36:25.252 
晚些 下午1點40分
有“Metal的新特性 第二部分”

00:36:25.319 --> 00:36:27.921 
這兩個講座將告訴我們
Metal世界裏所有新特性

00:36:27.988 --> 00:36:30.524 
你可在應用里加入很棒的內容
讓應用更優秀

00:36:31.491 --> 00:36:34.194 
之後 爲了你們當中的着色狂人

00:36:34.261 --> 00:36:37.231 
下午3點
有“高級Metal着色器優化”演講

00:36:37.698 --> 00:36:39.533 
如果你想知道如何更好地利用着色器

00:36:39.600 --> 00:36:41.768 
我建議你們參與該話題
非常棒的演講

00:36:42.836 --> 00:36:44.471 
感謝你們前來聽我們的講座

00:36:44.538 --> 00:36:47.174 
歡迎來到全球開發者大會
希望你們剩下幾天過得愉快

00:36:47.908 --> 00:36:48.809 
再次感謝