00:00:19.386 --> 00:00:22.055
在Instruments中
使用時間分析器

00:00:22.122 --> 00:00:24.925
早點分析 經常分析

00:00:26.627 --> 00:00:27.794
下午好

00:00:28.762 --> 00:00:29.963
我叫Kris Markel

00:00:30.030 --> 00:00:32.198
我是Apple性能工具團隊的工程師

00:00:32.266 --> 00:00:35.903
今天我們談談
在Instruments中使用時間分析器

00:00:36.803 --> 00:00:37.938
這是我們的議題

00:00:38.005 --> 00:00:40.507
我們要從分析開始講

00:00:40.574 --> 00:00:41.875
分析是什麼及如何使用它

00:00:41.942 --> 00:00:43.177
然後我要演示一個示例

00:00:43.243 --> 00:00:46.647
使應用的速度更快 工作量更少

00:00:46.713 --> 00:00:51.919
最後 確保應用有非常棒的用戶響應

00:00:52.452 --> 00:00:55.822
在我們開始講正題之前
讓我們談談爲什麼要這樣做

00:00:56.089 --> 00:01:01.261
原因就是我們想提供一種
優秀的用戶體驗

00:01:01.562 --> 00:01:04.598
我們想讓用戶喜歡用我們的應用

00:01:04.932 --> 00:01:08.435
我們想讓他們喜歡用我們應用
是因爲應用的速度很快

00:01:08.735 --> 00:01:09.803
速度像獵豹一樣快

00:01:10.370 --> 00:01:12.606
可以節省他們的時間來做更多的事

00:01:13.173 --> 00:01:16.143
我們想確保用戶的設備
一整天都有電

00:01:16.810 --> 00:01:19.513
這樣他們一整天都能使用設備

00:01:19.580 --> 00:01:21.448
而你的應用一定不想成爲那個

00:01:21.515 --> 00:01:23.750
在電量消耗表上排名第一的應用

00:01:24.551 --> 00:01:27.721
最後 我們想確保流暢的滾動

00:01:28.021 --> 00:01:33.026
在我們的應用中有迅速響應的UI
這樣用戶就會喜歡用它

00:01:33.794 --> 00:01:35.162
我們該如何實現呢？

00:01:35.229 --> 00:01:37.130
我們要用一種叫做分析的技術

00:01:37.664 --> 00:01:40.567
這種分析技術回答了
關於應用的兩個問題

00:01:40.801 --> 00:01:42.236
做了多少工作？

00:01:42.603 --> 00:01:44.304
做了什麼工作？

00:01:44.838 --> 00:01:46.907
若你尚未注意到標題

00:01:46.974 --> 00:01:50.310
我們要使用一種叫做
時間分析器的工具來實現

00:01:50.611 --> 00:01:53.113
時間分析器回答了另一個問題

00:01:53.347 --> 00:01:55.415
應用什麼時候做那個工作？

00:01:56.617 --> 00:01:59.586
時間分析器是應用中
Instruments的一部分

00:01:59.786 --> 00:02:02.523
Instruments
是很多工具的集合

00:02:02.756 --> 00:02:05.759
這些工具都是用來
測定應用的各個方面的

00:02:06.660 --> 00:02:07.861
怎麼用呢？

00:02:07.928 --> 00:02:09.029
嗯 非常簡單

00:02:09.096 --> 00:02:12.533
從Xcode產品菜單中
選擇Profile

00:02:13.333 --> 00:02:14.902
讓我們現在來操作一下

00:02:16.270 --> 00:02:19.106
好的 首先 我要給你們
演示一下我的應用

00:02:19.473 --> 00:02:20.974
讓你們瞭解它的功能

00:02:21.675 --> 00:02:24.945
我的應用使用了照片框架來查找

00:02:25.012 --> 00:02:27.714
用戶的圖庫
檢測是否有圖片副本

00:02:28.515 --> 00:02:30.117
我現在要操作一下

00:02:30.484 --> 00:02:34.321
如果我的測試數據中有很多副本
就得等一會兒了

00:02:34.388 --> 00:02:36.256
那麼 它給出了一個很大的數

00:02:36.423 --> 00:02:37.257
好的 完成了

00:02:37.925 --> 00:02:40.027
現在 我要選擇一些照片

00:02:41.795 --> 00:02:44.298
找一張好點兒的圖 這張吧

00:02:44.531 --> 00:02:47.134
然後應用就會使用核心圖像
面部識別功能

00:02:47.201 --> 00:02:49.469
這樣我可以給人臉上添加
一雙金魚眼

00:02:49.870 --> 00:02:52.873
然後應用就使用
CoreMotion中的力學UI

00:02:53.407 --> 00:02:56.577
當你搖動設備時
金魚眼會跟着一起晃動

00:02:57.544 --> 00:03:00.113
好的 這就是應用

00:03:01.148 --> 00:03:03.350
讓我們繼續分析它正在做什麼

00:03:04.117 --> 00:03:09.690
那麼從Xcode產品菜單中
正如我剛說過的 選擇Profile

00:03:10.524 --> 00:03:13.093
這將生成應用的一個發佈版本

00:03:13.427 --> 00:03:17.297
然後開啓Instruments
開始測定

00:03:17.865 --> 00:03:20.234
生成分析用的一個
發佈版本很重要

00:03:20.300 --> 00:03:23.504
因爲你希望能從編譯器中
獲得最優結果

00:03:24.905 --> 00:03:26.306
這得等會兒

00:03:26.573 --> 00:03:29.209
它正在把應用複製到設備上

00:03:33.981 --> 00:03:34.882
好了

00:03:35.816 --> 00:03:37.351
現在 Instruments開啓了

00:03:37.551 --> 00:03:40.120
它會顯示模板選擇器

00:03:40.854 --> 00:03:45.492
你可以瞭解Instruments
都提供了哪些工具

00:03:45.926 --> 00:03:47.928
今天 當然了
我們要用時間分析器

00:03:48.095 --> 00:03:49.897
我要點擊選擇按鈕

00:03:52.032 --> 00:03:54.501
若你從未用過Instruments

00:03:54.568 --> 00:03:56.803
這個用戶界面看起來
可能有點兒嚇人

00:03:57.137 --> 00:03:59.106
但是很容易上手

00:04:00.374 --> 00:04:04.444
我要做的就是點擊
左上角的這個記錄按鈕

00:04:05.245 --> 00:04:08.215
開啓應用 並開始測定

00:04:08.482 --> 00:04:10.017
讓我們實際操作一下

00:04:10.884 --> 00:04:13.120
好的 那麼現在 應用開啓了

00:04:15.656 --> 00:04:17.491
正在啓動 好了

00:04:17.891 --> 00:04:19.959
對吧？我要做副本檢測

00:04:21.595 --> 00:04:22.462
等一下

00:04:25.065 --> 00:04:25.899
好的

00:04:26.233 --> 00:04:28.936
然後 我要做副本檢測了

00:04:29.870 --> 00:04:31.438
讓我們看看是否開始獲得數據了

00:04:32.206 --> 00:04:33.273
好了

00:04:35.242 --> 00:04:36.243
好的 完成了

00:04:36.844 --> 00:04:38.579
現在 我要選擇照片

00:04:40.747 --> 00:04:42.749
然後我要挑出一張照片

00:04:43.417 --> 00:04:44.918
添加一雙金魚眼

00:04:45.886 --> 00:04:47.287
搖動一下

00:04:48.055 --> 00:04:49.923
現在不管那張圖了

00:04:51.258 --> 00:04:55.596
然後停止記錄

00:04:55.863 --> 00:04:57.164
點擊停止按鈕

00:04:59.566 --> 00:05:01.068
現在我們可以看到

00:05:01.134 --> 00:05:06.406
有一個應用正在做什麼的高級概覽

00:05:06.807 --> 00:05:08.509
時間分析器給出了兩張圖表

00:05:08.575 --> 00:05:11.178
Instruments
的頂部是時間線視圖

00:05:12.246 --> 00:05:14.715
第一張圖表是CPU的使用情況

00:05:14.781 --> 00:05:16.450
就是應用使用了多少CPU

00:05:17.184 --> 00:05:19.887
我可以把鼠標懸停在圖表上
查看精確數值

00:05:20.454 --> 00:05:25.993
第二張圖表
是應用所處的生命週期

00:05:26.059 --> 00:05:28.061
以及所延續的時間

00:05:31.265 --> 00:05:35.736
這讓我有了一個很好的概念
關於應用做了多少工作

00:05:36.003 --> 00:05:37.137
以及是什麼時候做的

00:05:37.771 --> 00:05:40.340
但是 我如何瞭解應用
正在做什麼呢？

00:05:40.874 --> 00:05:44.077
要了解該信息 我們要往下看
Instruments的調用樹視圖

00:05:44.244 --> 00:05:46.013
就是這個詳細視圖中的一部分

00:05:46.713 --> 00:05:51.151
調用樹視圖呈現了所收集的
通過比重合計的

00:05:51.218 --> 00:05:55.889
調用棧樣本
並顯示在詳細視圖中

00:05:56.523 --> 00:05:58.625
這是什麼意思呢？

00:05:59.126 --> 00:06:03.797
嗯 以圖形顯示比文字說明
更顯而易見

00:06:03.864 --> 00:06:05.599
讓我們來看一個圖表

00:06:06.500 --> 00:06:09.203
在這裏 時間向右運動

00:06:09.269 --> 00:06:11.271
這是我們那個非常簡單的應用

00:06:11.772 --> 00:06:14.308
我們有一個主方法
這是調用method1

00:06:14.641 --> 00:06:15.943
這是調用method2

00:06:16.643 --> 00:06:17.611
在這個時間點

00:06:17.678 --> 00:06:20.914
時間分析器要從應用中
獲得一個調用棧

00:06:21.415 --> 00:06:22.449
看起來是這樣的

00:06:23.016 --> 00:06:26.687
就跟你在Xcode中的調試器中
看到的調用棧是一樣的

00:06:27.187 --> 00:06:30.858
但在Instruments或
時間分析器中 後續的每一行都會縮進

00:06:30.924 --> 00:06:33.994
正因爲如此 才能創建一個樹結構
我們一會兒就會看到了

00:06:34.962 --> 00:06:36.330
時間在繼續

00:06:36.396 --> 00:06:38.465
哦 然後它記錄了那個調用棧

00:06:38.765 --> 00:06:42.336
然後記錄了
在那個調用棧內

00:06:42.402 --> 00:06:43.570
出現每個方法或函數的次數

00:06:44.671 --> 00:06:47.374
時間繼續
我們可以看到method2結束了

00:06:47.441 --> 00:06:50.544
method1調用結束了的method3
然後又調用了method2

00:06:51.211 --> 00:06:53.480
然後我們繼續 已經過了一毫秒

00:06:53.947 --> 00:06:56.049
時間分析器要取第二個樣本

00:06:56.116 --> 00:06:58.785
在這個示例中 第二個樣本看起來
跟第一個樣本一樣

00:06:58.852 --> 00:07:00.587
我們要繼續 更新表

00:07:00.854 --> 00:07:03.056
只是爲每個數增加了增量

00:07:04.124 --> 00:07:06.226
時間還在繼續

00:07:06.293 --> 00:07:08.896
現在我們看到應用正在做不同的事

00:07:09.429 --> 00:07:12.733
主方法直接調用了method2
然後調用了method3

00:07:13.367 --> 00:07:16.069
時間分析器就在這兒
取了另一個樣本

00:07:16.136 --> 00:07:18.038
現在 我們看到了一個
不同的調用棧

00:07:18.672 --> 00:07:20.841
在這個示例中 只有兩個方法

00:07:21.375 --> 00:07:24.811
然後 我們更新表
這是一個樹的分支

00:07:24.878 --> 00:07:30.083
現在我們瞭解了 主方法有時調用
method1 有時調用method2

00:07:30.417 --> 00:07:33.353
我們知道每種方法被調用了多少次

00:07:34.655 --> 00:07:37.891
那麼 時間繼續 我們收集更多的樣本

00:07:37.958 --> 00:07:40.260
這些樣本恰巧跟第一次的樣本
完全一樣

00:07:40.561 --> 00:07:42.996
我們要適當地更新表

00:07:43.730 --> 00:07:47.301
現在 讓我們看看這個表說明瞭什麼

00:07:48.635 --> 00:07:53.006
要注意一點 時間分析器實際上
並不是在測定持續的時間

00:07:53.273 --> 00:07:55.342
它並不是記錄哪個方法
什麼時候開始

00:07:55.609 --> 00:07:58.312
什麼時候結束 然後做個減法

00:07:58.612 --> 00:08:02.049
而是把這些樣本集合到一個
有用的彙總中

00:08:02.382 --> 00:08:05.052
當你在時間分析器中查看時間值時

00:08:05.118 --> 00:08:07.187
實際上不是一個持續時間的測定

00:08:07.454 --> 00:08:12.125
而是樣本時間乘以樣本個數

00:08:12.192 --> 00:08:14.161
在絕大部分情況下 是1毫秒

00:08:14.828 --> 00:08:17.197
這的確有一些副作用

00:08:17.464 --> 00:08:20.067
其中一個就是時間分析器
並不會區分

00:08:20.133 --> 00:08:23.904
被重複調用的
是連續運行的方法

00:08:23.971 --> 00:08:25.439
還是稍縱即逝的方法

00:08:25.739 --> 00:08:28.442
我們實際上可以看到在調用樹中

00:08:28.509 --> 00:08:32.111
method1和method2
出現的樣本個數相同

00:08:32.179 --> 00:08:37.618
從時間分析器的角度來說
它們做了同樣多的工作

00:08:38.118 --> 00:08:41.955
但我們知道 實際上method1
被調用了兩次 運行時間很長

00:08:42.022 --> 00:08:45.125
而method2被調用了四次
運行時間很短

00:08:46.226 --> 00:08:49.630
時間分析器還集中分析
CPU的使用情況 對吧？

00:08:49.696 --> 00:08:53.567
它回答了這個問題
應用正在做什麼工作？

00:08:53.867 --> 00:08:57.471
另一個結果是
它不一定會捕捉一切

00:08:57.871 --> 00:09:00.240
事實上 表中遺失了什麼？

00:09:01.942 --> 00:09:03.677
沒有method3 對嗎？

00:09:03.977 --> 00:09:05.812
如果你有執行起來非常快的函數

00:09:05.879 --> 00:09:08.415
或執行起來很快而且非常
頻繁地調用的方法

00:09:08.782 --> 00:09:10.317
這些方法將不會
出現在調用樹中

00:09:10.918 --> 00:09:12.619
實際上沒問題
這就是我們想要的

00:09:12.686 --> 00:09:14.488
因爲那並不會影響

00:09:14.555 --> 00:09:16.857
所產生的工作量

00:09:18.192 --> 00:09:20.260
那麼現在 我們對調用樹
有了更好的理解

00:09:20.360 --> 00:09:23.430
讓我們看看如何通過它使應用的
速度更快 工作量更少

00:09:31.572 --> 00:09:34.875
好的 讓我們回去看時間線

00:09:36.410 --> 00:09:40.714
我想看一下第一大塊
CPU的使用情況

00:09:40.781 --> 00:09:45.385
可以看到 在大量時間內
CPU的佔用是100%

00:09:46.753 --> 00:09:49.489
那麼 我想確切瞭解那時
應用正在做什麼

00:09:49.556 --> 00:09:52.159
我恰巧知道
那時我正在做副本檢測

00:09:52.459 --> 00:09:55.896
預計那個工作量會很大
所以我一點兒都不吃驚

00:09:56.196 --> 00:09:57.831
但無論在哪兒
你佔用了大量CPU資源

00:09:57.898 --> 00:10:00.567
通常總是能讓它更快一些

00:10:01.668 --> 00:10:04.104
所以 爲了更好地瞭解
這裏正在發生什麼

00:10:04.371 --> 00:10:10.511
我要用觸控板 放大 然後鬆開

00:10:10.911 --> 00:10:15.916
我可以更好地瞭解在這個時間段
到底發生了什麼

00:10:16.650 --> 00:10:21.021
然後我要點擊並拖拽時間線視圖

00:10:22.089 --> 00:10:23.957
這樣可以應用一個篩選器

00:10:24.024 --> 00:10:27.361
現在調用樹只能顯示在那個

00:10:27.427 --> 00:10:30.130
時間框架內所收集樣本的數據

00:10:30.330 --> 00:10:32.065
如果你注意看 你會看到

00:10:32.132 --> 00:10:34.868
調用樹實際上顯示的數據變少了

00:10:34.935 --> 00:10:37.371
只顯示了這個時間段的數據

00:10:38.505 --> 00:10:40.841
現在 讓我們更詳細地
看一下調用樹

00:10:42.342 --> 00:10:43.677
你將在這兒看到幾個欄

00:10:43.744 --> 00:10:46.580
有比重和自比重 然後是標識名

00:10:47.414 --> 00:10:50.784
比重代表調用樹出現的

00:10:51.084 --> 00:10:53.854
指定部分的樣本百分比

00:10:54.221 --> 00:10:56.390
你將看到比重旁邊還有個時間

00:10:56.456 --> 00:10:58.792
正如我之前講過的
那不是持續時間

00:10:59.059 --> 00:11:03.497
而是樣本時間乘以樣本個數

00:11:04.131 --> 00:11:05.866
然後還有自比重

00:11:06.300 --> 00:11:10.904
實際上是在那個方法內
所花費的時間

00:11:10.971 --> 00:11:12.906
而非在它調用的其他方法內
所花費的時間

00:11:13.273 --> 00:11:15.475
你在這裏可以看到 這些是0

00:11:15.542 --> 00:11:18.679
如果你關閉這個 還是0

00:11:18.779 --> 00:11:19.780
仍然是0

00:11:20.113 --> 00:11:24.651
這就告訴我們 你知道的
在樣本中主方法的比重是99%

00:11:25.752 --> 00:11:29.289
但其實這些全部也是在
UIApplication主方法中

00:11:29.590 --> 00:11:33.227
無論是什麼方法都要調用
UIApplication的主方法

00:11:33.493 --> 00:11:35.329
我們不會一個接一個地顯示這些

00:11:35.395 --> 00:11:37.965
我要使用Instruments 8
中的新功能

00:11:38.632 --> 00:11:41.702
我按下選項鍵
並點擊顯示三角按鈕

00:11:41.969 --> 00:11:44.104
這樣能得到一個更好的顯示

00:11:44.238 --> 00:11:46.206
這將會關閉調用樹

00:11:46.273 --> 00:11:48.141
除非調用樹中有真正令人
關注的數據

00:11:49.443 --> 00:11:51.578
如果我們繼續往下滾動

00:11:51.645 --> 00:11:54.014
我們可以看到
我們實際上有一些方法

00:11:54.281 --> 00:11:55.916
有自比重

00:11:56.216 --> 00:11:58.585
其實若我查看這個
特定的release調用

00:11:58.652 --> 00:12:03.757
我可以看到 它的比重是117毫秒
跟它的自比重一樣

00:12:04.024 --> 00:12:05.759
那麼它所有的時間都花在它自己身上了

00:12:05.826 --> 00:12:09.162
沒有調用任何後續的函數或方法

00:12:09.863 --> 00:12:11.265
其實 你知道的 通過查看這些

00:12:11.331 --> 00:12:14.601
我看到這裏調用了很多
Objective-C執行時間

00:12:14.935 --> 00:12:18.372
實際上它們的自重都很大

00:12:19.673 --> 00:12:23.844
這些運行時間方法已經被無限
高度優化 運行起來非常快

00:12:24.211 --> 00:12:27.581
通常是時間分析器不會
捕捉的那類東西

00:12:27.648 --> 00:12:29.016
因爲運行速度太快了

00:12:29.950 --> 00:12:34.621
但是它們已經被顯示出來了
於是我知道通常它們會被頻繁調用

00:12:35.055 --> 00:12:36.523
所以纔在樣本中出現

00:12:36.823 --> 00:12:40.694
這通常是循環很多
Objective-C對象的情況

00:12:40.761 --> 00:12:42.462
你將看到這會在軌跡中顯示出來

00:12:42.963 --> 00:12:46.767
調用樹體現的第二點是
看右邊

00:12:47.067 --> 00:12:52.105
我們可以看到調用樹的哪部分
來自哪個庫

00:12:52.172 --> 00:12:53.273
特定的方法調用

00:12:53.340 --> 00:12:55.843
並且在這裏 我們能看到這是
隨着照片框架出現的

00:12:56.109 --> 00:12:57.444
實際上是按照層級排列的

00:12:58.011 --> 00:12:59.346
滾動到右邊

00:12:59.646 --> 00:13:03.450
我們可以看到
這裏有一行來自應用的代碼

00:13:03.517 --> 00:13:05.819
這行代碼導致了工作量的產生

00:13:08.021 --> 00:13:11.592
你知道的 這行的比重是0

00:13:11.658 --> 00:13:13.460
它自己沒做任何工作

00:13:13.527 --> 00:13:15.696
但是它卻觸發了所有工作

00:13:16.196 --> 00:13:19.700
我不能再加快Objective-C
發佈調用的速度了

00:13:19.766 --> 00:13:23.937
但我能看到是否可以少調用幾次

00:13:24.505 --> 00:13:26.240
所以 我要雙擊這行

00:13:26.507 --> 00:13:28.041
把我帶入代碼中

00:13:29.109 --> 00:13:33.180
Instruments給每行
添加了一個樣本個數的註釋

00:13:33.247 --> 00:13:36.416
那麼 看這個方法
我能看到大部分時間

00:13:36.483 --> 00:13:38.151
都花在紅色背景行那兒

00:13:38.986 --> 00:13:41.955
但是如果我再仔細看一下
我實際上能看到其他東西

00:13:42.022 --> 00:13:43.657
我嵌套了四個循環

00:13:44.157 --> 00:13:50.831
事實上 每個循環重複整個
照片採集的過程

00:13:51.431 --> 00:13:53.500
這是很典型的一個

00:13:53.567 --> 00:13:55.502
叫做N次方行爲的例子

00:13:55.936 --> 00:13:58.572
如果我向這行代碼中代入
更多數據

00:13:58.639 --> 00:14:01.341
速度會變慢 越來越慢

00:14:01.408 --> 00:14:05.712
因爲我知道會運行大量數據
這很不好

00:14:06.346 --> 00:14:08.215
所以我想改變這種情況

00:14:08.649 --> 00:14:09.850
我要進入Xcode

00:14:10.450 --> 00:14:11.585
這是我的代碼

00:14:12.619 --> 00:14:17.891
避免嵌套四個循環的典型方法是
使用基於集合的實現

00:14:18.358 --> 00:14:21.195
我不再贅述了 我要繼續

00:14:22.362 --> 00:14:28.702
創建一個新算法
用來執行副本檢測 使用...

00:14:33.440 --> 00:14:35.709
使用一個計數集合和另一個
查找副本的

00:14:40.514 --> 00:14:41.748
集合

00:14:42.416 --> 00:14:45.319
現在 讓我們看看
我實際上做了點兒改變

00:14:45.452 --> 00:14:47.287
再一次 我要進入產品菜單

00:14:47.988 --> 00:14:49.456
我要選擇分析

00:14:50.190 --> 00:14:54.061
它會重新創建我的應用
並把它安裝在設備上

00:14:55.729 --> 00:14:57.831
因爲Instruments已運行了

00:14:57.998 --> 00:15:00.434
它會立即開始記錄

00:15:01.268 --> 00:15:04.905
那麼 當它把應用複製到設備上時
讓我們看一下 已經開始分析了

00:15:07.941 --> 00:15:09.009
這是Instruments

00:15:10.711 --> 00:15:12.346
我的應用已經開啓了

00:15:14.581 --> 00:15:17.251
好的 它開始記錄了 我要縮小

00:15:19.219 --> 00:15:21.588
好的 我要縮小
這樣我們就能看到數據了

00:15:23.156 --> 00:15:25.392
我要執行副本檢測

00:15:27.528 --> 00:15:29.530
副本 所有照片

00:15:30.998 --> 00:15:32.399
我可以看到數據進來了

00:15:32.599 --> 00:15:34.668
實際上是以分鐘爲單位記錄的
我還以爲是秒

00:15:35.269 --> 00:15:38.705
好的 那麼副本檢測
實際上速度更快了

00:15:39.339 --> 00:15:44.545
事實上 我們再也不會看到貫穿
時間線的那個長條了

00:15:44.611 --> 00:15:45.712
這是個不錯的變化

00:15:46.079 --> 00:15:49.116
我想繼續
重新測定應用剩餘的部分

00:15:49.183 --> 00:15:50.551
選擇一些照片

00:15:51.185 --> 00:15:52.886
添加一雙金魚眼

00:15:53.420 --> 00:15:54.621
搖動一下

00:15:55.189 --> 00:15:56.790
然後就不用管那張照片了

00:15:56.857 --> 00:16:00.827
現在應用是靜態的
不應該做任何工作

00:16:01.295 --> 00:16:05.132
但是讓我們看看
時間分析器怎麼說

00:16:05.232 --> 00:16:06.533
停止記錄

00:16:09.703 --> 00:16:11.205
加載一分鐘纔有數據

00:16:11.305 --> 00:16:12.139
哇哦

00:16:14.174 --> 00:16:19.580
好的 我可以看到在調用的末端

00:16:19.646 --> 00:16:21.415
佔用了一些CPU資源

00:16:21.982 --> 00:16:24.651
並不多 但我希望是0

00:16:25.052 --> 00:16:26.954
所以我要繼續 看看它做了什麼

00:16:27.721 --> 00:16:30.591
我再次通過觸摸板進行放大

00:16:32.192 --> 00:16:36.129
拖拽並選擇
看看這裏發生了什麼

00:16:37.264 --> 00:16:43.003
然後繼續
點開查看正在發生什麼

00:16:43.470 --> 00:16:45.539
查看調用樹

00:16:45.806 --> 00:16:48.775
這次我看到在CoreMotion中
有大量的調用 對吧？

00:16:48.842 --> 00:16:50.344
且我知道我的應用正在此做什麼

00:16:50.410 --> 00:16:54.381
它正在使用CoreMotion進行
檢測並移動眼睛

00:16:54.982 --> 00:16:57.518
但如果查看上邊的調用樹

00:16:57.584 --> 00:17:01.421
實際上這個調用樹中沒有
我的任何代碼

00:17:01.989 --> 00:17:04.825
我並沒有執行任何可以直接引起
使用CPU的操作

00:17:05.092 --> 00:17:08.328
但我應用中的某些東西使
CoreMotion做了不該做的

00:17:08.729 --> 00:17:10.097
關於應用 我知道的是

00:17:10.163 --> 00:17:14.034
我發現
當不看屏幕的時候

00:17:14.101 --> 00:17:16.002
我不能關閉CoreMotion監控

00:17:16.603 --> 00:17:18.438
讓我們繼續改一下

00:17:19.406 --> 00:17:20.540
返回Xcode

00:17:21.942 --> 00:17:26.847
實際上我已經寫好了所有方法

00:17:27.047 --> 00:17:30.184
只需要調用即可
讓我們把它們添加到這裏來

00:17:32.186 --> 00:17:35.055
然後我們停止觀察這兒

00:17:39.626 --> 00:17:41.195
好的 現在讓我們測定這個

00:17:41.261 --> 00:17:44.464
並確保會發生我們所期待的改變

00:17:45.399 --> 00:17:48.769
再次
Instruments會重建應用

00:17:49.036 --> 00:17:50.103
並把它放在設備上

00:17:50.971 --> 00:17:55.042
因爲Instruments已經開啓
並正在運行 它會再次開始記錄

00:17:55.475 --> 00:17:58.312
這一次 我要提前放大

00:17:58.712 --> 00:18:02.616
我點擊篩選器外面 移除它

00:18:04.518 --> 00:18:07.120
好的 一旦應用在設備上安裝

00:18:08.322 --> 00:18:10.390
Instruments就會再次
開啓對它的記錄

00:18:18.065 --> 00:18:19.399
好的 就是這樣

00:18:23.704 --> 00:18:29.109
好的 這一次 我要繼續
只添加照片

00:18:33.113 --> 00:18:35.048
然後我要滾動到一張照片那兒

00:18:35.816 --> 00:18:36.783
選擇它

00:18:37.084 --> 00:18:38.118
添加眼睛

00:18:39.553 --> 00:18:40.821
搖動一下

00:18:40.888 --> 00:18:42.456
讓我們再稍微放大點兒

00:18:45.192 --> 00:18:48.328
選擇一張新照片
這樣屏幕上就沒有眼睛了

00:18:49.196 --> 00:18:51.498
然後停止記錄

00:18:51.565 --> 00:18:53.400
看看是否發生了我們
所期待的變化

00:18:54.034 --> 00:18:59.306
一旦Instruments
完成數據處理 我就放大這個末端部分

00:18:59.373 --> 00:19:03.177
我可以看到在末端
CPU的佔用率爲0

00:19:03.577 --> 00:19:07.281
所以應用不再做它不需要做
的工作了

00:19:08.782 --> 00:19:10.918
那麼 讓我們回顧一下
我們做了什麼

00:19:11.885 --> 00:19:15.355
第一件事是用軌跡面板計算

00:19:15.422 --> 00:19:17.958
應用做了多少工作
以及什麼時候做的

00:19:18.025 --> 00:19:21.361
這樣就很容易找到想要關注的區域

00:19:21.762 --> 00:19:25.132
並且觸控板很容易操作
軌跡面板或時間線

00:19:25.199 --> 00:19:27.067
但用鼠標控制也不錯

00:19:27.134 --> 00:19:30.537
使用option鍵-拖拽
和control鍵-拖拽放大和縮小

00:19:31.705 --> 00:19:35.642
我們在軌跡視圖上找到了一個
佔用許多CPU資源的區域

00:19:35.709 --> 00:19:37.177
我們想讓它速度更快

00:19:37.344 --> 00:19:42.149
所以我們繼續 放大
對那個區域進行篩選

00:19:43.250 --> 00:19:45.452
我們查看了調用樹 我們發現

00:19:45.519 --> 00:19:48.488
產生工作量的地方
是應用中的那個部分

00:19:49.323 --> 00:19:53.794
然後我們往回看調用樹
直到看到我們的代碼

00:19:53.861 --> 00:19:57.097
應用中的哪個部分產生了
這樣的工作量

00:19:57.397 --> 00:19:59.433
即使不是應用自己產生的？

00:20:00.734 --> 00:20:03.504
我們看一下代碼 考慮一下

00:20:03.570 --> 00:20:05.606
撓撓頭 吃一個三明治

00:20:05.672 --> 00:20:07.441
我們發現了可使它速度更快的方式

00:20:07.941 --> 00:20:10.677
所以我們實現了那些變更

00:20:10.744 --> 00:20:13.914
並證實了實際上會讓它的速度變得更快

00:20:13.981 --> 00:20:16.083
在這個例子中
這是個意義重大的改進

00:20:16.149 --> 00:20:19.253
結果是我們節省了用戶的時間

00:20:19.419 --> 00:20:21.355
當用戶使用我的應用
來查找副本時

00:20:21.421 --> 00:20:23.524
他們再也不用看那個
旋轉的加載圖標了

00:20:24.324 --> 00:20:25.792
會很快地完成

00:20:27.160 --> 00:20:29.329
關於減少工作量
我們能做什麼呢？

00:20:29.696 --> 00:20:32.833
我們再關注一下軌道視圖
上的一個區域

00:20:33.901 --> 00:20:35.936
這一次並沒有佔用
很多CPU資源

00:20:36.003 --> 00:20:38.639
而CPU的佔用量
出人意料

00:20:39.139 --> 00:20:41.308
我們放大 加上一個篩選器

00:20:41.909 --> 00:20:43.577
我們看一下調用樹

00:20:43.644 --> 00:20:47.714
這一次 我們再看一下框架
我們看到的是CoreMotion

00:20:47.781 --> 00:20:49.917
但沒有誘發我們的代碼

00:20:50.551 --> 00:20:53.020
所以這次 我們得用另一種方式
來思考我們的應用

00:20:53.086 --> 00:20:56.123
是應用的哪個部分
導致了這個工作量？

00:20:56.857 --> 00:21:01.662
我們又一次 也許休息一小會兒
再吃個三明治

00:21:01.895 --> 00:21:04.631
想想如何使應用停止產生
那個工作量

00:21:05.199 --> 00:21:06.700
讓它不再出現

00:21:07.334 --> 00:21:09.436
我們繼續 重新分析應用

00:21:09.503 --> 00:21:12.906
驗證了我們所期望的修改

00:21:13.473 --> 00:21:17.778
事實上 結果是
我們顯著提高了

00:21:18.579 --> 00:21:21.114
應用運行時的電池續航能力

00:21:21.181 --> 00:21:24.284
無論任何時候 CPU都可以歸0
並進入休眠

00:21:24.585 --> 00:21:26.520
這就意味着有效地節省了用電量

00:21:26.753 --> 00:21:31.825
即使我們的CPU佔用量很低
仍然會有電量消耗

00:21:32.759 --> 00:21:35.929
那麼現在 我們變快了
工作量變少了

00:21:36.263 --> 00:21:38.732
讓我們使應用的響應
更積極一些吧

00:21:40.934 --> 00:21:43.403
應用的工作方式

00:21:43.470 --> 00:21:46.340
是主線程完成所有
用戶界面的工作

00:21:46.406 --> 00:21:51.178
承擔了響應用戶輸入並更新
視圖的任務

00:21:51.545 --> 00:21:56.116
無論如何處理用戶輸入
都有一個主線程

00:21:56.183 --> 00:22:00.420
主線程有一個運行循環
只是監聽一個隊列

00:22:00.487 --> 00:22:01.855
叫做事件隊列

00:22:01.922 --> 00:22:04.157
並等待事件在事件隊列中出現

00:22:04.758 --> 00:22:10.764
事件出現時 它把事件發送到
UIApplication或NS應用實例

00:22:11.164 --> 00:22:15.169
然後把事件傳遞到
應用的響應鏈中

00:22:15.802 --> 00:22:18.739
如果應用想響應那個事件

00:22:19.039 --> 00:22:21.208
那麼它會繼續並誘發你的代碼

00:22:21.775 --> 00:22:25.012
然後你可以在這裏的調用棧中
看到這個

00:22:25.345 --> 00:22:27.281
這是我應用中的調用棧

00:22:27.781 --> 00:22:30.050
我們可以看到 有主線程

00:22:30.817 --> 00:22:35.389
所有應用的主線程都是
以調用主函數開始的

00:22:35.923 --> 00:22:38.759
在這裏 我不清楚這些函數
具體有什麼作用

00:22:38.825 --> 00:22:41.161
但是顯而易見
都跟運行循環相關

00:22:41.995 --> 00:22:44.631
我看到有函數
handleEventQueue

00:22:44.698 --> 00:22:47.968
很顯然 這個函數是從事件隊列中
把一個事件取出來 並進行處理

00:22:48.468 --> 00:22:51.572
我可以看到它把事件
傳給了UIApplication

00:22:51.638 --> 00:22:55.008
然後傳到響應鏈
最後傳給了我的代碼

00:22:55.242 --> 00:22:58.512
在這個例子中
這是一個按鈕的IB動作

00:22:59.479 --> 00:23:01.215
然後我的代碼就執行了操作

00:23:02.249 --> 00:23:05.185
那麼 這對於保持應用積極響應
來說有什麼意義呢？

00:23:05.786 --> 00:23:10.224
嗯 忙時 主線程不能處理隊列

00:23:10.624 --> 00:23:13.627
因爲它會開始備份
備份你的用戶事件

00:23:14.094 --> 00:23:17.664
然後結果是 變得磕磕絆絆
不順暢

00:23:18.031 --> 00:23:21.301
最糟糕的情況是
你的應用變得完全沒有響應

00:23:21.635 --> 00:23:24.571
此時用戶會關閉應用
也許會從設備上刪除應用

00:23:25.506 --> 00:23:29.109
因此 釋放主線程很重要

00:23:29.877 --> 00:23:35.716
這樣就能很快地響應用戶輸入

00:23:36.984 --> 00:23:38.519
現在 有了這種方案

00:23:38.585 --> 00:23:42.155
讓我們看看可以對應用做出哪些改進
使它能更積極地做出響應

00:23:43.624 --> 00:23:46.960
好了 這次我要縮小軌跡視圖

00:23:47.528 --> 00:23:50.898
現在我想要關注的是這個
CPU佔用比較多的區域

00:23:51.164 --> 00:23:53.934
在這裏 我看到CPU的佔用率
遠遠超過100%

00:23:54.168 --> 00:23:56.870
也許可以對這裏進行優化

00:23:57.404 --> 00:24:00.908
而我恰巧知道 這是我給圖片
添加眼睛的時候

00:24:01.441 --> 00:24:04.611
那麼我再一次使用觸控板
進行放大

00:24:05.412 --> 00:24:08.315
點擊並拖拽 加上一個過濾器

00:24:09.483 --> 00:24:11.251
現在看一下調用樹

00:24:12.519 --> 00:24:15.989
這次 我想特別關注
主線程做了什麼

00:24:16.456 --> 00:24:19.259
我可以看到 實際上主線程

00:24:19.326 --> 00:24:22.663
在樣本中的出現頻率爲
63% 64%

00:24:23.931 --> 00:24:28.101
因此我就明白了 在這個時間段
正在進行一些工作

00:24:28.502 --> 00:24:30.771
但我想確切地知道做了多少工作

00:24:31.572 --> 00:24:35.709
爲此 我要繼續 看右上角

00:24:35.976 --> 00:24:38.779
我們可以使用不同的
策略和Instruments

00:24:38.846 --> 00:24:42.316
因此 你可以按照CPU
或線程瀏覽數據

00:24:42.683 --> 00:24:44.418
這一次 我想按照線程來看數據

00:24:44.885 --> 00:24:47.521
實際上我可以讓它變大點兒
以便查看

00:24:48.088 --> 00:24:52.125
在左側的這裏 你可以看到
應用中的所有線程

00:24:52.559 --> 00:24:54.094
主線程在頂部

00:24:54.595 --> 00:24:58.632
所以我可以看到主線程的CPU
使用情況

00:24:58.866 --> 00:25:01.902
在這裏 很明顯 達到了100%

00:25:02.302 --> 00:25:05.906
在這種狀態下
它絕不會響應用戶事件了

00:25:05.973 --> 00:25:09.142
也不能處理隊列了

00:25:09.209 --> 00:25:11.044
如果它正忙於處理應用中的工作

00:25:11.745 --> 00:25:14.381
那麼 主線程到底在做什麼？

00:25:14.915 --> 00:25:19.386
這一次 我要點擊右側的擴展
詳細視圖

00:25:19.753 --> 00:25:24.258
這將顯示在主線程上做了
大部分工作的調用棧

00:25:24.391 --> 00:25:26.960
因爲我的主線程是從左側
選出來的

00:25:27.294 --> 00:25:30.898
所以我在這裏滾動
我可以看到這是運行循環

00:25:30.964 --> 00:25:32.733
然後在這裏
我看到了我的代碼

00:25:33.066 --> 00:25:35.369
這是添加眼睛的代碼

00:25:35.769 --> 00:25:38.172
然後正在做更多的添加
眼睛的工作

00:25:38.238 --> 00:25:39.940
然後這裏
正在調用查找面部

00:25:40.007 --> 00:25:42.676
所以這是應用中的
面部檢測代碼

00:25:42.743 --> 00:25:46.113
然後我們可以看到下一行
調用了圖形核心

00:25:46.180 --> 00:25:52.019
如果我在詳細視圖中點擊這個
它將展開那行的調用樹

00:25:53.220 --> 00:25:55.489
再一次推導出我的代碼

00:25:55.556 --> 00:26:00.294
我沒必要在主線程上做面部檢測

00:26:00.360 --> 00:26:04.731
這並不是響應用戶輸入
也不是更新視圖

00:26:05.065 --> 00:26:07.167
因此可以挪到後臺線程上去實現

00:26:07.601 --> 00:26:11.572
那麼 這是執行面部檢測的代碼

00:26:11.638 --> 00:26:14.007
我可以看到面部檢測完成後

00:26:14.208 --> 00:26:16.443
它會繼續調用
displayEyes方法

00:26:16.877 --> 00:26:21.548
這裏要注意一個重點
displayEyes會更新UI

00:26:21.615 --> 00:26:24.218
因此這是主線程上的工作

00:26:24.751 --> 00:26:28.655
所以 我需要做的是在後臺
線程上執行面部檢測

00:26:28.989 --> 00:26:33.794
切回主線程 更新UI

00:26:35.028 --> 00:26:36.630
哦 好了

00:26:36.697 --> 00:26:38.832
好的 謝謝

00:26:41.101 --> 00:26:43.604
此處不應有掌聲

00:26:43.871 --> 00:26:44.905
但我接受你們的誇獎

00:26:45.839 --> 00:26:48.375
好了 這是在後臺實現這個
功能的代碼

00:26:48.442 --> 00:26:51.178
我要快速講一下

00:26:51.612 --> 00:26:54.147
進入後臺的一個隊列

00:26:54.214 --> 00:26:57.117
然後調度查找面部代碼

00:26:57.451 --> 00:27:00.654
正如我剛說過的
我們要調回主隊列

00:27:00.721 --> 00:27:02.222
更新我們的UI

00:27:02.589 --> 00:27:04.424
這一次在做分析時

00:27:04.491 --> 00:27:08.395
我會按住運行按鈕 選擇分析

00:27:09.062 --> 00:27:10.397
可以實現同樣的功能

00:27:10.731 --> 00:27:13.100
很可能會相當快

00:27:13.200 --> 00:27:15.102
哦 我刪除了代碼

00:27:16.069 --> 00:27:17.304
讓我們再做一次

00:27:17.571 --> 00:27:19.907
那麼因爲我已經實現了
我只需要繼續並...

00:27:20.774 --> 00:27:22.142
這個結果滿意嗎...

00:27:22.209 --> 00:27:24.845
點擊分析按鈕 好了

00:27:25.112 --> 00:27:26.780
它會創建我的應用

00:27:28.081 --> 00:27:29.550
並在設備上安裝應用

00:27:30.417 --> 00:27:33.187
好的 Instruments應顯示

00:27:33.587 --> 00:27:38.992
並開始記錄我的應用了

00:27:41.195 --> 00:27:44.298
哦 我要切回
Instruments視圖

00:27:48.435 --> 00:27:52.339
然後 讓我們縮小一下
看看進來的數據

00:27:53.974 --> 00:27:58.946
好的 很快
讓我們給應用添加一些照片

00:28:02.049 --> 00:28:04.184
然後執行眼睛檢測

00:28:04.585 --> 00:28:07.354
好了 那麼在這裏
我們能看到那個大的CPU峯值

00:28:08.055 --> 00:28:09.857
停止記錄

00:28:10.657 --> 00:28:13.026
現在 讓我們看看是否實現了
我們所期待的變更

00:28:13.293 --> 00:28:19.032
我要再次使用觸控板放大
圖表的這個區域

00:28:19.900 --> 00:28:24.404
點擊並拖拽時間線視圖
加一個過濾器

00:28:25.272 --> 00:28:27.674
現在 如果我們查看一下調用樹

00:28:27.741 --> 00:28:32.679
實際上我在這裏看到主線程
在樣本中的比重只有4.8%

00:28:32.746 --> 00:28:33.747
這是個好跡象

00:28:33.814 --> 00:28:35.983
我已經知道主線程的工作量
正在減少

00:28:36.049 --> 00:28:38.418
兩個輔助線程分擔了
更多的工作量

00:28:39.319 --> 00:28:41.855
那麼讓我們切到線程策略

00:28:42.322 --> 00:28:43.357
在這裏 我可以看到

00:28:43.423 --> 00:28:48.395
實際上 主線程在絕大部分
時間裏是完全被釋放的

00:28:50.998 --> 00:28:51.865
謝謝大家

00:28:55.702 --> 00:28:57.604
讓我們返回幻燈片

00:28:58.705 --> 00:29:00.374
談談我們剛纔做了什麼

00:29:01.241 --> 00:29:03.977
爲了使應用更積極地做出響應

00:29:04.678 --> 00:29:08.649
我們發現了一個區域
在這個區域中CPU佔用率很高

00:29:08.715 --> 00:29:12.419
我就放大那個區域 添加了一個
過濾器 這是很常見的操作

00:29:12.486 --> 00:29:14.154
我們做的就是

00:29:14.221 --> 00:29:16.123
關注主線程

00:29:16.190 --> 00:29:21.228
因爲我想確保我的應用
持續地做出積極響應

00:29:21.762 --> 00:29:25.933
我摘出主線程上的一些
非UI類的工作

00:29:26.166 --> 00:29:28.802
然後把那些工作挪到
後臺線程上去實現

00:29:29.536 --> 00:29:31.638
你很可能猜到了下一個步驟

00:29:31.939 --> 00:29:33.540
我驗證了我所做的變更

00:29:33.941 --> 00:29:37.945
確保應用正如我所期待的那樣

00:29:38.645 --> 00:29:41.715
結果是我得到了更好的用戶體驗

00:29:41.782 --> 00:29:45.819
當執行面部檢測時
我的用戶界面將持續做出響應

00:29:46.220 --> 00:29:47.354
這很棒

00:29:48.322 --> 00:29:50.624
關於優化 有幾點建議

00:29:50.824 --> 00:29:53.126
我們今天所做的修改相對簡單

00:29:53.193 --> 00:29:55.162
但確實增加了應用的複雜程度

00:29:55.629 --> 00:29:56.864
一般來說

00:29:56.930 --> 00:30:01.268
優化範例是用簡化換取性能

00:30:01.335 --> 00:30:03.136
關於優化

00:30:03.203 --> 00:30:07.941
但很幸運 因爲我早在開發階段
就做了分析

00:30:08.008 --> 00:30:09.209
我並沒有等到最後才做

00:30:09.276 --> 00:30:14.781
我現在有時間驗證
應用是否運轉正常

00:30:15.215 --> 00:30:18.852
如果我覺得必要 我可以添加
額外的單元測試或UI測試

00:30:19.152 --> 00:30:22.356
關注比較複雜的地方
仍然能正常運行

00:30:23.490 --> 00:30:25.726
在你發佈應用之前

00:30:25.792 --> 00:30:29.263
是你能做出修改的最後機會

00:30:29.730 --> 00:30:34.535
所以真正的收穫是它會
持續地分析你的應用

00:30:34.601 --> 00:30:36.870
尤其在你添加新功能之後

00:30:37.137 --> 00:30:38.839
要早做分析

00:30:38.906 --> 00:30:41.608
要不間斷地做分析

00:30:42.142 --> 00:30:45.112
有時候可以只分析運行時間
看能發現什麼

00:30:45.179 --> 00:30:47.347
你很快就會取得重大進展

00:30:48.182 --> 00:30:51.652
因此運行分析還是有好處的
可以瞭解是否正在發生有趣的事

00:30:52.619 --> 00:30:55.422
關於時間分析器的一些最佳範例

00:30:55.656 --> 00:30:59.326
總的來說 你的分析

00:30:59.393 --> 00:31:02.162
要儘可能地接近客戶
要運行的東西

00:31:02.563 --> 00:31:05.199
因此你要一直分析發佈版本

00:31:05.265 --> 00:31:06.500
最佳範例

00:31:06.567 --> 00:31:09.036
你不僅需要在編譯階段進行優化

00:31:09.102 --> 00:31:11.371
還需要在你客戶要使用的發佈
版本上進行優化

00:31:12.239 --> 00:31:14.608
你要一直在設備上做分析

00:31:14.675 --> 00:31:18.245
模擬器不能給你提供有用的數據

00:31:20.447 --> 00:31:24.785
要在能支持的最老、
最慢的設備上做分析

00:31:25.185 --> 00:31:26.553
有一條很好的規則

00:31:26.620 --> 00:31:29.022
如果能在較慢的設備上
很好地運行

00:31:29.089 --> 00:31:31.491
那麼 在較快的設備上一定
能更好地運行

00:31:31.892 --> 00:31:35.395
你想讓所有用戶在使用你的
應用時都有非常棒的體驗

00:31:35.696 --> 00:31:37.297
就算用的是較慢的設備也一樣

00:31:38.131 --> 00:31:40.801
要儘可能使用大數據集合

00:31:40.934 --> 00:31:46.773
在我的示例中 有時候用戶的相冊中
有成百上千

00:31:46.840 --> 00:31:48.141
或成千上萬張照片

00:31:48.375 --> 00:31:52.312
分析應用如何在那種環境下
運行非常重要

00:31:52.746 --> 00:31:56.483
因此我可以確保客戶在打開
應用時應用能順暢運行

00:31:58.018 --> 00:32:00.287
那麼 總結一下

00:32:00.821 --> 00:32:06.426
如果你希望客戶因爲應用能節約
時間而愛上你的應用

00:32:07.294 --> 00:32:09.863
有助於他們實現全天電量充沛

00:32:10.264 --> 00:32:13.333
並且你的UI響應順暢

00:32:13.400 --> 00:32:18.539
然後 你要做的是早做分析
並經常分析

00:32:20.274 --> 00:32:23.310
如果你想了解更多信息
請看這個URL

00:32:24.111 --> 00:32:27.247
這裏有一些相關的演講

00:32:27.514 --> 00:32:29.917
去年我們做了一場
“深度分析”的演講

00:32:29.983 --> 00:32:33.353
有關於時間分析器的更多
詳細信息 你可以瞭解一下

00:32:33.420 --> 00:32:36.256
今年 我們做了一個名爲深度解析
系統跟蹤的系列演講

00:32:36.323 --> 00:32:38.225
講的是當時間分析器力不從心時

00:32:38.292 --> 00:32:41.361
如何使用系統跟蹤工具

00:32:41.628 --> 00:32:43.664
謝謝大家
祝你們度過一個美好的下午