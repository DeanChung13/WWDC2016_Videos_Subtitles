00:00:19.353 --> 00:00:21.488
調試要訣和技巧

00:00:28.896 --> 00:00:32.232
大家下午好
歡迎參加“調試要訣和技巧”演講

00:00:32.598 --> 00:00:36.570
看到這麼多人來參加這個主題演講
我感到很欣慰

00:00:36.637 --> 00:00:38.105
很激動

00:00:38.405 --> 00:00:39.239
我叫Kate Stone

00:00:39.306 --> 00:00:42.910
我是Apple調試技術核心團隊的組長

00:00:43.644 --> 00:00:45.312
非常激動

00:00:45.379 --> 00:00:48.282
我希望能從我們的團隊中
請幾名工程師

00:00:48.348 --> 00:00:52.452
講一些新鮮事兒
如果你剛開始着手的話

00:00:52.519 --> 00:00:54.922
還有一些比較新鮮的小技巧

00:00:54.988 --> 00:00:58.592
即使你已經在你自己的平臺上做了十年
的調試工作 你仍然還會覺得新鮮

00:00:58.659 --> 00:01:02.262
這真的是個深水區
我們有很多內容要講

00:01:02.329 --> 00:01:03.363
讓我們開始吧

00:01:04.932 --> 00:01:09.403
特別注意
我們要講的技術就是LLDB

00:01:09.469 --> 00:01:11.505
若你用Xcode做過調試
你可能沒注意過

00:01:11.572 --> 00:01:14.842
後臺有一個叫做LLDB的技術

00:01:14.908 --> 00:01:17.945
這是一個底層調試工具
支持所有核心技術

00:01:18.545 --> 00:01:21.615
不僅僅存在於Xcode中
只要你需要 它無處不在

00:01:21.682 --> 00:01:24.518
但是 當然了 你跟它打交道
最多的地方之一

00:01:24.585 --> 00:01:27.120
是Xcode的調試控制檯

00:01:27.821 --> 00:01:30.858
Xcode把那個控制檯作爲調試區
的一個部分

00:01:31.925 --> 00:01:35.863
你將看到可視化的變量
同時也會看到這個LLDB控制檯

00:01:36.096 --> 00:01:38.632
我們今天要講的內容很多

00:01:38.899 --> 00:01:42.469
在那個提示框中
你可以獲得提示和一些很棒的東西

00:01:44.905 --> 00:01:46.940
當然 那個區域通常不只是包含

00:01:47.007 --> 00:01:50.611
LLDB的提示框以及
與調試器交互

00:01:50.677 --> 00:01:52.779
還包含你應用的輸出

00:01:52.846 --> 00:01:56.183
若是基於控制檯的應用 還可以鍵入

00:01:56.817 --> 00:01:58.685
那也許不是最便捷的方式

00:01:58.752 --> 00:02:01.355
如果你的應用利用了控制檯的其他功能

00:02:01.421 --> 00:02:05.993
如移動指針或色彩或其他
ANSI指針操作功能

00:02:06.326 --> 00:02:08.595
那麼 在Xcode 8中有個新選項

00:02:08.662 --> 00:02:12.199
允許你給你的應用分配獨立終端

00:02:12.266 --> 00:02:14.801
而LLDB仍留在Xcode中

00:02:14.868 --> 00:02:17.037
用起來很簡單 提出了選擇方案

00:02:17.938 --> 00:02:21.041
並且在最底部的選項標籤中
你能看到這個新控制檯

00:02:21.108 --> 00:02:26.079
你可以從默認切換到Xcode和終端

00:02:26.313 --> 00:02:28.382
然後 當你運行時
你將得到一個獨立終端

00:02:28.448 --> 00:02:31.652
用於處理應用的輸入和輸出
與Xcode是分離的

00:02:37.558 --> 00:02:40.360
接下來的演講 我們主要講LLDB

00:02:40.427 --> 00:02:43.130
若你對Xcode其它具體功能感興趣

00:02:43.497 --> 00:02:45.532
請查看這兩場演講的相關信息

00:02:45.599 --> 00:02:49.102
當然 演講已結束
但是你們可以看一下視頻

00:02:50.704 --> 00:02:53.440
你還要注意 LLDB不只是
Xcode的一部分

00:02:53.674 --> 00:02:57.110
而Swift REPL
其實就是LLDB

00:02:57.578 --> 00:03:00.080
當你打開Swift REPL
並開始跟它交互時

00:03:00.147 --> 00:03:02.816
你就已經在調試環境中了

00:03:02.883 --> 00:03:05.919
因此 無論什麼時候你需要調試器
它都在那兒

00:03:05.986 --> 00:03:08.422
事實上 我們今天要講的每個命令

00:03:08.488 --> 00:03:10.090
你都能在REPL中直接使用

00:03:10.157 --> 00:03:12.793
只需要在REPL的提示框中加個
冒號前綴即可

00:03:13.093 --> 00:03:16.930
先是冒號 然後是命令 這樣就能直接
在LLDB中發出命令了

00:03:17.664 --> 00:03:19.766
比如
我現在Swift REPL提示框

00:03:20.367 --> 00:03:23.570
此刻 我想查找某類型的信息

00:03:23.637 --> 00:03:26.240
當然 我可以打開Xcode並查看幫助

00:03:26.306 --> 00:03:27.774
但是在提示框中

00:03:28.108 --> 00:03:31.411
我可以簡單地使用
：type lookup Comparable

00:03:31.912 --> 00:03:34.414
我要查找這個協議 我發現事實上

00:03:34.481 --> 00:03:37.718
它是從另一個協議衍生出來的
添加了以下四個函數

00:03:38.285 --> 00:03:42.155
如果你熟悉並且一直在使用類型查找
它是個很棒的功能

00:03:42.222 --> 00:03:45.492
但你可能不會注意這一點
儘管它的名字是類型查找

00:03:45.559 --> 00:03:47.895
它實際上可以用來查找更多的東西

00:03:47.961 --> 00:03:50.831
實際上我可以查找函數
得到完整的簽名

00:03:51.265 --> 00:03:53.667
甚至可以查找整個模塊

00:03:53.734 --> 00:03:55.636
當然了 內容會很多

00:03:55.702 --> 00:03:58.872
因爲它是那個模塊中每個類型的
完整說明

00:03:59.072 --> 00:04:00.407
在這裏 我們把它簡化了

00:04:02.042 --> 00:04:05.679
那麼 REPL可以很好地處理
這種附加的命令

00:04:05.746 --> 00:04:11.552
還可以用來與你在REPL中寫的代碼
進行交互

00:04:11.818 --> 00:04:13.620
假如我寫一個簡單的函數

00:04:14.221 --> 00:04:17.391
我寫好了一個函數
當我在函數中時 我想停止

00:04:17.457 --> 00:04:19.459
查看某一行正在發生什麼

00:04:19.526 --> 00:04:21.361
那麼我可以發佈斷點命令

00:04:21.695 --> 00:04:23.730
加一個冒號前綴 ：b 2

00:04:23.797 --> 00:04:25.432
我在第二行設置了一個斷點

00:04:25.499 --> 00:04:28.769
當我調用這個函數時 正如我所
期待的那樣停止了

00:04:29.136 --> 00:04:33.006
因爲執行已經停止了
它會立即切回LLDB提示框

00:04:33.073 --> 00:04:34.541
在LLDB提示框中

00:04:34.608 --> 00:04:39.146
我可以發佈其他LLDB命令
進行交互並探測我的應用

00:04:39.446 --> 00:04:43.150
REPL還將自動進行這些操作
如果你遇到溢出的情況

00:04:43.217 --> 00:04:45.552
或一般會終止你應用的其他東西

00:04:45.619 --> 00:04:47.754
所以 你可以直接從Swift REPL中

00:04:47.821 --> 00:04:49.289
利用調試器的全部功能

00:04:50.324 --> 00:04:53.694
你還要注意 你可以隨時在兩個
提示框之間切換

00:04:53.760 --> 00:04:55.095
如果你在REPL提示框中

00:04:55.262 --> 00:04:59.533
只寫一個冒號 然後按Enter
將打開LLDB提示框

00:04:59.900 --> 00:05:02.636
而REPL命令將切回REPL提示框

00:05:02.703 --> 00:05:05.005
這樣 你可以隨時使用這兩個提示框

00:05:05.472 --> 00:05:07.174
REPL有一些不同的特點

00:05:07.241 --> 00:05:09.376
可能更適用於調試Swift代碼時

00:05:09.443 --> 00:05:10.711
的調試會話中

00:05:12.813 --> 00:05:13.647
這很棒

00:05:14.014 --> 00:05:17.084
這是大多數人跟LLDB互動的
主要方式

00:05:17.150 --> 00:05:20.220
但LLDB還是個獨立的
命令行工具

00:05:20.587 --> 00:05:23.590
如果我要遠程連接到一臺機器的
命令窗口 很奇妙

00:05:23.657 --> 00:05:25.125
我的連接很慢

00:05:25.192 --> 00:05:28.729
我非常想利用命令行工具

00:05:28.996 --> 00:05:31.131
但在其它環境下也很有用

00:05:31.198 --> 00:05:35.068
你可能想用它來 比如說
如果你正在自動化調試任務

00:05:35.369 --> 00:05:38.372
我想把調試器設置成每次開啓時
加載的命令都一樣

00:05:38.438 --> 00:05:40.741
所以我可能要提供

00:05:40.807 --> 00:05:44.378
一個包含一大堆LLDB命令的文件
用於進行配置

00:05:44.444 --> 00:05:48.115
LLDB -- source
後邊跟一個文件名

00:05:48.182 --> 00:05:51.151
這將調用LLDB並
source所有命令

00:05:51.218 --> 00:05:53.487
按照我想要的方式設置調試會話

00:05:54.688 --> 00:05:57.057
如果你不想陷入設置文件的麻煩中

00:05:57.124 --> 00:06:00.928
你可以調用LLDB
然後直接在命令行上寫命令

00:06:00.994 --> 00:06:04.464
-one-line接着是命令

00:06:04.531 --> 00:06:07.000
只要我啓動LLDB 就會發出命令

00:06:07.267 --> 00:06:09.303
如果我想附加命令

00:06:09.369 --> 00:06:12.372
我可以在這裏重複option的
簡化形式

00:06:12.439 --> 00:06:15.609
-o後邊跟着另一個命令
可以重複無數次

00:06:16.043 --> 00:06:19.146
所以 在自動化腳本中
把LLDB設置成

00:06:19.213 --> 00:06:20.480
我所期待的方式非常瑣碎

00:06:20.914 --> 00:06:24.017
當然 這也非常有價值

00:06:24.251 --> 00:06:28.488
如果我有一個應用
只有百分之一的錯誤率

00:06:28.555 --> 00:06:31.792
是一個竟用條件
我想一次次地運行同樣的調試順序

00:06:31.859 --> 00:06:34.695
我也有個特殊選項可以實現

00:06:35.662 --> 00:06:38.832
LLDB -- batch
啓動批處理模式

00:06:39.066 --> 00:06:43.804
那將執行我提供的指令
從單行命令或從文件中獲得

00:06:44.338 --> 00:06:48.041
並且假設我的應用正常運行
然後正常退出

00:06:48.942 --> 00:06:50.511
如果應用崩潰

00:06:50.577 --> 00:06:53.847
它會在LLDB提示框中停止
我可以查找問題所在

00:06:54.615 --> 00:06:58.085
當然 我可以用其他窗口命令
把它打包

00:06:58.151 --> 00:07:01.088
無限重複那一系列動作

00:07:01.154 --> 00:07:04.925
或者至少直到應用崩潰
並且我也準備好調查問題了

00:07:07.060 --> 00:07:09.496
LLDB有大量的選項

00:07:09.563 --> 00:07:11.932
如果你之前沒有看過
LLDB -- help

00:07:11.999 --> 00:07:15.235
我建議你看一看 幫助文檔中描述了
這些選項以及更多的內容

00:07:17.604 --> 00:07:21.675
我要在這裏介紹一個非常有趣的概念

00:07:22.209 --> 00:07:25.345
這可能是整場演講中
最無關緊要的事了

00:07:25.412 --> 00:07:28.382
那麼 如果你打算忘記某張幻燈片
請從這張開始

00:07:29.550 --> 00:07:32.886
因爲它大部分是透明的
你可能沒注意到效果

00:07:32.953 --> 00:07:35.856
我還想要介紹一些微妙的地方

00:07:36.089 --> 00:07:37.491
從Xcode 8開始

00:07:37.558 --> 00:07:40.928
LLDB已經從Xcode的程序中
完全分離

00:07:41.094 --> 00:07:42.462
它對你完全透明

00:07:42.529 --> 00:07:44.531
你按照你一般的調試方式開始調試

00:07:45.065 --> 00:07:49.403
支持多個不同的調試器版本

00:07:50.237 --> 00:07:51.905
它會自動爲你選擇

00:07:51.972 --> 00:07:55.409
因此 如果我要調試Swift 3
我會得到最新的調試器

00:07:55.475 --> 00:07:58.312
有我們在這場演講中介紹的所有功能

00:07:58.378 --> 00:08:02.883
其實若我使用純C++或
Objective C 也是一樣的

00:08:02.950 --> 00:08:06.186
我會得到最新的調試器
擁有我們在這裏講的所有功能

00:08:07.187 --> 00:08:09.590
另一方面
如果我調試Swift 2.3

00:08:09.656 --> 00:08:11.258
我將得到一個調試器

00:08:11.325 --> 00:08:16.263
其實是跟我們今年早些時候發佈
Xcode 7.3.1時一起發佈的

00:08:16.730 --> 00:08:18.765
意思是 有些新命令不可用

00:08:18.832 --> 00:08:23.237
但我們支持自Swift編譯器
時代的全部調試器

00:08:25.873 --> 00:08:27.307
但最重要的是

00:08:27.374 --> 00:08:29.176
如果你是我們開源社區中的一員

00:08:29.576 --> 00:08:32.379
你可以使用調試器進行調試

00:08:32.446 --> 00:08:35.349
該調試器與
你正使用的開源Swift匹配

00:08:35.414 --> 00:08:37.985
因此 如果你下載正在開發中的快照

00:08:38.051 --> 00:08:40.453
或如果你開始添加代碼

00:08:40.520 --> 00:08:42.756
那麼調試器會立即可用

00:08:42.823 --> 00:08:44.458
你可以使用那個

00:08:44.525 --> 00:08:48.662
同時調試在Swift 3或
Swift 2.3中寫的程序

00:08:48.729 --> 00:08:50.697
一切都是完全透明的

00:08:52.065 --> 00:08:54.168
有一個額外的好處：

00:08:54.234 --> 00:08:57.905
如果LLDB陷入了一個
不能繼續的情況

00:08:57.971 --> 00:09:00.040
它需要關閉調試會話

00:09:00.240 --> 00:09:01.742
調試會話將會被終止

00:09:01.808 --> 00:09:05.078
LLDB可以優雅地退出
而Xcode將繼續運行

00:09:09.082 --> 00:09:13.153
說起如何利用LLDB這個強大的工具

00:09:13.620 --> 00:09:17.191
以及如何自定義你的體驗
我要邀請我們的一位工程師上臺

00:09:17.257 --> 00:09:18.392
Enrico Granata

00:09:24.498 --> 00:09:26.400
謝謝Kate 大家好

00:09:27.267 --> 00:09:32.139
對於LLDB
我最看好的是調試器的定製性

00:09:32.573 --> 00:09:36.577
開啓調試器定製技術
不僅能收穫很大的樂趣

00:09:36.643 --> 00:09:39.847
還能讓你在調試應用的過程中

00:09:39.913 --> 00:09:41.582
獲得令人驚歎的效率

00:09:41.648 --> 00:09:46.353
LLDB提供許多切入點
你可以進行自定義

00:09:46.820 --> 00:09:48.755
你可以從命令別名開始

00:09:48.822 --> 00:09:53.160
然後以你的方式定製命令
或定製數據格式化程序

00:09:53.227 --> 00:09:56.964
在Xcode 8中
我們有一個新的擴展點

00:09:57.097 --> 00:09:58.498
階梯效應

00:09:59.700 --> 00:10:04.371
考慮階梯效應的方式是你想
讓下一行命令做什麼？

00:10:04.438 --> 00:10:06.240
你想讓階梯命令做什麼？

00:10:06.306 --> 00:10:09.276
但你是否發現你自己想要
以一種或兩種方式隨處

00:10:09.343 --> 00:10:11.578
調整它的行爲？

00:10:11.912 --> 00:10:14.581
通過階梯效應 你全部可以實現

00:10:15.682 --> 00:10:21.054
但使LLDB...自定義LLDB
滿足你需求的最簡單方式

00:10:21.121 --> 00:10:22.589
是創建一個命令別名

00:10:22.923 --> 00:10:25.592
這種方式需要取一段你頻繁使用的

00:10:25.659 --> 00:10:27.761
調試器語句

00:10:27.828 --> 00:10:30.531
並給它附上一段短語句

00:10:31.064 --> 00:10:36.537
現在 在Xcode 8中
你還可以附上幫助文本

00:10:36.603 --> 00:10:38.972
這樣可以達到你自己的或跟你一起分享

00:10:39.039 --> 00:10:41.842
那些別名的人目的

00:10:41.909 --> 00:10:44.144
可以幫你記住別名是幹什麼用的

00:10:44.678 --> 00:10:45.712
讓我們來看個例子

00:10:46.780 --> 00:10:50.384
首先 要創建別名
從command alias命令起

00:10:50.851 --> 00:10:54.154
然後 正如我剛說過的
你可以附上幫助文本

00:10:54.421 --> 00:10:57.491
你提供給我們一段短語句

00:10:57.791 --> 00:11:00.661
然後給我們一個你想要替換的
完整的調試器命令

00:11:01.261 --> 00:11:05.065
shell現在就是個正常的調試器命令

00:11:05.132 --> 00:11:07.334
跟我們內建的其他命令一樣

00:11:07.534 --> 00:11:09.503
你可以 比如 help shell

00:11:09.770 --> 00:11:13.607
它會顯示那些你定義的幫助文本

00:11:14.408 --> 00:11:19.012
在這些情況下 調試變得有些粗糙

00:11:19.079 --> 00:11:22.649
你可能在查找漏洞時忘記你自己是誰

00:11:22.716 --> 00:11:25.352
你可以要求調試器提醒你的身份

00:11:25.686 --> 00:11:28.655
它會像這樣通知你 我是Enrico

00:11:29.423 --> 00:11:33.060
這很棒 但如果你想做一些
更高級的事兒

00:11:33.126 --> 00:11:35.495
而不僅僅是給現有命令
附上一個新名稱

00:11:35.829 --> 00:11:38.265
我們還公佈了一Python API

00:11:38.532 --> 00:11:40.501
這是一個有相當廣泛選項的模型

00:11:40.567 --> 00:11:43.003
可以讓你按照你的意願綁定調試器

00:11:43.871 --> 00:11:46.340
相當容易上手

00:11:46.673 --> 00:11:50.177
我們在之前的WWDC演講中
曾詳細闡述過這個工具

00:11:50.244 --> 00:11:51.678
你可以看一下在線視頻

00:11:52.212 --> 00:11:55.682
我們有個網站 裏面有文檔和示例

00:11:56.016 --> 00:11:59.353
你可以在線搜索一下

00:11:59.553 --> 00:12:01.555
有一個社區在LLDB腳本處理方面

00:12:01.622 --> 00:12:02.990
做得很棒

00:12:03.891 --> 00:12:05.392
讓我們快速地看一個例子

00:12:05.959 --> 00:12:10.464
假如 我想要一個命令
可以讓我檢索

00:12:10.531 --> 00:12:13.800
調試時退出的最後一個函數的返回值

00:12:14.601 --> 00:12:15.736
這裏有一些注意事項

00:12:16.336 --> 00:12:20.607
這個命令只有在你執行完函數
並且之後不再執行任何

00:12:20.674 --> 00:12:23.877
階梯效應後
才起作用

00:12:24.111 --> 00:12:26.680
你可以鍵入表達式
你可以查看變量

00:12:26.747 --> 00:12:28.482
只要不單步跳過就沒問題

00:12:28.916 --> 00:12:30.651
讓我們快速看一個例子

00:12:30.984 --> 00:12:34.788
你導入一個包含那個命令的文件

00:12:35.255 --> 00:12:37.991
然後 正如我所說的
執行完函數

00:12:38.058 --> 00:12:40.527
就能看到返回值

00:12:40.627 --> 00:12:41.728
好的 很棒

00:12:41.795 --> 00:12:44.598
這是默認的 不需要自定義

00:12:44.765 --> 00:12:48.202
但是 比如說 如果我鍵入回溯

00:12:48.468 --> 00:12:51.271
這是個冗餘的回溯

00:12:51.338 --> 00:12:53.807
現在 我不記得返回值在哪兒了

00:12:54.007 --> 00:12:56.710
好的 我會進入終端
嘗試把它挖掘出來

00:12:56.977 --> 00:12:58.645
但是很幸運

00:12:58.979 --> 00:13:01.582
我們實際上可以寫一個命令
告訴我們答案

00:13:01.915 --> 00:13:04.985
從而再次得到返回值

00:13:07.087 --> 00:13:09.623
這就是再次得到返回值要做的
所有工作

00:13:09.857 --> 00:13:12.826
另外 不要再擔心讀取那個值了

00:13:12.893 --> 00:13:15.162
它會一直在那兒

00:13:16.196 --> 00:13:19.766
另一方面 你看到那是個文本

00:13:19.833 --> 00:13:23.370
現在你可以鍵入你的別名shell
鍵入文本

00:13:23.670 --> 00:13:25.606
你會發現你自己鍵入這些內容

00:13:25.672 --> 00:13:27.808
是因爲每次你開始調試時
它們都很棒

00:13:27.875 --> 00:13:29.810
你會一次一次再一次地鍵入它們

00:13:29.877 --> 00:13:34.281
直到你變成一隻會打字的猴子
你要做的就是鍵入這些內容

00:13:34.848 --> 00:13:36.884
不 我要說不

00:13:37.150 --> 00:13:40.554
我要說不要再讓你自己重複鍵入了

00:13:40.921 --> 00:13:41.989
完全沒必要

00:13:42.055 --> 00:13:44.157
LLDB有一個初始化文件

00:13:44.558 --> 00:13:48.529
叫做.llbdinit
就在你的主文件夾中

00:13:49.463 --> 00:13:53.033
如果你需要LLDB做一些特別的事
一些不同的事

00:13:53.100 --> 00:13:56.503
在Xcode下啓動或終端下啓動時

00:13:57.671 --> 00:14:00.340
有一個.llbdinit -Xcode文件

00:14:00.541 --> 00:14:04.511
當在Xcode下的調試器中啓動時
很好用

00:14:05.279 --> 00:14:06.380
還有一個訣竅

00:14:06.680 --> 00:14:09.750
如果你需要在調試器啓動時
帶有Python命令

00:14:10.050 --> 00:14:12.853
請不要把它們鍵入
.llbdinit中

00:14:13.120 --> 00:14:17.191
而是要把它們放在一個.py文件中
然後source該.py文件

00:14:17.524 --> 00:14:20.494
在.llbdinit中導入命令腳本

00:14:23.530 --> 00:14:26.967
如果你們用過LLDB

00:14:27.467 --> 00:14:30.604
你很可能非常熟悉p和po命令

00:14:31.305 --> 00:14:32.906
這些是很不錯的命令

00:14:33.207 --> 00:14:37.611
可以查找數據
因爲它們是完全表達式

00:14:38.078 --> 00:14:41.815
它們有你編寫應用所使用的語言的
全部功能

00:14:41.882 --> 00:14:44.051
你可以在調試器控制檯上使用

00:14:44.918 --> 00:14:48.288
另外 強大的功能伴隨着
重大的責任

00:14:49.156 --> 00:14:52.593
這些命令在你的目標進程中
運行代碼

00:14:52.726 --> 00:14:55.429
它們可能會導致一些副作用

00:14:55.729 --> 00:14:58.866
有時候 幾乎不可能

00:14:58.932 --> 00:15:01.768
在你當前停止的點上運行代碼

00:15:02.769 --> 00:15:07.508
如果p運行了一次代碼
那麼po實際上將運行兩次代碼

00:15:07.875 --> 00:15:11.245
因爲它不僅會評估你提供的表達式

00:15:11.311 --> 00:15:14.481
還會評估代碼

00:15:14.548 --> 00:15:17.384
以便以一種作者可定製的方式

00:15:17.451 --> 00:15:19.920
打印你的自定義類型

00:15:20.954 --> 00:15:25.359
這種方式很棒 如果作者給他們的類型
完全按照你想要的方式

00:15:25.425 --> 00:15:27.194
定製了顯示

00:15:27.661 --> 00:15:28.996
如果你沒那麼幸運

00:15:29.263 --> 00:15:32.099
p命令提供另一種變量視角

00:15:32.165 --> 00:15:33.767
可能更接近你想要的

00:15:34.468 --> 00:15:38.105
同時po是一個運行兩次的命令

00:15:38.172 --> 00:15:41.608
在編碼你的目標進程時也很可能
會產生副作用

00:15:42.643 --> 00:15:43.777
如果你擔心這個問題

00:15:44.311 --> 00:15:48.148
我們有另一個查看變量的
命令frame variable

00:15:48.549 --> 00:15:52.352
這是個可預見的命令
它不會運行任何代碼

00:15:52.953 --> 00:15:53.921
另一方面

00:15:53.987 --> 00:15:56.423
因爲它沒有運行代碼的能力

00:15:56.690 --> 00:15:59.860
它提供的語句也極其有限

00:16:01.562 --> 00:16:04.031
現在有很多方法可以查看數據

00:16:04.431 --> 00:16:08.969
但是劇透一下 在Xcode 8中
我們有更多方式來實現

00:16:10.771 --> 00:16:14.141
有兩種新方式
分別是parray和poarray

00:16:14.875 --> 00:16:17.644
是的 你說對了 聽起來像p和po

00:16:17.878 --> 00:16:20.347
但它們可以專門處理數組

00:16:21.415 --> 00:16:23.417
它們如何專門處理數組？

00:16:23.984 --> 00:16:24.818
嗯

00:16:26.019 --> 00:16:31.058
如果你在Objective C
或Swift數組中用過NS數組

00:16:31.124 --> 00:16:35.762
你習慣於安全容器
該容器知道包含了多少東西

00:16:36.296 --> 00:16:38.065
C指針並不能瞭解這個信息

00:16:38.265 --> 00:16:40.901
C指針並不包含某種電量模塊

00:16:41.068 --> 00:16:43.403
它們不知道要指向多少元素

00:16:43.637 --> 00:16:48.709
那麼 當我們像在這個調試器中
打印C指針時

00:16:49.042 --> 00:16:51.612
我們所能瞭解的只是指針的值

00:16:52.479 --> 00:16:54.581
但現在我們知道它指向一羣元素

00:16:54.648 --> 00:16:56.717
所以我們可以開始打印第一個

00:16:57.117 --> 00:16:58.285
打印第二個

00:16:58.886 --> 00:17:01.889
繼續依次打印 現在我們又變成
那隻打字的小猴子了

00:17:01.955 --> 00:17:03.290
我們並不想這樣

00:17:04.858 --> 00:17:05.692
嗯

00:17:06.859 --> 00:17:11.265
在Xcode 8中 你可以這樣處理
parray 元素個數 指針

00:17:11.665 --> 00:17:13.800
這會擴展指針

00:17:13.867 --> 00:17:17.171
就像指定元素個數的一個數組一樣

00:17:18.872 --> 00:17:20.641
謝謝 謝謝

00:17:22.409 --> 00:17:26.914
這個方案已經很好了 但我爲什麼
要猜測元素個數呢？

00:17:27.481 --> 00:17:30.150
它就在那兒 個數就在那兒

00:17:30.217 --> 00:17:35.422
我真正想要的是能鍵入parray
個數 數據集

00:17:36.456 --> 00:17:37.791
幾乎就要實現了

00:17:38.192 --> 00:17:40.894
我要做的就是把count
放在倒引號中

00:17:41.428 --> 00:17:45.365
那個倒引號是個常用的
LLDB語法功能

00:17:45.432 --> 00:17:48.168
可以讓你取出表達式
並進行評估

00:17:48.235 --> 00:17:52.005
然後在執行命令之前 在命令中
替換那個表達式的值

00:17:52.739 --> 00:17:55.509
現在 我已經顯示出了完整的數組

00:17:57.678 --> 00:17:58.512
謝謝大家

00:18:02.149 --> 00:18:04.384
而po也一樣

00:18:04.451 --> 00:18:06.453
poarray 元素個數

00:18:07.387 --> 00:18:10.891
指針 然後我得到了po式的對象描述

00:18:11.859 --> 00:18:13.961
在po的話題上

00:18:14.261 --> 00:18:17.965
我確定你們可以
寫Objective C代碼

00:18:18.031 --> 00:18:19.233
我確定有不少人

00:18:19.299 --> 00:18:23.704
就是那樣實現的
很可能沒有認真思考過

00:18:24.271 --> 00:18:25.906
你取出po 鍵入po

00:18:25.973 --> 00:18:29.176
接着是一個數字
恰巧你知道是個指針值

00:18:29.243 --> 00:18:31.111
然後你取回一個非常漂亮的描述

00:18:31.745 --> 00:18:35.916
你在Swift中嘗試做同樣的事
你取回的只是個數字

00:18:36.183 --> 00:18:37.784
爲什麼？怎麼回事？

00:18:38.685 --> 00:18:42.122
嗯 我確定你不止一次
聽過這樣的事

00:18:42.189 --> 00:18:43.824
但我再說一次

00:18:44.091 --> 00:18:46.994
Swift是一種比
Objective C類型更安全的語言

00:18:47.194 --> 00:18:50.130
我們不能假設數字是任意對象

00:18:50.197 --> 00:18:53.634
因爲並不是所有的Swift對象
都關聯着一個指針值

00:18:53.967 --> 00:18:57.471
那麼當我們po一個數字時
我們會得到數字

00:18:58.405 --> 00:19:01.408
好的 這很棒 但拜託
我知道那兒有個對象

00:19:01.475 --> 00:19:02.876
剛剛已經顯示出來了

00:19:03.677 --> 00:19:04.978
有一種方式可以實現

00:19:06.613 --> 00:19:07.447
就是這個

00:19:08.081 --> 00:19:10.651
看起來有很多詞 我知道

00:19:10.717 --> 00:19:13.020
但它實際上...聽我講

00:19:13.353 --> 00:19:16.757
expr -O的意思是po

00:19:17.291 --> 00:19:20.260
如果你在LLDB控制檯中
鍵入help po

00:19:20.460 --> 00:19:24.498
它將告訴你那是expr -O的
一個別名

00:19:25.065 --> 00:19:27.201
那麼我們實際上在這裏鍵入的是

00:19:27.534 --> 00:19:30.904
po這個東西 就像我們在
Objective C代碼中做的那樣

00:19:31.438 --> 00:19:35.075
這樣 我們實際上會得到
我們想要的描述

00:19:36.577 --> 00:19:37.644
這很棒

00:19:38.312 --> 00:19:42.349
在一個實際檢驗內存地址
相關的主題上

00:19:42.416 --> 00:19:43.984
並嘗試搞清楚它們的

00:19:45.285 --> 00:19:46.653
底層調試

00:19:47.487 --> 00:19:51.458
關於底層調試
如果你只記得一件事

00:19:51.725 --> 00:19:54.394
那就是離它越遠越好

00:19:54.628 --> 00:19:55.762
不要碰底層調試

00:19:59.399 --> 00:20:03.170
很不幸的是 有時候你必須得碰

00:20:03.904 --> 00:20:07.307
也許你要調試只存在於
你應用發佈版本中

00:20:07.374 --> 00:20:08.842
優化代碼的東西

00:20:08.909 --> 00:20:10.377
我有時候會遇到這種情況

00:20:11.245 --> 00:20:15.716
或者你要調試第三方代碼
而你沒有任何調試信息

00:20:16.583 --> 00:20:18.118
如果出現以上任意一種情況

00:20:18.719 --> 00:20:22.990
那麼請聽我講 在這段旅程中
我們將穿越赫丘利斯之柱

00:20:24.091 --> 00:20:29.129
但請注意 在這段旅程中
如要前行 風險自擔

00:20:31.598 --> 00:20:33.500
就像這樣開始

00:20:34.101 --> 00:20:37.004
去年 有一位先生來到我的實驗室

00:20:37.070 --> 00:20:40.307
拿着他的筆記本電腦
讓我看那種狀態下的Xcode

00:20:40.374 --> 00:20:43.210
在Objc msgSend中崩潰了

00:20:43.844 --> 00:20:45.112
他給我講了一個故事

00:20:45.512 --> 00:20:48.916
我在商店中有個應用
很棒

00:20:49.249 --> 00:20:50.918
然後 我的框架供應商對我說

00:20:50.984 --> 00:20:54.588
“嘿 我的框架有新版本了
更新一下吧 沒問題的 ”

00:20:54.955 --> 00:20:58.158
我就更新了 我聽了他的話
然後現在 我的應用一啓動就崩潰

00:20:58.225 --> 00:20:59.793
我該怎麼做 請幫幫我

00:21:00.394 --> 00:21:04.831
然後 我們坐下來 我告訴他說
“嗯 我們幾乎都不瞭解情況

00:21:04.898 --> 00:21:09.837
但有一件事我們可以做...
就是開始讀取機器寄存器”

00:21:10.604 --> 00:21:12.806
LLDB有一個功能可以實現
讀取寄存器

00:21:12.873 --> 00:21:17.010
它允許你查看所有寄存器
其中只有一小部分寄存器

00:21:17.077 --> 00:21:19.313
甚至會允許你進行
自定義格式化

00:21:19.947 --> 00:21:21.048
它是什麼樣的呢？

00:21:21.815 --> 00:21:23.016
鍵入register read

00:21:24.218 --> 00:21:25.853
你將得到你的寄存器的值

00:21:26.753 --> 00:21:27.988
這裏有很多寄存器

00:21:28.055 --> 00:21:32.426
那麼 我爲什麼要關心屏幕上所有
這些怪異的數字和文字呢？

00:21:32.626 --> 00:21:34.061
嗯 你一定要關心

00:21:35.095 --> 00:21:38.265
因爲參數通常是在寄存器中
進行傳遞的

00:21:38.832 --> 00:21:41.268
好的 很好玩兒
但寄存器也太多了

00:21:41.335 --> 00:21:43.637
我如何瞭解實際上哪個
比較重要呢？

00:21:44.204 --> 00:21:49.610
這個問題要問你平臺應用的
二進制ABI接口

00:21:49.676 --> 00:21:51.812
：convention
會提供一些規則

00:21:52.479 --> 00:21:54.815
但LLDB還提供

00:21:54.882 --> 00:21:59.553
便捷的僞寄存器的命名
像$arg1 $arg2等等

00:21:59.620 --> 00:22:04.057
適用於參數爲簡單計數器的情況

00:22:04.124 --> 00:22:05.492
或指針類型

00:22:05.559 --> 00:22:09.363
實際上寄存器和參數是一一對應的

00:22:10.030 --> 00:22:13.700
在C陣營表達式中也有類似的便捷方式

00:22:14.368 --> 00:22:15.502
比如說

00:22:16.537 --> 00:22:20.207
如果我有個函數讀取這三個參數
然後我調用函數

00:22:20.874 --> 00:22:26.313
這些參數實際上將一對一映射爲
$arg1 $arg2和$arg3

00:22:27.648 --> 00:22:30.217
好的 這符合我們的情況

00:22:30.284 --> 00:22:33.987
在Objc msgSend中
我們開始讀取參數

00:22:34.521 --> 00:22:37.491
第一個參數是
指針 0 X 4 D 2

00:22:37.724 --> 00:22:40.894
第二個參數是選擇器符字符
緊接着一個附加字符

00:22:41.361 --> 00:22:44.531
我們恰巧知道Objc
msgSends的第一個參數

00:22:44.598 --> 00:22:46.667
是我們嘗試與對象
進行通訊的參數

00:22:46.733 --> 00:22:49.436
第二個參數是我們嘗試
要發送的選擇符

00:22:50.204 --> 00:22:52.506
且我們還可使用
memory read命令

00:22:52.573 --> 00:22:55.375
來查看我們要通訊的那個對象
到底怎麼了

00:22:55.809 --> 00:22:57.711
原來那是個不好的對象

00:23:01.582 --> 00:23:02.616
實際情況是

00:23:02.683 --> 00:23:05.552
我們在一個壞的對象上調用
這個選擇符

00:23:06.053 --> 00:23:07.387
我們是如何變成這樣的呢？

00:23:09.189 --> 00:23:12.626
嗯 在Objc msgSend中
崩潰了

00:23:12.960 --> 00:23:16.964
有東西調用了Objc msgSend
有東西調用了那個調用Objc msgSend的東西

00:23:17.030 --> 00:23:18.332
以此類推

00:23:18.398 --> 00:23:21.768
直到我們到達應用的切入點

00:23:22.603 --> 00:23:27.307
在LLDB中 我們從最小的
框架0開始調用

00:23:27.574 --> 00:23:30.511
一直到最大的框架N

00:23:30.978 --> 00:23:32.813
並且 如果你想移動到某個框架

00:23:33.113 --> 00:23:34.648
你可以使用up命令

00:23:34.715 --> 00:23:37.417
返回到堆棧上的一個編號較大的框架

00:23:37.484 --> 00:23:40.554
down命令可以返回到
編號較小的框架

00:23:42.656 --> 00:23:46.126
另一個需要了解的是
disassemble命令

00:23:46.193 --> 00:23:48.862
可以讓你反彙編一個函數

00:23:49.363 --> 00:23:52.399
你可以用在當前函數、任意框架、

00:23:52.633 --> 00:23:54.902
地址、函數名稱上

00:23:55.102 --> 00:23:57.437
你可以自定義反彙編的顯示方式

00:23:57.738 --> 00:24:00.207
在某些情況下 它會在有源代碼

00:24:00.407 --> 00:24:02.476
和調試信息的地方執行調試

00:24:02.543 --> 00:24:05.879
但如果你想比較這些指令
和機器指令

00:24:05.946 --> 00:24:11.518
你還可以讓LLDB總是隨着
源代碼一起顯示反彙編

00:24:12.052 --> 00:24:13.153
那麼在我們的例子中

00:24:14.855 --> 00:24:17.925
我們在那兒崩潰了 我們可以
看到誰調用了函數

00:24:17.991 --> 00:24:19.793
是一個啓動完成的應用

00:24:20.027 --> 00:24:23.764
讓我們快速看一眼那個函數
正在做什麼

00:24:26.667 --> 00:24:29.069
那個函數正在調用這個
初始化程序

00:24:29.136 --> 00:24:33.240
框架供應商告訴我們 “是的
編碼那個初始化程序getGlobalToken”

00:24:33.607 --> 00:24:35.375
它正在來回來去地填充東西

00:24:35.442 --> 00:24:39.179
然後調用Objc msgSend
我們就崩潰了

00:24:40.514 --> 00:24:44.952
那麼我們可以單步跳過機器編碼
並查看這些調用實際上是在做什麼

00:24:45.219 --> 00:24:48.755
首先 我們單步跳過
getGlobalToken調用

00:24:49.189 --> 00:24:52.125
然後我要做個弊

00:24:52.392 --> 00:24:56.029
我恰巧知道寄存器叫做rax

00:24:56.296 --> 00:24:58.398
包含那個函數的返回值

00:24:58.665 --> 00:24:59.900
若我讀取這個函數返回值

00:25:01.568 --> 00:25:03.470
我只能得到不正確的指針值

00:25:03.937 --> 00:25:05.138
有意思

00:25:05.472 --> 00:25:07.708
讓我們再做幾次單步跳過

00:25:08.208 --> 00:25:10.677
不 並沒有修改它 並沒有修改它

00:25:11.211 --> 00:25:14.815
我們正在做的是取出那個指針值
不做任何修改

00:25:14.882 --> 00:25:16.783
並把它移動到rdi中

00:25:17.150 --> 00:25:19.720
然後調用Objc msgSend

00:25:20.153 --> 00:25:21.722
我在想是否關聯？

00:25:22.289 --> 00:25:25.626
如果我在這時候
在進入Objc msgSend之前

00:25:25.826 --> 00:25:28.662
reg read $arg1

00:25:30.264 --> 00:25:32.366
rdi是不正確的指針值

00:25:33.600 --> 00:25:35.369
我們證明瞭什麼呢？

00:25:35.435 --> 00:25:38.705
我們證明瞭
getGlobalToken函數

00:25:38.772 --> 00:25:41.575
就是我們的框架供應商非常激動地
讓我們調用的函數

00:25:41.642 --> 00:25:43.844
實際上給我們返回了一個
不正確的對象

00:25:44.044 --> 00:25:47.080
一嘗試給那個不正確的對象
發送消息

00:25:47.414 --> 00:25:50.584
就會收到一個大驚喜
我們的應用就會崩潰

00:25:51.318 --> 00:25:53.754
最後驗證了我們的情況後

00:25:53.820 --> 00:25:55.822
輕輕拍了拍我們的背

00:25:56.156 --> 00:25:58.258
接着有請
Sean Callanan上臺

00:25:58.325 --> 00:26:01.595
他會講解表達式解析器
相關的新特性 謝謝

00:26:07.734 --> 00:26:08.836
不覺得神奇嗎？

00:26:09.203 --> 00:26:10.237
感覺像魔術一樣

00:26:10.304 --> 00:26:13.740
你的程序只是把數據以數字、數字數組

00:26:14.041 --> 00:26:15.475
的方式進行存儲

00:26:16.109 --> 00:26:19.012
但你可以用LLDB這個強大的工具

00:26:19.446 --> 00:26:22.983
以你想要的方式來表現數據

00:26:25.219 --> 00:26:26.286
有時候

00:26:26.720 --> 00:26:30.624
並不是隻看數字和判斷是什麼數據

00:26:31.225 --> 00:26:32.860
那麼容易

00:26:33.861 --> 00:26:36.330
有時候你需要使用表達式解析器

00:26:37.164 --> 00:26:38.632
Enrico已經展示了

00:26:38.699 --> 00:26:42.269
表達式解析器在一般情況下的
命令語句

00:26:42.636 --> 00:26:44.404
但是它還有好多功能

00:26:45.572 --> 00:26:50.878
表達式解析器的工作是跟你的程序
和SDK一起運行

00:26:51.745 --> 00:26:54.882
在你當前的斷點上

00:26:55.582 --> 00:27:00.120
表達式解析器通過變形數據
來得到你想要

00:27:01.054 --> 00:27:04.057
實際檢測的數據

00:27:05.559 --> 00:27:10.831
我說過
程序和SDK是一起運行的

00:27:11.732 --> 00:27:15.636
回憶一下前幾年的情況
SDK在LLDB中運行

00:27:15.702 --> 00:27:17.571
並不總是那麼容易

00:27:18.939 --> 00:27:22.109
那麼比如說 如果你在
Objective C程序上斷點了

00:27:22.576 --> 00:27:25.812
你嘗試獲取程序的撤銷管理器

00:27:27.247 --> 00:27:31.919
你很可能會得到至少一次
或兩次煩人的報錯

00:27:33.020 --> 00:27:37.024
這跟你正在嘗試做的完全無關

00:27:37.858 --> 00:27:39.193
真是莫名其妙

00:27:39.726 --> 00:27:42.429
但是去年我們就講了一個
解決方式

00:27:44.364 --> 00:27:48.368
如果你手動導入AppKit

00:27:49.736 --> 00:27:52.606
那麼你的表達式就能起作用了

00:27:53.273 --> 00:27:56.677
好吧 但是我們爲什麼要這麼做呢？
它已經在那兒了

00:27:58.445 --> 00:27:59.479
我都能聽見你在哀嚎

00:28:02.516 --> 00:28:03.750
並非只有你一個人遇到這種情況

00:28:05.052 --> 00:28:09.323
因此今年我們考慮如何使這個
方式變得更好

00:28:10.290 --> 00:28:11.558
效果非常明顯

00:28:12.259 --> 00:28:15.462
我們查看了當前源文件導入的
那個模塊

00:28:16.129 --> 00:28:18.332
然後就自動導入

00:28:18.532 --> 00:28:20.868
不再需要手動導入了

00:28:26.807 --> 00:28:27.641
很酷

00:28:27.708 --> 00:28:30.544
我們可以更有效地擺脫
手動實現方式

00:28:30.878 --> 00:28:34.348
非常棒 但我們認爲這是一個
很強大的工具

00:28:34.815 --> 00:28:39.353
讓我來講一下這個工具的一些
不錯的功能

00:28:40.687 --> 00:28:44.424
現在 有時候 這種便捷可能會
阻礙你的開發

00:28:44.491 --> 00:28:48.328
你實際上想手動地導入
你想要的東西

00:28:49.263 --> 00:28:50.464
有個功能可以實現

00:28:50.764 --> 00:28:55.102
有一個設置
你可以禁用自動導入功能

00:28:55.169 --> 00:28:58.071
然後你就能使用去年的老功能了

00:28:58.972 --> 00:29:01.608
我們認爲你一定會喜歡上這個功能
它的默認狀態爲開啓

00:29:02.709 --> 00:29:03.544
很好

00:29:03.877 --> 00:29:07.881
現在 讓我們談談
如何通過重用代碼

00:29:08.448 --> 00:29:10.017
有效地使用表達式解析器

00:29:11.985 --> 00:29:16.790
重用代碼最簡單的情況是
重用變量

00:29:17.758 --> 00:29:22.162
請記住 我說過
你可能需要做多級表達式

00:29:22.596 --> 00:29:26.433
從你當前位置獲得你實際
想要的數據

00:29:27.701 --> 00:29:32.706
在Swift中 你可以執行像定義
和使用

00:29:33.006 --> 00:29:33.841
臨時變量那麼簡單的操作

00:29:35.175 --> 00:29:37.978
這就能解決問題 就像你在你自己的
程序中鍵入一樣

00:29:39.313 --> 00:29:43.684
現在 可能會超出你想象的是如果
你再次使用它 會發生什麼

00:29:44.818 --> 00:29:47.221
那麼我們會問
變量名稱是什麼？

00:29:49.122 --> 00:29:52.526
嗯 實際上我們刻意
讓它這樣工作

00:29:53.060 --> 00:29:56.230
原因是你可能會單步跳過

00:29:56.296 --> 00:29:58.365
你可能會在不同的地方設置斷點

00:29:58.432 --> 00:30:02.603
也許稍後 你會位於一個程序
定義A的地方

00:30:02.836 --> 00:30:06.273
我們希望作爲臨時變量的A
給你帶來阻礙嗎？

00:30:07.174 --> 00:30:10.777
很可能不希望
但有一個解決方法

00:30:14.047 --> 00:30:16.517
我們可以設置一個功能可見性

00:30:16.917 --> 00:30:20.087
確保你的變量不會像那樣消失

00:30:20.153 --> 00:30:22.222
實際上我們會設置一個
本地環境

00:30:22.289 --> 00:30:25.626
就像你在程序中添加了
一對大括號

00:30:25.959 --> 00:30:28.195
把let A放在大括號中
然後是打印

00:30:29.329 --> 00:30:31.365
但是如果你想讓A起作用

00:30:31.798 --> 00:30:34.401
你要做的就是給它一個專用名稱

00:30:34.868 --> 00:30:36.336
一個名稱外加$符號

00:30:37.171 --> 00:30:40.941
意思是 它將永遠不會跟你自己的
程序名稱衝突

00:30:41.875 --> 00:30:45.846
這意味着只要你的調試會話存在
它就會存在

00:30:47.080 --> 00:30:47.915
了不起

00:30:48.448 --> 00:30:51.251
你還可以用這個工具做什麼？
可以做很多

00:30:52.719 --> 00:30:55.956
在Swift中
自LLDB和Swift發佈的第一天起

00:30:56.023 --> 00:30:58.559
你就可以用函數來解決
同樣的問題

00:30:59.626 --> 00:31:01.328
現在 當你解決問題時

00:31:01.395 --> 00:31:05.132
你很可能想要使用
多行表達式模式

00:31:05.199 --> 00:31:08.101
事實上 如果你鍵入表達式命令
並按下Enter鍵

00:31:08.168 --> 00:31:10.504
你會立即打開一個多行編輯器

00:31:10.571 --> 00:31:12.873
你可以鍵入你自己的函數

00:31:13.640 --> 00:31:15.108
如果你定義你的函數

00:31:15.843 --> 00:31:20.514
你就可以簡便地重用這個函數
請不要忘了$符號

00:31:22.015 --> 00:31:25.853
若你們曾在Swift中嘗試過
這樣做並且說過“太棒了！”

00:31:26.286 --> 00:31:28.155
你可能在Objective C中
也嘗試過了

00:31:29.690 --> 00:31:32.492
效果並沒那麼好

00:31:34.061 --> 00:31:36.296
這裏不允許函數定義

00:31:36.630 --> 00:31:38.999
“不是吧 LLDB那東西
總是會妨礙我 ”

00:31:39.399 --> 00:31:43.837
好吧 嗯 看起來我們
也喜歡這個功能

00:31:43.904 --> 00:31:45.739
我們認爲這功能很不錯
我們想讓它變得更好

00:31:46.807 --> 00:31:50.110
但我們不能讓它變得那麼神奇

00:31:50.377 --> 00:31:54.248
因爲 你記得吧
我們在你的代碼中停止了

00:31:54.615 --> 00:31:57.751
我們想表現得像在你的函數內一樣

00:31:58.652 --> 00:32:01.588
如果你在Swift中
你可以定義餘下的函數

00:32:01.655 --> 00:32:03.690
沒什麼大不了的
編譯器會喜歡的

00:32:03.757 --> 00:32:06.493
它不喜歡$符號
你可以去掉它

00:32:06.560 --> 00:32:08.262
但餘下的就沒什麼問題了

00:32:08.996 --> 00:32:10.097
這完全合法

00:32:11.665 --> 00:32:14.234
但是在C、C++
和Objective C中

00:32:14.301 --> 00:32:16.970
嘗試像那樣處理餘下的函數

00:32:17.137 --> 00:32:19.706
沒有用 編譯器會對你咆哮的

00:32:22.276 --> 00:32:28.715
嗯 避免方式是使用
頂層表達式模式

00:32:29.383 --> 00:32:31.752
是expression命令的
一個擴展

00:32:31.818 --> 00:32:32.986
可以使它完全脫離

00:32:33.053 --> 00:32:36.056
你停止的那個當前函數

00:32:36.123 --> 00:32:38.058
並定義全局代碼

00:32:38.559 --> 00:32:41.328
可以是函數或變量或其他你想要的

00:32:42.129 --> 00:32:45.499
現在 你可以定義函數
並按照你期待的方式使用函數

00:32:46.733 --> 00:32:47.568
好的

00:32:48.502 --> 00:32:52.139
現在 函數不是你可以定義的
唯一能重用的東西

00:32:52.206 --> 00:32:55.442
我已經講過變量了
你還可以定義閉包

00:32:55.509 --> 00:32:58.111
閉包是變量和代碼的一種合併

00:32:59.146 --> 00:33:00.881
在Swift中 你可定義一個閉包

00:33:00.948 --> 00:33:01.782
並使用它

00:33:02.916 --> 00:33:04.585
今年 Xcode有了新特性

00:33:05.219 --> 00:33:07.154
你可在Objective C中
實現同樣的功能

00:33:07.554 --> 00:33:09.957
你可以定義和重用塊

00:33:11.124 --> 00:33:14.394
如果你是C++的鐵桿粉絲

00:33:14.461 --> 00:33:16.730
你可以用匿名函數實現
完全一樣的功能

00:33:18.599 --> 00:33:19.433
現在

00:33:20.501 --> 00:33:23.170
你可以用這些塊做什麼呢？
它們有什麼特殊作用呢？

00:33:23.370 --> 00:33:25.939
嗯 比如說
你可以把它們傳給函數

00:33:26.773 --> 00:33:30.611
有時候你可能需要在指定隊列上
手動運行某些東西

00:33:31.845 --> 00:33:32.679
那樣是可以的

00:33:33.013 --> 00:33:35.449
你可以把素材發送給
比如說 一個全局隊列

00:33:35.749 --> 00:33:37.217
塊就會運行

00:33:38.585 --> 00:33:39.419
現在

00:33:40.420 --> 00:33:43.123
有時候有點兒煩人

00:33:43.457 --> 00:33:49.496
因爲這些複雜的表達式會增加
錯別字的出現頻率

00:33:50.564 --> 00:33:52.132
現在 不同的是

00:33:52.733 --> 00:33:55.469
速度很快 不用回頭看之前的代碼

00:33:55.536 --> 00:33:58.672
在這個表達式和之前代碼中的表達式？

00:33:59.439 --> 00:34:00.607
你很可能會錯過它

00:34:00.707 --> 00:34:02.276
但編譯器一定不會錯過它

00:34:02.943 --> 00:34:06.246
如果丟了分號
編譯器會對你咆哮

00:34:07.814 --> 00:34:09.216
但還有個更好的方式

00:34:09.583 --> 00:34:13.152
如果你在源編輯器中鍵入
我們會告訴你

00:34:13.453 --> 00:34:16.556
“這裏很可能丟失了一個分號
你想加上它嗎？”

00:34:18.192 --> 00:34:21.728
嗯 看起來LLDB可以實現
同樣的功能

00:34:21.995 --> 00:34:23.496
並且我們可以做得更好

00:34:23.563 --> 00:34:26.967
只需要自動添加遺失的分號

00:34:27.266 --> 00:34:28.534
然後就能運行表達式了

00:34:28.902 --> 00:34:30.571
我們管這個叫做修訂

00:34:30.871 --> 00:34:34.808
以前是在Clang中使用
現在LLDB也可以實現同樣的功能了

00:34:36.777 --> 00:34:38.512
Swift中也有修訂

00:34:39.646 --> 00:34:42.815
在Swift中 你不太可能會遇到
分號問題

00:34:43.083 --> 00:34:45.418
但是同志們 那些感嘆號很煩人

00:34:49.056 --> 00:34:53.860
是的 嗯 它們很有用 因爲它們
在你自己的代碼中

00:34:53.927 --> 00:34:56.096
當你調試時 幫助你理解它

00:34:56.163 --> 00:34:58.131
你只是希望它們不要阻礙你

00:34:58.599 --> 00:35:00.234
相信我 我們也是這麼想的

00:35:01.668 --> 00:35:04.872
如果你嘗試使用一些沒有
解包的東西

00:35:06.039 --> 00:35:08.075
我們就會應用修訂併爲你解包

00:35:09.209 --> 00:35:12.045
現在 可能會有一兩個人

00:35:12.112 --> 00:35:14.548
說“我不希望調試器碰我的代碼 ”

00:35:15.048 --> 00:35:15.883
現在

00:35:18.285 --> 00:35:20.988
對於這些人 我也有過這樣的顧慮

00:35:21.688 --> 00:35:23.524
我們有設置

00:35:23.824 --> 00:35:26.960
可以關閉整個自動應用修訂功能

00:35:27.628 --> 00:35:31.198
如果你不喜歡調試器
自鳴得意地指出

00:35:31.265 --> 00:35:34.001
你代碼中的每一個小錯誤
併爲你修改好

00:35:34.101 --> 00:35:36.303
那麼你也可以關閉那部分功能

00:35:37.871 --> 00:35:38.705
好的

00:35:39.573 --> 00:35:40.407
謝謝

00:35:44.745 --> 00:35:45.579
好了

00:35:45.846 --> 00:35:48.182
很好 這是個不錯的便捷功能

00:35:48.248 --> 00:35:51.985
但是我還要提另一個

00:35:52.052 --> 00:35:53.854
你能定義爲可重用的東西

00:35:55.155 --> 00:35:56.857
你可以在Swift中定義你自己的類型

00:35:57.925 --> 00:36:00.761
比如說
你可以輸入多行表達式

00:36:00.827 --> 00:36:02.196
定義一個類

00:36:03.130 --> 00:36:05.933
當你嘗試實例化那個類時

00:36:05.999 --> 00:36:08.435
它就是這樣

00:36:08.502 --> 00:36:11.004
就像你已經在程序中
定義過的類一樣

00:36:12.239 --> 00:36:17.411
在C++中也一樣 你可以定義
一個類並重用它

00:36:19.513 --> 00:36:22.716
現在讓我們來看個例子

00:36:22.783 --> 00:36:25.786
我們可以在你自己的程序中
使用所有這些概念

00:36:28.422 --> 00:36:32.693
通常尤其是當你的程序
與web API交互時

00:36:32.759 --> 00:36:35.229
你會得到返回的許多數據
你想要篩選數據

00:36:35.295 --> 00:36:36.797
尤其是當你正在調試時

00:36:37.698 --> 00:36:41.401
篩選數據的方式
尤其是在NS數組中

00:36:41.602 --> 00:36:43.203
是通過定義一個判斷實現的

00:36:44.438 --> 00:36:48.342
現在 在表達式分析器中
你可以定義自定義判斷

00:36:49.076 --> 00:36:52.346
在這種情況下 我們寫一個塊

00:36:52.646 --> 00:36:56.383
從web服務器取出結果字符串

00:36:56.917 --> 00:37:01.054
進行篩選 查找有文本錯誤的字符串

00:37:01.755 --> 00:37:03.190
很可能有利於調試

00:37:04.258 --> 00:37:09.530
現在 如果你只從web服務器
取出完整數據的數組

00:37:10.464 --> 00:37:12.432
然後就應用判斷

00:37:12.599 --> 00:37:15.869
你可以立即獲得
你實際關心的消息

00:37:18.338 --> 00:37:23.076
現在你已經瞭解表達式分析器
是如何強大了

00:37:23.143 --> 00:37:24.978
接着有請
Jim Ingham上臺

00:37:25.045 --> 00:37:27.147
他會給你們講LLDB更強大的特性

00:37:32.319 --> 00:37:33.153
謝謝 Sean

00:37:33.353 --> 00:37:36.657
目前我們已經按先後順序

00:37:36.723 --> 00:37:40.160
講瞭如何當你停止後

00:37:40.227 --> 00:37:42.529
查看程序狀態 但我們還沒講

00:37:42.596 --> 00:37:44.865
如何得到這樣一個有趣的點

00:37:44.932 --> 00:37:46.834
這是我要跟你們講的內容

00:37:47.267 --> 00:37:51.839
當然 斷點是停止程序的一種
順其自然的方式

00:37:51.905 --> 00:37:56.476
那麼 我想談談你們覺得斷點
就是自然而然地

00:37:56.543 --> 00:37:59.580
在我設置斷點的地方停止
我的程序

00:37:59.713 --> 00:38:03.550
但這並不是它們的實現方式
LLDB也不是這麼認爲的

00:38:03.750 --> 00:38:07.221
對於LLDB來說
斷點其實是一個搜索

00:38:07.287 --> 00:38:10.757
在你的程序空間中尋找這些
有趣的位置以便停止

00:38:10.824 --> 00:38:13.360
事實證明也許是很多不同的搜索

00:38:14.027 --> 00:38:16.730
因此 斷點其實是搜索條件

00:38:16.797 --> 00:38:20.734
你停止的個別位置

00:38:20.801 --> 00:38:23.036
就是你認爲的那個
自然而然的斷點

00:38:23.103 --> 00:38:25.138
我們叫做斷點位置

00:38:25.372 --> 00:38:29.209
讓我們具體講一下 我要把這個
連到Xcode的斷點

00:38:29.276 --> 00:38:33.447
因爲不管怎樣 當使用LLDB調試時
Xcode都在幕後

00:38:33.514 --> 00:38:37.217
所以 Xcode斷點必須
都得是LLDB斷點

00:38:37.284 --> 00:38:41.588
那麼比如說 當你在Xcode中
點擊源邊列時

00:38:41.688 --> 00:38:44.858
你實際正在做的是在LLDB中
運行這條命令

00:38:44.925 --> 00:38:46.627
有些斷點設置命令

00:38:46.894 --> 00:38:49.229
類似地 當你做符號斷點時

00:38:49.296 --> 00:38:52.399
你正在運行一個按名稱
設置的斷點

00:38:52.833 --> 00:38:56.970
那麼我想讓你們有一點概念
就是這些實際上是搜索

00:38:57.037 --> 00:38:58.572
我要演示一些例子

00:38:58.639 --> 00:39:02.776
從而你可以自然而然地得到
多種結果

00:39:02.843 --> 00:39:06.146
雖然以前你覺得只是一個
單一的斷點設置

00:39:06.446 --> 00:39:10.651
那麼 第一個例子是符號斷點

00:39:10.851 --> 00:39:14.221
這是一個只在主函數上
設置斷點的例子

00:39:14.288 --> 00:39:16.156
這應該很簡單 對吧？

00:39:16.223 --> 00:39:18.692
但是稍後它會告訴你
“不 我有19個位置 ”

00:39:18.759 --> 00:39:20.561
爲什麼最終會得到19個呢？

00:39:20.861 --> 00:39:24.398
執行break list命令是不是
查看斷點設置的結果

00:39:24.464 --> 00:39:28.202
你看到的是斷點名稱搜索

00:39:28.268 --> 00:39:31.305
實際上是一個不精確的
名稱匹配搜索

00:39:31.371 --> 00:39:35.075
那麼比如說 它在一個類中
選取了選擇器名稱

00:39:35.142 --> 00:39:37.044
在很多情況下
這樣的確很方便

00:39:37.110 --> 00:39:40.714
因爲就像你在C++中調試時
你有命名空間、

00:39:40.781 --> 00:39:43.050
命名空間內部、類、方法

00:39:43.116 --> 00:39:47.154
你並不想鍵入整條路徑

00:39:47.521 --> 00:39:48.922
另一方面 也確實意味着

00:39:48.989 --> 00:39:51.992
搜索也許比你想要的範圍更廣

00:39:52.526 --> 00:39:54.862
我們提供很多不同類型的搜索

00:39:54.928 --> 00:39:57.865
當然 我們提供更精確的搜索

00:39:57.931 --> 00:40:01.869
即全名搜索 強制名稱匹配

00:40:01.935 --> 00:40:05.305
你指定的符號全名

00:40:05.639 --> 00:40:07.875
我們嘗試過 但就算那樣也不行

00:40:08.141 --> 00:40:10.911
因爲某些原因
某人決定在庫內加

00:40:10.978 --> 00:40:13.514
一個函數調用主函數
不知道爲什麼 但確實起作用了

00:40:13.814 --> 00:40:16.350
因此 你甚至可以指定

00:40:16.416 --> 00:40:19.119
通過shlib選項

00:40:19.186 --> 00:40:21.822
限制搜索特定的共享庫

00:40:21.889 --> 00:40:24.558
那麼最後 你就得到
你想要的斷點了

00:40:24.625 --> 00:40:27.494
我要再舉一個例子 不是因爲
我認爲你們不相信我

00:40:27.561 --> 00:40:30.297
而是因爲這個例子
經常會在Swift中出現

00:40:30.364 --> 00:40:32.132
文件和行斷點

00:40:32.332 --> 00:40:34.201
因爲Swift有個不錯的功能

00:40:34.268 --> 00:40:36.904
就是你調用一個使用閉包

00:40:36.970 --> 00:40:39.706
並定義閉包函數的函數

00:40:39.773 --> 00:40:42.709
簡單地通過用波形號來繼續

00:40:42.776 --> 00:40:45.012
然後接着是閉包體

00:40:45.179 --> 00:40:47.548
但是 如果你嘗試在那行設置斷點

00:40:47.614 --> 00:40:50.584
你就會發現有兩個停止的點

00:40:50.651 --> 00:40:51.652
爲什麼會這樣？

00:40:52.019 --> 00:40:54.688
你觀察時 你覺得很簡單
對吧？

00:40:54.855 --> 00:40:59.960
源代碼行實際上給閉包函數
提供了一些代碼

00:41:00.027 --> 00:41:03.664
你可以看到 我們在閉包函數上
有一個斷點位置

00:41:03.931 --> 00:41:07.501
但是它也是函數引用的位置

00:41:07.701 --> 00:41:10.537
因此還有一個位置是
那個引用的位置

00:41:12.172 --> 00:41:14.208
那麼無論怎麼樣 就是這樣

00:41:14.274 --> 00:41:16.910
已經講了一些例子

00:41:16.977 --> 00:41:19.079
我要給你們一個命令的通用格式

00:41:19.146 --> 00:41:22.850
然後再繼續講其他功能

00:41:23.317 --> 00:41:25.652
斷點設置命令是這樣的：

00:41:25.719 --> 00:41:27.187
鍵入break set

00:41:27.254 --> 00:41:30.390
然後有一些指定類型的選項

00:41:30.958 --> 00:41:34.661
這是指定你要進行
哪種搜索的選項

00:41:34.728 --> 00:41:36.930
是文件和行搜索
還是符號名搜索

00:41:36.997 --> 00:41:38.131
等等諸如此類？

00:41:38.198 --> 00:41:43.036
那個類型選項的值是用於
搜索的數據

00:41:43.270 --> 00:41:48.108
然後還有其他選項 比如忽略計數
條件 等等

00:41:48.175 --> 00:41:52.412
這些選項規定的不是指定
在哪兒中斷

00:41:52.479 --> 00:41:54.314
而是規定是不是中斷

00:41:55.415 --> 00:41:59.253
所以 搜索後是否可以修改

00:41:59.419 --> 00:42:02.089
是不能改變的
因爲我們已經搜索完了

00:42:02.155 --> 00:42:04.658
如果你希望這樣做的話
你只能設置一個新斷點來實現

00:42:04.725 --> 00:42:07.394
讓我們講講斷點位置相關的事

00:42:07.461 --> 00:42:09.630
斷點位置就是你要停止的位置

00:42:09.696 --> 00:42:11.765
它們是個別的搜索結果

00:42:11.965 --> 00:42:13.333
一般都會有地址

00:42:13.400 --> 00:42:16.270
是程序要叫停的地址

00:42:17.070 --> 00:42:21.542
當你查看它們時
它們通過生成斷點和位置編號被指定

00:42:21.642 --> 00:42:24.244
通過一個點分開

00:42:24.311 --> 00:42:27.714
因此 當你在Xcode中調試
並且在某個斷點上停止時

00:42:27.781 --> 00:42:31.518
你注意一下
你看一下PC小功能區

00:42:31.585 --> 00:42:34.421
PC功能區將在右側給出停止原因

00:42:34.488 --> 00:42:37.591
它總是會給出像2.1
這樣形式的斷點

00:42:37.658 --> 00:42:39.459
它從不給出像2這樣形式的斷點

00:42:39.526 --> 00:42:42.196
因爲你只能在這些位置上中斷

00:42:42.262 --> 00:42:44.331
所以是1.1 1.2等等

00:42:45.165 --> 00:42:49.269
另外 位置和斷點在某種程度上
與我講的其他選項

00:42:49.336 --> 00:42:52.606
是對稱的

00:42:52.773 --> 00:42:57.244
它們都有像命令和條件等那樣
相同的通用選項

00:42:57.311 --> 00:43:00.581
你可在斷點上指定任何命令條件

00:43:00.647 --> 00:43:03.550
然後它將適用於所有位置

00:43:03.617 --> 00:43:06.587
但是你還可以重載特定位置

00:43:06.653 --> 00:43:10.824
通過在位置上設置其中一個
命令或條件來實現

00:43:11.525 --> 00:43:13.560
還有一點好處

00:43:14.294 --> 00:43:17.798
很多時候
若你有一個生成一批位置的斷點

00:43:17.865 --> 00:43:20.067
你想得到其中五個
或你不想得到其中五個

00:43:20.133 --> 00:43:22.936
那麼你可以禁用它們
你可以分別執行

00:43:23.203 --> 00:43:25.672
但是 如果你不想搜索到它們

00:43:25.739 --> 00:43:27.941
你想禁用整個斷點

00:43:28.008 --> 00:43:29.643
你可以通過禁用斷點來實現

00:43:29.710 --> 00:43:33.847
但看起來並沒有改變位置的開啓
或禁用狀態

00:43:33.914 --> 00:43:35.983
因此 你只需要再把它打開即可

00:43:36.049 --> 00:43:39.219
就會像你所期待的那樣改變
所有位置的狀態

00:43:39.520 --> 00:43:42.389
這只是一個小貼士
那麼現在你已經看到

00:43:42.756 --> 00:43:45.726
斷點在LLDB中的概念

00:43:45.959 --> 00:43:49.162
讓我展示一些
LLDB提供的

00:43:49.229 --> 00:43:50.564
更強大的斷點類型

00:43:50.631 --> 00:43:53.033
這些仍然是搜索要停止的位置

00:43:53.133 --> 00:43:55.536
我們要進行哪種搜索呢？

00:43:55.602 --> 00:43:59.406
這正是你程序中的命名空間
所感興趣的

00:43:59.473 --> 00:44:03.143
看起來所有命名空間都是
黏糊糊的東西

00:44:03.210 --> 00:44:05.512
因爲它們都像函數名
或諸如此類的東西

00:44:05.746 --> 00:44:10.984
因爲我們總是使用常規表達式
作爲搜索模式的表達方式

00:44:11.084 --> 00:44:12.486
那麼如果你知道常規表達式

00:44:12.553 --> 00:44:14.054
你一定會覺得它很可愛

00:44:14.121 --> 00:44:15.889
如果你不熟悉常規表達式

00:44:16.290 --> 00:44:17.891
幾年前我就說過

00:44:17.958 --> 00:44:22.129
在你的辦公室找一個
有動物封面書的人

00:44:22.196 --> 00:44:24.164
即使現在 如果你想找個前輩

00:44:24.231 --> 00:44:27.201
你可以找個有書的人

00:44:28.168 --> 00:44:29.036
那麼無論如何...

00:44:32.773 --> 00:44:36.743
我們提供兩種搜索
一種顯而易見

00:44:36.977 --> 00:44:40.647
是搜索程序中的函數名

00:44:40.714 --> 00:44:42.216
這是那種搜索的選項

00:44:42.282 --> 00:44:43.984
還有一種可能不那麼明顯

00:44:44.051 --> 00:44:46.687
但我希望隨着我們更深入地講解
我能說服你 讓你覺得那很有意思

00:44:46.753 --> 00:44:49.590
就是源文本搜索斷點

00:44:49.890 --> 00:44:51.458
這就是搜索的選項

00:44:51.892 --> 00:44:52.993
讓我們先來看第一種

00:44:53.060 --> 00:44:55.829
函數名模式跟斷點相匹配

00:44:55.896 --> 00:44:57.631
我只展示一些例子

00:44:57.698 --> 00:45:00.067
假如某人給了你一個新類

00:45:00.133 --> 00:45:02.736
你不知道這個類是幹什麼的
你想知道它是如何工作的

00:45:02.803 --> 00:45:06.740
那麼你想要做的其實是中斷
那個類實現的所有方法

00:45:06.807 --> 00:45:09.676
你可以通過在Xcode中
仔細檢查源文件來實現

00:45:09.743 --> 00:45:12.946
從最開始進行 但很快你會覺得乏味

00:45:13.380 --> 00:45:16.183
順便說一下 你不想在父類
或子類這樣的類上中斷

00:45:16.750 --> 00:45:19.953
最好是嘗試制定一個
常規表達式

00:45:20.020 --> 00:45:23.790
匹配給定類中的所有函數

00:45:23.957 --> 00:45:26.760
那麼在Swift中
這是個合適的常規表達式

00:45:26.960 --> 00:45:29.763
或在Objective C中
這是個合適的常規表達式

00:45:29.830 --> 00:45:32.633
然後你要在這些表達式上
設置斷點

00:45:32.699 --> 00:45:35.402
然後你就可以運行程序
看看會發生什麼

00:45:35.469 --> 00:45:38.071
請記住 因爲你可以禁用個別位置

00:45:38.272 --> 00:45:40.407
當你做這種實驗時

00:45:40.474 --> 00:45:44.478
你會發現你可能搜索到其中一個
你知道它是幹什麼的 你並不感興趣

00:45:44.545 --> 00:45:47.214
所以你只需要禁用那個位置
然後繼續

00:45:47.281 --> 00:45:49.716
發現第二個 禁用
然後繼續 以此類推

00:45:49.983 --> 00:45:52.119
那麼這是一種探索新代碼的
不錯的方式

00:45:52.186 --> 00:45:54.955
更高級的版本是

00:45:55.022 --> 00:45:57.791
某人給你一個共享庫

00:45:57.858 --> 00:46:00.561
你想看看它在運行時到底
有什麼功能

00:46:00.627 --> 00:46:05.098
然後設置一個常規表達式斷點
我在這裏用的是簡化的-r形式

00:46:05.165 --> 00:46:07.734
常規表達式匹配一切

00:46:07.801 --> 00:46:09.169
用.*實現

00:46:09.236 --> 00:46:12.372
然後把它限制在
你感興趣的那個庫

00:46:12.439 --> 00:46:14.408
把這些和斷點命令相結合

00:46:14.474 --> 00:46:16.143
通常是一種很好的方式

00:46:16.210 --> 00:46:20.447
以便又迅速又隨性地獲得
這個庫的執行軌跡

00:46:20.514 --> 00:46:22.883
你可以向後追蹤 也許會打印局部

00:46:22.950 --> 00:46:25.485
然後繼續 你只需要運行程序

00:46:25.552 --> 00:46:29.690
並且得到那個庫的執行磁帶輸出即可

00:46:30.390 --> 00:46:33.460
當然了 在執行過程中速度會慢下來
但值得等待

00:46:34.394 --> 00:46:36.230
然後另一個小技巧是

00:46:36.296 --> 00:46:39.433
如果你找到你並不感興趣的
你可以禁用它們

00:46:39.833 --> 00:46:43.971
那麼讓我們談談另一種
匹配模式吧

00:46:44.304 --> 00:46:47.841
這裏的重點是有一些構造函數

00:46:47.908 --> 00:46:50.844
當你查看源文本時非常明顯

00:46:50.911 --> 00:46:53.680
但如何在生成的代碼中得到
那些構造函數

00:46:53.747 --> 00:46:55.182
真的很不明顯

00:46:55.315 --> 00:46:57.551
其中一個例子是宏

00:46:57.618 --> 00:47:01.088
通常在你的程序中替代文本

00:47:01.154 --> 00:47:02.356
然後它就悄悄消失了
但你知道

00:47:02.422 --> 00:47:06.293
它們插在代碼的哪個位置
因爲它們是大寫字母

00:47:06.360 --> 00:47:09.196
那麼想要搜索到它們
也許需要搜索全部大寫字母

00:47:09.263 --> 00:47:11.431
或你所關注的特定的宏

00:47:11.498 --> 00:47:13.300
但是你可以更有創造力

00:47:13.367 --> 00:47:17.905
比如說 我想了解指針

00:47:17.971 --> 00:47:19.506
指定字段的位置

00:47:19.773 --> 00:47:22.242
很明顯是在源文本中

00:47:22.309 --> 00:47:24.077
因爲看起來就像是那樣

00:47:24.178 --> 00:47:27.915
但在生成的代碼中
尋找這些位置可能會很困難

00:47:27.981 --> 00:47:32.386
因此還有另一個實例
在源文本中使用模式匹配

00:47:32.452 --> 00:47:36.590
可以允許你發現你用其他方式
發現不了的構造函數

00:47:37.191 --> 00:47:38.759
另一種使用方法是

00:47:38.825 --> 00:47:42.696
做主題分組

00:47:42.763 --> 00:47:44.631
你可以在上邊設置斷點

00:47:44.698 --> 00:47:48.569
通過插入手動模式到你的源代碼

00:47:48.635 --> 00:47:51.605
就像註釋裏說的中斷這裏
或中斷那裏

00:47:51.672 --> 00:47:53.640
如果你有興趣檢測

00:47:53.707 --> 00:47:57.211
程序功能中的這個特定的部分

00:47:57.444 --> 00:47:59.913
然後使用這些源常規表達式斷點

00:47:59.980 --> 00:48:01.048
來捕捉它

00:48:01.415 --> 00:48:06.320
那麼這就是源斷點的工作原理

00:48:06.386 --> 00:48:09.356
選項是源常規表達式

00:48:09.423 --> 00:48:12.226
爲搜索提供的數據是模式

00:48:12.292 --> 00:48:14.928
然後你可以把它限定在一個文件中

00:48:15.229 --> 00:48:20.434
你可以通過多次給出-f選項
限定在多個文件中

00:48:20.567 --> 00:48:23.103
並且還有一個標誌可以搜索
全部源文件

00:48:24.004 --> 00:48:27.841
讓我舉個例子來吊你的胃口

00:48:27.908 --> 00:48:31.044
假如我有個複雜的函數
比如狀態機

00:48:31.111 --> 00:48:34.481
是計算用的
然後從許多不同的地方返回

00:48:34.548 --> 00:48:37.384
在某些恐怖的超長的選擇語句中
或其他類似的選擇語句中

00:48:37.451 --> 00:48:41.154
我想找到什麼時候會返回空

00:48:41.221 --> 00:48:45.826
但我想了解返回空時

00:48:46.026 --> 00:48:47.594
的具體情況

00:48:48.095 --> 00:48:49.563
很難實現

00:48:49.630 --> 00:48:51.398
因爲你可以在函數返回後中斷

00:48:51.465 --> 00:48:52.699
並查看是否爲空

00:48:52.766 --> 00:48:55.802
你可以點擊所有返回空的位置

00:48:55.869 --> 00:48:59.740
但你可能會遺漏其中一個
或你只關注模式

00:49:00.340 --> 00:49:02.376
這裏有另外一個便捷方式

00:49:02.442 --> 00:49:05.012
在源常規表達式斷點類型中

00:49:05.078 --> 00:49:07.314
你不僅可以指定一個文件

00:49:07.381 --> 00:49:09.483
你還可以把它限定在一個
特定的函數中

00:49:09.550 --> 00:49:11.385
如果那樣的話
我要做這樣的操作

00:49:11.451 --> 00:49:14.621
中斷要返回的模式

00:49:14.688 --> 00:49:18.625
我正在展示我會用常規表達式
因爲我正在炫耀

00:49:18.692 --> 00:49:20.961
空格+星號代表任意數量的空格

00:49:21.028 --> 00:49:22.462
然後空指針

00:49:22.529 --> 00:49:25.432
我把它限定在一個函數中
且限定在我感興趣的一個文件中

00:49:25.499 --> 00:49:29.803
然後我會發現
在這個特定的用法中

00:49:29.870 --> 00:49:31.138
我精確地找到了返回空的位置

00:49:32.539 --> 00:49:35.776
那麼值得談一些額外的斷點選項

00:49:35.843 --> 00:49:37.711
你可能沒聽說過

00:49:37.778 --> 00:49:42.349
其中一個類似逐行或篩選

00:49:42.816 --> 00:49:47.888
很有用 因爲我們程序中同時存在
Swift和Objective C

00:49:48.255 --> 00:49:51.024
可以給指定的一種語言設置斷點

00:49:51.091 --> 00:49:54.795
那麼比如說 隨處都有計數方法

00:49:54.862 --> 00:49:56.597
如果你在計數上設置一個斷點

00:49:56.663 --> 00:49:58.999
你將在Swift代碼中得到一批斷點

00:49:59.066 --> 00:50:01.502
你也會得到一批
Objective C方法的斷點

00:50:01.568 --> 00:50:03.504
但你並不關心
Objective C方法

00:50:03.570 --> 00:50:05.138
你只想查看Swift代碼

00:50:05.405 --> 00:50:07.841
然後你可以指定語言爲Swift

00:50:08.041 --> 00:50:10.711
它將不會在 Objective C
名稱上執行恰巧匹配的斷點

00:50:10.777 --> 00:50:13.680
這很有用

00:50:13.747 --> 00:50:15.482
是的 對

00:50:15.549 --> 00:50:18.485
另一個有用的選項

00:50:18.552 --> 00:50:22.723
能使搜索縮小到一個
指定的線程

00:50:22.856 --> 00:50:26.326
假如你有一些能調用的代碼
和一批不同的線程

00:50:26.393 --> 00:50:27.928
就像內核或諸如此類的

00:50:27.995 --> 00:50:31.164
但當你開始執行一個線程時

00:50:31.231 --> 00:50:34.635
你不想讓用於檢測的斷點

00:50:34.701 --> 00:50:37.704
把你帶到其他線程上去 很簡單

00:50:37.871 --> 00:50:40.240
有一個線程ID選項

00:50:40.774 --> 00:50:42.776
這個選項可以讓你按照
線程名執行

00:50:42.843 --> 00:50:45.812
可以通過調用
pthread_setname_np設置

00:50:45.879 --> 00:50:48.615
這很方便 因爲如果你命名
一個線程

00:50:48.682 --> 00:50:51.084
然後保留在多個調試會話中

00:50:51.151 --> 00:50:53.620
線程ID當然會隨時變更

00:50:53.954 --> 00:50:55.322
你甚至可以限制它

00:50:55.389 --> 00:50:59.593
按照名稱對指定隊列進行編碼

00:51:00.994 --> 00:51:02.596
還有一點你可能會注意到

00:51:02.663 --> 00:51:06.166
就是你可以把全部選項
添加到現有斷點上

00:51:06.633 --> 00:51:07.935
特別有用

00:51:08.001 --> 00:51:11.605
如果你已經在Xcode的邊列中
設置了文件和行斷點的話

00:51:11.672 --> 00:51:15.642
比如說 你決定你想限定到
一個指定線程

00:51:15.709 --> 00:51:18.946
你可以在查詢後進行變更
命令是break modify

00:51:19.012 --> 00:51:22.983
另一件有用的事是展示
如何指定它們

00:51:23.050 --> 00:51:26.620
因爲你可以通過斷點指定

00:51:26.920 --> 00:51:28.622
通過斷點位置編號指定

00:51:28.689 --> 00:51:31.325
還有一個小語句來指定範圍

00:51:33.227 --> 00:51:34.061
就是這樣

00:51:35.229 --> 00:51:39.099
那麼現在 你得到了你想要的
所有斷點

00:51:39.166 --> 00:51:41.201
但你遇到了絆腳石

00:51:41.268 --> 00:51:43.570
就是目前Xcode看起來

00:51:43.637 --> 00:51:46.640
只保留了它已知的你設置的斷點

00:51:46.707 --> 00:51:51.211
而那些你想方設法手動寫入的斷點
它並不瞭解

00:51:51.345 --> 00:51:53.013
那麼如何保留那些斷點呢？

00:51:53.247 --> 00:51:55.582
第一種方法是Enrico講過的：

00:51:55.649 --> 00:51:58.185
如果你想把它保留在所有對象中

00:51:58.252 --> 00:52:01.054
你只需要把它放在LLDB初始化
文件中即可

00:52:01.288 --> 00:52:05.392
但是如果你想指定對象
有一個小技巧你可以使用

00:52:05.459 --> 00:52:10.030
當你每次調試那個指定對象時
加載斷點

00:52:10.097 --> 00:52:13.333
這其實是做一個
Xcode存儲的斷點

00:52:13.400 --> 00:52:17.037
最好是在程序執行中
早期斷開的斷點

00:52:17.104 --> 00:52:19.540
然後你把你的斷點和命令
放在那個斷點中

00:52:19.606 --> 00:52:22.676
這樣你就知道
如果是主可執行文件

00:52:22.743 --> 00:52:24.978
比如說 主函數是個快速接口

00:52:25.045 --> 00:52:26.980
那麼你可以做一個符號斷點

00:52:27.080 --> 00:52:29.650
然後把主函數放進去

00:52:29.716 --> 00:52:32.786
然後你還記得剛纔那張幻燈片吧

00:52:32.853 --> 00:52:34.821
我說過有個主函數的小麻煩

00:52:34.888 --> 00:52:37.090
那麼你可以指定共享庫

00:52:37.791 --> 00:52:41.061
然後你可以添加動作
是個調試器命令動作

00:52:41.128 --> 00:52:44.331
然後不要一個一個地
鍵入所有斷點

00:52:44.398 --> 00:52:45.999
因爲會很乏味

00:52:46.066 --> 00:52:48.869
把命令放在一個文件中很方便

00:52:48.936 --> 00:52:54.274
然後使用LLDB的command
source命令來加載這些斷點

00:52:54.341 --> 00:52:56.009
最後 如果你自動繼續

00:52:56.076 --> 00:52:58.712
每次你運行時 你都將自動獲得

00:52:58.779 --> 00:53:00.380
所有那些斷點集

00:53:01.281 --> 00:53:04.084
我還想講另一個便捷方式

00:53:04.151 --> 00:53:06.386
用來克服

00:53:06.453 --> 00:53:11.825
你在現代語言中常見的一種
特定的煩人的麻煩

00:53:12.326 --> 00:53:16.330
就是當你嘗試單步跳入某個東西時

00:53:16.396 --> 00:53:19.199
問題是在大部分現代語言中

00:53:19.266 --> 00:53:22.970
大多數變量存取現在都是通過屬性
完成的

00:53:23.036 --> 00:53:25.205
或通過存取子函數或諸如此類

00:53:25.272 --> 00:53:26.106
所以...

00:53:26.473 --> 00:53:29.910
一般來說 這並不是你嘗試
要調試的代碼

00:53:30.811 --> 00:53:32.913
最後導致了這樣一個情況

00:53:32.980 --> 00:53:35.782
我在這兒 我嘗試進入這個函數
完成某些功能

00:53:35.849 --> 00:53:36.950
我想進入那裏

00:53:37.017 --> 00:53:39.987
所以我嘗試單步跳入
但並沒有成功

00:53:40.053 --> 00:53:42.556
因爲我正在傳遞的一個參數

00:53:42.623 --> 00:53:44.858
是存取子函數
所以我在那個存取器中中斷了

00:53:44.925 --> 00:53:47.394
我並不想在那兒中斷
因爲那一點兒都沒有意義

00:53:47.461 --> 00:53:50.364
因此我要做的是完成並返回

00:53:50.430 --> 00:53:53.033
是不是有一種方式可以讓這個
過程變得更簡單？

00:53:53.100 --> 00:53:56.436
看起來我們添加了一個叫做
定向單步跳入的東西

00:53:56.503 --> 00:54:00.841
選項是step_in_target
表示你要單步跳入

00:54:00.908 --> 00:54:02.809
我要做的是單步跳入

00:54:02.876 --> 00:54:05.479
但我只想讓你在這個指定的地方中斷

00:54:05.546 --> 00:54:07.514
就是你正在用這個表達的意思

00:54:07.581 --> 00:54:09.416
讓我們在這種情況中嘗試一下

00:54:09.483 --> 00:54:12.286
我們發現它幾乎不怎麼工作

00:54:12.352 --> 00:54:13.820
不怎麼工作的原因是

00:54:13.887 --> 00:54:16.290
雖然我們沒有在存取器中中斷

00:54:16.356 --> 00:54:20.093
但是我們卻在下一個源文件上中斷了
而不是在函數中中斷

00:54:20.160 --> 00:54:21.261
這是有道理的

00:54:21.328 --> 00:54:24.231
因爲實際上單步跳入是按照
源代碼逐行執行的

00:54:24.298 --> 00:54:26.266
這就是多行調用

00:54:26.333 --> 00:54:28.402
那麼我們也要通過給出

00:54:28.468 --> 00:54:31.238
結束行的編號添加能指定

00:54:31.305 --> 00:54:33.140
單步跳入的終止範圍

00:54:33.207 --> 00:54:36.510
或更方便的是隻進入這個塊

00:54:36.577 --> 00:54:38.846
讓我進入 做一些操作

00:54:38.912 --> 00:54:43.383
甚至還有一個別名
即函數中的sif單步跳入

00:54:43.584 --> 00:54:47.654
那麼 你要做的就是坐在這裏
並在函數中鍵入step

00:54:47.721 --> 00:54:49.756
然後你就會着陸在正確的位置

00:54:49.823 --> 00:54:51.625
若你沒着陸在正確的位置
我就不會把它放在幻燈片中講了

00:54:52.292 --> 00:54:56.029
最後我想講一下排錯

00:54:56.263 --> 00:54:59.600
你需要了解的一個信息是

00:54:59.666 --> 00:55:02.436
運行程序中到底有什麼

00:55:02.536 --> 00:55:05.405
比如 也許我創建了發佈版本
和調試版本

00:55:05.472 --> 00:55:07.841
我想了解我實際使用的是
哪個版本

00:55:07.908 --> 00:55:09.977
或某人給了我一個帶dSYM的庫

00:55:10.043 --> 00:55:11.545
這個dSYM允許讀入嗎？

00:55:11.812 --> 00:55:14.681
那麼 需要那種信息的命令

00:55:14.748 --> 00:55:16.116
是image list命令

00:55:16.183 --> 00:55:19.219
你可以給它一個模塊名
這樣它將給出

00:55:19.286 --> 00:55:21.522
關於加載到你程序中
某個模塊的信息

00:55:21.588 --> 00:55:25.559
或者爲了消遣
你可以不提供任何選項

00:55:25.626 --> 00:55:28.262
將會顯示全部
有時候多得令人震驚

00:55:29.830 --> 00:55:32.232
那麼 這裏有個例子
讓我們看看如何使用它

00:55:32.432 --> 00:55:35.335
我鍵入image list

00:55:35.402 --> 00:55:37.938
我看到這裏有個
二進制映像的路徑

00:55:38.005 --> 00:55:41.041
那麼假如 如果我想查看我是否
使用的是調試版本

00:55:41.108 --> 00:55:43.544
是的 看起來我的確像是用的調試版本

00:55:43.610 --> 00:55:47.481
如果有dSYM的話 它總是會在
二進制映像後列出來

00:55:47.548 --> 00:55:49.683
此情況下
我看到我的確得到了二進制映像

00:55:50.517 --> 00:55:53.654
我想告訴你一個
Swift調試的信息

00:55:53.720 --> 00:55:56.857
我這張幻燈片上的內容實際上
並不是我要講的內容

00:55:56.924 --> 00:55:58.759
因爲我們時間很緊

00:55:58.825 --> 00:56:00.994
但我會告訴你TLDR

00:56:01.428 --> 00:56:03.130
因爲我講得太快 你可能讀不完

00:56:03.197 --> 00:56:07.868
由於Swift和LLDB之間的
工作方式

00:56:07.935 --> 00:56:11.338
所有帶調試信息的Swift代碼

00:56:11.405 --> 00:56:13.273
都必須在本地創建

00:56:13.340 --> 00:56:17.277
因此 從其他人那兒拷貝二進制
映像是行不通的

00:56:17.344 --> 00:56:20.013
你要確保一切都是在本地創建的

00:56:20.080 --> 00:56:21.682
並且有編譯器

00:56:21.748 --> 00:56:24.585
隨着你正在使用的調試器一起運行

00:56:26.253 --> 00:56:28.922
我想說的是 這是我們提供的
一個小便利

00:56:28.989 --> 00:56:31.692
那麼 Enrico講的優化代碼
優化的規則

00:56:31.758 --> 00:56:34.561
我們之前聽到
如果不是不得不做的話 就不要做

00:56:34.628 --> 00:56:39.533
由於大部分軟件開發者都是理性的人

00:56:39.600 --> 00:56:42.069
你可以寫一個推論

00:56:42.135 --> 00:56:45.873
調試優化代碼的絕大多數人
實際上都不是故意執行的

00:56:46.106 --> 00:56:48.575
那麼現在當你中斷在文件中時

00:56:48.642 --> 00:56:52.112
 LLDB將告訴你
那個文件被優化了

00:56:52.179 --> 00:56:56.216
每個庫只通知一次
你將得到一條像這樣的消息

00:56:56.283 --> 00:56:59.586
然後你快速進入設置
把它們改回來

00:57:00.921 --> 00:57:03.957
剛剛添加到Clang中的
另一個新功能

00:57:04.024 --> 00:57:05.926
是這個模塊概念

00:57:05.993 --> 00:57:09.363
模塊是允許編譯器

00:57:09.429 --> 00:57:13.066
查看你程序標頭環境中的
所有標頭的方式

00:57:13.667 --> 00:57:16.870
編譯並解析它們

00:57:16.937 --> 00:57:19.740
然後在所有編譯器中重用

00:57:19.806 --> 00:57:22.376
然後我們想
爲什麼我們不能對調試信息

00:57:22.442 --> 00:57:23.944
做同樣的事呢？

00:57:24.011 --> 00:57:28.215
爲什麼不能允許
類型信息的解析形式

00:57:28.282 --> 00:57:31.251
也一次性完成然後

00:57:31.318 --> 00:57:35.222
在所有帶調試信息.o文件中共享呢？

00:57:35.289 --> 00:57:38.258
這叫做Clang模式調試功能

00:57:38.959 --> 00:57:40.827
此外 我們還可以使用
PCH文件

00:57:40.894 --> 00:57:44.631
Xcode中的設置
是Clang模塊調試

00:57:44.698 --> 00:57:47.067
這是由於某種原因
我放進去的標誌

00:57:47.367 --> 00:57:50.270
這很棒 因爲就像編譯器一樣

00:57:50.337 --> 00:57:53.273
提高了調試信息的生成速度

00:57:53.340 --> 00:57:57.010
它將縮短編譯時間
但它有一個警告

00:57:57.077 --> 00:58:00.380
那個警告實際上可能是個重要警告

00:58:00.447 --> 00:58:04.518
那麼 那個警告是你的調試不僅
依賴於.o文件

00:58:04.585 --> 00:58:07.721
還依賴於內存中的某些東西

00:58:07.988 --> 00:58:11.625
因此 一般來說 那不是個問題
每個東西都在自己的位置上

00:58:11.692 --> 00:58:16.096
但當你要給某人發佈庫或應用時

00:58:16.363 --> 00:58:20.300
該怎麼工作呢？
嗯 如果是應用或框架

00:58:20.367 --> 00:58:23.237
你只需要運行dsymutil即可

00:58:23.303 --> 00:58:26.740
效果是一樣的 它把一切都集合起來
一切都能正常運行

00:58:26.807 --> 00:58:30.177
但請記住
dsymutil只在關聯產品上運行

00:58:30.244 --> 00:58:32.145
並不在.o文件上運行

00:58:32.212 --> 00:58:35.916
因此 若你發佈的是
帶調試信息的靜態庫

00:58:35.983 --> 00:58:38.519
那麼你必須關閉這個
G模塊的功能

00:58:38.585 --> 00:58:41.488
否則你將會給客戶發佈
已損毀的調試信息

00:58:41.989 --> 00:58:44.458
順便說一下 如果磁盤空間不足

00:58:44.525 --> 00:58:46.193
你刪除了模塊緩存

00:58:46.260 --> 00:58:48.495
那麼你就不能再調試了

00:58:48.695 --> 00:58:51.365
這是那個功能的一個不利因素

00:58:51.965 --> 00:58:55.669
那麼 讓我來總結一下吧

00:58:56.103 --> 00:58:59.773
我希望你瞭解LLDB是個
定製化很強的調試器

00:58:59.840 --> 00:59:02.242
提供多種查看數據的方式

00:59:02.743 --> 00:59:07.114
表達式實際上可以提供
更強大的檢測功能

00:59:07.181 --> 00:59:11.251
我認爲Sean的例子很好
講瞭如何在live狀態下

00:59:11.318 --> 00:59:14.221
從一個複雜的數組中通過
並發現你感興趣的點

00:59:15.022 --> 00:59:18.592
在Xcode中 我們有很多斷點類型
比你想象的多

00:59:19.326 --> 00:59:22.729
你可以把自己陷入超級深的麻煩中

00:59:22.796 --> 00:59:24.431
比源代碼層的調試還深

00:59:24.498 --> 00:59:28.936
總之 希望我們提供了豐富的
工具集讓你探索自己的代碼

00:59:29.002 --> 00:59:33.440
這裏有一些之前演講的信息
可能涉及你感興趣的內容

00:59:33.507 --> 00:59:36.543
還有一些早些時候的演講
你可能沒參加

00:59:36.910 --> 00:59:39.213
或參加了 但無論如何
我把它們列在幻燈片上了

00:59:39.279 --> 00:59:40.214
謝謝大家

00:59:40.414 --> 00:59:43.584
希望你們能在僅剩的WWDC
期間度過一段美好的時光