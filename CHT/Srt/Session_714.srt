00:00:19.386 --> 00:00:20.821
現代互聯網的網絡系統

00:00:28.896 --> 00:00:30.297
下午好
女士們和先生們

00:00:30.731 --> 00:00:32.566
看到這麼多人在場我感到非常高興

00:00:33.133 --> 00:00:35.936
有多少人是第一次來WWDC？

00:00:37.571 --> 00:00:38.906
哇！這令人難以置信

00:00:38.972 --> 00:00:40.073
歡迎

00:00:40.507 --> 00:00:42.743
我希望你們在WWDC一切順利

00:00:44.344 --> 00:00:46.813
現在我們要來談一些
網絡系統的話題

00:00:47.681 --> 00:00:49.316
我今天有五個內容要講

00:00:49.883 --> 00:00:54.521
我們將向你們介紹顯式擁塞通知的最新進展

00:00:54.588 --> 00:00:55.989
我們去年談論過（顯式擁塞通知）

00:00:56.590 --> 00:00:59.860
我們要告訴你關於IPv6
進展的最新動態

00:01:00.561 --> 00:01:04.298
我們要談論一點點國際化文本

00:01:04.364 --> 00:01:06.366
它正變得日益重要

00:01:08.302 --> 00:01:12.806
我們要來探索下你如何控制
網絡接口的訪問權

00:01:12.873 --> 00:01:15.642
來避免你的用戶收到天價流量賬單

00:01:16.343 --> 00:01:20.714
我們會以一些關於
網絡服務質量探討進行收尾

00:01:21.548 --> 00:01:26.053
你可能聽說過Apple
Cisco Fastlane聲明

00:01:26.620 --> 00:01:30.224
我們就它將如何適用於你的應用
這一話題加以談論

00:01:32.993 --> 00:01:34.261
我們先從ECN說起

00:01:36.496 --> 00:01:38.265
簡單地回顧下去年講的內容

00:01:39.233 --> 00:01:44.738
我們展示了Smart Queue
Management和標記而非丟棄數據包

00:01:44.805 --> 00:01:50.844
如何在重新發送過程中
降低延遲 減少延時

00:01:50.911 --> 00:01:55.148
來提高所有應用程序的用戶體驗

00:01:55.215 --> 00:01:57.384
特別是對串流影像這類情況

00:02:00.254 --> 00:02:06.793
在iOS 9上面
我們對TCP連接沒有啓用ECN

00:02:06.860 --> 00:02:08.228
但是在一個不相關的改動裏

00:02:08.294 --> 00:02:11.732
VPN軟件會關注ECN標記

00:02:11.798 --> 00:02:16.036
我們發現德國的一個ISP
把所有的數據包都標記了

00:02:16.103 --> 00:02:20.040
“經歷了擁塞”
這對VPN是不好的

00:02:20.374 --> 00:02:24.044
好消息是他們在幾個星期內修好了網絡

00:02:24.111 --> 00:02:27.748
我們沒接到世界其他地方發來的
任何錯誤報告

00:02:27.814 --> 00:02:33.020
這告訴我們的是
我們在世界各地推出了iOS

00:02:33.086 --> 00:02:34.855
發現了一個問題並修好了

00:02:35.522 --> 00:02:37.658
現在互聯網對ECN來說安全了

00:02:40.527 --> 00:02:46.300
也正因爲這樣 在iOS 9.3
和OS X El Capitan上

00:02:47.034 --> 00:02:51.138
隨機5%的TCP連接使用了ECN

00:02:51.205 --> 00:02:54.107
我們用這個來收集性能數據

00:02:54.174 --> 00:02:57.945
然後檢查確認互聯網
對ECN來說是持續安全的

00:02:58.478 --> 00:03:01.582
在你已有的
Developer Seed中

00:03:02.149 --> 00:03:06.153
100%的Wi-Fi連接
和100%的

00:03:06.220 --> 00:03:08.889
這三個網絡運營商的連接
現在都在用ECN

00:03:10.524 --> 00:03:16.363
去年 我報告說Alexa上56%

00:03:16.897 --> 00:03:20.767
排名前百萬的網站支持ECN

00:03:21.168 --> 00:03:24.271
這是一個還挺令人驚訝的支持數

00:03:24.338 --> 00:03:26.039
對於一個沒人用的技術來說

00:03:27.941 --> 00:03:33.881
我和我在ETH的好朋友
Zurich和Brian談了下

00:03:35.182 --> 00:03:38.085
Brian Trammell和
Mira Coolwind還有他們的同事

00:03:38.151 --> 00:03:39.786
爲我們重新跑了下測試

00:03:40.420 --> 00:03:43.056
今年的百分比上升到了70%

00:03:43.357 --> 00:03:46.994
而且如果你只看IPv6的網站
都到了83%

00:03:47.861 --> 00:03:48.962
所以

00:03:49.997 --> 00:03:55.969
這是在號召ISP、網絡運營商

00:03:56.036 --> 00:03:58.272
和賣給他們設備的供應商們行動起來

00:03:58.705 --> 00:04:00.407
客戶端在使用ECN

00:04:00.741 --> 00:04:02.342
網絡服務在支持ECN

00:04:02.676 --> 00:04:06.180
是時候讓中間的網絡開始標記數據包

00:04:06.246 --> 00:04:07.648
而不是丟棄他們

00:04:07.714 --> 00:04:13.320
它給你更好的用戶體驗
它減少了因爲重新傳輸而產生的延時

00:04:13.387 --> 00:04:15.355
而且它更有效的利用了網絡

00:04:15.422 --> 00:04:18.959
因爲你避免了重新傳輸包裹而浪費帶寬

00:04:20.761 --> 00:04:24.064
我們的下一個話題是IPv6

00:04:26.500 --> 00:04:31.438
全球啓用IPv6計劃
是四年前的上個星期

00:04:31.505 --> 00:04:34.842
它現在還在增長

00:04:36.076 --> 00:04:39.012
我看了各種各樣的數據統計

00:04:39.079 --> 00:04:42.516
現在來給大家展示其中的一小部分樣本

00:04:42.583 --> 00:04:49.523
我看了通過IPv6
訪問Apple主頁的比例

00:04:49.590 --> 00:04:53.727
在比利時 這個比例現在到了39%

00:04:54.561 --> 00:04:57.664
在美國T-Mobile
這個比例到了54%

00:04:58.599 --> 00:05:01.835
在Verizon上 這個比例到了74%

00:05:02.269 --> 00:05:08.675
很清楚的一點是 在這些運營商上
IPv6的通信是主流

00:05:11.311 --> 00:05:12.880
原因很簡單

00:05:13.514 --> 00:05:18.252
IPv6更簡單、更可靠
操作起來也更便宜

00:05:18.318 --> 00:05:22.489
所以運營商想轉用IPv6原因很清楚

00:05:23.190 --> 00:05:26.560
但對於開發者和用戶來說代價是什麼？

00:05:27.027 --> 00:05:28.795
IPv6欠成熟嗎？

00:05:29.029 --> 00:05:30.130
它更慢嗎？

00:05:30.364 --> 00:05:33.800
分給IPv6的容量更少嗎？

00:05:33.867 --> 00:05:35.836
這些是很重要的問題

00:05:35.903 --> 00:05:41.308
內容提供商和開發者密切關注着這個

00:05:42.042 --> 00:05:45.779
他們用收集自網頁瀏覽器的數據

00:05:45.846 --> 00:05:49.950
測量一些東西
像其用戶每人瀏覽網頁時的加載時間

00:05:50.017 --> 00:05:52.586
然後把這個信息發送回來

00:05:52.653 --> 00:05:56.223
這樣他們就能知道自己的產品

00:05:56.290 --> 00:05:58.058
在世界各國

00:05:58.125 --> 00:06:00.861
不同的ISP
不同的運營網絡上運行如何

00:06:02.796 --> 00:06:08.135
LinkedIn報告他們現10%的
通信是通過IPv6

00:06:08.202 --> 00:06:14.141
他們發現頁面平均加載時間
比通過IPv4快10%到40%

00:06:15.409 --> 00:06:18.812
他們推理這可能是因爲較少的額外開銷

00:06:19.513 --> 00:06:22.850
通過大規模超載的NAT建立連接

00:06:23.750 --> 00:06:25.953
Facebook發現了相似的結果

00:06:26.019 --> 00:06:29.256
他們現在通信的45%是IPv6通信

00:06:29.690 --> 00:06:33.260
這是他們最近根據數據的平均情況
做出的報告

00:06:33.327 --> 00:06:38.198
ATP通過IPv6的
GET請求要快15%

00:06:39.032 --> 00:06:42.903
若你只看數據集合中iPhone部分

00:06:42.970 --> 00:06:45.973
結果發現其中30%通過IPv6

00:06:47.975 --> 00:06:53.780
所以IPv6對網絡操作者來說更好

00:06:54.314 --> 00:06:56.350
他對用戶和內容提供商也更好

00:06:56.717 --> 00:07:03.023
這也是爲什麼Apple
100%支持IPv6

00:07:03.357 --> 00:07:07.194
你們上個月肯定都已經看到了這個聲明

00:07:07.928 --> 00:07:11.231
我們去年宣佈了
我們將要求所有的應用

00:07:12.065 --> 00:07:14.968
兼容IPv6網絡

00:07:15.035 --> 00:07:21.141
我們還說將在自己的IPv6網絡上
用NAT64 Gateway測試所有應用

00:07:22.309 --> 00:07:25.312
從這個月起
我們開始強制執行那個要求

00:07:26.046 --> 00:07:29.349
還仔細的尋找任何

00:07:29.416 --> 00:07:33.754
這個行爲會導致應用程序
拒絕率升高的證據

00:07:33.820 --> 00:07:35.789
因爲如果是這種情況的話

00:07:35.856 --> 00:07:38.292
我們將不得不研究並找到解決的辦法

00:07:38.759 --> 00:07:41.895
但是好消息是
我們盡全力監測

00:07:42.596 --> 00:07:46.033
沒有發現應用程序拒絕率的任何變化

00:07:46.433 --> 00:07:51.638
這個真正告訴你的是
你們中99%有應用

00:07:51.738 --> 00:07:53.874
在IPv6支持下能正常工作

00:07:54.208 --> 00:07:56.109
這是我們意料之中的

00:07:56.176 --> 00:07:58.445
但是最好還是能確認下

00:07:59.379 --> 00:08:05.219
若你已有一個應用被拒絕了
而且你認爲可能和IPv6有關係

00:08:05.285 --> 00:08:08.589
那麼今天或者明天來一下實驗室吧

00:08:09.156 --> 00:08:13.493
你可以在WWDC這裏
用NAT64網絡測試你的應用

00:08:13.560 --> 00:08:17.397
我們可以幫助你檢測下
哪裏可能出問題了

00:08:19.299 --> 00:08:22.236
我們的建議仍然是
也一直會是

00:08:22.970 --> 00:08:28.008
使用高層級兼容地址族的API

00:08:30.978 --> 00:08:35.115
如果你非得使用
低層級的BSD API

00:08:35.948 --> 00:08:38.751
那麼你將會有額外的工作要去做

00:08:39.285 --> 00:08:42.890
這就是爲什麼我們誠摯建議使用
高層級API來爲你做那些額外工作

00:08:44.024 --> 00:08:50.197
另一條重要建議是使用主機名
而不是IPv4地址

00:08:50.664 --> 00:08:54.501
因爲IPv4地址
是IPv4內置的一部分

00:08:54.902 --> 00:08:57.304
讓我給你看個小圖片告訴你爲什麼

00:08:58.639 --> 00:09:01.275
這是幾年前的一個典型情況

00:09:01.341 --> 00:09:05.078
你有一個客戶端在用IPv4
你有一個服務器在用IPv4

00:09:05.546 --> 00:09:08.415
數據包在NAT Gateway
繞了點圈子

00:09:08.482 --> 00:09:10.350
這就是你如何連接到服務器

00:09:12.920 --> 00:09:18.725
現如今 很多運營商開始使用
帶NAT64 Gateway的IPv6網絡

00:09:18.792 --> 00:09:21.862
數據包仍然在
NAT Gateway繞點路

00:09:21.929 --> 00:09:25.899
然後連接到互聯網上
那個老的過時的IPv4服務

00:09:28.869 --> 00:09:34.474
如果你們數據中心的人提出雙棧服務

00:09:34.975 --> 00:09:38.378
但是你的應用還在用v4字面值

00:09:38.946 --> 00:09:41.615
那麼數據包還是會繞同樣的路

00:09:41.682 --> 00:09:44.585
通過NAT到達服務的v4接口

00:09:45.419 --> 00:09:47.354
但是如果你通過主機名查找

00:09:47.421 --> 00:09:51.358
並且他們把IPv6的
配額記錄放入DNS

00:09:51.792 --> 00:09:55.162
那就是你如何直達數據路徑

00:09:56.463 --> 00:09:58.265
不用通過NAT Gateway

00:10:02.369 --> 00:10:04.171
我談了字面值地址

00:10:05.339 --> 00:10:10.677
我們現對選定的API
支持IPv4字面值地址

00:10:11.545 --> 00:10:13.380
如果你使用其中的一個地址

00:10:13.780 --> 00:10:19.486
我們實際會爲你在本地設備上
做DNS64綜合體

00:10:20.087 --> 00:10:22.789
創建一個臨時IPv6地址

00:10:22.856 --> 00:10:25.559
與你因特網上v4服務相對應

00:10:25.626 --> 00:10:27.961
然後通過NAT64 Gateway
進行連接

00:10:29.029 --> 00:10:32.466
請記住 使用字面值v4地址

00:10:32.533 --> 00:10:36.069
一定會阻止你的應用
連接到一個ATV6服務器

00:10:36.136 --> 00:10:39.506
但話又說回來
如果那是你應用程序的需要

00:10:40.807 --> 00:10:43.277
這裏是一個例子教你如何去做

00:10:44.745 --> 00:10:50.684
如果你編程語言用的是Swift
和高層Cocoa API

00:10:50.751 --> 00:10:52.586
這些會爲你自動生成

00:10:52.653 --> 00:10:57.391
但是如果現在你用的是UDP代碼
而且你用的是BSD socket

00:10:57.457 --> 00:11:00.093
你需要用到的API是
getaddrinfo

00:11:00.894 --> 00:11:04.865
你把要連接的地址用字面值傳進去

00:11:06.099 --> 00:11:07.434
傳入你想要的端口號

00:11:07.501 --> 00:11:10.871
這裏https是443端口的同義詞

00:11:12.172 --> 00:11:14.608
你對得到的地址進行循環

00:11:14.675 --> 00:11:16.410
記住 不要只用第一個

00:11:16.476 --> 00:11:19.012
你會得到一個數組包含
多個地址你需要去試

00:11:19.680 --> 00:11:21.915
當然 在你結束時釋放內存

00:11:22.316 --> 00:11:23.784
連接在Local Link的設備

00:11:23.851 --> 00:11:29.590
我們從開發者那裏收到的另一個問題
是關於物聯網的

00:11:30.357 --> 00:11:32.159
有的開發者寫的應用

00:11:32.226 --> 00:11:35.062
和不是他們製造的設備進行互動

00:11:35.362 --> 00:11:39.700
其中一些設備還不是很先進

00:11:40.567 --> 00:11:43.937
我們希望那些設備去支持IPv6

00:11:44.638 --> 00:11:46.406
如果不行的話

00:11:46.473 --> 00:11:50.143
我們建議他們起碼支持
IPv4 link-local地址

00:11:50.811 --> 00:11:52.880
所以即便在一個只支持v6的網絡上

00:11:53.580 --> 00:11:58.051
那些設備間可使用v4
與link-local地址互相交流

00:11:59.219 --> 00:12:02.890
如果這個設備兩樣都做不了 也可以

00:12:03.490 --> 00:12:06.460
當你提交應用時 通知應用審查

00:12:07.060 --> 00:12:09.696
那不能成爲拒絕你應用的理由

00:12:10.764 --> 00:12:14.234
但很可能是在這個設備上
貼上這個標籤的理由

00:12:16.170 --> 00:12:19.273
要記住
所有的線下鏈路通信

00:12:19.606 --> 00:12:23.544
仍然要兼容IPv6和NAT64

00:12:26.280 --> 00:12:32.986
總結一下
我們推薦你支持IPv4和IPv6

00:12:33.053 --> 00:12:35.455
在兩端都要支持
即在客戶端和服務器

00:12:36.323 --> 00:12:38.358
我們推薦你使用主機名、

00:12:38.692 --> 00:12:41.662
這樣你可在v4的網絡上
獲得一個v4地址

00:12:41.728 --> 00:12:43.997
在v6網絡上獲得v6地址

00:12:45.532 --> 00:12:50.204
如果你確實需要使用字面值地址
一些選定的API現在支持他們

00:12:50.537 --> 00:12:51.438
只要你設置合適

00:12:51.672 --> 00:12:52.673
但是記住

00:12:52.739 --> 00:12:58.045
插入v4字面值以後
會阻礙和v6服務器的通信

00:13:00.080 --> 00:13:03.450
這就引入了我們要講的下一個部分
國際文本

00:13:06.386 --> 00:13:08.522
你可能已經開始見到像這樣的東西

00:13:09.056 --> 00:13:14.061
如果你的母語是英語
這可能看起來挺難懂也挺嚇人的

00:13:15.195 --> 00:13:20.133
但我今天想談的是 它到底有多簡單

00:13:20.834 --> 00:13:25.372
國際支持在你的應用中
不需要成爲一個艱鉅的任務

00:13:25.873 --> 00:13:28.775
事實上 其實它不比支持ASCII難

00:13:29.476 --> 00:13:34.014
所以儘管這部分標題是國際文本和網絡

00:13:34.081 --> 00:13:35.983
我們其實可以把網絡劃去

00:13:37.050 --> 00:13:41.321
眼下 我只想談談通常來說
你如何支持國際文本

00:13:43.957 --> 00:13:45.826
我要從一些背景知識說起

00:13:46.093 --> 00:13:50.531
並不是因爲你們中
很多人每天可能會遇見它

00:13:51.164 --> 00:13:56.570
而是我想揭開它一部分神祕的面紗
讓它不那麼可怕

00:13:56.637 --> 00:13:59.273
因爲它真的不再比ASCII複雜了

00:14:00.140 --> 00:14:02.075
我們的第一個概念是Unicode

00:14:03.443 --> 00:14:06.613
Unicode是一大串數字

00:14:06.680 --> 00:14:11.218
與之相對應的是人們能看懂的字符

00:14:11.885 --> 00:14:17.090
它就像一個大電話本
事實上 它可以書的形式出現

00:14:17.157 --> 00:14:20.360
它是一本又大又厚
一頁一頁寫滿了數字和字符的書、

00:14:21.128 --> 00:14:23.497
那就是個抽象概念

00:14:23.564 --> 00:14:26.400
你有整數和它代表的字符

00:14:26.967 --> 00:14:30.337
想在我們的電腦裏用這些整數

00:14:30.404 --> 00:14:32.739
我們需要代表這些數字的方法

00:14:33.473 --> 00:14:35.976
在內存裏 在硬盤上
在網絡上

00:14:37.845 --> 00:14:43.550
代表他們的一種方法是UTF-32
就是一個32位的數字

00:14:43.617 --> 00:14:45.552
像其他32位的數字一樣

00:14:45.619 --> 00:14:48.322
你需要關心它到底是大尾數還是小尾數

00:14:48.989 --> 00:14:52.192
它需要佔用的空間是ASCII的四倍

00:14:54.161 --> 00:14:58.031
UTF-16就更簡潔些
它用的是16位的數字

00:14:58.098 --> 00:15:01.401
它仍有同樣的問題
小尾數還是大尾數

00:15:02.402 --> 00:15:06.807
因爲它是16位
它只能代表65000個值

00:15:07.274 --> 00:15:11.645
所以你得用代理對來代表超出範圍的值

00:15:11.712 --> 00:15:13.046
因此那就有點累贅

00:15:14.448 --> 00:15:18.619
UTF-8是一個8位面向字節的編碼

00:15:19.253 --> 00:15:21.722
因此
不存在字節的順序問題

00:15:22.322 --> 00:15:28.562
這也正是用它來編碼很理想的原因

00:15:28.629 --> 00:15:31.298
那就讓我們深入研究下UTF-8

00:15:33.467 --> 00:15:37.671
它發明於1992年新澤西的一個深夜

00:15:37.738 --> 00:15:42.142
它是計算機科學天才的罕見作品之一

00:15:42.209 --> 00:15:46.480
當我第一次聽說它的時候
我立馬知道了 這就是答案

00:15:46.547 --> 00:15:48.549
這解決了國際文本的問題

00:15:49.049 --> 00:15:52.152
所以我想告訴你們
一些關於它是如何工作的

00:15:52.219 --> 00:15:54.788
那樣你就理解他到底有多簡單了

00:15:54.855 --> 00:15:57.191
UTF-8的語法

00:15:57.257 --> 00:16:02.663
Unicode的代碼點 從0到7F
和ASCII的值是完全一樣的

00:16:02.729 --> 00:16:06.099
UTF在內存中
用完全一樣的字節代表他們

00:16:06.700 --> 00:16:10.671
它的意思是如果你有一個硬盤裏
裝滿了明文ASCII文件

00:16:10.737 --> 00:16:15.676
我就能魔杖一揮 然後說
我宣佈你現在是UTF-8

00:16:16.376 --> 00:16:18.412
硬盤裏沒有任何一個字節需要改變

00:16:19.079 --> 00:16:21.281
文件的意義也沒有改變

00:16:21.849 --> 00:16:26.086
你對那些傳統的ASCII
有自動的向後兼容性

00:16:26.587 --> 00:16:28.021
這個東西好極了

00:16:28.088 --> 00:16:31.725
UTF-16和UTF-32
以及其他編碼沒有這樣的屬性

00:16:33.327 --> 00:16:36.530
對於ASCII範圍以外的值

00:16:36.597 --> 00:16:39.399
他們會表示成多字節序列

00:16:39.600 --> 00:16:45.739
但所有那些多字節序列
只用字節值大於128的

00:16:46.340 --> 00:16:50.277
所以在ASCII字符和

00:16:50.344 --> 00:16:54.748
大數值Unicode代碼點的
多字節編碼之間是沒有重疊的

00:16:55.382 --> 00:16:58.051
這個屬性不適用於其他

00:16:58.118 --> 00:17:01.288
那些重新使用
高碼字節代表其他東西的編碼

00:17:03.290 --> 00:17:06.126
UTF-8有3種類型的字節

00:17:06.560 --> 00:17:09.796
它有明文ASCII字節

00:17:10.030 --> 00:17:11.164
UTF-8多八位序列

00:17:11.231 --> 00:17:14.501
如果一個字節從最顯眼的0開始

00:17:14.568 --> 00:17:16.303
那就告訴你它是明文ASCII

00:17:17.971 --> 00:17:20.773
如果前2、3或者4位是1

00:17:20.840 --> 00:17:23.644
那就告訴你它是一個兩、
三或者四字節序列

00:17:24.278 --> 00:17:25.913
如果前兩位是10

00:17:25.979 --> 00:17:29.449
那就告訴你它是多字節序列

00:17:29.516 --> 00:17:31.018
我來聯繫語境展示一下

00:17:32.052 --> 00:17:34.021
獨立的ASCII字符

00:17:35.622 --> 00:17:41.161
前兩位是1的字節
意味着它是兩字節序列

00:17:41.595 --> 00:17:43.564
開頭3個1的是三字節序列

00:17:44.064 --> 00:17:46.200
開頭4個1的是四字節序列

00:17:48.569 --> 00:17:50.270
這個賦予了它一個絕妙的屬性

00:17:50.337 --> 00:17:55.642
你可跳到UTF-8文件中間任何地方

00:17:55.709 --> 00:17:58.679
通過看任何老字節
你能分辨出來你看到的是什麼

00:17:59.146 --> 00:18:00.647
這個是獨立的ASCII嗎？

00:18:00.714 --> 00:18:02.983
這是一個多字節序列的開始嗎

00:18:03.050 --> 00:18:04.952
我處在一個多字節序列的中間

00:18:05.018 --> 00:18:08.088
是向前還是向後跳幾位
才能找到字符的邊界？

00:18:08.388 --> 00:18:12.426
所以這對於插入和刪除錯誤來說
是非常非常魯棒的

00:18:12.893 --> 00:18:18.498
這是個效率高到精簡的編碼

00:18:18.565 --> 00:18:21.401
但它又恰有足夠的多餘度使自身可靠

00:18:23.737 --> 00:18:28.809
它另外一個有用的屬性是
在一個字符串的UTF編碼裏

00:18:28.876 --> 00:18:30.110
是沒有0字節的

00:18:30.344 --> 00:18:34.781
而C語言把0看成是一個字符串的結尾
所以這個屬性非常有用

00:18:34.848 --> 00:18:37.317
UTF-16字符串
到處都是0

00:18:37.384 --> 00:18:39.853
UTF-8的屬性

00:18:39.920 --> 00:18:41.221
另外一個不錯的屬性

00:18:41.288 --> 00:18:47.027
是若你在UTF字符串上做一個
無腦簡單的字節檢驗碼的字符串排序

00:18:47.094 --> 00:18:51.665
他們的排序和你直接對Unicode
代碼點排序的結果是一樣的

00:18:52.266 --> 00:18:55.335
這真是一堆絕妙的屬性

00:18:55.936 --> 00:18:59.573
這就是爲何Ken Thompson
發明它之後 僅僅時隔六年

00:19:00.107 --> 00:19:03.944
IETF發佈文檔 要求從那時起

00:19:04.378 --> 00:19:08.782
所有新互聯網標準協議
必須能使用UTF-8

00:19:10.050 --> 00:19:13.787
這個理念也在網路被接受了

00:19:15.255 --> 00:19:17.591
四年前 Google做了個問卷調查

00:19:17.658 --> 00:19:20.961
發現80%的網頁都是UTF-8

00:19:21.028 --> 00:19:24.731
包括了一小部分老式的明文ASCII

00:19:24.798 --> 00:19:27.267
當然也是UTF-8的兼容子集

00:19:27.334 --> 00:19:30.070
UTF-8網頁的百分比

00:19:30.137 --> 00:19:33.340
上個月那個數字增長到了87%

00:19:34.842 --> 00:19:39.146
正因爲這樣 W3C和IETF一樣

00:19:39.213 --> 00:19:43.150
同樣推薦我們只用UTF-8

00:19:43.684 --> 00:19:44.852
這相當棒

00:19:46.220 --> 00:19:47.888
但是有一個問題

00:19:48.488 --> 00:19:53.861
出於某種歷史發展中遺失了的原因
DNS界決定不這麼做

00:19:53.927 --> 00:19:57.197
他們發明瞭一個不同的編碼方法
被叫做Punycode

00:19:58.632 --> 00:20:05.572
Punycode重新使用已有
ASCII字節值來代表不同的東西

00:20:06.306 --> 00:20:10.911
那些字節值對應的是
字母、數字和連字符

00:20:12.513 --> 00:20:17.451
這個的結果是
如果我們有一段字節

00:20:18.252 --> 00:20:21.421
我可把這些字節當成ASCII值處理

00:20:21.889 --> 00:20:23.790
然後得到這樣的東西

00:20:25.125 --> 00:20:28.195
或者我可以把它們
當成Punycode編碼來處理

00:20:28.562 --> 00:20:30.030
然後得到他們真實的內容

00:20:30.731 --> 00:20:36.436
那個對於相同字節的雙重解釋
可能會出現問題

00:20:36.503 --> 00:20:41.141
因爲你想給用戶看的內容並不明確

00:20:41.208 --> 00:20:42.376
或者不是用戶想要的

00:20:42.442 --> 00:20:44.511
如果用UTF-8來做對比

00:20:44.845 --> 00:20:47.214
你注意到的第一件事
是編碼變得簡潔

00:20:47.281 --> 00:20:48.515
它用了更少的字節

00:20:48.982 --> 00:20:51.285
而且只有一個有效的解釋

00:20:51.818 --> 00:20:54.588
所以不會出現模棱兩可的情況

00:20:55.856 --> 00:20:59.960
對你們來說好消息
是你們不需要關心這些

00:21:00.027 --> 00:21:01.495
因爲我們會爲你處理

00:21:02.963 --> 00:21:06.800
在iOS 9和
OS X El Capitan上

00:21:06.867 --> 00:21:12.072
如果你試圖在命令行ping一個
UTF-8的主機名 那會失敗的

00:21:12.673 --> 00:21:14.508
你輸的是UTF-8

00:21:15.175 --> 00:21:20.848
那些字符通過了工具檢測
被API接受併到了網絡上

00:21:20.914 --> 00:21:26.019
但那名字沒以UTF-8
輸入到DNS中 所以失敗了

00:21:26.887 --> 00:21:30.157
從現在開始的iOS 10
和macOS Sierra

00:21:30.791 --> 00:21:36.363
同樣的ping指令
在命令行輸入同樣的UTF-8字符

00:21:37.164 --> 00:21:41.502
我們現會把它翻譯成Punycode

00:21:42.636 --> 00:21:45.305
運行查詢
它將會成功

00:21:46.073 --> 00:21:50.377
這裏ping指令
會使用Punycode

00:21:50.711 --> 00:21:53.247
把它以ASCII形式展示

00:21:53.313 --> 00:21:57.451
所以你看到的是屏幕上這些亂碼
而不是你原本輸入的實際名字

00:21:57.985 --> 00:22:01.522
這也是對同一字符
有雙重翻譯問題的一部分

00:22:01.788 --> 00:22:05.692
但是好消息是所有的
Bonjour和DSA API

00:22:05.759 --> 00:22:09.663
現在會接受以UTF-8格式輸入
的國際文本

00:22:17.337 --> 00:22:18.238
謝謝

00:22:18.906 --> 00:22:21.375
因爲Punycode格式
有非常嚴格的限制

00:22:21.441 --> 00:22:25.012
它甚至不支持
像名字中有空格這樣簡單的東西

00:22:25.078 --> 00:22:28.315
對於Bonjour搜索發現
我們用的是DNS

00:22:28.382 --> 00:22:29.750
我們不想有那麼嚴格的限制

00:22:30.184 --> 00:22:37.090
因此 運算法則的工作方式
是RFC 6763裏記錄的

00:22:37.157 --> 00:22:39.660
我們首先嚐試UTF-8

00:22:40.060 --> 00:22:43.864
如果DNS管理員把UTF-8
放在他們的區域文件裏

00:22:43.931 --> 00:22:47.234
這做起來很簡單
人們在90年代在做的

00:22:47.301 --> 00:22:50.571
我們運行查詢 我們成功了
我們得到了結果 一切都很正常

00:22:51.004 --> 00:22:54.274
現在不同之處在於
若我們失敗了 我們沒有放棄嘗試

00:22:55.075 --> 00:22:57.878
而是用Punycode進行再次嘗試
看看是否奏效

00:22:57.945 --> 00:23:00.013
所以我們在同一個API中支持這兩種

00:23:00.848 --> 00:23:03.483
Email地址

00:23:03.550 --> 00:23:07.054
Email地址當今也變得國際化

00:23:07.688 --> 00:23:10.657
這個做起來也不難

00:23:11.925 --> 00:23:14.962
但是用戶卻碰到問題了
因爲一個愚蠢的小原因

00:23:15.696 --> 00:23:18.232
很多app 當你註冊一個賬戶時

00:23:18.298 --> 00:23:20.801
或者你去網頁上註冊一個賬戶時

00:23:20.868 --> 00:23:24.371
他們試着驗證
這個email地址是否有效

00:23:24.438 --> 00:23:29.243
他們檢查它是否
以.com結尾或者類似的格式

00:23:30.043 --> 00:23:33.146
但有着絕對有效email地址的用戶

00:23:33.213 --> 00:23:36.049
卻不讓註冊賬戶

00:23:36.116 --> 00:23:37.985
因爲他們的email地址被拒絕了

00:23:38.352 --> 00:23:43.724
所以我們需要移除
那些出問題的驗證器

00:23:43.790 --> 00:23:46.426
說實在的 對於email地址
唯一你能檢驗的東西

00:23:46.493 --> 00:23:47.895
是它是否有一個@字符

00:23:48.262 --> 00:23:51.265
如果有的話
它就可能是個有效的email地址

00:23:51.331 --> 00:23:55.068
如果你想知道它是否有效
發送一封確認郵件

00:23:55.135 --> 00:23:58.005
讓用戶迴應以確認它是有效的

00:23:59.573 --> 00:24:03.677
如果你在寫一個email客戶端
或者email服務器

00:24:04.044 --> 00:24:06.480
會有一堆RFC你需要去看一下

00:24:06.847 --> 00:24:10.017
但是對於剩下的人來說
你不需要去擔心它

00:24:10.484 --> 00:24:13.420
讓用戶以UTF-8格式
輸入email地址

00:24:13.954 --> 00:24:18.792
把它存在你客戶端的數據庫中
讓郵件服務器把它

00:24:18.859 --> 00:24:20.961
以email標準編碼正確發出去

00:24:22.162 --> 00:24:24.198
國際文本的範例

00:24:24.264 --> 00:24:28.602
來對這個部分進行一下收尾
我們推薦你把UTF-8用到每個地方

00:24:29.269 --> 00:24:31.071
讓一切變得那麼簡單

00:24:31.538 --> 00:24:33.807
不要擔心Punycode
我們來爲你處理

00:24:34.474 --> 00:24:38.946
對於接受用戶的輸入要自由靈活

00:24:39.012 --> 00:24:41.481
這是個新的多語言國際世界

00:24:43.917 --> 00:24:46.820
下面到了接口部分

00:24:48.322 --> 00:24:53.293
Wi-Fi Assist是
我們去年引入的

00:24:55.462 --> 00:24:56.864
說真的 這不新

00:24:57.397 --> 00:25:01.401
自第一個iPhone起就一直這樣

00:25:02.469 --> 00:25:05.172
如果我有Wi-Fi
我希望我的手機使用它

00:25:06.006 --> 00:25:09.910
如果我沒有Wi-Fi
那就是我爲什麼得花錢買蜂窩數據流量

00:25:09.977 --> 00:25:12.646
這樣出門在外我也有網絡

00:25:13.580 --> 00:25:15.816
第一個iPhone就這樣做了

00:25:16.617 --> 00:25:19.553
我們去年做的改變
是我們做的更好了

00:25:20.387 --> 00:25:23.090
我們對於做的那個決定更明智了

00:25:24.091 --> 00:25:27.861
因爲在Wi-Fi網絡的前沿
總是會有這樣的一個灰色區域

00:25:28.962 --> 00:25:31.798
移動因素也在此之內

00:25:31.865 --> 00:25:34.835
我們有個情況
我們稱之爲停車場問題

00:25:34.902 --> 00:25:38.005
它發生於一天的結束
當你要下班的時候

00:25:38.071 --> 00:25:41.074
你離開了辦公室
你拿出了手機 你有Wi-Fi

00:25:41.175 --> 00:25:44.011
你走出大樓去開車
然後你要查看地圖

00:25:44.077 --> 00:25:46.847
或者天氣預報
或查找電影什麼的

00:25:47.481 --> 00:25:49.449
你的手機以爲它有Wi-Fi

00:25:49.516 --> 00:25:51.852
它一小會兒前是有Wi-Fi

00:25:51.919 --> 00:25:55.556
但是你剛好走出了Wi-Fi的範圍
它還沒意識到

00:25:56.657 --> 00:25:58.926
有了Wi-Fi Assist
我們會去做這個決定

00:25:59.426 --> 00:26:00.694
我們嘗試使用Wi-Fi

00:26:00.761 --> 00:26:02.996
如果不管用
我們就會轉而使用蜂窩數據

00:26:04.765 --> 00:26:09.203
但就像任何新功能
有時候會存在傾向性

00:26:09.670 --> 00:26:13.440
讓新事物成爲人們問題的替罪羊
來遭受責備

00:26:13.807 --> 00:26:17.511
所有人會恨它
當有些app使用了大量的流量

00:26:17.578 --> 00:26:19.413
然後出乎意料地收到了天價賬單

00:26:20.080 --> 00:26:23.050
人們的本性就是責怪新功能

00:26:23.317 --> 00:26:25.853
但其實若你去看
Wi-Fi Assist的流量

00:26:25.919 --> 00:26:27.955
你很可能會發現
那部分非常少

00:26:28.555 --> 00:26:30.991
Wi-Fi Assist通常
不是問題所在

00:26:31.491 --> 00:26:33.794
應用有那個開關

00:26:33.961 --> 00:26:37.431
如果你不想那個應用使用太多流量
你可以把它關掉

00:26:38.165 --> 00:26:41.001
但那非常殘忍 更像是一種
要麼全要 要麼全不要的開關

00:26:41.768 --> 00:26:44.505
很多應用想做一些有點狡猾的事情

00:26:45.305 --> 00:26:47.374
比如你有個視頻流應用

00:26:48.775 --> 00:26:52.913
你可能想讓用戶能瀏覽目錄

00:26:52.980 --> 00:26:57.718
看到指甲蓋大小的小圖片
讀簡介 而這些全通過移動數據

00:26:57.985 --> 00:26:59.152
不會花費太多

00:26:59.853 --> 00:27:05.058
但是你可能想要應用程序的設置
不讓使用移動流量來緩衝視頻

00:27:06.093 --> 00:27:09.296
因爲用戶可能不想花費
太多錢到移動流量上

00:27:09.997 --> 00:27:14.334
如果你有那個設置的話
你會想要能夠辨別

00:27:14.401 --> 00:27:17.404
接收指甲蓋大小的圖片是允許的

00:27:17.471 --> 00:27:19.273
而緩衝視頻是不允許的

00:27:21.041 --> 00:27:24.244
很多開發者做過這樣的事情

00:27:25.312 --> 00:27:28.882
他們用可達性API來問
我在用手機流量？

00:27:29.016 --> 00:27:29.983
是還是否？

00:27:30.217 --> 00:27:32.819
如果沒在用手機流量
那就開始去下載吧

00:27:33.220 --> 00:27:36.023
但是 網絡的事情不是一直不變的

00:27:36.089 --> 00:27:37.958
事情每一秒都可能發生變化

00:27:38.325 --> 00:27:40.194
在你檢查

00:27:40.260 --> 00:27:43.030
是否在用手機流量
和實際上去連接之間

00:27:43.330 --> 00:27:45.432
用戶可能正穿過停車場

00:27:46.166 --> 00:27:49.002
所以這不是做檢查的正確方法

00:27:49.636 --> 00:27:54.241
正確方法是把你的意圖在網絡層表達

00:27:54.308 --> 00:27:56.777
我們會尊重你告訴我們的內容

00:27:58.278 --> 00:28:02.416
第一步是不要管那個“飛行前檢查”

00:28:02.850 --> 00:28:05.352
如果你想做個網絡傳輸
就去試一下

00:28:06.220 --> 00:28:09.990
如果那是一個你不想用蜂窩流量的傳輸

00:28:10.457 --> 00:28:12.960
那麼你可以把它在網絡層表達

00:28:13.460 --> 00:28:15.262
CoreMedia API的使用

00:28:15.629 --> 00:28:21.101
你使用NSURLSession來設置
allowsCellularAccess關鍵字

00:28:21.535 --> 00:28:24.371
若把allowsCellularAccess設爲假

00:28:24.671 --> 00:28:27.074
那麼我們就不會使用蜂窩數據進行連接

00:28:27.741 --> 00:28:28.675
簡單又好用

00:28:36.116 --> 00:28:39.152
如果連接失敗
你可以詢問用戶

00:28:39.219 --> 00:28:41.388
你想用移動流量還緩衝視頻嗎

00:28:42.289 --> 00:28:46.793
或者你可以等 訂閱更好途徑的提示

00:28:47.060 --> 00:28:50.531
當手機恢復Wi-Fi連接時
你就會被告知

00:28:50.764 --> 00:28:54.935
然後你就可在Wi-Fi再次可用時
重試你的連接

00:28:58.872 --> 00:29:04.178
總結一下
不要假設因爲你現在有Wi-Fi

00:29:04.244 --> 00:29:08.015
你在一秒以後仍然有Wi-Fi
甚至半秒以後

00:29:08.815 --> 00:29:09.816
情況一直在變

00:29:10.851 --> 00:29:14.688
把你想要的在網絡層表達
我們會遵從的

00:29:15.389 --> 00:29:16.757
網絡服務質量（QoS）

00:29:16.823 --> 00:29:20.661
我們最後一個話題是網絡服務質量

00:29:23.197 --> 00:29:27.634
去年夏天 我們宣佈了
Apple和Cisco的合作關係

00:29:27.701 --> 00:29:31.305
我來告訴你們一些關於新API的內容

00:29:31.371 --> 00:29:36.410
你就可以在網絡層來表達你的需求了

00:29:38.579 --> 00:29:40.547
實際中存在不同種類的網絡通信

00:29:41.915 --> 00:29:48.055
我們所做99%的事情是好的
標準的因特網盡力而爲流量

00:29:48.388 --> 00:29:53.493
我們想要能得到的最大吞吐量
並且我們最好能降低延時

00:29:54.695 --> 00:29:57.130
但是我們一定想要吞吐量越大越好

00:29:57.364 --> 00:29:59.967
用來滿足瀏覽網頁、發送email

00:30:02.169 --> 00:30:07.541
我們做的另外一件事是聯機備份
把圖片上傳到iCloud

00:30:08.308 --> 00:30:11.678
這也想要好一些的吞吐量

00:30:12.379 --> 00:30:14.648
但不像高優先級的東西需要的那麼大

00:30:15.249 --> 00:30:18.986
我們想把所有圖片上傳到iCloud

00:30:19.052 --> 00:30:24.691
讓這個過程在後臺完成
還不打擾看Netflix TV興致

00:30:25.559 --> 00:30:28.629
圖片上傳應該在我們睡覺時進行

00:30:29.162 --> 00:30:31.431
俗稱清道夫級別的流量

00:30:31.498 --> 00:30:34.535
它用的是網絡其他時候空閒的流量

00:30:34.601 --> 00:30:36.770
不然那些就被浪費了

00:30:36.837 --> 00:30:40.541
但第二類通信是
發送email 瀏覽網頁

00:30:40.607 --> 00:30:42.743
以及任何人們頻繁參與的活動

00:30:44.411 --> 00:30:50.317
第三類通信是電話語音
交互式語音和視頻

00:30:50.751 --> 00:30:53.220
我說交互式
是因爲它是關鍵部分

00:30:53.587 --> 00:30:55.322
當我們在談話時

00:30:55.522 --> 00:30:59.860
我說一句話 你聽到了 你要做回答
你回了我一句話 我也聽到了

00:31:00.093 --> 00:31:03.163
如果這個來回需要幾百毫秒

00:31:03.497 --> 00:31:05.432
人們的通信就被打斷了

00:31:08.335 --> 00:31:10.604
當人們談到語音和視頻時

00:31:10.671 --> 00:31:15.609
意識到一點很重要 就是看的
YouTube視頻可能是個視頻

00:31:16.043 --> 00:31:17.344
但它不是交互的

00:31:17.411 --> 00:31:20.547
它不需要那200毫秒
往返時間的附屬條件

00:31:21.815 --> 00:31:25.886
聽的播客節目可能是語音
但是它不意味着播客服務是聲音通信

00:31:25.953 --> 00:31:26.987
它不是互動的

00:31:28.488 --> 00:31:31.325
這就是爲何我把圖表這部分
標註爲電話語音

00:31:31.391 --> 00:31:33.460
因爲這是交互式語音和視頻

00:31:34.294 --> 00:31:37.197
對這類通信
你想要儘可能低的往返時間

00:31:38.632 --> 00:31:39.967
而且它的吞吐量非常小

00:31:40.033 --> 00:31:43.337
每秒只有幾千比特
你不需要50兆比特的語音

00:31:43.971 --> 00:31:49.810
所以把你的通信標記爲電話語音
會告訴網絡保持低延遲

00:31:50.577 --> 00:31:52.145
但是你也不要把隊列弄大

00:31:52.446 --> 00:31:56.049
若你試圖把語音類
做任何形式的批量傳輸

00:31:56.216 --> 00:31:59.119
你將會丟掉大部分的數據包

00:31:59.186 --> 00:32:02.022
因爲只有很少的網絡流量

00:32:02.089 --> 00:32:03.590
被分給了這類通信

00:32:03.891 --> 00:32:09.096
人們問的一個常見問題是
Fastlane會讓我的應用變快嗎？

00:32:09.162 --> 00:32:11.598
答案是 不會的
它不會讓你的應用變快

00:32:11.899 --> 00:32:13.867
它會減低語音通信的延時

00:32:17.404 --> 00:32:19.706
你可能會好奇 這個和

00:32:19.773 --> 00:32:23.177
Smart Queue Management
還有Explicit Congestion Notification

00:32:23.477 --> 00:32:25.179
就是之前談過的那兩個有什麼關聯

00:32:25.245 --> 00:32:30.050
答案是 那些技術全面改善了

00:32:30.717 --> 00:32:33.754
所有通信的延時

00:32:34.421 --> 00:32:38.158
但是電話語音可能還會是個極端個例

00:32:38.358 --> 00:32:40.694
它想要非常非常低的延遲

00:32:40.761 --> 00:32:44.231
不惜犧牲吞吐量來達到

00:32:45.399 --> 00:32:47.568
網絡服務類型API

00:32:47.634 --> 00:32:52.239
從iOS 5開始
我們就有了網絡服務類型API

00:32:52.706 --> 00:32:55.375
它讓你能向網絡表達你的一些需求

00:32:56.043 --> 00:33:00.214
但很多開發者寫的
諸如Skype和Facetime

00:33:00.280 --> 00:33:04.751
是通過UDP來做這類電話語音通信的

00:33:05.352 --> 00:33:09.590
在現在的iOS上要使用UDP
你需要使用BSD套接字

00:33:09.990 --> 00:33:15.629
所以我們現在有一個套接口選項
用來公開相同的功能

00:33:15.929 --> 00:33:19.166
這樣你的UDP客戶端可以從中受益

00:33:20.100 --> 00:33:24.104
我們知道一些開發者
過去一直在一次嘗試中設置

00:33:24.171 --> 00:33:27.574
服務的IP類型位系統
來達到同樣的效果

00:33:28.876 --> 00:33:32.746
問題是那些服務類型位系統
沒被很好地定義

00:33:32.813 --> 00:33:34.281
他們沒在任何地方被詳細說明

00:33:34.648 --> 00:33:38.452
一些Wi-Fi芯片供貨商會看
服務類型位系統

00:33:38.519 --> 00:33:41.321
然後把它當作設置

00:33:41.388 --> 00:33:45.759
Wi-Fi通信類型爲語音、
視頻或後臺的提示

00:33:46.994 --> 00:33:50.063
但是問題是
沒有對這些位系統進行標準定義

00:33:50.130 --> 00:33:52.533
詮釋起來就會不一致

00:33:52.766 --> 00:33:56.737
所以你可能在你辦公室測試過了
認爲一切正常

00:33:56.803 --> 00:33:58.572
但是對於一個客戶
卻是另外一回事

00:33:59.039 --> 00:34:00.707
這就是爲何我們有了新的套接口選項

00:34:00.774 --> 00:34:04.077
會在任何設備上
給你提供可靠的、一致的行爲

00:34:06.413 --> 00:34:07.948
如果你在用Swift編程

00:34:08.482 --> 00:34:12.386
你可以設置網絡服務類型屬性爲
語音、視頻或後臺

00:34:12.686 --> 00:34:16.790
或者你根本不去設置
那麼它就是傳統的盡最大努力傳輸

00:34:17.658 --> 00:34:21.228
如果你在使用套接口選項
我們有同樣的選項

00:34:21.862 --> 00:34:24.965
我們有其他大概多於七個的選項

00:34:25.199 --> 00:34:27.167
多於你們中大部分人需要的

00:34:27.234 --> 00:34:29.036
這些是四個有意思的

00:34:29.203 --> 00:34:31.737
鏈路層QoS標記

00:34:31.804 --> 00:34:35.141
當你設置這些選項時
會發生一些事

00:34:36.643 --> 00:34:39.679
在設備自身
有一些帶外隊列

00:34:40.347 --> 00:34:46.053
你爲通信設置的服務類型
控制它使用哪個隊列

00:34:47.621 --> 00:34:52.993
在Wi-Fi接口
它也會設置無線多媒體訪問類

00:34:54.360 --> 00:34:57.698
在iOS和OS X上
所有的設備都支持這個

00:34:58.332 --> 00:35:01.935
而且帶外隊列選擇同樣適用於
Ethernet和Wi-Fi

00:35:03.704 --> 00:35:10.177
現在 若你的設備在這些新的
Cisco Fastlane網絡上

00:35:10.777 --> 00:35:13.380
我們會識別也會設置

00:35:13.447 --> 00:35:17.317
IP層區分服務代碼點

00:35:17.384 --> 00:35:20.621
這樣你就能得到想要的處理方式

00:35:20.787 --> 00:35:23.757
不只是在它離開設備的第一跳

00:35:23.824 --> 00:35:26.193
而是在企業網絡上併發跳越

00:35:27.995 --> 00:35:31.765
我想強調的是
這不是你們所有人都需要的

00:35:31.832 --> 00:35:34.268
不必感覺你得走開
對代碼進行改動

00:35:34.801 --> 00:35:39.306
如果你在寫一個在線備份的應用
一定設置後臺通信類

00:35:39.907 --> 00:35:44.678
如果你在寫下一代的Skype
那就設置成語音類

00:35:45.078 --> 00:35:46.613
但是對於剩下的人來說

00:35:47.414 --> 00:35:50.317
標準的盡最大努力傳輸
幾乎可以確定就是你需要的

00:35:51.652 --> 00:35:53.487
還有一些其他事情你們應該記住

00:35:55.055 --> 00:35:58.825
帶外隊列選擇和Wi-Fi層

00:35:58.892 --> 00:36:01.762
服務質量標記被所有設備支持

00:36:01.929 --> 00:36:04.031
但是記住只適用帶外數據包

00:36:04.097 --> 00:36:07.801
進來的數據包
必須被另一端的發送者標記

00:36:08.435 --> 00:36:14.107
IP層的標記也只針對帶外數據包

00:36:14.775 --> 00:36:20.113
現只被Cisco網絡的兼容設備支持

00:36:20.814 --> 00:36:21.982
只被iOS支持

00:36:22.049 --> 00:36:25.419
不被Mac和Apple TV
或其他設備支持

00:36:26.119 --> 00:36:28.222
而且目前 只被Wi-Fi支持

00:36:28.288 --> 00:36:30.691
絕大多數人
在iPad上不用Ethernet

00:36:30.891 --> 00:36:32.793
但若你插入了Ethernet適配器

00:36:33.327 --> 00:36:35.662
服務質量不被Ethernet支持

00:36:36.363 --> 00:36:40.834
最後一點 如果管理員選擇安裝

00:36:40.901 --> 00:36:43.270
一個管理配置文件在設備上

00:36:43.337 --> 00:36:45.973
那麼管理配置文件可以限制

00:36:46.039 --> 00:36:49.977
那個應用可以使用這類服務選項

00:36:50.043 --> 00:36:53.814
只有在配置文件列表的應用
纔能夠設置服務類型

00:36:53.881 --> 00:36:56.049
對於其他應用來說將是個無操作

00:36:59.920 --> 00:37:01.488
概況來說這個部分

00:37:03.590 --> 00:37:06.193
你們大多數人的通信
應該繼續是盡最大努力

00:37:06.260 --> 00:37:07.494
網絡服務類型的最佳實踐

00:37:07.561 --> 00:37:11.265
如果你要做大型的批量傳輸
且時間並不那麼重要

00:37:11.331 --> 00:37:13.967
後臺通信是一個讓你少受打擾的方法

00:37:14.034 --> 00:37:15.969
讓你在網絡上成爲一個更好的公民

00:37:16.603 --> 00:37:18.772
記住 它沒有優先級這一說

00:37:19.173 --> 00:37:22.543
沒有所謂的高優先級到低優先級的排序

00:37:22.976 --> 00:37:27.247
它是一個web表達
你是否想要小吞吐量和低延遲

00:37:27.314 --> 00:37:30.284
還是大吞吐量和中等延遲

00:37:34.655 --> 00:37:35.822
今天的演講就到這裏

00:37:36.223 --> 00:37:37.257
謝謝你們的到來

00:37:37.658 --> 00:37:41.495
我們談了Smart
Queue Management

00:37:41.562 --> 00:37:46.667
這對所有ISP和運營商
以及網絡供貨商是一個號召行爲

00:37:47.434 --> 00:37:49.002
客戶端開始支持ECN

00:37:49.069 --> 00:37:50.637
服務器開始支持ECN

00:37:51.038 --> 00:37:53.340
如果你開始在你的網絡上標記數據包

00:37:53.407 --> 00:37:56.410
而不是丟棄他們
你會讓你的用戶更開心

00:37:57.077 --> 00:37:59.646
對在做的開發者的一句話

00:37:59.713 --> 00:38:05.285
是IPv6現在對於很多網絡運營商
在很多網絡上是主流的通信方式

00:38:06.086 --> 00:38:09.323
在你的應用程序中支持IPv6

00:38:09.756 --> 00:38:13.660
在你的服務器上
支持IPv6和IPv4

00:38:15.062 --> 00:38:18.031
對於你的文本
UTF-8是新的ASCII

00:38:18.365 --> 00:38:19.867
不比ASCII難

00:38:20.701 --> 00:38:22.369
用起來實在非常簡單

00:38:22.703 --> 00:38:26.106
我們現在所有的設備都良好地支持

00:38:26.306 --> 00:38:28.442
所有的Unicode字符的文字

00:38:28.509 --> 00:38:32.246
這樣那就沒任何疑慮支持UTF-8了

00:38:33.180 --> 00:38:38.085
最後 我們有新方法
讓你在網絡層表達意願

00:38:39.052 --> 00:38:41.922
你可以控制
什麼時候你不想使用蜂窩流量

00:38:42.723 --> 00:38:46.159
你現在也可以更好地控制

00:38:46.226 --> 00:38:49.029
數據吞吐量延遲的特性

00:38:50.531 --> 00:38:51.798
就是這些了

00:38:52.399 --> 00:38:54.835
這裏有個鏈接 你可以找到更多信息

00:38:55.636 --> 00:38:58.605
我們有其他講座
你可以觀看它的視頻

00:38:59.206 --> 00:39:00.307
你可能會感興趣

00:39:00.374 --> 00:39:04.278
我們有關於網絡和安全的講座 很重要

00:39:04.344 --> 00:39:07.114
我們還有幾個其他講座
是關於國際化的

00:39:07.714 --> 00:39:12.219
我們有一些講座關於高層級
網絡應用程序的 像HomeKit

00:39:12.519 --> 00:39:15.622
那就這樣吧
感謝來到WWDC