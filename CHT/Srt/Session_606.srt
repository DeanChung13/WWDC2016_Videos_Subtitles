00:00:19.520 --> 00:00:24.992
高級Metal着色器優化

00:00:31.532 --> 00:00:32.866
大家好

00:00:32.966 --> 00:00:35.602
我叫Fiona
這是我的同事Alex

00:00:36.069 --> 00:00:39.806
我任職於iOS GPU處理器團隊

00:00:39.873 --> 00:00:43.277
我們的工作就是讓大家的着色器
運行於最新的iOS設備上

00:00:43.377 --> 00:00:46.180
而且讓它們儘可能高效地運行

00:00:46.647 --> 00:00:48.982
這裏我要談一下我們的演講

00:00:49.116 --> 00:00:50.517
高級Metal着色器優化

00:00:50.584 --> 00:00:53.954
鍛造和打磨你的Metal着色器

00:00:54.721 --> 00:00:56.757
我們的編譯器是基於LVM的

00:00:56.823 --> 00:00:58.492
而且我們和開源社區合作

00:00:58.559 --> 00:01:01.862
讓LVM更加適用於GPU

00:01:03.730 --> 00:01:07.034
這是其它幾個Metal相關的演講
萬一你錯過了的話

00:01:07.100 --> 00:01:08.969
不用擔心 你可以上網看錄像

00:01:09.336 --> 00:01:11.738
昨天講了Metal應用的
第一部分和第二部分

00:01:12.239 --> 00:01:14.975
今天早些時候講了Metal新特性
的第一和第二部分

00:01:15.042 --> 00:01:16.743
因爲Metal有太多新的東西了

00:01:17.311 --> 00:01:18.946
當然 現在這個是最後一部分

00:01:19.513 --> 00:01:20.781
就是你們現在看的東西

00:01:22.115 --> 00:01:24.918
所以在這個演講中
我們將討論一些東西

00:01:24.985 --> 00:01:28.889
你們可以利用這些編輯器相關的東西
來讓你們的代碼運行地更快

00:01:29.489 --> 00:01:33.760
這些中的一部分是針對A8處理器
和更新的圖像處理器

00:01:33.827 --> 00:01:36.763
包括一些從未被公佈過的信息

00:01:37.598 --> 00:01:39.399
其中一些也將比較通俗

00:01:39.466 --> 00:01:42.302
我們會談到大家看到A8的圖標

00:01:42.503 --> 00:01:45.372
在演示文稿中 是針對A8處理器的

00:01:45.973 --> 00:01:50.010
另外 我們會談一些潛在的陷阱

00:01:50.377 --> 00:01:53.981
這些東西一般不會出現 就像微優化

00:01:54.047 --> 00:01:55.482
你們經常發現的那樣

00:01:55.749 --> 00:01:59.319
但是一旦你們碰到了
很有可能會降低很多性能

00:01:59.386 --> 00:02:01.488
相比之下 其他東西都不重要了

00:02:01.688 --> 00:02:04.424
所以始終要確保你們不會掉入這些陷阱

00:02:04.491 --> 00:02:07.427
這些會被標記上三角符號
正如你們看到的那樣

00:02:08.127 --> 00:02:10.597
在我們繼續之前 這不是第一步

00:02:10.931 --> 00:02:12.132
這是最後一步

00:02:12.799 --> 00:02:15.369
進行低級別的着色器優化是沒有意義的

00:02:15.435 --> 00:02:17.771
除非之前你已經做了高級別的優化

00:02:17.838 --> 00:02:19.406
比如觀看其他的Metal演講

00:02:19.473 --> 00:02:22.976
優化你的繪製調用 你的引擎結構等等

00:02:23.577 --> 00:02:26.813
優化你的着色器差不多是
你要做的最後一件事情

00:02:27.481 --> 00:02:31.952
而且 這個演講主要是給
經驗豐富的着色器程序員

00:02:32.419 --> 00:02:34.188
也許你在Metal方面經驗豐富

00:02:34.254 --> 00:02:36.356
而且你想要更深入的學習優化着色器

00:02:36.423 --> 00:02:40.227
又或許你剛開始接觸Metal
但你已在着色器優化方面做了很多工作

00:02:40.294 --> 00:02:42.896
在其他平臺
而且你想知道如何更好地優化

00:02:42.963 --> 00:02:46.600
A8處理器和更新的圖像處理器
這個演講就是爲你們準備的

00:02:48.302 --> 00:02:51.905
你可能已經看過這個管線圖了
若你看過任意一個之前Metal演講

00:02:52.339 --> 00:02:56.376
當然 我們也將聚焦在
這個管線圖的編碼階段

00:02:56.443 --> 00:02:58.312
正如你們所見的 着色器課程

00:02:59.213 --> 00:03:02.449
首先 Alex將會講一下
一些着色器性能的基本知識

00:03:02.516 --> 00:03:03.784
和一些高級一點的問題

00:03:03.851 --> 00:03:09.456
然後 我會回來講一些低級別的
底層的 繁瑣的着色器優化

00:03:10.624 --> 00:03:12.459
着色器性能基礎

00:03:17.731 --> 00:03:19.900
謝謝Fiona 首先讓我解釋一下

00:03:19.967 --> 00:03:21.268
着色器性能基礎

00:03:21.702 --> 00:03:22.903
這些是你想要確保

00:03:22.970 --> 00:03:26.106
你們是對的
在你們深入瞭解源代碼級別的優化

00:03:26.473 --> 00:03:29.643
通常你們在此所做改變的影響可能弱化

00:03:29.710 --> 00:03:33.013
或者潛在地掩蓋你在其它地方
做的更加有針對性的改變

00:03:33.347 --> 00:03:34.815
所有今天我打算談四個方面

00:03:34.882 --> 00:03:37.084
緩衝參數的地址空間選擇

00:03:37.150 --> 00:03:38.619
緩衝預加載

00:03:38.685 --> 00:03:40.354
碎片函數資源的處理

00:03:40.420 --> 00:03:42.422
和如何優化電腦內核

00:03:44.324 --> 00:03:45.692
好 讓我們從地址空間開始

00:03:46.159 --> 00:03:48.762
因爲這個功能不存在於

00:03:48.829 --> 00:03:50.597
所有着色語言
我給大家簡單的入門

00:03:51.231 --> 00:03:53.734
所以 圖像處理器有很多的途徑
從內存中拿到數據

00:03:53.800 --> 00:03:56.937
而對於不同的應用場景
這些途徑都是被優化過的

00:03:57.070 --> 00:03:59.840
所以它們有着不同的性能特徵

00:04:00.641 --> 00:04:04.511
在Metal中 我們給了開發者
使用路徑的控制權

00:04:04.578 --> 00:04:08.348
通過要求它們符合所有的緩存器
參數和指針

00:04:08.415 --> 00:04:11.385
在着色語言中 用它們要用的地址空間

00:04:11.652 --> 00:04:14.655
所以一部分地址空間專門用於

00:04:14.721 --> 00:04:16.790
從內存中提取信息

00:04:18.358 --> 00:04:20.427
其中的第一個就是設備地址空間

00:04:20.994 --> 00:04:23.163
這是一個限制相對較少的地址空間

00:04:23.230 --> 00:04:24.965
你可以通過地址空間來讀寫數據

00:04:25.032 --> 00:04:26.900
你可以傳任意多的數據

00:04:26.967 --> 00:04:29.369
你在API級別指定的寄存器

00:04:29.436 --> 00:04:31.605
有着相對靈活的參數要求

00:04:33.574 --> 00:04:35.876
另一方面 你有固定的地址空間

00:04:36.076 --> 00:04:38.111
如名字中所寫
這是一個只讀的地址空間

00:04:38.178 --> 00:04:39.847
但是有另外一些約束

00:04:40.247 --> 00:04:42.115
你能傳輸的數據量是有限制的

00:04:42.182 --> 00:04:44.284
通過地址空間 另外 緩存區偏移量

00:04:44.351 --> 00:04:47.788
你在API級別指定的
有更加嚴格的對齊要求

00:04:48.222 --> 00:04:49.823
但是 這就是地址空間

00:04:49.890 --> 00:04:51.959
被優化 爲了大量數據重用的情況

00:04:52.025 --> 00:04:54.761
所以 每當它有理的時候
你就會利用這個地址空間

00:04:56.063 --> 00:04:57.965
找出是否這個連續地址空間

00:04:58.031 --> 00:04:59.266
對你的緩衝器參數有意義

00:04:59.333 --> 00:05:01.835
通常在於兩個問題

00:05:02.636 --> 00:05:05.105
第一個問題是
我是否知道我有多少數據

00:05:05.539 --> 00:05:07.708
如果你的數據量是變化的

00:05:07.774 --> 00:05:10.711
這通常就是你需要使用
設備地址空間的一個信號

00:05:11.378 --> 00:05:16.450
另外 你要看一下緩衝器中的
每一個有多少被讀取

00:05:16.517 --> 00:05:20.621
如果這些可能被讀取多次

00:05:20.988 --> 00:05:23.857
這通常表示你需要
把他們放下連續地址空間

00:05:24.825 --> 00:05:26.960
讓我們用幾個例子把這付諸實踐

00:05:27.027 --> 00:05:28.395
例子源於一些頂點着色器

00:05:29.830 --> 00:05:31.899
首先 你有規則的原始頂點數據

00:05:32.900 --> 00:05:36.370
可以看出 每個頂點有自己的數據塊

00:05:36.803 --> 00:05:38.972
而且每個數據塊只被自己的頂點讀

00:05:39.039 --> 00:05:40.474
因此基本上沒有重用

00:05:40.541 --> 00:05:45.412
這是在設備地址空間
真正需要滿足的條件

00:05:46.747 --> 00:05:51.618
接着 你有投影矩陣以及其它的矩陣

00:05:52.186 --> 00:05:54.087
現在 屬於你的

00:05:54.421 --> 00:05:59.927
是你有一個對象
這些對象被單一的頂點讀

00:06:00.594 --> 00:06:02.396
在完全的數據重用情況下

00:06:02.462 --> 00:06:04.631
你想這個對象在常量地址空間裏

00:06:07.935 --> 00:06:10.737
把東西混合一點後 分析常量矩陣

00:06:11.171 --> 00:06:14.741
在這種情況下 很大可能你能得到最大

00:06:14.808 --> 00:06:16.009
bone數
這些對象是你正在處理的

00:06:16.643 --> 00:06:18.278
但是你單個看每個bone時

00:06:19.079 --> 00:06:21.882
矩陣可以被每一個和
那個bone相關的頂點讀取

00:06:21.949 --> 00:06:24.985
這也是潛在的大量重用

00:06:25.052 --> 00:06:27.688
所以這也該在常量地址空間裏

00:06:29.223 --> 00:06:31.191
最後，讓我們來看看每一個實例數據

00:06:33.861 --> 00:06:35.996
如你所見，例子中的所有頂點

00:06:36.063 --> 00:06:37.898
將會讀取這個特定的數據

00:06:38.332 --> 00:06:41.401
但是另一方面
你有一些潛在的可變實例

00:06:41.468 --> 00:06:44.238
所以這也應該在設備地址空間裏

00:06:45.839 --> 00:06:48.842
爲何地址空間的選擇對於性能那麼重要

00:06:48.909 --> 00:06:51.211
我們進入到下一個話題 緩衝器預加載

00:06:53.113 --> 00:06:54.815
Fiona將會花些時間講一下

00:06:54.882 --> 00:06:57.251
如何真正地在着色器中優化加載和存儲

00:06:57.317 --> 00:06:59.720
但在很多情況下
你能做的最好的事就是

00:06:59.786 --> 00:07:02.623
把這個工作交給專門的硬件去做

00:07:03.257 --> 00:07:04.892
以下兩種情況
我們能做優化

00:07:05.392 --> 00:07:07.160
背景緩存和頂點緩存

00:07:07.528 --> 00:07:12.032
但是這基於 你知道着色器中訪問模式

00:07:12.099 --> 00:07:13.934
和你把它們放在了什麼地址空間

00:07:15.402 --> 00:07:17.070
讓我們以常量緩存預加載

00:07:17.704 --> 00:07:19.039
所以這裏想說的是

00:07:19.106 --> 00:07:21.008
不同於通過常量地址空間來加載

00:07:21.074 --> 00:07:22.643
我們其實要做的是拿到你的數據

00:07:22.709 --> 00:07:25.379
然後將它們置於特殊的常量寄存器
這些寄存器是更快的

00:07:25.445 --> 00:07:26.547
對於ALU的讀寫

00:07:27.214 --> 00:07:29.816
所以只要我們知道什麼數據會被讀取
我們就可這麼做

00:07:30.651 --> 00:07:33.787
如果你的偏移量是已知的編譯時間
這就很直接明瞭了

00:07:33.954 --> 00:07:36.056
但是如果你的偏移量在運行前是未知的

00:07:36.123 --> 00:07:37.824
那麼我們就需要一些額外的信息

00:07:37.891 --> 00:07:39.426
關於你正在讀取多少數據量

00:07:41.495 --> 00:07:44.865
所以給編譯器表明
這個通常需要兩個步驟

00:07:44.965 --> 00:07:47.668
第一 你需要確保這個數據
是在常量地址空間

00:07:48.936 --> 00:07:51.972
另外你需要表明
你的訪問時是靜態綁定的

00:07:53.207 --> 00:07:55.442
做這個最好的方式是通過傳參數時

00:07:55.609 --> 00:07:57.978
儘量使用引用而不是指針

00:07:58.212 --> 00:08:00.614
若你只是傳遞一個參數或者一個結構體

00:08:00.681 --> 00:08:03.650
這是很直接的
你可以只改變指向引用的指針

00:08:03.717 --> 00:08:05.219
和對應地改變你的訪問

00:08:06.253 --> 00:08:09.022
如果你傳遞一個綁定的數組
這就會有所不同

00:08:09.590 --> 00:08:12.593
所以你在這個例子中要做的是
你可以嵌入那個大小的數組

00:08:12.659 --> 00:08:16.163
並將那個結構體通過引用來傳遞
而不是傳遞原來的指針

00:08:16.864 --> 00:08:18.966
我們通過一個例子來實踐一下

00:08:19.633 --> 00:08:21.435
在前燈碎片着色器

00:08:22.202 --> 00:08:24.705
如你在原始版本中看到的那樣

00:08:24.771 --> 00:08:26.106
我們有的是一些參數

00:08:26.173 --> 00:08:27.574
作爲普通設備指針進行傳遞

00:08:27.641 --> 00:08:29.810
而且這並沒有給出我們想要的信息

00:08:30.544 --> 00:08:31.712
所以我們能比這個做得更好

00:08:32.212 --> 00:08:34.114
相反 若我們注意到燈的數量相互關聯

00:08:34.181 --> 00:08:36.817
我們能做的就是將燈的數據

00:08:36.884 --> 00:08:39.219
和數量一起放在這麼一個結構體中

00:08:40.587 --> 00:08:42.990
然後將這個結構體傳給常量地址空間

00:08:43.056 --> 00:08:44.157
作爲像這樣一個引用

00:08:44.725 --> 00:08:46.727
這樣 我們就實現了常量緩存預加載

00:08:48.295 --> 00:08:51.198
讓我們在看一個例子
看看它實際中是如何影響你的

00:08:52.165 --> 00:08:55.135
實現延遲渲染有很多種方式

00:08:55.202 --> 00:08:57.638
但是我們發現實際上
你選擇的實現方式

00:08:57.704 --> 00:09:00.040
會對實踐中你實現的性能

00:09:00.107 --> 00:09:01.408
有很大的影響

00:09:02.843 --> 00:09:05.379
現在一種常用的模式是使用單一着色器

00:09:05.445 --> 00:09:07.814
來積累出所有燈光的結果

00:09:08.382 --> 00:09:11.018
正如你在函數的聲明中看到的那樣

00:09:11.084 --> 00:09:13.287
它可能在這個場景中
讀取任意或者所有的光

00:09:13.353 --> 00:09:15.255
這意味着你的輸入大小是無關聯的

00:09:17.224 --> 00:09:19.960
另一方面 如果你能結構化你的渲染

00:09:20.027 --> 00:09:22.763
使得每一個光在它自己的
繪製調用中被處理

00:09:22.829 --> 00:09:27.134
那麼每一個光就只需要讀那個光的數據

00:09:27.201 --> 00:09:29.970
它是着色器 那意味着你可以傳遞

00:09:30.037 --> 00:09:33.473
在常量地址空間和充分利用緩存預加載

00:09:34.274 --> 00:09:38.111
其實我們發現在A8後的圖像處理器上
這有一個很大的性能提升

00:09:40.614 --> 00:09:42.716
現在讓我們談一下頂點緩存預加載

00:09:42.783 --> 00:09:45.786
頂點緩存預加載的目的是
重用相同的專用硬件

00:09:45.853 --> 00:09:47.921
我們會在固定的函數頂點獲取中使用

00:09:48.889 --> 00:09:51.525
我們可在常規緩存加載中做這個 就像

00:09:51.592 --> 00:09:54.461
你在讀取緩存
看上去就像固定函數頂點獲取

00:09:54.862 --> 00:09:55.829
它意味着你需要

00:09:55.896 --> 00:09:58.098
使用頂點或者實例的ID來進行索引

00:09:58.832 --> 00:10:01.235
現在我們可以處理一些額外的改變

00:10:01.301 --> 00:10:04.071
爲頂點或者實例ID
比如應用一個發生器

00:10:04.137 --> 00:10:06.840
使用或者不使用基本頂點

00:10:06.907 --> 00:10:08.976
或實例偏移量
你可能在API級別的應用

00:10:10.077 --> 00:10:12.145
當然最簡單的方式是充分利用

00:10:12.212 --> 00:10:15.849
儘量使用Metal頂點描述功能

00:10:16.450 --> 00:10:18.151
但是如果你寫你自己的索引代碼

00:10:18.752 --> 00:10:20.287
我們強烈建議設計你的數據

00:10:20.354 --> 00:10:23.123
使得頂點線性到達而簡化緩衝區索引

00:10:23.824 --> 00:10:26.059
意識到這並不妨礙你做自己喜歡的事情

00:10:26.126 --> 00:10:28.996
比如你在畫矩形 你想賦值

00:10:29.429 --> 00:10:33.133
給矩形的所有頂點
你仍然可以做其它事情

00:10:33.200 --> 00:10:36.937
像用頂點ID除以4建立索引
因爲這看起來就像個分配器

00:10:38.672 --> 00:10:42.276
讓我們繼續着色器階段的一些具體問題

00:10:43.911 --> 00:10:46.947
在iOS 10裏
我們介紹了記錄資源的功能

00:10:47.014 --> 00:10:48.448
在片段功能裏

00:10:48.782 --> 00:10:51.151
對於隱藏的表面去除有着有趣的含義

00:10:52.252 --> 00:10:54.321
在這之前你也許已經習慣這種行爲

00:10:54.388 --> 00:10:56.423
片段不需要被着色

00:10:56.823 --> 00:10:59.293
只要一個不透明的片段過來遮擋它

00:11:00.160 --> 00:11:02.095
所以這不再是正確的尤其

00:11:02.162 --> 00:11:03.797
當你的片段功能正在寫資源

00:11:03.864 --> 00:11:05.866
因爲這些資源記錄仍需要發生

00:11:06.767 --> 00:11:10.270
相反你的行爲僅僅取決於
前面所發生的事情

00:11:10.904 --> 00:11:12.472
確切地說 發生什麼取決於

00:11:12.539 --> 00:11:15.676
在你的片段功能裏
你是否能進行早期的片段測試

00:11:16.443 --> 00:11:20.681
如果你通過 了早期的片段測試
一旦被柵格化

00:11:20.747 --> 00:11:23.650
只要它通過早期的深度和模塊測試

00:11:24.418 --> 00:11:26.353
如果你沒有指定早期的片段測試

00:11:26.420 --> 00:11:29.323
那麼只要它被柵格化了
你的片段就會被着色

00:11:30.057 --> 00:11:32.159
所以從最小化你的着色器的角度看

00:11:32.226 --> 00:11:35.062
你要做的是儘量早地使用早期片段測試

00:11:35.128 --> 00:11:36.330
但是有一些其它事情

00:11:36.396 --> 00:11:38.732
你可以做的 來提高你得到的拒絕

00:11:40.167 --> 00:11:41.768
且這其中大部分歸結於繪製順序

00:11:41.835 --> 00:11:44.304
你想要繪製這些圖案

00:11:44.371 --> 00:11:47.040
片段函數進行資源寫的圖案

00:11:47.307 --> 00:11:48.509
在不透明的圖案的後面

00:11:48.775 --> 00:11:51.678
而且如果你使用這些圖案
來更新的你的深度和畫筆緩存

00:11:51.745 --> 00:11:54.781
我們強烈建議
你把這些緩存按照從前到後進行排序

00:11:55.582 --> 00:11:57.751
注意這個指導應該聽上去相當的熟悉

00:11:57.818 --> 00:11:59.453
如果你曾經處理過片段函數

00:11:59.520 --> 00:12:01.622
丟棄或者修改你每一像素點的深度

00:12:04.091 --> 00:12:05.659
現在讓我談一談計算機內核

00:12:05.726 --> 00:12:08.395
因爲計算機內核的決定性特徵

00:12:08.462 --> 00:12:10.531
決定了計算能力

00:12:10.964 --> 00:12:15.636
我們來說說什麼因素影響了
你在iOS中是怎麼做的

00:12:17.070 --> 00:12:19.239
首先 我們有計算機線程啓動的限制

00:12:20.574 --> 00:12:24.711
所以在A8及以後的圖像處理器上
有一定量的時間

00:12:24.778 --> 00:12:27.481
被花在了啓動一些計算機線程

00:12:27.548 --> 00:12:30.551
所以如果你的在一個計算機線程中
沒有做足夠多的工作

00:12:30.617 --> 00:12:32.953
這就會使硬件沒有被充分利用

00:12:33.020 --> 00:12:34.488
這就降低了性能

00:12:35.956 --> 00:12:38.592
一個處理這個問題
比較好的方式和一個好的模式

00:12:38.659 --> 00:12:40.794
對於在iOS上寫計算機內核

00:12:40.861 --> 00:12:44.665
是在一個計算線程上
處理多個概念的工作條目

00:12:45.465 --> 00:12:48.101
尤其我們找到一種工作得很好的模式是

00:12:48.168 --> 00:12:51.805
重用數值 不是通過線程組內存傳遞

00:12:51.872 --> 00:12:55.209
而是通過重用加載的數據
爲下一個工作條目

00:12:55.275 --> 00:12:58.345
當你在同一個計算線程中
處理下一個工作條目

00:12:59.213 --> 00:13:01.114
最好通過一個例子來闡述這點

00:13:02.115 --> 00:13:03.650
這是一個音節過濾內核

00:13:03.717 --> 00:13:06.153
這是一種最直接的版本了

00:13:06.220 --> 00:13:08.288
它讀取三個不發音的區域

00:13:08.722 --> 00:13:10.791
併產生一個輸出像素點

00:13:12.092 --> 00:13:17.431
所以如果應用處理多工作條目的模式

00:13:17.798 --> 00:13:20.467
在單一計算線程中
我們就得到類似於這樣的東西

00:13:21.034 --> 00:13:24.238
注意現在我們是在以
一次兩個像素點向前邁進

00:13:24.838 --> 00:13:27.074
所以處理第一個像素點
和它以前做的沒區別

00:13:27.140 --> 00:13:28.542
我們讀取這個3乘3的區域

00:13:29.042 --> 00:13:31.245
我們應用了這個過濾器
且寫上去了這個數值

00:13:32.946 --> 00:13:34.948
但讓我們看看
第二個像素點是如何被處理

00:13:35.482 --> 00:13:38.218
支架是以一次兩個像素點邁進的

00:13:38.285 --> 00:13:40.654
我們需要確保有第二個像素點被處理

00:13:41.421 --> 00:13:42.689
現在我們讀取了它的數據

00:13:43.323 --> 00:13:46.560
注意到這個像素點
所需要的三分之二的區域

00:13:46.627 --> 00:13:48.295
已經被之前的像素點加載

00:13:48.362 --> 00:13:50.764
所以我們不需要重新加載
我們可重用這些原有值

00:13:51.031 --> 00:13:54.635
現在我們所需要加載是
這個像素點的新的三分之一

00:13:55.702 --> 00:13:58.172
之後 我們就能應用過濾器完成任務

00:13:59.273 --> 00:14:02.442
注意 最後我們不是做12個紋理讀取

00:14:02.509 --> 00:14:05.212
不是原有的9個
而是我們在創建2個像素點

00:14:05.612 --> 00:14:09.116
在大量的單個像素點的紋理獲取中
這是個有意義的縮減

00:14:09.783 --> 00:14:13.453
當然這個模式並不適用於
所有的計算使用案例

00:14:13.954 --> 00:14:16.924
有時你仍然要通過線程組內存傳遞數據

00:14:17.824 --> 00:14:19.326
這種情況下 當你同步

00:14:19.393 --> 00:14:21.595
一個線程組中的線程的時候

00:14:22.462 --> 00:14:24.031
需要記住一個重要的事情是

00:14:24.097 --> 00:14:26.834
你想要使用柵欄在儘量小的範圍內

00:14:26.900 --> 00:14:28.669
爲你需要同步的線程

00:14:29.236 --> 00:14:33.440
尤其若你的線程組在一個SIMD裏面

00:14:34.041 --> 00:14:37.144
在Metal中
通常的線程組閘函數是不需要的

00:14:37.511 --> 00:14:39.179
你可以使用的

00:14:39.246 --> 00:14:42.549
是新的SIMD組閘函數
這是在iOS 10中引入的

00:14:43.617 --> 00:14:46.954
我們發現的實際上是線程組

00:14:47.020 --> 00:14:51.792
符合單一SIMD和
使用SIMD組閘通常要快於

00:14:51.859 --> 00:14:55.128
使用一個更大的線程組
爲了擠壓另外的重用

00:14:55.195 --> 00:14:57.331
但是不得不使用線程組閘作爲結果

00:14:59.032 --> 00:15:01.335
總的來說

00:15:02.736 --> 00:15:04.471
確保你使用正確的地址空間

00:15:04.538 --> 00:15:05.739
爲每一個緩存參數

00:15:05.806 --> 00:15:07.641
根據我們說的規則

00:15:08.775 --> 00:15:11.645
機構化你的數據和渲染
最大程度地利用常量

00:15:11.712 --> 00:15:13.146
和頂點緩存預加載

00:15:14.448 --> 00:15:16.250
確保使用早期片段測試來過濾

00:15:16.316 --> 00:15:19.786
儘量多的片段
當你在做資源寫操作的時候

00:15:21.388 --> 00:15:24.324
給每一個計算給予線程足夠的工作量
這樣你就不會被限制

00:15:24.391 --> 00:15:26.360
在計算線程啓動

00:15:27.294 --> 00:15:29.196
給任務使用最小的欄柵當你需要

00:15:29.263 --> 00:15:31.365
同步線程池中的線程的時候

00:15:31.632 --> 00:15:35.002
那麼 我想讓Fiona詳細地
講一下調製着色器代碼

00:15:41.408 --> 00:15:42.276
謝謝Alex

00:15:43.243 --> 00:15:45.979
在進入這些細節之前

00:15:46.046 --> 00:15:48.615
我想要講一下
一些圖像處理器的普通特性

00:15:48.682 --> 00:15:50.551
和一些你們可能會遇到的瓶頸

00:15:50.617 --> 00:15:52.352
可能你們中所有的人都熟悉它

00:15:52.452 --> 00:15:54.454
但是我覺得還是有必要快速的過一下

00:15:54.755 --> 00:15:58.525
對於圖像處理器
通常來講你有一組資源

00:15:58.625 --> 00:16:02.329
經常會發生的事情是着色器
被其中的一個資源給卡住了

00:16:02.596 --> 00:16:04.031
舉個例子 你卡在了

00:16:04.097 --> 00:16:07.067
內存帶寬
提高你的着色器中的其它東西

00:16:07.134 --> 00:16:09.970
通常不會帶來明顯的性能提升

00:16:10.537 --> 00:16:12.973
識別出這些瓶頸

00:16:13.040 --> 00:16:16.276
和聚焦在這些瓶頸上
以提高性能是很重要的

00:16:16.343 --> 00:16:19.746
這實際上對於非瓶頸的東西也是有益的

00:16:19.813 --> 00:16:23.483
比如 在那個例子當中
如果內存使用成爲了瓶頸

00:16:23.550 --> 00:16:26.520
你通過提高算法變得更加高效

00:16:26.587 --> 00:16:30.557
你仍然節約了電量
即使你沒有提高幀速率

00:16:30.724 --> 00:16:34.027
當然在移動設備上
節約電量始終是是重要的

00:16:34.294 --> 00:16:35.963
所以這不是一個能忽略的東西

00:16:36.029 --> 00:16:38.565
只是因爲幀速率在那個例子中沒有上升

00:16:38.632 --> 00:16:43.504
所以在着色器這裏
你需要記住四個典型的瓶頸

00:16:43.704 --> 00:16:45.706
第一個是非常直接的ALU帶寬

00:16:45.772 --> 00:16:47.708
圖像處理器能處理的數學計算量

00:16:48.542 --> 00:16:50.844
第二是內存帶寬 同樣也是非常直接的

00:16:50.911 --> 00:16:53.747
圖像處理器能從系統內存中
加載的數據量

00:16:54.481 --> 00:16:55.916
另外兩個相對就沒那麼明顯

00:16:55.983 --> 00:16:57.951
第一是內存問題率

00:16:58.018 --> 00:17:01.488
它表示能執行的內存處理量

00:17:01.855 --> 00:17:06.026
這會出現在以下的場景中
當你的內存處理比較小的時候

00:17:06.093 --> 00:17:08.529
或者你使用很多線程組內存等等

00:17:09.029 --> 00:17:11.964
最後一個
也是我等會兒會深入講的一個

00:17:12.031 --> 00:17:14.034
是延遲佔用寄存器使用

00:17:14.101 --> 00:17:16.936
也許你已經同說過它來
但是我會把它留在最後

00:17:18.605 --> 00:17:20.507
所以爲了緩解其中的一些瓶頸

00:17:20.574 --> 00:17:23.310
和提高着色器的性能和效率

00:17:23.377 --> 00:17:27.013
我們將一起看一下四類優化機會

00:17:27.580 --> 00:17:28.982
第一類是數據類型

00:17:29.550 --> 00:17:31.285
首先要想到

00:17:31.351 --> 00:17:34.354
當你優化着色器時 是選擇數據類型

00:17:34.755 --> 00:17:38.659
當你選擇數據類型時
最重要的一件事是A8

00:17:38.725 --> 00:17:42.196
及更新的圖像器有16位的寄存器單元

00:17:42.763 --> 00:17:45.766
這意味着當你使用32位數據類型時

00:17:45.866 --> 00:17:49.236
那就是兩倍的寄存器空間 兩倍的帶寬

00:17:49.703 --> 00:17:53.841
可能是兩倍的電量等等
總之所有東西都是翻倍的

00:17:54.641 --> 00:17:56.977
所以 對應的 需要節約寄存器

00:17:57.044 --> 00:18:00.013
這樣會得到更快的性能 更低的能耗

00:18:00.214 --> 00:18:01.715
通過使用更小的數據類型

00:18:01.949 --> 00:18:04.785
在運算中儘可能地使用
半字節和短字節的變量

00:18:05.185 --> 00:18:07.221
從能耗看
半字節比浮點型變量節能多了

00:18:07.688 --> 00:18:09.523
浮點型比整型又要節能

00:18:09.823 --> 00:18:13.493
甚至在整型當中
短整型又要比長整型節能

00:18:13.794 --> 00:18:16.797
你節省寄存器最有效的方式

00:18:16.864 --> 00:18:20.167
是給紋理和插值使用半字節型

00:18:20.234 --> 00:18:23.303
因爲通常情況下你並不需要浮點型

00:18:23.370 --> 00:18:26.073
注意我不是指紋理格式

00:18:26.139 --> 00:18:28.942
我指的是數據類型
這數據類型是你用來存儲

00:18:29.009 --> 00:18:30.811
紋理樣本或者插值的結果

00:18:32.045 --> 00:18:36.650
A8及更新的圖像處理器中
是相當方便的

00:18:37.050 --> 00:18:40.654
使得比在其它圖像處理器上
使用更小的數據類更加的簡單

00:18:40.921 --> 00:18:43.991
是因爲數據類型轉換一般是免費的

00:18:44.124 --> 00:18:46.527
甚至在浮點型和半字節型之間

00:18:46.593 --> 00:18:48.462
這意味着你不需要擔心

00:18:48.529 --> 00:18:53.133
我會不會在使用半字節類型的過程中
引入了太多的類型轉化

00:18:53.200 --> 00:18:55.335
這會導致消耗太多嗎
這是否值得

00:18:55.736 --> 00:18:58.272
不 因爲類型轉換是自由的
所以很可能是更快了

00:18:58.539 --> 00:19:01.375
無論何時你都可以使用半字節類型
不需要擔心這個部分

00:19:01.675 --> 00:19:05.279
需要記住的一點是半字節精度的數值

00:19:05.345 --> 00:19:08.115
和限制與浮點型數據是不同的

00:19:08.916 --> 00:19:11.418
經常出現的一個錯誤

00:19:11.485 --> 00:19:16.957
如寫65,535這樣一個半字節類型

00:19:17.424 --> 00:19:19.760
但它實際上是無窮大

00:19:20.160 --> 00:19:22.362
因爲這比最大的半字節類型還要大

00:19:22.429 --> 00:19:24.998
所以要注意有哪些限制條件

00:19:25.065 --> 00:19:28.302
最好能知道哪裏應該用
半字節類型 哪裏不應該用

00:19:28.368 --> 00:19:31.104
降低在着色器中發生意外錯誤的可能性

00:19:32.072 --> 00:19:34.141
一個例子應用

00:19:34.208 --> 00:19:37.878
對於使用短整型數據類型 是線程ID

00:19:38.178 --> 00:19:41.915
你們中與計算機內核打過交道的
應該知道

00:19:41.982 --> 00:19:44.518
線程ID在程序中是廣泛被使用的

00:19:44.985 --> 00:19:47.654
所以把它們弄得小一點
能很大程度地提高

00:19:47.721 --> 00:19:51.792
運算的性能 可以節省寄存器等等

00:19:52.626 --> 00:19:58.632
對於本地線程ID 在這個例子中
沒有理由去使用無符號整型

00:19:58.866 --> 00:20:01.435
因爲本地線程ID
不能用那麼多的線程ID

00:20:01.869 --> 00:20:05.172
對於全局線程ID
通常你可以使用無符號短整型

00:20:05.239 --> 00:20:08.242
因爲大多數情況下
你不會有那麼多的線程ID

00:20:08.308 --> 00:20:09.643
當然這要取決於你的程序

00:20:09.977 --> 00:20:14.114
但是在絕大多數的情況下
你不會超過2的16次方減1

00:20:14.181 --> 00:20:15.516
所以你可使用無符號短整型

00:20:16.116 --> 00:20:19.253
這會降低功耗 也會更快

00:20:19.319 --> 00:20:23.290
因爲所有線性ID相關的運算都變快了

00:20:23.590 --> 00:20:26.026
所以我強烈建議你儘可能的這麼做

00:20:28.562 --> 00:20:31.565
另外 記住在類C的語言中

00:20:31.632 --> 00:20:33.100
當然這也包括Metal

00:20:33.166 --> 00:20:37.137
運算的精度是通過
輸入類型的大小來定義的

00:20:37.804 --> 00:20:40.140
比如 一個浮點型乘以一個半字節型

00:20:40.207 --> 00:20:43.577
這是一個浮點型運算而非半字節型運算
它會向上提升

00:20:44.011 --> 00:20:48.782
所以對應的 確保儘量不要使用浮點型

00:20:48.849 --> 00:20:52.419
因爲這會把一個半字節運算

00:20:52.486 --> 00:20:55.455
輸入半字節型 返回半字節型
變成一個浮點型運算

00:20:55.522 --> 00:20:57.291
因爲根據語法

00:20:57.357 --> 00:21:01.061
這實際上是一個浮點型運算
因爲輸入值中至少有一個是浮點型

00:21:01.762 --> 00:21:03.764
所有你可能想要做麼做

00:21:04.565 --> 00:21:06.433
事實上 這就會是一個半字節型運算

00:21:06.500 --> 00:21:08.101
而且會變得更快

00:21:08.602 --> 00:21:10.204
這可能就是你所說的

00:21:10.504 --> 00:21:14.007
所以要注意 不要在不經意間
引入浮點型精度的運算

00:21:14.074 --> 00:21:15.909
在你的代碼中
當你其實並不想要它時

00:21:19.079 --> 00:21:21.715
雖然我剛纔說了數據類型越小越好

00:21:21.782 --> 00:21:24.551
有一個例外是字符型

00:21:25.085 --> 00:21:27.554
在A8及更新的處理器上
原生的數據類型大小

00:21:27.621 --> 00:21:31.058
是16位的 而不是8位的

00:21:31.391 --> 00:21:35.529
所以字符型並不會節省空間
或者能耗或者其它一些東西

00:21:35.596 --> 00:21:38.365
進一步說 沒有原生的8位運算

00:21:38.432 --> 00:21:40.100
所以它似乎要被仿真

00:21:40.167 --> 00:21:43.470
如果你需要的話
它不會過度的耗資源 隨便用

00:21:43.537 --> 00:21:45.606
但是它可能會導致額外的指令

00:21:45.839 --> 00:21:48.675
所以不要把變量壓縮爲字符型

00:21:48.742 --> 00:21:50.544
在沒有必要的時候

00:21:53.981 --> 00:21:57.217
所以接下來我們會有計算優化

00:21:57.451 --> 00:22:01.288
在這個類別中
幾乎所有的都會影響ALU帶寬

00:22:01.989 --> 00:22:05.926
你能做的第一件事情始終
是儘量使用Metal內置

00:22:06.293 --> 00:22:09.096
它們是給各種不同的函數優化實現的

00:22:09.162 --> 00:22:11.164
它們已經爲硬件進行了優化

00:22:11.231 --> 00:22:13.700
通常來講 會比你自己實現的要好

00:22:14.334 --> 00:22:16.170
特別的

00:22:16.470 --> 00:22:20.574
實際上 他們中的一些通常是免費的

00:22:21.375 --> 00:22:24.344
這是因爲圖形處理器通常都有修改工具

00:22:24.444 --> 00:22:28.849
運算可以通過輸入輸出指令免費地執行

00:22:28.916 --> 00:22:32.085
對於A8及以後的圖形處理器
通常包括非門

00:22:32.152 --> 00:22:36.690
絕對值和飽和值 像你們看到的一樣
這三種綠色的運算符

00:22:37.090 --> 00:22:41.962
所以 沒有必要嘗試着
讓你的代碼更加聰明或者加速它

00:22:42.029 --> 00:22:43.297
通過避免這些

00:22:43.363 --> 00:22:45.399
同樣是因爲他們幾乎總是免費的

00:22:45.632 --> 00:22:48.302
因爲他們是免費的
你不可能比免費更加好

00:22:48.368 --> 00:22:50.304
無法在免費的基礎上再進行優化了

00:22:52.706 --> 00:22:56.944
A8及更新的圖形處理器
和很多其它處理器一樣 是標量機器

00:22:57.277 --> 00:22:59.513
而着色器通常是用向量表示的

00:22:59.580 --> 00:23:02.382
編譯器會把它們在內部分離開來

00:23:02.716 --> 00:23:05.552
當然 寫向量代碼並沒有什麼壞處

00:23:05.819 --> 00:23:08.889
它經常更加清晰 也更容易維護

00:23:08.956 --> 00:23:10.724
而且它符合你想要的東西

00:23:11.158 --> 00:23:14.995
但是它也不會比寫標量代碼更加好
從編譯器的角度

00:23:15.062 --> 00:23:16.163
和你要得到的代碼

00:23:16.530 --> 00:23:19.399
所以沒有必要去向量化代碼

00:23:19.466 --> 00:23:21.902
那並不符合向量格式

00:23:21.969 --> 00:23:24.771
因爲最後它只會導致一樣的東西

00:23:24.872 --> 00:23:26.507
而你浪費了你的時間

00:23:27.241 --> 00:23:30.777
但是 從一個側面說明
我等會兒會深入說一下

00:23:30.844 --> 00:23:32.179
在A8及更新圖像處理器上

00:23:32.246 --> 00:23:36.149
確實有向量加載在存儲裏
儘管他們沒有向量運算

00:23:36.850 --> 00:23:39.119
所以這只是應用於算術

00:23:40.921 --> 00:23:42.556
指令級別並行

00:23:42.623 --> 00:23:45.259
你們中有些人可能已經優化過了

00:23:45.325 --> 00:23:47.327
特別是若你做過中央處理器相關的工作

00:23:47.794 --> 00:23:51.765
但是在A8及更新的圖形處理器上
這通常不是一個好事情

00:23:51.832 --> 00:23:55.202
去嘗試優化它
因爲通常它要與寄存器使用競爭

00:23:55.269 --> 00:23:57.371
而寄存器使用通常更重要

00:23:57.905 --> 00:24:00.974
所以你可能見過的一種普通模式是一種

00:24:01.041 --> 00:24:03.243
你有多個有序的加法器

00:24:03.310 --> 00:24:07.181
在圖形處理器上更好地處理延遲

00:24:07.748 --> 00:24:11.385
但是在A8及更新的圖形處理器上
這可能是降低效率的

00:24:11.685 --> 00:24:13.921
你最好只使用一個累加器

00:24:14.087 --> 00:24:16.523
當然 這會導致更多的複雜例子

00:24:16.590 --> 00:24:18.692
比人工的簡單例子

00:24:19.159 --> 00:24:20.127
簡而言之

00:24:20.194 --> 00:24:23.263
不要嘗試去重新結構化你的代碼
從中得到更多的ILP

00:24:23.330 --> 00:24:25.499
這可能並不會對你有所幫助

00:24:25.566 --> 00:24:27.801
最糟糕的是 你的代碼可能變得更差

00:24:29.603 --> 00:24:33.240
所以在A8及更新的圖形處理器上
有個相當好的功能

00:24:33.307 --> 00:24:37.744
就是它們有着非常快速的選擇指令集
它們是三元運算符

00:24:38.412 --> 00:24:43.483
過去 使用一些小聰明是非常普遍的
就像這個

00:24:43.550 --> 00:24:49.056
在三元運算符中執行選擇操作
爲了避免那些分支等等

00:24:49.523 --> 00:24:52.860
但是在現代圖形處理器上
這些通常會是起相反的效果

00:24:52.926 --> 00:24:55.262
特別是對於A8及更新的圖形處理器

00:24:55.329 --> 00:24:57.731
因爲編譯器不會考慮這些小聰明

00:24:57.798 --> 00:25:00.100
它不會明白你的真實意圖

00:25:00.567 --> 00:25:02.769
真的 這是非常糟糕的

00:25:03.504 --> 00:25:04.771
你可能剛剛寫了這個

00:25:04.838 --> 00:25:06.940
而且它會更快 更短

00:25:07.007 --> 00:25:08.442
它會展示你的意圖

00:25:08.909 --> 00:25:12.412
像以前一樣 太過聰明反而會變得複雜

00:25:12.479 --> 00:25:14.648
你所做的會使編譯器困惑

00:25:16.783 --> 00:25:20.120
現在 它就是一個潛在的陷阱
希望這不會經常發生

00:25:20.988 --> 00:25:26.026
對於相對的圖形處理器
它們中的大部分都沒有整數除法運算

00:25:26.093 --> 00:25:29.029
或者取餘數指令集
整數型而不是浮點型

00:25:29.530 --> 00:25:33.767
所以避免除法運算

00:25:33.834 --> 00:25:36.603
不是字面的或者函數常量

00:25:36.670 --> 00:25:39.106
這個新特性在前面當然演講中提到過

00:25:39.506 --> 00:25:42.209
所以在這個例子中 我們想說的是

00:25:42.276 --> 00:25:45.679
分母是一個變量

00:25:45.746 --> 00:25:47.681
那就會非常非常得慢

00:25:47.748 --> 00:25:49.650
想象一下成百上千的時鐘秒針

00:25:50.284 --> 00:25:52.619
但是這另外兩個例子 它們會非常得快

00:25:52.686 --> 00:25:53.554
它們是好的

00:25:53.620 --> 00:25:55.489
不要覺得你必須要避免它

00:25:57.558 --> 00:26:00.661
最後 快速數學運算的主題

00:26:00.994 --> 00:26:04.264
在Metal中 快速運算是默認的

00:26:04.331 --> 00:26:07.234
這是因爲編譯器是經過
快速運算優化過的

00:26:07.301 --> 00:26:09.903
這對Metal着色器的性能來說
至關重要

00:26:09.970 --> 00:26:14.875
這能提供50%或者更多的性能提升
相較於沒有快速運算

00:26:14.942 --> 00:26:16.476
這也是爲什麼它是默認開啓的

00:26:17.177 --> 00:26:20.214
那麼在快速運算模式下
我們到底做了什麼事情呢

00:26:20.781 --> 00:26:23.951
第一 一部分Metal中內置的函數

00:26:24.017 --> 00:26:27.454
對於有沒有快速運算
有着不用的精度保證

00:26:27.521 --> 00:26:30.290
所以在某些函數中
它們會有稍微低一點的精度

00:26:30.357 --> 00:26:33.227
在快速運算模式中會有更好的性能

00:26:34.494 --> 00:26:37.497
編譯器會提高中間件的精度

00:26:37.564 --> 00:26:40.734
對於你的運算
比如通過組成一個多個加法指令集

00:26:41.235 --> 00:26:44.171
這不會降低中間件的精度

00:26:44.605 --> 00:26:46.740
所以舉個例子
如果你寫了一個浮點型的運算

00:26:46.807 --> 00:26:50.310
你的這個運算至少是浮點型的運算

00:26:50.377 --> 00:26:51.578
不是一個數學運算

00:26:52.012 --> 00:26:53.647
若你想要寫一個半字節型的運算

00:26:53.714 --> 00:26:56.450
你最好就自己寫
編譯器是不會幫你做的

00:26:56.517 --> 00:26:57.551
因爲這是不被允許的

00:26:57.618 --> 00:27:00.053
它不會讓你的精度達到那樣

00:27:00.921 --> 00:27:03.824
我們確實會忽略
如果不是一個數字 無窮量

00:27:03.891 --> 00:27:06.527
和符號零 這是很重要的

00:27:06.593 --> 00:27:08.862
如果不那樣的話 你不能真正證明

00:27:08.929 --> 00:27:11.198
x乘以0等於0

00:27:11.965 --> 00:27:16.503
但是我們不會引進一個新的NaN
不是一個數字

00:27:16.570 --> 00:27:20.240
因爲現實中 那是一個非常好的方式

00:27:20.307 --> 00:27:22.442
來激怒開發者 毀壞他們的代碼

00:27:22.509 --> 00:27:23.977
我們不想要這麼做

00:27:24.845 --> 00:27:28.582
編譯器會執行算術重整合

00:27:28.749 --> 00:27:30.617
但是不會做算術分配

00:27:30.684 --> 00:27:33.987
而且實際上 這不會毀壞代碼

00:27:34.054 --> 00:27:36.456
而且會使得它更快

00:27:36.523 --> 00:27:38.192
我們不想毀壞代碼

00:27:40.661 --> 00:27:43.997
所以無論什麼原因
如果絕對不能使用快速運算

00:27:44.364 --> 00:27:47.434
還是有方法恢復一部分性能

00:27:48.168 --> 00:27:52.105
Metal有一個內置的
融合的乘法加法

00:27:52.172 --> 00:27:55.509
它允許你直接請求
融合的乘法加法指令集

00:27:55.809 --> 00:27:57.077
當然如果快速運算被停用

00:27:57.144 --> 00:27:59.246
編譯器就不會被允許編譯它們

00:27:59.313 --> 00:28:02.850
它不會改變你的四捨五入的一位
這是被禁止的

00:28:03.350 --> 00:28:06.854
所以如果你想要使用融合的乘法加法
而且快速運算是停用的

00:28:06.920 --> 00:28:08.422
你需要使用內置的

00:28:09.122 --> 00:28:11.091
而且那會重新增加一部分的性能

00:28:11.425 --> 00:28:13.393
不是所有的性能 但至少有一部分

00:28:15.028 --> 00:28:17.598
所以 我們的第三個話題 控制流程

00:28:18.365 --> 00:28:20.667
預測的GP控制流程不是一個新的話題

00:28:20.734 --> 00:28:22.769
你們中的一些人
可能對此已經非常熟悉了

00:28:22.836 --> 00:28:25.038
但我快速回顧一下
這對你來說有什麼意義

00:28:25.539 --> 00:28:27.875
控制流程在SIMD中是一致的

00:28:27.941 --> 00:28:31.345
每一個線程都在做同一件事情
相當的快速

00:28:31.979 --> 00:28:35.048
就算編譯器看不到它 這也是真的

00:28:35.482 --> 00:28:38.919
所以如果你的程序看上去不一致

00:28:38.986 --> 00:28:41.355
但是隻有當運行的時候它才一致

00:28:41.421 --> 00:28:43.357
那仍然是很快的

00:28:44.024 --> 00:28:46.793
類似的 這個分歧的另一面

00:28:46.860 --> 00:28:49.296
不同的道路做不同的事情

00:28:49.363 --> 00:28:51.932
在那個例子中 它可能不得不運行

00:28:51.999 --> 00:28:54.334
於所有的路徑 同時地

00:28:54.401 --> 00:28:57.738
不同於中央處理器在一個時間點
只會選擇一個路徑

00:28:58.372 --> 00:29:00.841
因爲它會做更多的工作

00:29:00.908 --> 00:29:03.076
當然也就意味着不高效的控制流程

00:29:03.143 --> 00:29:04.878
會影響任意一個瓶頸

00:29:04.945 --> 00:29:07.681
因爲它只是直接地表明
圖像處理器做了更多事情

00:29:07.748 --> 00:29:09.383
無論是什麼事情

00:29:11.151 --> 00:29:15.622
所以 在控制流程這個話題上
我給大家的一個建議

00:29:15.889 --> 00:29:18.392
是避免切換fall-through

00:29:18.659 --> 00:29:20.961
這在中央處理器的代碼中非常的普遍

00:29:21.028 --> 00:29:23.997
但是對於圖像處理器
它們可能會成爲低效

00:29:24.264 --> 00:29:28.302
因爲編譯器不得不做相當嚴重的轉型

00:29:28.368 --> 00:29:31.038
爲了讓它們符合
圖像處理器的控制流程模型

00:29:31.104 --> 00:29:34.541
而且經常的 這會導致冗餘的代碼
和各種各樣的麻煩的東西

00:29:34.608 --> 00:29:36.643
你可能不希望發生這樣的事情

00:29:37.144 --> 00:29:40.280
若你能找到好方法來避免
代碼中fall-through切換

00:29:40.347 --> 00:29:42.049
你可能會變的更好

00:29:43.550 --> 00:29:45.285
現在到了我們最後一個話題

00:29:45.352 --> 00:29:46.186
內存訪問

00:29:46.453 --> 00:29:50.557
我們現在先從大家最可能碰到
的陷阱開始說

00:29:50.624 --> 00:29:54.962
那是動態地索引非常量堆數組

00:29:55.128 --> 00:29:56.463
這是非常有爭議的

00:29:56.530 --> 00:30:00.467
但你們中很多人可能已熟悉這些代碼了
大致上看上去着這樣的

00:30:00.968 --> 00:30:05.472
你有一個包含數值的數組
在運行時被定義

00:30:05.539 --> 00:30:08.509
在每一個線程或者
每一個函數調用中變化

00:30:08.575 --> 00:30:12.079
而且你索引這個數字
通過另外一個也是變量的值

00:30:12.346 --> 00:30:15.315
這就是動態索引非常量堆

00:30:15.782 --> 00:30:17.284
在我們繼續之前

00:30:17.351 --> 00:30:19.520
我不會想當然的認爲

00:30:19.586 --> 00:30:21.455
對於圖形處理器 堆棧是慢的

00:30:21.522 --> 00:30:22.723
我會解釋爲什麼

00:30:23.223 --> 00:30:27.628
所以 對於中央處理器
通常你有多個線程 或者幾十個線程

00:30:27.694 --> 00:30:30.330
且你有幾MB的緩存分配在這些線程中

00:30:30.898 --> 00:30:33.767
所以每一個線程可能有
成千上百KB的堆棧空間

00:30:33.834 --> 00:30:36.503
在它們變慢和不得不去處理主內存之前

00:30:37.271 --> 00:30:40.941
對於圖形處理器
通常會有成千上萬的線程在同時跑

00:30:41.441 --> 00:30:43.977
而且它們都在分享一個小得多的緩存

00:30:44.244 --> 00:30:45.812
所以平均下來

00:30:45.879 --> 00:30:48.448
每一個線程只有非常小的空間
給數據和堆棧

00:30:49.116 --> 00:30:52.085
這不單單意味着那個這不是很高效

00:30:52.152 --> 00:30:54.821
作爲一個慣例
對於絕大多數的圖形處理器程序

00:30:54.888 --> 00:30:57.191
如果你使用堆棧 你已經輸了

00:30:57.257 --> 00:31:01.628
這會非常慢
使得幾乎其他任何東西都本有可能更好

00:31:02.596 --> 00:31:05.265
一個真實世界的應用

00:31:05.332 --> 00:31:10.571
程序開始時 它需給向量
從兩個浮點型數據中選擇一個

00:31:10.637 --> 00:31:13.941
它用了32字節的數組
一組兩個浮點型數據

00:31:14.007 --> 00:31:16.844
在他它們中選擇 使用這個堆棧數組

00:31:16.910 --> 00:31:18.946
這會導致30%的性能損失

00:31:19.012 --> 00:31:21.081
在這個程序中 儘管只在開始時做一次

00:31:22.449 --> 00:31:24.051
這也會是相當的重要

00:31:24.651 --> 00:31:27.554
當然每次我們提高編譯器的時候

00:31:27.621 --> 00:31:29.923
我們要儘量避免

00:31:29.990 --> 00:31:31.425
儘量

00:31:31.491 --> 00:31:35.195
避免產生這些堆棧訪問
因爲這是不好的

00:31:35.729 --> 00:31:38.699
現在我要給大家展示兩個好的例子

00:31:39.566 --> 00:31:43.804
另外一個 哪些是常量 不是變量

00:31:43.937 --> 00:31:46.707
那不是一個非常量堆棧數組 沒關係

00:31:47.174 --> 00:31:50.177
因爲每一個線程的值不會變化

00:31:50.244 --> 00:31:51.845
它們不需要在每個線程中被複制

00:31:52.412 --> 00:31:53.480
所以這是可以的

00:31:54.781 --> 00:31:56.416
這個也是可以的

00:31:56.550 --> 00:31:59.820
等等 爲什麼？
這仍然是一個動態索引非常量堆棧數組

00:32:00.120 --> 00:32:02.656
但是它只是做動態索引 因爲這個迴路

00:32:03.257 --> 00:32:06.126
而且編譯器會展開這個迴路

00:32:06.393 --> 00:32:09.463
實際上 你的編譯器展開任意的迴路

00:32:09.530 --> 00:32:12.432
那會訪問這個堆棧
爲了讓它停止這麼做

00:32:13.166 --> 00:32:16.370
所以在這個例子中
它被展開後 就不再被動態索引了

00:32:16.436 --> 00:32:18.739
它會變得很快 值得提出來的是

00:32:18.805 --> 00:32:21.375
因爲在大量的圖形學代碼中
這是非常普通的模式

00:32:21.441 --> 00:32:24.678
而且我不想嚇唬你不要這麼做
當它可能還行的時候

00:32:26.146 --> 00:32:27.481
既然我們已經講了這個主題

00:32:27.548 --> 00:32:30.250
關於如何不要做加載和存儲這些類型

00:32:30.450 --> 00:32:34.555
讓我們繼續講加載和存儲
我們會講得快一些

00:32:35.355 --> 00:32:37.925
當A8及更新的圖像處理器
都是用標量算法

00:32:37.991 --> 00:32:41.228
正如我前面說過的那樣
它們確實有向量內存單元

00:32:41.995 --> 00:32:45.432
一個大的向量加載資源自然比

00:32:45.499 --> 00:32:48.602
多個小向量要快
當小向量相加大小和這一個大向量一樣

00:32:49.536 --> 00:32:52.206
這通常會影響內存處理速率瓶頸

00:32:52.272 --> 00:32:55.509
因爲你通過負載來運行 那沒多少負載

00:32:56.176 --> 00:33:00.013
對於iOS 10
我們新的編譯器優化中的一點

00:33:00.080 --> 00:33:02.749
是我們會去向量化一些負載和存儲

00:33:02.816 --> 00:33:05.385
會去儘可能地鄰接內存位置

00:33:05.719 --> 00:33:08.055
同樣是因爲它可以給出好的性能提升

00:33:08.889 --> 00:33:13.227
雖然如此
這是一個處理編譯器時的例子

00:33:13.293 --> 00:33:15.429
可能會很有幫助 我給大家舉個例子

00:33:16.263 --> 00:33:18.265
正如你們看到的這樣
這是一個簡單的迴路

00:33:18.365 --> 00:33:21.268
它做了一些計算和
讀取了一個結構體數組

00:33:21.869 --> 00:33:25.072
但是在每一步循環 它只讀取兩個加載

00:33:25.439 --> 00:33:27.574
現在如果可以 我們想要它變成一個

00:33:27.641 --> 00:33:29.009
因爲一個比兩個要好

00:33:29.276 --> 00:33:31.979
而且編譯器也想這樣

00:33:32.045 --> 00:33:34.348
它想要向量化這個 但是它做不到

00:33:34.414 --> 00:33:36.817
因爲A和C在內存中不是緊挨着的

00:33:36.884 --> 00:33:37.818
所以它什麼都做不了

00:33:37.885 --> 00:33:39.987
編譯器是不被允許重新安排結構體的

00:33:40.153 --> 00:33:41.355
所以我們有兩個負載

00:33:42.089 --> 00:33:43.590
對此有兩個解決辦法

00:33:43.924 --> 00:33:46.460
第一 當然是把它變成一個浮點型

00:33:46.527 --> 00:33:47.961
它就是向量負載了 結束了

00:33:48.629 --> 00:33:50.330
一個負載 兩個一組 什麼都好了

00:33:51.098 --> 00:33:54.935
而且 對於iOS 10
這也一個相同的快速

00:33:55.202 --> 00:33:58.472
因爲在這裏 我們重拍了我們的結構體
讓值一個接一個

00:33:58.705 --> 00:34:01.942
那樣編譯器可以向量化負載
當它做這個的時候

00:34:02.176 --> 00:34:05.279
這同樣是一個處理編譯器的例子

00:34:05.579 --> 00:34:08.549
編譯器被允許做一些
它以前做不了的事情

00:34:08.649 --> 00:34:11.217
因爲你知道到底發生了什麼

00:34:11.284 --> 00:34:15.255
你知道如何選擇模式 使得編譯器開心

00:34:15.422 --> 00:34:17.357
讓它可以做

00:34:19.826 --> 00:34:22.929
所以 另外一個要記住的
關於負載和存儲的事情

00:34:22.996 --> 00:34:26.166
是A8和更新的圖像處理器
有專門的硬件

00:34:26.233 --> 00:34:28.135
給設備內存地址分配

00:34:28.467 --> 00:34:31.737
但是這個硬件是有限制的

00:34:32.406 --> 00:34:36.409
訪問設備內存的偏移量
必須在有符號整型的範圍內

00:34:36.777 --> 00:34:39.213
小一點的數據類型
比如短整型和無符號短整型也是可以的

00:34:39.279 --> 00:34:40.981
實際上 它們是被強烈推薦的

00:34:41.348 --> 00:34:43.717
因爲那些也是在有符號整型的範圍的

00:34:44.284 --> 00:34:46.786
但是 無符號整型當然不是的

00:34:46.853 --> 00:34:49.089
因爲他可能有值超出了
有符號整型的範圍

00:34:49.623 --> 00:34:53.994
所以如果編譯器發生一種情況

00:34:54.061 --> 00:34:56.630
當偏移量是一個無符號整型
就不能保證

00:34:56.697 --> 00:34:58.899
它會很好的待在有符號整型的範圍內

00:34:59.199 --> 00:35:01.602
必須手動地計算地址

00:35:02.069 --> 00:35:04.071
而不是讓專用硬件來做這個

00:35:04.371 --> 00:35:05.639
那樣會浪費電量

00:35:05.706 --> 00:35:08.876
它會浪費ALU性能等等

00:35:08.942 --> 00:35:10.077
這是不好的

00:35:10.544 --> 00:35:15.249
所以 把你的偏移量轉爲整型
這樣問題就解決了

00:35:15.315 --> 00:35:18.619
當然利用這個通常會節省ALU帶寬

00:35:21.421 --> 00:35:24.124
所以在我們的最後一個話題上
我前面有所掩蓋

00:35:24.191 --> 00:35:25.492
延遲和佔用

00:35:26.193 --> 00:35:30.197
現代圖像處理器的核心設計之一
是隱藏延遲

00:35:30.264 --> 00:35:32.132
通過使用大規模的多線程

00:35:32.566 --> 00:35:34.701
所以當它們等待一些慢的東西結束

00:35:34.768 --> 00:35:37.604
比如紋理讀取
它們只是運行另一個線程

00:35:37.671 --> 00:35:39.273
而不是坐着什麼都不幹
只是等待

00:35:39.339 --> 00:35:40.407
這是相當重要的

00:35:40.474 --> 00:35:43.343
因爲紋理讀取通常要花好幾百個循環

00:35:43.410 --> 00:35:44.645
才能結束 平均下來

00:35:47.214 --> 00:35:49.483
所以你在着色器中延遲越多

00:35:49.550 --> 00:35:52.052
你就需要更多的線程來隱藏延遲

00:35:52.519 --> 00:35:54.154
你有多少線程呢？

00:35:54.221 --> 00:35:57.191
這限制於你有一定數量的資源

00:35:57.257 --> 00:35:59.693
它們被一個線程組中的線程共享

00:36:00.027 --> 00:36:02.629
所以顯然基於每一個線程的使用量

00:36:02.696 --> 00:36:04.598
你需要限制線程的數量

00:36:04.831 --> 00:36:06.934
相沖突的兩件事情是

00:36:07.000 --> 00:36:08.769
寄存器和線程組存儲器的數量

00:36:09.303 --> 00:36:11.138
所以在每個線程中你使用寄存器越多

00:36:11.305 --> 00:36:12.606
你就不能使用這麼多線程

00:36:12.706 --> 00:36:13.540
太簡單了

00:36:13.707 --> 00:36:15.976
如果你在每個線程中使用的線程組越多

00:36:16.043 --> 00:36:18.645
你又會遭遇同樣的問題

00:36:18.812 --> 00:36:20.948
每一個線程對於你的線程

00:36:21.648 --> 00:36:25.152
你可以檢查着色器的實際佔用率

00:36:25.552 --> 00:36:31.291
用MTLComputePipeLineState
導致maxTotalThreadsPerThreadgroup

00:36:31.558 --> 00:36:35.195
這將告訴你着色器的實際佔有率是多少

00:36:35.262 --> 00:36:39.533
基於寄存器的使用率
和線程組存儲器的使用率

00:36:39.833 --> 00:36:42.336
所以當我們說着色器延遲限制

00:36:42.536 --> 00:36:45.739
這意味着用來
隱藏着色器延遲的線程太少

00:36:45.806 --> 00:36:47.441
這時 你可以做兩件事情

00:36:47.608 --> 00:36:49.610
你可以減少着色器的延遲

00:36:50.010 --> 00:36:52.412
保存寄存器 另外一件事是

00:36:52.479 --> 00:36:54.882
避免使用更多的線程

00:36:56.984 --> 00:37:03.857
所以 對於一個非常大而複雜的着色器
克服延遲是有點困難的

00:37:04.157 --> 00:37:06.226
我將會重溫一些僞代碼實例

00:37:06.293 --> 00:37:08.195
可能會給你強烈的直覺

00:37:08.262 --> 00:37:12.933
在你的着色器中
如何考慮延遲和怎樣略微理智地建模

00:37:14.001 --> 00:37:16.670
所以 這兒有一個REAL的依賴案例

00:37:17.004 --> 00:37:19.606
有一個紋理樣本
然後我們使該紋理樣本

00:37:19.673 --> 00:37:21.708
執行if語句

00:37:21.775 --> 00:37:24.311
然後我們在x語句裏
創建另一個紋理樣本

00:37:24.912 --> 00:37:25.979
我們必須等兩次

00:37:26.046 --> 00:37:28.715
因爲我們在執行if語句前必須等一次

00:37:29.016 --> 00:37:31.485
在使用值之前又必須等一次

00:37:31.552 --> 00:37:32.753
第二個紋理樣本的

00:37:33.086 --> 00:37:38.725
兩次連續的紋理訪問造成總共兩次延遲

00:37:40.260 --> 00:37:42.229
這兒有一個錯誤的依賴案例

00:37:42.296 --> 00:37:43.397
該依賴看來很像另個

00:37:43.463 --> 00:37:45.999
除非我們在if語句中不使用它

00:37:46.900 --> 00:37:51.071
但是通常我們不能等待跨控制流程

00:37:51.271 --> 00:37:54.374
這種情況下if語句
成爲了一個嚴重的障礙

00:37:54.641 --> 00:37:58.345
所以我們不得不等

00:37:58.412 --> 00:37:59.780
即使沒有數據依賴

00:38:00.047 --> 00:38:01.648
所以我們仍然有兩次延遲

00:38:01.915 --> 00:38:05.652
當你意識到GPU並不在乎數據依賴

00:38:05.986 --> 00:38:09.389
它只在乎出現什麼依賴

00:38:09.890 --> 00:38:13.861
這樣第二個依賴的
延遲時間和第一個是一樣的

00:38:13.927 --> 00:38:16.029
即使那兒沒有數據依賴

00:38:17.431 --> 00:38:19.366
最後有個簡單的依賴

00:38:19.433 --> 00:38:21.335
在頂端你僅僅獲取兩個紋理

00:38:21.869 --> 00:38:26.640
它們都被並行獲取
這樣我們就只等一次

00:38:26.740 --> 00:38:29.176
所以就是1 x延遲而不是2 x延遲

00:38:30.110 --> 00:38:32.613
所以 運用這個知識你將會幹什麼呢？

00:38:32.679 --> 00:38:36.016
在很多實際着色器中 你有機會

00:38:36.083 --> 00:38:38.452
在延遲和吞吐量之間權衡

00:38:39.019 --> 00:38:41.788
一個常見的案例是

00:38:41.855 --> 00:38:45.125
你能決定代碼以一個紋理獲取爲依據

00:38:45.192 --> 00:38:48.095
在這個着色器中我們不必做任何事
還是早點放棄

00:38:48.495 --> 00:38:50.364
而且這是非常有意義的

00:38:50.430 --> 00:38:53.300
因爲在這種情況下你要做的事情

00:38:53.367 --> 00:38:56.069
將不必做 你正在保存所有的工作

00:38:56.270 --> 00:38:57.171
太棒了

00:38:57.671 --> 00:39:01.808
但是當你增加吞吐量

00:39:02.509 --> 00:39:04.378
通過減少你需要乾的工作

00:39:05.012 --> 00:39:07.948
但是你也增加了延遲

00:39:08.015 --> 00:39:12.853
因爲現在必須獲取第一個紋理
然後等待紋理獲取

00:39:13.320 --> 00:39:14.955
接着做早期的終止檢查

00:39:15.255 --> 00:39:17.758
接着做其它的紋理獲取

00:39:18.192 --> 00:39:21.295
呃 會更快嗎？難道不是嗎？

00:39:21.361 --> 00:39:23.964
時常你只需要測試一下

00:39:24.298 --> 00:39:27.534
因爲哪個更快真正依賴的是着色器

00:39:27.601 --> 00:39:31.038
但是值得考慮的事時常是真正的權衡

00:39:31.104 --> 00:39:33.440
你時常要測試來明確什麼是正確的

00:39:34.174 --> 00:39:35.876
雖然沒有通用規則

00:39:35.943 --> 00:39:40.447
我可以針對A8和後期的GPUs
給你一個獨特的的指南

00:39:40.514 --> 00:39:45.485
那就是同一時刻
硬件至少需要兩個紋理獲取

00:39:45.552 --> 00:39:47.955
來獲得足夠的性能來避免延遲

00:39:48.222 --> 00:39:49.456
一個是不夠的

00:39:49.823 --> 00:39:51.558
如果你只能做一次 沒有問題

00:39:51.625 --> 00:39:53.760
但是如果你有一些選擇

00:39:53.827 --> 00:39:55.829
來分配着色器中的紋理獲取

00:39:55.896 --> 00:39:58.131
如果你同一時刻允許它做兩次

00:39:58.198 --> 00:39:59.833
你會獲得更好的性能

00:40:01.235 --> 00:40:02.569
所以 總結就是

00:40:03.504 --> 00:40:04.371
確保你選擇了

00:40:04.438 --> 00:40:07.708
正確的地址空間 數據結構 佈局等等

00:40:07.774 --> 00:40:10.344
因爲把這個弄錯會導致

00:40:10.410 --> 00:40:13.080
這個演講中的其它東西都不重要了

00:40:14.314 --> 00:40:15.516
用編譯器工作

00:40:15.582 --> 00:40:16.950
寫下你想的

00:40:17.017 --> 00:40:18.452
不要嘗試着太聰明

00:40:18.519 --> 00:40:21.188
否則編譯器不知道你想什麼而迷失

00:40:21.421 --> 00:40:22.789
且不能做好它自己的任務

00:40:23.590 --> 00:40:25.459
另外 寫下你想的是很簡單的

00:40:26.894 --> 00:40:30.163
注意大陷阱而不僅僅是極小的優化

00:40:30.297 --> 00:40:33.800
它們時常不明顯而且它們也不時常發生

00:40:33.867 --> 00:40:35.302
但當它們發生時 會導致嚴重的問題

00:40:35.369 --> 00:40:39.339
它們導致的問題如此嚴重
以至於再多的小優化都無法彌補

00:40:40.908 --> 00:40:42.576
隨意試驗

00:40:42.643 --> 00:40:44.845
會發生很多定律權衡

00:40:44.912 --> 00:40:47.648
根本就沒有單一的定律

00:40:47.981 --> 00:40:49.950
全部都試一下 看哪種更快

00:40:51.818 --> 00:40:54.354
如果你想要更多的信息 上網查詢

00:40:54.421 --> 00:40:55.822
演講視頻就在網上

00:40:57.724 --> 00:40:58.825
還有其它的演講

00:40:58.892 --> 00:41:01.695
如果你又錯過了 視頻在網上都會有的

00:41:02.863 --> 00:41:03.697
謝謝