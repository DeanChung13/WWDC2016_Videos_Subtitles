00:00:19.920 --> 00:00:23.557
Cocoa的新特性

00:00:26.326 --> 00:00:27.261
上午好

00:00:27.895 --> 00:00:29.096
我叫Ali Ozer

00:00:29.329 --> 00:00:30.731
我和我的同事們

00:00:31.431 --> 00:00:32.366
謝謝

00:00:35.269 --> 00:00:37.905
我和我的同事Raleigh Ledet
還有Taylor Kelly

00:00:37.971 --> 00:00:40.073
來自Cocoa框架團隊
將給大家講講

00:00:40.140 --> 00:00:41.808
今年Cocoa的新特性

00:00:42.743 --> 00:00:44.011
我們的議程非常簡單

00:00:44.077 --> 00:00:46.880
首先 繼AppKit和
Foundation新特性

00:00:46.947 --> 00:00:48.182
之後的API更新

00:00:49.683 --> 00:00:53.954
關於API更新方面
我想跟大家講講

00:00:54.021 --> 00:00:55.556
我們主要有兩類API更新

00:00:55.622 --> 00:00:58.959
第一 由於新Swift API指南
導致的API更新

00:00:59.359 --> 00:01:02.062
第二 我們做的一些常用API改良

00:01:02.362 --> 00:01:03.430
讓我們開始吧

00:01:04.897 --> 00:01:07.634
無論你昨天是否聽過

00:01:07.701 --> 00:01:11.338
今天上午 我們有關於
Swift新API設計指南

00:01:11.538 --> 00:01:13.774
並且這些指南包含Cocoa約定和實踐

00:01:13.841 --> 00:01:17.377
我不過是要
提醒你這些東西是什麼

00:01:18.078 --> 00:01:20.414
使用清晰和一致性命名

00:01:20.848 --> 00:01:24.318
追求流暢的使用
大家都知道 調用的地方讀起來

00:01:24.384 --> 00:01:26.854
應該像英文短句
命名增強

00:01:26.920 --> 00:01:30.457
和不可變方法保持對應一致
sort與sorted

00:01:30.524 --> 00:01:33.694
append與appending
還有避免縮寫

00:01:33.760 --> 00:01:36.563
這些都是我們多年來使用的主要指南

00:01:36.630 --> 00:01:39.066
我們把它寫成文檔

00:01:39.132 --> 00:01:41.235
在以前WWDC大會上
我們也講過

00:01:41.301 --> 00:01:42.903
正如這次演講你看到的一樣

00:01:43.504 --> 00:01:45.772
現在我們把這些指南做了更新

00:01:45.839 --> 00:01:49.109
使用了Swift的特性 比如強類型

00:01:49.176 --> 00:01:51.645
類型推斷 還有重載

00:01:51.712 --> 00:01:54.681
並且確保我們的API
在Swift中能表現出來

00:01:54.748 --> 00:01:57.084
我來講下API中的一些關鍵不同點

00:01:57.150 --> 00:01:58.819
由於這些改變的結果

00:01:59.386 --> 00:02:02.523
一方面 我們消除了重複和
不必要的單詞

00:02:02.589 --> 00:02:05.492
顯然使我們的API更加敏捷

00:02:05.559 --> 00:02:06.693
你昨天可能聽了

00:02:06.760 --> 00:02:08.095
昨天有個例子

00:02:08.161 --> 00:02:11.098
如Chris Lattner
關於“詳情諮文”的部分

00:02:11.164 --> 00:02:14.735
這裏有另外一個例子
contacts.arrayByAddingObject

00:02:14.801 --> 00:02:18.906
比如這樣的一個方法調用
“數組”和

00:02:18.972 --> 00:02:21.341
“對象”並不能
真實反應這個調用

00:02:21.675 --> 00:02:25.245
所以這個名字現在改成了
contacts.adding(person)

00:02:26.713 --> 00:02:29.349
在NSColor這個類上
還有另外一個例子

00:02:29.950 --> 00:02:33.453
NSColor.blueColor
我們現在NSColor類上

00:02:33.520 --> 00:02:34.922
Blue已經是一個顏色了

00:02:34.988 --> 00:02:37.424
color這個單詞其實在
這調用中不需添加

00:02:37.791 --> 00:02:38.892
所以在新的指南中

00:02:38.959 --> 00:02:40.961
它將變成NSColor.blue

00:02:41.795 --> 00:02:44.431
不過需要注意的是我們仍然追求清晰

00:02:44.498 --> 00:02:47.901
這是NSColor另一方法
NSColor.textColor

00:02:48.902 --> 00:02:51.605
文本本質上不是一個顏色
其實

00:02:51.672 --> 00:02:54.975
談論文本的顏色可能會產生混亂

00:02:55.409 --> 00:02:58.979
文本是代表顏色的RGB值
還是其它的？

00:02:59.413 --> 00:03:01.715
所以在此案例中 我們沒改變這個方法

00:03:01.782 --> 00:03:04.051
還是作爲
NSColor.textColor

00:03:04.151 --> 00:03:05.452
跟它之前一樣

00:03:08.488 --> 00:03:12.593
另外一些關鍵變化是類型的利用

00:03:13.660 --> 00:03:17.497
這裏有個例子
document.readFromURL ofType

00:03:18.498 --> 00:03:22.402
現在這個API將變成
document.readFrom ofType

00:03:22.769 --> 00:03:26.540
你會注意到我們移除了
這個單詞... URL

00:03:26.640 --> 00:03:27.908
從我們的方法簽名中

00:03:27.975 --> 00:03:31.411
那是因爲第一個參數的類型就是URL

00:03:31.478 --> 00:03:34.214
根據類型推斷
Swift知道該如何去處理它

00:03:34.281 --> 00:03:35.449
通過移除這個單詞

00:03:35.516 --> 00:03:38.352
其實在NSDocument上
現有三個閱讀方法

00:03:38.819 --> 00:03:42.589
他們都準確的命名了同樣一件事
從ofType讀取

00:03:42.656 --> 00:03:45.459
並且它是作爲第一個參數
第一個參數的類型

00:03:45.526 --> 00:03:47.828
URL 數據
或者FileWrapper

00:03:47.895 --> 00:03:50.497
把它們區分開來

00:03:51.698 --> 00:03:54.401
現在這需要注意的一件事情就是利用

00:03:54.468 --> 00:03:55.602
第一個參數

00:03:56.970 --> 00:03:59.907
這裏從此以後就被拉到了括號內

00:04:00.440 --> 00:04:01.909
我們這樣做是基於大量的案例

00:04:01.975 --> 00:04:05.212
例如 當第一個參數表現成
介詞短語的一部分時

00:04:05.279 --> 00:04:08.515
我們會把這個短語拉到括號內
正如你這看到的一樣

00:04:08.582 --> 00:04:12.352
你可以從我們的API中
看到大量這樣的例子

00:04:12.653 --> 00:04:15.622
可能大家也注意到
第二個參數ofType

00:04:15.989 --> 00:04:18.725
我們並沒有把類型這個單詞
從API中移除

00:04:18.791 --> 00:04:22.362
因爲這個參數是一個字符串
而且字符串是弱類型

00:04:22.429 --> 00:04:24.731
我們其實要一個單詞來描述它們的角色

00:04:24.798 --> 00:04:27.901
而這裏的角色就是我們打開的文件類型

00:04:27.968 --> 00:04:30.838
所以我們在API中
保留了類型這個單詞

00:04:35.042 --> 00:04:38.245
現在很多框架和
標準庫API都被改變了

00:04:38.312 --> 00:04:40.247
基於這些新的指南

00:04:40.314 --> 00:04:43.584
並且把Objective-C
API映射到

00:04:43.650 --> 00:04:46.887
Swift的輸入者
也使用了這些新指南

00:04:46.954 --> 00:04:49.623
不過你可能會注意到有些API
還需要進一步調教

00:04:49.890 --> 00:04:52.693
我們已在些API中做了
如textColor API

00:04:52.759 --> 00:04:54.995
前面提到過的
它是一個例外

00:04:55.062 --> 00:04:57.998
若你在Swift中
暴露Objective-C API

00:04:58.065 --> 00:05:00.534
你可能需要使用一些

00:05:00.601 --> 00:05:04.371
像NS Swift Name
它可以讓你覆蓋默認的

00:05:04.438 --> 00:05:05.472
輸入者做的事情

00:05:06.039 --> 00:05:08.208
大家知道移植器轉換你的——

00:05:08.275 --> 00:05:10.544
移植器可將你現有Swift 2代碼

00:05:10.611 --> 00:05:14.515
轉換成Swift 3並且
它還會幫你使用這些新命名

00:05:14.581 --> 00:05:16.116
在你現有的代碼中 當然

00:05:16.316 --> 00:05:18.719
Swift API
設計指南討論

00:05:18.785 --> 00:05:21.088
在此之前
你可以

00:05:21.154 --> 00:05:22.589
從視頻中獲取一些細節

00:05:22.656 --> 00:05:24.658
關於這些指南和它們的影響

00:05:25.759 --> 00:05:29.196
現在我們已經有很多常用的API改良

00:05:29.263 --> 00:05:32.399
有些我們已經完成有一段時間了
有些我們還將繼續做

00:05:32.466 --> 00:05:34.101
我們來快速過一下

00:05:34.168 --> 00:05:35.435
可空性

00:05:35.502 --> 00:05:38.805
去年我們已經在這方面做了很多

00:05:38.872 --> 00:05:41.909
它通常用來聲明是否有參數返回值

00:05:41.975 --> 00:05:44.845
屬性可以爲空
或者是否可選

00:05:44.912 --> 00:05:47.347
今年我們一直在持續完善它

00:05:47.414 --> 00:05:51.018
例如 該方法在10.11版本中標明

00:05:51.084 --> 00:05:52.719
返回一個可選值

00:05:52.786 --> 00:05:56.557
NSMenu中的addItem方法
但在10.12版本中 它並沒有標明

00:05:56.623 --> 00:05:59.526
返回一個非可選值
因爲我們決定

00:05:59.593 --> 00:06:01.762
它永遠無法真正返回空值
而且

00:06:01.828 --> 00:06:03.630
最好由你的代碼來反應出來更爲適當

00:06:03.697 --> 00:06:04.965
當然 也更簡單一點

00:06:06.166 --> 00:06:09.269
我們一直在改進屬性
把getter和setter對

00:06:09.336 --> 00:06:11.672
轉換成正規屬性

00:06:11.738 --> 00:06:14.441
今年我們同樣在實際中
使用了Swift的能力

00:06:14.508 --> 00:06:16.176
來聲明類中的屬性

00:06:16.543 --> 00:06:19.179
例如 這是NSWindow中的
一個新屬性

00:06:19.246 --> 00:06:20.814
你會在後面的演講中聽到這個

00:06:20.881 --> 00:06:22.616
allowsAutomaticWindowTabbing

00:06:23.150 --> 00:06:26.320
這是在Swift中
一個真實類中的屬性

00:06:27.120 --> 00:06:28.655
你還會注意到我們同樣有能力

00:06:28.722 --> 00:06:30.157
在Objective-C中做到這樣

00:06:30.224 --> 00:06:32.259
在Objective-C中
你也可定義類屬性

00:06:32.326 --> 00:06:34.661
使用語法
@property class

00:06:34.728 --> 00:06:36.964
同樣特性引入到了
Objective-C中

00:06:37.030 --> 00:06:38.632
這確實很酷

00:06:38.699 --> 00:06:42.970
這有個Core Data的例子
NSPersistentStoreCoordinator

00:06:43.036 --> 00:06:46.039
在10.11版本中 它有這個方法
registeredStoreTypes

00:06:46.106 --> 00:06:47.774
現在它被定義成了類的屬性

00:06:47.841 --> 00:06:48.942
它是一個只讀屬性

00:06:49.009 --> 00:06:51.245
所以它只有get方法
正如你這裏看到的一樣

00:06:51.478 --> 00:06:55.983
同樣在Objective-C
它也變成了類的屬性 如你看到的一樣

00:06:58.085 --> 00:06:59.820
泛型
我們把它應用到了

00:06:59.887 --> 00:07:02.155
集合類中
不過它們真的

00:07:02.222 --> 00:07:03.357
不僅用於集合

00:07:03.423 --> 00:07:05.425
它們還用於其它任何地方

00:07:05.492 --> 00:07:07.261
我敢肯定 你已經意識到了

00:07:07.728 --> 00:07:10.564
這裏有一個Core Data
NSFetchRequest的例子

00:07:11.632 --> 00:07:14.301
這裏是10.11版本中定義的方式
非常簡單

00:07:14.368 --> 00:07:16.436
在10.12中 我們前進了一步

00:07:16.503 --> 00:07:19.239
添加了一個
ResultType類型參數

00:07:19.306 --> 00:07:23.076
我們同樣在其它一些API中
添加了一些東西

00:07:23.143 --> 00:07:24.444
如這execute方法

00:07:24.511 --> 00:07:27.814
返回一個這種結果類型的數組

00:07:27.881 --> 00:07:31.752
因此 這個用例
現在就變成這個樣了

00:07:31.818 --> 00:07:34.788
你從一個管理對象獲得請求

00:07:34.855 --> 00:07:36.023
比如員工

00:07:36.290 --> 00:07:38.058
然後往前繼續執行它

00:07:38.125 --> 00:07:40.060
現在返回值被自動推斷爲

00:07:40.127 --> 00:07:42.162
一個員工數組

00:07:42.596 --> 00:07:44.731
現在這個例子會是這樣
不過我們希望

00:07:44.798 --> 00:07:49.269
在將來的版本中
我們可以像這樣表達得更乾淨

00:07:49.336 --> 00:07:50.370
這確實很酷

00:07:50.437 --> 00:07:53.874
所以從這兩行
編譯器可以推斷

00:07:53.941 --> 00:07:56.176
返回類型是一個被管理了的對象數組

00:07:57.845 --> 00:08:00.314
我們一直在改進枚舉命名

00:08:00.380 --> 00:08:04.184
來看一個我們在這方面已實施的例子
NSColorPanelMode

00:08:04.251 --> 00:08:07.287
變化是——這是一個Swift用例

00:08:07.354 --> 00:08:08.755
你看它並非很吸引人

00:08:08.822 --> 00:08:12.860
是因爲.NSCrayonModeColorPanel
非常冗長

00:08:13.560 --> 00:08:17.030
變化就是我們把通用後綴拉到前面

00:08:17.097 --> 00:08:19.199
變成前綴
使得Swift裏的名字

00:08:19.266 --> 00:08:20.634
更清晰一點

00:08:20.701 --> 00:08:22.803
你知道 出現這點的地方

00:08:22.870 --> 00:08:24.905
用例就是.crayon

00:08:24.972 --> 00:08:27.241
這是它之前的樣子

00:08:27.441 --> 00:08:29.576
這是它現在的樣子 相當清晰

00:08:31.378 --> 00:08:33.113
在枚舉這一塊

00:08:33.179 --> 00:08:35.716
我們同樣對字符串枚舉
做了改進

00:08:35.782 --> 00:08:38.150
Swift支持字符串值的枚舉

00:08:38.217 --> 00:08:41.154
許多Cocoa API
都會暴露一組字符串

00:08:41.221 --> 00:08:45.058
無論打開或者關閉的API
在我們的API中

00:08:45.125 --> 00:08:47.794
我們來看一個字符串轉換的例子

00:08:48.829 --> 00:08:51.632
在Swift 2中我們有一堆
全局常量

00:08:51.999 --> 00:08:54.535
NSStringTransformLatinToGreek
等等

00:08:54.601 --> 00:08:56.904
有一個API
stringByApplyingTransform

00:08:56.970 --> 00:08:59.573
把這些字符串作爲
它的第一個參數

00:08:59.773 --> 00:09:01.942
在Swift 3中
我們添加了一種新類型

00:09:02.009 --> 00:09:06.280
叫StringTransform
還有一個擴展我們給它定義多種值

00:09:06.346 --> 00:09:07.981
比如LatinToGreek

00:09:08.048 --> 00:09:10.551
有API叫
applyingTransform

00:09:10.617 --> 00:09:15.455
它第一個參數現在是官方的
StringTransform

00:09:15.522 --> 00:09:19.293
所以這個字符串參數現在是
StringTransform

00:09:19.359 --> 00:09:20.561
類型更加安全

00:09:21.094 --> 00:09:24.932
現在 注意這裏有一個
開放式枚舉

00:09:24.998 --> 00:09:26.967
這裏面你可以定義
你自己的值

00:09:28.302 --> 00:09:29.436
我演示下如何做到這點

00:09:32.005 --> 00:09:33.040
你可以繼續添加一個擴展

00:09:33.106 --> 00:09:36.043
到StringTransform
然後定義你自己的類型

00:09:36.109 --> 00:09:40.047
現在這裏的值就是
ICU庫接受的值

00:09:40.113 --> 00:09:41.114
用於做轉換

00:09:41.181 --> 00:09:44.718
你可以使用任何有效的
ICU提供的ID

00:09:44.785 --> 00:09:47.020
它轉換成
一個ICU擁有的需要出版的東西

00:09:47.087 --> 00:09:49.890
這些我們API中並不暴露

00:09:50.057 --> 00:09:52.960
所以 你可以定義你自己的
出版轉換

00:09:53.026 --> 00:09:55.929
然後把它傳給API
如果它是一個內置的

00:09:58.332 --> 00:10:00.534
字符串枚舉
同樣在Objective-C可以使用

00:10:00.601 --> 00:10:04.204
通過使用這兩個宏
給開放或者封閉式的集合

00:10:04.271 --> 00:10:07.441
這是添加字符串轉換聲明的方式

00:10:07.508 --> 00:10:08.809
在10.11中 那是我們已有的方式

00:10:08.876 --> 00:10:11.078
在10.12中 有一個新
字符串轉換類型

00:10:11.144 --> 00:10:14.648
被定義成NS Extensible
String Enum

00:10:16.984 --> 00:10:19.620
我們同樣使用了Swift能力來改進

00:10:19.686 --> 00:10:24.224
在一個類型中嵌套聲明另一種類型

00:10:24.625 --> 00:10:26.627
看一個NSData的例子

00:10:26.693 --> 00:10:30.097
我們有一個可選的集合
NSDataWritingOptions

00:10:30.163 --> 00:10:34.368
NSData類有一個API
writeToURL使用了這個值

00:10:34.768 --> 00:10:38.138
在Swift 3中
它變成NSData類

00:10:38.205 --> 00:10:40.774
嵌套了WritingOptions
如你在此所見

00:10:42.176 --> 00:10:44.978
使用這個API實際上是指向

00:10:45.045 --> 00:10:48.315
WritingOptions顯然是
更加清晰更好作用域

00:10:48.749 --> 00:10:52.419
除了這些嵌套的改變
你可能注意到一些其它的東西

00:10:53.720 --> 00:10:55.923
那就是類型的變化

00:10:55.989 --> 00:11:00.260
你可能注意到
我們現在提供了一個空集合默認值

00:11:00.327 --> 00:11:03.297
大多數我們需要傳入可選值時

00:11:03.363 --> 00:11:06.366
意味着我們不在需要傳入可選參數了

00:11:07.034 --> 00:11:09.937
你可能還注意到
這裏NSURL變成了URL

00:11:10.003 --> 00:11:11.104
你可能已聽過這個了

00:11:11.171 --> 00:11:13.440
不過我們後面還會有
關於它的更多談論

00:11:15.108 --> 00:11:18.579
現在 我離開舞臺前的
最後一個主題是...

00:11:19.713 --> 00:11:20.747
noescape

00:11:20.814 --> 00:11:23.717
好的 noescape聲明

00:11:23.784 --> 00:11:27.588
一個閉包的執行
在函數調用後將不會退出

00:11:27.888 --> 00:11:28.856
我的意思是什麼？

00:11:28.922 --> 00:11:32.059
這裏有一個NSCollection view的方法
performBatchUpdates

00:11:32.125 --> 00:11:33.894
它有兩個閉包參數

00:11:35.195 --> 00:11:37.364
你可能注意到了
第一個參數標記爲noescape

00:11:37.431 --> 00:11:39.733
意思是這個閉包的執行

00:11:39.800 --> 00:11:42.636
將完成執行

00:11:42.703 --> 00:11:44.404
在API performBatchUpdates
方法返回之前

00:11:44.471 --> 00:11:46.773
第二個參數沒有標記爲
noescape

00:11:46.840 --> 00:11:51.044
意思是這個閉包的執行將可能發生在

00:11:51.111 --> 00:11:52.713
函數返回之後

00:11:52.779 --> 00:11:53.947
所以 這對你來說是一個好的暗示

00:11:54.014 --> 00:11:55.682
同樣對編譯器也是一個好的暗示

00:11:55.916 --> 00:11:58.151
這個技巧同樣適用於
Objective-C

00:11:58.218 --> 00:12:00.687
我們可以使用NS NOESCAPE
來裝飾閉包

00:12:00.754 --> 00:12:01.855
以達到同樣的效果

00:12:02.523 --> 00:12:05.692
這些就是我們常用API變化的概覽

00:12:05.759 --> 00:12:07.561
現在大家擁有的版本中

00:12:07.628 --> 00:12:09.229
我們已完成了所有想要做的事情

00:12:09.296 --> 00:12:11.532
將會有一些字符串枚舉變化

00:12:11.598 --> 00:12:14.234
類屬性變化將會在其它版本中出現

00:12:14.301 --> 00:12:16.336
我們將會應用到更多的API中

00:12:19.806 --> 00:12:21.475
接着我們來談談關於AppKit

00:12:21.542 --> 00:12:25.045
我將給大家邀請Raleigh
Ledet上臺給大家講講

00:12:25.112 --> 00:12:25.946
謝謝

00:12:30.284 --> 00:12:31.151
謝謝 Ali

00:12:31.385 --> 00:12:32.386
大家 上午好

00:12:33.287 --> 00:12:36.423
大家看到 在過去的一年裏
我們在AppKit上下了很多功夫

00:12:36.723 --> 00:12:40.327
現在我們深入一下
來講講窗口捕捉

00:12:41.428 --> 00:12:45.165
當你在macOS Sierra下
拖動一個窗口

00:12:45.232 --> 00:12:47.634
當你靠向一個邊緣的時候
將產生邊緣粘連

00:12:47.701 --> 00:12:49.736
還有與另外一個窗口的頂部對齊

00:12:49.803 --> 00:12:51.238
甚至是在縮放大小的時候

00:12:51.305 --> 00:12:55.108
所以現在將窗口對齊就簡單多了

00:12:55.175 --> 00:12:58.045
或者以你想要的方式
來縮放大小

00:12:58.612 --> 00:13:01.515
我們付出很多努力
在這裏提供摸索

00:13:01.582 --> 00:13:03.984
來確保我們只提供捕捉行爲

00:13:04.151 --> 00:13:07.487
第一時間推測
你想對窗口做些什麼

00:13:08.288 --> 00:13:10.858
在你的應用中獲取捕捉行爲的方式就是

00:13:10.924 --> 00:13:14.027
讓系統來爲你處理窗口的拖拽

00:13:14.795 --> 00:13:16.630
如果你自己跟蹤鼠標

00:13:16.697 --> 00:13:18.599
然後手動控制窗口的位置

00:13:18.665 --> 00:13:21.702
你將會繞開窗口捕捉
我們會恰當地放置窗口

00:13:21.768 --> 00:13:24.738
在這裏你要求我們放置它
正如我們之前的發佈

00:13:26.740 --> 00:13:29.443
如在keynote上看到的
我們現有了窗口tabbing

00:13:30.410 --> 00:13:34.114
這是一個TextEdit的例子
有三個文檔tab打開

00:13:34.848 --> 00:13:38.485
關於窗口tabbing
其實他們就是多個窗口

00:13:38.819 --> 00:13:42.823
所以此例中
有三個tab的TextEdit

00:13:42.890 --> 00:13:44.858
其實就是三個不同NS窗口支持

00:13:46.093 --> 00:13:49.596
所以我們做的只是
對這些當中的每一個窗口

00:13:49.663 --> 00:13:52.366
只將一個tab設置可見
就認爲是可見

00:13:52.933 --> 00:13:55.269
若你檢查NSWindow
的.visible屬性

00:13:55.335 --> 00:13:56.537
它將返回真

00:13:57.404 --> 00:14:00.607
只不過僅有可見的tab
才正真被渲染到屏幕上

00:14:00.807 --> 00:14:03.911
我們將其它窗口
隱藏到窗口服務器級別

00:14:03.977 --> 00:14:06.380
所以它們沒有被渲染
也不佔用任何資源

00:14:08.815 --> 00:14:10.651
而且我們自動處理這些過程

00:14:11.385 --> 00:14:14.054
那如何給窗口添加
一個New Tab呢？

00:14:14.688 --> 00:14:17.424
創建一個新的窗口
然後將它排到前面

00:14:17.491 --> 00:14:20.060
然後我們將會繼續
恰當地爲你創建一個tab

00:14:20.127 --> 00:14:21.762
然後放置在窗口中

00:14:22.462 --> 00:14:25.732
如果你要移除一個tab
將你的窗口過濾掉

00:14:25.799 --> 00:14:27.568
然後我們將繼續爲你移除掉tab

00:14:27.634 --> 00:14:29.136
這些都是自動玩完成的

00:14:30.704 --> 00:14:32.973
現在如果用戶縮放了窗口
我們將僅僅

00:14:33.040 --> 00:14:35.442
縮放與當前激活的tab
相關聯的窗口

00:14:36.143 --> 00:14:37.945
我們不會花費時間

00:14:38.011 --> 00:14:41.248
去處理其它窗口
當用戶並不想切換到它們的時候

00:14:41.515 --> 00:14:43.817
不過當用戶要切換到
其它tab中的某一個時

00:14:43.884 --> 00:14:45.586
在那時AppKit將會繼續

00:14:45.652 --> 00:14:48.722
適當的縮放窗口
重新渲染它

00:14:48.789 --> 00:14:51.959
然後將窗口服務器等級的
隱藏屬性修改

00:14:52.025 --> 00:14:54.461
所以用戶得到的是無縫的體驗

00:14:54.528 --> 00:14:57.831
一個窗口擁有多個tab
儘管在這背後

00:14:57.898 --> 00:14:59.833
我們只是處理了三個窗口

00:15:02.236 --> 00:15:05.138
我想談一些
大家需要做的東西

00:15:05.205 --> 00:15:07.374
當你準備給你的應用採取tab

00:15:07.441 --> 00:15:09.610
這依賴於你的應用

00:15:09.676 --> 00:15:10.577
是什麼類型

00:15:11.078 --> 00:15:14.181
如果你有一個例如類似基於
NSDocument一樣的應用

00:15:14.615 --> 00:15:17.284
或者non-NSDocument
的應用

00:15:17.651 --> 00:15:18.685
你需要做些什麼

00:15:18.752 --> 00:15:21.221
如果你已經存在一個tab實現

00:15:21.288 --> 00:15:24.858
我講圍繞這一節來講解
用一些大家可以使用的API

00:15:25.058 --> 00:15:27.227
在你的應用中去定製tab

00:15:28.929 --> 00:15:31.398
若是基於NSDocument的應用
你不需要做什麼

00:15:31.465 --> 00:15:34.868
這基本上是自動的
其實此處TextEdit

00:15:34.935 --> 00:15:38.172
我們幾乎完全是修改了0行代碼
在TextEdit上

00:15:38.405 --> 00:15:41.375
它完全支持標籤
而且在這個方框下運行的非常正確

00:15:42.476 --> 00:15:46.280
若是基於non-NSDocument的應用
它大部分是自動的

00:15:46.346 --> 00:15:48.348
不過你可能需要做的是
開啓

00:15:48.415 --> 00:15:51.752
New Tab按鈕
在你的應用裏

00:15:52.186 --> 00:15:54.922
New Tab按鈕
在這裏是一個附加的按鈕

00:15:54.988 --> 00:15:56.323
在所有tab的右邊

00:15:57.524 --> 00:16:02.162
要開啓這個按鈕 你需要實現
newWindowForTab NSResponder

00:16:02.229 --> 00:16:04.932
在你的NSWindow子類中重寫

00:16:04.998 --> 00:16:06.700
或者在響應鏈中
某個更高的地方

00:16:06.767 --> 00:16:09.036
例如
NSWindow代理

00:16:09.102 --> 00:16:12.239
或者NSWindow控制器
或者NSWindow文檔

00:16:12.506 --> 00:16:14.942
如果你在其中任何一個地方
實現了重寫

00:16:15.008 --> 00:16:16.977
AppKit將會看到它並且將繼續

00:16:17.044 --> 00:16:19.479
自動爲你開啓New Tab按鈕

00:16:22.082 --> 00:16:24.818
如果你有自己已存在的tab實現

00:16:24.885 --> 00:16:26.386
你可能需要禁用

00:16:26.453 --> 00:16:28.856
AppKit的自動窗口
tabbing行爲

00:16:29.790 --> 00:16:30.891
這裏是這個類的屬性

00:16:30.958 --> 00:16:33.260
NSWindow的
allowsAutomaticWindowTabbing

00:16:34.161 --> 00:16:36.430
這是一個類屬性
在你的應用啓動之初

00:16:36.496 --> 00:16:37.998
叫做NSWindow

00:16:38.065 --> 00:16:42.169
allowsAutomaticWindowTabbing
等於假

00:16:42.236 --> 00:16:44.771
這裏將關閉
AppKit的tabbing行爲

00:16:44.838 --> 00:16:47.975
然後你將可以繼續使用
你自己的tabbing實現了

00:16:48.375 --> 00:16:51.311
這裏非常重要
你需要在應用啓動

00:16:51.378 --> 00:16:53.113
且開始將窗口展示出來前調用它

00:16:56.083 --> 00:16:59.453
你只需要在你的應用中添加tab支持

00:16:59.520 --> 00:17:00.687
它大多數情況下是自動工作的

00:17:00.754 --> 00:17:03.557
不過這裏有些API
你可以用來自定義一些事情

00:17:04.090 --> 00:17:07.094
首先 用戶可以定義一些行爲

00:17:07.160 --> 00:17:10.030
指定在系統中
他們想要的tabbing方式

00:17:10.097 --> 00:17:11.832
且他們可以在系統設置中來這麼做

00:17:11.898 --> 00:17:13.834
你獲取用戶設置

00:17:13.901 --> 00:17:17.804
通過在NSWindow上
用戶tabbing設置的類屬性

00:17:18.137 --> 00:17:21.241
它們可以設置爲手動
始終或者僅僅tabbing

00:17:21.308 --> 00:17:23.143
在它們全屏的時候

00:17:25.279 --> 00:17:27.047
在剩下的這些屬性
和函數中

00:17:27.114 --> 00:17:29.616
我講給大家討論下
實例屬性以及

00:17:29.683 --> 00:17:30.984
NSWindow的函數

00:17:31.685 --> 00:17:33.687
一旦你有了一個NSWindow實例

00:17:33.954 --> 00:17:35.322
你可將它設置爲tabbing模式

00:17:35.722 --> 00:17:37.457
默認情況下
這個tabbing模式是自動的

00:17:37.524 --> 00:17:40.694
也就是說我們將使用
用戶的tabbing設置

00:17:41.061 --> 00:17:43.297
不過你可以將它設置爲首選或者禁用

00:17:43.363 --> 00:17:44.965
取決於你的窗口類型和你的需要

00:17:47.100 --> 00:17:49.670
當我們把窗口分組到一起
變成一組tab的時候

00:17:49.736 --> 00:17:52.706
我們只想把類似的窗口分組到一起
我們判斷的方式就是

00:17:52.773 --> 00:17:54.808
通過查看tabbing的標識符

00:17:54.875 --> 00:17:56.743
若有相同tabbing標識符窗口

00:17:56.810 --> 00:17:58.612
我們就可以把它們
以tab的方式分組到一起

00:17:59.213 --> 00:18:01.582
默認情況下 AppKit會使用
一種啓發式搜索並且

00:18:01.648 --> 00:18:03.984
從你的利益角度出發
生成一個tabbing標識符

00:18:04.051 --> 00:18:07.387
我們檢查這些東西
例如窗口的子類名稱

00:18:07.754 --> 00:18:10.190
窗口的屬性 文檔

00:18:10.257 --> 00:18:13.260
還有一些其它各種屬性
然後嘗試生成

00:18:13.327 --> 00:18:16.129
適當的tabbing標識符

00:18:16.496 --> 00:18:17.865
這種方式運作得非常好

00:18:17.931 --> 00:18:20.501
如果它在你的應用中
運作不夠好的話

00:18:20.567 --> 00:18:23.504
或者你想要更多的控制它

00:18:23.570 --> 00:18:25.706
你可以手動設置tabbing標識符

00:18:25.772 --> 00:18:27.441
AppKit將會遵守它

00:18:28.509 --> 00:18:30.978
你無法獲取到哪些窗口被分組到了一起

00:18:31.044 --> 00:18:34.281
通過tab中的某個窗口實例

00:18:34.348 --> 00:18:35.849
獲取所有tab窗口

00:18:36.383 --> 00:18:38.418
注意它會返回一個可選數組

00:18:38.886 --> 00:18:42.623
它可返回空 而且如果tab欄不顯示
它必然返回空值

00:18:42.689 --> 00:18:44.925
這裏根本沒有關聯的tab

00:18:46.760 --> 00:18:50.998
你可以手動添加
其它的tab窗口將它們分組到一起

00:18:51.064 --> 00:18:53.734
因爲這些都是窗口
這正好說明瞭API名稱

00:18:53.800 --> 00:18:56.637
當你添加一個tab窗口
而不是添加一個tab自身

00:18:56.703 --> 00:18:58.705
添加了tab窗口之後
可以使用

00:18:58.772 --> 00:19:01.408
NSWindowOrderingMode進行排序
它將使tab跟其他

00:19:01.875 --> 00:19:03.277
tab關聯起來進行排序

00:19:05.579 --> 00:19:08.649
AppKit會給菜單添加一些新項

00:19:09.082 --> 00:19:12.219
也就是說在窗口菜單下
添加了一些項目

00:19:12.286 --> 00:19:15.055
以此來幫助用戶在tab之前進行導航

00:19:15.122 --> 00:19:17.191
比如選擇下一個或者上一個tab

00:19:17.624 --> 00:19:19.960
這只是NSWindow上的IB動作

00:19:20.027 --> 00:19:23.297
而且你也可以基於你自己的
用戶界面元素來編寫它們

00:19:23.530 --> 00:19:26.600
例如 你可能想要一個按鈕
來切換tab欄

00:19:26.834 --> 00:19:28.836
你可以將那個按鈕連接到窗口

00:19:30.070 --> 00:19:32.072
toggleTabBar IBAction

00:19:32.439 --> 00:19:35.843
NSWindow將爲你處理
切換tab欄

00:19:37.477 --> 00:19:39.580
上面就是關於窗口捕獲和
tabbing的所有內容

00:19:40.147 --> 00:19:42.816
讓我們繼續來講下關於
右-左的支持

00:19:42.883 --> 00:19:44.551
我們在AppKit上做了很多工作

00:19:44.618 --> 00:19:47.120
來加強現有的右-左的支持

00:19:47.721 --> 00:19:51.491
大家這裏看到的截圖是運行在
阿拉伯語中的TextEdit

00:19:51.892 --> 00:19:54.127
標題欄是翻轉過來的

00:19:54.261 --> 00:19:56.230
滾動條被放到了另外一邊

00:19:56.296 --> 00:19:58.298
甚至New Tab按鈕也放到另一邊

00:19:58.365 --> 00:19:59.900
並且所有的小屬性

00:19:59.967 --> 00:20:02.069
還有各式各樣的標題欄按鈕都翻轉了

00:20:02.135 --> 00:20:04.705
非常符合右-左用戶的期望

00:20:06.006 --> 00:20:09.142
我想從三個不同的級別來討論
從右-左的支持

00:20:09.409 --> 00:20:12.913
系統級別會發生什麼
當用戶設置了他們的本地化

00:20:12.980 --> 00:20:14.381
在系統設置面板中

00:20:15.148 --> 00:20:16.517
它會對應用產生什麼影響

00:20:16.583 --> 00:20:18.051
你的應用會表現成什麼樣

00:20:18.118 --> 00:20:20.187
依賴於你對本地化的支持

00:20:20.787 --> 00:20:22.422
然後下降到內容層面

00:20:22.489 --> 00:20:23.891
就是在NSView級別

00:20:24.224 --> 00:20:26.560
如果需要的話
你可以進一步重寫一些東西

00:20:26.627 --> 00:20:28.428
直接使用用戶界面佈局

00:20:28.829 --> 00:20:30.931
然後我將會圍繞着一節

00:20:30.998 --> 00:20:33.667
通過一個非常不錯的開發技巧來幫助你

00:20:33.967 --> 00:20:36.436
給你的應用提供右-左的支持

00:20:37.704 --> 00:20:39.840
首先 讓我們從系統層面開始講

00:20:41.141 --> 00:20:42.876
這裏的關鍵點是一致性

00:20:43.110 --> 00:20:45.245
我們需要保持一致性的表現

00:20:45.312 --> 00:20:47.447
在用戶設置爲右-左的系統中

00:20:47.814 --> 00:20:50.951
所以不管你支持哪種本地化

00:20:51.018 --> 00:20:53.820
在你的應用中
我們想要讓所有菜單欄

00:20:54.087 --> 00:20:57.658
在一個右-左的系統中
從Apple這個菜單項開始

00:20:57.724 --> 00:21:01.762
在這裏放在其它的菜單項的右邊

00:21:01.828 --> 00:21:05.132
這裏同樣適用窗口的標題欄

00:21:06.033 --> 00:21:08.302
所以交通指示燈將翻轉到另一邊

00:21:08.368 --> 00:21:09.803
所有不在內容區域的東西

00:21:09.870 --> 00:21:11.305
都將翻轉到另一邊

00:21:11.705 --> 00:21:14.041
不管你的應用中支持的是何種本地化

00:21:14.274 --> 00:21:16.476
給用戶提供一致性的體驗

00:21:17.311 --> 00:21:21.181
現在降級到應用層面
我們將不能自動這麼做了

00:21:21.248 --> 00:21:22.916
因爲我們不想打斷任何

00:21:22.983 --> 00:21:24.318
你的應用中可能有的設定

00:21:24.785 --> 00:21:28.522
所以強烈的建議你添加
右-左的支持

00:21:28.589 --> 00:21:31.959
在你的應用中
添加猶太人和阿拉伯人本地化

00:21:32.993 --> 00:21:35.996
一旦在有了這些本地化

00:21:36.496 --> 00:21:37.731
在應用層面

00:21:37.798 --> 00:21:41.301
所有的滾動區域將自動無視
垂直滾動和標尺

00:21:41.368 --> 00:21:43.670
NSBrowser將自動翻轉

00:21:44.104 --> 00:21:46.340
在這個層面 我們同樣需要一致性

00:21:46.406 --> 00:21:51.211
所以不管何種用戶界面佈局方向的
任何內容區域

00:21:51.979 --> 00:21:55.816
我們都想要滾動條保持一致性
都在同一側

00:21:57.184 --> 00:21:58.719
下降到內容層面

00:21:59.253 --> 00:22:01.688
默認情況下用戶界面佈局方向
將會匹配

00:22:01.755 --> 00:22:04.091
你的是應用如何設置的

00:22:05.392 --> 00:22:08.529
在大部分情況下
這正是你所期望的

00:22:08.595 --> 00:22:09.963
不過有一些例外

00:22:10.030 --> 00:22:12.499
也就是說 如果你有
一些類似媒體控件

00:22:12.566 --> 00:22:15.035
或者空間控件 或者時間控件

00:22:15.102 --> 00:22:19.606
它們始終是一樣的佈局
從左往右

00:22:19.673 --> 00:22:22.376
對於左-右用戶和
右-左用戶來說都是這樣

00:22:23.043 --> 00:22:25.812
所以你可以修改用戶界面佈局方向

00:22:26.513 --> 00:22:28.982
並且下面這些AppKit中的
控件都支持那樣做

00:22:29.383 --> 00:22:31.885
所以自動佈局將不會在這個階段中

00:22:31.952 --> 00:22:38.492
不過在即將到來第二階段中
我們將開始使用父容器

00:22:38.959 --> 00:22:44.731
來決定哪邊是頭哪邊是尾

00:22:45.999 --> 00:22:47.534
版本中已有的表格視圖

00:22:47.601 --> 00:22:50.270
和outline view會適當的
調整它們的列

00:22:50.337 --> 00:22:54.641
NSPageController
可切換動畫且這個列表還在繼續

00:22:54.708 --> 00:22:57.811
我們在AppKit中
有很多對右-左的支持

00:22:57.878 --> 00:22:59.980
讓AppKit做繁瑣的工作

00:23:00.347 --> 00:23:04.551
給你的用戶提供一個右-左更好的體驗

00:23:06.954 --> 00:23:08.422
我答應過給大家一個開發技巧

00:23:08.488 --> 00:23:10.057
我已使用這個技巧一整年了

00:23:10.123 --> 00:23:11.859
我發現它難以置信的有用

00:23:12.226 --> 00:23:14.828
在Xcode中 你可以修改項目體質

00:23:14.895 --> 00:23:17.497
在Options選項中
修改你的應用的語言

00:23:17.564 --> 00:23:19.099
設置成右-左虛擬語言

00:23:19.566 --> 00:23:21.435
這可以讓你的應用

00:23:21.502 --> 00:23:24.037
在開發語言中運行
對我來說它就是英語

00:23:24.404 --> 00:23:26.173
大家看到這裏
TextEdit運行在英語當中

00:23:26.640 --> 00:23:31.078
但是它在所有控件中使用了
右-左翻轉

00:23:31.278 --> 00:23:34.281
所以窗口標題欄被翻轉了

00:23:34.515 --> 00:23:36.383
滾動區域的滾動條翻轉了

00:23:36.450 --> 00:23:39.186
大家看到所有小的子項和

00:23:39.253 --> 00:23:40.487
標題欄所有按鈕都翻轉了

00:23:40.554 --> 00:23:44.825
所以這是一個非常簡單的方式
讓你獲得右-左的支持

00:23:44.892 --> 00:23:47.995
並且確保所有的東西
在你的原生語言下運行正確

00:23:49.796 --> 00:23:52.165
在這裏僅僅涵蓋了
我們在AppKit中做的事

00:23:53.033 --> 00:23:54.401
還有很多東西可以討論

00:23:54.468 --> 00:23:57.504
在“國際化用戶界面新特性”的演講中

00:23:57.571 --> 00:23:59.139
在星期五上午9:00
於Nob Hill舉行

00:23:59.640 --> 00:24:01.308
他們涵蓋了更多東西在桌面方面

00:24:01.375 --> 00:24:05.979
比如WebKit 文本佈局
資源管理

00:24:06.046 --> 00:24:09.049
他們還包含iOS上右-左的支持

00:24:09.116 --> 00:24:11.151
強烈推薦大家也關注下這個討論

00:24:14.054 --> 00:24:15.889
讓我們來討論下promise拖拽

00:24:16.256 --> 00:24:18.225
若你還不熟悉
promise拖拽就是

00:24:18.292 --> 00:24:21.328
當用戶從你的應用中拖拽一個文件

00:24:22.262 --> 00:24:25.799
但是在磁盤上其實並沒有這個文件

00:24:26.133 --> 00:24:27.334
你只是許下個promise

00:24:27.401 --> 00:24:29.570
你將會寫入到用戶想要釋放的地方

00:24:29.903 --> 00:24:30.971
這就是一個文件promise拖拽

00:24:31.038 --> 00:24:34.575
從一開始我們就在OS X中
支持promise拖拽

00:24:35.809 --> 00:24:38.712
在macOS Sierra中
我們升級了文件promise拖拽

00:24:38.779 --> 00:24:42.015
將會更加現代化
使用NSFilePromiseProvider

00:24:42.082 --> 00:24:44.284
和NSFilePromiseReceiver對象

00:24:44.985 --> 00:24:47.354
現在這些對象允許
文件promise拖拽

00:24:47.421 --> 00:24:48.789
來支持拖放羣集

00:24:49.223 --> 00:24:50.490
若你對拖放羣集還不熟悉

00:24:50.557 --> 00:24:52.259
其實就是當你拖放多個元素時

00:24:52.326 --> 00:24:54.361
它們會形成中間拖動

00:24:54.428 --> 00:24:56.463
這依賴於目標應用

00:24:56.530 --> 00:24:57.531
將會對它們做什麼

00:24:59.666 --> 00:25:03.170
使用這兩類的文件promise
拖拽可支持拖拽羣集

00:25:03.237 --> 00:25:04.204
它們基於UTI

00:25:04.538 --> 00:25:06.974
它們完全是尊從
writer和reader樣板

00:25:07.040 --> 00:25:10.811
即你可使用NSPasteboard
上基於元素的API

00:25:10.878 --> 00:25:12.446
同這些對象一起工作

00:25:13.280 --> 00:25:14.982
如果可能的話它們會適配文件

00:25:15.048 --> 00:25:16.884
所以你不用擔心文件的適配

00:25:16.950 --> 00:25:19.253
我們會自動包裝文件適配的讀

00:25:19.319 --> 00:25:21.488
和寫 從你的利益角度出發

00:25:22.089 --> 00:25:23.457
並且反過來它們也是兼容的

00:25:24.124 --> 00:25:27.895
它們反過來也兼容基於無元素的
文件promise API

00:25:28.462 --> 00:25:31.031
也就是說你只需要關心一個API

00:25:31.231 --> 00:25:33.734
如果你實現了一個
NSFilePromiseProvider

00:25:33.800 --> 00:25:35.502
你現可提供文件promise

00:25:35.569 --> 00:25:39.406
給任何使用新NSFilePromiseReceiver API的人

00:25:39.473 --> 00:25:41.575
或者那些在現有應用中

00:25:41.642 --> 00:25:43.610
使用基於無元素API的人

00:25:43.677 --> 00:25:45.979
他們同樣可以接受
你的promise文件

00:25:46.046 --> 00:25:49.283
就像NSFilePromiseReceiver一樣

00:25:49.349 --> 00:25:51.552
你也可以接受文件promise

00:25:51.618 --> 00:25:54.454
從任何使用NSFilePromiseProvider的地方

00:25:54.521 --> 00:25:57.057
或者使用基於無元素API的地方

00:25:59.693 --> 00:26:03.530
所以如果你想在拖拽中提供
一個文件promise

00:26:03.597 --> 00:26:06.200
當用戶開始拖動時
你需要創建一個promise

00:26:06.266 --> 00:26:09.703
通過創建一個
NSFilePromiseProvider實例來實現

00:26:09.970 --> 00:26:13.207
如果你想要給
每個promise的文件

00:26:13.273 --> 00:26:14.641
都創建一個實例

00:26:14.708 --> 00:26:17.377
你需要提供一個
NSFilePromiseProvider代理

00:26:17.611 --> 00:26:19.580
這個代理將負擔承重的任務

00:26:19.646 --> 00:26:21.248
把文件寫入到磁盤上

00:26:21.949 --> 00:26:24.685
同時 目的地將調用
這個promise

00:26:24.751 --> 00:26:27.487
你將會被詢問提供目的地的文件名稱

00:26:27.554 --> 00:26:28.889
現在你知道目的地在哪裏了

00:26:28.956 --> 00:26:30.657
你就可以弄清楚文件名了

00:26:30.724 --> 00:26:33.360
不過請不要在這個時候寫入文件
因爲它還沒被包裝成

00:26:33.427 --> 00:26:35.863
文件適配
而且我們發現

00:26:35.929 --> 00:26:37.598
拖動中還有一些其它項目

00:26:38.232 --> 00:26:39.099
當拖動結束之後

00:26:39.166 --> 00:26:40.667
我們知道了所有需要知道的信息

00:26:40.734 --> 00:26:43.904
再來調用代理 然後詢問
你promise要寫入到的URL

00:26:44.705 --> 00:26:46.340
並提供一個完成的處理器

00:26:46.406 --> 00:26:50.611
在這個時候 它們都包裝成了
文件適配寫入

00:26:50.944 --> 00:26:53.347
然後只需要寫入文件到
提供的URL

00:26:53.413 --> 00:26:55.949
然後調用完成的處理器
讓文件適配知道

00:26:56.016 --> 00:26:56.950
你已經完成了寫入

00:26:58.385 --> 00:27:00.521
若你想要接受一個文件promise

00:27:00.821 --> 00:27:02.623
你首先需要註冊view

00:27:02.689 --> 00:27:04.725
在你想要允許任務發生的地方

00:27:05.192 --> 00:27:07.861
這通常由view.register
forDraggedTypes完成

00:27:07.928 --> 00:27:11.198
你需要添加的拖動類型
就是NSFilePromiseReceiver

00:27:11.265 --> 00:27:12.699
readableDrappedTypes

00:27:12.766 --> 00:27:14.067
這非常簡單

00:27:15.068 --> 00:27:17.771
現在一旦用戶拖動一個文件
promise到這個view上

00:27:17.838 --> 00:27:19.273
你將會得到拖拽消息

00:27:19.339 --> 00:27:21.375
然後你想得到promise對象

00:27:22.242 --> 00:27:26.013
可以使用基於元素樣板API

00:27:26.079 --> 00:27:29.650
訪問這個對象的forClasses
NSFilePromiseReceiver.self來獲得訪問

00:27:29.716 --> 00:27:32.386
你將會得到一個
NSFilePromiseReceiver對象的數組

00:27:33.320 --> 00:27:35.689
你但你有了
NSFilePromiseReceiver對象

00:27:35.756 --> 00:27:37.090
你可以調用這個promise裏面的

00:27:37.157 --> 00:27:40.227
通過調用receivePromisedFiles
atDestination options

00:27:40.294 --> 00:27:41.428
operationQueue reader

00:27:42.029 --> 00:27:44.531
然後它將迅速的從這個函數返回

00:27:44.598 --> 00:27:46.400
reader塊還沒有被調用

00:27:46.466 --> 00:27:47.768
我們將在後面返回來調用

00:27:48.869 --> 00:27:51.605
一但源文件寫入所有的promise

00:27:51.672 --> 00:27:54.308
現在我們繼續
返回過去調用reader塊

00:27:54.374 --> 00:27:56.343
在指定的操作隊列上

00:27:56.877 --> 00:28:01.615
現在 這點非常重要
你沒有指定NSMainOperationQueue

00:28:01.682 --> 00:28:04.117
給這個操作隊列
或者你將

00:28:04.184 --> 00:28:07.521
打斷你的應用
在等待源進程

00:28:07.588 --> 00:28:08.822
完成文件寫入的時候

00:28:08.889 --> 00:28:09.957
這過程需要一些時間

00:28:10.023 --> 00:28:12.392
而且你不想應用被打斷在這整個過程中

00:28:15.963 --> 00:28:18.198
這就是關於文件
promise拖拽所做的事

00:28:18.265 --> 00:28:22.202
它有更簡單的的API可以使用
而且可以同拖拽羣集工作

00:28:22.269 --> 00:28:24.872
還可以通過樣板支持基於元素API

00:28:25.772 --> 00:28:27.708
讓我們繼續來講下我們做的一些改進

00:28:27.774 --> 00:28:29.243
針對各種容器視圖

00:28:29.476 --> 00:28:31.178
我們從集合視圖開始

00:28:31.812 --> 00:28:34.681
對於集合視圖 預想你可以滾動

00:28:35.182 --> 00:28:38.318
內容可以在任何背景視圖上滾動

00:28:38.385 --> 00:28:39.419
這就是你可能已有的

00:28:39.586 --> 00:28:42.055
現在你可以告訴背景視圖
跟隨上下文一起滾動

00:28:42.122 --> 00:28:44.858
通過設置backgroundViews
ScrollsWithContent爲真

00:28:44.925 --> 00:28:46.093
它們將會一起滾動

00:28:46.927 --> 00:28:50.464
我們同樣已經支持
可選浮動header和footer

00:28:50.531 --> 00:28:52.699
你可以把這裏的文檔header
設爲浮動

00:28:52.766 --> 00:28:54.334
然後內容區域滾動將會在它下面

00:28:55.936 --> 00:28:58.739
使用NSCollectionView的浮動佈局
這將非常的簡單

00:28:59.006 --> 00:29:01.275
只需要設置sectionHeadersPinToVisible爲真

00:29:01.341 --> 00:29:04.444
或者sectionFootersPinToVisibleBounds爲真

00:29:04.511 --> 00:29:05.979
如果你想要footer爲浮動

00:29:06.046 --> 00:29:07.714
NSCollectionView將會

00:29:07.781 --> 00:29:10.083
適當的處理 基於你的行爲

00:29:11.151 --> 00:29:13.720
你也可以可選摺疊任何部分

00:29:13.787 --> 00:29:16.023
到一個單獨的水平的可滾動行

00:29:16.089 --> 00:29:18.926
正如你這裏看到的一樣
而且還有少許旋轉效果

00:29:18.992 --> 00:29:20.527
當你水平滾動的時候

00:29:22.229 --> 00:29:25.732
通過toggleSectionCollapse IBAction
可以非常簡單地做到這點

00:29:25.799 --> 00:29:27.201
在NSCollectionView上

00:29:27.634 --> 00:29:31.805
現在這個消息的發送者需要是一個視圖

00:29:31.872 --> 00:29:35.375
在你的區塊header或者一個
繼承自區塊header的視圖

00:29:35.442 --> 00:29:38.312
NSCollectionView才能準確的確定

00:29:38.378 --> 00:29:41.248
哪個區塊需要切換摺疊

00:29:43.250 --> 00:29:47.154
一旦在header或者
派生的視圖中有按鈕

00:29:47.588 --> 00:29:50.891
你需要將區塊的header
實現NSCollectionView

00:29:50.958 --> 00:29:53.994
SectionHeaderView協議
它僅僅只是

00:29:54.061 --> 00:29:56.530
把你的按鈕鏈接到sectionCollapseButton的插口

00:29:57.097 --> 00:29:59.499
然後NSCollectionView
將可以可以找到你的按鈕

00:29:59.566 --> 00:30:01.201
並且自動隱藏和顯示它

00:30:01.268 --> 00:30:05.038
依賴於內部有足夠的內容

00:30:05.105 --> 00:30:07.174
在這個區塊來摺疊

00:30:09.009 --> 00:30:11.712
NSTableView
將重繪所有的子視圖

00:30:12.212 --> 00:30:13.814
當索引值爲-1

00:30:13.881 --> 00:30:17.150
負1是我們的特殊數表示

00:30:17.217 --> 00:30:22.489
擴展你表格中的所有行和列

00:30:22.823 --> 00:30:24.091
因此 當你調用reloadData

00:30:24.157 --> 00:30:26.226
並且索引包含負1時

00:30:26.293 --> 00:30:29.396
我們將替你自動重載所有行

00:30:29.863 --> 00:30:33.667
這個僅從10.12版本開始支持

00:30:34.501 --> 00:30:37.271
因此在10.12或更新版本中

00:30:37.337 --> 00:30:40.774
NSOutlineView
也將自動加載它的表格

00:30:40.841 --> 00:30:43.610
相關聯的也會重新加載

00:30:44.545 --> 00:30:48.348
另外 OutlineView
現在體驗更好

00:30:48.415 --> 00:30:50.584
通過數據源返回

00:30:51.785 --> 00:30:56.557
這個功能非常有用 但若你的應用真想

00:30:56.623 --> 00:31:01.161
保持我們原有的刷新行爲

00:31:01.228 --> 00:31:03.063
你可以設置
stronglyReferencesItems爲假

00:31:03.130 --> 00:31:07.568
你就可以使用
10.12之前版本的行爲

00:31:10.737 --> 00:31:13.740
然後 Taylor Kelly向前

00:31:13.807 --> 00:31:15.742
來和你談談網格視圖

00:31:22.516 --> 00:31:23.417
謝謝Raleigh

00:31:23.917 --> 00:31:26.854
首先我想談NSGridView視圖

00:31:27.054 --> 00:31:30.157
這是和NSStackView
相似的一個新視圖類

00:31:30.224 --> 00:31:31.692
我們實現了創建和管理

00:31:31.758 --> 00:31:33.894
約束你的佈局

00:31:34.862 --> 00:31:37.564
但如同StackView
創建線性佈局顯示

00:31:37.631 --> 00:31:40.667
NSGridView
創建相交的行和列

00:31:41.001 --> 00:31:43.871
你在偏向窗格的UI中會經常看到

00:31:44.104 --> 00:31:46.440
是的 這些不同的行列

00:31:46.507 --> 00:31:48.942
會自動調整

00:31:49.009 --> 00:31:50.477
標準的定義

00:31:51.278 --> 00:31:55.682
它支持基線 頭部 底部 對齊

00:31:56.383 --> 00:31:59.520
它支持GridView設置整體間距

00:31:59.586 --> 00:32:02.890
作爲每個行列之間的間距

00:32:03.957 --> 00:32:06.727
類似電子表格應用 它支持單元格合併

00:32:06.793 --> 00:32:10.264
因此 一個單一的視圖
可以跨越多行或多個列

00:32:11.098 --> 00:32:13.700
如同分隔符做的一樣

00:32:15.135 --> 00:32:18.038
它還支持動態隱藏行和列的顯示

00:32:18.105 --> 00:32:20.073
不改變GridView結構的情況下

00:32:20.440 --> 00:32:22.809
例如 當我們點擊這個複選框

00:32:22.876 --> 00:32:24.811
我們可能想隱藏
顯示偏好按鈕

00:32:25.679 --> 00:32:28.382
我們可以通過獲取包含按鈕的行

00:32:28.448 --> 00:32:30.150
並設置其隱藏屬性爲true

00:32:30.784 --> 00:32:32.619
GridView將自動刷新界面

00:32:34.054 --> 00:32:36.490
還有幾個可以改進我們自動佈局

00:32:37.024 --> 00:32:39.660
一個是清理AppKit佈局週期

00:32:40.260 --> 00:32:42.729
視圖不在需要使用佈局

00:32:42.796 --> 00:32:44.731
或者不需要層的參與

00:32:45.399 --> 00:32:47.768
通過設置needslayout
爲true

00:32:47.835 --> 00:32:50.671
下一個界面顯示時 它會調用佈局

00:32:52.039 --> 00:32:55.542
這樣佈局顯示時
不再被調用兩次

00:32:55.609 --> 00:33:00.013
對於層的支持
我們減少了隱性髒佈局

00:33:00.080 --> 00:33:02.749
因此減少佈局

00:33:02.816 --> 00:33:04.284
這個實現方式很好

00:33:04.585 --> 00:33:05.719
但是 如果你遇到佈局

00:33:05.786 --> 00:33:07.821
在你調用時沒有響應

00:33:07.888 --> 00:33:10.324
確認你設置了needsLayout

00:33:11.358 --> 00:33:14.561
所有這一切都使它更容易
成爲你的子視圖手動佈局

00:33:14.628 --> 00:33:17.431
所以你可以重寫佈局
而不需要調用super

00:33:17.497 --> 00:33:21.468
計算子視圖寬架 設置並返回

00:33:22.536 --> 00:33:24.738
你要確保沒有

00:33:24.805 --> 00:33:26.573
將自己的視圖和其他視圖混淆

00:33:26.640 --> 00:33:28.308
若在視圖佈局中發生這樣的情況

00:33:28.375 --> 00:33:30.978
它設置自己的框架或父類的框架

00:33:31.245 --> 00:33:36.283
這將弄髒視圖的佈局
並導致額外的佈局

00:33:37.117 --> 00:33:39.720
如果一直存在
這就是我們說的佈局環

00:33:40.254 --> 00:33:41.755
這個很難去調試

00:33:42.222 --> 00:33:44.024
所以在macOS 和 iOS

00:33:44.091 --> 00:33:46.560
我們已經介紹了新的佈局環的調試

00:33:46.627 --> 00:33:49.596
所以你可以更好的理解
哪兒佈局有問題和爲什麼

00:33:51.164 --> 00:33:54.201
佈局的改變添加的API到父類

00:33:54.268 --> 00:33:57.070
因此 你可以知道父類的含義

00:33:57.538 --> 00:34:00.474
即使不使用父類接口
你也需要申請

00:34:02.442 --> 00:34:04.411
除此之外
時間現在是可以爲null

00:34:04.478 --> 00:34:07.181
因此 如果你正在使用該屬性
一定要處理的是零的情況

00:34:08.081 --> 00:34:10.117
另外 接口支持新功能

00:34:10.184 --> 00:34:12.052
用於自動佈局的添加

00:34:12.418 --> 00:34:13.620
因此在一個單獨文件或

00:34:13.687 --> 00:34:17.357
在一個單一的視圖層次結構中
你可以使用常量

00:34:17.424 --> 00:34:18.458
這是非常好的

00:34:19.726 --> 00:34:22.029
NSGridView佈局環調試的
詳細內容

00:34:22.094 --> 00:34:24.831
在週五“自動佈局有何新特性”中講解

00:34:26.099 --> 00:34:28.101
在這裏
我想談談顏色

00:34:28.168 --> 00:34:30.237
特別是全範圍的顏色

00:34:30.771 --> 00:34:33.540
所以sRGB是一個漂亮的
流行色彩空間

00:34:33.607 --> 00:34:37.844
通常是使用隱含的顏色
代替未指定的空間

00:34:38.145 --> 00:34:40.581
我們大部分的顯示器
有一個sRGB色域

00:34:41.514 --> 00:34:44.650
新的5K iMac
和iPad Pro 9.7英寸屏

00:34:44.918 --> 00:34:48.856
都包含這些更新的顯示器
可以顯示更生動的顏色

00:34:49.322 --> 00:34:52.059
具體地說 他們正在使用
P3色域

00:34:52.559 --> 00:34:56.063
比起sRGB色域

00:34:56.129 --> 00:34:58.565
它可以顯示很多
更充滿活力的綠色和紅色

00:34:59.433 --> 00:35:02.603
所以你的應用可以顯示照片

00:35:02.669 --> 00:35:05.706
更精確的顏色
可以展示這些更具活力的

00:35:05.772 --> 00:35:08.075
顏色讓界面看上去更加真實

00:35:08.842 --> 00:35:11.678
舉顏色的一個例子
綠色

00:35:11.745 --> 00:35:14.915
正好是
Pantone的2013年度色

00:35:16.149 --> 00:35:17.985
它超出了sRGB範圍

00:35:18.051 --> 00:35:19.786
所以以前顯示器不能顯示這個顏色

00:35:19.853 --> 00:35:22.623
但是使用P3可以完美顯示出來

00:35:24.024 --> 00:35:27.160
你的照片也包含
這些更鮮豔的顏色

00:35:27.227 --> 00:35:29.196
特別是紅色和橙色

00:35:29.730 --> 00:35:33.400
諷刺的是 投影機
甚至在家裏的電視

00:35:33.467 --> 00:35:35.669
其實不去
顯示這些顏色

00:35:35.736 --> 00:35:38.672
所以你不得不承認它們很特別

00:35:40.541 --> 00:35:41.875
如果你想用這些顏色

00:35:41.942 --> 00:35:45.212
有新的色彩空間displayP3
它讓你可以擁有

00:35:45.279 --> 00:35:47.915
這包含sRGB和
其它的色彩空間

00:35:48.415 --> 00:35:53.086
NSColor中有新構造方法
displayP3紅色 綠色 藍色 阿爾法值

00:35:53.153 --> 00:35:55.589
它允許你
在顏色空間中創建一個顏色

00:35:55.789 --> 00:35:58.692
UIColor具有相同的構造函數
具有相同的效果

00:35:59.760 --> 00:36:01.595
另一種方式具有廣泛的顏色

00:36:01.662 --> 00:36:05.098
採用的方式
我們調用擴展範圍sRGB

00:36:06.667 --> 00:36:09.837
所以用色彩空間時
你通常被限制

00:36:09.903 --> 00:36:11.872
元件值從0到1

00:36:12.406 --> 00:36:14.274
且你可在色域範圍內選擇任何顏色

00:36:14.341 --> 00:36:16.710
比如藍色 通過這些值

00:36:17.311 --> 00:36:20.147
但你不能代表一個顏色
這就是色域之外

00:36:20.214 --> 00:36:22.583
所以sRGB不能代表這個綠色的顏色

00:36:23.550 --> 00:36:26.353
擴展範圍sRGB
使用相同的基色

00:36:26.420 --> 00:36:29.389
和相同的白色點爲sRGB
但允許部件

00:36:29.456 --> 00:36:32.059
採取值小於
0或大於1

00:36:32.759 --> 00:36:36.163
所以它可以代表這個綠色
通過一個負的紅色和藍色的值

00:36:36.230 --> 00:36:38.131
和一個大於1的綠色值

00:36:39.066 --> 00:36:42.069
這恰好也是P3
綠色的原始值 因此

00:36:42.135 --> 00:36:45.105
擴展範圍的sRGB
你可以代表全範圍

00:36:45.172 --> 00:36:47.207
你需要的顏色
在顯示器上

00:36:48.542 --> 00:36:51.311
這也有一個彩色空間
extendedSRGB

00:36:51.879 --> 00:36:53.380
和現有的NSColor

00:36:53.447 --> 00:36:55.616
以及UIColor已經在使用的函數

00:36:55.782 --> 00:36:57.951
先前提供的
顏色使用sRGB

00:36:58.218 --> 00:37:01.555
現在將接受較少的值
小於0或大於1

00:37:01.622 --> 00:37:03.891
給你回一個
擴展範圍的sRGB色

00:37:04.391 --> 00:37:05.359
這是非常方便的

00:37:07.461 --> 00:37:08.662
考慮一個重要的事

00:37:08.729 --> 00:37:11.732
這些更廣泛的顏色
色域顏色深度

00:37:12.132 --> 00:37:15.736
所以sRGB理論上可以
表示在其色域任何顏色

00:37:15.802 --> 00:37:17.137
但每比特8位

00:37:17.204 --> 00:37:20.440
你也只能解決數量有限的 是的

00:37:20.507 --> 00:37:22.876
這裏的黑色空間只是非尋址顏色

00:37:22.943 --> 00:37:24.411
使用8位每組件

00:37:25.812 --> 00:37:29.283
當你擴大色域 增加該色域的音量

00:37:29.349 --> 00:37:31.118
但保持相同的位深度

00:37:31.185 --> 00:37:33.687
你是可尋址的色密度下降

00:37:34.121 --> 00:37:37.524
你能夠指定的顏色丟失精度

00:37:38.158 --> 00:37:39.193
這就是爲何我們建議

00:37:39.259 --> 00:37:42.462
工作時
這些更廣泛的色彩空間中 如P3

00:37:42.529 --> 00:37:45.165
你用16位比特
使用每個組件

00:37:46.333 --> 00:37:48.535
它內存和存儲數量翻倍

00:37:48.602 --> 00:37:51.271
但給你成倍增長更多可尋址顏色

00:37:51.338 --> 00:37:52.973
因此 我們認爲 權衡是值得的

00:37:54.374 --> 00:37:57.945
需要使用什麼API
考慮到這些更深的顏色

00:37:58.412 --> 00:38:00.981
好了 好消息是
大多數都是自動的

00:38:01.048 --> 00:38:04.151
所以NSWindow將自動使用
較深的支持存儲

00:38:04.251 --> 00:38:07.321
有了這些更高的位深度
寬色域顯示

00:38:07.387 --> 00:38:09.289
即使你拖動
它在整個屏幕

00:38:09.990 --> 00:38:11.959
如果你需要一個方法
明確控制

00:38:12.025 --> 00:38:15.295
你可以設置深度限制屬性
爲你選的值

00:38:16.430 --> 00:38:18.832
視圖和層內窗口會自動

00:38:18.899 --> 00:38:22.202
繼承該位深度
唯一的例外是OpenGL視圖

00:38:22.636 --> 00:38:25.138
你應該用
相關的像素格式的API

00:38:26.406 --> 00:38:31.478
在macOS和iOS的
CALayer有一新內容格式的屬性

00:38:32.079 --> 00:38:35.682
允許你再次
明確控制它使用比特深度

00:38:36.517 --> 00:38:39.119
所以這是你可以利用的優勢
在你的應用廣泛的顏色

00:38:39.186 --> 00:38:42.122
我們也提高了部分
系統性能 能夠更好的利用

00:38:42.189 --> 00:38:43.357
這些廣泛的色彩

00:38:43.790 --> 00:38:45.259
一個例子是彩色面板

00:38:45.659 --> 00:38:47.294
所以 在iMac左邊

00:38:47.361 --> 00:38:49.530
顏色盤會顯示

00:38:51.231 --> 00:38:52.065
開始

00:38:52.132 --> 00:38:55.969
它實際上會顯示和允許
從全方位的P3的顏色

00:38:57.371 --> 00:38:59.773
超出sRGB
正常顏色輪也會允許

00:39:00.574 --> 00:39:03.677
然而 你也能
右鍵單擊顏色輪

00:39:03.744 --> 00:39:06.280
並明確選擇
工作區色彩空間

00:39:06.680 --> 00:39:09.783
因此 即使在這些以前的顯示器
不能使P3的顏色

00:39:09.850 --> 00:39:11.785
你仍然可以允許選則他們

00:39:13.954 --> 00:39:15.989
RGB顏色選擇器
始終允許你

00:39:16.056 --> 00:39:17.858
選擇顏色
替換你工作空間

00:39:17.925 --> 00:39:19.960
但它也允許你
改變表示

00:39:20.027 --> 00:39:24.198
從8位值
從0到255到浮點數

00:39:24.565 --> 00:39:25.966
所以你又能得到精度更高

00:39:26.033 --> 00:39:28.001
工作時
有了這些更廣泛的色彩空間

00:39:28.702 --> 00:39:32.539
這些顏色面板的變化是
所有的應用程序完全免費

00:39:32.606 --> 00:39:34.575
沒有任何的接口需要調用

00:39:36.310 --> 00:39:39.313
工作具有廣泛的顏色
星期四的談話涵蓋更多

00:39:39.379 --> 00:39:41.748
如目錄支持
WebKit支持

00:39:42.149 --> 00:39:45.018
我建議你更新出來
如果這些東西使你感興趣

00:39:46.520 --> 00:39:49.056
因此 下一個主題是
狀況項目改進

00:39:49.122 --> 00:39:50.591
所以狀態項的事情

00:39:50.657 --> 00:39:52.860
底部的菜單欄

00:39:52.926 --> 00:39:54.795
這些是
先前的使用要求

00:39:54.862 --> 00:39:57.965
私有API來實現
但現在大多是免費的

00:39:58.932 --> 00:40:00.367
首先是排序

00:40:00.434 --> 00:40:03.604
現在你可以命令點擊
拖動任何項目排序它

00:40:03.670 --> 00:40:05.873
內部和外部的系統項目

00:40:06.440 --> 00:40:09.476
你也可以用鍵盤
焦點轉到您的項

00:40:09.543 --> 00:40:11.712
甚至激活菜單項內

00:40:12.779 --> 00:40:15.983
這一切最好的部分 這是完全自動的

00:40:16.049 --> 00:40:17.918
沒有API選擇或鏈接檢查

00:40:18.485 --> 00:40:21.054
所以所有的項目都是命令點擊
拖動重新排序

00:40:21.321 --> 00:40:24.858
和任何菜單設置的項目
將參與鍵盤導航

00:40:25.192 --> 00:40:27.928
如果他們有一個自定義的目標活動
他們會被跳過

00:40:29.463 --> 00:40:31.265
其次是隱藏和去除

00:40:31.632 --> 00:40:34.401
您現在可以命令單擊
並將一個項目從狀態欄中拖動

00:40:34.468 --> 00:40:36.336
移除通知該更改

00:40:36.403 --> 00:40:38.472
甚至編程恢復

00:40:39.373 --> 00:40:41.642
不同的排序
這就需要選擇

00:40:41.708 --> 00:40:44.511
沒有狀態項目將
自動移除

00:40:44.945 --> 00:40:47.347
你可以通過設置
現狀項目的行爲

00:40:47.414 --> 00:40:49.049
包含removalAllowed

00:40:49.683 --> 00:40:51.285
你可以編程
讀/設置

00:40:51.351 --> 00:40:55.022
甚至得到KVO通知這個變化的
利用可見屬性

00:40:55.589 --> 00:40:57.491
如果你的應用是一個狀態欄的應用

00:40:57.558 --> 00:41:00.260
它只表示意義
是在狀態欄圖標

00:41:00.327 --> 00:41:03.597
有無文件圖標或其他的方式
要退出它 你可以設置它

00:41:03.664 --> 00:41:05.599
自動退出清除

00:41:05.666 --> 00:41:07.801
通過設置terminationOnRemoval行爲

00:41:09.369 --> 00:41:11.738
所有這一切都會爲你保存
位置

00:41:11.805 --> 00:41:13.473
和可見的狀態
所以你不必擔心

00:41:13.540 --> 00:41:16.443
爲了保持使用
自動保存名字

00:41:16.910 --> 00:41:19.346
我們自動生成
這種基於項目指標

00:41:19.413 --> 00:41:21.014
你在你的應用程序中創建的

00:41:21.481 --> 00:41:23.784
但如果你創造它們
一些非確定性的順序

00:41:23.851 --> 00:41:25.485
或者只是想擁有
更明確的控制

00:41:25.686 --> 00:41:29.022
您可以設置自動保存的名稱
你選擇一些標識符

00:41:30.290 --> 00:41:31.658
這樣的狀況項目改進

00:41:31.725 --> 00:41:33.961
很多都是免費的
和一點點的調整

00:41:34.027 --> 00:41:36.163
你真的可以使他們
在應用程序中更好使用

00:41:37.097 --> 00:41:39.132
下一個是控件構造函數

00:41:39.533 --> 00:41:42.636
所以這些新的構造函數
在現有NS控制

00:41:42.703 --> 00:41:45.806
這使它很容易
得到標準的外觀和感覺

00:41:46.507 --> 00:41:50.711
例如 不同類型的按鈕
分段控制

00:41:50.944 --> 00:41:55.649
圖像視圖 滑塊
標籤和文本字段

00:41:56.116 --> 00:41:57.918
所以這些類型的
已有的

00:41:57.985 --> 00:41:59.753
Interface Builder對象庫

00:41:59.820 --> 00:42:02.990
這使得它很容易使用盒子的性能

00:42:03.624 --> 00:42:07.227
他們跟標準的系統設置
合適的字體大小 顏色和文本顏色

00:42:07.294 --> 00:42:09.162
他們支持不同的情境

00:42:09.229 --> 00:42:12.833
淺綠色充滿動感的標籤看起來很棒

00:42:12.900 --> 00:42:15.469
甚至盒子中充滿動感的暗色

00:42:15.536 --> 00:42:17.070
沒有額外的安裝

00:42:17.471 --> 00:42:20.007
這將對你代碼起何作用
我想向你舉例說明

00:42:20.974 --> 00:42:22.643
這是創建一個複選框前

00:42:22.709 --> 00:42:24.278
需設置相當多的屬性

00:42:24.344 --> 00:42:26.947
不幸的是
我們真的只關心其中的三個

00:42:27.014 --> 00:42:28.682
標題 目標和行動

00:42:29.816 --> 00:42:33.187
複選框 以及標題 目標
行動 剩下的

00:42:33.587 --> 00:42:34.688
這是非常好的

00:42:38.158 --> 00:42:39.560
更多的一點 哦

00:42:42.196 --> 00:42:43.030
等着

00:42:43.530 --> 00:42:45.599
所以這就是創造一個靜態標籤

00:42:45.666 --> 00:42:47.401
只是屏幕上的一些文字

00:42:47.467 --> 00:42:50.237
而在這裏 我們關心的
只是字符串值

00:42:50.971 --> 00:42:53.974
有文字的標籤 又是這樣的

00:42:54.808 --> 00:42:56.977
所以 這非常棒

00:42:57.044 --> 00:42:58.445
它是從盒子裏出來的

00:43:03.417 --> 00:43:06.687
它出來的盒子可以用
帶或不帶自動佈局

00:43:06.753 --> 00:43:08.922
所以 如果你要
定位約束

00:43:08.989 --> 00:43:11.024
你還需要設置
translatesAutoresizingMask

00:43:11.091 --> 00:43:14.361
IntoConstaints爲假
像你其他的視圖一樣

00:43:14.695 --> 00:43:16.997
所以如果你已經有了類
做這些事情

00:43:17.064 --> 00:43:19.166
我們仍然建議移動到
這些新的系統

00:43:19.233 --> 00:43:21.702
因爲你會確保
你的控制有標準的外觀

00:43:21.768 --> 00:43:24.137
感覺現在和未來

00:43:25.639 --> 00:43:28.041
我最後想談的是API的改進

00:43:28.108 --> 00:43:30.644
我只覆蓋了一些這些
適用於我們所有的框架

00:43:30.711 --> 00:43:32.212
這些申請AppKit

00:43:32.279 --> 00:43:35.082
我還想談談適用於AppKit
的另外兩點

00:43:36.016 --> 00:43:37.684
首先是弱委託

00:43:38.352 --> 00:43:40.654
所以我們已經添加了新的歸零
弱委託的支持

00:43:40.721 --> 00:43:44.124
對於不同的代表和數據
不同類別的源

00:43:45.025 --> 00:43:46.860
所以你不再需要明確這些屬性

00:43:46.927 --> 00:43:48.562
當引用們被釋放

00:43:49.696 --> 00:43:52.032
它仍然支持非弱引用的對象

00:43:52.232 --> 00:43:54.501
在這種情況下 它會回到原有的分配

00:43:54.568 --> 00:43:56.570
或不安全的 不保留語義

00:43:57.838 --> 00:43:59.072
我們也經歷過並確定了

00:43:59.139 --> 00:44:02.843
我們所有的類顯式
並宣佈其指定的初始化

00:44:03.377 --> 00:44:05.646
這些是和他們以前一樣有效的

00:44:05.712 --> 00:44:08.115
但現在只是
在實際的接口中聲明

00:44:08.682 --> 00:44:10.551
有一個例外
NSCursor

00:44:10.617 --> 00:44:13.187
所以 如果你是子NSCursor
請看發行說明

00:44:13.253 --> 00:44:14.922
你應該
正確處理

00:44:16.290 --> 00:44:18.725
與所有的新聲明
指定的初始化

00:44:19.059 --> 00:44:23.163
你應該確保你是正確的
在你的類的處理

00:44:24.198 --> 00:44:25.766
所以如果你以前沒有

00:44:25.832 --> 00:44:27.534
你可能會有這些錯誤問題

00:44:27.601 --> 00:44:29.236
這也許是微妙的錯誤

00:44:29.436 --> 00:44:31.772
在Objective-C
現在看到的編譯警告

00:44:31.839 --> 00:44:33.841
在Swift 你要去
獲得建立失敗

00:44:34.308 --> 00:44:37.044
所以你要確保你
妥善處理這些不同的情況

00:44:38.212 --> 00:44:39.413
這是AppKit最新內容

00:44:39.479 --> 00:44:40.714
在這一點上
我想翻過去

00:44:40.781 --> 00:44:43.083
有請Ali
講述“Foundation有何新特性”

00:44:50.490 --> 00:44:51.391
謝謝你 Taylor

00:44:53.861 --> 00:44:56.463
所以這裏有一些東西
這是新基礎

00:44:56.530 --> 00:44:58.632
現在進入主題

00:44:59.299 --> 00:45:02.336
現在你看到了
NSURL成爲URL

00:45:02.402 --> 00:45:04.872
我想我們昨天也談到了一點

00:45:04.938 --> 00:45:08.642
我們把NS前綴
在Swift中添加了快捷鍵

00:45:10.410 --> 00:45:13.280
現在 你可能知道
地基大的子集

00:45:13.347 --> 00:45:16.416
實際上
用Swift核心庫

00:45:16.483 --> 00:45:18.085
作爲Swift 代碼部分

00:45:18.151 --> 00:45:20.621
是可用的
在其他平臺上 如Linux

00:45:21.321 --> 00:45:25.526
我們要匹配的命名樣式
這部分的基礎

00:45:25.592 --> 00:45:28.028
隨着公約的建立
通過Swift標準庫

00:45:28.095 --> 00:45:29.963
而不使用前綴

00:45:31.164 --> 00:45:35.002
因此 我們的類型很多
沒有了NS前綴

00:45:35.068 --> 00:45:36.970
在基礎和Swift中
正如你所看到的

00:45:37.037 --> 00:45:38.972
NSFormatter變成了
Formatter等等

00:45:39.306 --> 00:45:42.576
最後兩個 NSData和NSURL
是一個特殊類別的一部分

00:45:42.643 --> 00:45:44.878
我會提到這一點

00:45:45.913 --> 00:45:48.182
現在 這正在發生
只有在基礎上修改

00:45:48.248 --> 00:45:49.349
這不是我們應用的東西

00:45:49.416 --> 00:45:52.186
到我們的其他框架
甚至在基礎

00:45:52.252 --> 00:45:54.154
這只是應用於一些API

00:45:54.221 --> 00:45:56.757
我們不把這
NS放到API

00:45:56.823 --> 00:45:59.326
本質上依賴於Objective-C

00:45:59.393 --> 00:46:03.230
例如 NSObject
NSProxy NSAutoreleasePool

00:46:03.530 --> 00:46:06.633
我們也不把它的API
在特定的平臺

00:46:06.700 --> 00:46:09.303
事實上
在其他平臺上不可用

00:46:09.369 --> 00:46:13.006
比如NSUserNotification
NSXPCConnection

00:46:14.341 --> 00:46:18.879
在另一個情況是類
這也暴露了值類型

00:46:19.313 --> 00:46:22.216
所以在這裏 我們正在暴露
數據 網址 等等 但

00:46:22.282 --> 00:46:26.220
我們也將NSData NSURL

00:46:26.286 --> 00:46:27.855
等等
我的意思是

00:46:28.121 --> 00:46:30.791
現在先讓我解釋
一點關於值類型

00:46:32.025 --> 00:46:34.228
你可能已經
熟悉值類型

00:46:34.294 --> 00:46:36.697
我們有這個概念在
基礎很長一段時間

00:46:36.763 --> 00:46:40.033
這些類型的值是
重要的 而不是身份

00:46:40.501 --> 00:46:44.505
比如NSString NSData
URL  Array等等

00:46:45.405 --> 00:46:49.643
現在 由於一些基礎的API
已經有這些值類型的語義

00:46:49.710 --> 00:46:52.412
我們已經提前並將
它們最爲Swift值類型添加

00:46:52.980 --> 00:46:55.682
我們已經做的全套API

00:46:55.883 --> 00:46:59.887
這當然是
字符串 數組 字典

00:46:59.953 --> 00:47:02.322
和設置已經
作爲值類型

00:47:02.389 --> 00:47:04.958
在Swift中  他們是可用的
在標準庫中

00:47:05.425 --> 00:47:09.663
所以現在這裏的這些類型是
暴露結構在Swift中

00:47:09.730 --> 00:47:13.534
他們有價值的語義類型
這意味着他們可以直接變異

00:47:13.600 --> 00:47:15.302
如果他們有意義的可變性

00:47:15.369 --> 00:47:19.173
你可以使用let或者var突出異變

00:47:19.540 --> 00:47:20.841
在你聲明他們的時候

00:47:21.108 --> 00:47:24.011
這些也符合Swift協議

00:47:24.077 --> 00:47:25.445
正如你所期望的

00:47:28.182 --> 00:47:30.984
現在已有的類的API
仍然保持在case

00:47:31.051 --> 00:47:32.886
在我們創建這些值類型

00:47:32.953 --> 00:47:35.756
讓我看看
這裏的案例研究

00:47:36.123 --> 00:47:38.659
一個例子是數據
我已經提到的那個

00:47:38.725 --> 00:47:40.694
所以現在我們的結構數據類型

00:47:40.761 --> 00:47:42.329
這是數據值類型

00:47:42.429 --> 00:47:48.068
這是我們期望的數據類型
在編程過程中使用最多

00:47:48.135 --> 00:47:51.939
這是前進的類型
然而 我們也有NSData

00:47:52.005 --> 00:47:54.575
這是NSObject和
NSMutableData子類

00:47:54.641 --> 00:47:57.411
這是一類NSData本身

00:47:57.778 --> 00:48:01.348
現在NS類型仍然存在
因爲如NSMutableData

00:48:01.415 --> 00:48:05.052
不是很容易遷移
所以他們不會遷移它

00:48:05.452 --> 00:48:08.155
我們的另一個原因是NS類型
有時你真的

00:48:08.222 --> 00:48:09.423
要繼承這些類型

00:48:09.489 --> 00:48:12.159
你知道 你可以子類化
NSData或者NSMutableData

00:48:12.226 --> 00:48:14.461
提供一些專業化的實現

00:48:14.528 --> 00:48:18.065
當然 你可以這樣做
類類型 如您在這裏看到的

00:48:18.131 --> 00:48:20.801
所以這些都是一些原因
爲什麼NS類型仍然存在

00:48:22.102 --> 00:48:24.471
現在 讓我們來看一看
這裏有些差異

00:48:25.772 --> 00:48:29.376
NSData類有一個長度屬性

00:48:29.443 --> 00:48:31.745
這個被命名爲數
在結構版本

00:48:31.812 --> 00:48:35.048
因爲它與其他
Swift標準庫更一致

00:48:35.482 --> 00:48:38.752
如寫入方法 範圍
和許多其他方法

00:48:38.819 --> 00:48:39.920
保持相當完整

00:48:39.987 --> 00:48:42.189
他們遇到相同的
方法 除非你會注意到

00:48:42.256 --> 00:48:45.692
NSRange和NSData
已成爲指標範圍

00:48:46.760 --> 00:48:50.697
在數據結構的版本 這是
更符合Swift庫

00:48:50.931 --> 00:48:54.034
最後你會注意到
這一變異的功能 如添加

00:48:54.101 --> 00:48:57.237
是不可以在這
直接值類型數據

00:48:57.304 --> 00:49:00.374
在NSData中
它在NSMutableData類中

00:49:00.941 --> 00:49:02.342
所以這些都是一些
的差異 你會看到

00:49:02.409 --> 00:49:04.478
在值類型
與類類型之間

00:49:06.313 --> 00:49:08.382
現在我不準備說
更多關於這個內容

00:49:08.448 --> 00:49:11.585
今天下午有一個談話
“Swift基礎有何新特性”

00:49:11.652 --> 00:49:12.886
在任務室裏

00:49:13.120 --> 00:49:15.722
我鼓勵你們參加
並聽到更多關於這些內容

00:49:17.824 --> 00:49:20.160
現在我們有幾個
基礎新類型

00:49:20.227 --> 00:49:21.862
代表測量的量

00:49:22.162 --> 00:49:24.264
這裏的主要類
是單元類

00:49:24.331 --> 00:49:27.868
這是一個抽象的類型
代表單位 如英里

00:49:27.935 --> 00:49:30.504
攝氏度 公里
每小時 等等

00:49:30.904 --> 00:49:33.774
然後我們有一個類維度
這是一個單位的子類

00:49:33.841 --> 00:49:35.943
這代表單位家庭
如長度

00:49:36.043 --> 00:49:38.145
溫度和速度 等

00:49:38.612 --> 00:49:40.047
因此 在此 我們有單位類

00:49:40.347 --> 00:49:43.383
我們有子類維度
然後我們的子類

00:49:44.117 --> 00:49:48.355
如單位長度 單位溫度
單位速度 和一堆更多

00:49:50.090 --> 00:49:52.860
有一個輔助類單元
轉換器可以

00:49:52.926 --> 00:49:55.395
單位之間
同一單位家庭轉換

00:49:56.263 --> 00:49:59.399
有一種結構測量
它是一個類

00:49:59.466 --> 00:50:02.503
在Objective-C
在Swift中作爲一個值類型

00:50:02.936 --> 00:50:05.839
結構測量相結合的值 如10

00:50:05.906 --> 00:50:07.875
用一個單位 如英里

00:50:07.941 --> 00:50:09.843
所以這基本上現在是一個測量

00:50:09.910 --> 00:50:11.645
最後錦上添花

00:50:11.712 --> 00:50:13.614
我們有測量
格式化程序類

00:50:13.680 --> 00:50:15.449
將一個測量

00:50:15.516 --> 00:50:17.818
並將其顯示給用戶區域中的用戶

00:50:18.318 --> 00:50:23.323
所以它會顯示10英里的用戶
在美國這裏

00:50:23.390 --> 00:50:26.560
但會顯示16公里 例如在歐洲

00:50:26.627 --> 00:50:27.728
使用歐洲系統的用戶

00:50:27.794 --> 00:50:31.164
所以它會爲你做的轉換
並向用戶展示正確的數據

00:50:36.803 --> 00:50:40.707
我們有很多已定義即可用的
單位家庭定義

00:50:40.774 --> 00:50:41.909
這是全套

00:50:42.142 --> 00:50:44.077
所以這些尺度的子類

00:50:44.144 --> 00:50:46.246
在其中的每一個
單位家庭

00:50:46.313 --> 00:50:49.383
我們實際上有多個即可用的單位

00:50:49.650 --> 00:50:51.919
讓我們看一看單位的溫度

00:50:52.352 --> 00:50:54.821
你會看到溫度
有三個標準單位

00:50:54.888 --> 00:50:57.191
開爾文 攝氏和華氏

00:50:57.491 --> 00:51:01.728
UnitTemperature類中
這些都被定義爲類屬性

00:51:01.795 --> 00:51:05.966
許多其他尺寸
也有一些單位規定

00:51:06.033 --> 00:51:08.035
知道彼此之間如何轉換

00:51:08.202 --> 00:51:13.207
更好的消息
你可以添加你自定義的單位

00:51:13.273 --> 00:51:16.510
我們提供
它們將使用現有的

00:51:16.577 --> 00:51:19.012
而且你也可以添加
你自己的單位家庭

00:51:19.413 --> 00:51:22.916
你可以聽到更多關於這個的內容
星期五下午4點

00:51:22.983 --> 00:51:24.451
測量和單位

00:51:26.787 --> 00:51:29.356
DateInterval是新類型
我們已添加到基礎版本

00:51:29.423 --> 00:51:32.059
它表示一個日期間隔

00:51:33.260 --> 00:51:36.597
它有三個屬性
開始 結束和持續時間

00:51:36.663 --> 00:51:38.365
相當直觀 當然 這些都不是

00:51:38.432 --> 00:51:41.435
完全獨立 但它們
作爲三個獨立的屬性

00:51:41.502 --> 00:51:42.769
除了這些屬性

00:51:42.836 --> 00:51:46.640
DateInterval能夠做到
檢查日期是否在日期間隔內

00:51:46.707 --> 00:51:48.976
或是否兩個日期間隔重疊等

00:51:49.510 --> 00:51:54.181
當然日期間隔在格式化時很有用

00:51:54.248 --> 00:51:55.682
通過DateIntervalFormatter類

00:51:55.749 --> 00:51:58.719
這就是我們
這是我們去年發佈API

00:51:59.553 --> 00:52:01.788
有個從String修改過來的
API接口

00:52:01.855 --> 00:52:05.092
現在我們從API到String
只需要一個日期間隔

00:52:05.659 --> 00:52:06.860
如此相當簡單

00:52:07.728 --> 00:52:12.032
現在在這裏讓我告訴你們
一個關於公共服務通告

00:52:12.099 --> 00:52:13.500
處理日期和時間

00:52:14.635 --> 00:52:16.603
所以處理日期可能是複雜的

00:52:17.204 --> 00:52:19.106
現在 這不是這裏建議的

00:52:19.173 --> 00:52:22.209
好嗎 我不是醫生

00:52:23.977 --> 00:52:26.313
讓我們說你想要
表示10秒時間

00:52:26.780 --> 00:52:28.982
你創建個DateInterval類

00:52:29.049 --> 00:52:31.652
開始時間和10秒

00:52:31.718 --> 00:52:34.721
這可能是正確的
無論你試圖做什麼

00:52:34.788 --> 00:52:37.391
無論你試圖
怎樣處理10秒

00:52:37.791 --> 00:52:39.760
但是讓我們說你是
試圖代表一天

00:52:40.227 --> 00:52:42.196
你也可能這樣
寫你的代碼

00:52:43.397 --> 00:52:46.433
24乘以60乘以60表示一天的秒數

00:52:46.900 --> 00:52:49.336
這是一個數字
24小時內的秒數

00:52:49.736 --> 00:52:52.873
它往往不是
正確的

00:52:53.240 --> 00:52:55.909
原因是因爲一天
並不總是24小時長

00:52:55.976 --> 00:52:57.678
一個月並非總是31天

00:52:57.744 --> 00:53:00.280
年不總是
365天 等等

00:53:00.347 --> 00:53:02.783
我們總是把那些記在心裏
但是有時一天

00:53:02.850 --> 00:53:07.688
23小時 或者有時
24小時 25小時 如你所知

00:53:08.222 --> 00:53:11.592
所以取決於你想做什麼
通過DateInterval表示日期

00:53:11.959 --> 00:53:14.628
你想設置一個鬧鐘嗎
正是從現在開始的24個小時

00:53:14.695 --> 00:53:17.865
你想在第二天同一時間發出一鬧鐘嗎

00:53:17.931 --> 00:53:19.032
你可要小心了

00:53:19.233 --> 00:53:23.470
通常情況下正確的解決方案
涉及使用日曆類

00:53:23.537 --> 00:53:25.205
你會遇到這些問題

00:53:25.272 --> 00:53:28.542
而且幸運的是他們的解決方案
上面所提到的從2013年開始

00:53:28.609 --> 00:53:30.511
常見的數據的解決方案
和時間的問題

00:53:30.577 --> 00:53:33.447
我建議你
回去重新看看

00:53:35.249 --> 00:53:38.752
ISO8601 DateFormatter
是基礎類中新提供的API

00:53:38.819 --> 00:53:40.420
這是一個格式化日期類

00:53:40.787 --> 00:53:41.622
謝謝

00:53:45.392 --> 00:53:47.094
很顯然你們中的一些人

00:53:47.160 --> 00:53:50.330
以前使用8601
8601是一個標準

00:53:50.397 --> 00:53:52.566
這是一個用於指定日期的交換格式

00:53:52.633 --> 00:53:53.967
在明確的方法中

00:53:54.334 --> 00:53:56.603
所以這是一個單獨的類
和DateFormatter相比

00:53:56.670 --> 00:53:57.938
因爲不向DateFormatter

00:53:58.005 --> 00:54:03.010
它是用戶本地化的日期
8601格式是非本地化

00:54:03.310 --> 00:54:05.712
你知道這是交換格式
所以這是一個單獨的類型

00:54:05.779 --> 00:54:08.115
我們決定讓事情變得簡單

00:54:08.448 --> 00:54:09.616
使用起來非常簡單

00:54:10.484 --> 00:54:11.818
所以創建一個格式化

00:54:13.554 --> 00:54:16.390
給自己一個日期
又沒有關係的建議

00:54:17.991 --> 00:54:20.527
簡單地問格式化程序
爲日期轉爲字符串

00:54:20.594 --> 00:54:22.129
它會返回你的格式

00:54:22.196 --> 00:54:24.531
現在DateFormatter
可以兩種方式實現

00:54:24.731 --> 00:54:25.732
所以你實際上可以

00:54:25.799 --> 00:54:28.402
哦 順便說一下
這是調用的輸出 正如你所看到的

00:54:28.468 --> 00:54:29.903
就要到午餐時間

00:54:31.004 --> 00:54:33.407
這裏是 此格式化程序
還有其他的方式

00:54:33.473 --> 00:54:34.641
也做解析

00:54:34.708 --> 00:54:38.612
所以你可以自己格式化
並要求從字符串轉換成日期

00:54:38.679 --> 00:54:40.113
它會返回你的日期

00:54:40.180 --> 00:54:41.415
所以它是雙向的

00:54:42.616 --> 00:54:46.286
這默認是RFC 3339
它是一種格式

00:54:46.353 --> 00:54:48.522
然而
有選項可讓您指定

00:54:48.589 --> 00:54:50.691
一些行爲 如果你需要的話

00:54:52.192 --> 00:54:55.495
現在讓我快速的告訴你們
我們提供的其他功能

00:54:56.396 --> 00:55:00.434
URL有一堆新的屬性

00:55:00.501 --> 00:55:04.104
如一個文件和一系列其他的典型路徑

00:55:04.171 --> 00:55:06.406
像音量是否加密等

00:55:06.473 --> 00:55:08.542
你可以閱讀所有
這些在發行說明中

00:55:08.609 --> 00:55:11.111
有一個新類
URLSessionTaskMetrics

00:55:11.512 --> 00:55:15.315
這個類可以幫助你收集
網絡資源

00:55:15.382 --> 00:55:17.117
加載性能信息

00:55:17.184 --> 00:55:20.954
所以你可以看看應用程序的網絡性能

00:55:22.422 --> 00:55:25.459
PersonNameComponentsFormatter
是新版本我們提供的一個API

00:55:25.893 --> 00:55:27.895
正如你所知道的 它需要一個名字

00:55:27.961 --> 00:55:30.697
它以一個區域設置適當的方式來格式化

00:55:31.064 --> 00:55:33.300
在這個版本中
其實現在可以解析名稱

00:55:33.367 --> 00:55:35.135
所以你給它一個名字
它會返回你

00:55:35.202 --> 00:55:37.471
名字 姓 等等

00:55:37.538 --> 00:55:38.639
這是一個不錯的工作

00:55:38.705 --> 00:55:41.475
由於它採用了一種基於
真實數據的統計模型

00:55:43.410 --> 00:55:45.445
最後

00:55:45.946 --> 00:55:47.814
但也有一些棘手的名字

00:55:47.881 --> 00:55:49.750
所以不要期望太高

00:55:52.853 --> 00:55:55.155
DateComponentsFormatter

00:55:55.222 --> 00:55:58.492
是我們最新的版本中添加的

00:55:58.559 --> 00:56:01.228
除了長短類型

00:56:01.295 --> 00:56:04.264
我們現在有一個簡單的風格
你可以格式化日期

00:56:04.331 --> 00:56:07.000
下一個發佈
也許我們會添加boxer風格

00:56:07.534 --> 00:56:09.369
好吧 這就是基礎

00:56:11.305 --> 00:56:13.540
核心數據 只是一個
簡短的提及核心數據

00:56:13.607 --> 00:56:15.576
你已經看到一些
API的改進

00:56:15.642 --> 00:56:16.844
在覈心數據與泛型

00:56:16.910 --> 00:56:19.713
有更多的
新的API在覈心代碼裏

00:56:19.780 --> 00:56:22.583
比如generational查詢
持久性存儲

00:56:22.649 --> 00:56:26.353
NSFetchedResultsController類
現在在系統OS X中可以使用

00:56:26.420 --> 00:56:28.689
對不起 是macOS系統

00:56:28.989 --> 00:56:32.392
週五上午10點你將聽到所有這一切
“核心數據有何新特性”

00:56:33.026 --> 00:56:35.429
還有一個我想大喊出來的

00:56:36.430 --> 00:56:39.833
我們每年都在這裏
告訴你關於新的API

00:56:39.900 --> 00:56:41.602
介紹了新技術

00:56:41.668 --> 00:56:44.471
你可能並不總是處於一個方式
通過這些API

00:56:44.538 --> 00:56:46.306
因爲你在做其他事情

00:56:46.373 --> 00:56:48.041
或者你等一個版本

00:56:48.342 --> 00:56:51.712
好吧 如果你想得到一個概述
關於最近我們已經添加的API

00:56:51.778 --> 00:56:55.082
APIs是重要的
創建用於Mac的現代應用

00:56:55.148 --> 00:56:56.250
這個談話是給你們的

00:56:56.450 --> 00:56:59.620
它將涉及很多主題
他們將有

00:56:59.686 --> 00:57:02.189
其他感興趣的演講
不只是在本屆 WWDC

00:57:02.256 --> 00:57:04.157
往屆 WWDC 也有

00:57:04.391 --> 00:57:07.561
它也適用於每個人
各年齡 不同經驗水平

00:57:07.895 --> 00:57:09.363
這也是星期五下午5點

00:57:09.429 --> 00:57:11.164
所以我希望你在這裏

00:57:13.033 --> 00:57:17.471
好的 那麼這是網頁
你可以瞭解更多信息

00:57:17.738 --> 00:57:20.440
請讀AppKit
與基礎版本說明

00:57:20.507 --> 00:57:22.509
您可以在我們的開發工具站點中找到

00:57:22.576 --> 00:57:25.846
它是一些原始信息
很多我已經談到了

00:57:26.146 --> 00:57:27.948
這是我們提到的有關演講

00:57:28.015 --> 00:57:29.149
還有更多的課程

00:57:29.416 --> 00:57:30.350
非常感謝大家