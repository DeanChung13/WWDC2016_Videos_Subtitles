00:00:20.020 --> 00:00:22.756
在iOS上使用觸摸輸入

00:00:22.823 --> 00:00:23.857
早上好

00:00:29.129 --> 00:00:31.765
歡迎來到在iOS上使用觸摸輸入

00:00:31.999 --> 00:00:34.168
我是Dominik Wagner
我是工程師

00:00:34.234 --> 00:00:36.403
在UIKit團隊
我會告訴你

00:00:36.470 --> 00:00:39.206
如何最好地利用我們的進展

00:00:39.273 --> 00:00:41.909
關於Multi-Touch
和Apple Pencil

00:00:42.843 --> 00:00:46.313
首先讓我們回顧一下最近新發布的硬件

00:00:46.380 --> 00:00:49.850
從去年WWDC起
我們發佈了很多東西

00:00:50.851 --> 00:00:54.521
比如帶3D Touch的
iPhone 6s和6s plus

00:00:55.055 --> 00:00:57.824
允許你使用每種觸摸的能力

00:00:58.559 --> 00:01:00.294
我不會就此談太多

00:01:00.561 --> 00:01:04.965
但是你可以瞭解Peek和Pop
帶來的良好體驗

00:01:05.465 --> 00:01:07.835
在今天晚些時候的演講
“窺視3D Touch”中

00:01:09.403 --> 00:01:13.273
我們介紹了更快的觸摸掃描
從iPad Air 2和iPad Pro開始

00:01:13.340 --> 00:01:16.877
給我們一個時間分辨率
是顯示刷新的兩倍

00:01:18.111 --> 00:01:21.281
我們還介紹了針對Apple iPad Pro
的Apple Pencil

00:01:21.715 --> 00:01:26.720
這個驚豔的設備 謝謝
給你精確的定位

00:01:26.787 --> 00:01:28.789
爲你的繪畫提供很好的精度

00:01:29.523 --> 00:01:33.060
它有更高的時間分辨率
是240赫茲

00:01:34.862 --> 00:01:39.633
它允許你使用它的傾斜和方向
當然還有力量

00:01:41.301 --> 00:01:44.805
我們的算法組在手掌拒絕上做了
很好的工作

00:01:45.172 --> 00:01:49.576
所以你可以在繪畫時休息手掌
不需要考慮它

00:01:50.777 --> 00:01:53.647
還發布了帶有Siri Remote的
Apple TV

00:01:54.848 --> 00:01:57.985
它的軌跡主要驅動
UIFocusEngine

00:01:58.051 --> 00:01:59.987
和你與Apple TV的互動

00:02:00.721 --> 00:02:04.491
但是你還能使用跟蹤板
通過使用遊戲控制器框架

00:02:04.558 --> 00:02:10.229
用來做爲一個遊戲控制器
和獲得跟蹤板的絕對位置

00:02:11.064 --> 00:02:14.334
最後你還可以處理跟蹤板

00:02:14.401 --> 00:02:18.071
在UIKit觸摸處理方法中的
間接觸摸

00:02:19.006 --> 00:02:23.110
我也不會談太多這方面
但有很好的Apple TV技術演講

00:02:23.177 --> 00:02:28.182
還有昨天的Apple TV
遊戲控制器輸入

00:02:28.882 --> 00:02:30.384
那我要講什麼？

00:02:30.784 --> 00:02:33.754
我要講你怎麼開發繪畫應用

00:02:34.288 --> 00:02:36.790
我們會從頭開始開發一個繪畫應用

00:02:36.857 --> 00:02:40.127
並且我會談到所有針對
Apple Pencil的新API

00:02:40.194 --> 00:02:43.096
所以你能訪問所有的新數據

00:02:44.097 --> 00:02:46.466
我們會一步步告訴你

00:02:47.034 --> 00:02:52.072
向你展示你可以採用的不同步驟
根據你看到的

00:02:52.706 --> 00:02:56.410
這個應用的全部代碼是可以下載的

00:02:56.476 --> 00:03:01.281
所以你不用擔心幻燈片上的代碼
晚些時候和它玩一玩

00:03:02.282 --> 00:03:05.285
向SpeedSketch問好
這是我們的例子

00:03:06.553 --> 00:03:09.323
SpeedSketch是一張紙
你可以在上面繪畫

00:03:09.389 --> 00:03:12.626
它完全支持iPad Pro
上的Apple Pencil

00:03:13.026 --> 00:03:16.330
和iPhone 6S上的
3D Touch

00:03:16.396 --> 00:03:19.399
它還工作在所有以前的iOS設備上

00:03:20.667 --> 00:03:22.469
讓我們先談談模型

00:03:25.639 --> 00:03:31.011
這是一個筆畫
這是UIKit如何看到取樣

00:03:31.078 --> 00:03:33.981
每個點是一個實例

00:03:34.047 --> 00:03:36.450
和可變的UITouch是同樣的實例

00:03:36.750 --> 00:03:39.086
你傳遞給觸摸處理方法

00:03:39.820 --> 00:03:43.657
並且我們建模我們的數據爲一系列
筆畫

00:03:47.594 --> 00:03:49.563
因爲UITouch是

00:03:49.630 --> 00:03:52.332
一個可變量
表示一個觸摸序列

00:03:52.833 --> 00:03:57.571
我們需要在觸摸處理方法中
從UITouch中複製出數據

00:03:57.838 --> 00:03:59.439
到更靜態的東西中

00:04:01.241 --> 00:04:03.110
所以我們會創建一個筆畫取樣

00:04:03.177 --> 00:04:06.213
做爲我們的數據結構最深層的元素

00:04:06.947 --> 00:04:10.918
它現在只包括UITouch的位置

00:04:10.984 --> 00:04:14.321
稍後我們會填入額外的數據

00:04:15.856 --> 00:04:19.593
我們會把那些取樣放入一個筆畫

00:04:19.660 --> 00:04:21.394
是一個筆畫取樣數組

00:04:21.461 --> 00:04:25.199
我們有一些方法來添加它們

00:04:26.266 --> 00:04:28.335
因爲我們想用筆畫

00:04:28.402 --> 00:04:33.407
作爲我們的主數據獲取結構
它還有一個狀態

00:04:33.974 --> 00:04:36.977
當用戶在繪畫時它是活動的
是完成

00:04:37.044 --> 00:04:39.246
當用戶完成時
可以是取消

00:04:39.313 --> 00:04:42.783
如果另一個用戶操作造成它被取消

00:04:42.850 --> 00:04:45.419
所以我們可以拋棄它而不是保留它

00:04:47.554 --> 00:04:49.857
最後我們把這些放入一個筆畫集合

00:04:49.923 --> 00:04:54.728
它是一個筆畫數組
我們會添加完成的筆畫

00:04:54.795 --> 00:04:57.297
要使它成爲我們的應用的
一個完整的數據模型

00:04:57.364 --> 00:05:00.300
我們要把活動筆畫做爲一個可選項

00:05:00.367 --> 00:05:04.938
這樣我們可以用這個筆畫集合作爲
一個完整應用的數據模型

00:05:05.973 --> 00:05:08.642
下一個問題是在哪獲取那些筆畫

00:05:09.576 --> 00:05:12.346
基本上你有3個地方可以這麼做

00:05:12.412 --> 00:05:15.249
第一個是UIGestureRecognizer

00:05:15.315 --> 00:05:17.885
一個定製的UIGestureRecognizer
子類

00:05:18.986 --> 00:05:23.156
下一個要尋找的地方
是一個UIView子類

00:05:24.057 --> 00:05:26.226
觸摸到達這裏

00:05:26.293 --> 00:05:31.164
你可以順着響應器鏈向上處理
我想

00:05:31.231 --> 00:05:33.133
我想你想想這個的順序

00:05:33.200 --> 00:05:37.604
若你可以用一個定製子類
或UIGestureRecognizer來做

00:05:38.205 --> 00:05:43.110
第二用UIView並儘可能接近你
能得到事件的地方

00:05:43.177 --> 00:05:46.146
最後纔不得不沿着響應器鏈向上

00:05:48.749 --> 00:05:50.117
這就是我們要做的

00:05:50.684 --> 00:05:54.188
我們創建一個子類獨有的
筆畫手勢識別器

00:05:54.888 --> 00:05:56.957
我們會把我們的主視圖控制器作爲
目標

00:05:58.892 --> 00:06:00.394
然後在行動方法中

00:06:00.460 --> 00:06:04.031
我們會用筆畫觸發一個視圖重繪

00:06:05.899 --> 00:06:08.535
讓我們開始創建這個手勢識別器子類

00:06:08.602 --> 00:06:12.906
要做的第一件事是導入
UIGestureRecognizer子類

00:06:13.273 --> 00:06:16.810
這向你暴露
UIGestureRecognizer的內部

00:06:16.877 --> 00:06:18.846
這樣你可以創建子類

00:06:19.246 --> 00:06:22.549
但要小心
不要使用這些內部

00:06:22.616 --> 00:06:24.952
在UIGestureRecognizer以外

00:06:25.018 --> 00:06:29.656
比如狀態設置器被暴露
如果你導入它

00:06:29.723 --> 00:06:32.726
你不應該在子類以外使用它

00:06:32.793 --> 00:06:39.466
否則手勢系統會工作異常
你會有許多問題需要調試

00:06:41.134 --> 00:06:43.504
讓我們添加我們的筆畫做爲
主數據結構

00:06:43.570 --> 00:06:46.173
在我們的手勢識別器中獲得筆畫

00:06:46.573 --> 00:06:48.475
並實現觸摸處理方法

00:06:49.376 --> 00:06:54.848
因爲我們做很多相似的事情
在總計4個觸摸處理方法中

00:06:54.915 --> 00:06:59.920
我們會有一個輔助方法實際上
查看這一系列UITouch

00:07:00.220 --> 00:07:03.991
決定我們是否對觸摸的其中之一
感興趣

00:07:04.725 --> 00:07:07.895
把它加入我們的數據模型
就是複製它的位置

00:07:07.961 --> 00:07:11.265
在此時作爲一個取樣
並返回給我們

00:07:11.331 --> 00:07:12.866
如果你對此感興趣

00:07:13.433 --> 00:07:16.770
我們會在這個觸摸開始
函數中使用輔助方法

00:07:16.837 --> 00:07:18.872
並把狀態設置成開始

00:07:19.406 --> 00:07:22.142
對UIGestureRecognizer
這是反常的

00:07:22.209 --> 00:07:26.680
因爲在狀態可能和狀態開始之間
的時間

00:07:26.747 --> 00:07:32.252
是不同的手勢識別器發生競爭的時間
處理這些觸摸序列

00:07:32.686 --> 00:07:36.190
但是對我們的筆畫
我們很想它馬上開始

00:07:36.256 --> 00:07:37.457
當觸摸向下傳遞時

00:07:37.524 --> 00:07:39.760
所以這是我們要做的

00:07:41.261 --> 00:07:44.831
在touchesMoved中
我們做相同的事並把狀態切換成已改變

00:07:44.898 --> 00:07:46.466
注意在手勢識別器中

00:07:46.533 --> 00:07:50.370
每個狀態改變觸發一個行動方法
即使是相同的

00:07:51.538 --> 00:07:54.308
我們對觸摸結束和取消做相同的事

00:07:56.109 --> 00:08:02.149
最後我們重置手勢識別器
用一個新的筆畫取代之前那個

00:08:02.216 --> 00:08:03.851
這樣我們能獲取下一個

00:08:04.551 --> 00:08:06.987
做爲好公民
我們總是調用super.reset

00:08:10.090 --> 00:08:12.492
讓我們在視圖控制器中使用它

00:08:14.361 --> 00:08:18.031
在viewDidLoad函數中
我們設置筆畫手勢識別器

00:08:18.098 --> 00:08:22.336
把我們自己做爲目標
動作是筆畫更新了

00:08:22.402 --> 00:08:24.638
然後把它加到主視圖

00:08:26.740 --> 00:08:29.776
在更新回調中
我們從手勢中獲得筆畫

00:08:29.843 --> 00:08:32.446
然後設置到我們的視圖中

00:08:32.513 --> 00:08:33.914
現在就做這些

00:08:34.815 --> 00:08:36.950
我告訴過你筆畫集合

00:08:37.017 --> 00:08:40.287
只是提一下
我想要保持它簡單

00:08:41.455 --> 00:08:43.991
所以讓我們看看它給我們什麼

00:08:45.692 --> 00:08:48.929
我總是喜歡這一刻
一些東西第一次運行

00:08:50.564 --> 00:08:56.136
你看到的是
這是Pencil在屏幕上的位置

00:09:00.374 --> 00:09:01.441
讓我們看一看

00:09:04.144 --> 00:09:06.480
這看起來不好

00:09:07.848 --> 00:09:08.849
發生了什麼？

00:09:09.316 --> 00:09:11.118
讓我們仔細看看慢動作

00:09:17.057 --> 00:09:18.759
這完全不是我們想要的

00:09:18.825 --> 00:09:20.794
我們看到了什麼？

00:09:20.861 --> 00:09:22.696
我們有Pencil的位置

00:09:23.297 --> 00:09:26.967
我們和最後畫的那條線之間有
非常非常大的距離

00:09:28.735 --> 00:09:31.371
我們畫的線很長而且不斷改變方向

00:09:31.438 --> 00:09:33.507
這不是我期待的

00:09:33.574 --> 00:09:36.043
我們有很好的時間分辨率

00:09:36.109 --> 00:09:37.611
爲什麼它看起來是這樣？

00:09:38.512 --> 00:09:40.480
顯然我們錯過了一些事件

00:09:41.014 --> 00:09:43.550
因爲多個原因我們錯過了一些事件

00:09:43.617 --> 00:09:46.687
其中之一是我們的繪製引擎的
實現很幼稚

00:09:47.020 --> 00:09:50.724
它每次都繪製一個完整位圖
以及每次有事件進入時

00:09:50.791 --> 00:09:55.529
它的速度不足以跟上顯示率

00:09:56.129 --> 00:09:58.131
我們會晚點談到這方面

00:09:58.498 --> 00:10:02.769
最重要的是我們沒有用iOS 9的
新API

00:10:02.836 --> 00:10:05.606
我們應該這麼做來獲得我們錯過
的事件

00:10:05.939 --> 00:10:09.176
因此我想再仔細地看看筆畫

00:10:10.677 --> 00:10:11.979
讓我們再看一次

00:10:12.913 --> 00:10:15.983
這裏的所有取樣我們都想有
並且看到

00:10:17.985 --> 00:10:22.523
在我們的觸摸處理方法中
我們永遠都得到開始

00:10:23.156 --> 00:10:28.829
和結束 但是在中間
我們得到touchesMoved

00:10:31.365 --> 00:10:35.402
我們沒有得到所有的作爲取樣進來
的touchesMoved

00:10:36.270 --> 00:10:37.671
這是有原因的

00:10:37.738 --> 00:10:40.974
如果我們發給你
所有的touchesMoved

00:10:41.041 --> 00:10:43.010
即使你阻塞主線程

00:10:43.310 --> 00:10:45.579
你會看到一些東西類似於重播

00:10:45.646 --> 00:10:48.215
觸摸互動的重播
如果你是進行實時互動

00:10:48.515 --> 00:10:50.050
這完全不是你想要的

00:10:50.117 --> 00:10:52.553
你想要發送給你的最新位置

00:10:52.953 --> 00:10:54.488
那是我們通常做的

00:10:54.555 --> 00:10:56.823
那是我們在OS 9之前做在

00:10:56.890 --> 00:10:58.625
實際上我們拋棄了其他事件

00:10:58.692 --> 00:11:02.462
如果你在主循環中不夠快

00:11:02.763 --> 00:11:06.466
那麼你看不到它們中的任何一個
但是從iOS 9開始

00:11:06.533 --> 00:11:09.102
我們使你能訪問以前的事件

00:11:09.703 --> 00:11:14.641
另一個原因是我們的數字轉換器
現在比顯示更快

00:11:16.109 --> 00:11:21.481
我們不想在我們有的每個數據點
都給你一個事件

00:11:21.982 --> 00:11:23.951
你會進行太多工作

00:11:24.017 --> 00:11:26.186
所以我們試着把它們合併在一起

00:11:26.620 --> 00:11:30.157
每次屏幕刷新發送一個

00:11:33.527 --> 00:11:38.866
你現在能做的是使用你從API
獲得的實時觸摸

00:11:39.233 --> 00:11:41.935
查詢錯過的觸摸

00:11:42.236 --> 00:11:44.605
這將包括你當前查詢的觸摸

00:11:44.671 --> 00:11:46.874
這樣你就有個完整一致的圖像

00:11:47.241 --> 00:11:49.676
這些觸摸被稱爲合併觸摸

00:11:50.244 --> 00:11:52.546
你爲所有的觸摸事件做這件事

00:11:55.549 --> 00:11:58.252
也爲開始和結束這麼做

00:11:58.952 --> 00:12:00.954
因爲你要待在相同的地方

00:12:01.021 --> 00:12:04.892
或者處理你的實時觸摸
或者合併觸摸

00:12:05.325 --> 00:12:08.462
因爲視圖裏有方法比如之前位置

00:12:08.529 --> 00:12:11.632
是之前觸摸的引用
如果你混合搭配

00:12:11.698 --> 00:12:13.267
那你會遇到問題

00:12:14.434 --> 00:12:18.172
現在我們知道怎麼獲得它們
讓我們在代碼中這麼做

00:12:20.641 --> 00:12:23.477
這個方法是coalescedTouches
爲了觸摸UIEvent

00:12:23.544 --> 00:12:25.946
你在觸摸處理回調函數中獲得事件

00:12:27.514 --> 00:12:34.288
這個結果可選不是因爲我們會給
你無值

00:12:35.155 --> 00:12:38.392
任何時候如果你只有一個觸摸
而且我們沒有合併觸摸

00:12:38.725 --> 00:12:43.230
這是因爲你可以要求任何
不是事件一部分的UI測試

00:12:43.297 --> 00:12:44.498
那麼你會得到無值

00:12:44.565 --> 00:12:46.934
你一定會得到UITouch

00:12:47.000 --> 00:12:50.070
至少你放入的一個
即使我們沒有合併更多

00:12:50.470 --> 00:12:54.308
所以你不需要在這用一個if語句

00:12:55.442 --> 00:12:57.277
讓我們把這些用在代碼中

00:12:58.912 --> 00:13:01.448
在我們的代碼中 看看感興趣的觸摸

00:13:01.515 --> 00:13:04.484
我們進行了觸摸追加
我們需要做的是循環

00:13:04.551 --> 00:13:07.554
在合併觸摸中並且追加那些

00:13:08.021 --> 00:13:09.423
這給你所有數據

00:13:10.490 --> 00:13:12.392
讓我們看看它看起來是怎樣的

00:13:15.062 --> 00:13:17.598
很好 現在我們真的有所有數據了

00:13:18.432 --> 00:13:20.300
讓我們比較一下

00:13:24.571 --> 00:13:27.808
在有一個停止的慢動作中

00:13:30.777 --> 00:13:32.012
你在這看到什麼

00:13:32.079 --> 00:13:35.649
這是Pencil現在玻璃上的位置

00:13:36.884 --> 00:13:40.954
灰色的是合併觸摸

00:13:41.021 --> 00:13:43.557
現在調試繪製引擎

00:13:44.157 --> 00:13:48.262
黑色的也是合併觸摸
但是對應那些實時觸摸

00:13:49.630 --> 00:13:52.900
你還可以看到有太多合併觸摸

00:13:53.467 --> 00:13:56.904
如果我們的數字轉換器是以四倍
於顯示的速度運行 你看到

00:13:56.970 --> 00:14:01.074
我們應該看到黑色之間平均應該
有三個灰色

00:14:01.508 --> 00:14:02.709
這太多了

00:14:04.111 --> 00:14:06.480
我們在末尾的間隙也很大

00:14:06.547 --> 00:14:10.617
這引起延遲
用戶可見的延遲

00:14:12.452 --> 00:14:13.353
我們看到什麼？

00:14:13.787 --> 00:14:15.589
我們繪製引擎的速度還是落後了

00:14:15.656 --> 00:14:17.357
我們目前還沒有解決它

00:14:18.292 --> 00:14:20.627
但是UIKit通過合併觸摸幫助我們

00:14:20.694 --> 00:14:24.264
最後的繪製有它需要的所有數據

00:14:24.698 --> 00:14:27.968
所以如果你只獲取這一類中的
一件事

00:14:28.035 --> 00:14:30.037
那麼用合併觸摸
如果你真的想

00:14:30.103 --> 00:14:32.606
獲得你Pencil的豐富數據

00:14:37.311 --> 00:14:39.546
那繪製的問題出在哪？

00:14:39.613 --> 00:14:41.615
你不應該在每個觸摸事件上繪製

00:14:42.015 --> 00:14:44.384
因爲顯示刷新率只有60赫茲

00:14:44.751 --> 00:14:48.689
儘管我們試着每幀只傳遞一個事件

00:14:49.189 --> 00:14:51.425
你可以知道
有時候是不可能的

00:14:51.491 --> 00:14:54.494
因爲如果你把手指和Pencil混合

00:14:54.561 --> 00:14:58.398
或者有其他事件傳入
我們需要按順序發送它們

00:14:58.465 --> 00:15:04.238
因此你需要準備好
獲得比顯示刷新率多的事件

00:15:05.138 --> 00:15:06.907
但是不要試着繪製更快

00:15:06.974 --> 00:15:11.245
因爲這隻會影響性能並增加延遲

00:15:11.311 --> 00:15:14.681
做一些甚至不會顯示在屏幕上的工作

00:15:15.315 --> 00:15:16.483
那你應該何時渲染？

00:15:16.550 --> 00:15:20.087
在我們的例子中我們使用
一個普通的UIView和核心圖像

00:15:20.654 --> 00:15:24.324
在這個情況下你應該在那個視圖中
使用需要顯示

00:15:24.858 --> 00:15:28.195
來標記那個視圖需要更新並把工作
交給CA

00:15:28.262 --> 00:15:33.400
來調用你需要實現的繪製方法
而不是你定製的位圖繪製

00:15:34.401 --> 00:15:37.504
如果你在用一個GLKView
或MetalView

00:15:38.205 --> 00:15:42.476
你還可以選擇這些行爲而不是
一個不變的更新

00:15:42.910 --> 00:15:46.346
通過把enableSetsNeedsDisplay
屬性設置爲真

00:15:46.947 --> 00:15:50.784
這樣如果你想要的話
那些視圖的行爲是一樣的

00:15:51.718 --> 00:15:53.687
如果你想用固定的速度繪製

00:15:53.754 --> 00:15:57.457
然後請用固定的速度繪製
不要根據進入的事件

00:15:57.524 --> 00:16:02.529
你可以用Metal和GLViews
的內部機制這麼做

00:16:02.596 --> 00:16:05.432
或者你可以用
CADisplayLink這麼做

00:16:05.499 --> 00:16:08.202
在你的DisplayLink
喚醒時 調用顯示

00:16:08.602 --> 00:16:12.172
我們所做的是在我們的
StrokesCGView中

00:16:12.239 --> 00:16:16.109
一個在筆畫上的didSet函數
用drawImageAndUpdate函數繪製

00:16:16.343 --> 00:16:18.512
這創建位圖
這並不好

00:16:18.846 --> 00:16:21.248
讓我們用
setsNeedsDisplay

00:16:22.916 --> 00:16:25.552
並且把繪製代碼移動到繪製方法中

00:16:26.320 --> 00:16:29.189
如果你使用一個普通的UFU
你可以做得更好

00:16:29.489 --> 00:16:33.360
你可以只標記改變了的區域
用setNeedsDisplayIn(rect)

00:16:34.094 --> 00:16:38.232
這也需要一些觸摸的檔案管理

00:16:38.298 --> 00:16:42.703
因爲你的繪製可能稍微大於
改變了的觸摸

00:16:42.769 --> 00:16:45.339
和採樣中的觸摸改變

00:16:45.739 --> 00:16:48.575
你可以看一個示例代碼來得到一個
例子

00:16:48.642 --> 00:16:51.011
關於你如何進行這類檔案管理

00:16:52.713 --> 00:16:56.149
更進一步 你可以在這一層上
激活drawsAsynchronously

00:16:57.050 --> 00:17:03.090
這把所有你在繪製矩形裏所做
的繪製向上傳遞到CG和CA

00:17:03.156 --> 00:17:05.992
CA在主線程外繪製它

00:17:06.126 --> 00:17:09.128
使你的主線程能更快進行事件處理

00:17:09.663 --> 00:17:13.767
要這麼做你只需要簡單地設置
drawsAsynchronously爲真

00:17:13.834 --> 00:17:15.301
在你的擴散層上

00:17:16.537 --> 00:17:18.172
讓我們看看這帶我們進行了多遠

00:17:25.412 --> 00:17:26.512
再一次在慢動作中

00:17:32.920 --> 00:17:36.423
現在我們有我說過的穩定的
合併觸摸數量

00:17:36.490 --> 00:17:39.293
大約3個合併觸摸和1個黑色的

00:17:40.861 --> 00:17:42.429
但我們還是有些延遲

00:17:42.496 --> 00:17:47.634
但是它小多了因爲我們按顯示的
速度進行繪製

00:17:47.868 --> 00:17:51.538
我們只有剩餘的延遲

00:17:51.905 --> 00:17:53.307
我們怎麼改進它？

00:17:53.874 --> 00:17:58.478
從iOS 9起我們有一個功能叫做
預測觸摸

00:17:58.812 --> 00:18:02.282
預測觸摸讓你瞥見未來

00:18:02.349 --> 00:18:06.820
和合並觸摸的使用方法相同
你詢問事件

00:18:06.887 --> 00:18:09.056
觸摸的預測觸摸

00:18:09.122 --> 00:18:13.760
你得到未來的一個觸摸數組

00:18:15.896 --> 00:18:17.464
你對這些觸摸做什麼？

00:18:17.531 --> 00:18:20.300
你臨時把它們加入你的數據結構

00:18:20.367 --> 00:18:22.269
他們在每個事件回調中改變

00:18:22.536 --> 00:18:25.038
所以你必須臨時加入它們

00:18:25.906 --> 00:18:28.041
你根據你的應用選擇它們的外觀

00:18:28.842 --> 00:18:33.914
我強烈推薦你使它們看起來像
真正的觸摸

00:18:34.882 --> 00:18:36.250
看看結果

00:18:36.750 --> 00:18:41.922
除非我們的預測偏差太多
那麼降低它

00:18:41.989 --> 00:18:46.994
使它看起來像暫定的
使它仍然看起來接近Pencil

00:18:49.563 --> 00:18:51.365
讓我們看看代碼

00:18:52.199 --> 00:18:55.736
現在在我們的觸摸設置方法
當你添加合併觸摸之後

00:18:58.138 --> 00:19:01.642
你臨時添加預測觸摸

00:19:02.075 --> 00:19:06.180
你需要確保刪除之前添加的臨時觸摸

00:19:07.347 --> 00:19:09.516
我會給你看一個視頻
看看它看起來怎樣

00:19:09.583 --> 00:19:11.351
和你應該做的對比

00:19:11.418 --> 00:19:15.422
我會用紅色高亮預測觸摸這樣我們
可以看到

00:19:15.489 --> 00:19:18.458
如果它對我們的例子足夠好

00:19:21.094 --> 00:19:23.730
再次在慢動作中
因爲這很快

00:19:29.903 --> 00:19:34.608
這些是預測觸摸
它使你更接近實際的Pencil位置

00:19:35.175 --> 00:19:39.947
這非常非常有助於屏幕上可見的
延遲

00:19:40.180 --> 00:19:43.817
你可以在這個例子中看到
這工作得很好

00:19:43.884 --> 00:19:45.118
所以我們會使用它們

00:19:45.185 --> 00:19:47.888
用我們繪製普通觸摸一樣的方式
繪製它們

00:19:49.456 --> 00:19:50.757
目前爲止我們看到什麼？

00:19:51.158 --> 00:19:55.295
我們看到了如何收集輸入
使用定製的UIGestureRecognizer

00:19:56.163 --> 00:19:58.265
如何訪問合併觸摸

00:20:00.400 --> 00:20:02.903
如何使渲染更快並有效率

00:20:03.971 --> 00:20:06.340
最後 如何使用預測觸摸

00:20:06.406 --> 00:20:10.677
所有的這些技術工作在所有iOS
設備上

00:20:10.744 --> 00:20:15.349
我們在例子中針對Pencil使用它們
但它們基本在其它設備也都運作

00:20:15.682 --> 00:20:20.888
現在讓我們看看
新Apple Pencil API

00:20:22.389 --> 00:20:24.324
讓我們從觸摸類型開始

00:20:24.791 --> 00:20:29.830
有了Apple Pencil
UITouch添加了新類型的方法

00:20:30.163 --> 00:20:33.834
UITouch類型
可以是三個值中的一個

00:20:34.268 --> 00:20:38.338
可以是直接
是你知道的以前的所有觸摸

00:20:39.673 --> 00:20:43.443
有隻針對Siri Remote
的間接觸摸

00:20:44.211 --> 00:20:47.214
還有針對Apple Pencil
的尖筆

00:20:50.918 --> 00:20:54.855
你用Apple Pencil可獲得的
第一個東西是更高的精度

00:20:54.922 --> 00:20:58.091
你在視圖中用精確位置

00:20:58.892 --> 00:21:01.695
你還在視圖中有精確的以前的位置

00:21:02.362 --> 00:21:05.132
無論何時你想要精確位置時你
應該用那些

00:21:05.199 --> 00:21:06.667
針對像是繪畫的一些事

00:21:06.733 --> 00:21:08.235
如果你想進行點擊測試

00:21:08.302 --> 00:21:12.973
你還是應該用以前的
叫做位置在

00:21:13.040 --> 00:21:14.741
和以前的位置在

00:21:15.142 --> 00:21:17.311
但是對繪畫 這會帶來不同

00:21:17.644 --> 00:21:19.079
沒有精確位置

00:21:19.146 --> 00:21:22.649
你會在你的繪畫中加入一些樓梯狀
的圖案

00:21:22.716 --> 00:21:23.984
這是你不想看到的

00:21:24.551 --> 00:21:27.588
你可以向所有的觸摸要求精確位置

00:21:27.654 --> 00:21:29.556
你將只獲得普通的

00:21:31.325 --> 00:21:33.293
接下來有力量

00:21:33.360 --> 00:21:38.432
力量做爲一個叫作力量的屬性暴露
還有一個最大可能力量

00:21:38.765 --> 00:21:40.100
它們是CGFloat類型

00:21:40.868 --> 00:21:44.238
它們的範圍是0到最大可能力量

00:21:44.605 --> 00:21:47.541
1.0表示平均的觸摸

00:21:47.608 --> 00:21:50.244
所以它們不是物理值

00:21:50.310 --> 00:21:53.780
所以你不應該做任何和實際的
力量有關的事

00:21:53.847 --> 00:21:59.152
但是你用這些值來影響你的繪畫

00:22:00.988 --> 00:22:06.894
在所有之前的設備和普通手指觸摸
它會永遠返回0

00:22:09.763 --> 00:22:10.998
關於力量的快速說明

00:22:11.064 --> 00:22:13.767
因爲我們把力量加入了UITouch

00:22:13.834 --> 00:22:16.003
在觸摸處理中有一個不同

00:22:16.069 --> 00:22:19.306
touchesMoved
被更多地調用

00:22:19.373 --> 00:22:23.310
因爲你想要能夠區分力量是否變化了

00:22:24.011 --> 00:22:26.680
我們現在會一直髮送
touchesMoved給你

00:22:26.747 --> 00:22:31.485
以前我們努力嘗試只發送
touchesMoved給你

00:22:31.552 --> 00:22:33.554
當位置改變時

00:22:35.055 --> 00:22:38.125
那是通過普通位置
甚至不是精確位置

00:22:38.926 --> 00:22:40.894
這給了你一些暗示

00:22:41.395 --> 00:22:44.231
比如你在野外看到很多這種

00:22:44.298 --> 00:22:46.400
若你在touchesMoved中
做了

00:22:46.466 --> 00:22:51.638
如果你有意取消一個點擊
這不好

00:22:51.705 --> 00:22:53.240
這不再工作

00:22:53.907 --> 00:22:59.012
你看到在iPhone 6s上
或者用Pencil

00:22:59.079 --> 00:23:02.883
如果你不得不非常非常輕地觸摸屏幕

00:23:02.950 --> 00:23:04.685
這是你會遇到的

00:23:04.751 --> 00:23:07.187
你需要看看你的觸摸處理代碼

00:23:07.487 --> 00:23:08.522
你應該怎麼做？

00:23:08.989 --> 00:23:11.725
如果可以你應該使用
UITouchGesturesRecognizer

00:23:11.792 --> 00:23:14.628
因爲它封裝了我們的所有知識

00:23:14.695 --> 00:23:19.733
至少你需要做的事
是記得觸摸開始的位置

00:23:19.800 --> 00:23:24.104
只取消它

00:23:24.171 --> 00:23:25.606
當你從開始位置移動了足夠遠時

00:23:27.307 --> 00:23:30.744
讓我們把力量加入模型
到我們的筆畫取樣中

00:23:31.078 --> 00:23:34.615
我們用一個可選的力量變量這麼做

00:23:35.682 --> 00:23:41.555
我們晚點會添加其他東西
我不會再顯示這個幻燈片

00:23:41.622 --> 00:23:45.826
所以讓我們看看力量在我們的繪製
中是什麼樣的

00:23:47.995 --> 00:23:49.630
很好 我們做了什麼？

00:23:50.063 --> 00:23:53.166
我們改變了力量的寬度空間

00:23:55.068 --> 00:23:57.204
下一個是傾斜

00:23:58.005 --> 00:24:01.542
Apple Pencil使你能利用
它和設備之間的傾斜

00:24:01.842 --> 00:24:04.211
這是用角度來測量的

00:24:04.278 --> 00:24:08.515
在Pencil和設備之間
我們調用高度

00:24:09.583 --> 00:24:12.653
這個高度角度作爲
altitudeAngle暴露

00:24:13.053 --> 00:24:14.421
是一個CGFloat

00:24:15.422 --> 00:24:20.994
它報告一個角度的弧度
在大概10度到90度之間的範圍

00:24:25.098 --> 00:24:27.568
第二個部分是方向

00:24:27.634 --> 00:24:32.039
方向是針對設備平面測量的

00:24:32.673 --> 00:24:39.146
測量正的x方向
和Pencil來自的方向之間

00:24:40.981 --> 00:24:42.683
這叫做方位角

00:24:44.251 --> 00:24:47.921
方位角和傾斜一起構成Pencil
的完整位置

00:24:47.988 --> 00:24:51.925
你用它來繪畫時可以驅動你的UI或者
數據點

00:24:52.726 --> 00:24:56.163
所以方位角依賴你的設備方向

00:24:56.230 --> 00:25:00.133
你需要在視圖中調用一個方法叫
azimuthAngle

00:25:00.501 --> 00:25:03.904
大部分時候你可能想用一個矢量

00:25:04.137 --> 00:25:07.341
所以我們在視圖中向你暴露方位角
單位矢量

00:25:07.407 --> 00:25:10.944
這個矢量會指向Pencil
來自的方向

00:25:11.278 --> 00:25:12.579
它的大小是1

00:25:15.682 --> 00:25:16.917
下一個 力量

00:25:17.484 --> 00:25:22.322
Pencil力量和
3D Touch力量的行爲有些不同

00:25:22.956 --> 00:25:27.327
力量是沿着Pencil的軸測量的

00:25:27.828 --> 00:25:30.364
3D Touch的力量
是在屏幕上測量的

00:25:30.430 --> 00:25:32.566
和設備平面垂直

00:25:33.133 --> 00:25:37.237
這造成一些不同
我催促你們試一試

00:25:37.404 --> 00:25:43.076
如果你們想要得到實際力量
所有你的繪畫工具的垂直力量

00:25:43.143 --> 00:25:45.245
因爲它們真的感覺不同

00:25:45.712 --> 00:25:48.415
幸運的是計算這個分量很容易

00:25:49.216 --> 00:25:50.651
這是這麼做的代碼

00:25:51.451 --> 00:25:54.922
你可以獲得垂直力量
通過力量除以

00:25:54.988 --> 00:25:57.191
高度角度的正弦

00:25:57.257 --> 00:25:59.259
要確保你保持在同樣的範圍內

00:25:59.326 --> 00:26:02.362
你應該取它和最大可能力量的
最小值

00:26:04.531 --> 00:26:08.836
最後一個關於
Apple Pencil力量的消息

00:26:08.902 --> 00:26:10.637
它是在Pencil內測量的

00:26:11.772 --> 00:26:14.274
然後無線傳輸給iPad

00:26:15.008 --> 00:26:17.911
這是通過無線傳輸的所有屬性

00:26:17.978 --> 00:26:22.950
這表明需要花一點時間
而且數據有可能丟失

00:26:23.483 --> 00:26:27.321
所以爲了不讓你等待
對無線傳輸的力量

00:26:27.387 --> 00:26:30.457
我們決定首先給你估計的屬性

00:26:31.225 --> 00:26:35.662
並稍後更新它們
這樣你能有最好的體驗

00:26:37.497 --> 00:26:40.968
爲此我們在UITouch上暴露了
估計屬性

00:26:41.401 --> 00:26:43.704
它的類型是
UITouchProperties

00:26:44.438 --> 00:26:46.807
所以估計屬性

00:26:49.643 --> 00:26:51.311
可以有一個力量值

00:26:51.378 --> 00:26:55.582
對你得到的第一個
Apple Pencil事件總爲真

00:26:57.851 --> 00:27:03.724
但是方位角和高度也可以被標記
爲估計的

00:27:04.124 --> 00:27:06.193
這發生在你從邊上進入

00:27:06.260 --> 00:27:11.498
我們不是百分之百確定值是什麼
或者你在離你手指很近的地方繪畫

00:27:11.565 --> 00:27:15.435
因爲我們的傳感器不能非常精確
地偵測它們

00:27:15.736 --> 00:27:18.939
我們告訴你它們是估計的
這樣你可以做一些事

00:27:19.006 --> 00:27:21.275
比如當從邊上進入時

00:27:21.341 --> 00:27:24.378
你可以在得到第一個確定的值
後回頭填充它們

00:27:24.444 --> 00:27:27.147
在我給你的例子中

00:27:27.214 --> 00:27:31.552
我那麼做來闡明那點

00:27:32.286 --> 00:27:37.057
還有位置
只對預測觸摸是估計屬性

00:27:37.124 --> 00:27:40.894
它給你一個簡單的方法區分預測觸摸
和普通的觸摸

00:27:43.630 --> 00:27:47.634
關於更新
我們也有估計屬性

00:27:47.701 --> 00:27:49.236
期待更新

00:27:50.137 --> 00:27:53.874
它的類型也是UITouchProperties
現在只有力量

00:27:53.941 --> 00:27:56.777
也許以後會有方位角和高度

00:27:56.844 --> 00:28:00.647
但是現在只有力量值
如果方位角和高度被設置

00:28:01.048 --> 00:28:03.150
我們會在未來向你發送更新

00:28:03.851 --> 00:28:08.789
我們還會在叫做觸摸估計屬性更新
的新響應器中這麼做

00:28:09.356 --> 00:28:10.757
我們還會在事後這麼做

00:28:10.824 --> 00:28:13.460
所以我們會在觸摸開始時發送
觸摸給你

00:28:13.527 --> 00:28:15.495
並在稍後發送更新

00:28:16.897 --> 00:28:18.298
讓我們看看這些

00:28:18.966 --> 00:28:20.133
所以你要怎麼做？

00:28:20.200 --> 00:28:21.969
當觸摸開始或移動時

00:28:22.035 --> 00:28:25.973
你在觸摸上檢查estimatedProperties-
ExpectedUpdates

00:28:26.240 --> 00:28:27.941
如果它不爲空

00:28:29.209 --> 00:28:33.347
你在UITouch使用
estimationUpdateIndex

00:28:33.413 --> 00:28:36.216
它是一個索引號 只針對觸摸被設置

00:28:36.283 --> 00:28:39.820
期待一個更新或表示一個更新

00:28:40.220 --> 00:28:43.423
並用它儲存你想更新的東西

00:28:43.490 --> 00:28:47.628
你當前的觸摸取樣在一個字典裏
你可以晚點查詢它

00:28:48.695 --> 00:28:50.597
在touchesEstimated-
PropertiesUpdated中

00:28:50.664 --> 00:28:52.999
然後你查詢你的取樣

00:28:53.667 --> 00:28:55.869
使用觸摸的估計更新

00:28:55.936 --> 00:29:00.174
你得到一個更新是那些期待
獲得更新的值

00:29:01.475 --> 00:29:05.279
注意 一些更新會在觸摸結束後
到達

00:29:06.180 --> 00:29:08.182
這是一個關於生命週期的事
你需要注意到

00:29:08.248 --> 00:29:12.553
如果你不在觸摸結束後保持
數據結構

00:29:12.619 --> 00:29:15.556
你會看到估計的力量

00:29:15.622 --> 00:29:17.858
出現在你的筆畫的末尾
它看起來會很怪

00:29:20.794 --> 00:29:22.396
讓我們看看代碼

00:29:23.730 --> 00:29:26.133
我們有touchesEstimated-
PropertiesUpdated

00:29:26.200 --> 00:29:28.602
我們遍歷觸摸

00:29:29.236 --> 00:29:32.105
我們查詢估計索引因爲我們在
這個方法中

00:29:32.172 --> 00:29:34.241
我們可以隱性地打開它

00:29:34.875 --> 00:29:37.811
我們找到我們的在取樣索引上的
取樣

00:29:37.878 --> 00:29:40.047
我們更新取樣
像我告訴過你的

00:29:40.113 --> 00:29:42.883
我們只在那個方法中更新數值

00:29:42.950 --> 00:29:45.018
我們在之前期待更新

00:29:46.954 --> 00:29:50.824
然後我們更新我們的筆畫
爲了以防未來

00:29:50.891 --> 00:29:53.794
我們還檢查這個觸摸是否還期待
更新

00:29:53.861 --> 00:29:56.697
只有它不的時候我們把它移出集合

00:29:57.197 --> 00:29:59.266
讓我們在活動中看看這

00:30:05.472 --> 00:30:07.241
我試着用方位角角度

00:30:07.708 --> 00:30:10.310
來做一個書法Pencil模擬

00:30:11.979 --> 00:30:14.848
現在我們有所有我們想要的數據

00:30:14.915 --> 00:30:17.784
讓我們看看它
沒有調試模式

00:30:21.922 --> 00:30:23.156
它看起來難道不好？

00:30:23.590 --> 00:30:27.728
我連接所有從硬件得到的點

00:30:27.794 --> 00:30:30.964
並沒有做插值或幻想的事

00:30:31.031 --> 00:30:32.799
像是你的繪製引擎會做的

00:30:37.771 --> 00:30:41.375
有了它 讓我們爲最終應用做一些
畫龍點睛的事

00:30:41.708 --> 00:30:45.512
目前爲止我們只是繪製整個屏幕

00:30:45.579 --> 00:30:48.482
我們不想被這麼限制

00:30:48.549 --> 00:30:52.052
讓我們支持任意畫布尺寸

00:30:52.119 --> 00:30:56.290
爲此 我們在一個容器視圖中包括
我們的筆畫視圖

00:30:56.356 --> 00:30:58.625
和一點陰影

00:30:58.692 --> 00:31:01.862
把它放到你的滾動視圖中
我們完成了 對嗎

00:31:03.063 --> 00:31:04.031
還沒有

00:31:04.464 --> 00:31:09.736
我們需要考慮如何處理手勢

00:31:09.803 --> 00:31:12.072
因爲滾動視圖
UIPanGestureRecognizer

00:31:12.139 --> 00:31:14.942
和我們的
StrokeGestureRecognizer衝突

00:31:15.409 --> 00:31:18.412
如果我們不做改變
我們會永遠畫筆畫

00:31:18.478 --> 00:31:19.913
我們永遠不能滾動

00:31:19.980 --> 00:31:21.215
這不是我們想要的

00:31:21.715 --> 00:31:25.385
一個方法是禁止
用Apple Pencil滾動

00:31:25.552 --> 00:31:28.121
這對註釋應用之類的會有用

00:31:28.188 --> 00:31:31.525
你總是想只用Pencil進行註釋

00:31:31.592 --> 00:31:33.627
特別地禁用那

00:31:33.694 --> 00:31:36.864
你可以那麼做因爲我們添加了
被允許的觸摸類型

00:31:36.930 --> 00:31:38.699
到UIGestureRecognizer中

00:31:38.932 --> 00:31:44.404
UITouch類型是一個觸摸類型
的NSNumber數組

00:31:44.471 --> 00:31:46.673
它默認是所有觸摸類型

00:31:47.641 --> 00:31:49.276
我們在這要做的是

00:31:49.343 --> 00:31:53.647
在這個例子中我們從滾動視圖中
得到panGestureRecognizer

00:31:54.581 --> 00:31:56.783
我們會設置允許的觸摸類型

00:31:56.850 --> 00:32:00.654
只允許直接觸摸
所以它只對手指反應

00:32:01.655 --> 00:32:05.359
我們會改變筆畫識別器只允許尖筆

00:32:06.360 --> 00:32:08.428
這顯然不是全部

00:32:08.495 --> 00:32:10.731
在代碼例子中你可以看到一個實現

00:32:10.797 --> 00:32:13.300
但是根據使用動態切換

00:32:13.367 --> 00:32:15.068
更復雜一點

00:32:15.135 --> 00:32:19.606
但是它說明一點是你可以限制你的
觸摸處理

00:32:19.673 --> 00:32:22.543
只針對Pencil或普通觸摸

00:32:26.613 --> 00:32:28.315
最後的一點注意事項

00:32:29.783 --> 00:32:32.019
UIGestureRecognizer
有一個新屬性

00:32:32.085 --> 00:32:34.755
叫做
requiresExclusiveTouchType

00:32:35.255 --> 00:32:41.094
雖然我們的手勢識別器默認針對
所有觸摸類型

00:32:42.496 --> 00:32:47.167
如果它們看到一個觸摸並開始識別
它們會堅持那個觸摸類型

00:32:47.701 --> 00:32:51.738
這樣你不會意外捏Pencil和手指

00:32:51.805 --> 00:32:55.876
這是你通常想
UIGestureRecognizer做的

00:32:55.943 --> 00:33:00.848
如果你不希望這樣 你設置
requiresExclusiveTouchType爲假

00:33:01.248 --> 00:33:04.718
這樣你可以在
手指和Pencil間識別

00:33:05.385 --> 00:33:09.556
來總結一下 我展示了所有
UITouch新屬性

00:33:10.657 --> 00:33:12.926
這樣你可以理解
Apple Pencil

00:33:13.594 --> 00:33:16.463
我展示瞭如何用合併和預測觸摸

00:33:16.530 --> 00:33:22.503
來獲得最豐富的繪畫數據
並有最少的延遲

00:33:23.670 --> 00:33:26.406
我告訴你們屬性估計
我們爲什麼這麼做

00:33:26.473 --> 00:33:31.745
你如何實際更新數據
得到Pencil提供的完整豐富數據

00:33:33.013 --> 00:33:39.686
我展示瞭如何調整手勢來只
對Pencil或手指反應

00:33:42.289 --> 00:33:45.192
這是一個已經存在的示例應用的
截圖

00:33:45.259 --> 00:33:48.829
默認使用漂亮的書法鋼筆

00:33:48.896 --> 00:33:50.864
對你來說更有趣

00:33:50.931 --> 00:33:54.601
它還有調試模式
你看到由它們組成的視頻

00:33:54.668 --> 00:33:57.504
你可以看到你的合併觸摸的行爲

00:33:57.571 --> 00:34:03.110
它們在邊界是怎麼被估計的
還看到傾斜和方位角

00:34:03.877 --> 00:34:08.148
玩一玩它來看看你的所有觸摸
處理怎麼工作

00:34:09.882 --> 00:34:13.187
這個演講的完整信息可以在這個
URL獲得

00:34:15.956 --> 00:34:19.326
昨天我們有Apple TV
控制遊戲輸入

00:34:19.393 --> 00:34:21.395
Siri Remote處理

00:34:21.628 --> 00:34:25.933
“窺視3D Touch”會向你展示
更高層的互動

00:34:25.998 --> 00:34:31.170
有了3D Touch中的力量來提供
Peek和Pop體驗

00:34:31.237 --> 00:34:35.542
要知道更多觸摸到顯示的延遲

00:34:36.009 --> 00:34:40.080
你應該看看去年的iOS上的
高級觸摸輸入

00:34:40.514 --> 00:34:42.683
就是這些了

00:34:42.748 --> 00:34:43.650
非常感謝