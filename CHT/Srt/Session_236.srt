00:00:22.823 --> 00:00:26.493
哇 大家下午好

00:00:28.362 --> 00:00:30.564
大家想要創建一個超棒的應用

00:00:30.998 --> 00:00:34.334
那麼一個很讚的佈局
將是不可或缺的一部分

00:00:34.868 --> 00:00:38.038
自動佈局功能可便於
大家創建自己的佈局

00:00:38.338 --> 00:00:42.109
針對不同的設備 定位和適配性

00:00:42.176 --> 00:00:44.111
以及針對不同語言的佈局

00:00:44.511 --> 00:00:47.414
我們今天將要探討自動佈局的新玩法

00:00:47.881 --> 00:00:50.250
本場演講共有三個部分

00:00:50.651 --> 00:00:51.885
第一部分由我爲大家講解

00:00:52.386 --> 00:00:55.389
我叫Jason Yao
是Interface Builder工程師

00:00:55.856 --> 00:00:58.258
我將告訴各位有關Interface Builder
的新特性

00:00:58.392 --> 00:01:02.496
接下來將由AppKit部門的Jesse
Donaldson 爲大家講解Cocoa的功能

00:01:02.796 --> 00:01:07.901
最後 UIKit的Marian Goldeen
將告訴諸位最新的調試技術

00:01:08.168 --> 00:01:13.173
這些工具和技術將
爲各位節省開發時間與精力

00:01:13.240 --> 00:01:16.276
當大家在工作中使用它們時
好了 我們現在開始吧

00:01:17.511 --> 00:01:19.913
首先來說說

00:01:20.347 --> 00:01:23.517
如何漸進式地運用自動佈局

00:01:24.218 --> 00:01:25.986
自動佈局的增量式運用

00:01:26.053 --> 00:01:27.221
這是什麼意思呢？

00:01:28.155 --> 00:01:31.425
在進行佈局設計時
Interface Builder裏的視圖

00:01:31.491 --> 00:01:33.560
不會立即限制所有東西

00:01:33.627 --> 00:01:37.164
大家可以逐步進行操作 以節省時間

00:01:37.464 --> 00:01:41.101
簡化各位的設置
並更具靈活性

00:01:41.568 --> 00:01:43.604
但在我向大家演示之前

00:01:44.037 --> 00:01:46.573
讓我們先來看一個背景設置的例子

00:01:47.774 --> 00:01:50.077
首先找到視圖

00:01:50.143 --> 00:01:52.446
然後拖拽到Interface
Builder畫布上

00:01:53.614 --> 00:01:56.984
然後設定它的尺寸和位置
之後進行一定編譯並運行

00:01:57.684 --> 00:02:01.989
這樣就能在設備上獲得既定尺寸的視圖

00:02:02.623 --> 00:02:06.159
然後對其進行旋轉 你會發現

00:02:07.494 --> 00:02:09.795
視圖尺寸與既定標準一致

00:02:09.863 --> 00:02:11.798
但還有一些操作要進行

00:02:12.032 --> 00:02:13.300
那麼接下來會怎樣呢？

00:02:14.668 --> 00:02:18.405
接下來 我們僅需簡單地
按照既定的寬高水平

00:02:18.472 --> 00:02:20.240
將其固定在界面頂端及左邊

00:02:20.541 --> 00:02:25.012
事實上 我們只是以隱式的方式
創建了約束條件

00:02:25.078 --> 00:02:28.916
在進行編譯時

00:02:28.982 --> 00:02:30.284
通過使用自動佈局引擎
來使視圖尺寸與既定水平一致

00:02:31.485 --> 00:02:33.954
如果各位需要進行更多的動態調整

00:02:34.454 --> 00:02:37.291
那麼各位就需要打開
Interface Builder畫布

00:02:37.591 --> 00:02:39.059
添加個性化約束條件

00:02:39.793 --> 00:02:42.663
那麼問題來了 有沒有一種更好的辦法

00:02:42.729 --> 00:02:46.466
或許可以不需要設置約束條件
就能簡單地進行尺寸調整呢？

00:02:47.367 --> 00:02:48.235
答案是肯定的

00:02:48.602 --> 00:02:53.740
Xcode 8的新功能
可在自動佈局文件上

00:02:54.141 --> 00:02:56.543
對視圖的
autoresizingMask屬性進行規定

00:02:56.610 --> 00:02:58.712
而無需設置約束條件

00:03:00.080 --> 00:03:03.350
這意味着 大家可以很簡單地
對視圖尺寸進行調整

00:03:04.184 --> 00:03:07.221
通過規定autoresizingMask屬性

00:03:07.387 --> 00:03:09.823
若在場有人還對自動佈局出現前
的時代存在記憶

00:03:09.890 --> 00:03:11.291
那您可能還認識這個UI

00:03:16.196 --> 00:03:18.165
這是Springs &amp; Struts UI

00:03:18.365 --> 00:03:20.868
大家可將視圖固定在邊緣並決定/b&gt;

00:03:20.934 --> 00:03:23.237
它的尺寸是否可調整

00:03:23.837 --> 00:03:27.641
那麼這些視圖就能
和各位的約束視圖一同進行良好的工作

00:03:28.375 --> 00:03:31.512
事實上 我們要對這些
autoresizingMask屬性進行設置

00:03:31.578 --> 00:03:33.814
並把它們轉換成約束條件

00:03:34.615 --> 00:03:37.885
但實際是在運行期間
將其轉換成約束條件

00:03:38.085 --> 00:03:39.720
這裏存在一個主要區別

00:03:39.920 --> 00:03:42.890
實際上 它們是在運行時間內
而非在建立時間內生成的

00:03:43.757 --> 00:03:48.128
因爲這樣更具靈活性 且更清晰

00:03:48.295 --> 00:03:52.366
若各位希望對視圖進行編程操作
那它能爲您帶來良好的控制

00:03:52.900 --> 00:03:56.136
因爲對於專業的自動佈局用戶

00:03:56.203 --> 00:03:57.671
可能還認識這個標誌

00:03:58.172 --> 00:03:59.873
對於視圖 我們簡單地將

00:03:59.940 --> 00:04:03.143
translatesAutoresizingMask
intoConstraints設定爲真

00:04:04.745 --> 00:04:06.180
那麼對於視圖來說

00:04:06.246 --> 00:04:08.949
若在Interface Builder
內添加了約束條件 它會怎樣呢？

00:04:09.550 --> 00:04:11.251
答案是 沒有變化

00:04:11.552 --> 00:04:14.955
各位僅需點擊一下視圖
就能獲得所有影響該視圖的約束條件

00:04:15.622 --> 00:04:19.959
AutoresizingMask
即可被忽略

00:04:21.461 --> 00:04:24.631
並且這些視圖的translates
AutoresizingMask 屬性都將變成假

00:04:26.066 --> 00:04:29.503
那麼將它們和最初的問題放到一起

00:04:29.837 --> 00:04:32.072
這樣 我們就能逐步地使用自動佈局了

00:04:32.472 --> 00:04:36.844
首先通過autoresizingMasks
對視圖尺寸進行簡單的調試

00:04:36.977 --> 00:04:40.047
然後添加相應約束條件
以進行更爲複雜的操作

00:04:41.148 --> 00:04:43.684
這會給大家帶來更好的靈活性

00:04:44.017 --> 00:04:45.819
當各位準備好添加約束條件時

00:04:46.653 --> 00:04:49.489
選擇你想要添加約束條件的子樹目錄

00:04:49.556 --> 00:04:52.125
先從父級開始
然後再按各自的方式進行

00:04:54.194 --> 00:04:58.031
這樣可按照各位的意願來
進行自動佈局操作

00:04:58.298 --> 00:05:00.934
並且有益於大家準備構建的新佈局

00:05:01.235 --> 00:05:03.770
方便大家進行尺寸調整

00:05:03.837 --> 00:05:08.041
且對於各位一直想進行佈局的文件而言
也是很棒的

00:05:08.509 --> 00:05:11.278
並且 你還可以在保留
現有行爲的情況下進行該操作

00:05:13.447 --> 00:05:15.382
我來給大家演示一下這個操作

00:05:15.983 --> 00:05:18.252
那麼 讓我們來看看
它究竟是什麼玩意兒

00:05:29.296 --> 00:05:32.065
我已用Interface Builder
打開了Xcode 8

00:05:32.132 --> 00:05:33.634
我要創建一個關於天氣的應用

00:05:34.668 --> 00:05:38.138
我找到了我的視圖
並已經拖拽到了視圖控制器

00:05:38.205 --> 00:05:40.841
它適用於iPad的豎屏模式

00:05:41.508 --> 00:05:44.444
我們來看看橫屏模式下它將是怎樣的

00:05:44.511 --> 00:05:47.414
在全新的設備結構配置欄內

00:05:47.614 --> 00:05:49.049
把豎屏模式更改爲橫屏模式

00:05:49.850 --> 00:05:52.085
點擊一下即可

00:05:52.219 --> 00:05:56.557
那麼 讓我們繼續 從頂部的圖標開始

00:05:56.623 --> 00:05:59.459
我們希望能將它放大 並橫跨父視圖

00:06:00.928 --> 00:06:02.396
不需要添加任何約束條件

00:06:02.963 --> 00:06:06.200
我並沒有添加約束條件
我找到尺寸查看器

00:06:06.366 --> 00:06:11.572
當然 這是AutoresizingMask查看器

00:06:11.638 --> 00:06:15.642
我說需要做的只是改變其寬度
並延展到另一邊

00:06:17.778 --> 00:06:19.413
現在 做點對小孩感興趣的事

00:06:19.479 --> 00:06:23.917
我先選中月亮
然後把它的未知屬性默認爲頂端

00:06:23.984 --> 00:06:25.586
然後我希望設置爲靠左

00:06:25.652 --> 00:06:28.188
接下來是雲朵 我把它設置爲靠右

00:06:28.956 --> 00:06:31.325
取消掉靠左的屬性

00:06:31.592 --> 00:06:34.895
接下來是標籤 我希望能按比例調整它

00:06:34.962 --> 00:06:36.663
比例精確

00:06:36.864 --> 00:06:38.565
我取消掉靠左的屬性

00:06:38.799 --> 00:06:40.300
調整它的寬度

00:06:40.367 --> 00:06:43.570
這裏有個小的動畫窗口
可讓我們對其進行預覽

00:06:43.637 --> 00:06:45.672
之後點擊上下兩端 使其固定

00:06:45.739 --> 00:06:47.407
然後同樣方法調整高度

00:06:47.975 --> 00:06:49.610
最後我們想要觀看其效果

00:06:50.444 --> 00:06:53.180
點擊橫屏模式 大功告成

00:06:53.580 --> 00:06:55.249
現在我們來試試2/3分屏模式

00:06:58.185 --> 00:07:00.254
大家看 標籤被截斷了

00:07:00.454 --> 00:07:01.522
這是怎麼回事呢？

00:07:02.089 --> 00:07:05.359
如你所見 標籤沒有是什麼問題

00:07:05.425 --> 00:07:06.793
它調用了
autoresizingMask

00:07:06.860 --> 00:07:09.763
然後根據自身的父視圖進行比例調整

00:07:10.731 --> 00:07:16.236
AutoresizingMask
不會對視圖的內容尺寸進行考慮

00:07:17.171 --> 00:07:19.339
但我可以通過約束條件來修正它

00:07:19.973 --> 00:07:23.977
不過對於這個特別的UI標籤
我還沒有別的技巧來解決它

00:07:24.278 --> 00:07:26.613
我只能通過屬性檢查器

00:07:27.014 --> 00:07:30.551
將它從固定文字尺寸
轉換爲最小文字尺寸

00:07:30.751 --> 00:07:32.586
這樣 就能完整地顯示出來

00:07:33.520 --> 00:07:37.057
於是 當我們返回全橫屏模式

00:07:37.124 --> 00:07:39.726
它也能很好地顯示出來 豎屏也一樣

00:07:40.627 --> 00:07:43.730
接下來 我們來處理一下
中間的溫度控制圖標

00:07:44.565 --> 00:07:46.934
我希望它能更精準地排列

00:07:47.000 --> 00:07:48.468
因此 我準備採用約束條件

00:07:49.102 --> 00:07:51.205
我先選中它...

00:07:51.271 --> 00:07:53.207
我想對這個75攝氏度的圖標
進行關於父視圖約束設置

00:07:53.273 --> 00:07:55.342
需要通過鍵盤操作

00:07:55.409 --> 00:07:57.845
調出關於父視圖連接

00:07:58.111 --> 00:07:59.713
即可調出約束條件菜單

00:08:00.380 --> 00:08:04.017
在該菜單內 可以通過按住shift
同時選擇多項約束條件

00:08:04.084 --> 00:08:07.321
我希望它處於水平及
垂直中心 點擊即可完成

00:08:08.121 --> 00:08:09.857
相似地 我想做同樣的調整

00:08:10.691 --> 00:08:13.193
按住Ctrl鍵拖拽到sunny圖標
按住Shift鍵

00:08:13.260 --> 00:08:17.130
我想添加Horizontally Space
及Baseline兩個約束條件

00:08:18.365 --> 00:08:19.766
然後對太陽圖標也一樣

00:08:19.833 --> 00:08:23.670
按住Ctrl鍵拖拽 按住Shift鍵
添加horizontal spacing

00:08:23.837 --> 00:08:25.372
以及center vertically兩個約束條件

00:08:27.174 --> 00:08:29.443
現在 我對視圖添加完了約束條件

00:08:29.510 --> 00:08:32.412
現在 我們僅需對框架進行更新即可

00:08:32.578 --> 00:08:35.982
現在 我們前往
“解決自動佈局問題”菜單

00:08:36.850 --> 00:08:38.919
對選中的視圖進行框架更新

00:08:40.821 --> 00:08:43.390
接下來
我想將溫度控制圖標再變大一點

00:08:43.957 --> 00:08:47.194
首先選中它 然後增加它的字體尺寸

00:08:47.261 --> 00:08:50.230
各位可能會注意到
當我在增加字體尺寸的時候/b&gt;

00:08:50.964 --> 00:08:52.633
因爲一切都準備就緒

00:08:52.699 --> 00:08:55.435
所以自動佈局
便自動爲我的框架進行了更新

00:08:55.802 --> 00:08:59.439
在Xcode 8中 我們爲各位做了
大量的框架自動更新的工作

00:09:01.041 --> 00:09:04.811
那麼接下來
我們希望能有個不錯的背景

00:09:05.779 --> 00:09:07.748
這是陽光明媚的一天

00:09:07.848 --> 00:09:10.317
因此 我們繼續添加一個圖片視圖

00:09:12.653 --> 00:09:15.422
從目標庫中 我拖拽出了一張圖

00:09:15.489 --> 00:09:16.823
把它放大到全視圖尺寸

00:09:24.198 --> 00:09:25.532
然後設置爲圖像屬性

00:09:28.635 --> 00:09:30.537
並選擇填充模式

00:09:30.604 --> 00:09:33.140
就該案例
我們可能會選擇AspectFill

00:09:33.941 --> 00:09:36.643
現在我們要確定
它的尺寸符合其父視圖模式

00:09:36.710 --> 00:09:40.147
我們可以對各邊添加共四個約束條件

00:09:40.514 --> 00:09:43.684
但對於這種簡單的尺寸調整
我們並不需要添加任何約束條件

00:09:43.750 --> 00:09:47.221
因爲我們可以調用尺寸查看器

00:09:47.287 --> 00:09:50.424
然後調用AutoresizingMasks
對四邊進行一定延展

00:09:50.490 --> 00:09:52.326
這樣就能改變其寬高水平

00:09:53.994 --> 00:09:57.598
最後同樣重要的是
我們需要把它放到文件的上方

00:09:57.664 --> 00:09:58.498
看它就又出現了

00:09:59.032 --> 00:10:02.402
然後需要確認
我這個banner的背景

00:10:02.603 --> 00:10:06.206
介於這屬於視覺藝術
看 現在就得到了很棒的半透明效果

00:10:06.673 --> 00:10:07.875
然後我們測試一下

00:10:07.941 --> 00:10:10.911
它現在看起來很棒

00:10:11.979 --> 00:10:15.616
在橫屏模式2/3模式

00:10:16.717 --> 00:10:18.452
及豎屏模式下都很棒

00:10:19.520 --> 00:10:21.655
同樣在iPhone 6s Plus
模式下也一樣

00:10:22.422 --> 00:10:25.993
以上內容既是關於
如何逐步使用自動佈局的內容

00:10:33.267 --> 00:10:36.203
接下來我想講些比較高級的主題

00:10:36.603 --> 00:10:39.506
混合設計與運行時間約束

00:10:40.307 --> 00:10:43.510
有些時候大家會陷入這樣一種窘境

00:10:43.577 --> 00:10:46.180
你在Interface
Builder內部進行視圖佈局

00:10:46.246 --> 00:10:47.781
並添加個人約束

00:10:47.848 --> 00:10:51.051
但是確實不知道該添加哪些約束條件

00:10:51.118 --> 00:10:55.022
直到運行時纔有眉目 這可能是因爲
約束條件的確定是根據諸如

00:10:55.088 --> 00:10:57.991
一天中某時刻或只有應用才瞭解的
一些大家正在載入的數據

00:10:58.859 --> 00:11:02.362
我想給大家展示三種工具和三個例子

00:11:02.429 --> 00:11:04.431
來解決這類問題

00:11:05.332 --> 00:11:08.635
首先是調用佔位符約束

00:11:09.670 --> 00:11:11.872
在這一情況下我選中一張圖

00:11:11.939 --> 00:11:17.744
我希望它在我的設備中處於
垂直與水平居中位置

00:11:17.811 --> 00:11:21.014
並處於邊緣白線以內

00:11:21.215 --> 00:11:23.684
而且我還希望它保持自身的長寬比例

00:11:24.218 --> 00:11:26.887
然而我並不知道
這幅圖最終會成爲什麼樣

00:11:27.621 --> 00:11:28.655
只有在運行時才能看到

00:11:29.022 --> 00:11:33.160
因此爲了充分了解近似尺寸與佈局

00:11:33.227 --> 00:11:37.531
可以查看Interface Builder
然後添加一個4:3的高寬比

00:11:37.931 --> 00:11:42.569
當然這一比例是我估計的
之後將其標記爲佔位符約束

00:11:43.003 --> 00:11:45.272
這樣就能在構建時間內對其進行移除

00:11:46.707 --> 00:11:50.177
當在運行時間內
確實需要對圖像進行設置時

00:11:50.377 --> 00:11:54.348
我會創建實際的長寬比例約束並運行

00:11:56.183 --> 00:12:00.420
第二個例子
假使你正在創建一項自定義控件

00:12:01.989 --> 00:12:06.059
你的自定義控件將清除
諸如UIView類或NSview類

00:12:06.126 --> 00:12:07.561
它會提供自己的圖像

00:12:07.628 --> 00:12:09.997
並管理其相關內容

00:12:10.163 --> 00:12:11.999
或許它甚至還能確定自己的尺寸

00:12:12.499 --> 00:12:15.502
它可以向自動佈局系統提供該尺寸

00:12:15.769 --> 00:12:18.372
通過指定其固有內容尺寸來進行

00:12:20.741 --> 00:12:22.843
Interface Builder
並不執行該代碼

00:12:22.910 --> 00:12:26.813
因此它並不知道
固有內容的尺寸該是多少

00:12:26.880 --> 00:12:28.782
但各位可以模擬其近似尺寸

00:12:28.849 --> 00:12:32.119
通過使用固有尺寸佔位符
來對其設定合理值

00:12:32.619 --> 00:12:35.689
因此你就可以得知
它在佈局中究竟是怎樣的

00:12:36.790 --> 00:12:38.492
記住你的自定義控件

00:12:38.559 --> 00:12:42.763
如果各位要這樣操作
務必提供它的實際固有內容尺寸

00:12:42.829 --> 00:12:46.400
你可以通過重寫
固有內容尺寸屬性來進行

00:12:46.466 --> 00:12:47.568
在自定義控件上進行

00:12:49.570 --> 00:12:52.306
最後一例是關於Xcode的新特性

00:12:53.207 --> 00:12:57.311
之所以把它放到最後來講是因爲
這可能是各位最後的一項應急選擇

00:12:57.544 --> 00:13:02.783
在大家對佔位符約束及設計

00:13:02.850 --> 00:13:04.918
還有固有內容尺寸佔位符黔驢技窮時

00:13:05.152 --> 00:13:07.888
因此我們爲各位設計了一項功能

00:13:08.055 --> 00:13:12.426
基於各視圖來調整模糊警告級別

00:13:13.126 --> 00:13:15.829
意思是說對於該視圖

00:13:15.896 --> 00:13:19.733
我希望它處於屏幕中央
但我只確定垂直位置

00:13:19.800 --> 00:13:23.904
而不知道水平位置也不知道尺寸大小

00:13:24.605 --> 00:13:27.140
Interface Builder
其實會爲此給出紅線

00:13:27.207 --> 00:13:31.111
以提醒我此時缺少足夠的約束條件

00:13:31.411 --> 00:13:34.281
來進行定位 所以它是模糊的

00:13:35.749 --> 00:13:37.918
這樣我就知道
我得在之後運行時間裏添加約束條件

00:13:37.985 --> 00:13:40.621
當我獲得所有需要的信息時

00:13:40.888 --> 00:13:44.992
如此 我就可以繼續操作

00:13:45.058 --> 00:13:48.228
並通過進行模糊屬性設定
來將作業區的無用信息移除

00:13:48.662 --> 00:13:53.500
並將該屬性由“總是確認”改爲

00:13:53.567 --> 00:13:55.235
“位置確認”或“絕不確認”

00:13:55.636 --> 00:13:58.906
然後我向自己保證
之後我得添加那些約束條件

00:13:58.972 --> 00:14:02.509
如此這般
第一次佈局通過前 會一直處於該尺寸下

00:14:04.578 --> 00:14:07.548
這些工具讓各位通過
設計師/運行時間約束來進行作業

00:14:07.614 --> 00:14:09.583
當大家已嘗試完各種

00:14:09.650 --> 00:14:12.586
Interface Builder
可添加約束條件的情況下

00:14:13.320 --> 00:14:16.723
那麼以上內容
既是如何逐步使用自動佈局

00:14:17.057 --> 00:14:21.094
及如何進行設計師/運行時間約束設置
那麼現在我們將開始第二部分內容

00:14:21.295 --> 00:14:24.231
歡迎我的同事
Jesse Donaldson

00:14:24.398 --> 00:14:26.300
來給大家講解新的Cocoa

00:14:26.767 --> 00:14:27.634
該你了Jesse

00:14:38.645 --> 00:14:41.381
大家好 今天由我給大家講解
NSGridView

00:14:41.448 --> 00:14:45.219
它是一種新的佈局容器
我們在macOS上有提供

00:14:48.188 --> 00:14:51.391
大家知道維護約束條件是件很難的事

00:14:51.458 --> 00:14:55.062
縱使你有如同該複選框一樣簡單的工具

00:14:55.128 --> 00:14:58.465
我們創建了StackView
來讓這件事變的簡單

00:14:58.532 --> 00:15:02.636
並且你還可以在任何時候
將一些視圖在工作區間內進行伸展

00:15:03.437 --> 00:15:05.172
有些佈局依然

00:15:05.772 --> 00:15:08.775
很難實現 比如

00:15:08.842 --> 00:15:10.544
你可以通過stacks創建它

00:15:10.978 --> 00:15:13.380
而NSStackView
則不能對內容進行

00:15:13.447 --> 00:15:15.749
跨行與列的排列

00:15:16.250 --> 00:15:18.051
這就是我們設計
NSGridView的原因

00:15:18.118 --> 00:15:21.955
它能輕鬆地將內容放在確切的網格上

00:15:22.022 --> 00:15:25.125
並能完成跨座標的排列方式

00:15:25.826 --> 00:15:27.227
那麼我們放大一點來看

00:15:28.428 --> 00:15:30.664
我從Voiceover設置的
UI上截取了這幅圖

00:15:30.731 --> 00:15:34.835
我在其中添加了紫色線條以便
讓大家知道它是如何適應網格的

00:15:35.669 --> 00:15:38.238
NSGridView調用多種輔助類

00:15:38.305 --> 00:15:42.042
NSGridRow和
NSGridColumn表示行與列

00:15:42.409 --> 00:15:45.679
並通過內容默認設置爲自動尺寸調整

00:15:47.314 --> 00:15:50.350
如果各位有需求還可以指明具體的尺寸

00:15:51.418 --> 00:15:53.720
還可以讓你添加一些額外的填充

00:15:53.787 --> 00:15:56.290
如果你的網格需要一些額外空間的話

00:15:56.356 --> 00:16:00.394
若你有些不適用於當前硬件構造的UI

00:16:00.794 --> 00:16:03.163
那麼這些UI將通過動態圖表示出來
並被隱藏

00:16:04.831 --> 00:16:08.769
NSGridView調用
獨立的NSGridCell

00:16:09.002 --> 00:16:10.604
以代表獨立的單元格

00:16:10.671 --> 00:16:14.341
並且單元格的作用既是

00:16:14.408 --> 00:16:16.210
對特定的內容視圖進行佈局管理

00:16:17.878 --> 00:16:20.447
單元格還可讓各位控制內容的位置

00:16:20.514 --> 00:16:22.816
如果單元格具有一定額外空間

00:16:24.017 --> 00:16:27.688
並且如果某些內容需要跨越多個單元格

00:16:27.754 --> 00:16:28.989
還可以對它們進行融合

00:16:29.056 --> 00:16:31.425
這就像各位熟悉的
電子數據表格程序一樣

00:16:32.459 --> 00:16:37.664
我已經創建了一個較小的UI
並且還有一些有趣的事可做

00:16:37.731 --> 00:16:41.034
我先展示這一小部分內容
並展示它是如何創建的

00:16:43.937 --> 00:16:47.140
我們打算在Interface Builder中
爲NSGridView提供支持

00:16:47.207 --> 00:16:49.843
但直到完成它之前我們還是得通過
代碼進行作業

00:16:49.910 --> 00:16:53.013
我把outlet放進了nib文件

00:16:53.080 --> 00:16:55.382
針對所有我想放入網格的控制組件

00:16:55.916 --> 00:16:59.520
之後無論何時大家對NSGridView
註明ContentView屬性

00:17:00.153 --> 00:17:03.657
在需要的情況下它都能考慮到
網格子視圖的可移動屬性

00:17:04.156 --> 00:17:07.294
這讓各位在運行期間可以輕鬆地
對網格視圖進行分配

00:17:07.361 --> 00:17:09.829
之後融入到現有視圖層次體系中

00:17:11.365 --> 00:17:14.134
可以通過多種方法構建網格視圖

00:17:14.201 --> 00:17:15.769
但我認爲這是最簡單的一種

00:17:15.836 --> 00:17:19.673
大家所要做的僅是

00:17:19.740 --> 00:17:21.241
爲每行註明一個內容視圖列表

00:17:21.842 --> 00:17:23.377
接下來我們來討論幾件事

00:17:23.443 --> 00:17:25.979
首先各位不必擔心網格的尺寸

00:17:26.346 --> 00:17:29.016
無論需要多少行與列它都能

00:17:29.082 --> 00:17:30.851
針對大家指定的內容進行處理

00:17:31.418 --> 00:17:36.390
其次各位從頭到尾使用的代碼
既具有近似網格狀的屬性

00:17:36.456 --> 00:17:40.227
而且至少與指定的UI是高度相關的

00:17:40.460 --> 00:17:43.864
這便於之後各位或他人返回

00:17:43.931 --> 00:17:45.632
並瞭解該代碼

00:17:46.366 --> 00:17:49.736
因此如果我們現在運行
它會出現這樣的結果

00:17:50.103 --> 00:17:52.539
僅對於調用構造函數來說這不算壞

00:17:52.906 --> 00:17:55.175
但顯然這並不符合設計

00:17:55.843 --> 00:17:59.079
最突出的問題是UI伸展幅度過大

00:17:59.146 --> 00:18:00.914
造成過多空白比如這個

00:18:01.548 --> 00:18:05.953
這是因爲表格視圖被限定到了窗口邊緣

00:18:06.086 --> 00:18:10.257
現在我要做的是將窗口的尺寸
調整到與網格一致

00:18:10.490 --> 00:18:14.061
但實際上這樣會使網格填滿整個窗口

00:18:14.828 --> 00:18:17.164
如果各位之前使用自動佈局比較頻繁

00:18:17.231 --> 00:18:21.435
那麼在使用文本文件或其他控制組件時
可能遇到過類似的問題

00:18:21.702 --> 00:18:23.704
我們準備用同樣的方式來解決這個問題

00:18:23.770 --> 00:18:26.540
通過調整網格視圖的
ContentHuggingPriority屬性

00:18:27.908 --> 00:18:31.645
這樣該窗口內的其它控制組件

00:18:31.712 --> 00:18:32.679
就能從nib文件中獲得較高的
ContentHugging值

00:18:33.580 --> 00:18:37.384
但直到我們在表格視圖中
增大ContentHugging值

00:18:37.751 --> 00:18:41.255
之後窗口可能將內容視圖的邊緣

00:18:41.321 --> 00:18:43.390
偏離行與列的邊緣

00:18:44.424 --> 00:18:48.962
一旦我們增加該值
反而能拉小窗口的邊緣

00:18:49.029 --> 00:18:50.564
空白間隔即消失了

00:18:52.065 --> 00:18:55.536
接下來我希望討論的是這些標籤

00:18:56.003 --> 00:18:58.972
顯然它們的佈局存在一些問題

00:18:59.106 --> 00:19:00.841
需要進行調整

00:19:00.908 --> 00:19:03.844
因此需要對它們進行標籤屬性的控制

00:19:05.112 --> 00:19:09.583
通過對單元格調整座標參數
會很容易地將它糾正過來

00:19:10.751 --> 00:19:16.423
X與Y座標屬性適用於行列

00:19:16.490 --> 00:19:18.158
單元格以及網格視圖

00:19:18.625 --> 00:19:23.063
方法就是
如果沒在單元格上指定具體數值

00:19:23.130 --> 00:19:26.233
那麼可調用關於行與列的數值

00:19:26.300 --> 00:19:28.235
或者網格視圖的數值如果必要的話

00:19:28.502 --> 00:19:31.271
這樣在一個位置進行數值設定
將讓整個過程變得很簡單

00:19:31.338 --> 00:19:34.208
並且能對各種單元格進行調整

00:19:34.608 --> 00:19:37.544
就這個案例我們可以從網格視圖中
得到處於零引索位置的列

00:19:37.644 --> 00:19:40.647
並對該列設置x座標

00:19:41.014 --> 00:19:44.318
如此就能將這倆標籤調整到正確位置

00:19:45.219 --> 00:19:49.389
接下來我想討論的是基線對齊

00:19:49.690 --> 00:19:53.093
該文本的標籤明顯沒有與

00:19:53.160 --> 00:19:54.695
處於控制狀態下的文本對齊

00:19:54.761 --> 00:19:57.197
在幻燈片上可能不是很明顯

00:19:57.264 --> 00:19:59.967
調整rowAlignment屬性
即可很容易對其進行校正

00:20:00.100 --> 00:20:03.370
與安置一樣
rowAlignment具有繼承性

00:20:03.704 --> 00:20:05.305
對於這種特別的設計

00:20:05.372 --> 00:20:09.510
通過基線來處理所有網格對齊的問題
是一件很棒的事

00:20:09.610 --> 00:20:12.279
因此我們可以在網格視圖中的一個地方
進行數值設定

00:20:12.346 --> 00:20:13.847
且該設定可影響一切

00:20:14.748 --> 00:20:18.552
如果大家夠仔細
能發現文本已經調整到了正確位置

00:20:19.720 --> 00:20:22.456
現在還有一件關於行對齊的問題是

00:20:22.523 --> 00:20:25.659
可能有許多處於行位置的視圖
處於行對齊狀態

00:20:26.260 --> 00:20:29.029
之後各位或許會對那些單元格註明安置

00:20:29.296 --> 00:20:33.800
所以 在這樣的情況下
網格視圖可能無法滿足所有的要求

00:20:34.134 --> 00:20:37.804
重要的是要理解行對齊

00:20:37.871 --> 00:20:40.073
總是比安置優先

00:20:40.340 --> 00:20:43.810
它起作用後
我們將得到整組的對齊內容視圖

00:20:43.877 --> 00:20:47.114
然後我們會使用安置功能
從第一個單元格開始進行安置

00:20:49.950 --> 00:20:53.687
接下來
我要給大家講的是這個彈出按鈕

00:20:53.754 --> 00:20:58.158
設計圖在彈出按鈕的
上、下均留有一點額外的間隔

00:20:58.225 --> 00:21:02.462
我們可以在該行中添加一些填充
使佈局也有這樣的間隔

00:21:05.666 --> 00:21:07.768
因此 我們要做的第一件事就是獲取行

00:21:08.035 --> 00:21:11.205
我們其實可以用之前
獲取列的相同方式進行

00:21:11.271 --> 00:21:14.975
通過指定索引獲取
但這種方式更好一點

00:21:15.609 --> 00:21:19.880
相反 我們從網格視圖
找到包含該彈出按鈕的單元格

00:21:19.947 --> 00:21:21.782
然後從該單元格獲取行

00:21:22.716 --> 00:21:24.985
這樣更好 因爲如果之後有人蔘與進來

00:21:25.352 --> 00:21:28.355
並更改網格視圖的配置
以添加一個複選框

00:21:28.422 --> 00:21:31.091
或其它類似的東西
這段代碼仍將有效

00:21:31.358 --> 00:21:34.228
如果你在代碼中
塞入了大量硬編碼的索引值

00:21:34.294 --> 00:21:37.998
那麼一旦有人添加一個複選框
你就得檢查所有的代碼

00:21:38.065 --> 00:21:40.300
以查看哪個索引值需要進行更新

00:21:41.902 --> 00:21:45.405
在任何情況下 只要我們獲取了行

00:21:45.472 --> 00:21:48.242
我們就可以繼續 並設置填充值

00:21:48.308 --> 00:21:50.777
我們會發現得到了一點點額外的間隔

00:21:50.844 --> 00:21:52.179
在彈出按鈕的上方和下方

00:21:53.146 --> 00:21:55.949
我們還需要在狀態單元格標籤上
留一點間隔

00:21:56.950 --> 00:21:59.119
我們可以通過同樣的辦法實現

00:22:02.689 --> 00:22:04.091
下面 我想在此處花點時間

00:22:04.157 --> 00:22:06.793
談談填充與間隔之間的不同

00:22:06.860 --> 00:22:08.929
我們還沒怎麼正經地討論過間隔

00:22:09.229 --> 00:22:11.832
填充值在行和列上都有

00:22:11.899 --> 00:22:14.835
它們僅用於在各處添加額外的間隔

00:22:14.902 --> 00:22:16.336
在網格需要添加間隔的地方

00:22:16.737 --> 00:22:19.606
網格視圖本身就可以設置間隔值

00:22:19.673 --> 00:22:23.477
它們適用於所有行或所有列之間的間隔

00:22:24.077 --> 00:22:30.184
因此 如果我們拷貝一份設計
並清除上面所有填充

00:22:30.584 --> 00:22:33.754
那我們就會看到這樣的結果
UI仍適當地間隔開

00:22:33.820 --> 00:22:37.291
但我們已無法分辨出
不同控制羣簇之間的區別

00:22:38.125 --> 00:22:42.829
如果我們保留填充
但去掉所有間隔 就會變成這樣

00:22:43.197 --> 00:22:47.668
我們仍能看到控制羣
但UI就很緊巴地擠在一起

00:22:48.202 --> 00:22:50.938
當然如果你把兩個都去掉了
那就會變成這樣

00:22:51.004 --> 00:22:53.640
整體都會被壓縮得很緊實

00:22:54.541 --> 00:22:58.612
此處需要記住的是
填充屬性默認爲零

00:22:58.846 --> 00:23:02.683
除非你特別設置它
否則在網格中不會有任何填充

00:23:02.749 --> 00:23:05.719
但是大家通常希望
在內容視圖之間留一些間隔

00:23:05.786 --> 00:23:10.657
所以網格視圖的間隔默認值默認不爲0

00:23:10.724 --> 00:23:15.095
如果你的用例要求視圖
都是彼此之間緊貼佈局

00:23:15.162 --> 00:23:18.866
那麼就需要在網格視圖中
將這些間隔屬性設置爲零

00:23:19.399 --> 00:23:23.871
此處最後一個確實不協調的地方
是這個複選框

00:23:23.937 --> 00:23:26.707
這是一個有趣的情況
因爲它需要跨邊界

00:23:26.773 --> 00:23:28.542
在底部的兩個單元格之間

00:23:28.609 --> 00:23:30.544
但我們可以通過合併單元格實現

00:23:30.611 --> 00:23:32.346
正如我在介紹中提到的

00:23:33.380 --> 00:23:35.749
這有幾種方法實現
但在這種情況下

00:23:35.816 --> 00:23:38.418
我們可以告訴該行
合併它的頭兩個單元格

00:23:38.785 --> 00:23:40.053
當你這樣做時

00:23:40.621 --> 00:23:44.625
它具有擴展
頂部前導單元格邊界的作用

00:23:44.691 --> 00:23:46.527
覆蓋整個合併範圍

00:23:48.362 --> 00:23:52.566
因此這個代碼一旦生效
我們看到複選框滑動

00:23:52.633 --> 00:23:55.402
現在這個內容視圖
已經在兩個單元格中展開佈局了

00:23:55.469 --> 00:23:56.670
就好像它們是同一個

00:23:56.737 --> 00:23:59.907
實際上 你可以看到
它只是沿襲了拖尾放置

00:23:59.973 --> 00:24:01.041
從第一列沿襲過來

00:24:02.809 --> 00:24:05.345
我們真的不希望有拖尾放置

00:24:05.679 --> 00:24:08.048
但是我們也不想有引導放置

00:24:08.348 --> 00:24:11.518
這個複選框實際上應該置於邊界中心

00:24:11.585 --> 00:24:13.086
介於兩列之間

00:24:13.654 --> 00:24:17.124
因爲列與列大小不一

00:24:17.191 --> 00:24:20.260
這不是網格視圖真正想爲你做的事情

00:24:20.460 --> 00:24:22.996
但是它卻爲你自己實現
這一目標留出了空間

00:24:24.264 --> 00:24:27.701
開始需要把該單元格的安放設置爲空

00:24:28.135 --> 00:24:30.671
當你將這些安置值設置爲空時

00:24:31.338 --> 00:24:33.674
它會導致網格視圖

00:24:33.740 --> 00:24:36.109
停止維護該佈局的這一屬性

00:24:37.110 --> 00:24:40.147
其結果是網格視圖
將不會應用任何約束條件

00:24:40.214 --> 00:24:42.216
這可能與我們的約束條件相悖

00:24:42.482 --> 00:24:45.285
所以一旦完成了這個
就可以繼續設置約束條件

00:24:45.352 --> 00:24:48.088
從複選框中心x錨點開始

00:24:48.155 --> 00:24:50.624
到它上面的複選框引導錨點

00:24:51.592 --> 00:24:52.960
一旦我們有了約束條件

00:24:53.026 --> 00:24:56.330
我們就可以像通常對待
約束條件那樣真正激活它

00:24:56.797 --> 00:25:00.534
但在這種情況下
要把它設在自定義安置約束條件陣列中

00:25:02.069 --> 00:25:04.204
如果這樣做就可以使網格視圖

00:25:04.271 --> 00:25:07.140
保持任何自定義的安置約束條件

00:25:07.207 --> 00:25:10.344
它會進行諸如激活或停用
約束條件等類似操作

00:25:10.410 --> 00:25:12.646
取決於該單元格是否可見

00:25:14.181 --> 00:25:18.685
接下來 這個代碼生效後
我們看到複選框移動到位置

00:25:18.986 --> 00:25:21.688
實現結果就與設計一致了

00:25:22.022 --> 00:25:22.856
這樣我們就完成了

00:25:23.457 --> 00:25:27.094
此處 部分網格的配置有些複雜

00:25:27.160 --> 00:25:30.998
但是比起你需要構建這個UI來說
整個過程還是簡單了很多

00:25:31.365 --> 00:25:33.867
從基本約束條件抑或是堆棧

00:25:34.401 --> 00:25:37.137
其實沒有太多需要改變

00:25:37.204 --> 00:25:42.643
爲了將這擴展到整個UI
我借鑑了VoiceOver參數選擇

00:25:43.744 --> 00:25:46.313
所以 總而言之
NSGridView很棒

00:25:46.380 --> 00:25:50.684
如果你的應用程序
有一個靜態網格式UI需要管理

00:25:51.318 --> 00:25:54.588
要處理它的一個好辦法是
獲取你的所有內容視圖

00:25:54.655 --> 00:25:56.723
並將它們放入一個網格
看看會發生什麼

00:25:57.057 --> 00:26:00.561
此時 你還可以對網格的配置
進行迭代重複

00:26:00.627 --> 00:26:03.530
直到實現你預期的佈局設計

00:26:03.630 --> 00:26:04.932
我希望大家覺得這個有所幫助

00:26:05.766 --> 00:26:08.302
接下來 有請同事
Marian Goldeen

00:26:08.368 --> 00:26:11.705
她將給大家講講
她開發的一些新的調試工具

00:26:12.105 --> 00:26:13.006
謝謝

00:26:19.613 --> 00:26:22.449
雖然不經常發生
但它一旦發生 就很要命

00:26:22.683 --> 00:26:26.653
然後就造成了故障 很難調試

00:26:26.820 --> 00:26:28.555
這是一個佈局的反饋環路

00:26:29.556 --> 00:26:31.525
當你遇到一個佈局的反饋迴路時

00:26:31.825 --> 00:26:33.894
你往往正在開始或者結束一個切換

00:26:34.094 --> 00:26:35.829
它可能是這樣的

00:26:35.896 --> 00:26:38.932
你點擊按鈕開始切換

00:26:39.333 --> 00:26:43.337
按鈕響應了 但其它都沒有響應

00:26:44.238 --> 00:26:48.008
這樣 你得馬上運行Xcode
在調試導航器中查看

00:26:48.075 --> 00:26:51.512
你會發現CPU卡住了

00:26:52.012 --> 00:26:55.916
內存佔用正在增加 可能你會中斷

00:26:55.983 --> 00:26:59.052
你繼續查看就會發現
一堆佈局正在回溯中

00:26:59.586 --> 00:27:04.091
現在出現的情況是 某種視圖集合

00:27:04.157 --> 00:27:07.794
正在運行佈局
不斷重複 形成了死循環

00:27:08.128 --> 00:27:09.596
運行循環永不停止

00:27:09.997 --> 00:27:13.066
此時出現的消息
都在收集自動釋放對象

00:27:13.133 --> 00:27:16.203
全部都在收集信息
這就是爲什麼內存佔用得越來越多

00:27:16.937 --> 00:27:21.241
造成這種情況的原因是
一種上行數據流setNeedsLayout

00:27:21.508 --> 00:27:24.945
我的意思是
在它佈局中leafword視圖之一

00:27:25.012 --> 00:27:28.982
正在做些事情
使得更趨於根定向的視圖

00:27:29.049 --> 00:27:32.953
以得到setNeedsLayout
所以當佈局完成其路徑時

00:27:33.020 --> 00:27:35.255
它正好回到頂部 並重新開始

00:27:35.522 --> 00:27:39.660
你們想知道的是
這其中涉及到了什麼視圖

00:27:40.127 --> 00:27:44.731
因爲這將幫你找出
setNeedsLayout的出處

00:27:44.798 --> 00:27:47.201
這是爲何？你要對它做什麼？

00:27:47.467 --> 00:27:50.671
這個信息其實收集起來有點難

00:27:50.904 --> 00:27:55.609
因此 這就是我們爲什麼
要介紹佈局反饋環路調試器

00:27:55.676 --> 00:27:57.678
以此來應對這些特殊情況

00:27:58.445 --> 00:28:01.715
這是一個在Xcode中
添加的啓動參數

00:28:01.782 --> 00:28:02.850
它叫做UIView

00:28:02.916 --> 00:28:07.221
或NSViewLayoutFeedbackLoop
DebuggingThreshold

00:28:07.754 --> 00:28:10.357
取決於你用的是macOS還是iOS

00:28:11.225 --> 00:28:14.194
你給它設置一個值 此處我設的100

00:28:14.394 --> 00:28:19.333
你可以設置任何值
但我們把它限制在50到1000之間

00:28:20.534 --> 00:28:22.703
現在當你對該啓動參數設置之後

00:28:22.769 --> 00:28:26.673
佈局反饋迴路調試器
將會計算佈局子視圖

00:28:26.740 --> 00:28:28.375
爲每個運行佈局的視圖進行計算

00:28:28.575 --> 00:28:32.012
如果它們其中任何一個運行超過閾值

00:28:32.079 --> 00:28:33.881
在同一個運行循環中

00:28:34.314 --> 00:28:38.285
在收集信息的同時
還會使循環運行一段時間

00:28:38.352 --> 00:28:42.990
然後它會引發異常
並把信息轉存到日誌中

00:28:43.624 --> 00:28:48.095
轉存信息至com.apple.AppKit子系統

00:28:48.161 --> 00:28:50.364
或com.apple.UIKit
子系統

00:28:50.430 --> 00:28:52.432
這取決於你用的是
macOS還是iOS

00:28:52.699 --> 00:28:54.835
這兩種情況有不同的佈局循環目錄

00:28:55.269 --> 00:28:58.839
如果你想了解更多
有關這一新日誌子系統和目錄的信息

00:28:58.906 --> 00:29:00.807
請參加今天五點鐘的講座

00:29:00.874 --> 00:29:03.677
在Knob Hill 舉行
主題是統一的日誌與活動跟蹤

00:29:04.711 --> 00:29:07.948
另外 你可以在調試器中設置斷點

00:29:08.015 --> 00:29:09.216
異常斷點

00:29:09.550 --> 00:29:11.685
你可以在調試器中打印反饋迴路

00:29:11.752 --> 00:29:13.987
或者它碰到斷點也是挺好的

00:29:14.054 --> 00:29:16.823
也許還可以更多地
反思一下發生了什麼事情

00:29:20.561 --> 00:29:23.830
所以我說的信息轉存確實就是信息轉存

00:29:24.131 --> 00:29:28.635
下面我們來看兩個
真實的實時佈局反饋環路的例子

00:29:28.702 --> 00:29:31.438
我用了佈局反饋環路調試器進行調試

00:29:31.505 --> 00:29:33.874
現在我們要查看這些日誌逐一細細查看

00:29:34.107 --> 00:29:37.411
很可能看到對你有所幫助的
兩個不同日誌記錄

00:29:37.477 --> 00:29:40.013
我們準備要查看佈局反饋環路

00:29:40.080 --> 00:29:42.616
這是由上行數據流
setNeedsLayout引起的

00:29:42.716 --> 00:29:45.052
這實際上與自動佈局無關

00:29:45.319 --> 00:29:50.157
而另一個是由源自約束條件的
模糊佈局導致的

00:29:50.224 --> 00:29:52.159
這對於自動佈局是非常特殊的

00:29:53.360 --> 00:29:57.130
所以對於第一例子
當上行數據流結構發生變化

00:29:58.098 --> 00:30:03.937
這是一張視圖樹的圖片
其中出現了反饋環路

00:30:04.371 --> 00:30:08.208
在這個視圖樹中
很多視圖其實都是運行中的佈局

00:30:10.978 --> 00:30:12.880
通常你會很幸運
因爲其中沒有太多視圖

00:30:12.946 --> 00:30:14.882
但如果碰到這樣的 你就會抓狂了

00:30:15.215 --> 00:30:18.719
但實際上 它們中
有10個僅僅是湊數的

00:30:18.819 --> 00:30:21.722
它們是實際問題的無辜受害者

00:30:21.788 --> 00:30:23.891
這出現在分層結構的較高層中

00:30:24.157 --> 00:30:26.793
接下來 可以看到第三層級視圖

00:30:26.960 --> 00:30:30.497
在其佈局中 正在改變它的子視圖邊界

00:30:31.131 --> 00:30:34.468
當一個視圖邊界發生變化
就會有一個明顯的setNeedsLayout

00:30:34.735 --> 00:30:37.571
因爲它需要爲了新的邊界
而重新設置其視圖

00:30:37.838 --> 00:30:41.642
但若正接收邊界的這個視圖發生了變化

00:30:41.808 --> 00:30:44.978
而如果它的父視圖實際不在佈局中

00:30:45.112 --> 00:30:47.848
父視圖也將收到一個
setNeedsLayout

00:30:47.915 --> 00:30:51.318
這樣佈局子視圖
將會有對佈局進行描述的字眼

00:30:51.919 --> 00:30:54.955
這樣 當佈局通過 執行到底並結束

00:30:55.022 --> 00:30:58.091
它會返回頂部並繼續執行佈局

00:30:58.158 --> 00:31:00.127
因爲頂視圖仍然需要佈局

00:31:00.327 --> 00:31:03.297
這會重置中間視圖的邊界

00:31:03.463 --> 00:31:07.568
反饋環路是由兩個視圖所驅動的

00:31:07.634 --> 00:31:09.870
這兩個視圖對中間視圖的邊界存在分歧

00:31:11.104 --> 00:31:13.407
你可以想象 有很多視圖正在運行中

00:31:13.807 --> 00:31:16.810
這樣 在日誌有很多信息
所以你大可放心使用

00:31:17.411 --> 00:31:20.781
日誌大概就是這樣的
或者說至少是頂層是這樣的

00:31:20.848 --> 00:31:23.750
當你查看這些日誌時
我希望你們也從這裏開始

00:31:23.817 --> 00:31:27.387
第一個被調出來的就是頂層視圖

00:31:27.788 --> 00:31:29.122
是佈局反饋環路的頂層視圖

00:31:29.189 --> 00:31:31.825
因此 在這個環路中
沒有視圖而更多的是根詞語

00:31:31.892 --> 00:31:33.627
相對這個佈局視圖而言

00:31:34.161 --> 00:31:38.065
接下來是關於子樹的遞歸循環描述

00:31:38.131 --> 00:31:39.666
在頂層視圖之下

00:31:39.967 --> 00:31:44.872
在描述中 有些視圖的旁邊
你會看到一個數字

00:31:44.938 --> 00:31:47.608
你往往會在頂層視圖的旁邊
看到一個數字

00:31:47.674 --> 00:31:49.076
此處你看到的就是23

00:31:49.576 --> 00:31:52.112
這些數字表示的是數量

00:31:52.179 --> 00:31:55.582
即接收佈局的視圖數量
且數字都是順序排列的

00:31:55.816 --> 00:31:58.218
當然 這是一個循環
我們可在任何地方放置一個

00:31:58.285 --> 00:32:01.255
但是我們這樣做的話
最後一個就是頂層視圖

00:32:01.321 --> 00:32:03.657
這樣你就能知道涉及到多少視圖

00:32:04.091 --> 00:32:07.861
所以總共是23個
但從這裏往下只有10個

00:32:07.928 --> 00:32:10.964
這兒頂部還有三個
加起來還是不到23

00:32:11.031 --> 00:32:12.165
這是怎麼回事呢？

00:32:12.699 --> 00:32:15.702
好了 讓我們來看看日誌的下一段

00:32:15.869 --> 00:32:18.539
這是按順序接收佈局的視圖

00:32:19.006 --> 00:32:24.378
在本段中
你可以看到正因爲有一個循環

00:32:24.444 --> 00:32:27.648
並不意味着羅列的每個視圖只出現一次

00:32:27.848 --> 00:32:32.553
我們展現出了十個視圖
後面還有兩個其它視圖

00:32:32.753 --> 00:32:34.988
接下來又是這十個相同的視圖

00:32:35.389 --> 00:32:37.424
所以這些是更leafmost的視圖

00:32:37.491 --> 00:32:40.494
當你看到這種情況
即一堆視圖被羅列出來

00:32:41.295 --> 00:32:44.531
在循環中不止一次出現

00:32:44.598 --> 00:32:48.902
它們往往都是其它更重要視圖的受害者

00:32:50.003 --> 00:32:54.341
所以就像我之前說的
我們真正感興趣的是

00:32:54.408 --> 00:32:58.078
頂層視圖從哪裏獲取
其setNeedsLayout

00:32:58.979 --> 00:33:04.685
因此 緊隨這一段後面是很多詳情

00:33:04.751 --> 00:33:06.820
關於在佈局中實際發生了什麼

00:33:06.887 --> 00:33:10.057
所以我們準備要直接滑動到日誌底部

00:33:10.123 --> 00:33:15.429
這段頂層視圖被稱爲
CallStacksSentTo

00:33:15.495 --> 00:33:17.965
所以在那兒 你只需要查找它就可以了

00:33:19.199 --> 00:33:24.872
現在 這樣的頂層視圖可以不止一個
大家知道通常只有一個

00:33:24.938 --> 00:33:28.976
這是個很複雜的情況
其中有幾個頂層視圖

00:33:29.209 --> 00:33:31.645
它們非常相似 我準備給大家展示一個

00:33:31.712 --> 00:33:35.315
在回溯的頂部是一些漏斗類函數

00:33:35.382 --> 00:33:38.986
用於反饋迴路調試器
但非常接近你看到的頂部視圖

00:33:39.052 --> 00:33:42.356
即在框架五中看到的
DropShadowViews

00:33:42.422 --> 00:33:43.757
接收一組邊界

00:33:44.324 --> 00:33:47.528
如果你記得遞歸描述中

00:33:47.594 --> 00:33:51.098
DropShadowView是
TransitionView子視圖

00:33:51.398 --> 00:33:54.668
DropShadowView
設置邊界的唯一方式是

00:33:54.735 --> 00:33:56.537
在TransitionView上
調用setNeedsLayout

00:33:56.603 --> 00:33:58.906
因爲TransitionView
不在佈局中

00:33:59.273 --> 00:34:03.710
這樣 在框架七中正在運行佈局的視圖

00:34:03.777 --> 00:34:05.979
不是TransitionView
而是其它東西

00:34:06.046 --> 00:34:08.649
但是在這個回溯中我們沒有看到該信息

00:34:08.715 --> 00:34:11.418
我沒有這個特定應用的符號

00:34:11.485 --> 00:34:15.589
所以 它們在這兒沒有顯示
此外 這可以是個視圖

00:34:15.656 --> 00:34:18.058
此處我們很幸運
因它是DropShadowView

00:34:18.125 --> 00:34:20.194
接收設定界限 覆蓋設定界限

00:34:20.260 --> 00:34:22.262
但它可能是一個不覆蓋設定界限的視圖

00:34:22.896 --> 00:34:26.366
但很可能在是回溯的信息中間

00:34:26.433 --> 00:34:28.001
與頂部信息之間

00:34:28.068 --> 00:34:31.071
這樣你就可以具體瞭解
自己感興趣的內容&lt;\b&gt;

00:34:31.138 --> 00:34:33.507
所以我們感興趣的是框架的變化

00:34:33.574 --> 00:34:35.342
對於DropShadowView

00:34:36.109 --> 00:34:39.012
所以我們向上回滾會發現信息的所在

00:34:39.079 --> 00:34:41.849
這在一些結構變化信息之下

00:34:42.349 --> 00:34:47.588
我們看到實際上這些結構變化

00:34:47.654 --> 00:34:49.656
邊界變化以及框架變化……

00:34:49.790 --> 00:34:51.757
變化一直在不停地重複中

00:34:52.025 --> 00:34:54.761
其中的兩個變化出現在佈局過程中

00:34:54.828 --> 00:34:57.698
在TransitionView上
合理的 也在預料中

00:34:57.998 --> 00:35:02.269
但其中一個來自
viewLayoutSubviews類函數

00:35:02.436 --> 00:35:05.873
即該視圖的一個特定視圖控制器

00:35:05.939 --> 00:35:08.041
即TransitionView
子視圖

00:35:08.408 --> 00:35:10.511
所以我們已經定位了問題

00:35:10.811 --> 00:35:15.215
修復這個漏洞的方式是依靠程序員

00:35:15.282 --> 00:35:18.585
找出其它方式來實現他們的目的

00:35:18.652 --> 00:35:23.891
且不改變佈局中子視圖的邊界

00:35:27.160 --> 00:35:31.365
好了 下面讓我們休息一下
因爲我們要轉到示例二了

00:35:31.431 --> 00:35:35.002
這是一個完全不同種類的反饋環路

00:35:36.503 --> 00:35:39.173
對於那些一直在用自動佈局的人來說

00:35:39.473 --> 00:35:40.941
如果要做很複雜的事情

00:35:41.008 --> 00:35:43.944
你可能會遇到模棱兩可的佈局問題

00:35:44.144 --> 00:35:47.447
而模棱兩可的佈局通常不是那麼可怕

00:35:47.648 --> 00:35:50.918
通常你可能會碰到一堆大小爲0的視圖

00:35:50.984 --> 00:35:52.452
你就會想我的視圖到哪裏去了

00:35:52.519 --> 00:35:56.323
或者說可能該視圖就是你所要的

00:35:56.390 --> 00:36:02.829
除了偶爾旋轉設備會獲得不同的佈局外

00:36:04.131 --> 00:36:06.567
但是有時真的會很不幸

00:36:06.633 --> 00:36:09.536
在優化佈局的更新限制通過時

00:36:09.603 --> 00:36:14.441
你可以訓練這種歧義
而如果歧義被訓練了

00:36:14.775 --> 00:36:18.178
則每一個都會發生變量變化

00:36:18.245 --> 00:36:20.914
每次它都將在某個地方擾亂佈局

00:36:20.981 --> 00:36:22.349
這樣你就明白了這個循環

00:36:23.584 --> 00:36:27.487
現在一個模棱兩可的佈局
作爲佈局反饋環路

00:36:27.554 --> 00:36:32.159
導致一些讓你撓頭的事情

00:36:32.226 --> 00:36:33.594
除非你能想到

00:36:33.827 --> 00:36:38.599
所以 這就是爲什麼我們總是
儘可能在日誌頂部調用它

00:36:38.732 --> 00:36:40.534
這樣它們已經在考慮它了

00:36:40.968 --> 00:36:44.304
所以這就是說模棱兩可的佈局被懷疑了

00:36:44.371 --> 00:36:46.740
然後當你查看遞歸描述時

00:36:46.940 --> 00:36:50.210
你看到模糊佈局遍佈到處都是
你也知道

00:36:50.277 --> 00:36:51.445
這很可疑

00:36:52.079 --> 00:36:54.248
我先說點題外話

00:36:54.448 --> 00:36:58.886
因爲在這些日誌中
我進行了一些縮略處理

00:36:58.952 --> 00:37:01.121
以便它們能在幻燈片上顯示正常

00:37:01.421 --> 00:37:04.658
但是有個縮略語大家可能不認識

00:37:04.725 --> 00:37:08.161
實際上就在日誌中 叫做tAMIC

00:37:08.295 --> 00:37:10.831
大家可以看到就在模棱兩可的佈局旁邊

00:37:11.164 --> 00:37:11.999
tAMIC表示

00:37:12.065 --> 00:37:14.668
將Auto Resizing Mask
翻譯成約束條件

00:37:14.735 --> 00:37:16.837
現在大家都可以這麼稱呼它

00:37:19.673 --> 00:37:24.411
無論如何
有歧義的佈局肯定是我們的問題

00:37:24.878 --> 00:37:26.880
我們可以去看回溯

00:37:26.947 --> 00:37:29.883
對setNeedsLayout
設爲頂層視圖 但我沒有

00:37:29.950 --> 00:37:33.053
這就是內部
Foundation和UIKit類函數

00:37:33.520 --> 00:37:34.988
這對我們沒什麼幫助

00:37:35.055 --> 00:37:36.790
我們得去看細節

00:37:36.857 --> 00:37:42.896
此處的詳情
將會告訴我們變量發生變化的視圖

00:37:42.963 --> 00:37:44.331
這些變化正觸發佈局

00:37:44.765 --> 00:37:51.205
關於模棱兩可的佈局
需要記住的一點是 它會蔓延

00:37:51.471 --> 00:37:53.907
所以你可能只是遺漏了幾個約束條件

00:37:54.208 --> 00:37:55.909
但是一堆視圖都是模棱兩可的

00:37:55.976 --> 00:37:58.345
因爲它們都是互相依賴的

00:37:58.579 --> 00:38:02.649
這樣 你會發現很多這類視圖
但只能從一個開始

00:38:02.716 --> 00:38:03.984
而一旦這個解決了

00:38:04.618 --> 00:38:07.054
剩下的即便無法全部解決
但也能解決大部分

00:38:07.588 --> 00:38:11.024
大家來看這兒
可以看到最小的x變量

00:38:11.091 --> 00:38:14.628
在-120到-160之間振盪

00:38:14.695 --> 00:38:16.697
不管怎樣都是某個奇數

00:38:17.097 --> 00:38:20.200
因爲它是模糊佈局
我們列出了約束條件

00:38:20.567 --> 00:38:22.569
這些約束條件影響佈局

00:38:22.703 --> 00:38:26.240
然後你很可能檢查出來丟失了什麼

00:38:26.640 --> 00:38:29.576
我準備現在就開始檢查約束條件

00:38:29.910 --> 00:38:33.213
因爲看到一系列約束條件可能會很嚇人

00:38:33.814 --> 00:38:36.984
而畫圖描述是唯一的處理辦法

00:38:37.284 --> 00:38:40.454
我想從一張視圖層次結構的圖片開始

00:38:40.521 --> 00:38:43.690
這些視圖被列在了約束條件之中

00:38:43.757 --> 00:38:47.094
幸運的是 在這個例子中
所有的視圖都屬於不同的子類

00:38:47.160 --> 00:38:49.062
所以我可以把它們標記出來給大家看

00:38:49.530 --> 00:38:52.399
接下來我要做的是給自己畫張圖

00:38:52.566 --> 00:38:54.034
描述約束條件是什麼

00:38:54.101 --> 00:38:58.071
所以約束條件是一個
最小的前導和尾隨填充

00:38:58.138 --> 00:39:00.007
對於容器中的標籤而言

00:39:00.440 --> 00:39:02.943
有一個定心的約束條件

00:39:03.010 --> 00:39:05.012
介於容器和操作視圖之間

00:39:05.479 --> 00:39:08.382
然後操作視圖中
有自動縮放的掩模約束條件

00:39:08.448 --> 00:39:11.018
將其安置在呈現視圖之中

00:39:11.084 --> 00:39:12.553
某個奇怪的地方

00:39:12.619 --> 00:39:14.821
有些東西明顯懼怕這些約束條件

00:39:15.355 --> 00:39:20.794
最終在呈現視圖
及其同類視圖之間將會進行對齊

00:39:21.261 --> 00:39:23.597
但是沒有什麼會真正堅持

00:39:23.664 --> 00:39:27.201
整個視圖層次需要在任何特定的地方

00:39:27.601 --> 00:39:34.107
這就是我們爲什麼要介紹模糊視圖
和佈局反饋環路

00:39:35.275 --> 00:39:39.613
這就是佈局反饋迴路調試器
它是一個啓動自變量

00:39:39.680 --> 00:39:43.350
你不會經常需要使用它
當你需要時 可節約大量時間

00:39:43.884 --> 00:39:47.087
簡要回顧一下 我們看了...

00:39:47.154 --> 00:39:50.424
如何逐步使用自動佈局和
Interface Builder

00:39:50.757 --> 00:39:53.794
在AppKit中
有類似網格佈局NSGridView

00:39:53.861 --> 00:39:57.497
若你想很快在iOS中看到它
請到Apple Bug Reporter中投票

00:39:57.764 --> 00:40:00.934
最後 我們還談到了反饋環路調試閾值

00:40:01.401 --> 00:40:04.071
若要了解更多詳情
請訪問Dub-Dub網站

00:40:04.137 --> 00:40:07.407
希望大家下午過得愉快
感謝你們的到來