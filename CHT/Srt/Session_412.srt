00:00:19.486 --> 00:00:23.757
線程檢查工具
和靜態分析

00:00:23.824 --> 00:00:28.829
幫助你在代碼中查找錯誤

00:00:31.765 --> 00:00:32.833
大家好 我是Anna

00:00:32.900 --> 00:00:35.869
歡迎來到線程檢查工具
和靜態分析演講

00:00:36.937 --> 00:00:39.606
由於我們的團隊
從事於錯誤尋找工具

00:00:39.673 --> 00:00:43.377
我們將告訴你
找出錯誤的新方法

00:00:44.044 --> 00:00:47.614
我開始會簡要概述一下
地址檢查工具

00:00:47.681 --> 00:00:50.484
然後更加深入到
線程檢查工具

00:00:50.551 --> 00:00:52.953
這是我們今年推出的新功能

00:00:53.554 --> 00:00:56.456
之後 Devin會上臺
給大家講講新的檢查

00:00:56.523 --> 00:00:58.759
我們添加到
Clang靜態分析器上

00:00:59.893 --> 00:01:00.727
開始吧

00:01:01.895 --> 00:01:07.601
檢查工具是LEM工具的一個家族
組合編譯時間檢測工具

00:01:07.835 --> 00:01:11.405
和運行時監控
在運行時尋找錯誤

00:01:11.772 --> 00:01:13.407
它們與Valgrind相似

00:01:13.540 --> 00:01:17.377
然而 它們的主要優點
是有低的運行時開銷

00:01:18.178 --> 00:01:20.314
兼容Swift
和Objective-C

00:01:20.514 --> 00:01:23.317
而且緊密集成於
Xcode UI

00:01:24.651 --> 00:01:28.555
去年我們在macOS和iOS上
推出了地址檢查工具

00:01:29.056 --> 00:01:33.694
這個工具能找出內存崩潰
例如棧堆緩衝區溢出

00:01:33.760 --> 00:01:35.762
用後死機 雙重死機

00:01:36.530 --> 00:01:39.499
在尋找內存問題上
極爲有效

00:01:39.566 --> 00:01:43.470
所以如果你還沒使用
我極力推薦它

00:01:44.304 --> 00:01:47.975
今年我們擴展這個工具
給Swift提供全面支持

00:01:48.609 --> 00:01:51.044
這會是令人激動的消息
對於那些

00:01:51.144 --> 00:01:53.780
喜歡在Swift中
不走尋常路的人

00:01:55.148 --> 00:01:58.452
所以這意味着什麼
如果你使用不安全指針類型？

00:01:58.752 --> 00:02:03.056
在地址檢查工具開啓時
進行測試 它會爲你找出錯誤

00:02:04.491 --> 00:02:08.829
地址檢查工具
雖然主要注重於內存崩潰問題

00:02:08.895 --> 00:02:11.965
這裏還有一個大的錯誤來源
那就是線程問題

00:02:12.933 --> 00:02:15.135
這些更加難以重現並調試

00:02:15.469 --> 00:02:16.970
對時機很敏感

00:02:17.171 --> 00:02:20.174
它們可能只會在
某些情況下出現

00:02:20.440 --> 00:02:23.577
這意味着
包含它們的應用程序

00:02:23.644 --> 00:02:25.746
會有難以預測的行爲

00:02:26.213 --> 00:02:30.284
所以今年我們推出另一個工具的支持
線程檢查工具

00:02:30.918 --> 00:02:32.819
這會有助於你找到

00:02:33.020 --> 00:02:35.756
並更好理解
你的線程錯誤

00:02:37.124 --> 00:02:39.126
TSan報告很多
不同類型的錯誤

00:02:39.193 --> 00:02:40.894
我們來看一些錯誤

00:02:41.228 --> 00:02:44.064
我會告訴你關於
未初始化互斥體的使用

00:02:44.531 --> 00:02:46.166
這可能看起來
沒什麼大不了

00:02:46.400 --> 00:02:49.736
然而 如果你使用
未經恰當初始化的互斥體

00:02:49.870 --> 00:02:52.372
這會在你的應用程序中
導致非常細微的錯誤

00:02:52.439 --> 00:02:55.509
因爲實際上
你沒有實現任何互相排斥

00:02:55.576 --> 00:02:56.977
當你使用那樣互斥體

00:02:57.411 --> 00:02:59.446
另一個例子是線程泄露

00:02:59.713 --> 00:03:01.682
如果你的應用程序
擁有很多線程

00:03:01.748 --> 00:03:03.383
如果那些線程泄露了

00:03:03.984 --> 00:03:06.186
這就會導致內存泄漏

00:03:06.687 --> 00:03:09.089
另一個是信號處理器中的
不安全調用

00:03:09.156 --> 00:03:11.058
以及從錯誤線程中解鎖

00:03:11.325 --> 00:03:15.028
然而 數據競爭
是目前最常見的問題

00:03:15.295 --> 00:03:17.397
因爲它們非常易於引發

00:03:17.898 --> 00:03:21.468
當多個線程訪問相同
內存位置時就會發生

00:03:21.768 --> 00:03:24.004
沒有使用恰當的同步

00:03:25.005 --> 00:03:26.874
我們看看該工具
是如何工作的

00:03:26.940 --> 00:03:29.109
通過進入Xcode演示

00:03:39.419 --> 00:03:42.689
這裏我將演示
線程檢查工具

00:03:42.756 --> 00:03:45.859
在去年Alpha版的
WWDC應用上

00:03:46.393 --> 00:03:49.329
所以如你所料
這裏顯示出了一週的安排

00:03:49.863 --> 00:03:51.965
不過 注意這個
有趣的視覺錯誤

00:03:52.032 --> 00:03:54.735
即使所有會話的數據
已下載完成

00:03:54.968 --> 00:03:57.171
網絡活動指示器
還是在轉動

00:03:58.238 --> 00:04:00.374
我知道我使用
全局變量來決定

00:04:00.440 --> 00:04:03.744
何時顯示或隱藏這個指示器
所以這裏可能有線程問題

00:04:03.810 --> 00:04:06.380
我們看看線程檢查工具
能否幫我們找到

00:04:07.381 --> 00:04:10.517
爲啓用線程檢查工具
我們選擇編輯方案

00:04:11.585 --> 00:04:13.287
現在Diagnostics選項卡

00:04:13.820 --> 00:04:16.055
點擊這裏啓用
線程檢查工具

00:04:16.990 --> 00:04:19.993
現在你可以選擇
每當遇到一個問題時

00:04:20.060 --> 00:04:23.063
就暫停調試器
並就地調試那個問題

00:04:23.530 --> 00:04:25.332
或者你可以選擇保持運行

00:04:25.399 --> 00:04:28.235
收集線程檢查工具
報告的所有線程問題

00:04:28.302 --> 00:04:29.469
之後再探究它們

00:04:30.003 --> 00:04:33.707
Xcode 8第二個工作流程是新的
只有線程檢查工具支持

00:04:33.774 --> 00:04:35.809
我們看看其工作原理

00:04:37.444 --> 00:04:40.147
當你在線程檢查工具下
啓動應用程序

00:04:40.347 --> 00:04:44.084
Xcode會通過額外的
編譯器工具重建你的項目

00:04:44.518 --> 00:04:46.653
然後會在特殊模式中啓動它

00:04:46.720 --> 00:04:48.722
嘗試找到線程問題

00:04:49.256 --> 00:04:51.358
這裏我們的應用程序啓動了

00:04:51.658 --> 00:04:54.494
Xcode告訴我們線程檢查工具
檢測到兩個問題

00:04:54.561 --> 00:04:58.031
並在活動查看器中顯示了
這個紫色的指示器

00:04:59.032 --> 00:05:01.034
點擊這個紫色指示器

00:05:01.401 --> 00:05:03.136
會將我們帶到
問題導航器

00:05:03.437 --> 00:05:05.172
之前我們只是用它

00:05:05.239 --> 00:05:07.608
顯示構建時間問題
例如編譯器警告

00:05:07.674 --> 00:05:09.776
編譯器錯誤
靜態分析器問題

00:05:09.843 --> 00:05:12.779
今年擴展支持了
運行時問題

00:05:12.846 --> 00:05:15.849
這樣線程檢查工具
的問題就能找到根源

00:05:16.783 --> 00:05:20.053
線程檢查工具報告了兩個問題
我們一個個看

00:05:20.120 --> 00:05:23.123
第一個是使用了
未初始化互斥體

00:05:24.091 --> 00:05:27.928
這個問題在之前運行
應用程序的某個時候出現的

00:05:28.295 --> 00:05:31.431
線程檢查工具
會告訴我們確切的時間

00:05:31.498 --> 00:05:33.834
通過提供歷史堆棧跟蹤

00:05:34.301 --> 00:05:36.336
即使這不是即時堆棧跟蹤

00:05:36.403 --> 00:05:39.606
你可以把它當做即時
堆棧跟蹤 一幀一幀查看

00:05:39.706 --> 00:05:40.707
我們來看看

00:05:40.774 --> 00:05:42.976
某時刻
我們調用了acquireLock

00:05:43.043 --> 00:05:46.613
這調用了pthread_mutex_lock
然後傳遞了無效的互斥體引用

00:05:47.114 --> 00:05:50.551
這是調用自resetFeedStatus
而它又是調用自初始化器

00:05:51.485 --> 00:05:53.820
這裏如你所見
我們確實初始化了互斥體

00:05:53.921 --> 00:05:55.889
不過是在使用之後
才初始化的

00:05:56.023 --> 00:05:57.491
這是簡單的排序錯誤

00:05:58.025 --> 00:06:00.961
所以重新給這兩個陳述排序
就應該解決好了

00:06:01.195 --> 00:06:05.199
好了 我們來看看第二個問題
那就是數據競爭

00:06:06.433 --> 00:06:09.036
線程檢查工具
告訴我們出現數據競爭

00:06:09.102 --> 00:06:11.004
在叫做活動計數的變量上

00:06:11.071 --> 00:06:14.341
這是相同的全局變量
用來決定

00:06:14.408 --> 00:06:16.476
何時顯示或隱藏指示器的

00:06:17.344 --> 00:06:21.381
因爲這是數據競爭
線程檢查工具會告訴我們兩個事件

00:06:21.582 --> 00:06:23.617
兩個競爭訪問

00:06:23.684 --> 00:06:25.118
一個讀取和一個寫入

00:06:25.452 --> 00:06:27.187
所以線程11上出現讀取

00:06:27.254 --> 00:06:29.256
而線程13上出現寫入

00:06:29.857 --> 00:06:32.326
注意這兩個都不是主線程

00:06:32.893 --> 00:06:34.428
而且堆棧跟蹤是一樣的

00:06:34.494 --> 00:06:37.297
這意味着它們可能
通過多個線程

00:06:37.598 --> 00:06:40.467
在相同的線上執行
並且沒有使用同步

00:06:40.701 --> 00:06:41.635
我們來看看

00:06:42.169 --> 00:06:45.372
好了 我們在更新
活動計數變量

00:06:46.139 --> 00:06:49.009
現在我可以通過添加鎖
來修復這個競爭

00:06:49.409 --> 00:06:51.578
不過注意這只是症狀

00:06:52.312 --> 00:06:54.882
這裏的下一行更新UI

00:06:55.983 --> 00:06:59.052
我們知道UI更新
應該發生在主線程上

00:06:59.419 --> 00:07:01.989
所以合適的修復是將

00:07:02.456 --> 00:07:06.293
counter-increment
和UI更新分派到

00:07:06.560 --> 00:07:10.764
Grand Central Dispatch
的主隊列上

00:07:11.965 --> 00:07:15.202
這既會解決
我們應用程序的邏輯問題

00:07:15.269 --> 00:07:18.539
也會解決競爭
因爲所有的線程會從

00:07:20.174 --> 00:07:22.242
相同的線程上
訪問計數變量

00:07:22.743 --> 00:07:25.579
我確定
我說得十分有說服力

00:07:25.646 --> 00:07:27.814
而且你們都相信
我將錯誤修復好了

00:07:28.048 --> 00:07:30.450
然而 最好的自行檢查方式

00:07:30.517 --> 00:07:33.253
就是在你的項目上
再次運行這個工具

00:07:33.921 --> 00:07:38.525
所以我們應該在線程檢查工具
啓用的情況下重新運行應用程序

00:07:38.592 --> 00:07:40.594
這會再次重建你的項目

00:07:40.661 --> 00:07:43.897
帶有這個額外檢查
而且在特殊模式中啓動

00:07:44.731 --> 00:07:46.400
現在應用程序啓動了

00:07:46.800 --> 00:07:50.103
我們看到奇怪的
視覺UI錯誤消失了

00:07:50.170 --> 00:07:52.406
而且線程檢查工具
沒有報告任何問題

00:07:52.840 --> 00:07:53.907
一切正常

00:07:54.274 --> 00:07:56.844
我們回到幻燈片

00:08:05.819 --> 00:08:07.654
我們回顧一下演示

00:08:08.288 --> 00:08:10.691
在方案編輯器中啓用
線程檢查工具

00:08:10.757 --> 00:08:14.528
當你進入診斷選項卡
跟地址檢查工具的做法一樣

00:08:14.728 --> 00:08:19.166
除了擁有在出現第一個問題時
暫停調試器的ASan工作流程之外

00:08:19.399 --> 00:08:21.802
線程檢查工具
支持另一種模式

00:08:21.969 --> 00:08:24.471
你可以在檢測問題的
過程中保持運行

00:08:24.538 --> 00:08:27.040
之後你可以在
問題導航器中探究它們

00:08:27.207 --> 00:08:29.877
在你重啓應用程序之前
它們會留在那裏

00:08:30.944 --> 00:08:33.947
我們來談談Xcode
在後臺發揮了什麼作用

00:08:34.014 --> 00:08:35.649
來讓這一切奏效

00:08:36.316 --> 00:08:39.520
爲了使用線程檢查工具
Xcode將特殊標記傳遞給

00:08:39.586 --> 00:08:41.822
Clang和Swift編譯器

00:08:42.289 --> 00:08:44.925
命令它們生成
被檢測二進制文件

00:08:45.993 --> 00:08:48.929
這個二進制文件鏈接到
TSan運行時間庫

00:08:49.329 --> 00:08:51.832
由檢測工具使用來

00:08:51.965 --> 00:08:55.302
監控程序的執行
並檢測那些線程問題

00:08:55.936 --> 00:08:58.805
所以如果你從命令行
進行構建和運行

00:08:58.872 --> 00:09:01.942
你可以將選項
傳遞給任何一個編譯器

00:09:02.876 --> 00:09:04.978
而且xcodebuild還會支持
線程檢查工具

00:09:05.045 --> 00:09:07.381
通過提供
enableThreadSanitizer選項

00:09:08.282 --> 00:09:11.818
默認情況下 TSan會在
檢測錯誤的過程中持續運行

00:09:12.319 --> 00:09:15.756
不過你可以命令它
在遇到第一個問題時就中止

00:09:15.956 --> 00:09:18.492
通過將TSan選項
環境變量設置成

00:09:18.559 --> 00:09:21.562
在啓動過程的時候
當halt_on_error=1時中止

00:09:21.828 --> 00:09:25.832
這會允許你有相同的工作流
與地址檢查工具是一樣

00:09:27.968 --> 00:09:29.403
在哪裏可以使用這個工具？

00:09:29.503 --> 00:09:31.705
線程檢查工具
在macOS上有支持

00:09:31.772 --> 00:09:33.640
以及64位的模擬器

00:09:33.841 --> 00:09:36.109
並不在設備上支持

00:09:37.344 --> 00:09:40.480
現在你知道如何使用該工具
如何啓動 如果尋找問題

00:09:40.547 --> 00:09:43.750
我們來談談
如何修復報告中的錯誤

00:09:44.117 --> 00:09:45.986
我們主要注重於數據競爭

00:09:46.053 --> 00:09:49.423
因爲這是所報告的
錯誤中最多的類型

00:09:50.224 --> 00:09:51.825
什麼是數據競爭？

00:09:52.159 --> 00:09:54.328
數據競爭發生於
當多個線程

00:09:54.995 --> 00:09:56.997
訪問相同的內存位置

00:09:57.064 --> 00:09:59.233
沒有使用恰當的同步

00:09:59.733 --> 00:10:02.703
而且至少一個訪問是寫入

00:10:03.971 --> 00:10:08.642
這裏的問題是
你最後可能不止得到過期數據

00:10:08.942 --> 00:10:10.944
而且行爲是無法預測的

00:10:11.011 --> 00:10:13.380
你最後甚至可能遇到內存崩潰

00:10:14.281 --> 00:10:16.550
所以數據競爭的原因是什麼？

00:10:16.717 --> 00:10:19.419
這通常表明
你遇到了邏輯問題

00:10:19.853 --> 00:10:22.389
在你程序的結構中

00:10:22.556 --> 00:10:24.424
而且只有你知道如何修復

00:10:25.125 --> 00:10:28.195
另一方面 這還意味着
缺失一些同步

00:10:28.262 --> 00:10:30.797
我們來談談第二種情景

00:10:31.965 --> 00:10:34.368
這是一個Swift中
數據競爭的例子

00:10:34.668 --> 00:10:36.270
我們有全局變量數據

00:10:36.703 --> 00:10:38.839
我們有一個生產者
設置成42

00:10:38.906 --> 00:10:41.141
以及一個打印它的消費者

00:10:42.009 --> 00:10:44.244
如果執行這兩段代碼

00:10:44.511 --> 00:10:46.947
通過兩個不同的線程
這就會出現數據競爭

00:10:48.182 --> 00:10:49.283
那這個代碼怎麼樣？

00:10:49.650 --> 00:10:52.886
我們引入了另一個變量
叫做isDataAvailable

00:10:53.287 --> 00:10:57.024
數據在生產者中更新後
我們設置那個標記

00:10:57.291 --> 00:10:59.826
而在消費者中我們要等待
直到標記設置完成

00:10:59.893 --> 00:11:01.929
如果一旦設置好
我們打印數據

00:11:02.362 --> 00:11:04.464
這看起來很有邏輯

00:11:04.598 --> 00:11:05.999
看起來應該會奏效

00:11:06.600 --> 00:11:10.070
問題是你看到的東西
不會得到執行

00:11:11.238 --> 00:11:14.808
這裏的指令可以被
任一個編譯器重新排序

00:11:14.875 --> 00:11:18.045
或者CPU 所以你不能
假設標記是在

00:11:18.111 --> 00:11:20.314
數據更新之後設置

00:11:20.848 --> 00:11:23.617
指令的順序無法保證

00:11:23.684 --> 00:11:25.319
在生產者和
消費者中都一樣

00:11:26.687 --> 00:11:28.422
所以這張幻燈片的意義何在？

00:11:28.488 --> 00:11:30.724
我只是想演示

00:11:31.058 --> 00:11:34.428
試着推出自己的同步方法

00:11:34.628 --> 00:11:36.597
通常是不好的想法

00:11:37.030 --> 00:11:38.198
那應該怎麼做？

00:11:38.465 --> 00:11:40.868
我們應該使用
已經可用的東西

00:11:41.201 --> 00:11:43.537
例如
Grand Central Dispatch

00:11:43.770 --> 00:11:47.007
是一個非常好的選項
你可以將最近訪問

00:11:47.407 --> 00:11:49.543
分配到相同的串行隊列

00:11:49.943 --> 00:11:52.613
這會確保它們在
相同的線程上執行

00:11:52.679 --> 00:11:54.147
而且沒有數據競爭

00:11:55.382 --> 00:11:59.486
現你可能想起線程檢查工具
適用於Objective-C和Swift

00:11:59.653 --> 00:12:02.089
我們使用Objective-C
作爲下一個例子

00:12:03.557 --> 00:12:05.459
這是惰性初始化代碼

00:12:05.759 --> 00:12:09.196
我們的實現方法
叫做getSingleton

00:12:09.496 --> 00:12:13.467
確保我們將相同的共享實例
返回到其所有的調用者

00:12:14.968 --> 00:12:17.738
如果這個代碼
由多個線程執行

00:12:18.071 --> 00:12:20.741
沒有適當的同步
這就會出現數據競爭

00:12:21.074 --> 00:12:24.878
當兩個線程都嘗試
更新共享實例變量

00:12:26.146 --> 00:12:27.881
好了 那這個代碼呢？

00:12:28.348 --> 00:12:31.485
我們嘗試修復這個問題
通過分配

00:12:31.552 --> 00:12:33.487
並初始化本地變量

00:12:33.921 --> 00:12:37.024
之後我們使用
atomic_compare_and_set操作

00:12:37.090 --> 00:12:41.962
來確保線程會原子級地
更新那個全局變量

00:12:42.062 --> 00:12:44.565
所以在右邊
不會有數據競爭

00:12:45.566 --> 00:12:47.301
這看起來像是踏入正軌

00:12:47.367 --> 00:12:48.902
不過這個代碼還有問題

00:12:49.336 --> 00:12:50.637
我們來看看它們

00:12:50.771 --> 00:12:54.441
首先 這會非常難以
推斷出內存管理

00:12:54.541 --> 00:12:56.143
當你使用原子

00:12:56.543 --> 00:12:59.813
例如 如果你使用ARC
這裏你會遇到use-after-free

00:13:00.681 --> 00:13:02.783
如果你使用MRR

00:13:03.083 --> 00:13:06.420
這個對象只有在
競爭出現時泄露

00:13:07.054 --> 00:13:09.122
這不是好事

00:13:09.223 --> 00:13:10.357
問題不只這一個

00:13:10.424 --> 00:13:14.628
另一個問題是
因爲讀取是非同步的

00:13:14.895 --> 00:13:17.030
這裏還是會出現競爭
如果一個線程嘗試

00:13:17.097 --> 00:13:18.699
讀取那個共享變量

00:13:18.765 --> 00:13:21.802
而另一個嘗試
原子級地設置它

00:13:22.503 --> 00:13:25.305
所以這是未定義行爲
這不好

00:13:26.039 --> 00:13:27.274
那你應該怎麼做？

00:13:27.341 --> 00:13:30.444
如果你已經知道解決方案了
使用Grand Central Dispatch

00:13:30.511 --> 00:13:34.081
這會替你進行
惰性初始化設置

00:13:35.282 --> 00:13:36.850
這在Swift中更加容易

00:13:37.251 --> 00:13:41.855
全局變量和類型常量
都分派了一個語義

00:13:42.122 --> 00:13:43.924
你能選擇兩者任意
一個解決方案

00:13:43.991 --> 00:13:45.792
對你的代碼有最有效的那個

00:13:47.561 --> 00:13:49.196
好了 總結一下

00:13:49.263 --> 00:13:52.366
你應該使用適合
你需求的最高級別API

00:13:52.900 --> 00:13:55.936
大多數人應該使用Grand
Central Dispatch

00:13:56.069 --> 00:13:59.940
如果這不適合
你可以使用pthread API

00:14:00.240 --> 00:14:01.775
或者比如NSLock

00:14:03.343 --> 00:14:07.781
我們新os_unfair_lock
是今年在我們平臺上新出的

00:14:07.848 --> 00:14:09.716
它代替了OSSpinLock

00:14:09.950 --> 00:14:12.553
我們還有
C++和C11 Atomics

00:14:13.120 --> 00:14:15.255
線程檢查工具支持它們

00:14:15.355 --> 00:14:19.226
你在之前的例子中看過了
它們非常難以正確地使用

00:14:20.093 --> 00:14:21.495
除了性能之外

00:14:21.562 --> 00:14:25.265
這要麼是不可測量的
或者是可以忽略的

00:14:25.699 --> 00:14:29.870
所以不要選擇使用那些API
如果你不去測量

00:14:29.937 --> 00:14:32.873
它們確實在你的
應用程序上有一些東西

00:14:34.408 --> 00:14:36.844
所以關於更多這些API的信息

00:14:36.910 --> 00:14:40.547
請參加
週五的併發程序設計演講

00:14:42.216 --> 00:14:44.618
現在我們來談談良性競爭

00:14:44.918 --> 00:14:45.953
這是什麼？

00:14:46.019 --> 00:14:48.689
一些開發者主張
在一些架構上

00:14:48.956 --> 00:14:50.457
例如x86

00:14:50.858 --> 00:14:54.328
你不需要在讀取和
寫入之間插入同步

00:14:54.828 --> 00:14:57.798
因爲架構本身就保證了自動

00:14:57.865 --> 00:15:00.534
指針大小數據的操作

00:15:01.802 --> 00:15:05.539
要記住的重要一點是
任何競爭 即使是良性競爭

00:15:05.606 --> 00:15:09.676
在C或C++標準中
被視爲未定義的行爲

00:15:10.377 --> 00:15:14.781
所以你不僅會驚奇地發現
帶有良性競爭的代碼運行在

00:15:14.848 --> 00:15:17.684
你之前沒有完全測試好的架構上

00:15:18.118 --> 00:15:21.421
而且編譯器可以自由
給那些指令重新排序

00:15:21.488 --> 00:15:23.724
跟沒有其他線程看到一樣

00:15:24.958 --> 00:15:28.328
所以最後你可能
會遇到非常細微的錯誤

00:15:28.695 --> 00:15:35.068
正如我們的線程檢查工具
工程主管所說：“修復所有錯誤”

00:15:43.277 --> 00:15:46.013
現在到我們演講
最精彩的部分了

00:15:46.580 --> 00:15:49.716
我們都知道數據競爭
很難重現 因爲它們

00:15:49.783 --> 00:15:51.051
對時機非常敏感

00:15:51.652 --> 00:15:55.222
線程檢查工具
最有趣的一點是它可以檢測

00:15:55.289 --> 00:15:58.192
那些在特定程序運行
過程中未顯現的競爭

00:15:58.825 --> 00:16:00.260
來看看它是怎麼做到的

00:16:01.295 --> 00:16:04.031
當你用線程檢查工具
編譯你的程序

00:16:04.231 --> 00:16:06.300
它會檢測每個內存訪問

00:16:06.366 --> 00:16:09.369
然後在上面加上標記前綴
使用引號

00:16:09.636 --> 00:16:13.273
不過首先
記錄關於訪問的信息

00:16:14.341 --> 00:16:19.680
第二 檢查那個
訪問是否參與競爭

00:16:20.347 --> 00:16:21.715
我們來深入看看

00:16:22.683 --> 00:16:25.319
對於每個對齊的
8字節應用程序內存

00:16:25.919 --> 00:16:30.791
線程檢查工具的影子狀態
會最多記錄4個訪問

00:16:31.425 --> 00:16:33.126
假設你有4個線程

00:16:33.360 --> 00:16:35.229
線程1寫入到那個內存位置

00:16:35.495 --> 00:16:38.165
線程檢查工具更新它
將信息存儲在

00:16:38.232 --> 00:16:40.434
影子線程
來重置內存位置

00:16:40.701 --> 00:16:43.871
我們還是會記錄
我們持續不斷做下去

00:16:44.338 --> 00:16:47.841
現在如果你有
4個以上的訪問怎麼辦？

00:16:50.377 --> 00:16:52.880
線程檢查工具
使用有根據的推測

00:16:52.946 --> 00:16:55.816
決定接下來
將哪個單元格驅逐掉

00:16:55.883 --> 00:16:59.052
這裏它驅逐了
相同線程的訪問

00:16:59.887 --> 00:17:01.855
這不會使其失去精度

00:17:03.090 --> 00:17:05.325
然而 如果我們有
第五個訪問

00:17:05.392 --> 00:17:07.426
這會驅逐一個隨機單元格

00:17:07.994 --> 00:17:10.797
所以像這樣限制
訪問的數量意味着

00:17:10.864 --> 00:17:13.500
我們可能不會在
所有案例中遇到所有競爭

00:17:14.902 --> 00:17:18.839
好了 現在我們談談
它是如何檢測數據競爭的

00:17:19.339 --> 00:17:21.208
線程檢查工具
使用衆所周知的方法

00:17:21.275 --> 00:17:23.377
用向量時鐘檢查競爭

00:17:24.178 --> 00:17:25.345
這如何起作用的？

00:17:25.878 --> 00:17:27.580
每個線程有線程本地存儲

00:17:27.915 --> 00:17:30.651
記錄線程自身的計數器

00:17:31.885 --> 00:17:34.955
以及其他所有線程的計數器

00:17:35.822 --> 00:17:37.991
這個計數器初始化爲0

00:17:38.225 --> 00:17:40.627
每次有線程訪問內存

00:17:41.195 --> 00:17:42.896
計數器就會增加

00:17:43.497 --> 00:17:48.836
例如 線程1訪問了
2個內存位置

00:17:49.236 --> 00:17:52.039
線程2訪問了
22個內存位置

00:17:52.906 --> 00:17:55.342
線程3訪問了
55個內存位置

00:17:56.343 --> 00:17:58.712
這個時間戳
是沒有可比性的

00:17:59.413 --> 00:18:02.182
每個線程使用這些
時間戳或者計數器

00:18:02.249 --> 00:18:06.253
來給其進行的內存訪問排序

00:18:07.955 --> 00:18:10.090
好了 我們回來

00:18:10.824 --> 00:18:13.727
將內存位置帶回來

00:18:13.794 --> 00:18:17.598
及其影子
看看線程是如何交互的

00:18:17.664 --> 00:18:19.333
以及它們如何
更新這裏的計數器

00:18:19.900 --> 00:18:21.802
我們還會加入鎖
線程使用它

00:18:21.869 --> 00:18:24.071
來同步內存位置的訪問

00:18:24.838 --> 00:18:26.473
好了 線程1寫入

00:18:27.174 --> 00:18:29.810
這是行爲良好的線程
它會獲取那個鎖

00:18:30.577 --> 00:18:32.279
它會更新其計數器

00:18:33.146 --> 00:18:35.182
它會寫入到那個內存位置中

00:18:35.749 --> 00:18:37.784
線程檢查工具
現在看到它了

00:18:38.151 --> 00:18:39.887
它會更新影子

00:18:40.721 --> 00:18:44.057
在更新影子之前
它看到影子中什麼都沒有

00:18:44.124 --> 00:18:46.226
沒保存到影子中
意味着

00:18:46.460 --> 00:18:49.763
內存位置之前未被訪問

00:18:50.264 --> 00:18:52.299
所以可以安全地寫入進去

00:18:53.734 --> 00:18:56.770
在釋放鎖之前
線程1會在上面

00:18:56.904 --> 00:18:58.805
更新有自己的時間戳

00:18:59.706 --> 00:19:01.074
然後釋放那個鎖

00:19:01.575 --> 00:19:04.278
現在該線程2去寫入了

00:19:05.012 --> 00:19:08.448
線程2也是行爲非常良好
的線程 它會獲取那個鎖

00:19:09.550 --> 00:19:13.287
像這樣獲取鎖
會讓線程2看到

00:19:13.353 --> 00:19:16.123
線程1的計數器已經增加了

00:19:18.192 --> 00:19:20.194
線程2增加其自身的計數器

00:19:20.260 --> 00:19:22.296
寫入到那個內存位置中

00:19:22.629 --> 00:19:25.332
線程檢查工具
看到它想要更新影子

00:19:26.033 --> 00:19:28.969
它在這裏看到
之前有東西進入影子裏了

00:19:29.036 --> 00:19:31.839
這意味着那個內存位置
已經被訪問了

00:19:31.905 --> 00:19:33.574
所以就會檢查是否有競爭

00:19:36.009 --> 00:19:38.178
通過對比時間戳

00:19:38.245 --> 00:19:41.148
線程檢查工具
看到線程2的同步時間

00:19:41.215 --> 00:19:43.650
是在線程1訪問內存之後

00:19:44.284 --> 00:19:45.786
所以沒有數據競爭

00:19:46.486 --> 00:19:48.255
我們就可以繼續更新

00:19:48.422 --> 00:19:50.457
在釋放鎖之前
線程2會更新

00:19:50.524 --> 00:19:51.892
其自身的時間戳

00:19:52.426 --> 00:19:53.527
然後釋放鎖

00:19:54.561 --> 00:19:56.730
好了 現在該線程3去寫入了

00:19:57.297 --> 00:19:58.932
線程3已經等了很長時間

00:19:58.999 --> 00:20:01.168
很激動地要寫入
那個內存位置中

00:20:01.268 --> 00:20:03.303
結果呢 它把鎖忘了

00:20:03.971 --> 00:20:06.740
它增加計數器
寫入到內存位置

00:20:07.508 --> 00:20:09.610
線程檢查工具
在那裏監督着

00:20:09.910 --> 00:20:14.047
它想更新影子
並檢查有沒有競爭

00:20:15.015 --> 00:20:18.886
線程檢查工具
看到線程3的

00:20:18.952 --> 00:20:20.420
舊視圖實在舊了

00:20:21.154 --> 00:20:23.757
在影子中存儲的
讀取和寫入是發生在

00:20:23.824 --> 00:20:25.659
線程3上次同步之後

00:20:27.060 --> 00:20:29.897
這就允許線程檢查工具
揪出那個錯誤

00:20:37.104 --> 00:20:39.540
關於這個算法
重要是要知道

00:20:39.606 --> 00:20:42.409
我們將與數據競爭相關聯的

00:20:42.476 --> 00:20:44.311
時間敏感性
在這裏不適用

00:20:45.045 --> 00:20:49.049
即使競爭在特定運行中沒有
顯現出來 TSan還是能檢測到

00:20:49.116 --> 00:20:51.285
但可能再次運行
應用程序就會出現

00:20:51.351 --> 00:20:53.220
或者用戶運行你的應用程序

00:20:53.754 --> 00:20:56.723
這讓使用線程檢查工具
更加高效

00:20:56.924 --> 00:21:00.294
相比於調試並
重現那些數據競爭

00:21:00.360 --> 00:21:02.763
在不使用該工具的
普通環境下

00:21:03.964 --> 00:21:05.732
另一個需要記住的是

00:21:05.799 --> 00:21:08.569
線程檢查工具
是運行時錯誤查找工具

00:21:08.635 --> 00:21:10.804
所以它只會找出競爭

00:21:11.071 --> 00:21:13.941
當你提供了足夠的覆蓋面

00:21:14.007 --> 00:21:17.144
所以請在線程檢查工具
啓用時運行你的所有測試

00:21:18.245 --> 00:21:21.315
這就是Xcode 8上新出的
線程檢查工具　用它

00:21:21.715 --> 00:21:24.484
它會找出錯誤
它會讓你的應用程序更好

00:21:32.459 --> 00:21:35.062
現在交給Devin
他會講講我們在

00:21:35.128 --> 00:21:37.130
Clang靜態分析器
上添加的檢查

00:21:43.470 --> 00:21:44.338
謝謝 Anna

00:21:46.106 --> 00:21:49.510
與檢查工具不同
靜態分析器可無需

00:21:49.676 --> 00:21:51.645
運行你的代碼
就能找出錯誤

00:21:52.479 --> 00:21:56.383
其做法是系統性地探測
整個程序的所有路徑

00:21:57.084 --> 00:22:00.888
這讓使其十分適合找出
重現條件很難很極端的錯誤

00:22:01.989 --> 00:22:04.992
它支持Clang
可編譯的所有語言

00:22:05.058 --> 00:22:07.761
所以C
Objective-C和C++

00:22:09.630 --> 00:22:12.966
今年靜態分析器
我們添加了三個新檢查

00:22:13.500 --> 00:22:15.235
本地化能力缺失的檢查

00:22:16.136 --> 00:22:17.938
不正當的實例清理檢查

00:22:18.138 --> 00:22:19.840
在手動保持的釋放代碼中

00:22:20.240 --> 00:22:22.142
還有爲空性違規的檢查

00:22:23.010 --> 00:22:24.344
我來跟大家講講

00:22:25.712 --> 00:22:28.248
在本地化應用中的常見錯誤

00:22:28.382 --> 00:22:30.651
就是忘記本地化UI元素

00:22:31.218 --> 00:22:33.654
這對用戶來說
會是很驚人的事

00:22:34.454 --> 00:22:37.824
他們會以自己的母語
使用你的應用

00:22:37.891 --> 00:22:39.626
不過突然出乎意料地

00:22:39.993 --> 00:22:43.497
你語言中的字符串
出現在他們的UI中

00:22:43.830 --> 00:22:45.933
這不是好的用戶體驗

00:22:46.767 --> 00:22:47.868
我來給演示一下

00:22:47.935 --> 00:22:50.737
靜態分析器
是如何找出這種錯誤的

00:22:56.143 --> 00:22:59.346
好了 我將演示
靜態分析器

00:22:59.413 --> 00:23:00.781
Anna使用的相同應用上

00:23:02.549 --> 00:23:05.519
要運行分析器
你可以去Xcode的產品菜單

00:23:05.586 --> 00:23:06.753
選擇分析

00:23:07.554 --> 00:23:10.157
這會探測大量經過你程序的路徑

00:23:10.224 --> 00:23:12.359
並試圖在每個路徑裏發現錯誤

00:23:13.727 --> 00:23:15.429
就像線程檢查工具

00:23:15.963 --> 00:23:19.166
如果靜態分析器
發現一個問題

00:23:19.466 --> 00:23:22.202
它會將這藍色
靜態分析器圖標

00:23:22.269 --> 00:23:24.638
顯示在Xcode的活動條中

00:23:26.406 --> 00:23:28.876
如果你點擊它
它會給你顯示問題導航器

00:23:29.042 --> 00:23:31.445
看來我們有一個本地化問題

00:23:32.779 --> 00:23:36.183
一個非本地化字符串
流向了面向用戶屬性

00:23:36.617 --> 00:23:38.051
所以我們應將其本地化

00:23:39.152 --> 00:23:41.188
不過看看這個方法

00:23:41.722 --> 00:23:43.857
我沒有看出任何很明顯的錯誤

00:23:44.525 --> 00:23:46.293
我會去點擊診斷功能

00:23:47.427 --> 00:23:49.630
這給我展示了更多的信息

00:23:49.696 --> 00:23:53.066
關於這個非本地化
字符串是如何流向

00:23:53.233 --> 00:23:54.668
面向用戶屬性的

00:23:56.436 --> 00:23:58.972
我可以通過路徑探測器欄
探測這個路徑

00:23:59.406 --> 00:24:01.441
在Xcode編輯器頂部

00:24:02.843 --> 00:24:05.379
通過反向推斷
我能看到這個方法是調用自

00:24:05.445 --> 00:24:07.381
表視圖數據源方法

00:24:07.648 --> 00:24:10.184
之後反過來它將其傳遞到

00:24:10.350 --> 00:24:12.252
這個非本地化的常量字符串

00:24:12.719 --> 00:24:14.121
所以我們將其本地化

00:24:16.190 --> 00:24:18.825
爲此我將使用
NS本地化字符串宏

00:24:21.395 --> 00:24:24.798
這會在運行時
加載一個翻譯版的字符串

00:24:25.866 --> 00:24:28.735
在使用這個宏時
非常重要的是

00:24:28.802 --> 00:24:31.672
同時包括你給譯員的註釋

00:24:31.738 --> 00:24:33.807
來幫助他們正確翻譯字符串

00:24:34.741 --> 00:24:35.776
所以我會說：

00:24:36.176 --> 00:24:37.611
“這是按鈕...

00:24:38.278 --> 00:24:40.414
會重置會話篩選器”

00:24:44.318 --> 00:24:45.152
好了

00:24:45.752 --> 00:24:48.822
我們再次運行分析器
確保我們解決了這個問題

00:24:52.793 --> 00:24:55.329
看起來很好
我切換回幻燈片

00:25:03.670 --> 00:25:07.140
回顧一下 你可以從
產品菜單中運行分析器

00:25:07.407 --> 00:25:10.711
它會將其找到的任何問題
在問題導航器中顯示

00:25:11.645 --> 00:25:16.750
正如我們所見 點擊診斷功能
非常有助於顯示路徑

00:25:17.184 --> 00:25:21.121
這會使問題更易於理解
並且最終修復它

00:25:26.393 --> 00:25:29.863
我們看到分析器可以
找到缺失本地化功能的地方

00:25:30.497 --> 00:25:33.233
但這也警告我們
當我們忘記給

00:25:33.567 --> 00:25:35.769
譯員提供註釋

00:25:36.670 --> 00:25:40.541
這裏我提供了零的註釋
沒有一點幫助

00:25:40.874 --> 00:25:42.910
所以分析器會警告

00:25:44.478 --> 00:25:45.812
你可以把這些檢查打開

00:25:45.879 --> 00:25:49.416
其他靜態分析器
檢查在項目構建設置中

00:25:49.483 --> 00:25:51.318
靜態分析器的部分

00:25:52.052 --> 00:25:55.822
本地化功能缺失的檢查
會由Xcode自動打開

00:25:56.156 --> 00:25:59.193
如果你的項目擁有
不止一種語言的本地化版本

00:26:00.427 --> 00:26:02.829
註釋缺失的檢查
是默認關閉的

00:26:02.930 --> 00:26:05.165
但你一定要打開它

00:26:05.232 --> 00:26:09.236
如果你不用其他方式
將這些註釋傳達給你的譯員

00:26:10.070 --> 00:26:13.740
例如 你可能已經直接
在字符串文件中這麼做了

00:26:18.478 --> 00:26:21.048
今年我們還改進了
dealloc檢查

00:26:21.148 --> 00:26:23.183
在你的手動保留釋放代碼中

00:26:24.218 --> 00:26:26.854
在手動保持釋放下
非常重要的是

00:26:27.454 --> 00:26:30.090
不要釋放實例變量
合成用於

00:26:30.157 --> 00:26:32.426
dealloc內的分配屬性

00:26:32.993 --> 00:26:35.495
如果你那麼做
這會導致過度釋放

00:26:35.562 --> 00:26:39.900
當那個值的所有者也釋放它
這會使你的程序崩潰

00:26:40.601 --> 00:26:42.669
所以現在分析器
放出了警告

00:26:44.505 --> 00:26:47.274
另一方面
你必須釋放實例變量

00:26:47.341 --> 00:26:49.977
合成用於保持或複製屬性

00:26:50.210 --> 00:26:52.279
因爲如果你不這樣做
它們會泄露

00:26:52.880 --> 00:26:54.715
分析器同樣也會警告

00:26:56.383 --> 00:26:57.217
耶！

00:26:59.520 --> 00:27:02.322
這真是非常棒的檢查

00:27:02.789 --> 00:27:06.793
我們運行的每個手動
保持釋放項目中 它都會

00:27:07.027 --> 00:27:07.961
找出一個錯誤

00:27:08.262 --> 00:27:09.263
所以試一下

00:27:11.565 --> 00:27:14.935
當然去除保持釋放問題
最好的方法

00:27:15.035 --> 00:27:17.971
是將你的項目
升級到自動引用計數

00:27:22.176 --> 00:27:24.711
幸運的是 Xcode可以
幫你自動完成這些

00:27:24.778 --> 00:27:26.213
如果你去編輯菜單

00:27:26.480 --> 00:27:29.183
選擇轉換到
Objective-C ARC

00:27:29.950 --> 00:27:32.386
這會讓編譯器
爲你處理所有的麻煩

00:27:32.452 --> 00:27:34.087
關於保持釋放

00:27:36.990 --> 00:27:38.258
終於在今年

00:27:38.592 --> 00:27:40.894
我們給爲空性違規
添加了一個檢查

00:27:41.962 --> 00:27:45.365
這是基於去年的成果
我們給SDK加註釋

00:27:45.432 --> 00:27:49.570
來表示方法或屬性
是接收還是返回零

00:27:50.637 --> 00:27:54.608
例如 Core Location的
時間戳屬性是非空的

00:27:55.075 --> 00:27:57.244
這是因爲每次的位置測量

00:27:57.678 --> 00:27:59.980
也有對應的日期和時間

00:28:00.914 --> 00:28:03.016
相比之下
其底層屬性可爲空

00:28:03.650 --> 00:28:06.653
這是因爲這個屬性會返回零

00:28:07.087 --> 00:28:10.557
當這個位置不是
室內定位激活的場地

00:28:12.492 --> 00:28:14.962
你應該給自己標頭註釋爲空性

00:28:15.062 --> 00:28:17.164
因爲它會啓用
新的程序和模型

00:28:17.631 --> 00:28:20.501
可以將你的爲空性預期直接

00:28:20.567 --> 00:28:22.236
傳達到客戶那裏

00:28:22.903 --> 00:28:25.205
這很重要 因爲違反

00:28:25.272 --> 00:28:28.842
這些預期 可能會引起
崩潰或意想不到的行爲

00:28:29.710 --> 00:28:31.445
事實上 我們認爲它如此重要

00:28:31.578 --> 00:28:35.215
以至於將它內置到Swift中
那裏的可選類型要求你

00:28:35.282 --> 00:28:37.518
先檢查零 之後再使用值

00:28:38.619 --> 00:28:40.888
這在Objective-C
中也很重要

00:28:41.288 --> 00:28:45.325
所以我們將爲空性違規的檢查
添加到靜態分析器

00:28:46.360 --> 00:28:48.729
而且這個檢查特別適用於

00:28:48.795 --> 00:28:51.431
混合Swift和
Objective-C代碼項目

00:28:52.199 --> 00:28:53.867
它會發現兩種問題

00:28:54.668 --> 00:28:56.670
在代碼中可能有邏輯問題

00:28:56.737 --> 00:28:58.872
可能你在錯誤時間返回零

00:28:59.173 --> 00:29:01.441
或者你可能會有錯誤的註釋

00:29:02.276 --> 00:29:03.710
所以我們看看如何修復

00:29:03.777 --> 00:29:06.280
這兩種問題

00:29:08.482 --> 00:29:12.986
一個常見錯誤是
從零初始化局部變量

00:29:13.220 --> 00:29:15.522
之後填充進一連串

00:29:15.589 --> 00:29:17.324
非窮舉的分支

00:29:18.425 --> 00:29:19.693
例如 這個方法

00:29:19.927 --> 00:29:22.629
返回一個位置的簡短說明

00:29:23.163 --> 00:29:24.364
要麼是城市的名字

00:29:24.731 --> 00:29:27.100
或國家
含有着這個位置

00:29:28.035 --> 00:29:30.671
但我們沒能考慮到
一個很重要的情況

00:29:31.605 --> 00:29:33.841
如果這個位置是
位於國際海域呢？

00:29:34.441 --> 00:29:36.510
那這既不是城市
也不是國家

00:29:36.577 --> 00:29:39.713
所以這個方法會
不出意外地返回零

00:29:40.614 --> 00:29:42.482
然後分析器會告訴我們

00:29:43.550 --> 00:29:44.418
幸運的是

00:29:45.185 --> 00:29:46.320
這也很棒

00:29:50.757 --> 00:29:52.793
幸運的是
這很容易修復的

00:29:53.026 --> 00:29:55.729
你要做的是
初始化你的局部變量

00:29:57.664 --> 00:30:00.000
通過非零默認值

00:30:00.667 --> 00:30:02.870
在此例中
我們使用常量字符串Earth

00:30:03.070 --> 00:30:05.772
當然 要確保將其本地化

00:30:08.609 --> 00:30:11.144
另一方面
可能是你的代碼

00:30:11.445 --> 00:30:13.780
在實施方面完全沒問題

00:30:14.081 --> 00:30:15.983
而是註釋出現錯誤

00:30:16.950 --> 00:30:19.453
我們發現其經常
發生的一個原因

00:30:19.686 --> 00:30:23.957
是當你使用方便的
NS_ASSUME_NONNULL_BEGIN和END的宏

00:30:25.092 --> 00:30:27.160
這些宏會將
標頭的一部分包起來

00:30:27.961 --> 00:30:30.264
而且它們包起來的內部範圍

00:30:30.397 --> 00:30:32.833
那些類型會隱含地成爲非空

00:30:33.567 --> 00:30:35.736
這可以節省你很多的鍵入

00:30:36.236 --> 00:30:38.405
但這也讓你很容易忘記

00:30:38.705 --> 00:30:40.474
將屬性標記爲可空

00:30:41.341 --> 00:30:44.411
在這個例子中
壓力特性會返回零

00:30:44.478 --> 00:30:46.547
如果設備沒有氣壓計

00:30:47.414 --> 00:30:50.617
但是屬性是隱含成爲非空的

00:30:52.352 --> 00:30:54.821
幸運的是
這裏也很容易修復

00:30:55.322 --> 00:30:57.591
我們可以明確地
將屬性標記爲

00:30:57.658 --> 00:30:59.760
可空
在那個區域內部

00:30:59.993 --> 00:31:02.996
這會告訴客戶
不要期待壓力數據

00:31:03.063 --> 00:31:04.565
是一直可用的

00:31:07.334 --> 00:31:09.970
你的確需要注意這個

00:31:10.404 --> 00:31:13.240
這是因爲你API的
爲空性是一種契約

00:31:13.540 --> 00:31:16.343
所以你不應該爲滿足
分析器而更改它

00:31:17.277 --> 00:31:19.713
相反 你應該仔細考慮你想

00:31:19.780 --> 00:31:22.282
公開的API並使用它

00:31:23.884 --> 00:31:25.986
如果你決定改變你的API

00:31:26.253 --> 00:31:29.256
那你還要仔細考慮向後兼容

00:31:30.057 --> 00:31:32.392
這在Swift尤爲重要

00:31:32.960 --> 00:31:35.596
因爲 爲空性會改變
類型的導入方式

00:31:38.632 --> 00:31:40.767
你也可能處在這樣的情況下

00:31:41.168 --> 00:31:43.804
你無法改變方法的實現

00:31:43.871 --> 00:31:45.072
及其註釋

00:31:45.706 --> 00:31:49.209
在這些情況下 你可以通過
轉換來壓制分析器診斷功能

00:31:50.277 --> 00:31:53.080
它經常出現的一個原因要歸咎於

00:31:53.347 --> 00:31:56.583
當違反前提條件時
會防守性返回零的方法

00:31:57.284 --> 00:31:59.152
在這個例子中
該方法返回零

00:31:59.219 --> 00:32:01.221
當索引越界的時候

00:32:02.155 --> 00:32:05.092
如果有依靠這種行爲
的現有代碼

00:32:05.792 --> 00:32:07.261
那你不能移除那個檢查

00:32:07.628 --> 00:32:09.363
而且你不能
用一個證書替代它

00:32:10.030 --> 00:32:13.800
相反 正確做法是告訴分析器
這是你特意做的

00:32:14.134 --> 00:32:16.670
通過將返回值轉化爲非空

00:32:22.075 --> 00:32:25.279
所以這是靜態分析器
和Xcode 8的新功能

00:32:32.586 --> 00:32:33.520
我們做個總結

00:32:34.621 --> 00:32:37.024
今天我們講了
三個很棒的工具

00:32:37.824 --> 00:32:39.793
這些工具找到真正的錯誤

00:32:40.561 --> 00:32:43.497
地址檢查工具和
線程檢查工具在運行時

00:32:43.564 --> 00:32:45.232
查找內存崩潰和線程問題

00:32:45.599 --> 00:32:49.469
靜態分析器甚至不用運行
你的代碼就能發現錯誤

00:32:49.837 --> 00:32:53.040
所以請在自己的項目中
使用這些工具

00:32:53.307 --> 00:32:57.010
它們會在用戶發現錯誤
之前幫你找到錯誤

00:32:58.312 --> 00:33:01.281
如果你有興趣瞭解更多信息
你可以去演講網站

00:33:02.349 --> 00:33:04.284
這裏還有幾個相關演講

00:33:04.351 --> 00:33:06.086
我們認爲可能會幫助到你

00:33:07.521 --> 00:33:08.355
謝謝大家