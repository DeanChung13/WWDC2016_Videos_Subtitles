00:00:20.087 --> 00:00:23.323
製造非凡的音頻效果

00:00:23.457 --> 00:00:25.893
音頻效果最佳實踐和API指南

00:00:26.226 --> 00:00:27.060
好

00:00:28.962 --> 00:00:30.163
下午好

00:00:30.998 --> 00:00:34.334
多少人想開發一款
音頻效果特別棒的應用

00:00:34.401 --> 00:00:35.903
但覺得可能會很困難？

00:00:36.803 --> 00:00:38.605
或者 多少人想要更多地

00:00:38.672 --> 00:00:40.774
關注應用程序
整體的用戶體驗

00:00:40.841 --> 00:00:43.010
但最終在音頻上
多花費了一點時間？

00:00:43.777 --> 00:00:46.180
我們一直以來都在努力
幫助你輕鬆解決這些問題

00:00:46.580 --> 00:00:49.449
我叫Saleem
Core Audio團隊的技術人員

00:00:49.516 --> 00:00:51.018
歡迎大家來到今天

00:00:51.084 --> 00:00:53.420
關於製造非凡音頻效果的
會議環節

00:00:54.521 --> 00:00:57.191
讓我們整體看下
今天我們爲大家準備了什麼

00:00:58.759 --> 00:01:00.961
我們會先開始介紹
AVFoundation框架

00:01:01.261 --> 00:01:04.230
我們有種類廣泛的
高層API

00:01:04.665 --> 00:01:06.800
可以讓你輕鬆
播放和錄製音頻

00:01:08.101 --> 00:01:12.739
對於更高級的用例 我們提供
AudioToolbox框架

00:01:13.607 --> 00:01:15.642
你可能聽說過
AudioUnits

00:01:15.709 --> 00:01:17.778
這些是基本的
組成模塊

00:01:19.246 --> 00:01:22.349
如果你必須使用
MIDI設備或MIDI數據

00:01:22.416 --> 00:01:23.951
我們還提供CoreMIDI框架

00:01:24.952 --> 00:01:27.521
對於遊戲開發
我們提供OpenAL

00:01:29.790 --> 00:01:31.658
在過去兩年裏
我們也一直在添加

00:01:31.725 --> 00:01:33.694
很多新的API和功能

00:01:34.261 --> 00:01:35.896
你可以看到
你可以通過很多方法

00:01:35.963 --> 00:01:37.931
在你的應用中
使用音頻

00:01:38.265 --> 00:01:40.434
所以 我們今天的目標是
指導你

00:01:40.501 --> 00:01:43.670
針對你的應用需求
選擇正確的API

00:01:44.071 --> 00:01:47.307
但不必擔心 我們也有
一些新東西與大家分享

00:01:50.277 --> 00:01:51.645
所以 按今天的日程表

00:01:51.712 --> 00:01:55.048
我們會先了解我們幾個平臺的
一些基本的設置步驟

00:01:55.816 --> 00:01:58.752
然後 我們會直接深入瞭解
一些簡單和高級的播放

00:01:58.819 --> 00:02:00.153
和錄製情景

00:02:00.921 --> 00:02:02.890
我們會簡要討論下多聲道音頻

00:02:03.790 --> 00:02:06.693
在隨後的介紹中
我們將瞭解下實時音頻

00:02:07.127 --> 00:02:10.297
以及你製造自己音頻效果、
樂器和生成器的方法

00:02:10.364 --> 00:02:11.798
最後以MIDI的介紹結尾

00:02:12.266 --> 00:02:13.500
好 讓我們開始吧

00:02:15.936 --> 00:02:20.274
iOS、watchOS和tvOS
都有相當豐富的音頻功能

00:02:20.340 --> 00:02:22.209
以及衆多寫入功能

00:02:22.676 --> 00:02:27.114
這樣 用戶才能撥打電話
播放音頻、玩遊戲

00:02:27.314 --> 00:02:29.016
和使用各種提高效率的應用

00:02:29.082 --> 00:02:32.386
用戶可以同時
或獨立進行這些操作

00:02:33.287 --> 00:02:36.657
所以操作系統管理了
大量默認的音頻行爲

00:02:36.723 --> 00:02:39.560
以便提供一致的
用戶體驗

00:02:41.395 --> 00:02:44.665
讓我們通過圖表瞭解爲什麼
音頻是一種基於管理的服務

00:02:46.433 --> 00:02:47.701
所以 你擁有一件設備

00:02:48.468 --> 00:02:51.138
設備有若干的
輸入和輸入

00:02:53.140 --> 00:02:55.075
然後 有操作系統

00:02:55.909 --> 00:02:59.246
操作系統可能包含大量應用
有些應用使用音頻

00:03:00.147 --> 00:03:01.949
最後 這裏是你的應用

00:03:03.951 --> 00:03:07.287
所以AVAudioSession是
你的開發者界面

00:03:07.387 --> 00:03:09.957
你可以通過該界面
向系統表達你的應用需求

00:03:11.024 --> 00:03:13.360
讓我們瞭解下這方面的
詳細內容

00:03:16.163 --> 00:03:19.266
類別表達
應用的高級別需求

00:03:19.800 --> 00:03:21.902
我們提供模式和類別選項

00:03:21.969 --> 00:03:25.205
可以幫助你進一步定製
和專門設計你的應用

00:03:28.175 --> 00:03:30.611
如果你喜歡一些
更高級的用例

00:03:30.677 --> 00:03:33.046
比如輸入選擇
你可能需要能夠選擇

00:03:33.113 --> 00:03:35.782
iPhone的前置麥克風
而不是底部麥克風

00:03:36.483 --> 00:03:38.051
如果你處理的是
多聲道音頻

00:03:38.118 --> 00:03:40.654
以及tvOS上的多聲道內容
你可能對聲道數

00:03:40.721 --> 00:03:42.189
這樣的東西感興趣

00:03:43.156 --> 00:03:45.692
如果你將USB音頻設備
連接到iPhone

00:03:45.759 --> 00:03:47.995
你可能對採樣率
這樣的東西感興趣

00:03:52.666 --> 00:03:56.303
所以 當你的應用準備好
經配置可使用音頻時

00:03:56.570 --> 00:03:58.705
它會通知系統
應用會話

00:03:59.573 --> 00:04:01.575
該過程會配置
設備的硬件

00:04:01.642 --> 00:04:03.310
從而滿足你應用的需求

00:04:03.577 --> 00:04:07.214
並且實際可能對系統中
其它音頻應用造成幹擾

00:04:07.381 --> 00:04:09.950
或者相互混雜 或者
降低其它音頻應用的音量

00:04:14.054 --> 00:04:17.591
瞭解下AVAudioSession
的一些基本使用步驟

00:04:18.024 --> 00:04:20.459
第一步是
註冊以獲取通知

00:04:21.361 --> 00:04:24.364
三種最重要的通知是
中斷通知

00:04:24.431 --> 00:04:27.634
路徑變更通知以及
mediaServicesWereReset通知

00:04:28.902 --> 00:04:32.172
你可以在激活會話之前
註冊以接收這些通知

00:04:32.239 --> 00:04:34.775
通過幾張幻燈片
我將展示如何管理通知

00:04:37.244 --> 00:04:39.580
接下來 基於
你應用的高級別需求

00:04:39.646 --> 00:04:42.549
你將需要設置適當的
類別模式和選項

00:04:43.250 --> 00:04:45.018
那麼 讓我們看幾個例子

00:04:46.854 --> 00:04:48.889
假如 我正在開發
一款提高效率的應用

00:04:48.956 --> 00:04:51.425
在這個應用中
我想要在用戶保存文檔時

00:04:51.491 --> 00:04:53.193
播放簡單的聲音

00:04:53.961 --> 00:04:56.496
這裏 我們知道音頻
能夠增強體驗

00:04:56.563 --> 00:04:58.332
但卻不是必要的

00:04:58.699 --> 00:05:01.401
在這種情況下 我想
使用AmbientCategory

00:05:02.669 --> 00:05:04.938
這個類別遵循振鈴開關

00:05:05.472 --> 00:05:07.441
音頻不在後臺播放

00:05:07.708 --> 00:05:09.343
而始終與其它應用音頻混雜

00:05:12.679 --> 00:05:16.149
若我在開發播客應用
我應該使用PlaybackCategory

00:05:17.317 --> 00:05:18.652
SpokenAudio模式

00:05:19.586 --> 00:05:21.722
這裏 我們能看到
這個應用位置將幹擾

00:05:21.822 --> 00:05:23.690
系統上的其它應用

00:05:25.559 --> 00:05:28.562
現在 如果你希望音頻繼續
在後臺播放

00:05:28.629 --> 00:05:32.199
你也需要在info.plist中
指定後臺音頻鍵

00:05:32.399 --> 00:05:34.668
這本質上也是
會話屬性

00:05:34.735 --> 00:05:36.904
只不過是通過
不同的方式表達

00:05:39.907 --> 00:05:41.041
而對於導航應用

00:05:41.108 --> 00:05:43.777
讓我們瞭解一下如何配置
導航提示

00:05:44.378 --> 00:05:46.680
你應使用
PlaybackCategory

00:05:47.447 --> 00:05:48.749
以及DefaultMode

00:05:49.183 --> 00:05:51.285
這裏有幾個
相關的選項

00:05:51.485 --> 00:05:54.087
你應同時使用
InterruptSpokenAudio

00:05:54.154 --> 00:05:56.990
AndMixWithOthers
以及duckOthers

00:05:57.758 --> 00:06:00.127
所以 如果你正在收聽
播客 同時進行導航

00:06:00.194 --> 00:06:02.329
就會出現導航提示
表明

00:06:02.396 --> 00:06:03.997
500英尺後左轉

00:06:04.064 --> 00:06:06.600
提示實際上會中斷播客應用

00:06:07.367 --> 00:06:08.836
如果你在聽音樂

00:06:08.936 --> 00:06:12.039
提示會降低音樂音量
並混雜在音樂中

00:06:13.740 --> 00:06:17.144
對於這種應用 你也應
使用後臺音頻鍵

00:06:20.714 --> 00:06:24.051
接下來 讓我們看看如何
對會話激活進行管理

00:06:25.786 --> 00:06:27.554
所以 激活意味着什麼？

00:06:27.754 --> 00:06:29.890
激活你的會話 會通知系統

00:06:29.957 --> 00:06:32.759
配置硬件
以適應應用的需求

00:06:33.794 --> 00:06:35.896
比如
我有一個應用

00:06:35.963 --> 00:06:37.831
類別爲PlayAndRecord

00:06:38.465 --> 00:06:41.235
當我激活我的會話
系統會配置硬件

00:06:41.301 --> 00:06:43.470
使用輸入和輸出

00:06:46.907 --> 00:06:49.510
現在 如果我
在使用音樂應用聽音樂時

00:06:49.576 --> 00:06:51.178
激活會話 會怎麼樣？

00:06:51.645 --> 00:06:55.048
這裏 我們可以看到
系統當前狀態設置爲僅播放

00:06:56.083 --> 00:06:57.718
所以 當我激活會話時

00:06:58.252 --> 00:07:02.689
我通知系統 針對輸入
和輸出進行硬件配置

00:07:03.457 --> 00:07:05.826
而且 既然我
處在不可混雜的應用位置

00:07:05.893 --> 00:07:07.427
我中斷了音樂應用

00:07:10.264 --> 00:07:12.799
所以 比如我的應用
進行了快速錄音

00:07:12.866 --> 00:07:15.135
一旦完成 我就停用會話

00:07:16.136 --> 00:07:19.206
如果我選擇通知其它應用
我已經停用會話

00:07:19.273 --> 00:07:21.775
我們將看到
音樂應用恢復播放

00:07:25.279 --> 00:07:28.849
接下來 讓我們看下如何
處理我們註冊接收的通知

00:07:31.084 --> 00:07:33.420
我們首先看一下
中斷通知

00:07:33.487 --> 00:07:35.422
我們會研究一個案例
案例中 你的應用

00:07:35.489 --> 00:07:37.291
沒有播放UI

00:07:37.858 --> 00:07:40.194
首先獲取
interruptionType

00:07:40.761 --> 00:07:42.763
如果這是
中斷的開始

00:07:43.197 --> 00:07:44.932
你的會話已經停用

00:07:45.799 --> 00:07:47.935
所以播放器已經暫停

00:07:48.001 --> 00:07:51.171
你將利用這段時間
更新你的任何內部狀態

00:07:52.940 --> 00:07:54.741
如果你收到結束中斷

00:07:55.342 --> 00:07:57.244
你會去激活會話

00:07:57.511 --> 00:08:00.514
啓動播放器
同時更新內部狀態

00:08:01.949 --> 00:08:05.419
我們看下這個過程在擁有
播放UI的應用中有什麼不同

00:08:07.621 --> 00:08:09.690
你接收開始中斷的
通知

00:08:09.857 --> 00:08:12.860
你的會話停用
你更新內部狀態

00:08:13.293 --> 00:08:14.962
而且這次要同時更新UI

00:08:15.229 --> 00:08:17.331
如果你有播放/暫停按鈕

00:08:17.397 --> 00:08:20.200
這種情況下 你應接着
將按鈕設置爲“播放”

00:08:22.369 --> 00:08:24.705
現在 當你接收到
結束中斷通知

00:08:25.038 --> 00:08:27.941
你應該查看並瞭解
shouldResume選項是否提交進來

00:08:28.509 --> 00:08:31.812
如果已經提交進來 那麼你
可以繼續激活你的會話

00:08:32.011 --> 00:08:34.815
開始播放 同時更新
內部狀態和UI

00:08:35.515 --> 00:08:36.517
如果沒有提交進來

00:08:36.582 --> 00:08:39.686
你應等到用戶
明確地恢復播放後

00:08:42.655 --> 00:08:45.792
應特別注意的是
你的中斷不一定是配對的

00:08:45.859 --> 00:08:49.396
所以 不是每個開始中斷
隨後都匹配一個結束中斷

00:08:49.963 --> 00:08:53.800
一個例子就是
彼此中斷的媒體播放器應用

00:08:57.471 --> 00:08:59.740
現在 讓我們看下
如何處理路徑變更

00:09:00.674 --> 00:09:02.910
路徑變更的
發生原因有很多：

00:09:03.277 --> 00:09:06.847
可能是連接設備變化了
可能是類別變化了

00:09:07.214 --> 00:09:09.850
可能是你選擇了
不同的數據源或端口

00:09:10.651 --> 00:09:13.320
首先要獲取
routeChangeReason

00:09:15.389 --> 00:09:18.859
如果你得到的原因是
媒體播放器應用中

00:09:18.926 --> 00:09:20.427
原有設備不可用

00:09:20.494 --> 00:09:22.563
此時你應停止播放

00:09:22.629 --> 00:09:26.600
這種情況的一個例子是
如果你的用戶使用耳機

00:09:26.667 --> 00:09:28.001
收聽音樂然後拔下耳機

00:09:28.068 --> 00:09:30.504
他們不會想
讓音樂立即通過

00:09:30.804 --> 00:09:32.272
揚聲器恢復播放

00:09:34.675 --> 00:09:37.978
對於更高級的用例 若你
收到oldDeviceUnavailable

00:09:38.045 --> 00:09:40.681
或newDeviceAvailable
routeChangeReason

00:09:40.747 --> 00:09:43.450
你可能需要在特定會話屬性
應用到你的應用時

00:09:43.517 --> 00:09:45.185
重新評估這些屬性

00:09:48.388 --> 00:09:50.958
最後 讓我們看下
如何處理設置了通知的

00:09:51.024 --> 00:09:52.693
媒體服務

00:09:53.393 --> 00:09:56.029
這種通知很少發生
但也確實會收到

00:09:56.096 --> 00:09:58.332
因爲我們不能確保
demon程序永遠運行

00:09:59.766 --> 00:10:01.201
這裏需要特別注意的是

00:10:01.268 --> 00:10:04.605
你的AVAudioSession
sharedInstance仍有效

00:10:06.006 --> 00:10:08.976
你將需要重置
類別模式和其它選項

00:10:11.011 --> 00:10:13.413
你也需要破壞和重建
你的播放器對象

00:10:13.480 --> 00:10:15.082
如AVAudioEngine

00:10:15.616 --> 00:10:18.085
遠程I/O
以及其它播放器對象

00:10:19.653 --> 00:10:22.856
我們提供在設備上
進行此測試的途徑

00:10:22.923 --> 00:10:25.726
路徑是設置——開發者
——重設媒體服務

00:10:29.830 --> 00:10:32.633
好 大致重述下
使用AVAudioSession的

00:10:32.699 --> 00:10:34.868
四大步驟
基本步驟

00:10:34.935 --> 00:10:36.603
你註冊以接收通知

00:10:36.670 --> 00:10:39.306
你設置適當的
類別模式和選項

00:10:39.373 --> 00:10:41.208
你對會話激活進行管理

00:10:41.408 --> 00:10:43.110
並且處理各種通知

00:10:43.477 --> 00:10:45.312
讓我們瞭解下今年的
一些新內容

00:10:46.713 --> 00:10:49.416
今年的新內容中 我們添加了
兩個新的類別選項：

00:10:49.483 --> 00:10:53.487
將allowAirPlay和allowBluetoothA2DP
添加到PlayAndRecord類別

00:10:55.122 --> 00:10:58.425
所以 這意味着你現在可以
在使用藍牙或AirPlay終端

00:10:58.492 --> 00:11:00.360
播放時 同時使用麥克風

00:11:02.095 --> 00:11:03.830
如果這是你應用的用例

00:11:03.897 --> 00:11:06.733
繼續操作 設置
類別和選項

00:11:06.800 --> 00:11:08.235
然後允許用戶從

00:11:08.302 --> 00:11:11.672
MPVolumeView或
 “控制中心”中選擇路徑

00:11:15.209 --> 00:11:17.344
我們同時爲
AVAudioSessionPortDescription

00:11:17.411 --> 00:11:19.446
上的VoIP應用添加了新屬性

00:11:19.513 --> 00:11:21.782
可以決定當前路徑
是否已經激活

00:11:21.849 --> 00:11:23.851
硬件語音處理

00:11:24.751 --> 00:11:27.487
所以 如果你的用戶
連接到擁有硬件語音處理的

00:11:27.721 --> 00:11:30.991
CarPlay系統或
藍牙免提耳機

00:11:31.391 --> 00:11:34.795
你可以使用該屬性禁用
你的軟件語音處理功能

00:11:34.862 --> 00:11:36.830
這樣你就不會對音頻
重複處理了

00:11:39.066 --> 00:11:42.503
如果你已經使用Apple的
內置語音處理輸入/輸出設備

00:11:42.569 --> 00:11:44.238
你無需擔心這一點

00:11:45.205 --> 00:11:47.908
今年新內容中 我們也引進了
CallKit框架

00:11:48.175 --> 00:11:51.211
爲使你瞭解如何使用
CallKit增強你的VoIP應用

00:11:51.278 --> 00:11:52.679
本週早些時候
安排了場演講

00:11:52.746 --> 00:11:55.349
如果你錯過了
可以到網上收看

00:11:58.018 --> 00:12:00.220
所以 這只是
AVAudioSession的概況

00:12:00.287 --> 00:12:02.823
在之前的演講中 我們
對此話題進行了許多深入介紹

00:12:02.890 --> 00:12:06.727
所以 我們鼓勵你到網上查看
之前的視頻和編程指南

00:12:09.763 --> 00:12:10.697
好 我們繼續

00:12:11.098 --> 00:12:14.034
AVAudioSession適用於
你平臺的情況下 你完成設置

00:12:14.234 --> 00:12:17.771
現在 我們看下如何在應用中
進行簡單的音頻播放和錄製

00:12:19.873 --> 00:12:21.942
我們先看一下
AVFoundation框架

00:12:22.476 --> 00:12:24.978
這裏有很多級別
可以處理這種任務

00:12:25.045 --> 00:12:26.647
我們有AVAudioPlayer

00:12:26.813 --> 00:12:29.650
AVAudioRecorder
以及AVPlayer等級別

00:12:32.352 --> 00:12:35.455
AVAudioPlayer是文件中
播放音頻的最簡單方法

00:12:36.056 --> 00:12:38.325
我們支持各種格式

00:12:39.359 --> 00:12:41.762
我們提供所有
基本的播放操作

00:12:42.462 --> 00:12:44.264
我們同時支持
一些高級的操作

00:12:44.331 --> 00:12:45.866
比如 設置音量

00:12:46.166 --> 00:12:48.202
你可以按照聲道獲得計量

00:12:48.268 --> 00:12:51.038
你可以循環播放
調整播放速度

00:12:51.405 --> 00:12:53.173
進行立體聲調製

00:12:54.575 --> 00:12:57.778
如果你使用iOS或tvOS
你可以進行聲道分配

00:13:00.747 --> 00:13:03.050
如果你有多個文件
要進行播放

00:13:03.116 --> 00:13:05.652
你可以使用多個
AVAudioPlayer對象

00:13:05.719 --> 00:13:07.788
也可以同步你的播放

00:13:09.957 --> 00:13:12.426
今年新內容中
加入了一種方法 可以允許你

00:13:12.492 --> 00:13:14.962
在特定時間內
逐漸降到某個音量

00:13:18.298 --> 00:13:22.035
看下代碼示例 瞭解你在應用中
如何使用AVAudioPlayer

00:13:22.970 --> 00:13:26.373
比如 我還是在開發和構建
一個簡單的提高效率的應用

00:13:26.440 --> 00:13:27.908
我想要
在用戶保存文檔時

00:13:27.975 --> 00:13:29.643
播放確認音頻

00:13:30.410 --> 00:13:35.616
這種情況下 我有AVAudioPlayer
和鏈接到我級別中資源的URL

00:13:37.117 --> 00:13:41.054
在設置功能中 我繼續操作
使用我URL的內容

00:13:41.388 --> 00:13:45.392
創建AVAudioPlayer對象
同時我準備好播放器進行播放

00:13:47.528 --> 00:13:50.697
在saveDocument功能中
我可能進行一些工作

00:13:50.764 --> 00:13:52.566
瞭解下文檔是否
保存成功

00:13:52.633 --> 00:13:54.868
如果已保存 我只需播放文件

00:13:55.068 --> 00:13:56.069
非常簡單

00:13:58.605 --> 00:14:00.340
現在 讓我們看下
AVAudioRecorder

00:14:01.742 --> 00:14:04.111
這是將音頻錄製到文件的
最簡單方法

00:14:04.745 --> 00:14:06.713
你可以錄製指定的時長

00:14:06.780 --> 00:14:09.616
或者錄製到
用戶明確要求停止的時候

00:14:09.816 --> 00:14:12.186
你基於聲道
獲得計量

00:14:12.452 --> 00:14:14.922
我們支持各種編碼格式

00:14:16.256 --> 00:14:19.960
所以 要設置格式 我們使用
Recorder Settings Dictionary

00:14:20.093 --> 00:14:21.628
這是由鍵組成的字典

00:14:21.695 --> 00:14:25.465
包含的鍵列表可使你
設置各種格式參數

00:14:25.532 --> 00:14:28.268
例如採樣率和聲道數

00:14:28.569 --> 00:14:30.137
若你使用Linear PCM數據

00:14:30.204 --> 00:14:32.773
你可以調整位深度
和字節順序等

00:14:32.840 --> 00:14:34.441
如果你使用編碼格式

00:14:34.508 --> 00:14:36.710
你可以調整質量
和比特率等

00:14:37.244 --> 00:14:40.314
讓我們看下代碼示例 瞭解如何使用
AVAudioRecorder

00:14:42.683 --> 00:14:45.719
所以 我首先做的是
創建格式設置

00:14:46.119 --> 00:14:49.356
這裏 我創建了一個
比特率相當高的AAC文件

00:14:50.557 --> 00:14:54.494
然後 我要做的是創建
AVAudioRecorder對象

00:14:54.995 --> 00:14:56.997
包含指向文件位置的URL

00:14:57.564 --> 00:14:59.499
以及我剛剛定義的
格式設置

00:15:01.935 --> 00:15:04.538
在這個例子中
有一個簡單的按鈕

00:15:04.605 --> 00:15:06.306
我可以用它來切換
錄音機的狀態

00:15:06.473 --> 00:15:09.343
所以我按下這個按鈕時
如果錄音機正在錄製

00:15:09.476 --> 00:15:11.111
我接着操作 停止錄製

00:15:11.478 --> 00:15:13.080
我開始錄製

00:15:13.146 --> 00:15:16.617
我可以使用錄音機的
內置儀表向UI提供反饋

00:15:19.253 --> 00:15:20.988
最後讓我們看下AVPlayer

00:15:22.389 --> 00:15:26.260
AVPlayer不僅適用於本地文件
而且適用於流媒體內容

00:15:26.994 --> 00:15:29.363
你擁有所有的標準控件

00:15:30.531 --> 00:15:32.399
我們同時提供你可以直接

00:15:32.466 --> 00:15:35.102
使用的內置用戶界面
比如AVPlayerView

00:15:35.169 --> 00:15:36.870
以及AVPlayerViewController

00:15:38.372 --> 00:15:40.707
AVPlayer也適用於
視頻內容

00:15:40.774 --> 00:15:43.510
今年 我們在AVPlayer中
添加了若干新功能

00:15:43.577 --> 00:15:45.512
如果想了解我們做出的改進

00:15:45.579 --> 00:15:48.415
你可查看AVFoundation
Playback的新進展

00:15:48.482 --> 00:15:50.851
如果你錯過了那部分
你可以到網上進行觀看

00:15:53.787 --> 00:15:54.888
高級播放和錄製

00:15:54.955 --> 00:15:58.258
好 目前我們已經瞭解了
一些非常簡單的

00:15:58.325 --> 00:15:59.826
播放和錄製案例

00:16:00.427 --> 00:16:02.663
現在 讓我們看一下
一些更高級的用例

00:16:04.364 --> 00:16:07.968
高級用例不僅包括
從文件中播放音頻

00:16:08.035 --> 00:16:10.237
而且包括處理
緩衝音頻數據

00:16:12.773 --> 00:16:15.275
你可能感興趣的是
音頻處理

00:16:15.342 --> 00:16:18.312
應用特定的音效
以及將多個來源的音頻混合

00:16:20.147 --> 00:16:22.416
或者你可能對
實施3D音效感興趣

00:16:23.917 --> 00:16:27.521
這方面的應用案例包括
開發經典的卡拉OK應用

00:16:28.488 --> 00:16:31.225
開發具有超高音效的
DJ應用

00:16:31.558 --> 00:16:34.261
或者開發一款讓用戶
完全沉浸其中的遊戲

00:16:36.196 --> 00:16:37.664
對於這種高級用例

00:16:37.731 --> 00:16:41.134
我們在AVFoundation中有
叫AVAudioEngine的級別

00:16:43.036 --> 00:16:45.038
AVAudioEngine
是一款強大

00:16:45.105 --> 00:16:47.674
功能豐富的Objective-C
和Swift API

00:16:49.810 --> 00:16:51.378
它是一種實時音頻系統

00:16:51.912 --> 00:16:53.914
可以通過向你提供
非實時界面

00:16:53.981 --> 00:16:56.350
簡化實時音頻的處理工作

00:16:57.484 --> 00:17:00.721
所以 處理實時音頻
涉及很多複雜的操作

00:17:00.787 --> 00:17:02.856
而AVAudioEngine可以
使你的代碼更加簡單

00:17:04.992 --> 00:17:07.094
AVAudioEngine管理
一個節點圖表

00:17:07.327 --> 00:17:09.663
這些節點使你
得以播放和錄製音頻

00:17:10.329 --> 00:17:12.031
你可以以各種方式
連接這些節點

00:17:12.098 --> 00:17:14.800
從而形成多個不同的
處理鏈條

00:17:15.769 --> 00:17:16.837
並進行混音

00:17:17.804 --> 00:17:21.407
你也可以在處理鏈條的
任意一點捕獲音頻

00:17:22.108 --> 00:17:25.045
我們提供一個專門的節點
可以使你實現音頻的空間化

00:17:27.414 --> 00:17:30.684
那麼 讓我們看一下根本的
組成部分——AVAudioNode

00:17:31.985 --> 00:17:33.453
我們有三類節點

00:17:34.354 --> 00:17:36.924
我們有源節點
可以提供用於呈現的數據

00:17:37.724 --> 00:17:39.459
例如你的PlayerNode

00:17:39.526 --> 00:17:42.095
InputNode或者抽樣單位

00:17:43.764 --> 00:17:46.466
我們有處理節點
可以使你處理音頻數據

00:17:46.700 --> 00:17:50.704
所以 你客戶處理的效果包括
延遲、失真以及混音

00:17:52.773 --> 00:17:55.642
我們有目標節點

00:17:55.709 --> 00:17:57.744
即你圖表中的
終端節點

00:17:57.811 --> 00:18:00.247
它與輸出硬件
直接連接

00:18:02.716 --> 00:18:04.251
讓我們看一下設置示例

00:18:05.452 --> 00:18:07.821
比如 我正在構建
一款經典的卡拉OK應用

00:18:09.690 --> 00:18:11.692
在這個例子中
我有三個源節點

00:18:11.758 --> 00:18:14.361
我使用InputNode
捕獲用戶聲音

00:18:14.895 --> 00:18:17.297
使用PlayerNode
播放伴奏曲

00:18:18.332 --> 00:18:20.767
使用另一個PlayerNode
播放其它音效

00:18:20.834 --> 00:18:22.736
和對用戶使用的反饋

00:18:24.304 --> 00:18:25.739
對於處理節點

00:18:25.806 --> 00:18:28.742
我可能會對用戶聲音
應用特定的EQ

00:18:30.077 --> 00:18:31.879
然後我會使用混音器

00:18:31.945 --> 00:18:34.281
將三個源合成爲
單個輸出內容

00:18:35.148 --> 00:18:37.951
然後這單個輸出內容
將通過OutputNode播放

00:18:38.018 --> 00:18:39.620
然後傳遞到輸出硬件

00:18:41.522 --> 00:18:44.391
我也可以捕獲用戶的聲音
並進行一定的分析

00:18:44.491 --> 00:18:47.461
從而瞭解安裝TapBlock後
他們的表現情況

00:18:48.362 --> 00:18:51.231
然後基於此
我可以無條件地安排

00:18:51.298 --> 00:18:53.934
播放出這些反饋隊列

00:18:56.170 --> 00:18:58.572
現在 讓我們看一下
遊戲設置示例

00:19:00.274 --> 00:19:03.043
這裏主要相關節點是
EnvironmentNode

00:19:03.110 --> 00:19:04.845
它可以模擬3D空間

00:19:05.078 --> 00:19:07.347
並將相連的源空間化

00:19:07.447 --> 00:19:09.283
引擎設置示例
遊戲

00:19:09.349 --> 00:19:13.153
在這個例子中 我使用InputNode
以及PlayerNode作爲源

00:19:14.855 --> 00:19:17.057
你也可以調整你源上的
各種3D混音屬性

00:19:17.124 --> 00:19:20.627
比如位置和閉塞

00:19:21.395 --> 00:19:24.064
而對於EnvironmentNode
你也可以在那裏調整屬性

00:19:24.131 --> 00:19:28.001
如listenerPosition
以及其它混響參數

00:19:30.571 --> 00:19:33.674
所以 該3D空間然後
可以與伴奏曲混合

00:19:33.740 --> 00:19:35.375
然後通過輸出設備播放

00:19:38.946 --> 00:19:39.847
核心級別

00:19:39.913 --> 00:19:42.182
在進一步
介紹AVAudioEngine前

00:19:42.249 --> 00:19:44.484
我想再介紹下
Engine廣泛使用的

00:19:44.551 --> 00:19:46.353
一些根本的核心級別

00:19:47.387 --> 00:19:49.323
我從AVAudioFormat開始

00:19:50.958 --> 00:19:53.560
AVAudioFormat
描述音頻文件或音頻流中的

00:19:53.627 --> 00:19:55.429
數據格式

00:19:56.096 --> 00:19:59.199
所以我們有標準格式
通用格式

00:19:59.266 --> 00:20:00.868
以及壓縮格式

00:20:01.735 --> 00:20:04.404
該級別也包含
AVAudioChannelLayout

00:20:04.571 --> 00:20:07.341
你在處理多聲道音頻時
可能會用到

00:20:07.474 --> 00:20:11.144
它是我們的現代界面 連接到
AudioStreamBasicDescription結構

00:20:11.211 --> 00:20:13.013
以及AudioChannelLayout結構

00:20:15.349 --> 00:20:16.917
現在 讓我們看下
AVAudioBuffer

00:20:16.984 --> 00:20:18.719
AVAudioBuffer
核心級別

00:20:18.852 --> 00:20:20.587
該級別有兩個子級別

00:20:20.654 --> 00:20:24.291
AVAudioPCMBuffer
可用於緩衝PCM數據

00:20:24.625 --> 00:20:26.727
包括AVAudioCompressBuffer

00:20:26.793 --> 00:20:29.162
可用來緩衝壓縮音頻數據

00:20:30.163 --> 00:20:32.499
這兩個級別均提供
現代界面 連接到我們的

00:20:32.566 --> 00:20:35.769
AudioBufferList
以及AudioStreamPacketDescription

00:20:38.005 --> 00:20:39.706
讓我們看一下AVAudioFile

00:20:40.641 --> 00:20:43.710
該級別允許你
從任何支持的格式進行讀寫

00:20:44.678 --> 00:20:47.447
允許你將數據讀入
PCM緩存並從PCM緩存

00:20:47.514 --> 00:20:49.716
將數據寫入文件

00:20:49.850 --> 00:20:53.453
這樣 它可以透明化地
處理任何編碼和解碼

00:20:55.322 --> 00:20:59.426
它現在取代我們的AudioFile
和ExtAudioFile API

00:21:00.260 --> 00:21:02.563
最後 讓我們看下
AVAudioConverter

00:21:03.163 --> 00:21:05.566
AVAUDIO轉換器
核心級別

00:21:05.632 --> 00:21:07.801
該級別處理音頻格式轉換

00:21:08.335 --> 00:21:12.606
所以 你可以在兩種
PCM數據格式間轉換

00:21:14.575 --> 00:21:17.978
也可以在PCM以及
壓縮音頻格式間轉換

00:21:18.912 --> 00:21:21.281
其中 轉換器幫你
進行編碼和解碼

00:21:23.317 --> 00:21:26.220
這一級別取代我們的
AudioConverter API

00:21:28.455 --> 00:21:29.990
今年新內容中 我們也添加了

00:21:30.057 --> 00:21:32.593
最小相位
採樣速率轉換器算法

00:21:35.095 --> 00:21:38.498
所以 你可以看到
當與音頻數據相連時

00:21:38.565 --> 00:21:40.300
所有核心級別能很好地協作

00:21:42.536 --> 00:21:46.373
讓我們看下這些級別然後怎樣與
AVAudioEngine交互

00:21:48.809 --> 00:21:53.413
若你觀察AVAudioNode發現
它有輸入和輸出AVAudio格式

00:21:55.382 --> 00:21:58.852
如果你觀察PlayerNode
它可以通過AVAudioFile

00:21:58.919 --> 00:22:01.989
或AVAudioPCMBuffer
使連接到Engine

00:22:05.092 --> 00:22:08.762
如果你安裝NodeTap
該部分以PCM緩存的形式

00:22:08.829 --> 00:22:10.831
向你提供音頻數據

00:22:11.064 --> 00:22:12.366
你可以使用它進行分析

00:22:12.432 --> 00:22:15.736
或者你可以使用AVAudio文件
將它保存在文件中

00:22:17.804 --> 00:22:19.339
如果你處理的是
壓縮流

00:22:19.406 --> 00:22:21.275
你可以將它分解爲
壓縮緩存

00:22:21.341 --> 00:22:24.845
用AVAudioConverter
將它轉換爲PCM緩存

00:22:24.912 --> 00:22:27.447
然後通過PlayerNode
將它提供給Engine

00:22:32.486 --> 00:22:36.356
今年新內容中我們爲Watch帶來了
AVAudioEngine子集

00:22:37.090 --> 00:22:40.093
與此同時 我們也添加了
AVAudioSession子集

00:22:40.160 --> 00:22:42.262
以及你剛剛看到的
所有核心級別

00:22:43.864 --> 00:22:45.866
我相信你一定想
看一下演示

00:22:46.633 --> 00:22:47.835
我們爲你準備了演示

00:22:48.769 --> 00:22:52.372
我們直接使用SceneKit
和AVAudioEngine開發了簡單的遊戲

00:22:53.407 --> 00:22:56.677
在這個遊戲中 我的舉動是
將小行星發射到太空

00:22:56.910 --> 00:22:58.912
在屏幕底端
有一團火焰

00:22:58.979 --> 00:23:02.082
我可以使用Watch的
數碼錶冠控制火焰

00:23:02.783 --> 00:23:04.618
現在 如果行星
接觸到火焰

00:23:04.685 --> 00:23:06.587
就會播放特別大的
爆炸聲

00:23:07.221 --> 00:23:08.388
所以 讓我們來看看

00:23:09.056 --> 00:23:11.625
演示WATCHOS上的
AVAUDIOENGINE

00:23:27.875 --> 00:23:30.177
我肯定這個遊戲
違背了基本的物理定律

00:23:30.244 --> 00:23:33.514
因爲它在太空中播放音頻
對吧？這是不可能的

00:23:36.817 --> 00:23:40.320
好 那讓我快速看一下游戲中的
AVAudioEngine代碼

00:23:42.322 --> 00:23:44.625
在我的級別中
我有AVAudioEngine

00:23:44.892 --> 00:23:46.360
我有兩個PlayerNode

00:23:46.493 --> 00:23:48.195
一個播放爆炸聲

00:23:48.328 --> 00:23:50.030
一個播放發射聲

00:23:51.698 --> 00:23:54.368
我也有連接到
我音頻資源的URL

00:23:56.637 --> 00:24:00.207
在這個例子中 我使用
緩存向引擎提供數據

00:24:03.744 --> 00:24:05.145
讓我們看下如何
設置引擎

00:24:06.480 --> 00:24:09.383
首先要做的是
附加我的PlayerNode

00:24:09.449 --> 00:24:12.352
所以 我觸摸explosionPlayer
和launchPlayer

00:24:13.854 --> 00:24:15.722
接下來 我將使用核心級別

00:24:15.789 --> 00:24:19.193
我將從我資產的URL
創建一個AVAudio文件

00:24:19.793 --> 00:24:21.695
然後
我將創建一個PCM緩存

00:24:21.762 --> 00:24:24.965
我將把文件中的數據
讀入PCM緩存

00:24:25.532 --> 00:24:28.535
之所以能這樣做是
因爲我的音頻文件非常短

00:24:31.205 --> 00:24:33.240
接下來 我繼續操作
連接源節點

00:24:33.307 --> 00:24:36.243
以及引擎的主要混音器

00:24:39.479 --> 00:24:43.250
所以 當遊戲即將開始時
我接着開啓引擎

00:24:43.317 --> 00:24:44.751
並開啓播放器

00:24:45.786 --> 00:24:49.790
當發射小行星時
我只是安排launchBuffer

00:24:49.857 --> 00:24:51.491
在launchPlayer上播放

00:24:52.693 --> 00:24:54.595
當小行星接觸到火焰時

00:24:54.661 --> 00:24:58.465
只需安排explosionBuffer
在explosionPlayer上播放

00:24:59.633 --> 00:25:00.968
這樣 只需幾行代碼

00:25:01.034 --> 00:25:03.270
我就能爲
watchOS上的遊戲

00:25:03.337 --> 00:25:05.072
創造非常豐富的音頻體驗

00:25:06.106 --> 00:25:07.474
這只是個簡單的例子

00:25:07.541 --> 00:25:09.710
我們非常期待能看到
你製造的效果

00:25:12.079 --> 00:25:13.247
多聲道音頻

00:25:13.313 --> 00:25:17.317
結束AVAudioEngine介紹
之前 我要談論下多聲道音頻

00:25:18.218 --> 00:25:20.621
具體的是 它如何與
tvOS關聯的

00:25:22.322 --> 00:25:24.725
去年十月 我們發佈了tvOS

00:25:24.791 --> 00:25:26.860
以及第四代Apple TV

00:25:27.261 --> 00:25:30.497
所以這是在全球開發者大會上
我們首次可以談論該話題

00:25:30.931 --> 00:25:33.834
有關Apple TV上音頻
有趣的一點是

00:25:33.901 --> 00:25:37.271
很多用戶已經連接到
多聲道硬件

00:25:37.471 --> 00:25:39.840
這是因爲很多家庭影院系統
已經支持

00:25:39.907 --> 00:25:42.910
5.1或7.1環繞立體聲系統

00:25:43.243 --> 00:25:46.880
今天 我只是想略微展示下
你怎樣使用AVAudioEngine

00:25:47.247 --> 00:25:48.615
來呈現多聲道音頻

00:25:50.651 --> 00:25:53.153
首先 讓我們回顧下
AVAudioSession的設置

00:25:54.588 --> 00:25:57.558
我首先設置我的類別
和其他選項

00:25:57.624 --> 00:26:00.460
然後激活會話
以便配置硬件

00:26:00.527 --> 00:26:02.362
滿足我的應用需求

00:26:03.964 --> 00:26:06.800
現在 按照我想使用的
呈現格式

00:26:06.900 --> 00:26:09.369
我首先需要查看
當前路徑是否支持該格式

00:26:09.503 --> 00:26:12.739
要查看這一點
我需要查看我想要的聲道數

00:26:12.806 --> 00:26:15.876
是否小於或等於
最大輸出聲道數

00:26:16.176 --> 00:26:19.847
如果是 那麼我可以繼續
設置我想要的輸出聲道數

00:26:22.049 --> 00:26:25.252
接着 我可以從會話中
查詢得到實際的聲道數

00:26:25.319 --> 00:26:26.987
然後使用它繼續操作

00:26:29.189 --> 00:26:33.193
或者 我可以查看當前端口上
的ChannelDescription陣列

00:26:34.161 --> 00:26:37.064
每個ChannelDescription
向我提供一個channelLabel

00:26:37.464 --> 00:26:38.498
和一個channelNumber

00:26:39.366 --> 00:26:42.269
所以 我可以使用該信息
瞭解確切的格式

00:26:42.336 --> 00:26:45.539
以及如何將內容映射到
連接的硬件上

00:26:47.441 --> 00:26:49.776
現在我們換回
AVAudioEngine設置話題

00:26:51.178 --> 00:26:52.446
這裏有兩個用例

00:26:52.513 --> 00:26:56.149
第一個用例是
如果你已經擁有多聲道內容

00:26:57.684 --> 00:26:59.953
第二個用例是
如果你擁有單聲道內容

00:27:00.020 --> 00:27:01.188
並且想對它空間化

00:27:01.255 --> 00:27:03.223
這通常是爲遊戲準備的

00:27:04.992 --> 00:27:06.426
所以 在第一個用例中

00:27:07.895 --> 00:27:10.864
我擁有多聲道內容
以及多聲道硬件

00:27:11.532 --> 00:27:13.367
我只需獲得硬件格式

00:27:13.433 --> 00:27:16.570
我將它設置爲我的混音器
和我的OutputNode間的連接

00:27:16.970 --> 00:27:19.540
在源端
我獲得了內容格式

00:27:19.606 --> 00:27:22.743
並將它設置爲我的
SourceNode和混音器間連接

00:27:23.243 --> 00:27:26.113
這裏混音器爲你
處理聲道映射

00:27:29.349 --> 00:27:32.119
現在 在第二個用例中
我們有一堆單聲道源

00:27:32.452 --> 00:27:35.022
我們將使用EnvironmentNode
對其空間化

00:27:36.456 --> 00:27:38.659
跟之前一樣
我們獲取硬件格式

00:27:38.825 --> 00:27:42.162
但在設置兼容格式前
我們必須將其映射到

00:27:42.229 --> 00:27:44.231
EnvironmentNode
支持的格式

00:27:45.265 --> 00:27:48.802
要了解支持的格式列表
你可以查詢我們的網上文件

00:27:49.436 --> 00:27:51.672
所以 我設置好兼容格式

00:27:51.905 --> 00:27:55.209
現在 在源端
像之前一樣 我獲得內容格式

00:27:55.309 --> 00:27:59.046
並將其設置爲我的播放器和
EnvironmentNode之間的連接

00:28:00.113 --> 00:28:05.018
最後 我也必須將
多聲道呈現算法設置爲

00:28:05.085 --> 00:28:08.288
SoundField 它目前受
EnvironmentNode支持

00:28:09.756 --> 00:28:13.026
此時 我可以啓動引擎
開始播放

00:28:13.360 --> 00:28:16.663
然後調整我們支持的
所有各種3D混音屬性

00:28:19.967 --> 00:28:20.868
好 簡單回顧下

00:28:21.268 --> 00:28:25.005
AVAudioEngine是功能
豐富強大的API

00:28:26.840 --> 00:28:28.976
它簡化了實時音頻的
處理工作

00:28:30.844 --> 00:28:34.114
它使你能夠處理
多聲道音頻和3D音頻

00:28:35.015 --> 00:28:36.250
現在 你可以在Watch上

00:28:36.316 --> 00:28:38.552
開發具有豐富音頻體驗的遊戲

00:28:40.120 --> 00:28:44.157
它取代了我們的
AUGraph和OpenAL API

00:28:44.758 --> 00:28:47.127
我們在之前演講中
簡要介紹了Engine

00:28:47.194 --> 00:28:50.597
我們鼓勵你儘量
瞭解與此相關的內容

00:28:51.365 --> 00:28:53.600
現在 我要將舞臺
交給我的同事Doug

00:28:53.667 --> 00:28:54.768
讓他接着介紹

00:28:55.035 --> 00:28:55.869
Doug？

00:29:01.175 --> 00:29:02.276
謝謝 Saleem

00:29:02.843 --> 00:29:07.181
好 我想在此繼續介紹
音頻API

00:29:07.681 --> 00:29:12.486
我們介紹AVAudioEngine
時順便說到了實時音頻

00:29:13.353 --> 00:29:14.922
Saleem強調

00:29:15.656 --> 00:29:19.259
儘管音頻處理
在實時環境中發生

00:29:19.493 --> 00:29:22.262
我們卻是在非實時
環境中進行控制

00:29:22.329 --> 00:29:24.331
這就是操作簡化的本質

00:29:24.698 --> 00:29:26.733
但有的時候
你實際想要

00:29:26.800 --> 00:29:30.337
在實時過程或環境下工作

00:29:30.604 --> 00:29:32.272
所以 我想進一步介紹下這點

00:29:32.606 --> 00:29:34.608
那麼 什麼是實時音頻

00:29:34.741 --> 00:29:37.511
有的用例中
我們需要實時操作

00:29:37.578 --> 00:29:40.080
這種用例的特點是
低延遲

00:29:42.216 --> 00:29:44.718
可能我所熟悉的
我們平臺上

00:29:44.785 --> 00:29:47.321
最早的應用例子是
音樂應用

00:29:47.888 --> 00:29:51.525
比如
當用戶按下MIDI鍵盤上的

00:29:51.592 --> 00:29:54.127
一個鍵時
你可能正在合成聲音

00:29:54.795 --> 00:29:56.563
我們想要儘量減少

00:29:56.630 --> 00:30:00.067
從按下MIDI音符到
播放音符的時間

00:30:00.534 --> 00:30:04.338
我們有像吉他踏板
一樣的實時音頻效果

00:30:05.272 --> 00:30:09.009
我們想要儘量減少
從吉他音頻

00:30:09.076 --> 00:30:11.144
輸入進電腦

00:30:12.012 --> 00:30:15.782
到我們在電腦中處理音頻
應用延遲、變形

00:30:15.849 --> 00:30:17.818
然後將音頻發回到擴音器
所花費的時間

00:30:18.218 --> 00:30:21.989
所以這種情況下我們需要
低延遲以實現樂器的快速響應

00:30:22.623 --> 00:30:26.226
電話也具有
要求低延遲的特徵

00:30:26.894 --> 00:30:29.963
我們都曾經跟其他國家的
人打電話

00:30:30.030 --> 00:30:31.932
而且經歷過高延遲的情況

00:30:31.999 --> 00:30:33.800
高延遲在電話中是不好的

00:30:34.134 --> 00:30:36.003
我們進行很多信號處理

00:30:36.103 --> 00:30:37.704
我們需要降低延遲

00:30:38.438 --> 00:30:41.675
同樣 在遊戲引擎中
我們也希望降低延遲

00:30:42.209 --> 00:30:45.946
用戶在進行操作
與控制桿等交互

00:30:46.480 --> 00:30:48.982
我們想要儘快產生相應聲音

00:30:49.049 --> 00:30:51.318
有時候我們想要
在聲音呈現時

00:30:51.385 --> 00:30:52.653
控制這些聲音

00:30:53.053 --> 00:30:55.756
或者 也許我們就
已經有了遊戲引擎

00:30:56.256 --> 00:31:00.093
在所有這些案例中
我們都需要寫出能夠

00:31:00.327 --> 00:31:01.562
在實時環境中運行的代碼

00:31:02.596 --> 00:31:06.366
在這種實時環境中

00:31:07.768 --> 00:31:10.437
我們受到約束的

00:31:10.504 --> 00:31:13.173
一個主要特徵是
我們的操作是有時限的

00:31:14.174 --> 00:31:16.410
對吧？每隔幾毫秒

00:31:16.476 --> 00:31:20.080
系統都會叫醒我們
要求我們發出

00:31:20.147 --> 00:31:22.216
持續同樣短暫時間的聲音

00:31:22.716 --> 00:31:26.353
也許 我們能夠完成任務
產生無縫對接的音頻

00:31:26.854 --> 00:31:30.257
也許 我們任務失敗
花費過長時間產生音頻

00:31:30.824 --> 00:31:32.893
因而輸出內容產生缺陷

00:31:32.960 --> 00:31:35.395
用戶聽到的是故障的聲音

00:31:36.029 --> 00:31:40.234
我們製造音頻所能使用的
時間間隔很短

00:31:40.300 --> 00:31:43.203
我們的期限通常
短至3毫秒

00:31:43.270 --> 00:31:46.707
而iOS中默認的
20毫秒

00:31:46.773 --> 00:31:50.544
也仍然是非常緊張的期限

00:31:51.545 --> 00:31:55.182
所以 在這樣的環境中
我們必須特別小心自己的操作

00:31:56.083 --> 00:31:59.653
我們不能停滯
我們不能分配內存

00:31:59.753 --> 00:32:01.522
我們不能使用互斥體

00:32:01.588 --> 00:32:04.258
我們不能訪問文件系統
或者套接字

00:32:04.658 --> 00:32:05.659
我們不能記錄

00:32:05.993 --> 00:32:10.130
我們甚至不能調用分派
“async”因爲它會分配續延

00:32:10.898 --> 00:32:14.067
我們必須小心不要
與Objective-C

00:32:14.134 --> 00:32:18.539
Swift運行時交互 因爲
它們二者並不完全實時安全

00:32:18.605 --> 00:32:21.808
有些情況下 它們也會
採取互斥體

00:32:22.776 --> 00:32:25.846
這是部分列表
還有其它操作我們不能做

00:32:25.913 --> 00:32:27.814
你要問自己
最重要的事情是

00:32:28.148 --> 00:32:32.119
我進行的操作
分配內存或使用互斥體嗎？

00:32:32.186 --> 00:32:35.289
如果答案是“是”
那操作就不是實時安全的

00:32:36.056 --> 00:32:37.424
那麼 我們能做什麼呢

00:32:37.491 --> 00:32:39.927
過會兒 我會
向大家展示這方面的例子

00:32:41.428 --> 00:32:47.167
不過 首先 我想只是
討論下如何管理

00:32:47.234 --> 00:32:50.337
打包實時音頻組件的問題

00:32:50.704 --> 00:32:53.774
我們通過叫做Audio Unit的
API集實現打包

00:32:54.474 --> 00:32:58.545
所以 這是我們打包的方式

00:32:58.612 --> 00:33:00.948
而對於你 關於此問題
作爲其他開發者

00:33:01.014 --> 00:33:03.383
你可以通過它打包你
在其它應用中會再次使用的

00:33:03.450 --> 00:33:06.386
信號處理和模塊

00:33:06.753 --> 00:33:11.358
而且它也提供一個API
可以管理

00:33:11.425 --> 00:33:15.629
你非實時環境
和實時呈現環境之間的

00:33:15.696 --> 00:33:17.631
轉變和交互

00:33:19.333 --> 00:33:22.269
所以 作爲應用開發者
你可以託管Audio Unit

00:33:23.270 --> 00:33:25.706
這意味着你可以允許
用戶選擇一個單元

00:33:25.772 --> 00:33:30.043
或者你可以簡單的使用指向
系統內置單元的硬編碼引用

00:33:31.044 --> 00:33:33.514
你也可以構建
自己的Audio Unit

00:33:34.147 --> 00:33:37.017
可以將它們構建爲
應用擴展或插件

00:33:37.651 --> 00:33:41.755
你也可以簡單地
私下對你的應用

00:33:41.822 --> 00:33:42.856
註冊一個Audio Unit

00:33:42.923 --> 00:33:46.593
這樣很有用 比如
如果你有一些小塊的

00:33:46.660 --> 00:33:48.495
信號處理想要在

00:33:48.562 --> 00:33:51.064
AVAudioEngine
環境中使用

00:33:54.301 --> 00:33:56.136
所以 在Audio Unit下

00:33:56.203 --> 00:33:59.039
我們有更根本的API

00:33:59.273 --> 00:34:00.874
叫做音頻組件

00:34:02.075 --> 00:34:06.380
這是AudioToolbox
框架內的一組API

00:34:07.114 --> 00:34:11.585
框架維護了系統上
所有組件的記錄

00:34:11.652 --> 00:34:13.053
AUDIO UNITS：組件

00:34:13.120 --> 00:34:16.822
每個組件都有一種類型
子類型以及製造商

00:34:16.889 --> 00:34:18.292
這些是包含4個字符的代碼

00:34:18.725 --> 00:34:22.295
它們作爲發現並註冊
組件的鍵

00:34:24.063 --> 00:34:27.568
有很多種不同的
音頻組件類型

00:34:28.168 --> 00:34:33.739
兩種主要的類型是Audio
Units和Audio Codecs

00:34:34.373 --> 00:34:37.077
但在Audio Unit中
我們又有輸入/輸出單元

00:34:37.143 --> 00:34:38.846
生成器、效果、樂器

00:34:39.279 --> 00:34:41.949
轉換器以及混音器

00:34:42.315 --> 00:34:45.319
在codecs編碼解碼器中
我們又有編碼器和解碼器

00:34:45.585 --> 00:34:48.255
在macOS上
我們還有音頻文件組件

00:34:51.725 --> 00:34:55.161
關於組件的實施

00:34:56.029 --> 00:34:59.299
組件的實施
有很多不同的方法

00:34:59.366 --> 00:35:02.069
有一些是如果你用它
寫代碼時需要了解的

00:35:02.135 --> 00:35:03.837
而另外一些 不過是背景知識

00:35:04.738 --> 00:35:08.942
現在創建組件
最好的方法

00:35:09.009 --> 00:35:12.646
若是Audio Unit 最好是
創建Audio Unit應用擴展

00:35:13.280 --> 00:35:19.152
通過10.11和9.0版本
我們去年對此進行了介紹

00:35:20.153 --> 00:35:21.488
所以 那些是應用擴展

00:35:21.555 --> 00:35:25.526
而那之前 Audio Units是
打包在組件捆綁包裏的

00:35:25.592 --> 00:35:27.294
audio codecs等也是如此

00:35:28.862 --> 00:35:31.064
那大概要回溯到
Mac OS 10.1了

00:35:33.367 --> 00:35:38.939
有趣的是 音頻組件也包括
iOS上應用間的音頻節點

00:35:39.373 --> 00:35:41.775
節點應用使用

00:35:42.109 --> 00:35:45.779
組件子類型和製造商密鑰
進行註冊

00:35:46.446 --> 00:35:49.683
主應用程序通過Audio
Component Manager

00:35:50.250 --> 00:35:51.952
發現
節點應用程序

00:35:53.720 --> 00:35:56.390
最終 你能夠註冊
——像我之前提到的——

00:35:56.456 --> 00:35:59.860
你能夠註冊自己的組件
以便用於你自己的應用程序

00:36:00.527 --> 00:36:03.897
只是補充下
有一些Apple內置組件

00:36:04.331 --> 00:36:07.000
在iOS上 它們連接到
AudioToolbox

00:36:09.002 --> 00:36:12.639
所以 以上就是
組件實施的情況

00:36:12.840 --> 00:36:16.510
現在 這裏 我要將焦點
僅僅集中到一種組件——

00:36:16.743 --> 00:36:18.545
音頻輸入/輸出單元

00:36:18.712 --> 00:36:19.913
這是Audio Unit

00:36:19.980 --> 00:36:21.849
音頻輸入/輸出單元
最常用

00:36:21.915 --> 00:36:25.752
如果你只使用一種組件
這很可能就是

00:36:25.819 --> 00:36:27.254
你會使用的組件

00:36:28.121 --> 00:36:31.425
其中的原因是
這是連接到系統基本

00:36:31.491 --> 00:36:34.528
音頻輸入/輸出路徑的
首選界面

00:36:35.329 --> 00:36:39.867
現在 在macOS上 該基本
路徑位於Core Audio框架

00:36:40.300 --> 00:36:41.602
我們稱之爲Audio HAL

00:36:42.402 --> 00:36:44.204
這是非常低級別的界面

00:36:44.638 --> 00:36:48.942
比如 它能使客戶處理
在多聲道設備上

00:36:49.009 --> 00:36:51.011
有趣的流媒體類型

00:36:52.045 --> 00:36:56.283
所以通過音頻
輸入/輸出單元

00:36:56.650 --> 00:36:58.585
能夠非常輕鬆地
處理Audio HAL界面

00:37:00.087 --> 00:37:04.491
在iOS上 你甚至不需要
Core Audio框架的訪問權限

00:37:04.558 --> 00:37:05.792
在那裏 它不是公共的

00:37:05.959 --> 00:37:08.262
你必須使用
音頻輸入/輸出單元

00:37:08.695 --> 00:37:13.267
作爲你將音頻輸入
和輸出系統的低級別方式

00:37:15.369 --> 00:37:17.538
我們現在音頻輸入/輸出

00:37:18.405 --> 00:37:21.608
單元的首選界面是
AUAudioUnit

00:37:21.675 --> 00:37:23.443
及AudioToolbox框架

00:37:24.178 --> 00:37:26.980
如果你使用
我們的API已經有一段時間

00:37:27.347 --> 00:37:31.218
你熟悉第2版Audio Units
它是macOS上AUHAL系統

00:37:31.285 --> 00:37:36.423
以及iOS和Watch上
AURemoteIO系統的

00:37:36.490 --> 00:37:38.492
一部分——

00:37:39.059 --> 00:37:41.328
實際上 我不確定
Watch上有沒有

00:37:41.395 --> 00:37:46.333
不過不論如何
AUAudioUnit是你連接到

00:37:46.567 --> 00:37:48.936
低級別I/O機制的全新現代界面

00:37:50.604 --> 00:37:53.473
所以 我要向你展示使用

00:37:53.540 --> 00:37:58.912
AUAudioUnit
進行AudioIO操作的情況

00:37:59.379 --> 00:38:02.049
所以 這裏
我用Swift寫好了

00:38:02.850 --> 00:38:04.551
產生方波的簡單程序

00:38:06.220 --> 00:38:08.622
這是我的信號處理

00:38:08.689 --> 00:38:12.226
像之前提到的 我要
展示你在這兒可以做什麼

00:38:12.893 --> 00:38:16.363
所以 這個波形信號發生器
向你展示

00:38:16.697 --> 00:38:21.168
你基本上可以讀取內存
寫入內容並進行數學運算

00:38:21.902 --> 00:38:24.238
這是這裏進行的
所有操作

00:38:24.304 --> 00:38:27.975
即產生最簡單的
波形 ——方波——

00:38:28.208 --> 00:38:30.911
至少從計算機的
角度來說最簡單

00:38:31.879 --> 00:38:34.414
所以 這種級別叫做
SquareWaveGenerator

00:38:35.549 --> 00:38:39.853
讓我們看看如何使用AUAudioUnit
播放SqaureWaveGenerator

00:38:41.755 --> 00:38:45.125
首先 我們創建
一條音頻組件描述

00:38:46.093 --> 00:38:49.363
這條描述告訴我們尋找
哪個組件

00:38:50.130 --> 00:38:51.331
類型是輸出

00:38:51.465 --> 00:38:55.135
子類型是我根據
平臺在這裏做出的選擇——

00:38:55.602 --> 00:38:57.471
RemoteIO或
HalOutput

00:38:58.172 --> 00:39:01.842
這裏有Apple製造商
以及一些未使用的標記

00:39:02.910 --> 00:39:06.947
然後我可以使用組件描述
創建AUAudioUnit

00:39:08.081 --> 00:39:09.816
這樣我就能得到想要的單元

00:39:11.418 --> 00:39:15.722
現在 打開了
我可以開始配置

00:39:16.557 --> 00:39:19.626
這裏我要做的
第一件事是搞清楚

00:39:19.693 --> 00:39:23.197
系統上有多少音頻聲道

00:39:23.263 --> 00:39:27.801
這可以使用多種方法通過iOS上的
AVAudioSession實現

00:39:28.368 --> 00:39:32.372
不過 最簡單和便捷的是

00:39:32.439 --> 00:39:36.376
你可以簡單地查詢

00:39:36.810 --> 00:39:39.346
輸入/輸出單元的
outputBusses

00:39:39.746 --> 00:39:45.052
而outputBus[0]是
輸出指向的流

00:39:45.652 --> 00:39:48.488
所以我將獲取它的格式
那是我的硬件格式

00:39:48.956 --> 00:39:52.693
那麼 這個硬件格式
可能是比較奇異的東西

00:39:52.759 --> 00:39:55.329
比如 它可能顯示惰性

00:39:56.830 --> 00:39:59.633
我不知道
是不是要處理它

00:39:59.700 --> 00:40:01.802
所以我只是創建
一個renderFormat

00:40:01.869 --> 00:40:04.905
這是具有相同採樣率的
標準格式

00:40:05.405 --> 00:40:07.074
以及一些聲道

00:40:08.242 --> 00:40:13.347
爲快速簡單起見
我只呈現兩個波段

00:40:13.413 --> 00:40:15.482
而不論
硬件聲道數是多少

00:40:16.316 --> 00:40:18.118
好 那就是我的
renderFormat

00:40:18.352 --> 00:40:20.954
現在 我可以告訴I/O單元

00:40:21.321 --> 00:40:25.058
這是我想要在
inputBus[0]上給你的格式

00:40:25.559 --> 00:40:29.997
完成該操作後 該單元
現會把我的renderFormat

00:40:30.163 --> 00:40:31.365
轉換成hardwareFormat

00:40:31.965 --> 00:40:33.967
在該例中 在我的MacBook上

00:40:34.034 --> 00:40:37.971
該單元會獲取
該去交錯的浮點

00:40:38.372 --> 00:40:41.775
並將其轉換成
交錯浮點緩衝器

00:40:43.577 --> 00:40:47.481
好 接下來 我將
構建我的方波生成器

00:40:48.248 --> 00:40:51.051
如果你是像我一樣的
音樂和數學迷

00:40:51.585 --> 00:40:54.788
你知道代碼中有A440
該數值乘以

00:40:54.855 --> 00:40:58.225
1.5後增長20%

00:40:59.693 --> 00:41:02.062
所以 我將在
左聲道呈現A

00:41:02.129 --> 00:41:04.231
右聲道呈現E

00:41:05.365 --> 00:41:08.836
這裏是
會在實時環境中運行的代碼

00:41:12.039 --> 00:41:13.774
其中有很多參數

00:41:13.941 --> 00:41:16.143
而實際上我只需要
其中的幾個

00:41:16.210 --> 00:41:20.113
我只需要frameCount
和rawBufferList

00:41:20.914 --> 00:41:25.452
rawBufferList是一種
高難度的低級別C結構

00:41:25.886 --> 00:41:32.893
我可以使用SDK上的覆蓋
在Swift語言中對其重包裝

00:41:32.993 --> 00:41:35.329
這樣拿走了
音頻bufferList

00:41:35.896 --> 00:41:39.333
讓它看起來像是
矢量或數組/陣列

00:41:40.767 --> 00:41:42.603
將rawBufferList轉換成

00:41:42.669 --> 00:41:46.039
不錯的Swift包裝後
我可以查詢它的數量

00:41:46.540 --> 00:41:50.344
如果我得到至少一個緩衝器
那麼 我就能呈現左聲道

00:41:50.844 --> 00:41:53.614
如果我得到至少兩個緩衝器
我就能夠呈現右聲道

00:41:54.248 --> 00:41:56.850
這就是我現在
要做的所有工作

00:41:56.917 --> 00:41:59.453
當然 波形信號發生器內
還有更多的工作要做

00:41:59.520 --> 00:42:01.522
不過上述就是
實時環境下的所有工作

00:42:02.656 --> 00:42:05.626
所以 現在 我都設置好了
準備好呈現了

00:42:06.026 --> 00:42:07.861
我會告訴I/O單元

00:42:08.629 --> 00:42:11.565
進行所有必要的分配
以便開始呈現

00:42:12.099 --> 00:42:14.201
然後I/O單元
實際會讓硬件

00:42:14.735 --> 00:42:16.603
運行3秒 然後停止

00:42:16.670 --> 00:42:18.539
這個簡單的程序到此結束

00:42:23.243 --> 00:42:24.912
這就是AUAudioUnit

00:42:26.180 --> 00:42:30.450
接下來 我要簡單講一下
其它一些Audio Unit

00:42:30.984 --> 00:42:35.022
我們有效果 可以獲取
音頻輸入 產生音頻輸出

00:42:35.455 --> 00:42:38.659
有樂器 可以獲取
類似MIDI的東西作爲輸入

00:42:39.059 --> 00:42:40.727
同時也能產生音頻輸出

00:42:41.195 --> 00:42:44.531
有生成器 能夠產生
音頻輸出

00:42:44.665 --> 00:42:48.602
而不輸入任何東西
除了一些可能的參數控制

00:42:48.902 --> 00:42:52.906
如果我要將我的方波生成器
重新打包爲Audio Unit

00:42:53.006 --> 00:42:54.508
我會做成生成器

00:42:57.644 --> 00:43:00.314
要託管這些
種類的Audio Unit

00:43:00.380 --> 00:43:02.482
你也可以使用AUAudioUnit

00:43:03.584 --> 00:43:07.354
你可以使用單獨的部分
向它提供輸入

00:43:07.588 --> 00:43:10.157
這跟你在I/O單元上
看到的

00:43:10.224 --> 00:43:12.826
輸出供應塊非常相似

00:43:13.660 --> 00:43:16.163
你可以將這些單元
呈現部分連接起來

00:43:16.230 --> 00:43:18.265
創建你自己的
定製化類型

00:43:18.966 --> 00:43:21.902
你可以使用參數
控制這些單元

00:43:23.203 --> 00:43:26.306
而且 很多單元
尤其是第三方單元

00:43:26.874 --> 00:43:28.542
都有很好的用戶界面

00:43:28.609 --> 00:43:31.011
作爲主應用程序
你可以獲取

00:43:31.078 --> 00:43:34.815
audio unit視圖
在你的應用程序中顯示

00:43:34.882 --> 00:43:36.450
並讓用戶與其交互

00:43:39.786 --> 00:43:41.889
若你想
編寫自己的Audio Unit

00:43:43.991 --> 00:43:46.627
我首先的做法很簡單
就是在應用的環境中

00:43:46.693 --> 00:43:48.428
構建Audio Unit

00:43:48.695 --> 00:43:53.467
這樣你可以進行調試
而無需擔心流程間的通信問題

00:43:53.534 --> 00:43:54.668
全部在一個過程中完成

00:43:55.068 --> 00:43:57.504
你首先
將AUAudioUnit劃入子級別

00:43:58.071 --> 00:44:02.276
使用AUAudioUnit的
這一級別方法將其註冊爲組件

00:44:02.976 --> 00:44:04.244
然後你可以對其進行調試

00:44:05.279 --> 00:44:06.780
一旦完成——

00:44:06.914 --> 00:44:09.116
如果你確定了
要將其作爲

00:44:09.683 --> 00:44:11.285
Audio Unit擴展分佈

00:44:11.652 --> 00:44:14.755
你就可以採取同樣的
AUAudioUnit子級別

00:44:15.422 --> 00:44:17.591
你可以對其微調
和進一步修飾

00:44:18.325 --> 00:44:21.028
不過然後你將需要
多花一點功夫

00:44:21.361 --> 00:44:23.764
將其打包爲
Audio Unit擴展

00:44:24.398 --> 00:44:27.434
所以 你就獲得一個擴展程序
你可以把它嵌入某個應用程序

00:44:27.501 --> 00:44:29.803
也可以在App Store
出售該應用程序

00:44:33.707 --> 00:44:35.776
好 我想邀請
我的同事Torrey

00:44:35.843 --> 00:44:39.346
向你展示下Audio Unit擴展
的一些威力

00:44:39.680 --> 00:44:41.682
過去一年
我們一些開發者使用它

00:44:41.748 --> 00:44:42.883
做了不少很酷的事情

00:44:43.684 --> 00:44:44.751
大家可好？ 

00:44:45.552 --> 00:44:46.753
參加WWDC可開心？

00:44:48.188 --> 00:44:49.056
好

00:44:50.724 --> 00:44:51.959
讓我們製造些聲響吧

00:44:52.693 --> 00:44:54.695
我會從這兒開始 啓動——

00:44:54.761 --> 00:44:56.630
首先
我的樂器在這兒

00:44:56.697 --> 00:45:00.567
這是我的iPad Pro
我首先啓動Arturia iSEM

00:45:01.268 --> 00:45:03.170
這是非常強大的合成器應用

00:45:03.237 --> 00:45:06.006
這裏是我喜歡的
合成喇叭聲音

00:45:11.845 --> 00:45:15.349
我很喜歡這個聲音 我想把它
放到我正在編輯的曲目中

00:45:15.449 --> 00:45:19.019
這個將作爲我們的Audio
Unit插件應用

00:45:19.520 --> 00:45:21.688
現在 我要啓動GarageBand

00:45:21.755 --> 00:45:24.591
它將作爲我們的Audio Unit
主應用程序

00:45:25.192 --> 00:45:28.595
現在GarageBand中
有個我正編輯的sick beat

00:45:28.662 --> 00:45:31.565
我將它命名爲WWDC Demo

00:45:32.366 --> 00:45:33.333
讓我們聽一下

00:45:43.577 --> 00:45:46.780
好 接下來我們看一下
辭句部分

00:45:55.088 --> 00:45:57.925
接着 我們將處理
和聲部分

00:45:57.991 --> 00:45:59.960
這應該是歌曲的
高潮部分

00:46:00.027 --> 00:46:02.262
我希望多一點動感
多一點張力

00:46:02.696 --> 00:46:05.265
讓我們通過Audio Unit
製造這種效果

00:46:06.800 --> 00:46:08.235
我將在這裏添加一個新曲目

00:46:09.069 --> 00:46:12.105
添加新樂器 我會看到
這裏有Audio Unit選項

00:46:12.973 --> 00:46:15.309
如果我選擇它 接下來我會
在這裏看到系統上

00:46:15.375 --> 00:46:16.910
寄存
所有的Audio Unit

00:46:17.244 --> 00:46:21.648
我看到的是Arturia iSEM
因爲我在家裏練習這個

00:46:22.983 --> 00:46:25.185
選擇iSEM
GarageBand現在將

00:46:25.252 --> 00:46:28.555
在這裏顯示屏幕上的
MIDI控制器以供我使用

00:46:28.922 --> 00:46:32.693
它有完整的尺度變化
以及琶音器 就在這裏

00:46:32.759 --> 00:46:35.462
我會充分利用這些工具
因爲我很喜歡動感的音樂

00:46:35.863 --> 00:46:39.366
在這裏的左邊
你可以看到音調/修正滾輪

00:46:39.433 --> 00:46:41.001
你甚至可以修改速度

00:46:41.335 --> 00:46:44.104
Audio Unit在這裏
向我提供的視圖

00:46:44.171 --> 00:46:45.339
其實我可做小的調整

00:46:45.839 --> 00:46:48.442
而現在 我要在這裏
錄製一小段音頻

00:46:48.509 --> 00:46:50.544
然後看一下它
在整個曲子中的效果

00:46:50.611 --> 00:46:51.478
那麼——

00:47:04.825 --> 00:47:06.093
好了 不錯

00:47:08.262 --> 00:47:10.063
讓我們聽一下它
在整個曲子中的效果

00:47:14.201 --> 00:47:16.270
好了
這就是我想要的張力

00:47:16.970 --> 00:47:20.374
現在 讓我進行更深入的介紹
向大家展示我進行的操作

00:47:22.576 --> 00:47:23.977
我會在這裏進行編輯

00:47:25.379 --> 00:47:28.182
我會更仔細地
觀察循環曲目

00:47:29.082 --> 00:47:31.084
這裏 我希望大家
注意兩點

00:47:31.185 --> 00:47:33.887
第一點是
這些是MIDI事件

00:47:33.987 --> 00:47:36.456
使用跨應用音頻與將
Audio Unit作爲插件使用

00:47:36.523 --> 00:47:40.527
的不同點是
你實際可以在這裏看到

00:47:40.594 --> 00:47:42.663
MIDI音符 
這就使事後的編輯更簡單

00:47:43.063 --> 00:47:45.799
我希望大家在這裏
注意的另外一點是

00:47:45.866 --> 00:47:47.968
你可以在這裏
看到單個MIDI音符

00:47:48.035 --> 00:47:50.971
但是之前你看到的是
我彈奏巨大粗厚的和絃

00:47:51.371 --> 00:47:53.340
這是因爲我利用了

00:47:53.407 --> 00:47:55.709
GarageBand內置的
琶音器

00:47:55.776 --> 00:47:57.244
所以我纔得到了這些單個音符

00:47:57.311 --> 00:47:59.112
如果願意
我可以隨意更改

00:47:59.179 --> 00:48:00.981
使音符聽起來
更人性化

00:48:01.315 --> 00:48:03.450
不過我對曲子現在的效果
已經很滿意

00:48:04.751 --> 00:48:08.021
這裏 我最後要向大家顯示的
實際是 首先

00:48:08.088 --> 00:48:12.092
我會將這個複製到
臨近的單元格

00:48:13.727 --> 00:48:18.265
我之前跟你提過
這裏提供的Audio Unit視圖

00:48:18.532 --> 00:48:20.300
實際是交互式的

00:48:20.367 --> 00:48:21.835
它不僅是外觀漂亮的圖片

00:48:21.935 --> 00:48:24.505
所以 如果你喜歡探索
你甚至可以嘗試

00:48:24.571 --> 00:48:26.874
爲朋友演奏一曲

00:48:32.012 --> 00:48:33.180
略微提高音量

00:49:32.840 --> 00:49:33.707
讓我們收尾

00:50:01.335 --> 00:50:02.503
我的演示就到這裏

00:50:05.305 --> 00:50:07.774
我想感激大家所付出的
時間和精力

00:50:07.841 --> 00:50:10.043
始終感謝大家寫出炫酷的應用

00:50:11.178 --> 00:50:13.146
演示
Audio Unit擴展

00:50:14.982 --> 00:50:15.883
謝謝Torrey

00:50:16.250 --> 00:50:19.653
好 這裏簡單回顧下

00:50:20.854 --> 00:50:24.124
你能看到我們去年
關於Audio Unit擴展的介紹

00:50:24.191 --> 00:50:28.028
其中更詳細地介紹了
API的構造

00:50:28.095 --> 00:50:29.429
這裏我們只是想向你展示

00:50:29.496 --> 00:50:31.431
由於Audio Unit炫酷的功能
人們利用它都做了什麼

00:50:33.667 --> 00:50:37.871
好 說到MIDI
我們看到GarageBand怎樣

00:50:37.938 --> 00:50:39.673
將Torrey的演奏錄製成MIDI

00:50:40.707 --> 00:50:42.910
我們的系統中
有很多API是

00:50:42.976 --> 00:50:46.246
使用MIDI通信的
而要在什麼時候使用

00:50:46.313 --> 00:50:48.282
哪些API並不總是很清楚

00:50:48.982 --> 00:50:51.952
所以我希望能夠
幫助大家稍稍澄清這一點

00:50:53.754 --> 00:50:56.723
現在 你可能就有
一個標準的MIDI文件

00:50:57.591 --> 00:51:00.294
比如 難聽的手機鈴聲

00:51:00.427 --> 00:51:03.630
不過MIDI文件
在音樂教學中十分有用

00:51:03.830 --> 00:51:07.768
我可以獲得我想學習
樂曲的MIDI文件

00:51:07.835 --> 00:51:09.336
我可以看到所有的音符

00:51:10.003 --> 00:51:12.105
若你有一個MIDI文件 你可用
AVAudioSequencer

00:51:12.172 --> 00:51:13.707
播放該文件

00:51:14.007 --> 00:51:17.244
這樣會在AVAudioEngine
環境中播放文件

00:51:19.246 --> 00:51:21.815
如果你想要控制
軟件合成器

00:51:22.282 --> 00:51:24.818
如我們看到GarageBand
控制iSEM的情形

00:51:25.419 --> 00:51:28.555
能使用的最好的API是
AUAudioUnit

00:51:29.590 --> 00:51:31.892
而且如果你想要
AUAudioUnit回放到

00:51:31.959 --> 00:51:35.863
AVAudioEngine
你可以使用AVAudioMIDIInstrument

00:51:39.032 --> 00:51:40.667
現在 有MIDI核心框架

00:51:40.734 --> 00:51:42.769
人們經常認爲
該框架會做一些

00:51:43.036 --> 00:51:44.505
其它較高級別的任務

00:51:44.571 --> 00:51:48.475
但實際上 它是非常
底層的API

00:51:48.542 --> 00:51:50.744
基本上只是用於
與MIDI硬件通信

00:51:50.878 --> 00:51:53.747
比如 外部USB的
MIDI接口

00:51:54.181 --> 00:51:55.749
或者藍牙MIDI鍵盤

00:51:56.283 --> 00:51:58.218
我們也提供MIDI網絡驅動

00:51:59.019 --> 00:52:03.190
你可以使用它發送原始
MIDI消息 比如在iPad

00:52:03.257 --> 00:52:04.758
和MacBook之間發送

00:52:06.360 --> 00:52:09.029
你也可以使用核心
MIDI框架

00:52:09.096 --> 00:52:10.964
在流程之間實時發送MIDI

00:52:12.065 --> 00:52:15.769
這有時會涉及一個灰色地帶

00:52:15.836 --> 00:52:19.039
人們會問：“好吧 我該使用
核心MIDI在我的

00:52:19.106 --> 00:52:23.110
排序器
以及正在收聽MIDI和

00:52:23.177 --> 00:52:25.245
合成的應用之間通信嗎？”

00:52:25.746 --> 00:52:29.082
我會說那可能不是
適合於這種情況的API

00:52:29.149 --> 00:52:31.318
如果你正在同時
使用MIDI和音頻

00:52:31.618 --> 00:52:33.520
我會使用AUAudioUnit

00:52:33.887 --> 00:52:36.089
情況應該是
當你在兩個應用中

00:52:36.156 --> 00:52:39.560
或者一個應用的兩個實體中

00:52:39.626 --> 00:52:42.629
操作純MIDI時——
或許其中一個是來自

00:52:42.696 --> 00:52:43.797
另一開發者的靜態庫

00:52:44.665 --> 00:52:48.702
在上述情況下 你可以
將核心MIDI用於流程間

00:52:48.802 --> 00:52:50.871
或實體間的實時MIDI

00:52:52.539 --> 00:52:56.510
這裏就到了我們
音頻API長篇介紹的尾聲

00:52:57.277 --> 00:53:00.047
我們從應用程序開始
——在底端是

00:53:00.113 --> 00:53:03.584
CoreAudio框架
和驅動

00:53:04.418 --> 00:53:07.721
介紹了AVAudioEngine
如何用AVAudioSession

00:53:07.788 --> 00:53:11.358
在我們除了macOS之外的
所有平臺上完成設置

00:53:11.992 --> 00:53:14.127
我們介紹了你可以怎樣
使用AVAudioPlayer

00:53:14.194 --> 00:53:16.630
及AVAudioRecorder
從文件中

00:53:16.697 --> 00:53:18.098
進行簡單的播放和錄製操作

00:53:18.732 --> 00:53:21.735
或者如果你的文件
或網絡流媒體涉及視頻

00:53:21.802 --> 00:53:23.103
你可以使用AVPlayer

00:53:23.971 --> 00:53:27.074
AVAudioEngine是
構建複雜處理圖表的

00:53:27.374 --> 00:53:30.210
優質高級別界面

00:53:30.444 --> 00:53:32.579
可以處理很多問題

00:53:32.646 --> 00:53:36.884
你通常無需使用
任何較低級別的API

00:53:37.251 --> 00:53:41.788
不過如果使用了 我們介紹了
AudioToolbox中的

00:53:42.256 --> 00:53:45.192
AUAudioUnit 它可以讓你
直接與I/O循環

00:53:46.193 --> 00:53:50.964
與第三方或與你自己的樂器
效果和生成器通信

00:53:51.598 --> 00:53:54.401
最後 我們簡要介紹了
核心MIDI框架

00:53:56.570 --> 00:53:58.639
我今天在此的介紹結束了

00:53:59.773 --> 00:54:02.009
你可以訪問此鏈接
瞭解更多信息

00:54:02.676 --> 00:54:04.811
我們在此提供了
很多相關介紹

00:54:05.245 --> 00:54:06.113
非常感謝