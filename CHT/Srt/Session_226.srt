00:00:19.853 --> 00:00:23.891
CloudKit新特性
分享無限渴望

00:00:29.830 --> 00:00:32.499
下午好 歡迎來到第226場演講

00:00:32.566 --> 00:00:33.734
CloudKit新特性

00:00:34.334 --> 00:00:35.569
我是Paul Seligman

00:00:35.636 --> 00:00:37.738
CloudKit客戶小組的工程師

00:00:38.038 --> 00:00:40.340
我今天很高興能跟你們在一起

00:00:40.407 --> 00:00:41.742
聊一聊最新的消息

00:00:41.808 --> 00:00:43.977
和新的特性
關於CloudKit的生態系統

00:00:44.411 --> 00:00:46.113
我們今天講什麼？

00:00:46.213 --> 00:00:49.716
今天首先我們要
簡單瞭解一下什麼是CloudKit

00:00:50.050 --> 00:00:52.819
然後我們換個話題
講一講Telemetry

00:00:52.886 --> 00:00:55.556
這是一個新特性
可以讓你想象

00:00:55.622 --> 00:00:58.258
CloudKit支持的應用如何工作

00:00:58.992 --> 00:01:02.629
我們會講到
API的改進和可用性

00:01:03.964 --> 00:01:05.632
我們還會講到Sharing

00:01:05.699 --> 00:01:07.634
這是個新功能
可以讓用戶

00:01:07.701 --> 00:01:09.203
能夠分享數據

00:01:09.403 --> 00:01:12.206
但同時又能完全控制
他人的訪問權限

00:01:15.309 --> 00:01:16.910
什麼是CloudKit？

00:01:17.444 --> 00:01:20.013
CloudKit是一種技術
讓你能夠

00:01:20.080 --> 00:01:22.716
使應用數據和用戶數據

00:01:22.783 --> 00:01:24.351
隨時隨地可用

00:01:25.352 --> 00:01:29.223
CloudKit是一個框架
給你訪問iCloud數據庫的權限

00:01:30.691 --> 00:01:33.327
CloudKit被大量使用於
Apple產品

00:01:33.393 --> 00:01:36.129
它讓你們相信我們努力的貢獻

00:01:36.230 --> 00:01:38.332
它讓我們自信
能夠連接到

00:01:38.398 --> 00:01:40.033
數千萬用戶

00:01:41.802 --> 00:01:44.338
CloudKit可用於
所有Apple平臺

00:01:47.741 --> 00:01:50.410
現在 我簡明扼要地
介紹一下CloudKit

00:01:50.477 --> 00:01:53.814
就是過去幾年我們爲
引進CloudKit所做的幾個方面

00:01:54.348 --> 00:01:56.550
我建議你們去聽聽
下一場演講

00:01:56.617 --> 00:01:59.319
如果你想要更多的
瞭解生態系統

00:01:59.887 --> 00:02:01.588
我還要推薦這幾場演講

00:02:01.655 --> 00:02:04.691
他們更詳細地
講解了CloudKit的具體方面

00:02:04.858 --> 00:02:07.728
通過這些方法
你可以讓你和你的應用

00:02:07.794 --> 00:02:09.562
利用CloudKit的優點

00:02:10.130 --> 00:02:12.399
現在 所有的演講都已發佈到網上
且相互關聯

00:02:12.466 --> 00:02:15.235
developer.apple.com/CloudKit

00:02:18.071 --> 00:02:19.540
這裏所列的東西

00:02:19.606 --> 00:02:22.609
是使用CloudKit的開發者
必須要熟悉的東西

00:02:23.010 --> 00:02:25.646
我們一個個講
先從Container開始吧

00:02:26.480 --> 00:02:30.050
Container是一個機制
通過它可以上傳數據到iCloud

00:02:30.517 --> 00:02:32.719
所以 Notes會用到Container

00:02:32.786 --> 00:02:34.321
照片會用到Container

00:02:34.388 --> 00:02:36.857
當應用在CloudKit創建時

00:02:36.924 --> 00:02:39.026
它也需要有自己的Container

00:02:40.093 --> 00:02:44.231
如果我們看看Container內部
就會發現它裏面裝的都是數據庫

00:02:45.165 --> 00:02:47.267
直到上週
這就是我們的數據模型

00:02:47.634 --> 00:02:50.704
Container有兩個數據庫
一個公用的和一個個人的

00:02:51.638 --> 00:02:55.042
引進了分享後
我們就用了第三個數據庫類型

00:02:55.108 --> 00:02:56.143
分享數據庫

00:02:56.610 --> 00:02:58.078
這個之後細講

00:03:00.214 --> 00:03:03.217
存儲的基本單位在CloudKit裏
是一個record（記錄）

00:03:03.417 --> 00:03:05.552
它是一組鍵值對

00:03:05.819 --> 00:03:09.790
通常映射到一個目標模型
不對 是數據模型中的一個目標

00:03:10.591 --> 00:03:13.393
現在 我們不會把記錄
鬆散的存儲在數據庫裏

00:03:13.527 --> 00:03:16.630
而是將它們封裝在
Record Zones（記錄區）

00:03:17.531 --> 00:03:19.867
一個記錄區可以存很多個記錄

00:03:20.501 --> 00:03:23.136
一個數據庫可以有很多個記錄區

00:03:24.271 --> 00:03:27.474
不同的數據庫
支持不同類型的記錄區

00:03:28.275 --> 00:03:31.044
公用的和個人的數據庫
都有一個默認的記錄區

00:03:31.378 --> 00:03:34.882
這是你所有記錄的歸屬
除非你特別指定另外一個

00:03:35.682 --> 00:03:38.619
個人數據庫也可以
包括自定義的記錄區

00:03:38.886 --> 00:03:42.689
這是由你的應用創建並上傳到數據庫

00:03:43.490 --> 00:03:47.227
最後 新的分享數據庫
由分享類記錄區組成

00:03:49.663 --> 00:03:53.467
有了分享功能後
這個列表上就多了一個新的核心概念

00:03:53.534 --> 00:03:54.768
就是Share的概念

00:03:55.602 --> 00:03:58.739
Share是record的子類
並同樣地

00:03:58.805 --> 00:04:01.408
與Records一起
存在記錄區裏

00:04:01.808 --> 00:04:05.112
你可以把Record想成
你想要分享的東西

00:04:05.479 --> 00:04:07.614
Share代表的就是你如何分享它們

00:04:07.681 --> 00:04:09.850
比如參與者和許可

00:04:10.284 --> 00:04:13.387
同樣 這個一會兒再說
現在只要知道有這麼個東西

00:04:16.023 --> 00:04:18.959
我們在Apple的很多系統中
使用CloudKit

00:04:19.026 --> 00:04:21.995
所以我想花點時間
來着重介紹我們的幾個客戶

00:04:22.863 --> 00:04:26.266
在公用數據庫裏
有一些應用可能是你用過的

00:04:26.333 --> 00:04:28.368
WWDC應用和News應用

00:04:29.303 --> 00:04:32.472
特別是News應用
它要將文章內容和圖片等

00:04:32.539 --> 00:04:33.707
保存到公用數據庫裏

00:04:33.907 --> 00:04:36.009
這是公用數據庫
最大的好處

00:04:36.109 --> 00:04:39.680
它存的數據
是你希望所有用戶都能訪問的

00:04:40.581 --> 00:04:43.083
與之相對的
就是個人數據庫

00:04:43.417 --> 00:04:47.020
個人數據庫是
你存儲用戶私人數據的地方

00:04:47.521 --> 00:04:49.790
這裏面有幾個
是Apple的應用

00:04:49.857 --> 00:04:52.459
包括iCloud Backup和iCloud Drive

00:04:52.526 --> 00:04:54.494
iCloud Photo Library和Notes

00:04:56.396 --> 00:04:59.166
我很高興地跟大家宣佈
兩個新功能

00:04:59.233 --> 00:05:01.602
Notes Collaboration
和Activity Sharing

00:05:01.668 --> 00:05:03.871
都是創建於CloudKit Sharing之上

00:05:04.271 --> 00:05:07.241
因此
Notes和Activity應用

00:05:07.307 --> 00:05:09.009
是使用分享數據庫的應用

00:05:13.280 --> 00:05:16.717
2年前 我們引入了CloudKit
通過提供兩個本地框架

00:05:16.783 --> 00:05:18.886
一個是iOS 另一個是macOS

00:05:19.820 --> 00:05:21.655
去年我們這個家庭擴大了

00:05:21.722 --> 00:05:23.824
新添了tvOS數據庫框架

00:05:24.024 --> 00:05:25.459
還有兩個網絡框架

00:05:25.526 --> 00:05:28.161
CloudKit JS
和CloudKit網絡服務

00:05:29.129 --> 00:05:32.332
網絡框架可以讓用戶
訪問CloudKit數據

00:05:32.399 --> 00:05:33.634
無論是在網上

00:05:33.700 --> 00:05:36.970
還是在沒有其他本地框架的平臺上

00:05:38.172 --> 00:05:40.908
今年我們繼續擴大
來完善這個家庭

00:05:40.974 --> 00:05:43.310
就是添加了watchOS本地框架

00:05:45.245 --> 00:05:47.814
我們這就有了一個
可用的CloudKit本地框架

00:05:47.881 --> 00:05:49.550
覆蓋所有Apple平臺

00:05:50.584 --> 00:05:51.852
那麼現在我們來慢慢了解

00:05:51.919 --> 00:05:55.088
今年的一些
值得注意的針對平臺的改進

00:05:55.155 --> 00:05:56.723
從macOS開始吧

00:05:57.958 --> 00:05:59.626
我們要與你們分享的
這個大好消息

00:05:59.693 --> 00:06:03.463
就是你不再需要通過Mac
App Store來分發應用

00:06:03.530 --> 00:06:05.465
只要好好利用CloudKit

00:06:10.537 --> 00:06:13.073
使用iCloud for
Developer ID新特性

00:06:13.140 --> 00:06:15.609
你可以直接
授權應用使用CloudKit

00:06:15.676 --> 00:06:18.979
和其他iCloud服務
通過你的許可配置

00:06:20.480 --> 00:06:22.716
接下來我要講的是
服務器對服務器

00:06:23.083 --> 00:06:26.119
這個功能已經
推出了幾個月了

00:06:26.386 --> 00:06:28.255
它讓你能夠

00:06:28.322 --> 00:06:31.425
使你的服務器
直接與CloudKit服務器對話

00:06:31.491 --> 00:06:32.860
就像管理用戶一樣

00:06:33.994 --> 00:06:36.163
你的服務器
可向CloudKit驗證自己

00:06:36.230 --> 00:06:37.931
通過使用一個公用/個人的密鑰對

00:06:37.998 --> 00:06:40.834
是你已在CloudKit
Dashboard建好的

00:06:41.802 --> 00:06:43.937
你可以設置你的服務器

00:06:44.004 --> 00:06:46.507
讓他們有完全權限改寫公用數據庫

00:06:48.141 --> 00:06:52.079
這是個很好的方法讓你從服務器
導入數據給CloudKit

00:06:52.346 --> 00:06:55.349
或者從CloudKit
導出數據到服務器

00:06:55.782 --> 00:06:59.620
或者讓兩套數據更新
保持服務器和CloudKit一致

00:07:03.156 --> 00:07:06.493
CloudKit作爲watchOS的本地框架
被引入後

00:07:06.560 --> 00:07:09.062
你就有了另一個機制
讓你的Watch應用

00:07:09.129 --> 00:07:10.998
和iOS應用進行更新

00:07:11.865 --> 00:07:14.334
這樣一來你可以將
CloudKit想成一個代替

00:07:14.401 --> 00:07:16.203
watch連接性框架的選項

00:07:16.370 --> 00:07:18.705
CloudKit有一個亮點

00:07:18.772 --> 00:07:20.741
就是獨立功能性

00:07:22.075 --> 00:07:24.845
CloudKit使用
NSURLsession

00:07:24.912 --> 00:07:27.614
我們的網絡連接
使用最好的可用界面

00:07:27.748 --> 00:07:29.850
如果你的watch是
連接到iOS設備

00:07:30.017 --> 00:07:31.985
我們會將通過iOS設備通信

00:07:32.486 --> 00:07:35.889
但是watch同時也可以
直接與CloudKit服務器對話

00:07:35.956 --> 00:07:37.090
只要有Wi-Fi

00:07:38.959 --> 00:07:43.797
現在我們來展示
完整版本的CloudKit API

00:07:44.898 --> 00:07:48.001
引進了CloudKit
作爲watchOS的本地框架

00:07:48.068 --> 00:07:51.738
你就可以寫出差不多的
使用CloudKit的應用代碼

00:07:51.805 --> 00:07:53.607
在所有的Apple平臺上

00:07:55.275 --> 00:07:57.244
比如Activity應用就使用了它

00:07:57.311 --> 00:08:01.081
寫出CloudKit相似代碼
用於iOS和watchOS

00:08:01.148 --> 00:08:03.150
來開展活動
“分享明天”

00:08:04.218 --> 00:08:07.221
注意我說的是相似代碼
不是一樣的代碼

00:08:07.287 --> 00:08:10.624
當你編寫代碼
並部署給各種Apple平臺

00:08:10.691 --> 00:08:14.094
你要記住
每個平臺的優勢和限制

00:08:14.728 --> 00:08:17.965
也就是說
有時你會打破資源的上限

00:08:18.365 --> 00:08:20.701
你必須要時刻記得
CPU的特性

00:08:20.767 --> 00:08:22.302
存儲空間

00:08:22.369 --> 00:08:25.506
網絡特點
比如延遲和吞吐量

00:08:26.707 --> 00:08:30.110
你可以用這些決定
與服務器對話的頻率

00:08:30.177 --> 00:08:32.712
以及想要傳送的數據量

00:08:33.647 --> 00:08:38.519
同樣 測試仍是最好的辦法
來調整你的應用去適應平臺

00:08:38.784 --> 00:08:42.121
保證用戶
能獲得最佳的體驗

00:08:45.259 --> 00:08:47.895
現在我來換個話題
講講Telemetry

00:08:48.128 --> 00:08:49.897
Telemetry是一個新功能

00:08:50.230 --> 00:08:51.832
讓你可以形象化

00:08:51.899 --> 00:08:54.535
CloudKit應用的運行情況

00:08:55.469 --> 00:08:56.503
Telemetry表現爲

00:08:56.570 --> 00:08:59.907
一系列圖表 可見於
CloudKit Dashboard

00:09:01.241 --> 00:09:04.845
你可以通過它們看到
你在公用數據庫中的行爲

00:09:04.978 --> 00:09:08.549
或者是你在不同的用戶個人數據庫裏
行爲的集合

00:09:09.783 --> 00:09:10.984
你可以觀察這些圖表

00:09:11.051 --> 00:09:14.688
這樣就能瞭解
每時每天每週每月的數據

00:09:15.589 --> 00:09:18.458
你可以選擇
查看整個應用

00:09:18.759 --> 00:09:21.662
也可以集中觀察
某一種操作

00:09:23.130 --> 00:09:24.831
那現在就看看它長什麼樣

00:09:26.300 --> 00:09:29.703
這就是CloudKit Dashboard
你可能很熟悉

00:09:29.770 --> 00:09:33.207
我請你們看看
左下角這個新的UI元素

00:09:33.273 --> 00:09:34.308
性能標籤

00:09:35.375 --> 00:09:37.010
當你選擇性能標籤

00:09:37.077 --> 00:09:39.112
你可以訪問一系列圖表

00:09:39.179 --> 00:09:41.682
告訴你
你的客戶都在做什麼

00:09:41.748 --> 00:09:43.317
它們分兩類

00:09:44.017 --> 00:09:47.354
第一個是性能圖
表示的信息有

00:09:47.421 --> 00:09:50.357
每秒的操作量

00:09:50.724 --> 00:09:52.593
以及你的請求的平均大小

00:09:53.293 --> 00:09:57.264
你可以通過觀察它
想象公用或個人數據庫中的數據

00:09:57.331 --> 00:09:59.099
在不同時段的情況

00:09:59.433 --> 00:10:02.002
也可根據
不同操作類型觀察

00:10:03.370 --> 00:10:06.640
現在顯示的這個圖
我們叫做正確性圖表

00:10:07.107 --> 00:10:10.110
我要你們注意的
是客戶端錯誤

00:10:10.878 --> 00:10:14.481
它告訴你
你發出的請求中有百分之多少

00:10:14.548 --> 00:10:16.116
導致了客戶端錯誤

00:10:17.150 --> 00:10:18.452
那麼 客戶端錯誤

00:10:18.519 --> 00:10:21.788
是一種錯誤的子集
是CKOperation可能會產生的報錯

00:10:22.322 --> 00:10:23.624
正是這個子集

00:10:23.690 --> 00:10:26.927
才使你的應用
能解決錯誤並採取行動

00:10:27.394 --> 00:10:30.163
比如
你可能要保存一個記錄

00:10:30.230 --> 00:10:32.966
但是服務器上
有一個與之衝突的記錄改變

00:10:33.534 --> 00:10:35.269
又或者你試圖獲取更改

00:10:35.335 --> 00:10:37.638
從一個記錄區
但服務器不知道

00:10:38.172 --> 00:10:41.308
這兩種情況都會認作客戶端錯誤
從而顯示在這張圖裏

00:10:42.910 --> 00:10:45.479
通過形象化你的錯誤趨勢

00:10:45.879 --> 00:10:49.082
我們希望
你可以利用它來發現

00:10:49.149 --> 00:10:52.486
客戶發現異常頻繁的
錯誤數量的情況

00:10:53.687 --> 00:10:54.955
我們之前說過

00:10:55.022 --> 00:10:58.492
錯誤處理很重要
特別是對CloudKit支持的應用

00:10:59.426 --> 00:11:01.995
區別能正確處理錯誤的應用

00:11:02.062 --> 00:11:04.264
和不能正確處理錯誤的應用

00:11:04.331 --> 00:11:07.601
就在於區別
功能性應用和非功能性應用

00:11:07.868 --> 00:11:11.605
重要的是它是編寫
基於CloudKit的應用的一部分

00:11:12.072 --> 00:11:13.807
所以我們希望
你能好好用這些圖

00:11:13.874 --> 00:11:16.343
來發現你需要檢查的地方

00:11:16.410 --> 00:11:18.545
看看你的客戶
是如何處理錯誤的

00:11:19.179 --> 00:11:21.849
要了解更多
如何處理錯誤的知識

00:11:21.915 --> 00:11:25.252
我推薦你們參加明天的一個演講
CloudKit的最佳操作

00:11:25.485 --> 00:11:28.422
我們會拿出一部分時間
深入探討正確的錯誤處理

00:11:30.791 --> 00:11:33.760
接下來我要說說
API的一些改進

00:11:33.994 --> 00:11:36.463
這些都是上屆 WWDC後
新出的

00:11:37.030 --> 00:11:40.067
實際上我要講四點
希望你們能仔細聽

00:11:40.200 --> 00:11:42.503
首先是長時間操作

00:11:43.770 --> 00:11:47.474
長時間操作是一個機制
讓你不需要重複

00:11:47.541 --> 00:11:49.610
你已經對服務器
完成的工作

00:11:50.377 --> 00:11:54.081
所以按照現在的情況
應用關閉 操作就停止

00:11:54.147 --> 00:11:57.518
所有它執行的未完成操作
也會關閉

00:11:57.851 --> 00:12:00.654
即使這個操作
馬上就能完成了

00:12:02.623 --> 00:12:04.124
通過延長
你的操作時長

00:12:04.191 --> 00:12:07.294
操作的時長
可以超過應用的生存期

00:12:08.562 --> 00:12:11.565
它們會繼續運行
CloudKit也會繼續緩存

00:12:11.632 --> 00:12:14.001
本地緩存服務器的反饋

00:12:14.935 --> 00:12:18.105
當應用再次運行的時候
操作又繼續運行

00:12:18.172 --> 00:12:22.176
那麼我們只要返回給你
本地緩存中的緩存就可以

00:12:22.743 --> 00:12:25.112
在很多情況下
這個可以完全消除

00:12:25.179 --> 00:12:27.181
網絡連接再一次往返

00:12:27.915 --> 00:12:30.717
關於創時間操作的更多細節
我們明天再討論

00:12:30.784 --> 00:12:33.353
最佳操作 9點
歡迎你來參與

00:12:35.088 --> 00:12:38.592
下一個我想講的話題
是從我們的開發者那裏聽來的

00:12:38.659 --> 00:12:42.596
是關於不良連接下
CKOperation的行爲

00:12:43.096 --> 00:12:46.200
我想爲你們描述的場景是
我們有一臺設備

00:12:46.333 --> 00:12:48.368
設備的網絡
假設可用

00:12:48.435 --> 00:12:51.138
但是我們收不到任何流量
兩個方向都沒有

00:12:51.605 --> 00:12:55.075
另外提一下
你實際可以模擬這個場景

00:12:55.142 --> 00:12:56.710
通過使用網絡連接調節器

00:12:56.777 --> 00:13:00.113
這是一個很棒的開發者工具
可以模擬類似的情況

00:13:01.615 --> 00:13:04.585
現在 CKOperation
是NS操作的子類

00:13:04.651 --> 00:13:07.020
因此它有QualityOfService屬性

00:13:07.754 --> 00:13:11.225
如果操作被標記爲
用戶互動或用戶發起

00:13:11.291 --> 00:13:12.593
那麼在不良網絡環境下

00:13:12.659 --> 00:13:15.696
我們會在1分鐘後停止
並給出連接超時的報錯

00:13:16.597 --> 00:13:18.932
如果你的操作有任意一個
其他的QualityOfServices

00:13:18.999 --> 00:13:21.869
我們會繼續嘗試
最多七天

00:13:22.336 --> 00:13:23.871
這大概不是你理想的狀態

00:13:24.438 --> 00:13:26.139
另外 如果你選擇不設置

00:13:26.206 --> 00:13:28.709
一個明確的QualityOfService
在你的CKOperation中

00:13:28.775 --> 00:13:31.211
我們會幫你選一個
就是utility

00:13:32.279 --> 00:13:35.315
所以如果都算上
很多開發者報告說

00:13:35.382 --> 00:13:38.252
“都5天了
怎麼我的操作還沒完成”

00:13:38.652 --> 00:13:39.920
所以我們要解決這個問題

00:13:40.320 --> 00:13:43.056
解決辦法
是兩個新的API

00:13:44.024 --> 00:13:46.360
第一個用來解決
網絡無活動

00:13:46.426 --> 00:13:50.631
我們視它爲CKOperation的
TimeoutIntervalForRequest屬性

00:13:51.465 --> 00:13:52.799
默認爲1分鐘

00:13:52.966 --> 00:13:56.837
這個時間
是我們等待封裝傳送的時間

00:13:57.471 --> 00:14:00.440
如果在這段時間內
我們沒有看到任何流量進出

00:14:00.507 --> 00:14:03.477
我們會停止操作
並告訴你網絡連接超時

00:14:04.578 --> 00:14:07.514
我們還會設置
一個端到端超時

00:14:07.581 --> 00:14:11.652
表現爲CKOperation的
timeoutIntervalForResource屬性

00:14:12.486 --> 00:14:15.255
這個默認時長爲7天
這一段時間是用來

00:14:15.322 --> 00:14:17.324
等待整個網絡往返一次

00:14:17.391 --> 00:14:20.994
也就是從你的設備到服務器
然後再返回

00:14:21.828 --> 00:14:25.699
我要提醒大家一個CKOperation
可能發出多個網絡請求

00:14:25.766 --> 00:14:27.201
去完成它的任務

00:14:27.768 --> 00:14:30.671
因此一個CKOperation
所需時間會超過你的預期

00:14:30.737 --> 00:14:33.040
只要有所進展
能傳遞就可以

00:14:36.176 --> 00:14:38.712
下面來講講
如何有效地獲取

00:14:38.779 --> 00:14:40.047
一系列記錄更改

00:14:40.113 --> 00:14:42.482
當服務器裏
有很多記錄區的時候

00:14:42.916 --> 00:14:46.787
我們在研究分享功能的時候發現
客戶會看到更多的記錄區

00:14:46.854 --> 00:14:48.255
比你過去見過的要多

00:14:49.523 --> 00:14:51.124
以前你的解決方法是

00:14:51.191 --> 00:14:54.561
從數據庫中
截取一整列記錄區

00:14:54.628 --> 00:14:56.763
通過使用
CKFetchRecordZonesOperation

00:14:57.931 --> 00:14:58.932
但是這會產生幾個問題

00:14:58.999 --> 00:15:01.168
我們不想輪詢
也不想去截取

00:15:01.235 --> 00:15:03.637
一整列記錄區
然後從服務器上下載

00:15:03.737 --> 00:15:06.340
所以我們不再建議
使用這種方法

00:15:06.406 --> 00:15:08.542
我們用兩個新的概念
代替了它

00:15:09.309 --> 00:15:11.745
第一 CKDatabaseSubscription

00:15:12.446 --> 00:15:14.181
這個新類型可以被激發

00:15:14.248 --> 00:15:16.750
當數據庫裏
出現任何更改的時候

00:15:17.050 --> 00:15:19.820
即便是在
一個你不曾瞭解的記錄區

00:15:20.687 --> 00:15:24.224
第二個就是
CKFetchDatabaseChanges操作

00:15:24.758 --> 00:15:26.960
這是一種操作
讓你可以請求服務器

00:15:27.027 --> 00:15:29.596
給出一列記錄區
裏麪包含了未完成更改

00:15:29.663 --> 00:15:31.532
從過去的某個節點開始

00:15:33.967 --> 00:15:37.104
那麼現在你有了一列記錄區
你想從中截取更改

00:15:37.171 --> 00:15:38.472
如何做到呢？

00:15:39.106 --> 00:15:43.210
以前的方法是
發出CKFetchRecordChanges操作

00:15:43.277 --> 00:15:46.647
傳遞單一記錄區
從這個區裏獲取更改

00:15:47.514 --> 00:15:51.351
我們不想讓你逐個枚舉
所有的記錄區

00:15:51.418 --> 00:15:53.587
所以我們立刻
棄用了這個操作

00:15:54.454 --> 00:15:57.958
取而代之的是一個全新的操作
名字聽上去差不多

00:15:58.192 --> 00:16:00.994
CKFetchRecordZoneChangesOperation

00:16:02.462 --> 00:16:06.633
它實際上是個批次接口
覆蓋了以前的操作

00:16:06.700 --> 00:16:07.835
讓你可以

00:16:07.901 --> 00:16:10.537
從多個記錄區
獲取記錄更改信息

00:16:10.604 --> 00:16:12.105
只要一個網絡往返
就能完成

00:16:12.940 --> 00:16:14.808
那麼我們就來切實看一下

00:16:16.577 --> 00:16:18.512
這是一個數據庫
幾個記錄區

00:16:18.579 --> 00:16:20.547
每個記錄區
都有一系列記錄

00:16:20.781 --> 00:16:23.784
而客戶更新過了
所有更改

00:16:23.851 --> 00:16:26.253
現在又出現了
幾個新記錄

00:16:27.187 --> 00:16:31.325
你的客戶
由於已經存了CKDatabaseSubscription

00:16:31.825 --> 00:16:35.462
會造成服務器生成推送
併發給客戶

00:16:36.196 --> 00:16:39.666
然後 使用
CKFetchDatabaseChangesOperation

00:16:40.033 --> 00:16:43.203
你可以向服務器請求
一列包含未完成更改的記錄區

00:16:43.270 --> 00:16:45.172
這個例子裏
就是第一個和第三個

00:16:46.707 --> 00:16:48.742
有了這個記錄區列表

00:16:49.042 --> 00:16:51.945
你可以發起
CKFetchRecordZoneChangesOperation

00:16:52.212 --> 00:16:55.249
請求所有的記錄
和所有更改的記錄區

00:16:55.315 --> 00:16:56.817
完成在一個網絡往返中

00:17:01.455 --> 00:17:04.790
最後我要講講
如何快速的獲取更改

00:17:04.858 --> 00:17:07.694
在多個記錄存在
一個服務器的記錄區的情況下

00:17:08.829 --> 00:17:12.199
如果你以前
用過CloudKit獲取記錄

00:17:12.598 --> 00:17:14.734
那你會比較熟悉
moreComing標識

00:17:14.800 --> 00:17:17.704
它定義在
CKFetchRecordChangesOperation

00:17:17.771 --> 00:17:20.807
用來告訴你
這裏不僅有我們給你的更改

00:17:20.874 --> 00:17:23.242
服務器上還有更多
你能獲取的更改

00:17:23.310 --> 00:17:25.979
需要隨後發起
CKFetchRecordChangesOperation

00:17:27.414 --> 00:17:29.283
這個方法
有幾個問題

00:17:29.349 --> 00:17:32.920
第一就是
我們已經發出了檢查標識的邏輯

00:17:32.986 --> 00:17:35.656
並且發起了另一個操作
對所有其他客戶

00:17:36.023 --> 00:17:37.824
這有可能再次失敗

00:17:38.725 --> 00:17:42.596
第二就是在你考慮
要不要獲取並尾接新的操作

00:17:42.663 --> 00:17:43.964
通過尾接指令的時候

00:17:44.264 --> 00:17:45.899
CloudKit是空閒狀態

00:17:46.600 --> 00:17:48.202
我們想把兩個問題都解決

00:17:48.268 --> 00:17:51.038
所以我們利用了我們創建的全新操作

00:17:51.104 --> 00:17:54.341
CKFetchRecordChangesOperation
來改變這個模型

00:17:54.975 --> 00:17:57.978
不再是我們告訴你
這裏有更多可用的更改

00:17:58.045 --> 00:17:59.880
而是你告訴我們

00:17:59.947 --> 00:18:02.783
你想通過新的
fetchAllChanges屬性做什麼

00:18:04.384 --> 00:18:05.552
它的定義爲真時

00:18:05.786 --> 00:18:08.188
CloudKit會從服務器
獲取一批更改

00:18:08.255 --> 00:18:09.656
交給我們的客戶

00:18:09.723 --> 00:18:12.860
然後立刻返回服務器
獲取下一批更改

00:18:13.493 --> 00:18:15.429
這就讓運轉持續進行

00:18:15.495 --> 00:18:18.298
一邊開始拉取網絡數據
一邊是你的處理進程

00:18:19.366 --> 00:18:21.969
我們認爲這應該是個常見的行爲

00:18:22.035 --> 00:18:25.038
所以將它設定爲這一新類的默認行爲

00:18:26.507 --> 00:18:29.476
因此 新的
CKFetchRecordZoneChangesOperation

00:18:29.543 --> 00:18:32.045
默認的是
獲取整個記錄

00:18:32.112 --> 00:18:33.447
從指定的記錄區

00:18:36.850 --> 00:18:38.819
你可能會想
如果你有了一個大記錄區

00:18:38.886 --> 00:18:41.855
比如說服務器上
用戶的iCloud Photo Library

00:18:41.922 --> 00:18:45.726
這就意味着後續的操作
就要獲取記錄區中的所有記錄

00:18:45.792 --> 00:18:47.861
需要很長一段時間完成

00:18:48.629 --> 00:18:50.330
所以我們想能迅速恢復

00:18:50.397 --> 00:18:52.799
如果操作中途失敗的話

00:18:52.866 --> 00:18:56.570
我們不想重新下載
已經從服務器上獲取的批

00:18:57.104 --> 00:18:59.506
因此我們給這個新類
添加了新的回調

00:19:00.407 --> 00:19:03.110
RecordZoneChangeTokensUpdatedBlock

00:19:03.544 --> 00:19:05.212
在給出一批更改之後

00:19:05.279 --> 00:19:08.248
我們會告訴你
一個最新的服務器更改token

00:19:08.982 --> 00:19:12.419
那麼你寫的代碼
要做到兩件事

00:19:13.053 --> 00:19:14.655
首先你要commit

00:19:14.721 --> 00:19:18.091
每個你從服務器獲得的
記錄的更改

00:19:19.026 --> 00:19:22.563
第二要緩存
這個服務器token

00:19:23.864 --> 00:19:25.999
如果操作
在未來某個節點失敗了

00:19:26.066 --> 00:19:29.770
你可以發起一個新的
CKFetchRecordZoneChangesOperation

00:19:30.103 --> 00:19:32.806
傳遞給已經本地緩存好的
服務器token

00:19:32.873 --> 00:19:35.209
然後直接從斷掉的地方
繼續操作

00:19:35.309 --> 00:19:39.012
不需要重新下載
已經從服務器下載過的批數據

00:19:40.681 --> 00:19:43.951
這4個API的改進功能
是我們希望你們能好好利用的

00:19:44.017 --> 00:19:47.688
如果你正在編寫
基於CloudKit的應用

00:19:48.689 --> 00:19:50.457
接下來 我要換一個話題了

00:19:50.524 --> 00:19:53.627
讓我們有請Jacob Farkas上臺
來爲我們講解Sharing UI

00:19:54.127 --> 00:19:58.866
SHARING UI
你和我的分享空間

00:20:00.968 --> 00:20:01.802
謝謝你 Paul

00:20:02.469 --> 00:20:05.939
我是Jacob Farkas
是CloudKit小組的工程師

00:20:06.006 --> 00:20:07.441
今天我要講的是

00:20:07.508 --> 00:20:10.544
如何將CloudKit分享界面
添加到你的應用中

00:20:10.611 --> 00:20:12.613
而且只需要寫幾行代碼

00:20:15.415 --> 00:20:18.485
我們已介紹了CloudKit新類型
就是CKShare

00:20:18.785 --> 00:20:20.854
這是CKRecord的子類

00:20:21.021 --> 00:20:24.057
它負責存儲兩種重要的信息

00:20:24.625 --> 00:20:26.293
第一 分享的信息

00:20:26.693 --> 00:20:30.264
第二 分享給誰

00:20:31.565 --> 00:20:33.333
那麼我們來看個例子

00:20:33.400 --> 00:20:34.902
這是個人數據庫

00:20:34.968 --> 00:20:36.937
這裏有一個備註
在個人數據庫裏

00:20:37.271 --> 00:20:38.438
我們想分享它

00:20:39.840 --> 00:20:42.109
因此 我們要創建CKShare

00:20:43.410 --> 00:20:46.280
並把那個記錄作爲root record（根記錄）
來對它初始化

00:20:47.214 --> 00:20:49.783
創建Share
必須使用根記錄

00:20:49.850 --> 00:20:51.885
所以Share裏必須有內容

00:20:53.854 --> 00:20:56.423
接下來我們要保存
這個Share和根記錄

00:20:56.490 --> 00:20:57.991
要同時存到服務器

00:20:58.725 --> 00:21:02.296
這麼做是因爲
CKRecord有一個新屬性

00:21:02.362 --> 00:21:04.665
就是我們正在創建的Share
的一個引用

00:21:04.865 --> 00:21:07.501
通過同時保存根記錄和Share

00:21:08.068 --> 00:21:10.737
這個引用會與
你剛剛創建的Share聯繫起來

00:21:14.174 --> 00:21:16.677
我們不僅要定義分享什麼

00:21:16.743 --> 00:21:19.279
也需要定義分享給誰

00:21:20.080 --> 00:21:23.083
因此我們在CloudKit裏創建了
新的lookup服務

00:21:24.585 --> 00:21:27.554
這個lookup服務
會利用一個電子郵箱

00:21:28.055 --> 00:21:30.791
然後轉給
一個CKShare使用者

00:21:31.124 --> 00:21:33.493
你可在Share上
設置這個Share使用者

00:21:33.827 --> 00:21:35.329
將Share存到服務器

00:21:35.395 --> 00:21:38.699
現在他的iCloud賬戶
就可以訪問Share了

00:21:40.601 --> 00:21:43.203
我們也支持
通過電話號碼尋找用戶

00:21:43.270 --> 00:21:45.138
或者通過CloudKit用戶記錄ID

00:21:48.342 --> 00:21:52.513
現在我們希望用戶可以控制
他們分享數據庫裏的動態

00:21:52.579 --> 00:21:55.449
不想讓這些記錄反覆不停地出現

00:21:55.782 --> 00:21:58.118
用戶需要能控制它
這樣才能

00:21:58.185 --> 00:22:00.220
接受這個Share並加入它

00:22:01.054 --> 00:22:03.457
這就是說我們需要一個方法
去告訴其他用戶

00:22:03.524 --> 00:22:05.459
我們分享了東西給他們
並邀請他們

00:22:05.526 --> 00:22:06.894
並且告訴他們需要加入

00:22:07.461 --> 00:22:09.196
這個就是通過URL來實現

00:22:10.931 --> 00:22:14.201
每一個分享都帶一個URL
作爲它唯一的身份

00:22:15.102 --> 00:22:19.973
如果用戶在iOS按一下這個URL
或者macOS上點擊它

00:22:20.307 --> 00:22:22.142
接受UI會顯示出來

00:22:22.376 --> 00:22:24.611
詢問他們是否要加入這個Share

00:22:25.045 --> 00:22:27.080
如果是 會跳轉到應用

00:22:27.147 --> 00:22:28.982
他們會看到這個Share的內容

00:22:30.551 --> 00:22:34.488
URL最好的一點就是
如果用戶使用比較老的平臺

00:22:34.555 --> 00:22:36.590
或者是不支持分享的平臺

00:22:37.024 --> 00:22:38.625
它會轉到iCloud.com

00:22:38.692 --> 00:22:41.028
這樣我們也能
讓他們看到Share的內容

00:22:41.195 --> 00:22:43.830
告訴他們
如何接受並加入這個Share

00:22:45.599 --> 00:22:48.435
那麼就把這個URL放進電子郵件

00:22:48.735 --> 00:22:51.338
然後發送給
我們邀請的其他參與者

00:22:52.506 --> 00:22:55.342
他們會收到這封郵件 點擊它

00:22:55.776 --> 00:22:57.344
然後在他們的分享數據庫裏

00:22:57.411 --> 00:23:00.747
就可看到這個Share和Note
是我們創建並分享給他們的

00:23:02.449 --> 00:23:05.018
這裏最精彩的就是
這個分享數據庫

00:23:05.085 --> 00:23:08.021
實際上是個視圖
可以看到用戶的個人數據庫

00:23:08.288 --> 00:23:11.558
所以 如果另一個用戶
有權限訪問Share

00:23:12.025 --> 00:23:13.260
並且更新了這個Note

00:23:13.660 --> 00:23:16.930
我們會看到同樣的更改
出現在我們的個人數據庫中

00:23:17.931 --> 00:23:20.501
那麼我們來看一看
UI裏這個是什麼樣子

00:23:29.076 --> 00:23:32.312
好 我們做了Note
並添加了分享

00:23:32.379 --> 00:23:34.147
平臺是macOS X Sierra

00:23:35.883 --> 00:23:39.987
通過使用我們今天發佈的
CloudKit分享API

00:23:40.821 --> 00:23:44.458
就會看到一個新的Share Add
Person按鈕出現在上方

00:23:44.691 --> 00:23:46.059
點擊它

00:23:47.327 --> 00:23:50.697
會收到一個新的菜單
選擇如何分享URL

00:23:52.566 --> 00:23:53.567
當我們點擊分享

00:23:54.234 --> 00:23:57.171
系統UI會調令Notes...

00:23:57.638 --> 00:23:59.740
告訴Notes
要存下這個Share

00:23:59.806 --> 00:24:01.441
以及根記錄
給服務器

00:24:02.376 --> 00:24:05.445
一旦成功
系統UI會跳出一個寫郵件的窗口

00:24:05.512 --> 00:24:07.147
這裏可以邀請其他用戶

00:24:08.148 --> 00:24:09.283
點擊發送

00:24:09.850 --> 00:24:12.686
系統UI就會將這個Share
存到服務器

00:24:12.753 --> 00:24:14.188
尋找參與者

00:24:14.621 --> 00:24:16.723
然後再把郵件轉發給其他用戶

00:24:18.292 --> 00:24:20.761
那麼換到iPad看看
這裏另一個用戶

00:24:20.827 --> 00:24:22.296
我們看到了剛發出去的郵件

00:24:23.130 --> 00:24:24.932
我們可以點這個URL

00:24:25.766 --> 00:24:27.968
然後會詢問我們
是否要加入這個Share

00:24:29.603 --> 00:24:31.605
如果選是
我們會直接跳轉到Notes

00:24:31.672 --> 00:24:33.540
Share會顯示
Note開始下載

00:24:33.607 --> 00:24:36.109
現在我們就把這個Note
分享給其他用戶了

00:24:37.311 --> 00:24:39.713
如果對Note進行更改
在發起人的界面

00:24:39.980 --> 00:24:42.416
比如說我取消選擇列表上的牛油果

00:24:42.482 --> 00:24:44.852
添加青檸爲
另外要買的東西

00:24:45.586 --> 00:24:48.522
我們會看到
分享給我們的note也變了

00:24:56.530 --> 00:24:58.398
那麼現在看看
背後的代碼

00:25:01.735 --> 00:25:04.071
你們現在可能已經
很熟悉CloudKit框架了

00:25:04.137 --> 00:25:07.608
也就是CKRecord
和新的CKShare目標存在的地方

00:25:08.275 --> 00:25:10.511
如果要使用
新的系統分享UI

00:25:10.577 --> 00:25:13.447
你可以在
macOS下的AppKit裏

00:25:13.881 --> 00:25:15.949
和iOS下的UIKit裏找到

00:25:20.053 --> 00:25:22.689
首先我們來看iOS分享API

00:25:24.458 --> 00:25:28.295
在調出UI之前
當然要先創建一個Share

00:25:28.362 --> 00:25:30.564
我們就用這個根記錄創建Share

00:25:31.498 --> 00:25:35.002
我們會設置幾個屬性
讓UI顯示這個Share

00:25:35.969 --> 00:25:37.404
標題和縮略圖

00:25:38.539 --> 00:25:43.043
然後我們接着創建
UI雲分享控制器

00:25:44.344 --> 00:25:48.148
我們用剛建的Share對它初始化
然後傳遞給他一個準備處理器

00:25:49.016 --> 00:25:51.185
這個準備處理器會被調出

00:25:51.251 --> 00:25:53.820
當要把這個分享記錄
保存到服務器時

00:25:54.221 --> 00:25:57.691
這個處理器會創建
一個CKModifyRecordsOperation

00:25:58.158 --> 00:26:00.060
保存記錄和Share到服務器

00:26:00.594 --> 00:26:03.330
完成之後
就會調出完成處理器

00:26:06.633 --> 00:26:10.737
下面我們就要設置一個屬性
給這個UI雲分享控制器

00:26:11.738 --> 00:26:14.541
其中一個屬性就是
available permissions

00:26:14.608 --> 00:26:17.678
我們可以選擇
是隻公開分享這個Share

00:26:17.744 --> 00:26:21.181
還是隻給參與者
讀或寫的許可

00:26:21.815 --> 00:26:25.953
我們還要設置
presentation controller源視圖

00:26:26.019 --> 00:26:30.357
讓添加朋友的彈窗出現在
我們點擊按鈕的地方

00:26:31.725 --> 00:26:33.293
我們定義自己爲代理

00:26:33.360 --> 00:26:36.230
這樣我們就可以收到
UI活動的返回

00:26:36.797 --> 00:26:39.566
最後調出Present
這時

00:26:39.633 --> 00:26:42.102
跳出一個這樣的彈窗

00:26:43.470 --> 00:26:45.973
這時 如果你已經保存了
這個Share到服務器

00:26:46.039 --> 00:26:49.109
就可以只用Share
調出UI雲分享控制器

00:26:49.676 --> 00:26:51.812
然後它會顯示
一個被邀請用戶的列表

00:26:51.879 --> 00:26:53.981
讓他們管理Share上的用戶

00:26:54.047 --> 00:26:55.849
也可以按他們的意願停止分享

00:26:55.916 --> 00:26:58.852
所有的事情
系統UI都爲你考慮好了

00:27:02.222 --> 00:27:04.224
macOS分享API
跟這個十分相似

00:27:04.291 --> 00:27:07.094
所以我們就快速過一下
着重講一下不同之處

00:27:09.196 --> 00:27:11.598
首先創建一個
NSItem provider

00:27:11.665 --> 00:27:14.134
用它註冊
CloudKit Share

00:27:14.701 --> 00:27:16.737
這個處理器看上去
跟我們之前看到的一樣

00:27:16.803 --> 00:27:19.039
你要把記錄裏的Share
保存到服務器

00:27:19.106 --> 00:27:21.308
完成後 調出完成處理器

00:27:22.843 --> 00:27:25.479
接下來你要創建一個
NSSharingService

00:27:26.213 --> 00:27:29.550
這個分享服務的代理
就是你自己

00:27:29.616 --> 00:27:30.717
然後調出perform

00:27:30.784 --> 00:27:33.253
通過剛剛創建的
NSItem provider

00:27:36.523 --> 00:27:39.893
最後 NSSharingService可以回調

00:27:39.960 --> 00:27:43.430
所以 如果你設置
Share的可操作選項

00:27:43.697 --> 00:27:46.533
你就要回調
Share選項

00:27:49.136 --> 00:27:52.105
macOS上
Share創建的UI是這個樣子

00:27:52.539 --> 00:27:56.276
如果要在Share上修改參與者
界面是這樣

00:27:59.313 --> 00:28:02.449
如果一個用戶
接受你的應用的分享

00:28:02.850 --> 00:28:04.518
你的應用就會發布

00:28:04.585 --> 00:28:08.956
然後收到這個回調
ApplicationuserAcceptedCloudKitShare

00:28:09.456 --> 00:28:13.360
回調中包含Share元數據
是根記錄中的Share

00:28:13.427 --> 00:28:14.828
是用戶剛剛同意的

00:28:15.729 --> 00:28:17.231
這個iOS的操作很像

00:28:17.297 --> 00:28:20.834
除了用的是UIApplication
而非NSApplication

00:28:23.570 --> 00:28:27.708
最後 你要告訴系統
你的應用支持CloudKit分享

00:28:28.008 --> 00:28:30.544
這要通過
CKSharingSupported key實現

00:28:30.611 --> 00:28:31.912
就在info P list裏

00:28:34.314 --> 00:28:37.217
我們還要高興地宣佈
我們已經把完全分享支持添加到了

00:28:37.284 --> 00:28:39.286
CloudKit JavaScript庫

00:28:39.353 --> 00:28:42.789
這樣只要你在網上
就可以創建和接受Share

00:28:42.856 --> 00:28:47.194
而且我們已經提供了一些UI
讓你可以用來管理Share

00:28:47.861 --> 00:28:50.731
你現在就可以
在CloudKit目錄裏試試看

00:28:51.899 --> 00:28:54.301
現在我要將舞臺
轉交給我的同事Vanessa

00:28:54.368 --> 00:28:57.137
她會爲你們
深入講解分享

00:29:02.276 --> 00:29:03.143
謝謝你 Jacob

00:29:04.144 --> 00:29:05.679
嗨 下午好

00:29:06.446 --> 00:29:07.548
我叫Vanessa Hong

00:29:07.614 --> 00:29:09.983
我是CloudKit
服務器小組的工程師

00:29:11.218 --> 00:29:15.989
今天我們要深入瞭解分享
通過展示一些常見的使用場景

00:29:18.158 --> 00:29:20.327
首先從被分享的數據講起吧

00:29:20.394 --> 00:29:22.196
之後我們會逐步深入

00:29:22.262 --> 00:29:24.431
講解CKShare對象中的
internal

00:29:25.165 --> 00:29:28.402
之後我們講講
如何調出分享API

00:29:28.468 --> 00:29:30.404
如果你想創建
自定義的UI的話

00:29:31.238 --> 00:29:33.907
最後結尾講一些
特別需要注意的事項

00:29:34.374 --> 00:29:35.475
現在就開始吧

00:29:38.545 --> 00:29:40.814
Jacob展示了
如何分享一個單一記錄

00:29:41.181 --> 00:29:45.752
但是用戶想分享的
有時不只是一個單一的記錄

00:29:46.019 --> 00:29:48.322
可能是很多記錄

00:29:48.655 --> 00:29:51.158
可能已經連接了
CKReferences

00:29:52.593 --> 00:29:57.130
但是你的應用只想讓參與者
看到這個記錄的一部分

00:29:57.898 --> 00:30:00.934
這就是爲什麼我們要在
CKRecord上引進新的域

00:30:01.001 --> 00:30:02.669
叫Parent Reference

00:30:04.004 --> 00:30:05.138
設置
Parent Reference

00:30:05.205 --> 00:30:08.475
可以在任何
你想在包含於分享結構層的記錄上

00:30:09.142 --> 00:30:12.613
這個設置甚至可以
在用戶決定分享之前完成

00:30:16.083 --> 00:30:17.251
當用戶確實要分享

00:30:17.317 --> 00:30:20.153
你可以只用根記錄
創建CKShare

00:30:20.587 --> 00:30:22.322
之後所有產生的記錄

00:30:22.389 --> 00:30:25.592
都會通過Parent Reference
鏈接到這個根記錄

00:30:25.826 --> 00:30:28.462
並且自動
存入分享結構層

00:30:29.129 --> 00:30:31.932
那麼來看看
在分享數據庫裏是什麼樣子

00:30:34.168 --> 00:30:38.172
一個分享數據庫只是一個視圖
可以看到用戶的個人數據庫

00:30:38.739 --> 00:30:41.074
所以它不包含
任何具體的記錄

00:30:42.843 --> 00:30:47.447
當一個參與者接受了一個Share
他們只能看到分享給他們的內容

00:30:47.514 --> 00:30:49.216
所以他們看到是分享的那個層次

00:30:50.417 --> 00:30:54.054
也就是說這些記錄沒有複製

00:30:54.121 --> 00:30:57.658
只有一套數據
並存在所有者的個人數據庫中

00:30:58.192 --> 00:31:01.295
也就是說
所有者和所有的參與者

00:31:01.361 --> 00:31:03.964
都通過同一套記錄互動

00:31:04.631 --> 00:31:07.835
這種爭用
最後可能會導致衝突

00:31:09.036 --> 00:31:10.671
要學習如何處理衝突

00:31:10.737 --> 00:31:12.039
我推薦你們

00:31:12.105 --> 00:31:16.109
2014年 WWDC的一場
“高級CloudKit”演講

00:31:17.778 --> 00:31:22.583
現在 可讀/寫參與者
就可以修改 刪除和添加記錄了

00:31:24.551 --> 00:31:27.788
但是我們又不想
讓他們隨意添加東西

00:31:27.855 --> 00:31:29.356
到別人的數據庫裏

00:31:30.057 --> 00:31:33.126
比如他們不能隨意添加根記錄

00:31:34.228 --> 00:31:37.664
也不能添加沒有
Parent Reference的記錄

00:31:37.731 --> 00:31:40.601
即便是它能連接到
分享結構層

00:31:41.802 --> 00:31:47.441
所以要通過分享數據庫
正確的添加新紀錄

00:31:48.375 --> 00:31:52.379
就要設置Parent Reference
並連接到分享結構層

00:31:54.114 --> 00:31:58.185
這樣即便你添加
新的記錄給參與者

00:31:58.252 --> 00:31:59.887
通過分享數據庫

00:32:00.254 --> 00:32:03.090
新的記錄只存在
所有者個人數據庫裏

00:32:03.790 --> 00:32:05.025
這就意味着

00:32:05.325 --> 00:32:09.930
所有參與者添加的記錄
都不計入所有者的配額

00:32:10.564 --> 00:32:15.402
因此創建的份額不受影響
開發者的份額也不受影響

00:32:17.104 --> 00:32:20.841
所有者的個人數據庫是
唯一保存這些記錄的地方

00:32:20.908 --> 00:32:23.410
所以我們只能讓他們
不影響所有者的份額

00:32:24.678 --> 00:32:26.680
這就是如何分享多個記錄

00:32:28.248 --> 00:32:31.084
我們來近距離研究下
分享數據庫

00:32:33.687 --> 00:32:37.724
這裏我們有兩個Share
來自兩個不同的所有者

00:32:38.225 --> 00:32:41.028
但是兩個Shares名字一樣
那怎麼區分？

00:32:41.962 --> 00:32:44.665
我們忽略了
一個十分重要的細節

00:32:44.731 --> 00:32:48.435
就是所有CloudKit的記錄
都存在記錄區裏

00:32:48.969 --> 00:32:52.239
而這個區是由CKRecord
Zone ID定義的

00:32:54.308 --> 00:32:55.309
這個區的名字

00:32:55.375 --> 00:32:58.011
是你創建的
自定義的區的名字

00:32:58.412 --> 00:32:59.680
其所有者的個人數據庫中

00:33:00.848 --> 00:33:03.817
所有者的名字
就是所有者的用戶記錄名字

00:33:04.651 --> 00:33:08.322
這個例子中的兩個區 有同樣的名字
但是屬於不同的所有者

00:33:08.956 --> 00:33:12.693
假設第一個所有者分享了一些東西
但是在不同的區

00:33:13.293 --> 00:33:16.063
那麼當你調出
FetchDatabaseChanges API時

00:33:16.129 --> 00:33:17.764
這個新的區會出現

00:33:17.831 --> 00:33:21.001
之後當你調出
FetchRecordZoneChanges

00:33:21.068 --> 00:33:23.003
你會看到新的記錄和Share

00:33:24.605 --> 00:33:28.876
假設第二個所有者
分享的東西在現有的區裏

00:33:30.077 --> 00:33:32.079
這個區已經存在
所以不需要再建新的

00:33:32.145 --> 00:33:33.146
我們只要再利用

00:33:33.981 --> 00:33:35.482
當調出
FetchChanges API時

00:33:35.549 --> 00:33:38.952
你會看到這個區發生了變化
新的記錄出現了

00:33:40.854 --> 00:33:42.422
這就是我們的分享數據庫

00:33:43.323 --> 00:33:46.727
那麼再深入一層
看看CKShare對象

00:33:49.730 --> 00:33:53.734
在所有者創建Share之前
得有要分享的東西

00:33:54.034 --> 00:33:56.436
因此 記錄代表了Share的內容

00:33:57.938 --> 00:34:01.208
CKShare代表瞭如何分享

00:34:02.075 --> 00:34:03.644
我們要講的是
如何分享

00:34:05.712 --> 00:34:07.047
就像Jacob說的

00:34:07.114 --> 00:34:11.284
每個CKShare都是一個CKRecord
但有附加屬性

00:34:11.918 --> 00:34:16.123
我們之前講過了這些屬性
如何應用於Share的生存期

00:34:16.190 --> 00:34:20.060
所以如果重頭開始
所有者就要創建一個Share

00:34:21.995 --> 00:34:25.465
還要決定Share的
publicPermission如何

00:34:25.766 --> 00:34:27.768
這個例子裏
所有者決定是none

00:34:27.835 --> 00:34:30.003
因爲他想要邀請參與者

00:34:30.771 --> 00:34:32.873
假設他邀請了兩個參與者

00:34:33.172 --> 00:34:35.409
他們的狀態是自動接受邀請

00:34:36.310 --> 00:34:39.813
之後所有者就要考慮
給每個邀請者什麼樣的權限

00:34:41.715 --> 00:34:45.152
然後所有者保存Share後
就會收到Share的URL

00:34:45.985 --> 00:34:47.888
這裏會發生兩件事

00:34:47.987 --> 00:34:50.690
第一是這個Share有一個聲明

00:34:50.958 --> 00:34:52.059
聲明說

00:34:52.125 --> 00:34:54.795
只有兩個參與者
可以接受這個Share

00:34:55.596 --> 00:34:57.231
所有者是唯一知道該URL的人

00:34:57.297 --> 00:35:00.734
只有他能
將這個URL告訴其他人

00:35:01.802 --> 00:35:04.338
所以即使他把這個URL
告訴了100個人

00:35:04.404 --> 00:35:06.974
還是隻有兩個人
可以接受這個Share

00:35:08.141 --> 00:35:12.646
當一個參與者通過URL
接受了這個Share

00:35:15.382 --> 00:35:18.452
接受之後
他們的接受狀態就會變成已接受

00:35:19.319 --> 00:35:22.623
然後Share的權限
就是所有者給予他們的權限

00:35:23.657 --> 00:35:27.194
假設所有者
想要創建一個更加開放的分享

00:35:27.427 --> 00:35:28.729
就讓我們重頭開始

00:35:31.832 --> 00:35:33.433
所有者設立一個Share

00:35:34.935 --> 00:35:38.605
將公用權限設置爲
只讀或者是可讀/寫

00:35:39.773 --> 00:35:42.576
他沒有邀請任何人
只是保存這個Share

00:35:43.043 --> 00:35:44.978
之後他獲得了這個分享的URL

00:35:45.779 --> 00:35:47.247
這時仍然有兩件事會發生

00:35:47.314 --> 00:35:51.919
第一是Share有一個聲明
說任何人都可以參加

00:35:52.452 --> 00:35:53.987
所有者還是唯一知道URL的人

00:35:54.721 --> 00:35:57.291
他負責告訴其他人

00:35:57.424 --> 00:36:00.894
假如他告訴了100個人
那麼所有這100個人都能參加

00:36:02.029 --> 00:36:04.464
他們也要
通過這個URL參加

00:36:04.531 --> 00:36:08.569
然後出現在Share裏的參與者
狀態變爲已接受

00:36:09.603 --> 00:36:13.373
他們的權限來自於Share的
publicPermissionfield

00:36:15.876 --> 00:36:18.111
這就是你如何創立一個分享
和接受一個分享

00:36:19.079 --> 00:36:23.717
Share的第二個階段
就是當參與者退出時

00:36:25.919 --> 00:36:27.988
當然參與者可以退出分享

00:36:28.055 --> 00:36:31.925
通過刪除
分享數據庫裏的CKShare對象

00:36:33.493 --> 00:36:36.964
這同時會刪除
分享數據庫裏的分享記錄

00:36:37.264 --> 00:36:39.600
要明確的是
CKShare仍然存在

00:36:39.666 --> 00:36:42.269
它在所有者的個人數據庫裏

00:36:42.336 --> 00:36:44.037
只是這個參與者

00:36:44.404 --> 00:36:47.007
不再出現在Share裏
也不再是被邀請的狀態

00:36:48.942 --> 00:36:51.812
但是所有者
對他的Share有完全掌控

00:36:52.646 --> 00:36:54.281
他可以刪除任何一個人

00:36:55.983 --> 00:36:57.918
假設他想把所有人都刪了

00:36:59.119 --> 00:37:01.755
他就要刪除CKShared對象

00:37:01.822 --> 00:37:03.323
從他的個人數據庫裏清除

00:37:04.057 --> 00:37:07.261
這會刪除
Share根記錄的pointer

00:37:09.396 --> 00:37:12.633
這時所有者就回到初始狀態
就是未分享狀態

00:37:15.235 --> 00:37:19.006
接着我們來講講
CKShareParticipant對象

00:37:19.573 --> 00:37:21.775
如果你見過這個對象
在生存期開始之前

00:37:21.842 --> 00:37:24.211
你會看到接受狀態和許可

00:37:24.444 --> 00:37:26.680
但是現在看一看
UserIdentity類

00:37:27.648 --> 00:37:29.049
這有lookupInfo

00:37:29.550 --> 00:37:33.120
是指參與者是如何
被邀請到Share的

00:37:33.554 --> 00:37:36.924
所以這裏會有他們的郵箱
電話或者用戶記錄ID

00:37:37.958 --> 00:37:40.027
名字分爲
姓和名

00:37:40.093 --> 00:37:43.564
它會在參與者接受
這個Share的時候彈出

00:37:46.533 --> 00:37:49.803
每個CKShareParticipant
會分到一個iCloud賬戶

00:37:50.470 --> 00:37:53.173
那麼假設
所有者邀請了4個人

00:37:53.240 --> 00:37:56.376
我們能找到
前兩個人的iCloud賬戶

00:37:57.311 --> 00:37:59.646
但是後兩個人沒有

00:37:59.947 --> 00:38:01.114
但是這沒什麼問題

00:38:01.415 --> 00:38:04.151
CloudKit
會創建一個臨時佔位符

00:38:04.218 --> 00:38:05.619
給第三個和第四個人

00:38:06.286 --> 00:38:09.823
而且只有第3和第4個參與者

00:38:10.123 --> 00:38:11.525
需要證明

00:38:11.592 --> 00:38:13.994
他們持有的
郵箱地址和電話號碼

00:38:14.328 --> 00:38:17.831
是所有者邀請他們時提供的
這就是驗證過程

00:38:18.765 --> 00:38:21.535
這個過程會將
郵箱或者電話與賬戶聯繫在一起

00:38:21.602 --> 00:38:24.705
這樣就不需要
再走一遍驗證過程

00:38:27.107 --> 00:38:29.576
這就是我們現在
在分享中的所有對象

00:38:29.676 --> 00:38:32.679
那麼接下來
我們聊聊分享API

00:38:34.681 --> 00:38:36.850
如果你想創建自定義UI

00:38:36.917 --> 00:38:40.354
你可以調出我們的API
有兩種方法

00:38:40.854 --> 00:38:43.991
代表所有者
你可以幫他們設立一個Share

00:38:44.691 --> 00:38:48.028
代表參與者
你可以幫他們接受一個Share

00:38:48.862 --> 00:38:52.399
watchOS和tvOS
沒有內置的系統UI

00:38:53.100 --> 00:38:54.468
所以你可以讓你的用戶

00:38:54.535 --> 00:38:57.738
用另一個平臺
建立和接受一個Share

00:38:57.804 --> 00:39:01.375
之後這個Share的數據
在所有平臺上就都可用了

00:39:02.342 --> 00:39:05.712
或者你也可以調出
我們的分享API

00:39:05.779 --> 00:39:06.947
你要這麼做

00:39:09.816 --> 00:39:12.686
代表所有者
你要幫他們添加參與者

00:39:13.654 --> 00:39:16.990
你需要尋找他們
通過郵件 電話或者用戶記錄ID

00:39:17.257 --> 00:39:20.160
然後轉換成
CKShareParticipant對象

00:39:21.662 --> 00:39:23.897
一旦獲得了
CKShareParticipant對象

00:39:23.964 --> 00:39:25.566
就要添加到分享裏

00:39:26.667 --> 00:39:30.337
然後調出CKModifyRecordsOperation
來保存這個分享

00:39:30.904 --> 00:39:34.441
現在你的應用
就獲得了這個分享的URL

00:39:35.042 --> 00:39:38.679
當然你可以決定
是應用還是所有者

00:39:38.745 --> 00:39:40.414
來把這個URL告訴別人

00:39:41.849 --> 00:39:45.085
當一個參與者接受一個分享
第一步都是從URL開始

00:39:47.354 --> 00:39:50.858
首先要將URL轉換成
CKShareMetadata對象

00:39:50.924 --> 00:39:55.095
然後將這個元數據傳遞給
CKAcceptSharesOperation

00:39:56.330 --> 00:39:59.700
現在 參與者就會顯示在分享中
並且是已接受的狀態

00:40:01.268 --> 00:40:04.671
這個已接受的API
也有一些限制

00:40:05.639 --> 00:40:09.243
從隱私角度來說
我們無法返回他們的姓名組件

00:40:09.309 --> 00:40:11.478
那麼驗證程序不可用

00:40:11.778 --> 00:40:13.347
如果你收到這個報錯

00:40:13.780 --> 00:40:16.650
或者iCloud賬戶的
Boolean爲假

00:40:17.551 --> 00:40:20.420
那麼你要讓你的用戶
親自打開這個URL

00:40:20.487 --> 00:40:23.657
這樣可以觸發系統或者網絡

00:40:24.124 --> 00:40:26.159
讓他們通過驗證過程

00:40:28.262 --> 00:40:29.663
以上就是分享API

00:40:30.430 --> 00:40:32.733
現在我們再來說說
你的用戶

00:40:35.736 --> 00:40:39.339
應用的用戶可以邀請
任何他們想邀請的人

00:40:39.973 --> 00:40:42.709
通過郵件或者電話

00:40:43.210 --> 00:40:44.578
這就意味着

00:40:45.179 --> 00:40:50.017
應用的潛在用戶
要遠遠多於現在的用戶羣

00:40:50.918 --> 00:40:54.288
這些被邀請人可能沒有安裝
最新的操作系統

00:40:54.354 --> 00:40:56.156
他們甚至可能沒有Apple的產品

00:40:56.223 --> 00:41:00.394
所以當他們點擊這個URL
我們會把他們轉到網頁

00:41:01.528 --> 00:41:04.331
以Notes爲例
這就是他們看到的畫面

00:41:05.299 --> 00:41:09.603
他們會被要求加入分享
然後他們就可以看到分享的內容

00:41:11.371 --> 00:41:14.341
他們可以與這個Note互動
就像在設備上一樣

00:41:15.175 --> 00:41:19.012
但是這是個Note網頁應用
存在於iCloud.com

00:41:19.079 --> 00:41:21.148
你的應用如何呢？

00:41:21.682 --> 00:41:24.852
默認的情況下
你的用戶會看到這樣一個界面

00:41:25.619 --> 00:41:29.122
這裏有你的應用的圖標
並要求你的用戶使用最近使用的設備

00:41:29.623 --> 00:41:32.659
這不是最理想的用戶體驗

00:41:33.160 --> 00:41:35.395
所以我有一些好消息要告訴你

00:41:36.230 --> 00:41:40.567
你可以到CloudKit Dashboard
設置一個fallback URL

00:41:41.602 --> 00:41:45.339
如果被邀請人點擊了
這個分享給他們的URL

00:41:46.073 --> 00:41:49.009
我們會把他們
重新導向你的fallback URL

00:41:49.776 --> 00:41:53.580
我們會在後面添加token
代表Share的唯一URL

00:41:54.047 --> 00:41:56.884
這樣你就可以
立刻讓他們接受share

00:41:56.950 --> 00:41:58.652
然後顯示分享的數據

00:42:00.287 --> 00:42:02.890
現在我希望
你們都等不及要開始分享了

00:42:03.524 --> 00:42:05.726
這是最後一點
你們要知道的

00:42:07.027 --> 00:42:09.596
CKShare是最新的記錄類型

00:42:09.663 --> 00:42:13.967
這種類型
與CloudKit其他類型一樣

00:42:14.701 --> 00:42:17.704
可以在上面創建自定義域
你可以運行查詢指令

00:42:18.338 --> 00:42:22.376
你也可以第一個
在開發環境下創建新記錄

00:42:22.976 --> 00:42:25.512
創建的最簡單的方法

00:42:26.013 --> 00:42:28.649
就是使用用戶身份
登錄開發環境

00:42:28.715 --> 00:42:31.151
然後從你的個人數據庫
分享點什麼

00:42:32.419 --> 00:42:34.888
這樣就會觸發
記錄類型的創建

00:42:35.022 --> 00:42:38.425
然後去CloudKit Dashboard
部署scheme給production

00:42:38.926 --> 00:42:40.260
如果不這麼做

00:42:40.561 --> 00:42:44.398
那麼用戶在production環境下
創建分享時就會出錯

00:42:44.464 --> 00:42:46.934
因爲記錄類型還沒成立

00:42:49.102 --> 00:42:50.103
這就是最後我要講的

00:42:51.405 --> 00:42:52.906
那麼 今天你們瞭解了

00:42:52.973 --> 00:42:56.043
CloudKit可用於所有平臺
包括watchOS

00:42:56.109 --> 00:42:59.713
它也可用於網絡
通過CloudKit JS

00:43:01.682 --> 00:43:05.152
Telemetry在CloudKit
Dashboard可用

00:43:05.219 --> 00:43:08.121
這是個很好的辦法
來視覺化你的應用的行爲

00:43:08.188 --> 00:43:09.823
包括錯誤趨勢

00:43:10.557 --> 00:43:14.194
API有了很多改進
包括長時間操作

00:43:14.795 --> 00:43:17.464
QualityOfService
還有最新fetch changes APIs

00:43:18.265 --> 00:43:21.001
現在你也全面瞭解了
我們的新功能 分享

00:43:21.535 --> 00:43:22.970
你看到了這個系統UI

00:43:23.737 --> 00:43:26.340
你知道了
如何創建自定義UI

00:43:26.406 --> 00:43:28.008
通過調出我們的分享API

00:43:28.475 --> 00:43:30.677
你也看過了所有
我們用在分享中的對象

00:43:31.245 --> 00:43:32.946
包括分享者的存在週期

00:43:33.480 --> 00:43:36.416
我打賭你們回去後
會設置這些fallback URL

00:43:38.151 --> 00:43:41.021
那麼 感謝你們
與我們分享這樣的體驗

00:43:42.856 --> 00:43:45.225
我想請大家關注這場演講
“CloudKit的最佳操作”

00:43:45.292 --> 00:43:46.693
就在明天早上九點

00:43:46.760 --> 00:43:49.730
這場演講很精彩
讓你瞭解如何能有效率地使用CloudKit

00:43:50.597 --> 00:43:54.434
謝謝你們的到來
希望你們享受 WWDC 的其他會議