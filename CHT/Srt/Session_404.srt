00:00:19.353 --> 00:00:23.190 
Swift入門

00:00:23.257 --> 00:00:25.926 
大家好歡迎參加Swift入門

00:00:26.426 --> 00:00:29.563 
我是Dave Addey
和同事Brian和Alex一起

00:00:29.630 --> 00:00:33.033 
我想要給你們一個Swift編程語言
的快速概覽

00:00:33.800 --> 00:00:36.970 
在之後60分鐘裏
你們會獲得足夠的Swift 3知識

00:00:37.037 --> 00:00:40.774 
來能夠閱讀Swift代碼
最好還能開始寫代碼

00:00:42.309 --> 00:00:46.180 
讓我們看看這個語言的一些基礎

00:00:46.680 --> 00:00:48.916 
這是一些我兩年前寫的代碼

00:00:49.383 --> 00:00:51.418 
我寫了一個常量
用let來表明

00:00:51.718 --> 00:00:54.188 
這被叫做language
是一個字符串類型

00:00:54.721 --> 00:00:57.491 
這中間的冒號我們會經常
在Swift中看見

00:00:57.558 --> 00:00:58.992 
它表明是類型

00:00:59.059 --> 00:01:00.994 
language是一個字符串類型

00:01:01.562 --> 00:01:04.730 
我在swift代碼裏用字符串給它賦值

00:01:05.966 --> 00:01:06.934 
讓我們做更多

00:01:07.301 --> 00:01:09.403 
假設有個整數稱爲
introduced

00:01:09.469 --> 00:01:10.904 
我們將它賦值爲2014

00:01:11.305 --> 00:01:13.307 
及一個布爾型被稱爲
isAwesome

00:01:13.473 --> 00:01:14.675 
把它設爲真

00:01:16.043 --> 00:01:19.413 
你注意到這些值都無需改變

00:01:19.713 --> 00:01:21.515 
名字language不會改變

00:01:21.582 --> 00:01:23.183 
或者它出現的年份

00:01:23.684 --> 00:01:26.486 
兩年了Swift還是很好

00:01:26.553 --> 00:01:28.355 
所以這也可以是一個常量

00:01:28.989 --> 00:01:30.924 
這是Swift中的一般原則

00:01:31.258 --> 00:01:34.027 
如果一些量不需要被改變
我們申明它爲常量

00:01:35.329 --> 00:01:38.131 
現在你可能還注意到了命名習慣

00:01:38.565 --> 00:01:41.902 
常量和變量是小寫開始的駝峯式
命名法

00:01:41.969 --> 00:01:45.372 
像字符串、取整和布爾
類型是大寫駝峯式命名法

00:01:47.174 --> 00:01:49.209 
現在如果我們看右邊的這些

00:01:49.276 --> 00:01:50.644 
很明顯

00:01:50.711 --> 00:01:54.314 
我想要的是字符串 整數 布爾型

00:01:55.215 --> 00:01:58.385 
在這種情況下
Swift會推斷這些類型

00:01:58.452 --> 00:02:00.754 
我們不需要寫出來

00:02:00.821 --> 00:02:03.323 
你仍然得到明確申明瞭類型的變量

00:02:03.390 --> 00:02:04.992 
但是你不用寫那麼多代碼

00:02:06.426 --> 00:02:07.861 
這是一些常量

00:02:07.928 --> 00:02:10.797 
那麼對於變量呢？
它們有時候會改變

00:02:10.864 --> 00:02:12.799 
這是一個變量
被用var表明

00:02:12.866 --> 00:02:14.401 
這是爲了語言的版本

00:02:14.468 --> 00:02:17.838 
它被改變了
讓我們更新它到2016年的情況

00:02:19.239 --> 00:02:21.608 
現在如果我試着對常量這樣做

00:02:21.675 --> 00:02:23.977 
如果我試着給
isAwesome賦值爲假

00:02:24.645 --> 00:02:25.979 
Swift告訴我有個錯誤

00:02:26.046 --> 00:02:27.047 
這是對的

00:02:28.982 --> 00:02:31.285 
編程時常做的一件事

00:02:31.351 --> 00:02:33.320 
是通過其它值生成字符串

00:02:33.387 --> 00:02:36.089 
我們可以把字符串連接在一起

00:02:36.156 --> 00:02:39.393 
像這裏展示的這樣
但是Swift有一個更整潔的方法

00:02:39.459 --> 00:02:42.162 
被稱爲字符串插入
它看起來是這樣的

00:02:42.930 --> 00:02:46.233 
我們可以把字符串和值放進
一個更大的字符串

00:02:46.300 --> 00:02:49.403 
通過用括號包裹並在前面加一個
反斜槓

00:02:49.469 --> 00:02:52.005 
我們在這想生成消息
“Hello WWDC”

00:02:53.207 --> 00:02:54.908 
我們並不只用字符串

00:02:54.975 --> 00:02:56.443 
我們還可以添加其他值

00:02:56.510 --> 00:02:58.478 
像是這裏的整數
加入年

00:02:59.079 --> 00:03:01.582 
我們還可以加入表達式

00:03:01.648 --> 00:03:04.751 
我們可以讓年加1
爲了可能是明年的代碼

00:03:06.520 --> 00:03:09.756 
現在Swift中的字符串
對於Unicode編碼是完全兼容的

00:03:09.823 --> 00:03:14.127 
它可以是ASCII
也可以是貓 狗 國旗

00:03:14.828 --> 00:03:16.530 
這都是相同的

00:03:16.597 --> 00:03:19.066 
不論是常量還是變量

00:03:19.132 --> 00:03:20.868 
你幾乎可以使用任何字符

00:03:20.934 --> 00:03:23.036 
在常量和變量名中

00:03:24.338 --> 00:03:26.373 
說到標準字符

00:03:26.440 --> 00:03:29.409 
Swift做了很多工作來解決這意味
什麼

00:03:29.476 --> 00:03:30.844 
做爲一個單獨字符

00:03:31.311 --> 00:03:33.780 
無論你的字符串是怎樣在幕後編碼的

00:03:33.847 --> 00:03:35.349 
或者怎麼顯示在屏幕上

00:03:36.683 --> 00:03:38.785 
我有一個字符串
叫做dogString

00:03:39.353 --> 00:03:42.689 
你可能認爲它有6個字符

00:03:42.756 --> 00:03:46.627 
D O G ？！狗臉

00:03:47.194 --> 00:03:48.495 
但你錯了

00:03:48.562 --> 00:03:51.098 
這裏只有5個字符而不是6個

00:03:51.765 --> 00:03:55.302 
這裏有一個特殊符號
被稱爲問號驚歎號

00:03:55.369 --> 00:03:59.106 
很好的用來形容狗

00:04:00.374 --> 00:04:02.910 
如果你不相信我
讓Swift來證明這點

00:04:03.744 --> 00:04:06.146 
每個字符串都有一屬性
叫characters

00:04:06.213 --> 00:04:08.382 
它給我們字符串中的字符的集合

00:04:08.448 --> 00:04:11.051 
我們可以訪問這個集合的計數屬性

00:04:11.118 --> 00:04:12.653 
來看有多少字符

00:04:13.253 --> 00:04:14.922 
如果把那傳遞給Print函數

00:04:14.988 --> 00:04:17.558 
我們發現我們實際上有5個字符

00:04:18.725 --> 00:04:20.793 
如果你仍然不相信我

00:04:20.861 --> 00:04:23.197 
讓我們一個個遍歷那些字符

00:04:23.263 --> 00:04:24.865 
用for-in循環

00:04:24.932 --> 00:04:26.767 
把每一個打印在它們自己的一行中

00:04:26.834 --> 00:04:29.403 
你可以看到我們實際上有5個字符

00:04:29.736 --> 00:04:33.240 
D O G ？！和狗臉

00:04:35.943 --> 00:04:39.012 
除了基本類型外

00:04:39.079 --> 00:04:41.181 
我們還有一些內置的集合

00:04:41.248 --> 00:04:43.217 
我們有數組和字典

00:04:43.584 --> 00:04:47.221 
你可能知道字典在別的語言裏
是哈希或者映射表

00:04:47.955 --> 00:04:51.191 
最簡單的創造數組或字典的方法
是使用字面值

00:04:51.258 --> 00:04:54.361 
這是一個數組字面值
用方括號包圍

00:04:54.428 --> 00:04:55.762 
並用逗號分隔每個值

00:04:56.663 --> 00:04:59.933 
這裏我們有一個數組包含4個名字
4個字符串

00:05:00.968 --> 00:05:02.436 
字典看起來類似

00:05:02.503 --> 00:05:05.172 
它們的鍵和值被冒號分開

00:05:05.239 --> 00:05:08.542 
我們有一個字典
它的鍵是名字是字符串類型

00:05:08.609 --> 00:05:10.143 
它的值是整數

00:05:11.912 --> 00:05:15.782 
現在你可能注意到在數組中

00:05:15.849 --> 00:05:17.718 
它們都是相同的類型
都是字符串

00:05:18.318 --> 00:05:21.188 
在名字數組中插入其它類型是
沒有意義的

00:05:21.255 --> 00:05:24.224 
有一個整數 布爾型或自行車

00:05:24.725 --> 00:05:26.126 
這會很奇怪

00:05:26.760 --> 00:05:29.029 
對於名字
我們總是希望它們是字符串

00:05:29.530 --> 00:05:30.664 
我們可在Swift中表達它

00:05:30.731 --> 00:05:33.166 
我們可以說我們想要一個字符串
數組

00:05:33.233 --> 00:05:35.369 
當我們從中取出值時

00:05:35.435 --> 00:05:37.271 
我們可以把它當成字符串處理

00:05:38.038 --> 00:05:39.273 
這就是我們爲何這樣寫

00:05:39.339 --> 00:05:42.442 
這是我們怎麼寫一個字符串數組
用方括號包圍一個字符串

00:05:43.443 --> 00:05:44.611 
但是我們早前看到

00:05:45.479 --> 00:05:49.183 
如果右手邊明顯的表明了我們
想要的類型

00:05:49.583 --> 00:05:52.319 
Swift會爲我們做推斷
在這也會發生

00:05:52.386 --> 00:05:54.021 
我們不需要寫下類型

00:05:54.321 --> 00:05:57.057 
很清楚我們想要字符串數組

00:05:57.791 --> 00:05:59.126 
對字典也是同樣的

00:05:59.193 --> 00:06:02.329 
這裏很明顯我們想要鍵是字符串
值是整數

00:06:02.396 --> 00:06:06.099 
Swift可以爲我們推斷這些
所有東西都有清楚的類型

00:06:08.335 --> 00:06:11.638 
Swift有所以你在別的語言裏知道
循環種類

00:06:11.705 --> 00:06:15.509 
我們有在執行循環體之前
檢查條件用的While循環

00:06:16.043 --> 00:06:18.545 
一repeat-while循環
執行循環體一次

00:06:18.612 --> 00:06:21.081 
在檢查條件前
來決定是否繼續

00:06:22.015 --> 00:06:24.384 
我們先前看過我們有for-in循環

00:06:24.451 --> 00:06:26.653 
用來在字符串中遍歷所有字符

00:06:27.421 --> 00:06:30.424 
這不是for-in唯一能做的事

00:06:31.258 --> 00:06:34.061  
我們能用它遍歷一個範圍

00:06:34.127 --> 00:06:36.864  
這裏我們有一個從1到5的範圍

00:06:36.930 --> 00:06:38.565  
包括這些數字

00:06:38.632 --> 00:06:41.602  
我們用來打印5個入口
在乘以4表中

00:06:42.302 --> 00:06:46.473  
我們把它寫成1... 5
這被稱爲閉合範圍

00:06:46.540 --> 00:06:47.908  
因爲它包括2邊的數字

00:06:48.675 --> 00:06:50.511  
有時我們需要

00:06:50.577 --> 00:06:54.014  
一個範圍
運行到比最後的數字少1

00:06:54.548 --> 00:06:55.949  
這是一個它很有用的例子

00:06:56.717 --> 00:06:59.987  
我有一個整數數組
但我只想打印前5個

00:07:00.621 --> 00:07:05.058  
因爲數組的索引從0開始
我希望索引從0到4

00:07:05.792 --> 00:07:08.362  
所以我們想要用半閉合範圍運算符

00:07:08.428 --> 00:07:09.429  
點 點 小於

00:07:09.496 --> 00:07:12.566  
因爲它運行到比最終的數字
在這是5小1

00:07:14.835 --> 00:07:17.037  
我們可以對數組使用for-in循環

00:07:17.104 --> 00:07:19.773  
這裏我們爲數組裏的每個名字
打印一條信息

00:07:20.541 --> 00:07:22.376  
我們也可以對字典使用它

00:07:22.943 --> 00:07:26.613  
現在注意我們要遍歷鍵和值

00:07:26.680 --> 00:07:28.682  
名字和年齡
在同一時間

00:07:29.383 --> 00:07:32.486  
這在Swift裏被稱爲元組

00:07:32.553 --> 00:07:34.454  
讓你把多個值組合在一起

00:07:34.521 --> 00:07:35.789  
同時使用它們

00:07:35.856 --> 00:07:38.225  
我們晚點會看到另一個例子

00:07:38.425 --> 00:07:41.595  
這使代碼遍歷一個字典時清楚很多

00:07:43.497 --> 00:07:45.699  
我們要怎麼修改這些集合？

00:07:46.366 --> 00:07:49.303  
這是我今年 WWDC 的裝箱單

00:07:49.369 --> 00:07:51.905  
我把它申明我一個變量
所以我可以改變它

00:07:51.972 --> 00:07:55.042  
我包括了基本的襪子和鞋子

00:07:56.677 --> 00:08:00.147  
在 WWDC 2014

00:08:00.214 --> 00:08:03.984  
我忘記了我的襪子
這是一個惡夢

00:08:04.051 --> 00:08:05.853 
我不會再犯同樣的錯誤

00:08:06.186 --> 00:08:10.057 
所以我們檢查數組的第一項是襪子

00:08:10.123 --> 00:08:12.960 
2014後如果我把它放在列表裏它
會是第一個

00:08:13.527 --> 00:08:15.295 
我們通過下標來這樣做

00:08:15.362 --> 00:08:18.565 
在數組名後寫一個在方括號裏的
索引

00:08:18.632 --> 00:08:21.802 
如果我們打印這個值
我實際上記得添加襪子

00:08:23.070 --> 00:08:26.039 
襪子和鞋子還不夠
但是爲了一星期的會議

00:08:26.106 --> 00:08:28.809 
我還需要其他東西
讓我們添加一個新物品

00:08:28.876 --> 00:08:31.245  
讓我們把褲子加入數組

00:08:31.311 --> 00:08:33.145  
我們使用append方法

00:08:34.448 --> 00:08:35.782  
但是這有一個問題

00:08:36.683 --> 00:08:39.852  
這個會議是在美國
他們不叫褲子“trousers”

00:08:40.787 --> 00:08:42.121  
他們叫褲子“pants”

00:08:42.188 --> 00:08:44.591  
這會引起很多誤解

00:08:44.791 --> 00:08:46.727 
所以讓我們修改數組中的一個值

00:08:47.094 --> 00:08:49.062 
讓我們把它改成牛仔褲

00:08:49.129 --> 00:08:52.432  
我們又用下標來這樣做
改變在索引2的項目

00:08:52.799 --> 00:08:55.536  
牛仔褲在哪都一樣
因此不會招致誤解

00:08:57.371 --> 00:09:00.641  
這個會議在加利福尼亞州
這裏總是晴天很熱

00:09:01.208 --> 00:09:02.476  
讓我們再加一些東西

00:09:02.543 --> 00:09:06.446  
讓我們加一些短褲 拖鞋 防曬霜

00:09:07.147 --> 00:09:09.716  
我們可用append
contentsOf方法

00:09:09.783 --> 00:09:12.452  
並傳遞一個兼容的數組
另一個字符串數組

00:09:13.120 --> 00:09:15.022  
它們在同一時間都被添加

00:09:16.523 --> 00:09:21.094  
這個會議是在加利福尼亞州的
舊金山

00:09:21.628 --> 00:09:23.163  
這裏並不總是天晴並且炎熱

00:09:23.764 --> 00:09:25.566  
所以讓我們修改一下這三項

00:09:25.632 --> 00:09:28.302 
用連帽衫和圍巾來代替

00:09:29.069 --> 00:09:31.738 
我們可以通過傳遞一個下標範圍
來這麼做

00:09:32.005 --> 00:09:33.974 
注意我們要修改三項中的兩項

00:09:34.041 --> 00:09:35.943  
這在Swift中是合法的

00:09:37.811 --> 00:09:40.214  
那對於字典呢？
讓我們修改一個字典

00:09:40.547 --> 00:09:44.117  
這裏是我的年齡字典

00:09:44.184 --> 00:09:46.520  
我想加入其他人

00:09:46.587 --> 00:09:51.191  
我們通過用下標的辦法
來爲一個還沒有值的鍵加一個值

00:09:51.258 --> 00:09:52.659  
我加入了Justyn

00:09:53.660 --> 00:09:56.129  
但是仔細想想
上週是Justyn的生日

00:09:56.196 --> 00:09:57.397  
所以這個值現在不對

00:09:57.464 --> 00:10:00.901  
我需要更新它
我還是用一樣的方法

00:10:00.968 --> 00:10:02.936  
我給同一個鍵賦不同的值

00:10:03.003 --> 00:10:04.404  
現在我的字典是對的了

00:10:06.607 --> 00:10:09.576 
如果我想要從字典裏取出一個值

00:10:10.077 --> 00:10:12.246 
如果我想知道是否有Devon的年齡

00:10:12.312 --> 00:10:15.382 
或者Daryl
或者Daniel

00:10:16.650 --> 00:10:19.319 
可能在字典對這些人有一個值

00:10:19.386 --> 00:10:22.189 
也可能沒有
我們需要一個方式來應對這種情況

00:10:22.956 --> 00:10:26.226 
這是Swift的被稱爲可選的一個
功能的好的使用案例

00:10:27.294 --> 00:10:31.532  
如果我們試着對Amy這樣做
我們可能期望有個值是40

00:10:32.299 --> 00:10:34.768  
如果我們對Daryl這麼做
我們應該得到什麼？

00:10:34.835 --> 00:10:36.236  
這裏對Daryl沒有值

00:10:37.938 --> 00:10:39.239 
這樣考慮這個問題

00:10:39.907 --> 00:10:43.677 
或者在字典裏Amy有一個整數值

00:10:44.244 --> 00:10:47.915 
或者沒有一個整數值
像例子裏的Daryl

00:10:49.216 --> 00:10:54.087 
所以這裏我們有一個可選的整數
我們寫成Int問號

00:10:54.788 --> 00:10:56.823 
問號表示這裏可能有值

00:10:56.890 --> 00:10:57.991 
也可能沒有

00:10:59.860 --> 00:11:02.196 
我們看看我們是否找到一個值

00:11:02.262 --> 00:11:03.897 
通過把它和nil比較

00:11:03.964 --> 00:11:06.834 
nil是一種特殊情況
是沒有值的簡寫

00:11:07.401 --> 00:11:09.870 
如果對Daryl這麼做
沒有值

00:11:09.937 --> 00:11:11.071 
我們會打印這個信息

00:11:12.406 --> 00:11:13.240 
年齡沒有找到

00:11:14.041 --> 00:11:16.743 
如果我們試着對Amy這樣做
我們找到一個值

00:11:16.810 --> 00:11:19.479 
所以它不等於nil
我們不打印這個消息

00:11:21.014 --> 00:11:23.183 
一般我們不僅僅查看一個值是否
存在

00:11:23.250 --> 00:11:25.319 
當它存在時我們想使用它

00:11:25.385 --> 00:11:27.955 
Swift有一種簡單的寫法

00:11:28.288 --> 00:11:29.456 
寫下“if let”

00:11:30.858 --> 00:11:35.195 
它是說如果字典含有Amy的值

00:11:36.129 --> 00:11:38.832 
讓一個新的常量age等於那個值

00:11:39.533 --> 00:11:42.135  
我們就可以在if語句裏使用那個值

00:11:42.970 --> 00:11:45.072  
請注意在此我們把它當成
真正的整數使用

00:11:45.138 --> 00:11:46.373  
它不再是可選的

00:11:47.307 --> 00:11:50.110  
if語句查看它的值並解包

00:11:50.177 --> 00:11:53.447  
給我們一個普通的整數
我們可以對它做整數的操作

00:11:55.649 --> 00:11:57.818 
我們看了一些if語句

00:11:57.885 --> 00:11:59.987 
這是另一個
用來打印生日消信

00:12:00.721 --> 00:12:03.056 
有兩件事需要注意

00:12:04.057 --> 00:12:07.895 
首先我們不需要在條件附近有括號
只需要寫下條件

00:12:09.029 --> 00:12:13.133 
第二我們給每一部分的語句加
大括號

00:12:13.200 --> 00:12:15.936 
加表明哪部分代碼會被執行

00:12:18.071 --> 00:12:21.508 
此外我們還有switch語句

00:12:21.575 --> 00:12:24.378 
可以用來寫更復雜更強大的匹配

00:12:25.345 --> 00:12:28.949 
它轉換一個常量或者變量的當前值

00:12:29.016 --> 00:12:30.817 
和一系列可能的情況匹配

00:12:31.552 --> 00:12:33.554 
比如我們有這種情況

00:12:33.620 --> 00:12:36.623 
如果年齡值是1

00:12:36.690 --> 00:12:39.426 
我們想要打印第一個生日快樂的
消息

00:12:40.127 --> 00:12:42.062 
我們也可以匹配範圍

00:12:42.262 --> 00:12:44.831 
匹配任意值使一些人是青少年

00:12:45.666 --> 00:12:48.936 
我們可以匹配更復雜的模式
比如這一個

00:12:49.002 --> 00:12:52.139 
一個叫decade的臨時常量

00:12:52.606 --> 00:12:54.641 
等於我們當前要匹配的值

00:12:55.309 --> 00:12:57.377 
檢查是否能被10整除

00:12:58.245 --> 00:13:01.815 
如果可以
用它打印一條特殊的生日消息

00:13:01.882 --> 00:13:06.220 
爲任何人剛滿30或40歲或其他
重要的年齡

00:13:07.788 --> 00:13:10.424 
但這有一個問題

00:13:11.525 --> 00:13:15.062 
如果我們想要爲以下年齡的人打印
消息 比如41

00:13:15.462 --> 00:13:17.664 
97或56

00:13:18.632 --> 00:13:20.200 
它們不會得到一個消息

00:13:20.267 --> 00:13:23.070 
聽起來很不幸
特別是在它們的生日上

00:13:25.038 --> 00:13:26.640 
坦白說Swift在這幫助我們

00:13:27.040 --> 00:13:30.277 
Swift確保switch語句
是完整的

00:13:30.344 --> 00:13:33.780 
你不會偶然的忘記你需要的情況

00:13:34.448 --> 00:13:37.084 
在這個例子裏
我們可以加一個default語句

00:13:37.317 --> 00:13:40.888  
捕獲每一個我們之前沒有捕獲的
情況

00:13:40.954 --> 00:13:43.357  
說無聊的生日快樂

00:13:45.559 --> 00:13:47.261  
這裏有另一個switch語句

00:13:48.095 --> 00:13:51.932 
它獲得一個字符串值用戶名
和一個布爾型值

00:13:51.999 --> 00:13:54.735 
指示用戶密碼是否合法

00:13:55.469 --> 00:13:57.771 
我們會一起用這兩個值

00:13:57.838 --> 00:14:00.073 
來產生一個合適的消息用來顯示

00:14:00.140 --> 00:14:02.509 
當用戶要登錄一個受限的區域

00:14:03.777 --> 00:14:07.481 
要這樣做 我們可以同時switch
兩個值

00:14:08.015 --> 00:14:09.783 
用一個元組
像之前做過的那樣

00:14:10.918 --> 00:14:13.620 
這表明我們可以寫一些非常非常
有趣的case

00:14:13.687 --> 00:14:15.455 
有趣的switch case

00:14:15.522 --> 00:14:17.524 
可有一個case
是用戶名爲admin

00:14:17.591 --> 00:14:19.126 
密碼爲真

00:14:19.193 --> 00:14:21.328 
然後打印消息來歡迎管理員回來

00:14:22.863 --> 00:14:24.598 
現在如果是一個客人

00:14:24.665 --> 00:14:27.234 
我們永遠都不希望客人進入受限
區域

00:14:27.301 --> 00:14:28.936 
即使密碼是合法的

00:14:29.436 --> 00:14:32.706 
我們可以用下劃線來忽略密碼

00:14:33.273 --> 00:14:35.742 
它的意思是匹配任意可能的值

00:14:36.977 --> 00:14:38.478 
對所有其他用戶

00:14:38.545 --> 00:14:41.782 
我們不關心用戶名是什麼
我們只關心密碼

00:14:41.849 --> 00:14:43.617 
我們可以忽略用戶名

00:14:44.184 --> 00:14:47.054 
我們切換到我們想要做的

00:14:47.120 --> 00:14:48.655 
檢查密碼合法性

00:14:48.922 --> 00:14:51.892 
要這麼做我們創建一個叫做
IsValid的臨時常量

00:14:52.459 --> 00:14:55.562 
然後我們用三元條件運算符

00:14:55.629 --> 00:14:57.998 
就是這個問號和冒號

00:14:59.166 --> 00:15:01.602 
來說如果是合法的
用這個消息

00:15:01.668 --> 00:15:03.871 
否則用這個消息

00:15:05.005 --> 00:15:06.707 
如果我們瀏覽一些例子

00:15:07.774 --> 00:15:10.010 
如果使用管理員並且密碼有效

00:15:10.077 --> 00:15:12.679 
他們將得到一個管理員消息
就像我預期的那樣

00:15:13.614 --> 00:15:16.817 
如果我們試着用客人
即使密碼有效

00:15:16.884 --> 00:15:19.720 
他們得到對不起你不能進入的消息

00:15:20.320 --> 00:15:22.823 
如果我們用Bob並且密碼有效

00:15:22.890 --> 00:15:25.058 
他獲得預期的歡迎消息

00:15:25.592 --> 00:15:28.428 
但如果他的密碼無效
他得到訪問被拒絕的消息

00:15:30.664 --> 00:15:34.268 
現在關於這個switch語句
有最後一個需要注意的點

00:15:35.068 --> 00:15:37.437 
它沒有默認這個情況

00:15:38.305 --> 00:15:40.374 
它沒有的原因是它不需要

00:15:40.440 --> 00:15:42.042 
它已經是完整的

00:15:42.109 --> 00:15:46.346 
如果我們看一下後這個case

00:15:46.713 --> 00:15:49.850 
實際上它包括了所有可能的情況

00:15:49.917 --> 00:15:51.451 
我們沒有在上面匹配到的

00:15:51.518 --> 00:15:53.921 
所以switch語句不需要default
就已經完整了

00:15:56.023 --> 00:15:58.926 
這就是Swift語言的一些基本知識

00:15:58.992 --> 00:16:00.994 
現在我想把演講交給
我的同事Brian

00:16:01.061 --> 00:16:03.463 
來介紹Swift中的函數和閉包

00:16:08.802 --> 00:16:11.038 
好的 謝謝Dave
就像我已經說過的

00:16:11.104 --> 00:16:13.974 
讓我從怎樣在Swift中
定義函數開始

00:16:14.675 --> 00:16:17.110 
你用func關鍵字定義函數

00:16:17.177 --> 00:16:19.513 
然後你在大括號裏實現它

00:16:19.580 --> 00:16:22.416 
我們定義了一個簡單的函數
叫做sendMessage

00:16:22.482 --> 00:16:24.251 
打印消息到控制檯

00:16:25.419 --> 00:16:27.821 
然後你可以用一個直觀的方式
調用這個函數

00:16:27.888 --> 00:16:32.392  
通過寫下其名sendMessage
接着是一對空括號

00:16:33.293 --> 00:16:34.962  
讓我們給這個函數加上參數

00:16:35.028 --> 00:16:38.198  
來表明消息是否應該吼叫

00:16:39.366 --> 00:16:41.802 
你寫下參數的名稱
接着是冒號

00:16:41.869 --> 00:16:43.070 
然後是參數的類型

00:16:43.136 --> 00:16:46.406 
就像你申明一個常量或變量
所做的那樣

00:16:46.940 --> 00:16:50.110 
我們添加了一個叫做shouting
的參數 它是布爾類型

00:16:50.844 --> 00:16:52.079 
當你調用這個函數時

00:16:52.145 --> 00:16:55.716 
參數的名稱爲你傳入的參數提供
一個標籤

00:16:57.618 --> 00:17:00.287  
給參數加標籤使代碼更易讀

00:17:00.354 --> 00:17:03.056  
使參數的目的清楚

00:17:03.757 --> 00:17:06.193  
在這個情況下
如果沒有shouting標籤

00:17:06.260 --> 00:17:09.229  
一些閱讀你的代碼的人可能以爲
那個真是表明

00:17:09.296 --> 00:17:11.565  
是否發送這條消息

00:17:12.965 --> 00:17:14.233  
所以你可以喊出一個消息

00:17:14.300 --> 00:17:15.836  
但是你要把消息發給誰？

00:17:16.403 --> 00:17:17.738  
讓我們加入另一個參數

00:17:17.804 --> 00:17:19.873  
使我們把消息發給特定的人

00:17:21.308 --> 00:17:23.343 
在這我們添加一個參數叫做接收人

00:17:23.410 --> 00:17:24.877 
是一個字符串類型

00:17:24.944 --> 00:17:28.982 
我們還通過字符串插入將接收人
姓名加入我們的消息中

00:17:30.417 --> 00:17:33.654  
當你調用函數時你可以傳入接收人
姓名

00:17:34.555 --> 00:17:37.291  
現在雖然這個消息按你期待的
那樣打印

00:17:37.357 --> 00:17:39.526  
它讀起來不是很好

00:17:40.127 --> 00:17:43.497 
發送消息接收人
Morgan讀起來很怪

00:17:43.964 --> 00:17:46.233 
當你調用函數時你希望它讀起來
自然

00:17:46.300 --> 00:17:48.335 
在這個例子中你希望讀起來像

00:17:48.402 --> 00:17:52.206 
發送消息給Morgan
這形成一個有好的語法的短語

00:17:52.806 --> 00:17:55.475 
你可以通過改變參數名稱來這樣做

00:17:55.542 --> 00:17:58.212 
這也會改變參數的標籤名

00:17:58.278 --> 00:18:00.981 
這使得函數被調用時讀起來好一些

00:18:01.048 --> 00:18:02.883 
發送消息給Morgan

00:18:02.950 --> 00:18:06.153 
但是這在函數內部工作的不好

00:18:07.187 --> 00:18:11.091 
在函數體裏你希望參數是一個名詞
而不是一個介詞

00:18:11.158 --> 00:18:13.560 
嘿給聽起來不好

00:18:14.461 --> 00:18:17.197 
但是有時沒有一個單詞能工作良好

00:18:17.264 --> 00:18:21.368 
既在函數體內
又在調用函數的標籤

00:18:21.969 --> 00:18:24.104 
在Swift中你不用放棄其中的一個

00:18:24.605 --> 00:18:26.406 
當一個參數的名稱不合適時

00:18:26.473 --> 00:18:29.710 
參數的標籤

00:18:29.776 --> 00:18:31.778 
你可以明確地提供一個更合適的
名稱

00:18:33.080 --> 00:18:36.817 
你把這個明確的參數標籤寫在
參數名前

00:18:36.884 --> 00:18:39.520 
在這我們添加to作爲明確的參數標籤

00:18:39.586 --> 00:18:41.622 
在接收者參數的之上

00:18:41.688 --> 00:18:43.524 
這表示你可以用“to”

00:18:43.590 --> 00:18:46.093 
當你調用函數發送消息給Morgan

00:18:46.159 --> 00:18:49.630 
然後你仍然可以在函數體內
使用接收者

00:18:51.098 --> 00:18:53.634 
讓我們添加另一個參數到函數中

00:18:53.700 --> 00:18:55.802 
使你調用它時能提供一個定製消息

00:18:57.504 --> 00:19:00.174 
這裏我們添加了一個消息參數
是字符串類型

00:19:00.240 --> 00:19:03.010 
現在我們調用函數
你可以傳遞你自己的消息

00:19:04.745 --> 00:19:07.481  
再一次的
代碼如預期一樣運行

00:19:07.548 --> 00:19:09.516  
但是讀起來還是不好

00:19:10.050 --> 00:19:12.686  
發送消息消息是重複的

00:19:13.587 --> 00:19:17.824 
消息標籤無助於澄清第一個
參數的作用

00:19:17.891 --> 00:19:20.394 
因爲函數名中已經說清楚了

00:19:20.460 --> 00:19:21.461 
發送消息

00:19:22.329 --> 00:19:24.998 
在這裏參數標籤使代碼更難讀

00:19:25.732 --> 00:19:26.834 
在這種情況

00:19:26.900 --> 00:19:29.469 
你可以在參數名前寫一個下劃線

00:19:30.304 --> 00:19:32.840 
這表明你不給參數提供標籤

00:19:32.906 --> 00:19:34.174 
當你調用函數時

00:19:37.277 --> 00:19:39.513 
這時我們的函數讀起來自然

00:19:39.580 --> 00:19:41.548 
發送消息 在Bash見
給Morgan

00:19:43.784 --> 00:19:46.420 
我們不常需要喊出我們的消息

00:19:46.486 --> 00:19:49.523 
我們通常傳遞假給這個參數

00:19:50.157 --> 00:19:51.825 
在Swift你可以捕獲這個行爲

00:19:51.892 --> 00:19:54.027 
在函數申明中

00:19:54.695 --> 00:19:57.631 
當參數有一個常用到的值時

00:19:57.698 --> 00:19:59.900 
你可以把它作爲default值

00:20:01.001 --> 00:20:04.438 
你能過賦一個default值
在這個情況下是假

00:20:04.505 --> 00:20:06.340 
在參數的類型的後面

00:20:07.074 --> 00:20:08.442 
當你調用函數時

00:20:08.509 --> 00:20:10.677 
你可以忽略相應的參數

00:20:10.744 --> 00:20:12.346 
default值被使用

00:20:15.015 --> 00:20:18.752  
當你決定是否使用 怎樣使用
明確的參數標籤

00:20:18.819 --> 00:20:22.990  
什麼時候忽略一個參數或者提供
一個default值

00:20:23.056 --> 00:20:25.826  
記得函數只被申明一次

00:20:25.893 --> 00:20:27.361  
但是被重複使用

00:20:27.427 --> 00:20:29.296  
最重要的事是

00:20:29.363 --> 00:20:32.232  
函數被調用時讀起來清楚準確

00:20:33.467 --> 00:20:34.701  
現在讓我們學習更多

00:20:34.768 --> 00:20:36.436  
你需要考慮的事

00:20:36.503 --> 00:20:38.238  
當編寫優秀Swift API時

00:20:38.939 --> 00:20:41.141  
請去看Swift API指導演講

00:20:42.309 --> 00:20:44.811 
我們已經看了很多種函數獲得
值的方式

00:20:45.312 --> 00:20:48.015 
讓我們看看讓它們返回值的方法

00:20:48.815 --> 00:20:50.250 
假設你想寫一個函數

00:20:50.317 --> 00:20:53.453 
返回數組裏第一個有給定前綴的
字符串

00:20:54.588 --> 00:20:56.423 
函數獲得一個字符串前綴

00:20:57.391 --> 00:20:58.692 
一個字符串數組

00:20:59.660 --> 00:21:02.196 
返回一個有給定前綴的字符串

00:21:02.262 --> 00:21:03.797 
如你所見 你用一個箭頭

00:21:03.864 --> 00:21:06.433 
來表明函數值的類型

00:21:06.500 --> 00:21:07.668 
在這裏是字符串

00:21:08.735 --> 00:21:10.137 
讓我們看看這是怎麼工作的

00:21:11.438 --> 00:21:14.575 
首先用一個for-in循環來遍歷
數組中的每一個字符串

00:21:15.375 --> 00:21:17.711 
然後檢測字符串是否有給定的前綴

00:21:19.413 --> 00:21:21.515 
你需要檢測字符串
是否有給定的前綴

00:21:21.582 --> 00:21:23.550 
使用string.hasprefix方法

00:21:23.917 --> 00:21:27.020 
如果它有 那麼完成了
你只需要返回這個字符串

00:21:27.087 --> 00:21:28.889 
通過將它寫進返回語句

00:21:30.724 --> 00:21:31.859 
但是你要返回什麼

00:21:31.925 --> 00:21:34.261 
如果數組不含有你在找的字符串？

00:21:35.128 --> 00:21:37.564 
因爲這個函數申明瞭會返回字符串

00:21:37.631 --> 00:21:40.734 
唯一的選項是一些合法的字符串

00:21:40.801 --> 00:21:42.236 
在這個情況下是空字符串

00:21:43.003 --> 00:21:44.304 
但這不是好的Swift代碼

00:21:45.405 --> 00:21:48.041 
但是像Dave演示過的
可選是完美的

00:21:48.108 --> 00:21:50.410 
用來表明值有可能不存在

00:21:51.712 --> 00:21:54.181 
所以你只需要改變函數返回類型

00:21:54.248 --> 00:21:57.184 
爲可選字符串
通過在字符串後寫一個問號

00:21:57.584 --> 00:22:00.487 
現在你可以返回nil
當字符串沒有找到時

00:22:01.388 --> 00:22:04.124  
因爲函數返回可選的字符串

00:22:04.191 --> 00:22:06.560  
你可以在一個if-let語句裏安全
地使用它

00:22:07.528 --> 00:22:10.497  
請注意Swift推斷函數的返回類型

00:22:10.564 --> 00:22:12.666 
所以不需要明確的寫出來

00:22:14.434 --> 00:22:16.003 
我們看了一些方法

00:22:16.069 --> 00:22:19.072 
函數能獲得和返回不同類型

00:22:19.139 --> 00:22:22.943 
比如字符串 整數 數組
和可選類型

00:22:23.243 --> 00:22:25.913 
讓我們看看怎麼寫另一種函數

00:22:28.015 --> 00:22:30.651 
假設你要寫一個函數過濾一個
數字數組

00:22:30.717 --> 00:22:32.085 
基於一些條件

00:22:33.120 --> 00:22:34.988 
讓我們想想這個函數需要做什麼

00:22:36.223 --> 00:22:37.925  
它要獲得一個數字數組

00:22:38.358 --> 00:22:39.927  
對數組中的每一個數字

00:22:39.993 --> 00:22:43.330  
函數判斷是否將它包含在被過濾
的結果中

00:22:44.364 --> 00:22:48.635  
比如你想要一個數組
被過濾成只含有偶數

00:22:49.469 --> 00:22:51.772  
你可以測試每個數是否能被2整除

00:22:52.339 --> 00:22:56.210  
4當然是偶數
所以它被包括在結果數組裏

00:22:57.978 --> 00:23:00.180  
如果一個數不是偶數
比如17

00:23:01.114 --> 00:23:03.884  
過濾函數轉而檢測下一個數

00:23:03.951 --> 00:23:05.886  
然後繼續 遍歷剩下的數組

00:23:06.920 --> 00:23:08.822  
讓我們看看寫這個函數的代碼

00:23:10.858 --> 00:23:13.227 
函數申明是你想要的

00:23:13.493 --> 00:23:16.230 
但是你要把什麼類型放在
這個包括數字參數這裏？

00:23:16.964 --> 00:23:21.101 
你剛剛看到
決定是否把數字包括進結果裏

00:23:21.668 --> 00:23:23.570 
是一個函數

00:23:23.637 --> 00:23:26.139 
不是一個簡單的值比如字符串
或者一個數字

00:23:27.241 --> 00:23:31.245 
在Swift裏函數可以接收其他函數
做爲參數

00:23:31.912 --> 00:23:34.014 
那麼函數類型看起來是怎樣的？

00:23:35.182 --> 00:23:37.684 
所有的函數類型在Swift中
都有基本的形式

00:23:38.085 --> 00:23:40.521 
函數參數類型
如果有的話

00:23:40.587 --> 00:23:43.757 
在括號裏
跟隨的是一個箭頭

00:23:43.824 --> 00:23:44.858 
然後是函數返回類型

00:23:46.326 --> 00:23:49.663 
比如說我們早前的發送消息函數

00:23:50.163 --> 00:23:52.266 
它有空的括號

00:23:52.332 --> 00:23:55.169 
因爲它不需要任何參數
箭頭空

00:23:55.836 --> 00:23:58.405 
這裏空表示它不返回任何值

00:23:59.406 --> 00:24:01.575 
在Swift中如果你的函數不返回
任何值

00:24:01.642 --> 00:24:04.478 
你不需要明確的寫箭頭空

00:24:08.715 --> 00:24:11.218 
這是第一個字符串函數

00:24:11.385 --> 00:24:13.353 
它的簽名複雜一些

00:24:13.420 --> 00:24:15.489 
但是它的類型還是遵循基本的形式

00:24:16.256 --> 00:24:19.793 
它獲得一個字符串一個數組
一個字符串參數並返回一個可選字符串

00:24:20.327 --> 00:24:23.096 
你們已經知道了函數類型的語法

00:24:23.163 --> 00:24:26.767 
所以很清楚你要怎麼完成過濾
整數這個函數的申明

00:24:27.768 --> 00:24:29.169 
這個包括數字參數

00:24:29.236 --> 00:24:33.207 
可以是任何函數獲得一個整數
返回一個布爾型

00:24:33.273 --> 00:24:37.511 
你把類型Int寫在括號裏
箭頭布爾

00:24:38.212 --> 00:24:40.380 
讓我們來完成函數的剩餘部分

00:24:41.915 --> 00:24:44.151 
你需要生成一個過濾過的數字
的數組

00:24:44.218 --> 00:24:46.019 
這有一個變量叫做結果

00:24:46.086 --> 00:24:48.755 
它被初始化爲一個整數數組

00:24:49.423 --> 00:24:52.392 
隨着你遍歷傳給這個函數的數組

00:24:52.559 --> 00:24:55.796 
檢查每個數字是否應該包括在
結果數組裏

00:24:56.830 --> 00:25:00.501 
要這麼做 你把每個數字傳遞給
包括數字函數

00:25:00.567 --> 00:25:02.636 
注意在過濾整數函數體內

00:25:02.703 --> 00:25:07.441 
包括數字參數被當成被傳入的函數
的名字

00:25:07.908 --> 00:25:09.009 
那說明你可以調用它

00:25:09.076 --> 00:25:11.311 
和調用其實函數相同的方式

00:25:12.412 --> 00:25:13.780 
這就是你怎麼寫一個函數

00:25:13.847 --> 00:25:15.949 
獲得另一個函數做爲一個參數

00:25:16.450 --> 00:25:18.452 
但是你怎麼調用這類函數？

00:25:19.720 --> 00:25:22.689 
首先你需要把一些值傳遞給過濾
整數函數

00:25:22.756 --> 00:25:24.458 
這是一個數字數組

00:25:24.525 --> 00:25:26.927 
和一個簡單的函數叫做可被2整除

00:25:26.994 --> 00:25:28.896 
表明一個整數是否是偶數

00:25:31.465 --> 00:25:34.334 
你可以看到能被2整除的類型

00:25:34.401 --> 00:25:37.104 
和包括數字參數的類型匹配

00:25:37.671 --> 00:25:42.676 
這表明我們可以傳遞能被2整除
函數

00:25:43.143 --> 00:25:45.145 
給過濾整數函數做爲一個參數

00:25:46.346 --> 00:25:50.284 
你通過簡單地傳遞能被2整除
函數的名字

00:25:51.218 --> 00:25:53.854  
現在你得到一個數組只含有偶數

00:25:54.788 --> 00:25:57.057  
注意你沒有包括括號

00:25:57.124 --> 00:25:59.793  
當傳遞能被2整除函數時

00:25:59.860 --> 00:26:02.362  
這是因爲你現在並沒有調用它

00:26:02.429 --> 00:26:05.299  
它在晚些時候在過濾整數函數體
內被調用

00:26:07.201 --> 00:26:10.037  
還要注意我們傳遞了數組的名字

00:26:11.238 --> 00:26:14.007  
我們也可以傳遞數組字面值

00:26:14.474 --> 00:26:16.910  
比如如果你只需要傳遞少量值

00:26:16.977 --> 00:26:19.746  
不需要創建一個常量
爲了等會的重用

00:26:21.081 --> 00:26:24.184  
傳遞函數參數也可以這樣

00:26:26.653 --> 00:26:29.323  
很可能能被2整除函數

00:26:29.389 --> 00:26:30.757  
不會被重用

00:26:31.291 --> 00:26:33.794  
新建一個函數很麻煩

00:26:33.861 --> 00:26:37.231  
每次你想要傳遞不同的過濾函數
條件

00:26:38.565 --> 00:26:41.368  
如果你看看能被2整除的重要部分

00:26:41.668 --> 00:26:43.637  
你可以看到給它一個名字

00:26:43.704 --> 00:26:46.573  
僅僅是爲了方便重用

00:26:47.941 --> 00:26:50.210 
能被2整除僅僅是一個名字

00:26:50.277 --> 00:26:52.679 
針對你所看重的功能

00:26:54.715 --> 00:26:58.552 
在Swift中像你可以寫
一個字面值字符串或字面值數組

00:26:58.619 --> 00:27:01.522 
你也可以寫一個
沒有名字的字面值函數

00:27:01.588 --> 00:27:04.224 
被稱爲閉包表達式
並在你的代碼中被傳遞

00:27:05.325 --> 00:27:06.860 
寫一個閉包表達示的語法

00:27:06.927 --> 00:27:09.363 
和函數申明很像

00:27:09.429 --> 00:27:10.898 
除了它沒有名字

00:27:11.832 --> 00:27:15.903 
把整個閉包的函數寫在大括號中

00:27:15.969 --> 00:27:20.741 
用in關鍵字把閉包函數體和
簽名區分開

00:27:20.807 --> 00:27:23.777 
用數字參數類型是整數

00:27:23.844 --> 00:27:26.280 
在閉包的函數體內返回一個布爾型

00:27:28.649 --> 00:27:31.752 
這是最明確和最完整的定義閉包
的方式

00:27:32.452 --> 00:27:33.720 
但是你之前見過了

00:27:33.787 --> 00:27:37.157 
Swift可以推斷很多信息
從代碼的上下文中

00:27:39.393 --> 00:27:42.829 
比如閉包的函數類型已知

00:27:42.896 --> 00:27:45.566 
從包括數字這個參數的類型中

00:27:46.099 --> 00:27:48.202 
所以你不需要明確的寫出來

00:27:49.670 --> 00:27:53.207 
如果整個閉包的體只是一個
返回語句

00:27:53.273 --> 00:27:56.777 
像這裏一樣你不需要明確的寫
出return關鍵字

00:27:58.345 --> 00:28:02.382 
這是更乾淨的語法
但是因爲閉包很短

00:28:02.649 --> 00:28:05.652 
看起來這個參數數字都顯得有點
多餘

00:28:06.186 --> 00:28:09.790 
像這種情況
Swift提供暗示的變量名

00:28:09.857 --> 00:28:13.460 
所以不需要寫出參數名或者in
關鍵字

00:28:14.928 --> 00:28:16.230 
這個暗示的文件名

00:28:16.296 --> 00:28:18.732 
用一個美元符號開始
以及一個從0開始的數字

00:28:18.799 --> 00:28:23.136 
$0表示第一個閉包參數
$1是第二個 等等

00:28:24.238 --> 00:28:27.574 
雖然這可以在任何閉包表達式中
使用

00:28:28.275 --> 00:28:31.979 
使用它們不會使你的代碼變得
難以閱讀

00:28:33.714 --> 00:28:37.818  
現在你看到Swift提供很多方便的
編寫閉包的方式

00:28:37.985 --> 00:28:41.255  
但是直接在一個函數的括號中
傳遞它們

00:28:41.688 --> 00:28:43.457  
看起來有很多符號

00:28:44.258 --> 00:28:47.060  
一個關閉大括號緊鄰一個關閉括號

00:28:47.327 --> 00:28:48.428  
看起來很怪

00:28:50.030 --> 00:28:53.100  
但是當閉包是最後一個參數時

00:28:53.166 --> 00:28:54.401  
這種情況就是

00:28:55.002 --> 00:28:57.371  
你可以寫一個尾隨閉包

00:28:57.437 --> 00:28:59.139  
就在括號外面

00:29:00.307 --> 00:29:04.278  
你接下來會看到如果一個閉包是
一個函數的唯一參數

00:29:04.678 --> 00:29:06.713  
你可以移除這個括號

00:29:07.814 --> 00:29:09.983  
這時尾隨閉包看起來很好

00:29:10.317 --> 00:29:12.886  
當閉包含有多於一行代碼時

00:29:13.820 --> 00:29:16.323 
比如這個更復雜的閉包

00:29:16.390 --> 00:29:19.860 
它判斷一個數每一位相加的和
是否是偶數

00:29:21.328 --> 00:29:22.563 
尾隨閉包語法

00:29:22.629 --> 00:29:27.034 
確保即使是複雜的有多行的閉包

00:29:27.100 --> 00:29:28.836 
看起來也很自然很好

00:29:30.671 --> 00:29:33.273 
現在過濾整數函數很有用

00:29:33.340 --> 00:29:35.642 
如果你想要過濾整數

00:29:36.376 --> 00:29:39.313 
但是要怎麼過濾其他類型的數組
比如類型數組？

00:29:40.514 --> 00:29:42.816 
例如假設你有一個名字數組

00:29:42.883 --> 00:29:45.352 
你想要一個過濾了的數組
只含有名字

00:29:45.419 --> 00:29:47.354 
含有少於給定的字符數

00:29:48.755 --> 00:29:50.757  
你可以寫一個過濾字符串函數

00:29:50.824 --> 00:29:52.259  
像你看到的這個

00:29:52.726 --> 00:29:55.262  
因爲你已經寫好了一個過濾整數
函數

00:29:55.329 --> 00:29:57.764  
讓我們來看看你能否重用一些邏輯

00:29:59.499 --> 00:30:01.568 
首先你當然想要做一些簿記

00:30:01.635 --> 00:30:05.372 
把所有涉及數字的地方改成字符串

00:30:06.507 --> 00:30:11.278 
下一步把所有整型改成字符串類型

00:30:13.447 --> 00:30:15.382 
因爲實際上這2個函數的行爲

00:30:15.449 --> 00:30:18.318 
是一樣的
對整數和字符串

00:30:18.385 --> 00:30:19.786 
沒有什麼別的要做

00:30:19.853 --> 00:30:21.421 
它們實際上是同樣的函數

00:30:22.422 --> 00:30:25.025 
你現在有函數過濾字符串數組

00:30:26.393 --> 00:30:30.197 
現在如果你想要一個函數過濾
其他類型

00:30:30.464 --> 00:30:33.534 
你可以重複這個步驟

00:30:33.600 --> 00:30:34.601 
爲每種類型

00:30:34.935 --> 00:30:37.638 
但是這顯然很無聊

00:30:38.505 --> 00:30:41.141 
實際上你可以寫一個函數

00:30:41.208 --> 00:30:43.977 
可以處理任意類型的數組

00:30:44.044 --> 00:30:45.546 
這被稱爲泛型函數

00:30:46.346 --> 00:30:47.948 
我們來看看怎麼寫一個

00:30:48.682 --> 00:30:52.152 
寫一個這種函數和你已經看到的
沒有很大不同

00:30:52.753 --> 00:30:54.988 
首先你把名字改得更通用

00:30:55.055 --> 00:30:57.925 
比如函數叫過濾

00:30:57.991 --> 00:31:00.594 
而不是過濾整數或過濾字符串

00:31:01.495 --> 00:31:04.164 
接下來更重要的是你需要填寫
佔位符

00:31:04.231 --> 00:31:07.234 
你在這裏看到的
元素的類型

00:31:07.835 --> 00:31:10.137 
但是你現在還不知道元素的類型

00:31:10.971 --> 00:31:13.640 
所以你希望是一個類型參數

00:31:14.007 --> 00:31:16.844 
實際的類型會在函數被調用時確定

00:31:18.378 --> 00:31:20.247 
這裏我們填寫了佔位符

00:31:20.314 --> 00:31:22.649 
用一個通用類型參數叫做元素

00:31:23.650 --> 00:31:26.720 
所以你能看到區別
在類型參數

00:31:26.787 --> 00:31:30.190 
和實際存在的類型比如字符串
或者整數

00:31:30.624 --> 00:31:34.528 
你把類型參數寫在尖括號中

00:31:34.595 --> 00:31:36.163 
緊跟函數名後面

00:31:36.730 --> 00:31:38.632 
現在你有一個泛型函數

00:31:38.699 --> 00:31:42.035 
作用於一個數組包含任意類型的值

00:31:44.571 --> 00:31:47.374 
你和以前一樣調用這種函數

00:31:47.441 --> 00:31:50.611 
你不需要指定你想要這個函數
處理的類型

00:31:50.677 --> 00:31:53.247 
因爲可以通過你傳入的值推斷

00:31:54.681 --> 00:31:58.352  
過濾是如此有用的操作
所以Swift標準庫

00:31:58.418 --> 00:32:02.256  
有一個過濾方法可用用於任何
種類的序列或集合

00:32:03.257 --> 00:32:07.160 
你和你看到的過濾函數以同樣的
方式工作

00:32:07.227 --> 00:32:10.531 
除了這是一個方法
你需要用點號來調用它

00:32:10.597 --> 00:32:12.900 
names.filter像你看到的

00:32:14.668 --> 00:32:17.037  
Swift標準庫實際上有很多其他
方法

00:32:17.104 --> 00:32:19.339  
接受閉包作爲一個參數

00:32:19.907 --> 00:32:22.643  
另一個很有用的是映射方法

00:32:22.709 --> 00:32:25.212  
它也作用於任何序列或集合

00:32:26.013 --> 00:32:27.981  
映射返回一個新的數組

00:32:28.048 --> 00:32:30.884  
包含對每個元素進行閉包的結果

00:32:31.251 --> 00:32:34.888  
這是一個例子在對上面得到的
包含短名字的數組調用映射方法

00:32:35.088 --> 00:32:38.625  
它傳遞一個閉包把每個字符串
轉成大寫

00:32:40.527 --> 00:32:44.598  
你可以把它們鏈起來強行多個操作

00:32:44.665 --> 00:32:45.666 
比如

00:32:45.732 --> 00:32:49.102 
你可以在同一個表達式裏過濾
並大寫

00:32:49.169 --> 00:32:51.672 
通過把兩個方法形成一個鏈

00:32:51.738 --> 00:32:53.073 
使用點號

00:32:53.140 --> 00:32:54.875 
過濾先進行

00:32:54.942 --> 00:32:56.977 
然後映射在被過濾過的數組上
被調用

00:32:57.044 --> 00:32:59.613 
最終返回大寫的字符串

00:33:01.381 --> 00:33:02.516  
這讀起來很棒

00:33:02.583 --> 00:33:04.918  
即使你用尾隨閉包語法

00:33:06.587 --> 00:33:10.324  
所以使用閉包和函數接收閉包
作爲參數的這個組合

00:33:10.390 --> 00:33:15.362  
使它有可能寫一些複雜強大的代碼

00:33:15.929 --> 00:33:18.498  
用一個簡明但是很有表現力的方式

00:33:19.099 --> 00:33:22.936 
我們已經看了函數和閉包
以及一點泛型函數

00:33:23.003 --> 00:33:27.274 
我想邀請Alex上臺告訴你們
所有關於Swift數據類型的事

00:33:34.314 --> 00:33:35.148 
謝謝Brian

00:33:36.083 --> 00:33:38.886 
你們看到了Swift中的數據類型

00:33:39.286 --> 00:33:43.123 
現在讓我們看看怎樣創建
你自己的數據類型

00:33:44.525 --> 00:33:46.126 
讓我們從結構開始

00:33:46.627 --> 00:33:48.595 
你創建一個像這樣

00:33:48.662 --> 00:33:52.799 
你寫下struct關鍵字
跟隨的是結構的名字

00:33:52.866 --> 00:33:54.568 
矩形

00:33:56.170 --> 00:33:58.172 
然後在大括號裏

00:34:00.374 --> 00:34:02.543 
你寫下結構的屬性

00:34:04.478 --> 00:34:06.213 
屬性使用相同的語法

00:34:06.280 --> 00:34:09.382 
和你在前面見過的變量和常量一樣

00:34:11.083 --> 00:34:12.652 
這裏有兩個屬性

00:34:12.719 --> 00:34:15.656 
做爲申明的一部分被賦值

00:34:15.989 --> 00:34:20.293 
所以你可以新建一個矩形
通過只寫下矩形這個名字

00:34:21.027 --> 00:34:23.197 
跟隨一對括號

00:34:24.197 --> 00:34:27.601 
要訪問屬性
你使用點號

00:34:30.137 --> 00:34:33.139 
你不需要爲屬性提供值

00:34:33.206 --> 00:34:35.442 
在類型申明中

00:34:35.509 --> 00:34:37.844 
實際上大部分時候你不這麼做

00:34:38.277 --> 00:34:40.581 
更常見的 你只寫類型

00:34:41.648 --> 00:34:44.818 
然後你在建立實例時賦值

00:34:46.520 --> 00:34:51.458 
矩形除了尺寸的另一個屬性是面積

00:34:52.525 --> 00:34:54.895 
雖然你不想儲存面積

00:34:55.062 --> 00:34:58.665 
你需要在每次尺寸變化時更新它

00:34:59.533 --> 00:35:01.602 
你想要的是一個屬性

00:35:01.668 --> 00:35:05.172 
它的值當你需要的時候被計算出

00:35:05.639 --> 00:35:08.675 
你可以用一個被計算屬性

00:35:10.077 --> 00:35:11.778 
要創建一個被計算屬性

00:35:12.513 --> 00:35:17.885 
在屬性的名稱和類型後面
你寫一個函數體

00:35:18.118 --> 00:35:21.321 
用來計算並返回

00:35:21.588 --> 00:35:23.590 
函數的當前值

00:35:24.658 --> 00:35:27.628 
雖然它是被計算的而不是被儲存的

00:35:27.694 --> 00:35:30.197 
你還是可以用點號訪問它

00:35:31.665 --> 00:35:33.967 
你還可以用屬性做更多

00:35:34.334 --> 00:35:36.870 
你可以有設置者和監視者

00:35:38.038 --> 00:35:40.507  
你可以獲得更多信息

00:35:40.574 --> 00:35:45.445  
在Swift編程語言的屬性章節

00:35:48.215 --> 00:35:51.051 
就像你在結構中定義屬性

00:35:51.218 --> 00:35:53.120 
你還可以定義方法

00:35:54.154 --> 00:35:57.691 
和你已經看過的函數一樣的語法

00:35:59.159 --> 00:36:03.597  
和屬性一樣
你用點號訪問方法

00:36:03.664 --> 00:36:05.132  
當你需要調用它們時

00:36:08.435 --> 00:36:12.339  
你看到幾次新建矩形的語法了

00:36:12.906 --> 00:36:15.943  
我們看看它做了什麼的更多細節

00:36:17.377 --> 00:36:21.815 
這看起來像調用函數因爲這個括號

00:36:22.049 --> 00:36:24.351 
實際上它是在調用初始化者

00:36:25.319 --> 00:36:28.889 
我們一直在用一個特殊的初始化者

00:36:28.956 --> 00:36:31.291 
稱爲成員初始化者

00:36:31.358 --> 00:36:34.995 
Swift爲你的結構實現

00:36:35.662 --> 00:36:37.130 
這是它看起來的樣子

00:36:37.197 --> 00:36:40.033  
如果你明確的寫這個初始化者

00:36:41.134 --> 00:36:43.370  
你寫init關鍵字

00:36:43.437 --> 00:36:47.641  
然後在裏面你爲矩形的屬性設值

00:36:48.942 --> 00:36:52.012  
注意有兩個寬度

00:36:52.513 --> 00:36:54.815  
一個是屬性另一個是參數

00:36:55.516 --> 00:37:00.654  
你寫下self點來明確的參考屬性

00:37:01.855 --> 00:37:04.424  
這就是你怎麼寫初始化者

00:37:06.894 --> 00:37:10.097  
矩形結構有足夠多的代碼

00:37:10.163 --> 00:37:13.100  
值得進行一些組織

00:37:13.166 --> 00:37:16.970  
Swift中這樣做的一個方法是
使用擴展

00:37:18.372 --> 00:37:22.676 
一個擴展讓你向一個已有的類型
添加功能

00:37:23.911 --> 00:37:28.682 
在Swift裏你可以用擴展來分離
你的代碼

00:37:29.816 --> 00:37:33.487 
核心功能可以在結構的申明中

00:37:34.588 --> 00:37:39.193 
輔助的功能可以在一個或多個
擴展中

00:37:40.427 --> 00:37:43.263 
你可以不受限地擴展你自己的類型

00:37:43.830 --> 00:37:47.768 
如果你需要你可以擴展從其他
地方來的類型

00:37:47.835 --> 00:37:51.538 
比如foundation 或者標準庫

00:37:53.140 --> 00:37:56.643 
你早前看到怎麼創建範型函數

00:37:56.710 --> 00:38:01.215 
在不同的類型上進行相同的操作

00:38:01.982 --> 00:38:07.554 
你還可以創建泛型結構
它包含不同類型的數據

00:38:08.255 --> 00:38:10.424 
語法看起來很相似

00:38:10.490 --> 00:38:15.863 
你仍然有泛型類型參數在名字
後面的尖括號裏

00:38:16.730 --> 00:38:21.935 
這個例子把名字附加給一些種類
的元素的數組

00:38:22.970 --> 00:38:26.440 
這會是個有用的數據結構
比如

00:38:26.507 --> 00:38:31.178 
來填充一個表視圖
有不同的部分有標題名

00:38:31.678 --> 00:38:35.215 
你創建一個泛型結構實例

00:38:35.282 --> 00:38:37.684 
就像另一個類型的實例

00:38:39.586 --> 00:38:43.123 
你在這看到如果你寫下類型標註

00:38:44.424 --> 00:38:48.028 
棋盤遊戲和質數有不同的類型

00:38:49.029 --> 00:38:53.433 
一個是字符串數組
另一個是整數數組

00:38:54.301 --> 00:38:58.739 
它們有不同的元素類型
所以它們是不同的類型

00:39:00.174 --> 00:39:02.209 
你不需要寫數組

00:39:02.709 --> 00:39:06.146 
Swift自動推測是什麼元素

00:39:08.182 --> 00:39:09.650 
這就是結構

00:39:11.518 --> 00:39:14.621 
在Swift中另一個數據類型是類

00:39:15.689 --> 00:39:18.392 
你在名稱前寫下類別關鍵字

00:39:18.458 --> 00:39:21.161 
但是關於結構的一切都仍然有效

00:39:21.695 --> 00:39:24.998 
屬性 方法 初始化者等等

00:39:26.099 --> 00:39:29.169 
那麼爲什麼你想要創建一個類？

00:39:30.804 --> 00:39:36.176 
一個原因是你的代碼可以引用
一個類的同一個實例

00:39:36.243 --> 00:39:38.045 
從不同的地方

00:39:38.679 --> 00:39:41.982 
這和結構的行爲不同

00:39:43.083 --> 00:39:46.019 
一個結構的行爲像一個大的值

00:39:46.787 --> 00:39:51.058 
比如 在遊戲中 你讓玩家1有
一個分數

00:39:52.359 --> 00:39:58.031 
你給玩家2一個一樣的分數
你有兩個獨立的分數

00:39:58.899 --> 00:40:03.837 
改變玩家2的分數不會改變
玩家1的分數

00:40:05.072 --> 00:40:10.477 
但是兩個玩家需要引用硬盤上
的同一個文件

00:40:10.544 --> 00:40:12.446 
當他們記錄他們的高分的時候

00:40:13.914 --> 00:40:17.150 
因爲這是一個類
這就是你想要的行爲

00:40:18.652 --> 00:40:23.991 
當玩家2得到一個新的高分
並把它記錄到文件中

00:40:24.658 --> 00:40:26.960 
兩個玩家都看到改變

00:40:29.062 --> 00:40:31.999 
如果你是從另一個面嚮對象語言
中過來

00:40:32.065 --> 00:40:35.402 
你可能習慣於寫很多類

00:40:35.469 --> 00:40:40.040 
在Swift中你不需要經常寫它們

00:40:41.208 --> 00:40:45.746 
任何時候你想要檢查是否相等
或進行復制

00:40:46.780 --> 00:40:49.917 
你通常只需要一個值類型像是結構

00:40:51.518 --> 00:40:55.822  
要知道更多爲什麼以及怎麼
用值類型的信息

00:40:55.889 --> 00:40:58.492  
你可以看一個很有用的演講

00:40:59.726 --> 00:41:02.095  
另一個用類的原因是

00:41:02.162 --> 00:41:05.065  
你想從已有的類中派生一個子類

00:41:06.934 --> 00:41:09.670 
比如假設你有一個框架

00:41:09.736 --> 00:41:14.741 
給你魚類包含一些核心的魚的功能

00:41:15.976 --> 00:41:22.049  
你可以創建子類來添加功能
像是飛魚可以添加飛方法

00:41:23.050 --> 00:41:27.654  
你標明這是一個子類通過寫冒號魚

00:41:28.789 --> 00:41:34.394  
子類還可以覆蓋方法來提供它們
自己的實現

00:41:35.462 --> 00:41:37.664  
像抱怨魚

00:41:37.731 --> 00:41:41.835  
它像普通魚一樣游泳
只是會先報怨

00:41:44.838 --> 00:41:49.610  
你寫super.swim
來調用父類的實現

00:41:50.611 --> 00:41:53.046  
這個代碼還不能被編譯

00:41:54.014 --> 00:41:56.617  
當你在Swift中覆蓋方法

00:41:56.683 --> 00:42:00.854  
你需能寫覆寫關鍵字來明確標明

00:42:01.455 --> 00:42:03.257  
現在代碼工作

00:42:04.725 --> 00:42:08.862  
像是一個錯誤
偶然覆蓋了一些東西

00:42:08.929 --> 00:42:14.568  
這也是一個錯誤
寫了覆寫卻不覆蓋任何東西

00:42:15.736 --> 00:42:20.474  
這就是說如果你拼錯了一個
想要覆蓋的方法的名字

00:42:20.974 --> 00:42:24.545  
Swift會在編譯時告訴你這個錯誤

00:42:26.346 --> 00:42:29.249  
一個賽格威也可以提供初始化者

00:42:30.684 --> 00:42:35.189  
比如魚有初始化者接收一個名字

00:42:35.889 --> 00:42:41.361  
抱怨魚的初始化者需要名字和報怨

00:42:42.663 --> 00:42:46.900  
在初始化者中你設置初始值

00:42:46.967 --> 00:42:50.370  
爲子類申明的屬性

00:42:51.471 --> 00:42:53.907  
然後你調用super.init

00:42:54.808 --> 00:42:58.011  
讓父類完成初始化

00:42:59.613 --> 00:43:04.017  
你可以用初始化者做更多
特別是圍繞類

00:43:05.752 --> 00:43:09.389  
你可以在初始化者這一章知道更多

00:43:09.456 --> 00:43:11.425  
在Swift編程語言中

00:43:13.193 --> 00:43:15.562 
你看過了怎麼用子類

00:43:15.629 --> 00:43:18.632 
讓我們談談子類編程

00:43:20.868 --> 00:43:25.772 
繼續遊戲的例子
假設你有玩家基類

00:43:26.473 --> 00:43:30.511 
因爲每個玩家輪流行動
你有一種方法這樣做

00:43:31.411 --> 00:43:33.680 
你有兩類玩家

00:43:34.348 --> 00:43:36.383 
你有人類玩家類

00:43:36.450 --> 00:43:39.887 
通過顯示UI給用戶來完成一輪

00:43:40.554 --> 00:43:43.190  
你有電腦玩家類

00:43:43.257 --> 00:43:46.960  
通過進行最好的合法的移動來
完成一輪

00:43:48.161 --> 00:43:53.400  
問題就是什麼進入基類的實現中？

00:43:54.768 --> 00:44:00.307  
人類和電腦玩家沒有共享的行爲

00:44:01.008 --> 00:44:04.211 
沒有共享的代碼可以移出

00:44:05.145 --> 00:44:07.681 
在附近的代碼

00:44:07.748 --> 00:44:12.019 
你永遠都不會想要一個
玩家基類實例

00:44:12.553 --> 00:44:15.122 
所以這個方法永遠都不應該被調用

00:44:16.757 --> 00:44:19.626 
這裏能寫的唯一合理的東西

00:44:19.693 --> 00:44:23.931  
是一些嚴重錯誤來幫助你捕獲失誤

00:44:23.997 --> 00:44:26.466  
在開發的早期階段

00:44:27.534 --> 00:44:33.240  
所有玩家類在做的是描述
做爲一個玩家意味着什麼

00:44:33.640 --> 00:44:36.243  
每個玩家進行一輪

00:44:36.844 --> 00:44:39.847  
它是玩家的藍圖

00:44:41.181 --> 00:44:46.286  
在Swift中你用協議表達這種關係

00:44:47.321 --> 00:44:51.725  
協議規定要求像是方法和屬性

00:44:52.960 --> 00:44:56.296 
他們就像接口或者抽象類

00:44:56.363 --> 00:44:58.332 
你可能在別的語言裏知道

00:44:59.700 --> 00:45:03.003 
你使用protocol關鍵字
來創建一個

00:45:03.637 --> 00:45:08.308  
因爲它描述其他類型要實現的要求

00:45:09.042 --> 00:45:11.044  
你不提供一個實現

00:45:12.779 --> 00:45:17.417  
類型通過提供那些實際來遵守協議

00:45:18.418 --> 00:45:22.456  
你通過寫：Player來申明符合性

00:45:22.956 --> 00:45:25.325  
就像你對父類做的那樣

00:45:26.960 --> 00:45:30.297  
這樣你不再使用子類

00:45:30.364 --> 00:45:33.467  
這些方法不覆蓋任何東西

00:45:34.868 --> 00:45:36.970  
你不寫覆寫關鍵字

00:45:39.406 --> 00:45:43.243  
沒有理由它再是一個類

00:45:43.343 --> 00:45:44.978  
讓我們把它變爲結構

00:45:46.847 --> 00:45:50.384  
讓我們仔細看看人類玩家

00:45:52.286 --> 00:45:56.023 
它還有一些其它的屬性比如
名字和分數

00:45:56.757 --> 00:46:00.194 
如果你創建一個玩家實例
你可以打印它

00:46:02.329 --> 00:46:07.000  
你得到一個default的描述
因爲標準庫

00:46:07.267 --> 00:46:10.404  
可以把任何類型轉化成字符串

00:46:12.306 --> 00:46:15.042  
但是如果你想要定製這個轉化

00:46:15.108 --> 00:46:17.511  
來打印一個更好的描述

00:46:18.445 --> 00:46:23.450  
該標準庫還有一個協議
叫CustomStringConvertible

00:46:23.984 --> 00:46:26.453  
使你提供自己的描述

00:46:27.154 --> 00:46:29.456 
這是這個協議的樣子

00:46:30.090 --> 00:46:33.594 
它有一個要求
一個描述屬性

00:46:34.962 --> 00:46:39.700 
任何遵守這個協議的類型
使用定製描述

00:46:40.467 --> 00:46:45.239 
你要在哪實現這個描述屬性？

00:46:46.340 --> 00:46:49.710 
記住你可以整理你的代碼

00:46:49.776 --> 00:46:54.982 
使用擴展
核心功能在函數申明中

00:46:55.048 --> 00:46:58.185 
附加功能在擴展中

00:46:59.186 --> 00:47:04.291 
有一個字符串轉換功能是第二類

00:47:04.358 --> 00:47:08.896 
它不是核心功能
所以把它放在擴展裏

00:47:09.396 --> 00:47:13.500 
這是你如何擴展一個類型
來遵守協議

00:47:14.468 --> 00:47:18.872 
你在第一行寫下
“: CustomStringConvertible”

00:47:20.007 --> 00:47:24.144 
然後你在擴展體內實現要求

00:47:26.113 --> 00:47:30.417  
現在你可以調用打印
你獲得定製的字符串轉換

00:47:31.818 --> 00:47:36.657  
你可以在Swift裏用協議和擴展
做很多

00:47:36.757 --> 00:47:39.693  
來組織你的代碼並建立抽象

00:47:40.827 --> 00:47:43.864  
要知道更多信息請看

00:47:43.931 --> 00:47:47.901  
2015年的面向協議編程

00:47:49.436 --> 00:47:54.575  
那帶來Swift最後的一個數據類型
枚舉

00:47:55.576 --> 00:47:58.912 
你在有一個值列表時使用枚舉

00:47:58.979 --> 00:48:00.881 
當你提前知道

00:48:01.582 --> 00:48:06.587 
這是一個枚舉支持左或右對齊
的文本

00:48:07.588 --> 00:48:12.893 
當你用一個枚舉時
你用點號來訪問它的案例

00:48:14.027 --> 00:48:16.463 
這裏只有兩個案例

00:48:16.530 --> 00:48:19.600 
所以你把它們寫在一行還是可讀的

00:48:21.101 --> 00:48:25.138 
因爲枚舉是一個可能值的列表

00:48:25.205 --> 00:48:27.808 
經常把它和switch一起用

00:48:28.709 --> 00:48:32.212  
一個switch case
對應一個枚舉案例

00:48:33.714 --> 00:48:37.751  
一遍遍寫對齊有點重複

00:48:37.818 --> 00:48:39.853  
在這並不需要

00:48:40.921 --> 00:48:47.261  
switch考慮文本對齊
所以需要檢查的僅有的可能值

00:48:47.461 --> 00:48:50.397  
是枚舉的案例

00:48:51.164 --> 00:48:54.535  
所以你可以省略枚舉名稱

00:48:54.601 --> 00:48:56.803  
只用寫“.left”

00:48:58.438 --> 00:49:01.742  
還要注意這裏沒有default

00:49:02.843 --> 00:49:05.379  
和你已經看到的原因一樣

00:49:05.979 --> 00:49:10.417  
switch已經覆蓋了所有可能的
對齊值

00:49:10.584 --> 00:49:14.087  
沒有東西留下給default來處理

00:49:15.489 --> 00:49:18.892  
省略default有一個好處

00:49:19.493 --> 00:49:23.597  
如果你晚些回來增加一個枚舉案例

00:49:23.664 --> 00:49:26.200  
但是忘記更新switch

00:49:26.266 --> 00:49:30.504  
Swift會高亮這個錯誤直到你添加
遺失的代碼

00:49:32.673 --> 00:49:38.011  
讓我們快速看一看
你能對枚舉做的其他兩件事

00:49:40.681 --> 00:49:44.718 
你可以給每個枚舉案例關聯一個值

00:49:45.652 --> 00:49:51.124 
比如對齊可以指定要用多少填充

00:49:52.793 --> 00:49:58.332  
你可以獲得那個填充值
在switch case中

00:50:00.601 --> 00:50:07.441 
你也可以給每個枚舉案例
一個原始值從其他類型中

00:50:07.508 --> 00:50:09.877 
比如字符串或者整數

00:50:11.578 --> 00:50:14.882  
來讓你提升代碼的類型安全

00:50:14.948 --> 00:50:18.752  
通過用枚舉取代字符串常量

00:50:21.154 --> 00:50:24.258  
你今天下午看了很多Swift

00:50:24.758 --> 00:50:27.127  
但是沒有時間展示所有的

00:50:28.028 --> 00:50:31.532  
最後一個我想展示的是錯誤處理

00:50:34.134 --> 00:50:39.173 
在Swift中你可以用枚舉來描述
錯誤

00:50:40.741 --> 00:50:44.912 
你用throws關鍵字標記一個函數
可以拋出錯誤

00:50:47.047 --> 00:50:51.752 
你在必須要運行的代碼塊前
寫defer關鍵字

00:50:51.818 --> 00:50:53.720 
無論是否發生錯誤

00:50:54.087 --> 00:50:58.258 
它都會在退出作用域前被運行

00:50:58.325 --> 00:51:00.294 
比如從一個函數返回

00:51:03.630 --> 00:51:06.633 
在調用可能拋出錯誤的代碼前

00:51:06.700 --> 00:51:08.402 
你用try關鍵字標記它

00:51:09.970 --> 00:51:14.675  
你可以捕獲和拋出錯誤
用catch和throw關鍵字

00:51:16.243 --> 00:51:21.582  
關於所有細節請看錯誤處理章節

00:51:21.648 --> 00:51:23.717  
在Swift編程語言中

00:51:25.452 --> 00:51:29.389 
你可以在這找到這本書和其他資源
的鏈接

00:51:31.592 --> 00:51:36.964  
有很多很好的Swift演講
可以在這周晚些時間參加或者看視頻

00:51:37.698 --> 00:51:38.532 
謝謝