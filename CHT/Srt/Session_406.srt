00:00:19.386 --> 00:00:21.455 
應用啓動時間優化

00:00:22.523 --> 00:00:26.260 
早上好 歡迎來到406演講
“應用啓動時間優化”

00:00:26.560 --> 00:00:29.363 
我叫Nick Kledzik
我將和同事Louis

00:00:29.429 --> 00:00:32.598 
帶大家一起討論 如何啓動進程

00:00:34.168 --> 00:00:36.937 
你們可能會想 這個主題適合我嗎？

00:00:38.605 --> 00:00:41.508 
所以我們請了專業的開發營銷團隊
做了一些調查

00:00:41.575 --> 00:00:45.145 
得出的結果是
有三組人羣將會從本演講中收益

00:00:45.679 --> 00:00:50.951 
第一組 是應用開發者
他們的應用啓動很慢

00:00:52.352 --> 00:00:56.456  
第二組 是不想在第一組的應用開發者

00:00:59.226 --> 00:01:03.530  
最後一組
是任何對操作系統的運作感到好奇的人

00:01:04.864 --> 00:01:06.834 
所以本次演講分成兩個部分

00:01:06.900 --> 00:01:10.437 
第一部分更注重理論
第二部分更注重實際

00:01:10.504 --> 00:01:12.206 
我負責第一部分

00:01:13.874 --> 00:01:16.777 
我將會帶你一起看看發生的步驟

00:01:16.877 --> 00:01:18.011 
一直到主函數

00:01:18.946 --> 00:01:21.181 
但是爲了理解所有的步驟

00:01:21.248 --> 00:01:25.519 
首先需要上一個速成課
關於Mach-O和虛擬內存

00:01:27.588 --> 00:01:29.690 
首先
快速講一下Mach-O的部分術語

00:01:29.990 --> 00:01:34.194 
Mach-0是運行時
可執行文件的文件類型

00:01:34.261 --> 00:01:36.997 
第一個類型是可執行文件
應用裏最重要的二進制文件

00:01:37.064 --> 00:01:39.333 
也是應用擴展文件的主二進制文件

00:01:40.601 --> 00:01:44.571 
Dylib是一個動態庫
在其他平臺上

00:01:44.638 --> 00:01:47.574 
用的是你可能會熟悉的名字：
DSO和DLL

00:01:48.375 --> 00:01:51.044 
我們的平臺上還有另一種類型叫捆綁包

00:01:51.178 --> 00:01:54.414 
捆綁包是一種特殊的Dylib
是不能進行鏈接的

00:01:54.481 --> 00:01:57.251 
只能在運行時
用dlopen()函數打開它

00:01:57.317 --> 00:01:59.152 
Mac OS的插件會用到

00:02:00.354 --> 00:02:03.757 
最後是圖像
圖像指的是任意這三種類型

00:02:04.024 --> 00:02:05.492 
我會常常提到圖像

00:02:06.093 --> 00:02:09.295 
最後 是框架
該名詞在我們的領域如雷貫耳

00:02:09.363 --> 00:02:11.331 
但就本主題而言

00:02:11.598 --> 00:02:14.168 
框架是一個Dylib
周圍有特別的目錄結構

00:02:14.234 --> 00:02:16.036 
存儲該Dylib需要的文件

00:02:17.538 --> 00:02:20.674 
我們來看看Mach-O圖像格式

00:02:20.807 --> 00:02:23.043 
Mach-O圖像分成數段

00:02:24.111 --> 00:02:27.381 
按照慣例
所有的段名都是由大寫字母組成

00:02:29.316 --> 00:02:33.554 
每一段都是頁面大小的倍數

00:02:33.787 --> 00:02:37.691 
該例中 TEXT段大小是3頁
DATA和LINKEDIT段大小是1頁

00:02:38.458 --> 00:02:40.494 
頁面大小由硬件決定

00:02:40.561 --> 00:02:45.199 
arm64處理器的頁面大小是16K
其他都是4K

00:02:46.200 --> 00:02:49.436 
另一種查看方式是分區

00:02:49.503 --> 00:02:51.438 
編譯器常常會忽略分區

00:02:51.505 --> 00:02:54.341 
分區是段的子範圍

00:02:54.975 --> 00:02:57.411 
分區不用遵循頁面的大小

00:02:57.644 --> 00:02:59.112 
但是它們是不重疊的

00:03:02.883 --> 00:03:06.486 
最常見的段名是
TEXT DATA LINKEDIT

00:03:06.553 --> 00:03:09.756 
實際上幾乎每一個二進制文件
都包含這三段

00:03:09.823 --> 00:03:12.526 
你可以添加自定義段
但一般不會給它賦值

00:03:13.427 --> 00:03:14.595 
這些是用來做什麼的？

00:03:14.661 --> 00:03:17.030 
TEXT是文件的開頭

00:03:17.097 --> 00:03:20.133 
它包含了Mach的頭文件
任何機器指令

00:03:20.200 --> 00:03:22.603 
以及任何只讀常量 比如C字符串

00:03:23.937 --> 00:03:25.372 
DATA段是重寫段

00:03:25.439 --> 00:03:27.808 
它包含了所有的全局變量

00:03:28.709 --> 00:03:30.110 
最後是LINKEDIT段

00:03:30.410 --> 00:03:33.213 
它不包含全局變量的函數

00:03:33.280 --> 00:03:35.916 
它包含變量函數信息

00:03:35.983 --> 00:03:37.584 
比如名稱和地址

00:03:39.520 --> 00:03:42.456 
你可能還聽說過通用文件
什麼是通用文件？

00:03:42.956 --> 00:03:45.893 
假設你生成一個64位的iOS應用

00:03:46.193 --> 00:03:48.095 
現在你有一個Mach-O文件

00:03:48.161 --> 00:03:49.530 
當你也想讓它在32位的設備上運行

00:03:49.596 --> 00:03:52.366 
Xcode裏會發生什麼變化？

00:03:52.966 --> 00:03:57.638 
重新生成時 Xcode會生成
另一個單獨的Mach-O文件

00:03:57.704 --> 00:03:59.740 
這個是爲32位生成的armv7

00:04:00.340 --> 00:04:03.810 
之後這兩個文件合併成第三個文件

00:04:04.344 --> 00:04:07.481 
叫作 Mach-O通用文件
它前端有一個頭文件

00:04:07.548 --> 00:04:09.950 
所有的頭文件都有一個
所有體系結構的列表

00:04:10.017 --> 00:04:11.718 
它們的偏移值也在文件裏

00:04:12.119 --> 00:04:14.855 
該頭文件也是一個頁面的大小

00:04:15.756 --> 00:04:18.926 
你也許想問
爲什麼段都要是頁面大小的倍數？

00:04:18.992 --> 00:04:21.962 
爲什麼頭文件要一個頁面的大小
爲什麼要浪費那麼多空間？

00:04:22.596 --> 00:04:26.567 
這就涉及到我們下個主題 虛擬內存

00:04:27.301 --> 00:04:28.936 
什麼是虛擬內存？

00:04:30.470 --> 00:04:32.773 
你們當中可能有人知道
軟件工程裏的格言

00:04:32.840 --> 00:04:35.409 
任何問題都可以
通過添加一個間接層加以解決

00:04:35.843 --> 00:04:39.112 
所以虛擬內存解決的問題是

00:04:39.646 --> 00:04:43.150 
所有這些進程存在時
該如何管理所有物理內存？

00:04:43.417 --> 00:04:45.219 
所以他們添加了一個小的間接層

00:04:45.352 --> 00:04:47.654 
每一個進程都是一個邏輯地址空間

00:04:48.121 --> 00:04:50.624 
映射到RAM的某個物理頁面

00:04:53.627 --> 00:04:55.996 
這種映射不一定是一對一的

00:04:56.330 --> 00:05:00.000 
邏輯地址可以不對應任何物理RAM

00:05:00.067 --> 00:05:03.937 
也可以多個邏輯地址對應
同一物理RAM

00:05:04.471 --> 00:05:06.740 
這樣帶來很多種可能

00:05:07.274 --> 00:05:08.709 
能利用虛擬內存做什麼呢？

00:05:09.009 --> 00:05:12.779 
首先 如果有一個邏輯地址
不映射任何物理RAM

00:05:13.213 --> 00:05:16.617 
當進程要訪問該地址時
就會產生頁面錯誤

00:05:16.717 --> 00:05:18.352 
內核將停止該線程

00:05:18.418 --> 00:05:21.054 
並試圖找出解決方案

00:05:22.856 --> 00:05:25.058 
下一點是 如果有兩個進程

00:05:25.392 --> 00:05:28.195 
有兩個物理地址 映射同一個物理頁面

00:05:28.262 --> 00:05:31.031 
這兩個進程共享一樣比特的RAM

00:05:31.098 --> 00:05:32.933 
進程之間開始共享

00:05:34.401 --> 00:05:37.337 
另一個有意思的功能是
基於文件的映射

00:05:38.105 --> 00:05:40.641 
不用把整個文件讀入RAM

00:05:40.707 --> 00:05:43.310 
而是可以調用mmap()函數
告訴虛擬內存系統

00:05:44.244 --> 00:05:49.316 
我想把這部分文件映射到
進程裏的這段地址

00:05:49.716 --> 00:05:50.784 
爲什麼要這麼做？

00:05:51.318 --> 00:05:54.755 
不用讀取整個文件 通過設置該映射

00:05:55.022 --> 00:05:57.524 
第一次訪問這些不同的地址時

00:05:57.591 --> 00:05:59.026 
如同已經在內存裏讀過

00:05:59.726 --> 00:06:02.196 
每次訪問未訪問過的地址時

00:06:02.262 --> 00:06:05.065 
都會導致頁面錯誤
內核會讀該錯誤頁面

00:06:05.132 --> 00:06:07.401 
將會造成讀取文件遲緩

00:06:08.235 --> 00:06:10.337 
現在可以把所有功能集中

00:06:10.571 --> 00:06:13.774 
關於我告訴你的Mach-O可以發現

00:06:13.841 --> 00:06:17.678 
Dylib或圖像的TEXT段
可以映射到多個進程

00:06:18.145 --> 00:06:19.313 
將會造成讀取遲緩

00:06:19.379 --> 00:06:22.115 
而所有這些頁面可以在進程間共享

00:06:26.086 --> 00:06:28.789 
DATA段呢？DATA段用來讀寫

00:06:28.956 --> 00:06:31.225 
有一個策略叫寫入時複製

00:06:31.692 --> 00:06:35.796 
這和Apple文件系統的克隆很相似

00:06:36.630 --> 00:06:39.466 
寫入時複製所做的是它積極地

00:06:39.533 --> 00:06:41.368 
在所有進程裏共享DATA頁面

00:06:42.336 --> 00:06:46.940 
只要進程只讀有共享內容的全局變量

00:06:47.007 --> 00:06:50.277 
但是一旦有進程想要
寫入其DATA頁面

00:06:50.477 --> 00:06:51.812 
寫入時複製開始

00:06:51.912 --> 00:06:54.481 
內核會把該頁面複製

00:06:54.548 --> 00:06:57.985 
放入另一個物理RAM並重定向映射

00:06:58.051 --> 00:07:01.388 
所以該進程有了該頁面的副本

00:07:02.589 --> 00:07:04.658 
這把我們帶到了 髒vs乾淨頁面

00:07:04.858 --> 00:07:06.994 
該副本被認爲是髒頁面

00:07:07.261 --> 00:07:11.431 
髒頁面是指含有進程特定信息

00:07:11.865 --> 00:07:14.434 
乾淨頁面是指內核可以按照需要
重新建立的頁面

00:07:14.501 --> 00:07:16.103 
比如重新讀取磁盤

00:07:16.603 --> 00:07:19.506 
所以髒頁面比干淨頁面要昂貴許多

00:07:20.807 --> 00:07:24.077 
最後一點是 頁面也有權限界限

00:07:26.180 --> 00:07:28.415 
這指的是 可以標記一個頁面

00:07:28.482 --> 00:07:31.685 
可讀 可寫 或可執行
或它們的任何組合

00:07:33.520 --> 00:07:36.857 
所以我講到了Mach-O格式
關於虛擬內存的一些內容

00:07:36.924 --> 00:07:38.392 
看看它們是如何一起工作的

00:07:38.625 --> 00:07:42.129 
我先往前跳一步
先簡單講講Dylib是如何操作的

00:07:42.196 --> 00:07:44.731 
一會兒我會和你們一起來看 但現在

00:07:44.798 --> 00:07:47.768 
我想講一下它在Mach-O
和虛擬內存之間是如何映射的

00:07:48.101 --> 00:07:51.705 
這裏有一個Dylib文件
我們沒有把它讀到內存

00:07:51.772 --> 00:07:53.006 
而是把它映射到內存

00:07:53.440 --> 00:07:57.644 
所以 在內存裏該Dylib文件
本應該佔用8個頁面

00:07:59.479 --> 00:08:01.815 
看一下 不同是有這些“全零填充”

00:08:01.882 --> 00:08:04.251 
大部分全局變量的初始值都是零

00:08:04.318 --> 00:08:05.953 
所以靜態鏈接器進行了優化

00:08:06.019 --> 00:08:08.689 
把所有值爲0的全局變量都移到了尾端

00:08:08.755 --> 00:08:10.190 
然後不佔用任何磁盤空間

00:08:10.490 --> 00:08:12.192 
取而代之
我們利用虛擬內存的特性

00:08:12.392 --> 00:08:15.562 
該頁面第一次被訪問時
告訴虛擬內存 把它填滿0

00:08:15.796 --> 00:08:17.364 
所以它不需要讀取

00:08:19.066 --> 00:08:22.002 
Dylib必須要做的第一件事
是查看Mach頭文件

00:08:22.202 --> 00:08:23.704 
在內存裏 在該進程裏

00:08:23.804 --> 00:08:25.906 
它將查看內存的頂盒

00:08:26.073 --> 00:08:28.909 
此時 那裏是空的
沒有內容映射到物理頁面上

00:08:28.976 --> 00:08:30.210 
所以產生頁面錯誤

00:08:30.277 --> 00:08:33.013 
到那時內核意識到
它被映射到了一個文件

00:08:33.080 --> 00:08:35.015 
所以它將讀取文件的第一頁

00:08:35.616 --> 00:08:37.918 
放入物理RAM設置其映射

00:08:38.452 --> 00:08:41.421 
現在Dylib可以真正通過
Mach頭文件開始讀取

00:08:41.488 --> 00:08:43.190 
它這麼做了 Mach頭文件說

00:08:43.256 --> 00:08:45.792 
“看看LINKEDIT段上的
這條信息”

00:08:45.859 --> 00:08:49.897 
再一次 Dylib跳下去
查看進程1的底盒

00:08:50.631 --> 00:08:52.199 
這又會產生頁面錯誤

00:08:53.634 --> 00:08:56.436 
內核又讀入RAM的另一個

00:08:56.503 --> 00:08:59.173 
LINKEDIT的物理頁面
Dylib現可期望一個LINKEDIT

00:08:59.506 --> 00:09:01.742 
進程 LINKEDIT
將會告訴Dylib

00:09:01.808 --> 00:09:06.113 
對DATA頁面做一些修正
讓dylib可運行

00:09:07.147 --> 00:09:08.782 
所以 同樣的事又發生了

00:09:09.616 --> 00:09:12.219 
Dylib現從DATA頁面讀取數據

00:09:13.153 --> 00:09:14.254 
但是有一點不同

00:09:14.321 --> 00:09:17.591 
Dylib 想要寫回一些內容
修改DATA頁面

00:09:17.658 --> 00:09:19.760 
此時 寫入時複製出現了

00:09:20.260 --> 00:09:21.528 
這個頁面變髒了

00:09:23.497 --> 00:09:25.966 
所以髒RAM的8個頁面將會是什麼？

00:09:26.033 --> 00:09:28.769 
若我只用malloc()函數
分配8頁內存 然後讀了一些內容進去

00:09:28.836 --> 00:09:29.903 
我將會有8個頁面

00:09:29.970 --> 00:09:32.406 
但是我只有1頁的
髒RAM和2頁乾淨的

00:09:32.472 --> 00:09:35.542 
如果第二個進程加載
同一個Dylib 會發生什麼？

00:09:36.343 --> 00:09:38.779 
在第二個進程裏
Dylib經歷相同的步驟

00:09:38.846 --> 00:09:40.347 
首先它查看Mach頭文件

00:09:40.747 --> 00:09:42.382 
但這次內核說

00:09:42.449 --> 00:09:44.318 
“在RAM某處我已經有這頁了”

00:09:44.384 --> 00:09:48.222 
所以內核只簡單地把映射重定向
重新使用該頁面 沒有任何IO操作

00:09:48.689 --> 00:09:50.858 
LINKEDIT也是如此 更加快速

00:09:51.258 --> 00:09:52.693 
我們來看DATA頁面

00:09:53.293 --> 00:09:56.530 
此時 內核必須要看看在DATA頁面

00:09:56.630 --> 00:09:59.132 
乾淨的副本是否還存在RAM某處

00:09:59.199 --> 00:10:02.002 
如果還在 就可以重複使用
如果不再 就必須要重新讀取

00:10:02.870 --> 00:10:05.172 
在該進程種
Dylib會讓RAM變髒

00:10:06.206 --> 00:10:09.042 
最後一步是LINKEDIT

00:10:09.109 --> 00:10:10.811 
只在Dylib進行操作時被需要

00:10:11.111 --> 00:10:13.447 
所以它可以提醒內核 當它完成時

00:10:13.747 --> 00:10:15.849 
它不再需要這些LINKEDIT頁面

00:10:15.916 --> 00:10:18.185 
當有別人需要RAM時 可以回收它們

00:10:19.620 --> 00:10:22.189 
現在有兩個進程在共享這些Dylib

00:10:22.256 --> 00:10:25.359 
每個進程都本應該有8個頁面
也就是一共有16個髒頁面

00:10:25.559 --> 00:10:28.595 
但現在我們只有2個髒頁面
和1個乾淨的 共享頁面

00:10:31.832 --> 00:10:34.701 
我還想補充說明兩點
安全如何影響Dyld

00:10:34.768 --> 00:10:36.837 
兩點安全問題會影響Dyld

00:10:36.904 --> 00:10:39.940 
首先是ASLR 地址空間佈局隨機化

00:10:40.707 --> 00:10:42.609 
這是10年或20年前的舊技術

00:10:42.676 --> 00:10:45.012 
基本概念是把加載地址隨機化

00:10:47.381 --> 00:10:48.582 
第二點是 代碼簽名

00:10:48.782 --> 00:10:53.687 
你們當中的很多人都有代碼簽名的經驗
在Xcode裏 代碼簽名是指

00:10:53.754 --> 00:10:57.724 
對整個文件運行一個加密哈希算法

00:10:57.891 --> 00:10:59.526 
然後在文件上簽名

00:10:59.960 --> 00:11:04.998 
爲了在運行時進行驗證
整個文件都必須要重新讀取

00:11:05.332 --> 00:11:09.770 
所以在編譯階段
我們讓Mach-O文件的每一個頁面

00:11:10.170 --> 00:11:13.106 
都進行自己的加密哈希算法

00:11:13.307 --> 00:11:15.509 
所有哈希都儲存在LINKEDIT裏

00:11:16.543 --> 00:11:19.446 
這使得你的每個未被修改的頁面

00:11:19.513 --> 00:11:22.883 
在被讀取的過程中
都能得到及時驗證

00:11:24.484 --> 00:11:26.186 
好的 速成課結束

00:11:26.253 --> 00:11:28.555 
現在我將帶你們一起
從exec()講到main()

00:11:32.292 --> 00:11:34.695 
什麼是exec()？
exec()是一個系統調用

00:11:36.296 --> 00:11:37.965 
當你進入內核 說

00:11:38.031 --> 00:11:40.434 
我想把這個進程換成這個新程序

00:11:40.501 --> 00:11:44.805 
內核會抹去整個地址
映射指定的可執行程序

00:11:45.072 --> 00:11:47.674 
ASLR把它映射到一個隨機地址

00:11:48.408 --> 00:11:52.012 
下一步是從該隨機地址 回溯到0地址

00:11:52.679 --> 00:11:54.581 
把整個區域標記爲不可訪問

00:11:54.648 --> 00:11:57.985 
意思是 不可讀 不可寫 不可執行

00:11:58.785 --> 00:12:01.522 
該區域在32位處理器下
至少4KB大小

00:12:01.588 --> 00:12:04.625 
64位處理器下至少4GB大小

00:12:04.858 --> 00:12:08.328 
這樣可以捕捉任何空指針引用

00:12:08.395 --> 00:12:11.698 
捕捉任何指針截斷

00:12:14.601 --> 00:12:17.938 
Unix誕生的前幾十年
一切都很簡單

00:12:18.005 --> 00:12:20.908 
我只需映射一個程序
把指針引用指向它 開始運行它即可

00:12:20.974 --> 00:12:22.843 
然後共享庫被髮明出來

00:12:23.210 --> 00:12:24.845 
那麼誰來加載Dylibs？

00:12:25.579 --> 00:12:27.514 
人們很快意識到情況太過複雜

00:12:27.581 --> 00:12:29.516 
不想讓內核來做這件事

00:12:29.583 --> 00:12:34.288 
所以人們新建了幫助程序
在我們的平臺上 叫作Dyld

00:12:34.688 --> 00:12:37.191 
在別的Unix平臺
可能聽說過它名字LD.SO

00:12:37.791 --> 00:12:40.961 
當內核完成進程的映射
它現在映射另一個Mach-O文件

00:12:41.028 --> 00:12:44.431 
調用Dyld進入該進程
到另一個隨機地址

00:12:44.831 --> 00:12:48.902 
把指針引用指向
Dyld 讓Dyld完成進程啓動

00:12:50.470 --> 00:12:52.239 
現在Dyld在運行進程

00:12:52.306 --> 00:12:55.843 
它的工作是加載所有依賴的Dylib

00:12:55.943 --> 00:12:57.377 
讓它們全部準備好開始運行

00:12:58.111 --> 00:12:59.646  
我們一起來瀏覽這些步驟

00:12:59.947 --> 00:13:02.883  
底部有很多步驟和一個時間線

00:13:02.950 --> 00:13:05.552  
我們瀏覽這些的時候 也會瀏覽時間線

00:13:06.253 --> 00:13:10.257  
首先 Dyld是否需要
映射所有的依賴Dylib？

00:13:10.657 --> 00:13:12.159  
什麼是依賴Dylib？

00:13:12.226 --> 00:13:15.062 
要找到它們 首先要讀取主可執行文件

00:13:15.128 --> 00:13:17.297 
的頭文件 內核已經映射好的

00:13:17.364 --> 00:13:19.833 
在該頭文件裏有一個所有依賴庫的列表

00:13:19.967 --> 00:13:21.301 
都必須要進行分析

00:13:22.069 --> 00:13:24.037 
所以必須要找到每一個Dylib

00:13:25.439 --> 00:13:28.709 
如果每一個Dylib都找到了
它就須打開和開始運行每一個文件

00:13:28.809 --> 00:13:30.911 
它需要確保是一個Mach-O文件

00:13:31.778 --> 00:13:35.449 
對它進行驗證 找到它的編碼簽名
在內核裏對它進行註冊

00:13:37.985 --> 00:13:41.121 
然後它可以在該Dylib裏的每一段
調用mmap()

00:13:42.456 --> 00:13:43.891 
好吧 這非常簡單

00:13:44.458 --> 00:13:47.094 
你的應用知道內核Dyld

00:13:47.160 --> 00:13:49.997 
Dyld說 噢
這個應用依賴A和B Dylib

00:13:50.063 --> 00:13:51.431 
加載它們兩個 完成了

00:13:51.498 --> 00:13:55.035 
當然 實際情況要更爲複雜
因爲A.dylib和B.dylib

00:13:55.102 --> 00:13:56.503 
自身也可能依賴dylib

00:13:57.371 --> 00:14:00.007 
所以dyld必須再做一次同樣的事

00:14:00.073 --> 00:14:01.275 
爲每一個dylib

00:14:01.341 --> 00:14:03.944 
而每個dylib可能依賴於
某個已加載或新的東西

00:14:04.011 --> 00:14:07.147 
它決定是否已經加載
如果否 則需要加載

00:14:07.781 --> 00:14:09.483 
所以 如此繼續

00:14:11.818 --> 00:14:13.420 
最終所有的都加載了

00:14:13.487 --> 00:14:17.357 
如果你看一個進程
系統裏的一個普通進程

00:14:17.524 --> 00:14:22.563 
都會加載1到400個dylibs
這個加載數量很大

00:14:23.130 --> 00:14:26.400 
還好大部分都是OS dylibs
我們做了很多工作

00:14:26.466 --> 00:14:28.435 
在建立OS預計算時

00:14:28.502 --> 00:14:31.638 
和與緩存那些dyld要做的工作
來加載這些內容

00:14:31.839 --> 00:14:34.208 
所以OS dylibs加載速度非常
非常快

00:14:37.578 --> 00:14:39.613  
現在所有dyibs都已經加載完成

00:14:39.680 --> 00:14:43.483  
但它們都彼此獨立
我們必須要把它們綁在一起

00:14:43.851 --> 00:14:45.018  
這就是修復

00:14:45.886 --> 00:14:48.255  
關於修復有一點 我們已經知道

00:14:48.388 --> 00:14:50.924  
因爲編碼簽名的存在
我們無法修改指令

00:14:51.358 --> 00:14:53.794  
那麼dylib該如何
調用另一dylib？

00:14:53.861 --> 00:14:56.330  
如果無法修改指令 怎麼調用？

00:14:56.430 --> 00:14:59.433  
我們把老朋友找回來
加上許多舊的間接引用

00:15:00.100 --> 00:15:04.037  
所以我們的code-gen
即動態PIC 即地址無關代碼

00:15:04.104 --> 00:15:06.240  
代碼可以加載到該地址 並且是動態的

00:15:06.306 --> 00:15:09.643  
也就是說 地址間接地被分配

00:15:09.943 --> 00:15:12.279  
也就是說爲了讓一個調用另一個

00:15:12.513 --> 00:15:15.415  
code-gen實際上
在DATA段裏新建了一個指針

00:15:15.516 --> 00:15:17.618  
該指針指向我們想要調用的位置

00:15:17.718 --> 00:15:20.153  
代碼加載該指針 跳向指針

00:15:22.356 --> 00:15:25.158 
所以所有的dyld
都在修復指針和數據

00:15:26.894 --> 00:15:29.863 
修復有兩種 重設基址和綁定

00:15:29.930 --> 00:15:31.198 
它們的區別是什麼？

00:15:31.298 --> 00:15:35.068 
重設基址是指
如果有一個指針指向圖像範圍內

00:15:35.369 --> 00:15:37.237 
需要做出的所有修改

00:15:37.504 --> 00:15:38.739 
第二種是綁定

00:15:38.906 --> 00:15:41.175 
綁定是指 如果指針指向圖像範圍外

00:15:41.241 --> 00:15:43.177 
它們必須進行不同的修復

00:15:43.243 --> 00:15:44.645 
我來帶大家一起看看其步驟

00:15:45.312 --> 00:15:47.581 
但是首先 如果你覺得好奇
有這麼一個指令

00:15:47.648 --> 00:15:49.483 
dyldinfo還有很多選項參數

00:15:49.550 --> 00:15:52.753 
你可以在任何二進制文件上運行
就可以看到所有的修復

00:15:52.819 --> 00:15:55.556 
該dyld將必須該二進制文件
才能讓他準備好

00:15:58.759 --> 00:15:59.726 
這就是重獲基址

00:16:00.761 --> 00:16:04.798 
過去你可以爲每一個dylib
指定首選加載地址

00:16:05.399 --> 00:16:08.068 
該首選加載地址是一個靜態指針

00:16:08.135 --> 00:16:10.070 
和dyld一起合作
比如 若把它加載

00:16:10.137 --> 00:16:12.573 
到該首選加載地址 所有指針和數據

00:16:12.639 --> 00:16:14.374 
本應該內部編碼的 都是正確的

00:16:14.441 --> 00:16:16.176 
那麼dyld就不用做任何修復

00:16:16.643 --> 00:16:18.345 
但是現在 因爲有了ASLR

00:16:19.713 --> 00:16:21.548 
dylib加載到隨機地址上

00:16:21.982 --> 00:16:25.485 
它滑到了其他地址
也就是說所有那些指針和數據

00:16:25.552 --> 00:16:27.487 
都還依然指向舊地址

00:16:27.855 --> 00:16:31.225 
所以爲了修復它們
我們需要計算滑動值

00:16:31.291 --> 00:16:34.995 
也就是移動距離
並且對每一個內部指針

00:16:35.128 --> 00:16:37.130 
都添加該滑動值

00:16:37.764 --> 00:16:41.468 
所以重設基址是指遍歷所有

00:16:41.568 --> 00:16:44.137 
內部數據指針
然後爲它們添加一個滑動值

00:16:44.204 --> 00:16:47.107 
概念非常簡單 讀 添加 寫
讀 添加 寫

00:16:47.741 --> 00:16:49.409 
但是這些數據指針在哪裏？

00:16:49.576 --> 00:16:53.280 
這些指針在段裏的位置
都編碼在LINKEDIT段裏

00:16:54.014 --> 00:16:57.084 
此時 所有映射都已經結束

00:16:57.184 --> 00:16:58.352 
當我們開始重設基址時

00:16:58.418 --> 00:17:01.555 
實際上在所有DATA頁面上
都產生了錯誤

00:17:01.855 --> 00:17:03.991 
然後對頁面進行修改 產生寫入時複製

00:17:04.525 --> 00:17:07.761 
所有重設基址有時會非常昂貴
由於所有這些I/O

00:17:08.295 --> 00:17:10.263 
但是有一個技巧  就是按順序操作

00:17:10.329 --> 00:17:14.268 
從內核的角度來看
它認爲數據錯誤按順序產生

00:17:14.568 --> 00:17:17.436 
當它如此認爲時 內核會進行預讀

00:17:17.538 --> 00:17:19.339 
這樣I/O成本將降低很多

00:17:21.775 --> 00:17:22.675 
下面來講綁定

00:17:22.742 --> 00:17:25.479 
綁定針對那些指向dylib範圍外的
指針而言

00:17:26.213 --> 00:17:28.549 
這些指針通過名稱進行綁定
實際都是字符串

00:17:28.615 --> 00:17:30.884 
本例中
LINKEDIT段裏的malloc

00:17:30.951 --> 00:17:33.353 
也就是說該數據指針
需要指向malloc

00:17:33.554 --> 00:17:37.357 
所以運行時
dyld需要找到實現該符號的位置

00:17:38.792 --> 00:17:42.462 
這需要很多的計算 遍歷查找符號表

00:17:42.629 --> 00:17:44.998 
一旦找到 就把值存到該數據指針裏

00:17:45.299 --> 00:17:48.235 
計算複雜度比重設基址高得多

00:17:48.569 --> 00:17:49.970 
但是I/O很少

00:17:50.037 --> 00:17:52.206 
因爲重設基址已經完成大部分I/O

00:17:56.376 --> 00:17:59.146 
下一步 ObjC有很多DATA結構

00:17:59.213 --> 00:18:01.548 
DATA結構類
也就是指向方法的指針

00:18:01.615 --> 00:18:03.383 
以及高光指針等等

00:18:03.450 --> 00:18:06.420 
幾乎所有都已經被修復
通過重設基址或者綁定

00:18:07.020 --> 00:18:10.791 
但在ObjC運行時
還需要一些額外的操作

00:18:11.458 --> 00:18:13.594 
首先ObjC是一門動態語言

00:18:13.660 --> 00:18:16.964 
可以把一個類用名稱實例化

00:18:17.064 --> 00:18:18.765 
即ObjC運行時 必須要維護

00:18:18.832 --> 00:18:21.301 
一張表格 包含所有名稱及其映射的類

00:18:21.502 --> 00:18:23.637 
每次加載的名稱 都將定義一個類

00:18:23.704 --> 00:18:25.772 
名稱需要登記在一個全局表格裏

00:18:26.807 --> 00:18:32.312 
接下來 在C++裏你們可能聽說過
脆弱的ivar問題 抱歉

00:18:32.546 --> 00:18:34.248 
脆弱的基類問題

00:18:35.082 --> 00:18:38.051 
在ObjC裏不存在該問題
因爲我們做的其中一種修復就是

00:18:38.118 --> 00:18:41.255 
動態改變所有ivar的偏移值
在加載時

00:18:42.956 --> 00:18:46.493 
接下來 在ObjC裏 可以定義類別

00:18:46.560 --> 00:18:49.263 
就是改變另一個類中的方法

00:18:49.496 --> 00:18:53.267 
有時候 它們在那些位於
另一dylib且在圖像範圍外的類裏

00:18:53.800 --> 00:18:56.870 
此時 那些方法修復必須已經完成

00:18:58.172 --> 00:19:01.542 
最後 ObjC基於選擇器是唯一的

00:19:01.608 --> 00:19:03.010 
所以我們需要唯一選擇器

00:19:04.945 --> 00:19:07.247 
現在我們完成了所有的DATA修復

00:19:07.347 --> 00:19:09.950 
現在我們可以進行所有

00:19:10.017 --> 00:19:12.119 
可以靜態描述的DATA修復

00:19:12.186 --> 00:19:14.421 
現在是進行動態DATA修復的時機

00:19:14.721 --> 00:19:17.291 
在C++裏 有一個初始化器

00:19:17.357 --> 00:19:19.726 
可以指定 等於你想要的任何表達式

00:19:20.093 --> 00:19:23.263 
該抽象表達式 此時需要運行

00:19:23.330 --> 00:19:24.631 
此時開始運行

00:19:24.698 --> 00:19:26.900 
所以C++編譯器生成

00:19:27.768 --> 00:19:30.871 
初始化器來完成
那些抽象DATA的初始化

00:19:31.638 --> 00:19:34.608 
在ObjC 有一種方法
叫+load方法

00:19:34.942 --> 00:19:37.911 
現在+load方法已經被否決
不建議使用

00:19:37.978 --> 00:19:39.713 
建議使用+initialize

00:19:39.813 --> 00:19:41.782 
若有+load方法 此時它開始運行

00:19:43.383 --> 00:19:45.352 
現在我有了這張大圖

00:19:45.419 --> 00:19:49.223 
頂端是主可執行文件
所有的dylibs依照這張大圖

00:19:49.556 --> 00:19:50.991 
必須要運行初始化器

00:19:51.225 --> 00:19:54.161 
按什麼順序運行呢？我們選擇從下往上

00:19:54.228 --> 00:19:55.095 
原因在於

00:19:57.231 --> 00:20:00.067 
當初始化器運行時
可能會調用一些dylib

00:20:00.133 --> 00:20:02.636 
你需要確保那些dylib
已經準備好被調用

00:20:02.703 --> 00:20:04.438 
所以從下開始運行初始化器

00:20:04.505 --> 00:20:06.006 
一直往上到應用類

00:20:06.640 --> 00:20:08.876 
可以很安全地調用依賴的內容

00:20:11.345 --> 00:20:12.980 
但所有初始化器完成時

00:20:13.146 --> 00:20:15.883 
我們實際已經最終調用
的主Dylib程序

00:20:17.451 --> 00:20:19.453 
理論部分熬過來了

00:20:19.553 --> 00:20:22.022 
你們現在都是瞭解
進程如何啓動的專家了

00:20:22.356 --> 00:20:24.458 
知道dyld是一個幫助程序

00:20:25.259 --> 00:20:27.294 
它加載所有的依賴庫

00:20:28.028 --> 00:20:29.429 
修復所有DATA頁面

00:20:30.063 --> 00:20:32.132 
運行初始化器 跳轉到主函數

00:20:32.499 --> 00:20:35.836 
那麼該如何把這些理論應用到實際中？

00:20:35.969 --> 00:20:37.471 
我把該主題交給Louis

00:20:38.539 --> 00:20:40.541 
他將會爲你們講解非常實用的技巧

00:20:48.315 --> 00:20:49.149 
謝謝你 Nick

00:20:50.851 --> 00:20:53.854 
我們都曾有過這樣的經驗
把手機從口袋裏拿出來

00:20:54.054 --> 00:20:55.088 
按下主屏幕按鈕

00:20:56.123 --> 00:20:58.225 
輕輕點擊想要運行的應用

00:20:58.525 --> 00:21:00.327 
點擊 點擊 再點擊

00:21:00.394 --> 00:21:02.529 
不斷點擊 因爲它停止響應了

00:21:03.197 --> 00:21:05.566 
當這種情況發生時 非常令人沮喪

00:21:05.632 --> 00:21:06.867 
我想把這個應用刪了

00:21:08.602 --> 00:21:10.737 
我叫Louis Gerbarg
研究Dyld

00:21:11.071 --> 00:21:13.740 
今天 我們講討論如何讓應用立即啓動

00:21:13.807 --> 00:21:15.475 
可以讓用戶滿意

00:21:23.550 --> 00:21:25.219 
首先 我們來討論

00:21:25.285 --> 00:21:27.221 
在這部分演講中 要涉及的內容

00:21:29.022 --> 00:21:32.292 
我們將會討論啓動速度要多快

00:21:32.359 --> 00:21:34.695 
用戶體驗才足夠良好

00:21:37.097 --> 00:21:40.234 
如何測量啓動時間 因爲會很難測量

00:21:40.601 --> 00:21:43.003 
標準的測量應用的方法

00:21:43.070 --> 00:21:44.438 
在代碼運行前無法使用

00:21:45.873 --> 00:21:49.543 
我們將一起看一張列表
代碼的常見原因...

00:21:49.710 --> 00:21:51.845 
抱歉 我們將一起看一張列表

00:21:53.347 --> 00:21:55.649 
表上列有應用啓動慢的常見原因

00:21:56.617 --> 00:22:00.721 
最後 我們將討論一種
解決所有緩慢問題的方法

00:22:02.222 --> 00:22:04.258 
我將先劇透一部分演講後面的內容

00:22:07.060 --> 00:22:08.328 
少做點事

00:22:09.730 --> 00:22:12.866 
我不是說應用應該減少功能

00:22:13.433 --> 00:22:16.637 
我是指你的應用在運行前應該減少操作

00:22:16.703 --> 00:22:20.841 
我們想讓你搞清楚
如何推遲一些啓動行爲

00:22:20.941 --> 00:22:23.977 
從而只在啓動前一點點時間進行初始化

00:22:26.246 --> 00:22:29.216 
讓我們討論目標 想要多快啓動

00:22:29.550 --> 00:22:33.654 
不同平臺上的啓動時間也有所不同

00:22:34.054 --> 00:22:39.159 
但是 一個好的經驗法則是

00:22:39.793 --> 00:22:42.329 
400毫秒是一個不錯的啓動時間

00:22:43.397 --> 00:22:46.600 
原因在於

00:22:46.767 --> 00:22:50.204 
在手機上有啓動動畫顯示
給用戶一種持續感

00:22:50.270 --> 00:22:53.106 
在主屏幕和應用之間

00:22:53.173 --> 00:22:54.508 
當你看着它在運行時

00:22:54.842 --> 00:22:58.078 
這些動畫佔用時間 並且動畫

00:22:59.112 --> 00:23:01.582 
會給你一個機會隱藏啓動時間

00:23:02.182 --> 00:23:03.717 
顯然 根據情況會有所不同

00:23:03.784 --> 00:23:06.420 
應用擴展程序也是應用啓動的一部分

00:23:06.486 --> 00:23:08.155 
它們啓動的時間不同

00:23:08.522 --> 00:23:10.524 
手機 電視和手錶是不同的設備

00:23:10.591 --> 00:23:12.526 
但是400毫秒是一個好目標

00:23:14.261 --> 00:23:16.430 
啓動時間永遠不要超過20秒

00:23:16.496 --> 00:23:19.700 
如果超過20秒 OS會終止應用

00:23:19.766 --> 00:23:21.435 
以爲它進入了死循環

00:23:21.502 --> 00:23:22.436 
我們都曾有過這樣的經驗

00:23:22.503 --> 00:23:24.338 
點擊一個應用 回到了主屏幕

00:23:24.404 --> 00:23:26.473 
它不響應 就這麼消失了

00:23:26.874 --> 00:23:28.475 
這就是它被終止了

00:23:30.043 --> 00:23:34.715 
最後 在最慢的支持設備上進行測試
這很重要

00:23:34.781 --> 00:23:36.850 
這些計時器都是常量值

00:23:36.917 --> 00:23:39.520 
在我們平臺支持的所有設備上

00:23:39.853 --> 00:23:43.123 
如果在iPhone 6S上
你達到400毫秒

00:23:43.190 --> 00:23:47.194 
現在測試的結果 也許剛好達到

00:23:47.261 --> 00:23:49.530 
很有可能在iPhone 5上達不到

00:23:51.532 --> 00:23:54.334 
我們回憶一下Nick的演講中提到的

00:23:54.968 --> 00:23:56.937 
啓動時需做什麼
要解析圖像映射圖像

00:23:57.004 --> 00:23:58.172 
重設基址圖像
綁定圖像

00:23:58.238 --> 00:24:00.474 
啓動圖像初始化器 調用主函數

00:24:00.874 --> 00:24:04.111 
如果聽上去很多操作 沒錯
我說說就覺得很累

00:24:05.712 --> 00:24:06.813 
而再之後

00:24:07.481 --> 00:24:11.752 
還必須調用UIApplicationMain()
在ObjC應用裏可找到這個函數

00:24:11.818 --> 00:24:13.854 
或在Swift語言寫的應用裏
進行隱式處理

00:24:14.087 --> 00:24:15.489 
還有一些操作

00:24:15.556 --> 00:24:18.892 
包括運行框架初始化器

00:24:18.959 --> 00:24:20.194 
以及加載nibs

00:24:20.928 --> 00:24:23.997 
最終 在應用委託裏收到回調

00:24:24.164 --> 00:24:26.066 
我之所以提最後這兩個操作
是因爲它們都計算在

00:24:26.133 --> 00:24:28.602 
我之前說的那400毫秒的時間裏

00:24:29.102 --> 00:24:31.071 
但本次演講中我們不討論它們

00:24:31.505 --> 00:24:33.440 
如果你想更好地瞭解它們

00:24:33.507 --> 00:24:36.977 
在2012年有一個演講
iOS應用性能響應

00:24:37.277 --> 00:24:39.446 
我強力推薦你們找出來看看

00:24:40.981 --> 00:24:43.217 
但是現在我們就不再提了

00:24:44.151 --> 00:24:46.486 
我們繼續

00:24:46.720 --> 00:24:49.523 
還有一點 熱啓動和冷啓動

00:24:49.990 --> 00:24:53.260 
啓動應用時 分熱啓動和冷啓動

00:24:53.493 --> 00:24:54.628 
熱啓動是指

00:24:55.162 --> 00:24:57.998 
啓動時應用已經在內存裏

00:24:58.298 --> 00:25:00.801 
或者因爲已經啓動過 之前退出了

00:25:01.268 --> 00:25:03.837 
但還在內核的磁盤緩存裏

00:25:04.671 --> 00:25:06.406 
或者因爲你剛把它複製過去

00:25:07.307 --> 00:25:10.477 
冷啓動是指啓動時應用不在磁盤緩存裏

00:25:11.712 --> 00:25:15.415 
測量冷啓動時間通常更爲重要

00:25:16.683 --> 00:25:18.318 
冷啓動時間更爲重要的原因是

00:25:18.385 --> 00:25:23.123 
當用戶重啓手機後啓動應用

00:25:23.190 --> 00:25:24.458 
或很長時間後啓動應用

00:25:24.525 --> 00:25:26.159 
這時非常需要一個快速啓動

00:25:27.261 --> 00:25:31.031 
爲了測量冷啓動時間
必須在每次測量之間重啓設備

00:25:32.199 --> 00:25:36.103 
說了這麼多
如果你正致力於加快熱啓動時間

00:25:36.170 --> 00:25:37.704 
冷啓動時間應該也會隨之加快

00:25:37.771 --> 00:25:40.274 
你可以通過快速開發週期加快熱啓動

00:25:40.374 --> 00:25:43.844 
但是請時不時地測試一下冷啓動

00:25:47.981 --> 00:25:52.019 
在主函數啓動之前該如何測量時間？

00:25:52.152 --> 00:25:55.689 
dyld裏有內置的測量系統

00:25:56.089 --> 00:25:58.792 
可以通過設置環境變量訪問

00:25:59.393 --> 00:26:01.128 
DYLD_PRINT_STATISTICS

00:26:02.329 --> 00:26:04.932 
安裝OSes時候就可用了

00:26:05.065 --> 00:26:08.202 
它打印了很多內部調試信息

00:26:08.268 --> 00:26:09.469 
並沒有什麼用

00:26:09.536 --> 00:26:12.172 
它缺少了某些你可能想知道的信息

00:26:13.640 --> 00:26:15.209 
今天我們就來改進

00:26:16.877 --> 00:26:19.813 
在新的OS裏進步顯著

00:26:24.218 --> 00:26:27.754 
它會爲你提供更爲相關的信息

00:26:27.821 --> 00:26:30.958 
應該會提供可操作的方法
加快啓動時間

00:26:32.059 --> 00:26:33.794 
將會在seed 2可用

00:26:35.963 --> 00:26:40.033 
對此我還想講一點

00:26:40.501 --> 00:26:44.905 
加載每一個dylib
調試程序都必須暫停啓動

00:26:44.972 --> 00:26:47.474 
才能解析應用的符號

00:26:47.741 --> 00:26:49.009 
加載斷點

00:26:49.209 --> 00:26:51.745 
通過USB線 將非常費時

00:26:52.813 --> 00:26:55.949 
但是dyld清楚這一點
它把調試時間

00:26:56.016 --> 00:26:57.351 
從註冊時間裏減出去

00:26:57.417 --> 00:26:59.052 
所以不用爲此擔心

00:26:59.152 --> 00:27:02.289 
但是你會注意到它
因爲dyld會顯示

00:27:02.356 --> 00:27:04.658 
比你從牆上鐘錶中所觀察到
的數字精細得多

00:27:04.725 --> 00:27:06.827 
這是預期的和能夠接受的

00:27:07.027 --> 00:27:09.096 
如果你看到了那個數字 一切都是對的

00:27:09.162 --> 00:27:10.430 
我只想讓你們記下這一點

00:27:12.533 --> 00:27:14.868 
我們繼續

00:27:17.404 --> 00:27:19.473 
在Xcode裏設置環境變量

00:27:20.774 --> 00:27:24.244 
只需打開方案編輯器 如此填寫

00:27:24.811 --> 00:27:27.347 
完成後
會有一個新的控制檯日誌輸出

00:27:27.648 --> 00:27:29.183 
控制檯輸出被記錄

00:27:30.450 --> 00:27:31.818 
看上去是什麼樣？

00:27:32.653 --> 00:27:34.288 
這就是輸出看上去的樣子

00:27:34.354 --> 00:27:36.924 
底部的時間條代表它不同的部分

00:27:37.357 --> 00:27:38.659 
再添加一個內容

00:27:39.560 --> 00:27:42.296 
爲那400毫秒的目標添加一個指示器

00:27:42.696 --> 00:27:44.998 
在這個應用上並沒有達到

00:27:46.567 --> 00:27:50.637 
如果看順序 這就是基本步驟的順序

00:27:50.704 --> 00:27:52.372 
如Nick講的
啓動應用的順序

00:27:52.439 --> 00:27:53.941 
我們按照順序來看

00:27:56.743 --> 00:27:57.911 
加載dylib

00:27:58.779 --> 00:28:00.581 
關於加載dylib

00:28:00.647 --> 00:28:04.418 
還有看到的速度緩慢 需特別瞭解的是
嵌入式dylib 會非常昂貴

00:28:04.484 --> 00:28:07.721 
所以Nick說 平均每個應用
包含100到400個dylib

00:28:08.488 --> 00:28:11.158 
但是OS dylibs很快
因爲構建OS時

00:28:11.425 --> 00:28:14.528 
我們預計算了大量dylib數據

00:28:15.062 --> 00:28:18.332 
但是我們開發OS時
做不到每個應用裏的每個dylib

00:28:18.432 --> 00:28:20.767 
我們無法預計算
你要嵌入應用的dylib

00:28:20.834 --> 00:28:25.472 
所以加載時
必須要經過一個慢得多的過程

00:28:27.341 --> 00:28:31.578 
其解決方案是 少用dylib

00:28:31.879 --> 00:28:33.580 
而這將非常困難

00:28:33.981 --> 00:28:35.582 
不是說完全不能用

00:28:36.083 --> 00:28:40.020 
但是 有很多方法
可以合併已有dylib

00:28:41.522 --> 00:28:46.026 
可以使用靜態存檔
把dylib用這種方法鏈接到應用

00:28:47.761 --> 00:28:50.898 
還可以使用延遲加載
也就是使用dlopen()函數

00:28:51.231 --> 00:28:56.236 
dlopen()會帶來細微的
性能和正確性的問題

00:28:56.937 --> 00:28:59.606 
實際之後會帶來更多的工作量
但現在被延遲了

00:28:59.673 --> 00:29:01.842 
所以 這是個可行的選項

00:29:01.909 --> 00:29:03.577 
但是必須要仔細思考清楚

00:29:03.644 --> 00:29:06.880 
如果可能的話 我會反對這麼做

00:29:07.581 --> 00:29:12.085 
這裏有一個應用 有26個dylib

00:29:14.655 --> 00:29:17.624 
加載它們需要240毫秒

00:29:18.959 --> 00:29:22.229 
如果我把這些dylib合併成
兩個dylib

00:29:22.863 --> 00:29:25.966 
那隻需要20毫秒就可以加載

00:29:26.300 --> 00:29:28.969 
所以這些dylib都在
還可以使用它們

00:29:30.170 --> 00:29:32.406 
在應用和擴展程序間共享功能

00:29:33.373 --> 00:29:36.210 
但是 限制dylib數量將非常有用

00:29:36.276 --> 00:29:38.712 
我理解這是一個權衡

00:29:38.779 --> 00:29:40.414 
在開發舒適度

00:29:40.480 --> 00:29:42.716 
和麪向用戶的啓動時間
這兩者中做選擇

00:29:42.816 --> 00:29:45.152 
因爲dylib越多
你就可以越早開始生成

00:29:45.219 --> 00:29:47.588 
和重鏈接應用 開發週期就會越短

00:29:47.855 --> 00:29:50.224 
所以理所當然應該用它們

00:29:50.490 --> 00:29:52.960 
但是試試用有限的數量
這個目標不錯

00:29:53.026 --> 00:29:55.896 
我會大概建議 用半打應該不錯

00:29:57.865 --> 00:30:00.367 
現在我們修復好了dylib數目

00:30:00.434 --> 00:30:03.370 
繼續看看下一個速度緩慢的地方

00:30:03.637 --> 00:30:07.074 
綁定和重設基址要350毫秒的時間

00:30:07.474 --> 00:30:08.742 
如Nick所說的

00:30:10.711 --> 00:30:13.180 
重設基址由於I/O會更慢一些

00:30:13.247 --> 00:30:15.148 
而綁定會計算上昂貴

00:30:15.215 --> 00:30:16.583 
但它已經完成I/O

00:30:16.683 --> 00:30:19.186 
所以I/O是爲了它們
它們交加在一起

00:30:19.253 --> 00:30:20.587 
時間也交加在一起

00:30:22.389 --> 00:30:24.458 
如果我們深入看一下

00:30:25.893 --> 00:30:28.195 
時間都耗在修復DATA段裏的指針

00:30:28.395 --> 00:30:32.199 
所以我們必須修復少一些指針

00:30:32.699 --> 00:30:34.902 
Nick介紹了一個可以運行的工具

00:30:34.968 --> 00:30:38.739 
可以看到在DATA分區
修復指針的信息 dyldinfo

00:30:40.474 --> 00:30:42.976 
還能顯示正在哪些段和分區操作

00:30:43.043 --> 00:30:44.878 
你會很清楚地瞭解到在修復什麼

00:30:44.945 --> 00:30:49.616 
比如 如果看到一個符號
在ObjC分區ObjC類

00:30:50.517 --> 00:30:53.420 
很可能你有很多ObjC類

00:30:54.388 --> 00:30:58.225 
你可以做的一件事是 減少

00:30:58.292 --> 00:31:01.128 
ObjC類對象和ivars的數量

00:31:03.163 --> 00:31:06.400 
有很多編碼樣式都鼓勵很小的類

00:31:06.466 --> 00:31:08.202 
只有一個或兩個函數的

00:31:09.269 --> 00:31:15.509 
這些特殊的模式
可能會導致速度逐漸變慢

00:31:15.576 --> 00:31:18.612 
當你越加越多時 更要格外小心

00:31:18.679 --> 00:31:22.082 
有100個或者1000個
類不成問題

00:31:22.149 --> 00:31:25.752 
但我們見過有的應用有
5000 1萬 1萬5 2萬個類

00:31:26.119 --> 00:31:28.989 
這樣將會增加700或800毫秒

00:31:29.056 --> 00:31:31.058 
的啓動時間
因爲內核要把它們讀入頁面

00:31:33.193 --> 00:31:34.061 
還可以做一件事

00:31:34.127 --> 00:31:37.097 
可以試試減少使用C++虛擬函數

00:31:37.397 --> 00:31:40.033 
虛擬函數新建 我們稱作 V表格

00:31:40.634 --> 00:31:42.903 
和ObjC元數據相同

00:31:42.970 --> 00:31:46.173 
因爲它們都新建結構

00:31:46.240 --> 00:31:48.308 
在必須要被修復的DATA分區

00:31:48.609 --> 00:31:52.813 
它們比ObjC元數據小

00:31:52.880 --> 00:31:55.115 
但它們對於某些應用來說 作用顯著

00:31:56.717 --> 00:32:00.420 
還可使用Swift structs
Swift通常用的數據要少一些

00:32:00.487 --> 00:32:02.756 
帶有指針做相關修復

00:32:03.624 --> 00:32:07.528 
並且 Swift更爲內聯

00:32:07.594 --> 00:32:09.596 
可以更好的使用codegen
減少消耗

00:32:09.663 --> 00:32:13.901 
所以 轉爲Swift語言
也是一個好方法

00:32:14.801 --> 00:32:15.903 
還有一點

00:32:16.403 --> 00:32:18.105 
要小心機器生成的代碼

00:32:18.172 --> 00:32:23.143 
曾經有過這樣的例子
你可能描述某個結構

00:32:23.210 --> 00:32:26.780 
用DSL或一些自定義語言

00:32:26.847 --> 00:32:29.950 
然後有一個程序從中生成其他代碼

00:32:30.484 --> 00:32:33.587 
而如果這些程序中有很多指針

00:32:33.787 --> 00:32:36.223 
它們將變得非常昂貴 因爲生成代碼時

00:32:36.290 --> 00:32:37.624 
會生成非常非常大的結構

00:32:37.691 --> 00:32:41.828 
我們看過這樣的情況
生成了兆量級的數據

00:32:42.529 --> 00:32:44.531 
但好處是 比較容易進行控制

00:32:44.598 --> 00:32:46.233 
因爲你只需改變代碼生成器

00:32:46.300 --> 00:32:50.370 
不使用指針而用別的
比如偏移基址 結構

00:32:50.704 --> 00:32:53.407 
將收益良多 來看看本例中

00:32:53.774 --> 00:32:56.677 
加載時間怎麼樣了

00:32:57.744 --> 00:33:01.181 
我至少有1萬個類 實際上有2萬個

00:33:01.615 --> 00:33:03.083 
太多了都無法一次顯示完整

00:33:04.218 --> 00:33:06.286 
如果減少到1萬個類

00:33:06.620 --> 00:33:08.121 
啓動時間也減少了

00:33:08.255 --> 00:33:12.159 
這部分的啓動時間
從350毫秒減少到20毫秒

00:33:13.760 --> 00:33:19.733 
現在 除了初始化器

00:33:19.800 --> 00:33:22.569 
其他都在400毫秒以內 做得很好

00:33:25.472 --> 00:33:27.407 
關於設置ObjC

00:33:27.808 --> 00:33:29.343 
Nick說過所有它做的工作

00:33:29.409 --> 00:33:34.648 
它要註冊類 要處理非脆弱ivar

00:33:34.715 --> 00:33:37.918 
還要註冊目錄 還要讓選擇器變成唯一

00:33:38.685 --> 00:33:40.087 
我不想在此處多花時間

00:33:40.153 --> 00:33:41.488 
原因在於

00:33:42.222 --> 00:33:43.657 
這些問題我們都已經解決

00:33:44.124 --> 00:33:48.128 
通過之前對重設基址
數據和綁定的修復

00:33:48.462 --> 00:33:51.331 
那裏所做的所有減少
和你想在這裏做的完全相同

00:33:51.565 --> 00:33:53.300 
我們這裏就坐享其成

00:33:53.367 --> 00:33:54.968 
很短的時間 8毫秒

00:33:55.068 --> 00:33:57.504 
但我們並沒有特別對它進行操作

00:33:59.406 --> 00:34:02.843 
最後 來看一下初始化器

00:34:02.976 --> 00:34:04.845 
消耗時間長達10秒鐘

00:34:05.712 --> 00:34:08.415 
這裏我將講得比Nick更深入一些

00:34:08.581 --> 00:34:10.350 
有兩種類型的初始化器

00:34:11.885 --> 00:34:14.621 
顯式初始化器 比如+load

00:34:14.688 --> 00:34:17.456 
Nick說我們建議用
+initialize取代它

00:34:17.658 --> 00:34:21.661 
將導致ObjC在運行時初始化代碼

00:34:21.929 --> 00:34:25.966 
當類被實例化時 而不是文件加載之後

00:34:27.967 --> 00:34:31.804 
或者在C/C++裏
函數可以帶有一個屬性

00:34:32.572 --> 00:34:36.677 
可以導致函數像初始化器一樣生成代碼

00:34:36.877 --> 00:34:40.880 
這是顯式初始化器

00:34:40.947 --> 00:34:43.350 
我們寧願用調用點初始化器取代

00:34:43.550 --> 00:34:46.453 
要調用它可以用
dispatch_once()函數

00:34:47.987 --> 00:34:50.958 
或者跨平臺代碼裏
pthread_once()

00:34:51.592 --> 00:34:54.328 
若是C++ std::once()

00:34:54.728 --> 00:34:57.264 
所有這些函數基本上都有相同的功能

00:34:57.331 --> 00:34:59.566 
這些函數的代碼

00:34:59.633 --> 00:35:01.869 
只會在第一次點擊時運行 僅此一次

00:35:02.035 --> 00:35:04.438 
dispatch_once
在系統裏很優秀

00:35:04.605 --> 00:35:05.906 
第一次執行之後

00:35:05.973 --> 00:35:08.642 
幾乎等同於無操作 直接跳過

00:35:08.809 --> 00:35:12.946 
所以我強烈建議
不要使用顯式初始化器

00:35:14.081 --> 00:35:16.049 
接下來是隱式初始化器

00:35:16.116 --> 00:35:18.051 
如Nick所描述的那樣
隱式初始化器

00:35:18.118 --> 00:35:21.522 
大部分來自C++的全局變量
帶有非默認初始化器…

00:35:21.588 --> 00:35:23.056 
非默認構造函數

00:35:24.525 --> 00:35:26.994 
你可以選擇用之前提到的

00:35:27.160 --> 00:35:30.264 
調用點初始化器取代它

00:35:31.031 --> 00:35:32.766 
當然有很多地方可以把全局

00:35:32.833 --> 00:35:37.571 
換成非全局結構或指針
指向想要初始化的對象

00:35:39.106 --> 00:35:43.477 
還有一個選項 你沒有非默認初始化器

00:35:43.544 --> 00:35:46.813 
在C++裏
初始化器調用POD普通純式數據

00:35:47.548 --> 00:35:49.716 
如果對象只是普通純式數據

00:35:49.950 --> 00:35:52.119 
靜態鏈接器

00:35:52.186 --> 00:35:55.389 
將會爲DATA分區預計算所有數據

00:35:55.455 --> 00:35:56.924 
只把數據放在那裏

00:35:56.990 --> 00:35:58.992 
不一定要運行 不一定要修復

00:36:01.361 --> 00:36:02.429 
最後一點

00:36:04.298 --> 00:36:07.835 
很難找到它們 因爲它們是隱性的

00:36:08.068 --> 00:36:11.238 
但是編譯器會收到警告
——Wglobal-constructors

00:36:11.305 --> 00:36:12.439 
如果這麼做 會有警告

00:36:12.506 --> 00:36:13.540 
只要產生其中一個

00:36:13.607 --> 00:36:16.743 
所以把它添加到編譯器用的
標誌裏是個好方法

00:36:18.412 --> 00:36:20.380 
還有一個選項
即用Swift重新編寫

00:36:22.216 --> 00:36:23.350 
理由是

00:36:23.884 --> 00:36:26.053 
Swift有全局變量
並且會被初始化

00:36:26.119 --> 00:36:28.222 
它們確保在使用前被初始化

00:36:28.422 --> 00:36:31.992 
但是其方法不是用初始化器

00:36:32.226 --> 00:36:34.294 
在後臺
使用一次dispatch_once()

00:36:34.361 --> 00:36:36.129 
使用了一種調用點初始化器

00:36:36.563 --> 00:36:39.566 
所以轉爲Swift語言
將會做到這一點

00:36:39.633 --> 00:36:41.502 
所以這個選項我強烈建議

00:36:42.903 --> 00:36:43.737 
最後

00:36:44.204 --> 00:36:46.406 
在初始化器裏
請不要調用dlopen()

00:36:46.773 --> 00:36:49.443 
它將帶來巨大的性能問題 原因很多

00:36:49.743 --> 00:36:53.514 
dyld在運行時 是在應用啓動之前

00:36:53.847 --> 00:36:55.782 
我們可以做一下諸如關閉鎖定的操作

00:36:55.849 --> 00:36:56.950 
因爲是單線程

00:36:57.117 --> 00:37:01.255 
當dlopen()出現
在那種情況下

00:37:01.522 --> 00:37:03.624 
初始化器的運行發生了改變

00:37:03.690 --> 00:37:05.526 
可能會有多線程 必須要打開鎖定

00:37:05.592 --> 00:37:07.561 
將會帶來巨大的性能下降

00:37:07.928 --> 00:37:11.098 
還會帶來細微的死鎖和未定義行爲

00:37:13.467 --> 00:37:16.336 
還有 不要在初始化器上開始線程

00:37:17.004 --> 00:37:18.372 
也是出於同樣的理由

00:37:18.472 --> 00:37:20.073 
若必要
可以設立一個mutex

00:37:20.140 --> 00:37:22.843 
優先mutex甚至會有

00:37:23.076 --> 00:37:26.246 
預定義的靜態值
你可以用run no code設定

00:37:26.580 --> 00:37:28.549 
但是實際上在初始化器裏開始線程

00:37:28.615 --> 00:37:31.251 
會帶來潛在巨大的性能和正確性問題

00:37:32.786 --> 00:37:33.820 
這裏有一些代碼

00:37:33.887 --> 00:37:36.557 
有一個C++類
有一個非默認初始化器

00:37:36.623 --> 00:37:38.525 
網絡連接出現問題

00:37:38.725 --> 00:37:40.327 
請稍後再試

00:37:41.328 --> 00:37:42.429 
謝謝你 Siri

00:37:42.930 --> 00:37:46.633 
我有一個非默認初始化器

00:37:47.634 --> 00:37:52.439 
調試時還有 可能我註釋掉了

00:37:52.506 --> 00:37:55.309 
好 已經縮短到50毫秒

00:37:55.742 --> 00:37:56.577 
總共

00:37:57.211 --> 00:37:59.813 
有足夠的時間可以初始化nibs

00:37:59.880 --> 00:38:01.748 
還有其他的操作 狀態不錯

00:38:03.350 --> 00:38:04.718 
我們已經瀏覽完畢

00:38:06.720 --> 00:38:10.991 
我們一起來討論 我們應該瞭解什麼

00:38:11.225 --> 00:38:13.060 
如果啓動時間冗長

00:38:13.393 --> 00:38:16.597 
首先用DYLD_PRINT_STATISTICS測量時間

00:38:16.663 --> 00:38:19.032 
添加到檢測性能的測試工具裏

00:38:19.099 --> 00:38:22.436 
所以你可以追蹤應用是如何超時的

00:38:22.503 --> 00:38:24.571 
這樣可投入編寫
而不會在幾個月後發現

00:38:24.638 --> 00:38:25.706 
調試出現問題

00:38:29.076 --> 00:38:31.678 
爲了縮短啓動時間 可以採用的方法有

00:38:32.646 --> 00:38:34.448 
減少已有dylib的數量

00:38:35.415 --> 00:38:38.418 
減少已有ObjC類的數量

00:38:38.852 --> 00:38:40.821 
以及刪除靜態初始化器

00:38:43.790 --> 00:38:45.993 
還有可用更多Swift語言加快速度

00:38:46.059 --> 00:38:47.828 
因爲Swift真的很強大

00:38:48.762 --> 00:38:50.731 
最後 不鼓勵使用dlopen()

00:38:50.797 --> 00:38:54.234 
它會帶來細微的性能問題 很難診斷

00:38:55.102 --> 00:38:57.804 
可以通過屏幕上的URL獲取更多信息

00:38:59.606 --> 00:39:01.508 
本週還將有很多相關演講

00:39:01.575 --> 00:39:05.179 
再說一次 2012年有一個
關於應用性能的會話

00:39:05.245 --> 00:39:07.414 
涉及到應用啓動的另一部分

00:39:07.481 --> 00:39:09.449 
如果感興趣 強力推薦觀看該演講

00:39:09.850 --> 00:39:11.752 
感謝各位的到來
希望你們這周過得愉快