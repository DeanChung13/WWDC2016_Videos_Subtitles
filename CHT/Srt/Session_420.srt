00:00:19.386 --> 00:00:22.389
優化應用的網頁內容

00:00:22.456 --> 00:00:23.290
大家好

00:00:27.427 --> 00:00:29.763
歡迎來到“優化應用的網頁內容”

00:00:29.830 --> 00:00:31.398
我是Jonathan Davis

00:00:31.465 --> 00:00:34.168
網絡技術的推廣人
負責Safari和WebKit

00:00:34.902 --> 00:00:37.271
現在我要先說明一些事情

00:00:38.172 --> 00:00:40.707
很多人說我長得像
Edward Snowden

00:00:40.774 --> 00:00:42.309
但我向你保證 我不是他

00:00:43.210 --> 00:00:46.947
但這麼多衛星在頭頂盤旋
大概都是來抓我們的

00:00:47.915 --> 00:00:50.751
除此之外 我很激動地要展示些新東西

00:00:50.817 --> 00:00:53.787
它們可以幫助你
提升應用網頁內容的性能

00:00:54.288 --> 00:00:56.323
我們一直都知道

00:00:56.390 --> 00:00:59.326
性能是提供最佳用戶體驗的關鍵

00:00:59.393 --> 00:01:04.431
若你是個應用開發者並在應用裏用了
WebViews和JSContext

00:01:05.364 --> 00:01:07.901
而且你很關心性能
那你就來對地方了

00:01:08.569 --> 00:01:09.970
說到性能

00:01:10.304 --> 00:01:14.074
在當今時代裏
性能其實就是指電池壽命

00:01:14.141 --> 00:01:17.411
我認爲電池壽命是最終的有限資源

00:01:17.845 --> 00:01:20.280
它帶來很不同的結果
如果你能撥出最後一通電話

00:01:20.347 --> 00:01:23.717
或者發出最後一份重要的文件
在電池耗光之前

00:01:24.218 --> 00:01:26.420
性能對用戶來說
事關重大

00:01:26.753 --> 00:01:29.389
他們所選擇的應用
不會讓設備變慢

00:01:29.456 --> 00:01:30.724
而且耗電量低

00:01:31.692 --> 00:01:35.596
我們的經驗就是
根據用戶的反饋和各自的體會

00:01:35.662 --> 00:01:38.966
性能很重要
因爲電池壽命事關重大

00:01:40.400 --> 00:01:44.104
所以今年我們致力於
提供更好的工具

00:01:44.171 --> 00:01:46.640
來找到和修復
網頁內容的性能問題

00:01:47.207 --> 00:01:49.510
現在我們爲應用提供了工具
比如Swift

00:01:49.576 --> 00:01:51.778
還有Objective-C代碼
比如Instruments

00:01:52.312 --> 00:01:56.049
我們還提供了網絡檢查器
幫助網頁開發者創建網頁和網站

00:01:57.017 --> 00:01:59.286
但不要覺得
因爲你選擇了

00:01:59.353 --> 00:02:02.422
在應用中用網絡技術
就沒有其他工具可用了

00:02:02.489 --> 00:02:05.259
實際上
我今天展示給你的所有工具

00:02:05.325 --> 00:02:07.427
就是開發給人們
既能幫助他們建設網站

00:02:07.494 --> 00:02:10.430
也能讓他們在應用裏
用網絡技術

00:02:11.265 --> 00:02:12.566
那麼我首先要
向你展示

00:02:12.633 --> 00:02:15.936
如何把網絡檢查器連接到
JSContext的WebViews

00:02:16.003 --> 00:02:18.505
這樣在你需要它的時候
它就會立刻出現

00:02:19.540 --> 00:02:21.375
之後你會瞭解
一些新的功能

00:02:21.441 --> 00:02:25.479
它們能讓你瞭解JavaScript代碼
如何分配時間

00:02:25.546 --> 00:02:29.650
以及這些新功能
如何幫你迅速找到性能上的問題

00:02:30.651 --> 00:02:34.955
如果你想要看到
網絡內容的內存使用情況

00:02:35.022 --> 00:02:38.392
我們也給網絡檢查器增添了新的時間線
我都已等不及想展示了

00:02:38.592 --> 00:02:41.562
它們會幫你節省很多時間
來找到內存過大的問題

00:02:41.995 --> 00:02:43.797
準備好了？
那就開始吧

00:02:45.032 --> 00:02:46.333
第一件
我們要做的事

00:02:46.400 --> 00:02:48.769
是把網絡檢查器
連接到應用裏

00:02:49.469 --> 00:02:52.840
在應用裏使用網絡技術
有很多原因

00:02:53.574 --> 00:02:56.276
如JS context裏的
一些JavaScript模塊

00:02:56.343 --> 00:02:59.980
可以讓你輕鬆交換邏輯
並無編譯地添加新的模塊

00:03:00.747 --> 00:03:05.419
可能有些人正在tvOS應用裏
使用TVML的 JSContext

00:03:06.053 --> 00:03:09.690
另外一個使用網絡技術的原因
就是你要顯示的網頁內容

00:03:10.157 --> 00:03:12.059
比如第三方網站的
一個網頁

00:03:12.459 --> 00:03:13.727
這個網站
你不能控制

00:03:14.027 --> 00:03:16.663
可能就要用到Safari視圖控制器

00:03:16.730 --> 00:03:18.398
如果不是
你也許可以去聽聽

00:03:18.465 --> 00:03:21.602
去年的演講
“介紹Safari視圖控制器”

00:03:22.903 --> 00:03:26.106
但如果你顯示的內容
是你自己的或者你可以控制的

00:03:26.173 --> 00:03:31.912
或是可自定義的HTML CSS
或JavaScript編寫的內容

00:03:31.979 --> 00:03:34.281
或者是
可以提升應用體驗的內容

00:03:34.615 --> 00:03:36.350
WKWebView
是最好的選擇

00:03:36.717 --> 00:03:39.786
它實際上是個矩形
把網頁內容拉入應用

00:03:40.354 --> 00:03:43.690
它引入了iOS 8
和OS 10 Yosemite

00:03:44.858 --> 00:03:47.561
若你還在使用WebView
或者UIWebView

00:03:47.828 --> 00:03:51.164
那你一定要考慮
升級到WKWebView

00:03:51.565 --> 00:03:54.735
事實上 升級到WKWebView
可以讓你利用

00:03:54.801 --> 00:03:58.805
Nitro JavaScript
核心引擎和四級JIT編譯器

00:03:58.872 --> 00:04:00.007
這能大大提升速度

00:04:00.741 --> 00:04:02.743
若想了解更多WKWebView信息

00:04:03.010 --> 00:04:07.314
我推薦2014年的演講
介紹了現代化的WebKit API

00:04:08.282 --> 00:04:11.418
那麼去年我們給WKWebView
添加了很多優秀的功能

00:04:11.485 --> 00:04:16.589
比如 加載文件URL和自定義用戶代理字符串
還有WK網站數據存儲API

00:04:17.858 --> 00:04:22.296
現今有了iOS 10和macOS Sierra
我們改進了3D-touch支持

00:04:23.063 --> 00:04:25.532
現在你的應用就可以執行這些好用的

00:04:25.599 --> 00:04:27.835
Peek和Pop事件
在WKWebView裏

00:04:29.336 --> 00:04:31.438
就像我之前說的
因爲你選了

00:04:31.505 --> 00:04:32.906
在應用裏
應用網絡技術

00:04:33.807 --> 00:04:35.142
並不意味着
你沒有工具可用

00:04:35.209 --> 00:04:37.811
不論哪種情況
你可連接網絡檢查器

00:04:37.878 --> 00:04:40.214
發掘網頁內容
或JavaScript活動情況

00:04:41.081 --> 00:04:44.985
但使用網絡檢查器前
你必須要激活develop菜單

00:04:45.219 --> 00:04:49.156
只要上傳Safari設置
然後找到“高級”標籤

00:04:49.356 --> 00:04:51.558
然後在底部
你會看到這個複選框

00:04:51.625 --> 00:04:53.961
寫着在菜單欄顯示Develop菜單

00:04:54.995 --> 00:04:56.730
那就點擊它

00:04:56.964 --> 00:04:59.766
Develop菜單就會出現在
Safari的菜單欄裏

00:05:01.735 --> 00:05:04.371
爲讓網絡檢查器
連接到iOS設備

00:05:04.438 --> 00:05:06.073
你要開啓一個設置

00:05:06.607 --> 00:05:10.210
在iOS的設置應用裏
點擊Safari

00:05:10.511 --> 00:05:16.016
然後拉到底部 點擊“高級”
然後把檢查器設置打開

00:05:16.884 --> 00:05:18.652
現在你就可以
把設備連到Mac上

00:05:18.719 --> 00:05:20.654
在Safari裏
檢查Develop菜單

00:05:22.356 --> 00:05:24.558
Develop菜單裏
有些很酷炫的東西

00:05:24.625 --> 00:05:26.627
你之前可能
從未注意到過

00:05:26.693 --> 00:05:28.962
就是你能看到設備的列表

00:05:29.029 --> 00:05:32.866
這裏有已連接的iPhone
MacBook Pro和模擬器

00:05:33.500 --> 00:05:36.837
要連接一個設備
並開始使用這些工具

00:05:36.904 --> 00:05:39.206
進行調試
那麼只要選擇Device菜單

00:05:39.473 --> 00:05:43.377
就會收到 當前設備上運行的
WebViews和JSContexts 的列表

00:05:44.411 --> 00:05:46.580
這裏的Mac應用
並沒有使用WebKit

00:05:46.647 --> 00:05:48.015
而用JavaScript

00:05:48.148 --> 00:05:50.651
所以我可以直接連接它
並使用工具

00:05:51.585 --> 00:05:56.190
iOS裏的應用只會出現在
用Xcode創建和運行的時候

00:05:56.924 --> 00:06:00.194
但是說到Mac應用
你還要做一件事

00:06:01.261 --> 00:06:05.299
就是保持應用的完整性
我們不會讓任何人下載你的應用

00:06:05.365 --> 00:06:08.168
並用網絡檢查器
巡查你的應用

00:06:08.669 --> 00:06:10.103
所以你要添加
這個授權

00:06:10.170 --> 00:06:12.272
到應用本地開發的
授權文件裏

00:06:13.307 --> 00:06:15.542
你可能已經有了一個
授權文件

00:06:15.609 --> 00:06:17.477
如果沒有
創建一個也很簡單

00:06:17.544 --> 00:06:20.581
你只要創建新的plist
拓展名爲.entitlements

00:06:20.914 --> 00:06:25.419
並且Xcode的創建設置裏
定義一個代碼簽名的授權傳遞路徑

00:06:26.753 --> 00:06:28.488
這個要在
開發的時候添加

00:06:28.555 --> 00:06:30.791
之後在
運行應用的時候刪除

00:06:31.792 --> 00:06:32.893
一旦有了這個授權

00:06:33.126 --> 00:06:35.395
你的設備和應用就
出現在Develop菜單

00:06:35.462 --> 00:06:36.496
這樣就可以連接了

00:06:36.830 --> 00:06:42.669
輕鬆把網絡檢查器連接到
JSContext和WebViews上了

00:06:44.805 --> 00:06:47.674
我們已正常運行了
網絡檢查器和應用

00:06:48.675 --> 00:06:51.078
該談談網絡檢查器裏
新功能了

00:06:51.144 --> 00:06:53.814
我想首先講講
分析JavaScript代碼

00:06:53.881 --> 00:06:54.715
分析JavaScript

00:06:54.781 --> 00:06:57.584
JavaScript的分析器
已經存在挺長時間了

00:06:57.651 --> 00:06:59.620
今年它變得更好

00:06:59.686 --> 00:07:03.156
更有效率
能幫助你迅速找到

00:07:03.223 --> 00:07:05.392
哪裏調出的JavaScript
成本最高

00:07:05.459 --> 00:07:06.660
原因很簡單

00:07:07.628 --> 00:07:11.965
新的分析器採用了取樣技術
不會影響性能

00:07:12.032 --> 00:07:13.734
比以前好太多

00:07:14.568 --> 00:07:17.504
我們的分析器
在編譯器能用之前的時代

00:07:17.571 --> 00:07:18.739
實際是個翻譯器

00:07:19.206 --> 00:07:23.143
但是現在我們有了
這個強大的四級JIT編譯器

00:07:23.443 --> 00:07:26.947
那麼這個分析器
就真正成爲樣本分析器

00:07:28.048 --> 00:07:31.518
樣本分析器告訴你
代碼把時間都用在哪裏

00:07:31.752 --> 00:07:35.622
幫你解答
哪個代碼佔用的時間最多？

00:07:36.590 --> 00:07:39.059
它在運行程序中的取樣
以每毫秒爲單位

00:07:39.126 --> 00:07:40.594
並且短暫地
停頓執行

00:07:40.661 --> 00:07:43.130
並快照
所有正在運行的代碼

00:07:44.598 --> 00:07:45.966
它還可以取樣

00:07:46.033 --> 00:07:48.936
在代碼運行於
JIT編譯器所有四級的時候

00:07:49.002 --> 00:07:52.039
所以它的取樣速度
跟你代碼的實際速度差不多

00:07:52.873 --> 00:07:56.443
由於斷點處理
會導致代碼去優化

00:07:56.510 --> 00:07:57.978
我們暫時不管它們

00:07:58.545 --> 00:08:02.583
那麼當你分析的時候
你就可以瞭解網頁應用的真實性能

00:08:03.050 --> 00:08:06.854
使用樣本分析器
對性能幾乎沒有損害

00:08:07.120 --> 00:08:10.157
這就意味着
當你分析代碼的時候

00:08:10.657 --> 00:08:13.560
速度高達以前的30倍

00:08:14.361 --> 00:08:17.931
這就讓代碼分析過程
更快也更簡單

00:08:17.998 --> 00:08:20.434
而且收到的數據
也更準確

00:08:21.869 --> 00:08:25.939
這個進步真令人振奮 因爲我們團隊
和網絡檢查器團隊

00:08:26.006 --> 00:08:29.610
能利用它來發現
可以提升速度的地方

00:08:29.676 --> 00:08:31.044
就在網絡檢查器本身

00:08:32.412 --> 00:08:34.515
好了
現在我們有了樣本分析器

00:08:34.581 --> 00:08:37.618
看看如何利用網絡檢查器
幫我們找到問題

00:08:38.519 --> 00:08:41.688
這個內容很多
但是可以簡單的拆分開來

00:08:41.788 --> 00:08:43.991
更方便的是
這都是你已經熟悉的代碼

00:08:44.958 --> 00:08:47.160
當我們說到
分析JavaScript時

00:08:47.227 --> 00:08:50.597
意思是在Events裏
爲JavaScript記錄時間線

00:08:50.664 --> 00:08:52.399
這就是Events視圖

00:08:52.733 --> 00:08:56.270
顯示了一列單獨而且具體的
JavaScript事件

00:08:56.570 --> 00:09:00.073
特別的是
這裏都是D3庫的代碼

00:09:00.140 --> 00:09:02.910
所以它能更方便
調試代碼

00:09:02.976 --> 00:09:05.612
和分析代碼
在你正在使用的庫裏

00:09:06.346 --> 00:09:09.449
而且這裏的每一條
都是代碼運行的事件

00:09:09.716 --> 00:09:13.187
這是代碼進出
JavaScript核心引擎的情況

00:09:14.087 --> 00:09:15.856
包括了
監聽事件的回調

00:09:15.923 --> 00:09:19.193
比如動畫框架的條目
是在請求動畫框架處理器

00:09:20.160 --> 00:09:22.596
腳本評估條目
顯示JavaScript文件

00:09:22.663 --> 00:09:24.331
的上傳和首次評估

00:09:25.265 --> 00:09:27.234
這裏還有一些
時間信息

00:09:27.701 --> 00:09:30.971
告訴你運行的代碼
所花費的時間

00:09:32.039 --> 00:09:34.708
所以如果有哪個
超過了10或15毫秒

00:09:34.775 --> 00:09:36.343
你就快要打破

00:09:36.410 --> 00:09:38.812
60幀每秒的
流暢性能底線

00:09:40.647 --> 00:09:43.217
Events視圖很有用
但是還有另一個視圖

00:09:43.283 --> 00:09:46.119
是我們爲你添加的
叫做Call Trees視圖

00:09:46.553 --> 00:09:49.790
如果你用過其他分析工具
那麼對這個應該很熟悉

00:09:51.225 --> 00:09:54.161
只要點擊這個菜單
然後轉換到Call Trees視圖

00:09:55.429 --> 00:09:59.399
現在顯示了調用堆棧裏
函數的累計運行時間

00:10:00.133 --> 00:10:01.768
這個叫做Top Down視圖

00:10:01.835 --> 00:10:04.137
你可以用它
深入發掘Call Tree

00:10:04.204 --> 00:10:06.707
來找到
耗費大量時間的熱函數

00:10:07.774 --> 00:10:10.177
但我最喜歡的視圖是
Bottom Up視圖

00:10:12.513 --> 00:10:14.448
它能直接讓我找到
最熱的函數

00:10:14.515 --> 00:10:16.650
就是取樣最頻繁的函數

00:10:17.551 --> 00:10:19.319
這裏羅列的
是調出的函數

00:10:19.386 --> 00:10:21.622
按照用時
從大到小分類

00:10:21.688 --> 00:10:26.593
它反轉了Call Tree
讓你能直接對比各個函數的耗時

00:10:27.861 --> 00:10:30.731
你能準確地看到
耗時最多的地方

00:10:32.332 --> 00:10:35.169
你可以展開這一條
並按照路徑返回

00:10:35.235 --> 00:10:36.837
找到耗時最多的函數

00:10:37.471 --> 00:10:41.108
你就能知道這個成本最高的代碼
是何時何地調出的

00:10:42.809 --> 00:10:45.312
那麼關於這部分
有請我的同事

00:10:45.379 --> 00:10:46.980
Brian Burg
上臺爲大家展示

00:10:55.155 --> 00:10:57.858
謝謝你 Jon
樣本分析器很好用

00:10:57.925 --> 00:11:00.494
因爲它可以提取
十分複雜的內容

00:11:00.561 --> 00:11:03.564
並進行分析
讓你看到十分精確的信息

00:11:03.630 --> 00:11:05.132
而且你可以讓它
跑的更快

00:11:05.832 --> 00:11:09.469
爲了給你們展示
我要用我製作的iPad應用

00:11:09.770 --> 00:11:12.139
叫做衛星跟蹤器
在這裏看看

00:11:15.676 --> 00:11:19.680
衛星跟蹤器
會展示給你現在或任何時間

00:11:20.080 --> 00:11:21.615
衛星所在的位置

00:11:21.882 --> 00:11:24.618
你可以選擇
地球上的不同地點

00:11:25.219 --> 00:11:26.787
也可以選擇不同的衛星

00:11:28.222 --> 00:11:29.223
不同的時區

00:11:30.023 --> 00:11:30.858
這很棒吧

00:11:31.725 --> 00:11:33.460
如果你擔心
頭上盤旋的衛星

00:11:33.527 --> 00:11:36.330
要帶個錫紙帽子以防萬一
這個應用就是理想之選

00:11:37.064 --> 00:11:39.633
但是這裏有個小問題

00:11:39.700 --> 00:11:44.071
如果很多衛星
或者很多衛星組件

00:11:44.137 --> 00:11:47.207
像這樣擠爆了
那麼幀率的波動會很大

00:11:47.674 --> 00:11:49.676
這肯定不是
60幀每秒

00:11:49.743 --> 00:11:50.878
它會一直波動

00:11:51.411 --> 00:11:53.981
這樣就可以用
樣本分析器來查找

00:11:54.047 --> 00:11:55.849
發生了什麼
爲什麼這麼慢

00:11:57.751 --> 00:12:03.257
我們要做的就是打開Safari
並進入Develop菜單

00:12:03.957 --> 00:12:06.026
找到這裏的iPad
並連接上

00:12:07.594 --> 00:12:11.098
那麼我要做的第一件事
就是進入Frames視圖

00:12:11.164 --> 00:12:14.001
看看現在的位置
幀率如何

00:12:14.067 --> 00:12:16.069
那麼開始記錄

00:12:17.137 --> 00:12:18.572
我再轉回iPad

00:12:19.373 --> 00:12:20.774
做點什麼

00:12:22.876 --> 00:12:24.244
比如轉動一下

00:12:25.746 --> 00:12:27.514
或者換一個衛星

00:12:29.383 --> 00:12:30.250
換個時區

00:12:30.884 --> 00:12:32.219
好了
現在回去看看

00:12:35.489 --> 00:12:36.723
好的
把這個縮小

00:12:37.424 --> 00:12:40.227
所有的性能
就都顯示在這裏了

00:12:40.294 --> 00:12:44.865
有的時候是60幀每秒
像左邊這些

00:12:45.299 --> 00:12:47.367
在中間
則上下都有

00:12:47.434 --> 00:12:48.802
因爲我們在
更改視圖

00:12:49.136 --> 00:12:51.972
這一些
就太慢了

00:12:52.940 --> 00:12:55.042
我想知道
出了什麼問題

00:12:56.710 --> 00:12:58.879
那麼我就轉到
Events視圖

00:13:00.981 --> 00:13:03.283
點擊JavaScript
和Events時間線

00:13:03.350 --> 00:13:06.019
重點看看
樣本分析器的數據

00:13:07.955 --> 00:13:10.691
就像Jon之前演示的那樣
這裏的Events視圖

00:13:10.757 --> 00:13:12.926
會顯示所有
運行循環裏的內容

00:13:12.993 --> 00:13:16.096
這個例子裏
就是動畫和模擬

00:13:16.163 --> 00:13:18.398
就是我們在
不斷地渲染幀

00:13:18.465 --> 00:13:22.769
這不是很有用
因爲無法找到耗時最多的地方

00:13:23.537 --> 00:13:25.939
那麼我們轉到
Call Trees視圖

00:13:27.574 --> 00:13:30.844
這裏我們看到Top Down
Call Tree

00:13:31.211 --> 00:13:35.849
集合顯示了
所有的渲染幀

00:13:35.916 --> 00:13:37.484
都是最耗時的地方

00:13:38.352 --> 00:13:42.356
展開這個就能看到
D3有一個Timer函數

00:13:42.422 --> 00:13:45.893
它調出一些代碼
畫了一些場景

00:13:46.960 --> 00:13:49.863
這些場景包括
衛星

00:13:49.930 --> 00:13:52.099
和時間等

00:13:52.165 --> 00:13:56.303
這個很棒
能讓我們瞭解代碼在做什麼

00:13:56.670 --> 00:13:59.373
但是如果要想找出
哪個函數最耗費

00:14:00.073 --> 00:14:02.376
最好還是去看
Bottom Up視圖

00:14:04.044 --> 00:14:09.316
這裏我們列出了所有函數
無論誰調用它們

00:14:09.917 --> 00:14:12.686
我們看到這個fillText

00:14:12.753 --> 00:14:15.322
和tangent
是最耗費的兩個

00:14:15.422 --> 00:14:18.559
那爲什麼
會調出tangent呢？

00:14:18.792 --> 00:14:23.630
我們展開這一行
看看調令來源

00:14:23.830 --> 00:14:28.202
就在這裏
是_plotSatellites

00:14:28.435 --> 00:14:33.273
好像正在計算轉換
用來繪製地球

00:14:34.041 --> 00:14:35.876
好的
這些看着都很正常

00:14:36.443 --> 00:14:39.079
也許我該找出數學課本
讓它算得快一點

00:14:40.314 --> 00:14:41.682
現在看看
fillText

00:14:41.748 --> 00:14:45.652
換個畫面
回到這裏的應用

00:14:46.320 --> 00:14:51.458
我們正在當前時間上繪製文本
也在每個數據點上繪製

00:14:52.492 --> 00:14:53.460
這說得通

00:14:53.527 --> 00:14:57.898
但是如果仔細看
我們實際上把這個時間畫了兩次

00:14:58.699 --> 00:15:00.000
這就有點奇怪

00:15:00.767 --> 00:15:03.403
所以我們展開這一行

00:15:04.238 --> 00:15:06.707
就能看到
調令來自哪裏

00:15:07.975 --> 00:15:11.245
這裏我們好像
一次畫了兩個不同的前景

00:15:11.778 --> 00:15:14.114
這大概
不是我們想要的

00:15:15.516 --> 00:15:17.284
那麼來找找
哪兒出了問題

00:15:17.417 --> 00:15:20.120
如果像這樣
畫了兩個前景

00:15:20.220 --> 00:15:23.290
那麼我們的工作量
實際就是所需的兩倍

00:15:24.858 --> 00:15:28.729
爲了讓你的記憶更清晰
記住我們有個平面地圖

00:15:28.795 --> 00:15:31.431
然後有這個地球
它在轉動

00:15:32.833 --> 00:15:36.303
那麼
現在回到代碼

00:15:37.771 --> 00:15:41.942
找一找是什麼
控制着兩個地圖的切換

00:15:42.009 --> 00:15:43.010
估計哪裏弄錯了

00:15:46.513 --> 00:15:49.783
改變地點的時候
我們會讓兩個地球互換

00:15:51.051 --> 00:15:52.252
這是 updateLocation

00:15:52.819 --> 00:15:57.191
好的 因爲已經有一個地圖
就不再需要另一個

00:15:57.291 --> 00:16:00.494
這是有道理的
因爲這裏我們添加了隱藏類

00:16:00.561 --> 00:16:02.863
就爲了不讓它
顯示出來

00:16:04.298 --> 00:16:07.701
這裏在_globeMap
我們定義running值爲真

00:16:07.768 --> 00:16:09.236
在整個運行中

00:16:09.603 --> 00:16:12.506
而且在place中聲明
我們顯示的不是_globeProjection

00:16:12.573 --> 00:16:13.407
這是對的

00:16:13.473 --> 00:16:15.042
當我們顯示
平面地圖

00:16:15.108 --> 00:16:17.144
我們不會顯示地球
它也不會運行

00:16:18.178 --> 00:16:20.280
這個平面地圖
看上去好像

00:16:20.347 --> 00:16:22.382
一直在運行
UI也在運行

00:16:22.516 --> 00:16:26.086
這也挺奇怪的

00:16:26.486 --> 00:16:28.655
那麼我們回到地圖
試着做點兒什麼

00:16:32.192 --> 00:16:34.628
這裏我們選擇
這個數據組

00:16:35.762 --> 00:16:37.431
然後進入Earth

00:16:38.465 --> 00:16:43.237
它的幀率要好於
只做世界地圖

00:16:43.303 --> 00:16:44.505
那麼
這就很有道理

00:16:44.571 --> 00:16:47.574
我想我們在世界地圖活動的時候
畫了兩張地圖

00:16:47.641 --> 00:16:49.443
但是在平面地圖的時候
只畫了一個

00:16:49.510 --> 00:16:53.914
那麼我們就在這裏
改變這個條件

00:16:59.786 --> 00:17:01.288
糟糕
應該反過來

00:17:04.558 --> 00:17:08.996
好的 先停下
看看有沒有修復

00:17:12.598 --> 00:17:14.001
回到iPad

00:17:15.502 --> 00:17:16.737
好的
這看上去很流暢

00:17:16.803 --> 00:17:17.671
來到這裏

00:17:19.006 --> 00:17:19.839
恩 很好

00:17:22.041 --> 00:17:22.910
看上去不錯

00:17:22.976 --> 00:17:25.913
那麼我們再去檢查
時間渲染

00:17:25.979 --> 00:17:29.249
看看是不是
60幀每秒

00:17:30.684 --> 00:17:32.386
那麼
回到Frames視圖

00:17:33.053 --> 00:17:37.024
然後開始記錄
很不錯

00:17:37.090 --> 00:17:40.160
我轉動地球的時候
有點慢

00:17:40.227 --> 00:17:42.496
但穩定度
看上去...

00:17:42.563 --> 00:17:45.299
不錯
絕對在60幀每秒以下

00:17:45.832 --> 00:17:49.736
在這裏有一個條
只要低於它就是好的

00:17:52.940 --> 00:17:56.610
現在衛星跟蹤器
快了很多

00:17:56.677 --> 00:17:58.779
我們就知道
什麼時候帶上帽子

00:17:58.946 --> 00:17:59.780
這很棒

00:18:00.247 --> 00:18:04.017
這就是個簡單的例子
關於如何使用樣本分析器

00:18:04.084 --> 00:18:07.788
來發現最繁忙的內容
並讓它運行的更快

00:18:08.689 --> 00:18:12.893
下面Jon會跟大家講講
內存和分配

00:18:21.802 --> 00:18:22.636
謝謝 Brian

00:18:24.371 --> 00:18:27.074
你看到了
分析很迅速

00:18:27.274 --> 00:18:29.443
它能讓你瞭解
代碼的真實速度

00:18:29.510 --> 00:18:31.311
這樣你就能
獲得十分精確的數據

00:18:31.678 --> 00:18:34.448
再看看JavaScript
和Events時間線

00:18:34.948 --> 00:18:37.918
並用它們找到
緩慢的回調處理器和定時器

00:18:37.985 --> 00:18:40.454
或者在Events視圖裏
緩慢的腳本初始化

00:18:41.822 --> 00:18:44.157
請用新的Call Trees視圖
來瞭解耗時

00:18:44.224 --> 00:18:47.227
因爲它們會沿着
你選擇的時間線堆積起來

00:18:48.228 --> 00:18:50.464
記着Bottom Up
是你的新朋友

00:18:50.531 --> 00:18:54.201
它能幫助你找到
最需要優化的地方

00:18:55.869 --> 00:18:58.071
那麼現在我們已經看過了
新的樣本分析器

00:18:58.138 --> 00:19:00.574
和新的JavaScript
Call Trees視圖

00:19:00.908 --> 00:19:04.611
我很激動能用更好的工具
來優化CPU時間

00:19:04.678 --> 00:19:06.513
這樣就能給用戶
快速的體驗

00:19:06.580 --> 00:19:08.282
並幫他們
節省了電池

00:19:08.782 --> 00:19:10.551
這真的不錯
現在我們繼續

00:19:10.617 --> 00:19:12.219
看看性能的另一方面

00:19:12.586 --> 00:19:14.254
就是了解
內存都去哪兒了

00:19:15.189 --> 00:19:17.858
你肯定想更有效率地使用
網頁內容的內存

00:19:17.925 --> 00:19:19.526
因爲這是有限資源

00:19:19.960 --> 00:19:24.731
有效地使用內存可以
優化網頁內容的比例

00:19:24.798 --> 00:19:26.600
並能處理
大型數據組

00:19:28.335 --> 00:19:32.472
而且內存佔用過多會降低性能
我們並不想這樣

00:19:33.273 --> 00:19:35.175
它也會讓
你的網頁內容崩潰

00:19:35.242 --> 00:19:36.777
這更非我們所願

00:19:37.311 --> 00:19:41.682
好消息是若你運行WKWebView
它會以單獨的進程運行

00:19:41.982 --> 00:19:43.450
不會讓
整個應用崩潰

00:19:43.517 --> 00:19:45.752
但是這仍然不是
一個好的用戶體驗

00:19:46.286 --> 00:19:48.755
爲了幫你解決這些問題
我們添加了兩個新時間線

00:19:48.822 --> 00:19:50.557
給網絡檢查器
和Safari 10

00:19:51.859 --> 00:19:55.295
當啓動新網絡檢查器
新時間線就默認關閉

00:19:55.362 --> 00:19:56.730
所以要打開它們

00:19:56.797 --> 00:19:59.633
你只要點擊Edit
就在時間線上面

00:20:01.134 --> 00:20:03.704
就可以配置
自己想看的時間線

00:20:03.770 --> 00:20:06.673
這樣就可以只研究
自己想用的那個

00:20:06.740 --> 00:20:08.342
就和Instruments應用一樣

00:20:09.543 --> 00:20:12.946
只要開啓新的時間線
就可以記錄新的時間線了

00:20:13.280 --> 00:20:15.983
但你可能不想
讓它們同時運行

00:20:16.550 --> 00:20:19.386
JavaScript和
Events時間線樣本分析器

00:20:19.453 --> 00:20:21.188
雖然負載較少
但還是有

00:20:21.722 --> 00:20:24.491
而JavaScript Allocation
的時間線會添加更多進程

00:20:24.558 --> 00:20:27.761
在垃圾回收過程中
這會影響性能

00:20:28.428 --> 00:20:31.965
那我們就一直開着
Memory時間線

00:20:32.032 --> 00:20:35.002
那麼在記錄一個時間線的時候
你會看到這個

00:20:35.936 --> 00:20:39.907
這個新的Memory時間線圖表
顯示了內存如何分配

00:20:39.973 --> 00:20:42.342
到不同的目錄裏
在不同的時間

00:20:43.076 --> 00:20:44.878
這裏有一系列圖表

00:20:44.945 --> 00:20:48.515
幫你瞭解
內存的使用和劃分

00:20:49.750 --> 00:20:52.319
Breakdown表顯示了
內存如何分配給

00:20:52.386 --> 00:20:56.356
JavaScript和圖畫
和構成頁面的分層

00:20:56.423 --> 00:20:58.825
以及其他
引擎相關的網頁

00:21:00.060 --> 00:21:03.463
Max Comparison圖
幫你研究內存高峯

00:21:03.530 --> 00:21:04.831
這裏有一個高的水印

00:21:04.898 --> 00:21:07.401
幫你觀察
過去的內存問題

00:21:07.467 --> 00:21:10.437
你甚至可以分離各個峯
通過選擇一個特定的部分

00:21:10.504 --> 00:21:14.041
或者在一個峯值周圍
選擇一個特定的時間段

00:21:14.541 --> 00:21:17.945
然後你就可以使用
下面的目錄分類

00:21:18.011 --> 00:21:20.180
來看看是什麼
造成了大部分高峯

00:21:20.781 --> 00:21:23.784
這裏的每個圖表
都是獨立測量的

00:21:23.851 --> 00:21:26.653
所以你可以清楚地看到
不同時間的變化

00:21:28.021 --> 00:21:30.591
JavaScript裏的峯值
顯示的是

00:21:30.657 --> 00:21:33.527
大量新對象
被創建和引用的地方

00:21:33.660 --> 00:21:36.763
其中包括的對象
有字符串對象和函數

00:21:37.164 --> 00:21:41.201
以及所有支持它們的引擎數據
比如結構數據和編譯代碼

00:21:41.902 --> 00:21:44.605
當你看到
JavaScript的用量下降

00:21:44.671 --> 00:21:47.241
就是說垃圾回收
在回收內存

00:21:48.308 --> 00:21:50.811
圖片顯示了
分配給圖片的內存

00:21:50.878 --> 00:21:52.713
這些圖片都
通過解碼顯示

00:21:52.980 --> 00:21:54.815
這裏的圖片數據
比較大

00:21:54.882 --> 00:21:57.551
通常用於
可以在視口顯示的圖片

00:21:59.052 --> 00:22:01.722
層顯示的是
圖層內存

00:22:01.788 --> 00:22:04.858
分配在WebKits
tileGrid複合層

00:22:04.925 --> 00:22:06.093
和其他引擎層

00:22:07.227 --> 00:22:08.896
頁面就囊括了
所有其他的東西

00:22:08.962 --> 00:22:10.931
引擎所追蹤的
所有內容

00:22:10.998 --> 00:22:14.234
比如DOM和頁面風格
以及字體渲染數據

00:22:14.301 --> 00:22:16.470
內存緩存和系統分配

00:22:17.271 --> 00:22:19.306
所以這個分類
能讓你很好的保證

00:22:19.373 --> 00:22:22.242
內存用量
符合你的預期

00:22:22.943 --> 00:22:26.446
若你有很多JavaScript內容
你要明白

00:22:26.513 --> 00:22:30.150
JavaScript會是分類圖表裏
用量最多的一類

00:22:30.217 --> 00:22:33.086
在時間線圖表裏
你可能會隨着時間看到更多變化

00:22:33.954 --> 00:22:38.125
但是對於多圖片的頁面
比如畫廊

00:22:38.192 --> 00:22:41.428
那麼分層和圖片目錄
就可能是最大的

00:22:41.495 --> 00:22:42.896
隨着時間
變化也更多

00:22:43.830 --> 00:22:47.501
這就是Safari 10裏
最新的Memory時間線

00:22:49.203 --> 00:22:53.540
Memory時間線的補充就是
新的JavaScript Allocations時間線

00:22:54.074 --> 00:22:56.343
你不僅能看到
不同時間裏內存的變化

00:22:56.510 --> 00:22:58.111
還能更細的探究

00:22:58.178 --> 00:23:00.781
JavaScript Allocations
的真實情況

00:23:00.948 --> 00:23:06.553
對此我們有個強大的工具
JavaScript Allocation Snapshots

00:23:07.321 --> 00:23:08.889
快照的強大之處

00:23:08.956 --> 00:23:12.426
是你可在JavaScripts堆裏
對一個時刻進行快照

00:23:12.726 --> 00:23:15.696
然後你就可以深入看到
所有被分配的東西

00:23:16.129 --> 00:23:18.765
但是更強大的是
你有兩個快照的時候

00:23:19.466 --> 00:23:22.436
你就可以回頭再看
並進行對比

00:23:22.503 --> 00:23:25.639
對比快照
是我們最強大的工具之一

00:23:25.706 --> 00:23:29.243
它可以解答
我是不是做了不必要的分配？

00:23:30.110 --> 00:23:32.579
一定要利用它
因爲你需要多個快照

00:23:32.646 --> 00:23:36.783
這也就是爲什麼
默認每10秒照一次

00:23:37.217 --> 00:23:39.753
不僅要在記錄開始
還要在結束

00:23:40.153 --> 00:23:42.923
快照是在時間線上設計的
所以它們能連到

00:23:42.990 --> 00:23:44.825
其他時間線上
發生的事情

00:23:44.892 --> 00:23:46.894
在這裏
其他的都被我關了

00:23:48.128 --> 00:23:50.330
這些快照在下面列出
並附了一些細節

00:23:50.397 --> 00:23:51.899
比如堆的
時間和大小

00:23:52.766 --> 00:23:54.501
要了解一個特定的問題

00:23:54.568 --> 00:23:56.870
就通常需要
在開始和結束的時候快照

00:23:56.937 --> 00:23:58.739
圍繞你認爲
內存會出問題的地方

00:23:59.173 --> 00:24:00.541
這裏有三個技巧

00:24:01.074 --> 00:24:03.710
你可以依賴自動快照
每10秒一次

00:24:04.478 --> 00:24:07.247
或者可以親自快照
就按快照鍵

00:24:08.282 --> 00:24:09.750
或者用代碼執行

00:24:10.551 --> 00:24:14.254
最簡單的找到問題的方法
還是改代碼

00:24:14.555 --> 00:24:16.623
調出
takeHeapSnapshot API

00:24:16.690 --> 00:24:19.526
傳遞一個自定義的標籤參數
它可以是任何

00:24:19.593 --> 00:24:21.261
之後能幫你識別它的東西

00:24:21.695 --> 00:24:24.198
還有你要做
一對快照

00:24:24.264 --> 00:24:27.100
在你認爲導致問題的代碼
的前後

00:24:28.035 --> 00:24:30.537
你還可以通過快照
來使用這個代碼

00:24:30.604 --> 00:24:32.940
在一個循環內的
工作之間

00:24:33.340 --> 00:24:34.308
分析內存

00:24:34.374 --> 00:24:38.846
下面講講要時刻牢記的幾點
關於takeHeapSnapshot API

00:24:39.179 --> 00:24:43.050
要記住快照會增添一些額外的進程
在垃圾回收進程中

00:24:43.116 --> 00:24:45.552
這會影響性能
所以你一定要注意

00:24:45.619 --> 00:24:48.088
你的代碼是否
頻繁的發射快照

00:24:49.189 --> 00:24:52.726
你也要捕捉到
前後不同的信息

00:24:52.793 --> 00:24:55.462
當代碼在一個循環之間的
某個時刻運行時

00:24:56.630 --> 00:24:57.698
不要留下這個

00:24:57.764 --> 00:25:00.734
如果你把它留下
對大部分用戶來說沒問題

00:25:00.801 --> 00:25:04.204
但一旦有人運行網絡檢查器
它們就會使用所有的快照

00:25:04.271 --> 00:25:05.506
你大概也不想這樣

00:25:05.572 --> 00:25:08.876
所以要記住
在啓動前一定把它們刪除

00:25:09.776 --> 00:25:11.411
那麼這些快照
都顯示了什麼？

00:25:13.146 --> 00:25:14.181
讓我們來看一看

00:25:14.848 --> 00:25:18.619
你只要點擊時間線上的
快照圖標

00:25:18.685 --> 00:25:21.555
或者在快照列表條目裏
點擊Arrow按鍵

00:25:22.422 --> 00:25:25.225
你看到的這一列對象
都是之前分配在堆裏的

00:25:25.292 --> 00:25:27.294
快照有兩個視圖

00:25:27.694 --> 00:25:29.129
這是Instances視圖

00:25:29.196 --> 00:25:33.033
展示了堆裏的對象列表
按照類來分組

00:25:33.634 --> 00:25:35.736
另一個是
對象圖像視圖

00:25:35.802 --> 00:25:37.871
這實際上
概括了所有東西

00:25:37.938 --> 00:25:40.073
所有的所有

00:25:40.507 --> 00:25:42.109
如果你很熟悉這個代碼

00:25:42.176 --> 00:25:45.946
它就能很好地幫助你
確認事情或者找到相應的位置

00:25:46.947 --> 00:25:49.183
但是實際上
更有用的視圖

00:25:49.249 --> 00:25:51.785
是在Instances視圖裏

00:25:51.852 --> 00:25:54.221
它的強大在於
你可以輕鬆地找到對象

00:25:54.288 --> 00:25:57.057
不論他們在屬性路徑裏
藏得多深

00:25:57.958 --> 00:26:00.494
這裏的Count可以幫你
意識到潛在的問題

00:26:00.561 --> 00:26:02.162
就是它們
無法達到預期的時候

00:26:02.229 --> 00:26:05.199
比如我能否實現
4000多個字符串對象？

00:26:06.733 --> 00:26:10.470
你可以展開這個Classes
來看看所有分配到這裏的對象

00:26:11.238 --> 00:26:14.942
然後判斷什麼是什麼
通過這麼多不同的線索

00:26:15.008 --> 00:26:16.076
Class是一線索

00:26:16.944 --> 00:26:19.379
另外就是
對象的實際屬性

00:26:19.713 --> 00:26:21.648
這能讓我們很快了解
什麼是什麼

00:26:22.516 --> 00:26:24.785
但是最簡單的
瞭解對象的方法

00:26:24.852 --> 00:26:29.323
就是懸停在這個對象識別器上
你就會看到這個

00:26:30.924 --> 00:26:34.795
這裏實際上顯示的是
到對象的最短路徑

00:26:35.362 --> 00:26:38.098
它告訴了你究竟是什麼
讓這個對象保持活動

00:26:38.732 --> 00:26:40.868
它基本上總會給你
你需要的答案

00:26:41.768 --> 00:26:45.572
特別是在JavaScript的
垃圾回收裏

00:26:45.639 --> 00:26:48.509
這就是能
立刻解開疑惑的方法

00:26:49.643 --> 00:26:53.013
但是它最重要的功能
和最關鍵的要點

00:26:53.080 --> 00:26:55.048
在於它能
比較兩個快照

00:26:55.349 --> 00:26:57.551
看看這個
當你已經收集了一些快照

00:26:58.218 --> 00:27:00.521
只要點擊此處“比較快照”按鍵

00:27:01.321 --> 00:27:04.992
然後選擇Baseline快照
再選一個對比

00:27:05.792 --> 00:27:06.627
一下子

00:27:07.027 --> 00:27:09.263
你就有了一個
新的對比快照可以研究

00:27:09.796 --> 00:27:11.131
這個十分有意義

00:27:11.498 --> 00:27:13.467
因爲現在只能看到
新的對象

00:27:13.534 --> 00:27:16.637
在兩個點之間
在兩個快照之間

00:27:18.172 --> 00:27:21.475
展開對象類分組
可以看到所有的對象分配

00:27:21.542 --> 00:27:24.945
預覽中顯示了它們的名字
和類似遙測數據的東西

00:27:25.646 --> 00:27:27.848
這裏就說明
它是衛星對象

00:27:28.348 --> 00:27:31.151
這裏的彈窗顯示
_Satellites Array屬性

00:27:32.319 --> 00:27:34.054
由於這是
一個快照對比

00:27:34.121 --> 00:27:36.857
衛星的對象
都是新分配的

00:27:36.924 --> 00:27:39.359
這是個很重要的線索
顯示代碼在做什麼

00:27:39.893 --> 00:27:42.296
那麼爲了讓你們實際看到
這些新的存儲功能

00:27:42.362 --> 00:27:44.798
我要有請Brian回到臺上
來做另一個演示

00:27:51.171 --> 00:27:52.005
謝謝 Jon

00:27:52.606 --> 00:27:55.742
我把衛星跟蹤器
給了我的朋友Ed

00:27:55.809 --> 00:27:58.545
他熬了一夜
在玩這個

00:28:00.113 --> 00:28:04.251
他很開心
因爲他從來沒有被衛星跟蹤過

00:28:04.351 --> 00:28:05.452
但是這就有個問題

00:28:05.519 --> 00:28:09.122
它運行時間越長
最終會變得越來越慢

00:28:09.790 --> 00:28:13.026
這在我看來
很像傳統的內存

00:28:13.093 --> 00:28:15.262
打開時間越久
就越慢

00:28:15.929 --> 00:28:20.601
我想在衛星跟蹤器裏
用這些新存儲工具來看看

00:28:20.667 --> 00:28:22.369
我們是否泄漏了
一些內存

00:28:23.637 --> 00:28:26.173
那麼第一件事

00:28:26.240 --> 00:28:28.575
我的iPad在這兒

00:28:29.309 --> 00:28:31.545
我要回到
網絡檢查器...

00:28:34.381 --> 00:28:35.782
並且檢查這個應用

00:28:36.717 --> 00:28:38.418
我要做的第一件事

00:28:39.286 --> 00:28:43.857
在我不知道問題在哪兒的時候
就是要使用Memory時間線

00:28:43.924 --> 00:28:48.595
它會告訴我
頁面上大概發生了什麼

00:28:48.662 --> 00:28:50.030
那麼我們開始記錄

00:28:51.131 --> 00:28:52.766
轉回來

00:28:52.833 --> 00:28:57.604
我在兩個衛星之間
來回切換

00:28:58.138 --> 00:29:00.741
也許我會在這裏
添加一些效果

00:29:02.142 --> 00:29:04.611
好的
我在來回切換

00:29:06.613 --> 00:29:08.048
好了
現在去時間線看看

00:29:11.351 --> 00:29:15.422
在時間線概覽中
你看到一個堆積線形圖

00:29:15.489 --> 00:29:17.624
顯示了所有不同的部分
和相關的大小

00:29:17.858 --> 00:29:21.128
如果你點擊這裏
會看到更多的細節

00:29:22.563 --> 00:29:24.831
那麼這個頁面上
沒有圖片

00:29:24.898 --> 00:29:25.766
都是畫布

00:29:26.400 --> 00:29:27.801
分層也很平面

00:29:28.268 --> 00:29:30.804
頁面有些波動
有些內容在垃圾回收

00:29:30.871 --> 00:29:31.705
沒有問題

00:29:32.306 --> 00:29:35.175
如果你仔細看看JavaScript
你會看到...

00:29:35.776 --> 00:29:37.444
雖然有些東西
被垃圾回收

00:29:37.511 --> 00:29:40.280
但是整體來說
它還是在隨着時間堆積

00:29:40.614 --> 00:29:44.318
如果我們運行一整晚
那估計會堆積更多

00:29:44.952 --> 00:29:51.358
下一步就是啓用heap快照
或allocation快照

00:29:51.425 --> 00:29:54.194
這樣我們就能找到
隨着時間而分配的內容

00:29:56.630 --> 00:30:00.667
爲了實現這個
我們要開始新的記錄

00:30:03.103 --> 00:30:06.139
這有個快捷鍵
Shift 點擊或Shift 空格

00:30:06.206 --> 00:30:08.942
這樣就會啓動新的記錄
而不是繼續之前那個

00:30:09.510 --> 00:30:11.778
等等
我忘了改時間線

00:30:11.845 --> 00:30:13.046
去掉Memory

00:30:14.314 --> 00:30:15.916
選上Allocations

00:30:18.252 --> 00:30:19.520
好了
開始記錄

00:30:20.387 --> 00:30:21.288
回到iPad

00:30:23.190 --> 00:30:25.759
添加了小小的
takeHeapSnapshot鍵

00:30:25.826 --> 00:30:29.229
我已給控制檯添加了
一些takeHeapSnapshot的調令

00:30:29.296 --> 00:30:32.633
用於切換兩個衛星小組
和其他操作

00:30:33.800 --> 00:30:38.038
對這個記錄
我要轉動地圖

00:30:38.105 --> 00:30:41.942
然後不斷在
兩個衛星中切換

00:30:46.580 --> 00:30:49.416
我們還要看看Spy Satellites
看上去也有關聯

00:30:52.419 --> 00:30:54.254
好了 你會發現
開始有點卡了

00:30:54.321 --> 00:30:57.591
因爲我們給JavaScript堆裏的
所有東西拍了快照

00:30:57.658 --> 00:31:00.060
因此
產生了很多對象

00:31:00.127 --> 00:31:01.795
這會大幅降低
應用的速度

00:31:01.862 --> 00:31:05.265
所以一定不要
拍很多快照

00:31:05.332 --> 00:31:08.435
只在重要的時候拍

00:31:08.802 --> 00:31:13.974
這裏你可以看到方塊裏的S
就是我們拍的快照

00:31:16.043 --> 00:31:18.812
放大一下能看到

00:31:18.879 --> 00:31:20.814
隨着時間過去
內存十分穩定的增長

00:31:20.881 --> 00:31:23.584
當我們開始在
兩個衛星之間切換的時候

00:31:26.753 --> 00:31:29.056
如果我們要研究這個
像Jon說的那樣

00:31:29.122 --> 00:31:35.829
我們就要啓動對比
來看看是什麼被攔住了

00:31:35.896 --> 00:31:40.167
那麼我們就對比
快照9和11

00:31:41.602 --> 00:31:45.072
立刻
我們就看到很多東西

00:31:45.138 --> 00:31:49.443
被分配在9和11之間
並且仍然在活動中

00:31:49.943 --> 00:31:52.412
這就清楚地說明瞭
它們被留存了

00:31:52.479 --> 00:31:54.648
雖然我們
並不想這麼做

00:31:55.649 --> 00:31:57.551
那麼我們來看看
這些都是什麼

00:31:58.752 --> 00:31:59.620
這是些陣列

00:32:00.454 --> 00:32:03.423
看上去這個陣列裏
全是座標

00:32:04.858 --> 00:32:07.728
你知道在應用的不同部分
我們會用大量的座標

00:32:07.794 --> 00:32:11.164
但是如果我們停在這裏
就會看到它的路徑

00:32:11.265 --> 00:32:14.701
它們好像是被保存於
trajectoryHistory

00:32:14.768 --> 00:32:18.572
這是我們用來製作
追蹤衛星的東西

00:32:19.973 --> 00:32:21.375
好的
這樣不錯

00:32:21.441 --> 00:32:23.710
但是我想不應該

00:32:25.112 --> 00:32:27.714
再在已不顯示的衛星裏用
trajectoryHistory

00:32:27.781 --> 00:32:29.416
這好像是個bug

00:32:31.985 --> 00:32:33.620
我們也分配了
一些對象

00:32:35.055 --> 00:32:39.526
但奇怪的是
在快照9和11之間

00:32:39.593 --> 00:32:41.795
我們之前已經看到
這些衛星

00:32:41.862 --> 00:32:45.065
那麼我就不想
再給每個衛星創建新的對象

00:32:45.132 --> 00:32:48.735
我們只要直接使用它們
只要我們已經爲他們獲取了資源

00:32:48.802 --> 00:32:53.140
然後這裏有了很多
座標和遙測

00:32:53.207 --> 00:32:56.476
好像正在
重新解析什麼

00:32:58.045 --> 00:32:59.646
我不太確定
那麼...

00:33:00.113 --> 00:33:03.851
在這個視圖裏
我們有很多對象

00:33:03.917 --> 00:33:05.085
你不能讀取所有

00:33:05.152 --> 00:33:08.355
所以我想做的
就是找出很特別的那一個

00:33:08.856 --> 00:33:10.357
那麼在這個快照裏

00:33:11.825 --> 00:33:13.861
我們有很多字符串
陣列和對象

00:33:13.927 --> 00:33:15.395
但只有一個Promise

00:33:15.829 --> 00:33:17.831
它停留在
兩個快照之間

00:33:17.898 --> 00:33:19.900
所以我認爲
應該調試這個

00:33:19.967 --> 00:33:24.071
那麼我就找到代碼
看看是哪裏在用Promises

00:33:24.371 --> 00:33:27.274
因爲好像它與別的什麼
一起被泄露了

00:33:27.441 --> 00:33:29.576
於是
搜索Promise

00:33:30.077 --> 00:33:34.882
好了 這是D3庫
這是使用它的代碼

00:33:37.251 --> 00:33:39.052
好的
來看看這個

00:33:39.887 --> 00:33:44.892
好了 在［聽不清］裏
我們常常在衛星之間切換

00:33:44.958 --> 00:33:46.593
代碼是loadDataset

00:33:46.793 --> 00:33:50.631
有人寫了評論
太好了

00:33:51.665 --> 00:33:56.103
這裏看上去好像
有人請求我們改變衛星

00:33:57.271 --> 00:34:03.710
那麼這裏就可以
異步從URL下載數據

00:34:03.777 --> 00:34:06.046
當它返回
我們就要解析

00:34:07.414 --> 00:34:10.918
然後使用衛星繪圖庫 
做更多的解析

00:34:11.784 --> 00:34:13.887
然後我們把它存到
衛星列表上

00:34:15.389 --> 00:34:18.525
這都很不錯
但是回到檢查器

00:34:18.592 --> 00:34:20.527
我們好像每次都泄露該Promise

00:34:20.594 --> 00:34:22.929
如果你更仔細的想想

00:34:22.996 --> 00:34:25.732
如果切換到
已經下載的數據組會怎樣？

00:34:26.967 --> 00:34:29.235
我們甚至都沒有
檢查過這個事情

00:34:30.237 --> 00:34:33.373
你仔細的看看這裏

00:34:34.107 --> 00:34:36.577
每次在兩個衛星之間轉換

00:34:37.277 --> 00:34:38.812
我們就發出
一個新的網絡請求

00:34:38.879 --> 00:34:40.179
如果我們進入這個時間線

00:34:41.014 --> 00:34:44.618
就會看到我們在不斷請求
同樣的垃圾數據

00:34:46.018 --> 00:34:49.523
這是正常的
如果回到代碼 發出請求

00:34:49.590 --> 00:34:51.859
解析的時候
會產生大量的對象

00:34:52.492 --> 00:34:54.293
然後我們把它推入
衛星陣列

00:34:54.360 --> 00:34:56.697
就目前來看
它怎麼都不清楚

00:34:56.763 --> 00:35:02.202
我們好像一直在做無用功
然後不斷泄露

00:35:02.269 --> 00:35:04.838
所以這裏
我們要做的

00:35:04.905 --> 00:35:08.475
是檢查我們是否已經
解析了這個衛星對象

00:35:08.742 --> 00:35:10.043
因爲這是Promise

00:35:10.344 --> 00:35:14.081
如果它確實存在
我們可以調出.then

00:35:14.848 --> 00:35:18.886
由於這已解決
下一次評估Promise的反應時

00:35:18.952 --> 00:35:22.556
它就會進行檢查
並將衛星放到地圖上

00:35:23.657 --> 00:35:26.960
那麼在這裏
添加代碼

00:35:30.664 --> 00:35:33.734
如果不存在
我們就創建一個

00:35:42.242 --> 00:35:47.314
好了 現在停下來看看
有沒有效果

00:35:50.117 --> 00:35:52.352
我們就要回去
重新連接

00:35:55.923 --> 00:35:59.993
這是我們的應用
開始記錄吧

00:36:02.329 --> 00:36:05.132
當我們回到應用
我就打開快照

00:36:05.632 --> 00:36:06.700
打開一些效果

00:36:06.800 --> 00:36:10.237
然後往南走

00:36:10.804 --> 00:36:13.240
好的 間諜衛星

00:36:14.274 --> 00:36:16.777
衛星的科學實驗

00:36:17.811 --> 00:36:18.779
科學實驗

00:36:20.480 --> 00:36:21.315
好了

00:36:24.885 --> 00:36:28.455
如果我們回到這裏
我們看到內存的增長大大降低

00:36:28.522 --> 00:36:31.959
大概在1兆
而不是四五兆

00:36:32.025 --> 00:36:34.228
那麼這裏可能有
更多的泄露

00:36:34.294 --> 00:36:38.665
但是在快照結束的時候
我們的內存

00:36:38.732 --> 00:36:41.168
跟剛開始渲染的時候
一樣大

00:36:41.235 --> 00:36:43.537
這樣我們就修復了
這個特殊的泄露

00:36:44.805 --> 00:36:49.710
這就展示了我們如何使用
Allocations和Memory時間線

00:36:49.776 --> 00:36:53.547
來解決像這樣的
應用的內存泄露問題

00:36:54.114 --> 00:36:58.585
這很不錯
因爲應用可以用更多的操作

00:36:58.652 --> 00:37:00.954
有了diffing功能

00:37:01.021 --> 00:37:04.825
我們就可以深入觀察
我們所關心的衛星裏的變化

00:37:06.660 --> 00:37:09.062
好了
衛星跟蹤器就講到這

00:37:10.197 --> 00:37:11.031
你回來吧 Jon

00:37:16.670 --> 00:37:17.504
謝謝 Brian

00:37:17.738 --> 00:37:21.241
你看到了
真是不可思議的迅速和簡單

00:37:21.308 --> 00:37:24.845
這些新的時間線
讓內存零問題

00:37:25.512 --> 00:37:27.748
所以請記住
Memory時間線是瞭解

00:37:27.814 --> 00:37:30.317
內存的使用情況
和造成內存高峯的原因

00:37:30.384 --> 00:37:32.119
這樣你就知道
該去哪裏找問題

00:37:33.020 --> 00:37:37.291
然後使用多個Heap快照
在JavaScript Allocations時間線裏

00:37:37.357 --> 00:37:39.826
以便單獨放大
造成內存增長的代碼

00:37:40.761 --> 00:37:43.363
還有不要忘了刪除
takeHeapSnapshot

00:37:43.430 --> 00:37:44.932
在代碼運行之前

00:37:46.066 --> 00:37:48.101
要記住性能所受的影響

00:37:48.168 --> 00:37:51.505
是JavaScript Allocations
時間線記錄時產生的

00:37:53.607 --> 00:37:56.577
那麼以上就是
新的時間線工具

00:37:56.643 --> 00:37:58.445
可用在Safari 10的
網絡檢查器上

00:37:58.979 --> 00:38:00.747
我想你一定會
愛上它們

00:38:01.982 --> 00:38:04.852
在結束之前
我還想再說幾點

00:38:05.586 --> 00:38:08.355
我要建議你們
重新考慮下WKWebView

00:38:08.422 --> 00:38:09.623
如果你還沒有換掉它

00:38:11.358 --> 00:38:13.493
在Safari設置裏
打開Develop菜單

00:38:13.560 --> 00:38:15.262
連接網絡檢查器
到你的應用

00:38:15.329 --> 00:38:17.631
然後開始利用
這些新功能

00:38:18.031 --> 00:38:21.468
節省大量時間
Bottom Up視圖和Call Trees用於

00:38:21.535 --> 00:38:23.504
找到最需要優化的地方

00:38:23.570 --> 00:38:26.974
Memory時間線可以
快速看到內存高峯的情況

00:38:27.140 --> 00:38:31.111
Heap快照可以
輕鬆查找和比較對象分配

00:38:32.379 --> 00:38:33.881
時刻關注
新功能的更新

00:38:33.947 --> 00:38:36.550
今年網絡檢查器
和WebKit有更多內容

00:38:36.617 --> 00:38:39.486
可以讓你利用
應用的網頁內容

00:38:39.620 --> 00:38:41.722
來創造絕佳的
應用內的用戶體驗

00:38:42.789 --> 00:38:45.225
除了Brian和我
今天爲你們展示的功能

00:38:45.292 --> 00:38:48.562
我們團隊過去一年也爲
網絡檢查器添加了很多內容

00:38:49.396 --> 00:38:53.500
Quick Open會讓你直接跳到
頁面加載的資源

00:38:53.867 --> 00:38:58.739
尾調用堆棧
現在可顯示調試器裏的尾調用優化函數

00:38:59.339 --> 00:39:02.809
初春的時候在OS 10系統下
我們引進了Safari 9.1

00:39:03.277 --> 00:39:05.245
並更新了
網絡檢查器

00:39:05.913 --> 00:39:09.416
它顯示了Elements標籤下
DOM Tree裏的Pseudo Elements

00:39:09.883 --> 00:39:12.319
這裏還有一個
新的視覺風格邊欄

00:39:13.787 --> 00:39:15.489
可能你還沒注意到

00:39:15.756 --> 00:39:17.991
網絡檢查器
是一個開發者工具

00:39:18.058 --> 00:39:20.527
作爲WebKit開源項目的一部分

00:39:21.962 --> 00:39:25.199
WebKit是網頁瀏覽器引擎
用來支持你的應用

00:39:25.265 --> 00:39:27.668
驅動WebViews
和JSContext

00:39:28.068 --> 00:39:30.137
當然它也是Safari
背後的動力

00:39:31.004 --> 00:39:34.508
在過去一年裏
我們爲WebKit添加了好多新功能

00:39:34.575 --> 00:39:36.910
我們對ES6
100％支持

00:39:37.678 --> 00:39:40.714
我們改進了對IndexedDB
Standard的支持

00:39:41.215 --> 00:39:45.219
還添加了Shadow DOM支持
WebDriver和CSS變量

00:39:45.619 --> 00:39:46.753
以及Picture Element

00:39:47.688 --> 00:39:50.224
所以真的是很多內容
而且作爲開源項目

00:39:50.290 --> 00:39:52.559
一旦有新的出現
你就能知道

00:39:53.060 --> 00:39:55.329
你們在座大部分人
肯定都想能利用它工作

00:39:55.395 --> 00:39:58.365
如果你們想
對這些內容作出改進

00:39:58.432 --> 00:39:59.433
完全有機會

00:39:59.499 --> 00:40:01.702
因爲WebKit
是開放資源

00:40:02.669 --> 00:40:05.906
你可在WebKit.org上
找到更多WebKit項目信息

00:40:05.973 --> 00:40:09.710
WebKit團隊及其背後的
工程師們會在博客上寫他們的開發工作

00:40:09.776 --> 00:40:11.778
實際上
我們現在有兩個博客

00:40:11.845 --> 00:40:14.648
關於Memory時間線
和樣本分析器

00:40:14.715 --> 00:40:15.716
就是今天講的內容

00:40:15.782 --> 00:40:18.151
所以如果你想了解更多
可以去那裏看看

00:40:18.552 --> 00:40:21.355
我們還有一個功能狀態頁
一目瞭然的列出了所有更新

00:40:21.421 --> 00:40:22.789
針對網頁標準進程

00:40:23.357 --> 00:40:26.260
這裏還有鏈接
可以下載WebKit夜間建構

00:40:26.727 --> 00:40:29.930
和最新的瀏覽器
Safari技術概覽

00:40:30.797 --> 00:40:34.201
每幾周更新一次
附帶更新的WebKit引擎

00:40:34.668 --> 00:40:37.871
所以你可以在WebKit上
嘗試這些新的實驗性功能

00:40:37.938 --> 00:40:39.606
它們每兩週改進一次

00:40:40.474 --> 00:40:44.411
我們團隊投入了大量精力給Safari
WebKit和網絡檢查器

00:40:44.478 --> 00:40:47.581
網絡檢查器團隊
可以使用這些新性能特性

00:40:47.648 --> 00:40:50.918
就像我們今天展示的那樣
去查詢問題並提高性能

00:40:50.984 --> 00:40:52.419
對網絡檢查器本身

00:40:52.619 --> 00:40:54.555
我已經迫不及待
想看看你們會做些什麼

00:40:54.855 --> 00:40:56.590
想了解更多信息
請觀看這個演講

00:40:56.657 --> 00:40:59.259
在developer.apple.com
下載幻燈片

00:41:00.093 --> 00:41:03.163
這周的前幾天有很多場相關演講

00:41:03.230 --> 00:41:04.831
過去幾年也有不少

00:41:05.098 --> 00:41:07.835
這些都能在
developer.apple.com上找到

00:41:08.769 --> 00:41:12.606
那麼代表Brian 我自己
和Safari與WebKit團隊

00:41:12.673 --> 00:41:15.442
感謝你們的到來
祝大家在接下來的WWDC中過得愉快