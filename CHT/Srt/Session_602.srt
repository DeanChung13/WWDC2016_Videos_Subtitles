00:00:20.153 --> 00:00:23.023 
採用METAL 第一部分

00:00:26.393 --> 00:00:29.296 
下午好 歡迎來到
“採用Metal 第一部分”

00:00:29.696 --> 00:00:32.165 
我是GPU軟件團隊的
Warren Moore

00:00:32.499 --> 00:00:36.203 
我和同事Matt Collins
一起 他主要負責做展示

00:00:36.904 --> 00:00:38.338 
我想問一個

00:00:38.405 --> 00:00:41.542 
看似簡單的問題 什麼是Metal

00:00:42.209 --> 00:00:45.345 
你可能已聽說過Metal是
Apple的偏底層的API

00:00:45.412 --> 00:00:48.882 
面向GPU的
它是一個統一的圖形計算語言

00:00:49.216 --> 00:00:51.652 
並且面向多線程做了優化

00:00:51.952 --> 00:00:53.720 
專門爲我們的平臺所設計

00:00:53.954 --> 00:00:55.255 
這些都是正確的

00:00:55.589 --> 00:00:58.825 
但是Metal不僅有
Metal.framework

00:00:59.193 --> 00:01:04.864 
Metal同時也被
其他的框架和工具支持

00:01:05.699 --> 00:01:08.869 
它們提供了比metal框架
API多很多的東西

00:01:09.269 --> 00:01:11.939 
尤其是去年我們引入MetalKit

00:01:12.339 --> 00:01:14.775 
它包括了用來一些處理常見任務的工具

00:01:14.842 --> 00:01:18.478 
像與UIKit和AppKit交互
加載紋理

00:01:20.113 --> 00:01:21.748 
還有Metal性能着色器

00:01:21.949 --> 00:01:25.419 
能幫你做圖片處理

00:01:25.485 --> 00:01:28.789 
可以手動調優 高度優化的着色器

00:01:29.189 --> 00:01:32.159 
可以直接放到你的應用裏
來處理這些任務

00:01:33.227 --> 00:01:36.263 
Metal同時還緊密
與我們的開發工具結合

00:01:36.496 --> 00:01:37.998 
像Xcode與
Instruments

00:01:40.167 --> 00:01:41.902 
當你的應用裏面有着色器

00:01:42.336 --> 00:01:44.471 
它們會同你的應用一起編譯

00:01:44.571 --> 00:01:48.809 
通過Xcode集成到你的應用包裏

00:01:49.376 --> 00:01:52.279 
還有GPU框架調試器
可以做一個快照

00:01:52.579 --> 00:01:55.916 
在程序運行的任何一個點
來看看程序現在是什麼情況

00:01:56.717 --> 00:01:59.086 
Instruments中
Metal系統跟蹤

00:01:59.553 --> 00:02:01.955 
可以讓你在運行是查看應用的性能

00:02:02.022 --> 00:02:03.857 
和行爲

00:02:05.359 --> 00:02:07.794 
兩年前我們把Metal引入了iOS

00:02:08.027 --> 00:02:13.100 
然後我們又把它帶到了
Mac OS和tvOS

00:02:13.800 --> 00:02:16.436 
所以現在在我們平臺上
受到了廣泛的支持

00:02:17.004 --> 00:02:19.540 
同時我們的大部分硬件也支持它

00:02:19.907 --> 00:02:24.044 
包括桌面架構和移動架構

00:02:24.111 --> 00:02:27.114 
像Apple AMD Intel
和NVIDIA

00:02:27.447 --> 00:02:30.884 
所有的2012年後的Mac

00:02:31.185 --> 00:02:34.655 
2013年以後的所有iOS設備
還有新的Apple TV

00:02:35.389 --> 00:02:38.725 
Metal可以讓應用程序充分利用
GPU的性能

00:02:38.792 --> 00:02:42.162 
在我們的海量的產品上

00:02:44.898 --> 00:02:47.701 
在這些平臺上Metal屬於基礎技術

00:02:48.235 --> 00:02:52.406 
它支持核心圖像 核心動畫

00:02:52.773 --> 00:02:56.710 
遊戲和圖形庫比如SpriteKit
SceneKit和Model I/O

00:02:57.211 --> 00:02:58.912 
也是我們關鍵系統軟件的重要部分

00:02:58.979 --> 00:03:02.716 
像Preview和Safari

00:03:04.384 --> 00:03:06.587 
各種各樣開發者們
已廣泛使用了Metal

00:03:06.653 --> 00:03:10.591 
從AAA工作室 遊戲引擎提供商

00:03:11.024 --> 00:03:14.294 
到獨立開發者和專業工具開發者

00:03:14.428 --> 00:03:17.831 
他們開發了非常好的應用和遊戲

00:03:18.398 --> 00:03:21.502 
這只是一部分
我想着重說幾個

00:03:22.469 --> 00:03:26.073 
比如 Fancy Guo用
Metal顯著的提升了性能

00:03:26.273 --> 00:03:27.741 
帶來了驚人的視覺效果

00:03:27.808 --> 00:03:31.512 
在他們廣受歡迎的MORPG遊戲
Furious Wings

00:03:33.180 --> 00:03:36.817 
Metal也被用在
專業的內容創造工具

00:03:36.884 --> 00:03:39.419 
像iPad上即將發佈的
Affinity Photos

00:03:40.487 --> 00:03:44.691 
我帶大家快速預覽下都有什麼

00:03:46.026 --> 00:03:48.595 
這個是Serif Labs的
Affinity Photos

00:03:49.196 --> 00:03:51.198 
這是個全功能的圖片編輯應用

00:03:51.265 --> 00:03:54.501 
在iPad pro上
Metal可讓其獲得令人驚歎的效果

00:03:57.938 --> 00:04:00.874 
今年的 WWDC
我們會給你一些工具

00:04:01.241 --> 00:04:02.743 
讓你們開始使用Metal

00:04:02.809 --> 00:04:05.812 
來製作體驗非常棒的應用

00:04:06.780 --> 00:04:10.551 
今年的 WWDC 有很多很棒的內容

00:04:10.751 --> 00:04:12.619 
有五場講座專門介紹Metal

00:04:13.253 --> 00:04:16.390 
當然這是第一場會話
採用Metal 第一部分

00:04:16.990 --> 00:04:19.159 
在這節中我們會討論

00:04:19.226 --> 00:04:23.263 
Metal裏的一些基本概念

00:04:23.864 --> 00:04:26.600 
接着會介紹2D繪圖添加光照

00:04:26.667 --> 00:04:29.903 
紋理和動畫 我們還會介紹3D

00:04:30.637 --> 00:04:34.074 
這節課的第二部分
也是在這個教室 緊接着這節課

00:04:34.474 --> 00:04:36.176 
我們會介紹動態數據管理

00:04:36.243 --> 00:04:38.445 
接着會介紹一些高級的

00:04:38.545 --> 00:04:40.414 
關於GPU和CPU的同步

00:04:40.614 --> 00:04:43.016 
會讓你性能達到新高度

00:04:43.116 --> 00:04:44.885 
通過使用多線程編碼

00:04:47.421 --> 00:04:49.723 
我們會介紹下
Metal裏有什麼新東西

00:04:49.790 --> 00:04:52.893 
確實有很多新特性

00:04:52.960 --> 00:04:56.063 
在昨天的統一介紹中
相信你們也看到了一些

00:04:57.831 --> 00:04:59.266 
我不會詳細介紹全部的東西

00:04:59.333 --> 00:05:01.768 
如果你想在你的應用中使用

00:05:01.835 --> 00:05:03.837 
你應該看一下那個最新課程

00:05:05.572 --> 00:05:08.709 
最後 我們會有個很棒的
高級着色器優化的課程

00:05:09.176 --> 00:05:12.312 
對於那些想要

00:05:12.379 --> 00:05:14.781 
更好的使用着色器的人來說
這些絕對是乾貨

00:05:14.848 --> 00:05:17.284 
我們會詳細的討論硬件如何工作

00:05:17.351 --> 00:05:20.587 
你該怎樣使用Metal來更好的
發揮它的性能

00:05:21.622 --> 00:05:23.056 
還有調優你的着色器代碼

00:05:24.157 --> 00:05:26.827 
在這些課程中 我們會創建樣例工程

00:05:26.894 --> 00:05:30.030 
由簡單的
Hello Triangle開始

00:05:30.097 --> 00:05:31.798 
圖形編程領域的
Hello world

00:05:32.232 --> 00:05:35.402 
然後 我們會研究動畫和紋理貼圖

00:05:35.702 --> 00:05:38.305 
第二部分 我們會進入到下一層級

00:05:38.906 --> 00:05:41.341 
討論下實時更新對象數據

00:05:41.675 --> 00:05:44.578 
同時還有 通過多線程
來優化繪製調用

00:05:45.913 --> 00:05:48.515 
現在我們假設

00:05:49.283 --> 00:05:50.651 
你們已經熟悉

00:05:50.717 --> 00:05:53.086 
基本的圖形編程 最好是

00:05:54.288 --> 00:05:58.525 
知道可編程管線
熟悉着色器等

00:05:58.592 --> 00:06:01.895 
同時你想知道怎麼能用Metal來

00:06:01.962 --> 00:06:03.964 
讓你的程序和遊戲變得更棒

00:06:04.164 --> 00:06:07.000 
我假設大家都是這樣

00:06:07.067 --> 00:06:08.468 
這也是你們爲啥在此 對吧

00:06:09.970 --> 00:06:11.705 
我先過一遍議題

00:06:12.039 --> 00:06:14.241 
我們會先大體介紹下

00:06:14.308 --> 00:06:16.476 
Metal的理念

00:06:16.543 --> 00:06:18.312 
和爲何Metal會是現在的樣子

00:06:18.378 --> 00:06:20.147 
接着我們會詳細的

00:06:20.214 --> 00:06:22.049 
介紹創建一個Metal實例

00:06:22.482 --> 00:06:24.218 
接下來會介紹加載數據

00:06:24.551 --> 00:06:26.687 
到內存來供GPU使用

00:06:26.753 --> 00:06:29.389 
我們會簡要介紹下Metal着色語言

00:06:29.456 --> 00:06:32.326 
我們會介紹創建預驗證管線狀態

00:06:33.026 --> 00:06:36.096 
和GPU調用 包括繪製調用

00:06:36.830 --> 00:06:39.132 
我們會用一個討論結束

00:06:39.199 --> 00:06:42.970 
如何在Metal中處理
動畫和紋理貼圖

00:06:43.737 --> 00:06:45.672 
第二部分我們會介紹的更深一些

00:06:45.739 --> 00:06:47.508 
剛纔我已經提到了

00:06:47.574 --> 00:06:49.009 
現在我們開始

00:06:49.543 --> 00:06:51.345 
從理念概覽開始

00:06:51.411 --> 00:06:53.981 
只有幾點需要強調

00:06:55.415 --> 00:06:57.851 
使用和硬件驅動相匹配的API

00:06:58.652 --> 00:07:00.654 
儘量明確一些

00:07:01.021 --> 00:07:03.790 
儘量不做耗時操作

00:07:04.658 --> 00:07:07.160 
先說說使用和硬件驅動相匹配的API

00:07:08.295 --> 00:07:10.230 
Metal是一個完全現代化的API

00:07:10.430 --> 00:07:13.967 
也可以說它使用了最新的硬件特性

00:07:15.269 --> 00:07:18.338 
和硬件的工作流程息息相關

00:07:18.805 --> 00:07:22.476 
作爲一個全新的API
它非常輕量級

00:07:22.543 --> 00:07:25.679 
並且沒有歷史包袱

00:07:26.446 --> 00:07:29.616 
對的開銷的操作沒有花哨的技巧

00:07:29.816 --> 00:07:33.120 
它和Metal契合

00:07:33.187 --> 00:07:34.755 
並且都是在最基礎的層級操作

00:07:34.821 --> 00:07:37.191 
幸運的是 它是統一的

00:07:37.591 --> 00:07:39.226 
在我們的所有平臺上

00:07:41.328 --> 00:07:42.930 
當我們說我們更傾嚮明確的操作

00:07:42.996 --> 00:07:45.866 
意思是我們想讓你

00:07:45.933 --> 00:07:49.770 
負責操作GPU

00:07:49.837 --> 00:07:51.805 
而不是讓其默認的操作

00:07:52.105 --> 00:07:54.508 
同時還包括數據的管理和同步

00:07:55.342 --> 00:07:57.578 
這讓你有更多的責任

00:07:57.644 --> 00:08:00.480 
同時能有更好的性能

00:08:02.082 --> 00:08:04.284 
再來解釋下

00:08:04.351 --> 00:08:06.453 
不要經常做耗費大的工作

00:08:07.754 --> 00:08:12.626 
有三個地方

00:08:12.759 --> 00:08:14.194 
程序創建時

00:08:14.695 --> 00:08:16.496 
程序加載時

00:08:16.630 --> 00:08:18.165 
加載資源的時候

00:08:18.465 --> 00:08:21.869 
然後就是繪製時 每秒會調用60次

00:08:23.537 --> 00:08:25.672 
如果是歷史API 如OpenGL

00:08:25.973 --> 00:08:27.074 
你大部分時間會花在

00:08:27.140 --> 00:08:29.810 
狀態檢查上
每次調用繪製的時候

00:08:30.143 --> 00:08:33.246 
最壞的時候你需要在運行時重新編譯

00:08:33.746 --> 00:08:36.683 
這些都會給GPU的必要工作上

00:08:37.484 --> 00:08:40.254 
添加負擔 在調用繪製函數的時候

00:08:41.688 --> 00:08:44.525 
在Metal中我們把這些工作提前

00:08:44.958 --> 00:08:46.693 
像我開始說的

00:08:47.094 --> 00:08:48.896 
着色器的編譯可以在

00:08:48.962 --> 00:08:50.931 
程序編譯的時候同時進行

00:08:52.366 --> 00:08:54.701 
同時 我們也允許你驗證狀態

00:08:54.768 --> 00:08:57.538 
在調用繪製的時候提前驗證

00:08:57.838 --> 00:09:01.208 
這樣就不用在每次
調用繪製的時候驗證了

00:09:01.642 --> 00:09:04.545 
這樣你需要做的唯一工作

00:09:04.611 --> 00:09:07.581 
就是隻有繪製調用了

00:09:10.083 --> 00:09:11.485 
通過這些理念介紹

00:09:11.552 --> 00:09:13.487 
我們看看實際情況中的

00:09:13.554 --> 00:09:14.888 
Metal設備

00:09:16.123 --> 00:09:17.724 
這裏有個類MTL設備

00:09:18.425 --> 00:09:21.061 
它表示抽象的GPU

00:09:21.528 --> 00:09:24.865 
它是你Metal應用中的最基本對象

00:09:25.265 --> 00:09:27.301 
你將會用它來創建

00:09:27.367 --> 00:09:30.904 
像指令隊列 資源和管線狀態對象

00:09:30.971 --> 00:09:33.006 
和其他你需要用的對象

00:09:35.709 --> 00:09:37.845 
創建Metal設備很簡單

00:09:37.911 --> 00:09:41.114 
只需調用
MTLCreateSystemDefaultDevice

00:09:41.715 --> 00:09:43.951 
現在設備代表對象

00:09:44.017 --> 00:09:46.553 
你需要在程序開始時創建一個

00:09:46.720 --> 00:09:50.557 
並保持引用
因爲會在整個程序的生命週期使用

00:09:51.391 --> 00:09:52.759 
就這麼簡單

00:09:53.927 --> 00:09:56.129 
現在說說怎麼把數據

00:09:56.430 --> 00:09:58.265 
放到GPU可以讀取的位置

00:09:58.565 --> 00:10:00.267 
然後你可以觸發繪製調用

00:10:00.968 --> 00:10:04.037 
在Metal中
我們把數據存到緩衝中

00:10:04.338 --> 00:10:07.808 
緩衝就是一塊內存用來存數據

00:10:07.875 --> 00:10:09.309 
你可以用任何格式

00:10:10.043 --> 00:10:14.348 
可能是頂點數據 索引數據 常量

00:10:15.449 --> 00:10:17.084 
你把數據寫到緩存中

00:10:17.150 --> 00:10:18.752 
隨後在

00:10:19.052 --> 00:10:20.988 
頂點和片段函數中訪問

00:10:22.222 --> 00:10:23.957 
我們看看大體是個什麼樣子

00:10:24.024 --> 00:10:26.059 
這裏有個包含幾個緩存的例子

00:10:26.360 --> 00:10:28.795 
你加載數據的時候可能會創建

00:10:28.862 --> 00:10:31.565 
我們有個vertexBuffer
包含一些頂點數據

00:10:31.665 --> 00:10:34.434 
一個indexBuffer
包含一些連續的索引

00:10:35.702 --> 00:10:37.171 
更具體寫來說

00:10:37.671 --> 00:10:42.042 
每個頂點類型的實例
可能是一個Swift結構

00:10:42.376 --> 00:10:44.845 
用向量表示頂點的位置

00:10:45.579 --> 00:10:47.548 
同樣還有點的顏色

00:10:47.848 --> 00:10:50.050 
你可以讓它們在內存你連續保存

00:10:51.285 --> 00:10:53.387 
說下如何創建緩存

00:10:55.088 --> 00:10:58.292 
這個API在你已經創建的設備裏

00:10:58.692 --> 00:11:00.894 
簡單調用newBufferWithLength

00:11:00.961 --> 00:11:02.729 
來獲得一個指定大小的緩存

00:11:02.996 --> 00:11:04.998 
裏面默認沒有數據

00:11:05.432 --> 00:11:07.734 
或調用newBufferWithBytes

00:11:07.801 --> 00:11:10.237 
傳一個已經在內存中有數據的指針

00:11:10.637 --> 00:11:12.339 
Metal會把數據拷貝

00:11:12.573 --> 00:11:14.308 
到新創建的緩存

00:11:14.441 --> 00:11:16.109 
你可以馬上使用

00:11:17.244 --> 00:11:20.781 
你也可以用memcpy
把內容指針拷貝到緩存裏

00:11:23.717 --> 00:11:26.587 
既然我們要展示一個2D的三角

00:11:26.720 --> 00:11:27.988 
作爲我們第一部分的展示

00:11:28.589 --> 00:11:31.825 
我們先說下三角的幾何座標

00:11:33.126 --> 00:11:35.162 
既然我們想讓頂點着色器

00:11:35.229 --> 00:11:37.164 
和片段着色器儘可能的簡單

00:11:37.731 --> 00:11:40.901 
我們在裁減的空間裏提供座標

00:11:41.668 --> 00:11:44.705 
Metal的裁剪空間很有趣

00:11:44.771 --> 00:11:47.674 
它和其他類似的API有些不同

00:11:47.741 --> 00:11:49.343 
有點像DirectX裁剪空間

00:11:49.776 --> 00:11:53.013 
X從負1到1 Y軸從負1到1

00:11:53.080 --> 00:11:55.883 
Z軸從0到1

00:11:56.617 --> 00:11:59.753 
這個是我們要用的座標空間

00:11:59.953 --> 00:12:01.855 
代碼中是這樣的

00:12:02.723 --> 00:12:04.992 
我們創建了個Swift的頂點數組

00:12:05.292 --> 00:12:07.127 
我們依次添加頂點

00:12:07.194 --> 00:12:09.196 
同時包括位置和顏色值

00:12:12.766 --> 00:12:15.302 
現在 我們不用嚴格的使用索引繪製

00:12:15.402 --> 00:12:18.438 
在這個簡單的用例中

00:12:18.672 --> 00:12:22.609 
接着創建一個indexBuffer
並向其中添加0 1 2

00:12:22.876 --> 00:12:24.978 
代表三角形的第一個 第二個

00:12:25.045 --> 00:12:27.047 
和第三個點

00:12:27.114 --> 00:12:29.449 
然後用我們的設備創建接個緩存

00:12:29.550 --> 00:12:32.019 
我們會用newBuffer(withBytes
創建vertexBuffer

00:12:32.085 --> 00:12:34.721 
把頂點數據加載到Metal緩存中

00:12:35.122 --> 00:12:37.024 
我們再調用一次newBuffer(withBytes

00:12:37.090 --> 00:12:40.360 
把索引數據穿進去
得到indexBuffer

00:12:42.229 --> 00:12:44.398 
現在我們有了數據和內存

00:12:44.531 --> 00:12:47.634 
下面說說統一着色語言

00:12:48.202 --> 00:12:51.972 
Metal的着色語言是
C++ 14的擴展子集

00:12:52.339 --> 00:12:54.908 
他是圖形和計算的統一語言

00:12:55.275 --> 00:12:56.810 
代表你還可以做很多事

00:12:56.877 --> 00:12:58.645 
不僅是3D圖形

00:12:58.979 --> 00:13:01.481 
它可以讓你寫程序給GPU

00:13:02.816 --> 00:13:06.153 
這裏有個管線各個階段的圖表

00:13:06.253 --> 00:13:08.689 
現在我們是在頂點

00:13:08.755 --> 00:13:10.524 
和片段處理階段

00:13:10.591 --> 00:13:13.393 
每個階段都有相應的函數要寫

00:13:13.627 --> 00:13:16.930 
要麼是處理頂點要麼是片段

00:13:16.997 --> 00:13:18.632 
將會刷到屏幕上

00:13:19.266 --> 00:13:21.335 
語法上 它看起來像這樣

00:13:21.902 --> 00:13:25.672 
我們不會詳細介紹

00:13:25.739 --> 00:13:30.244 
希望你們注意這些函數修飾符：
頂點和片段

00:13:30.544 --> 00:13:33.280 
你會注意到右面函數的前面

00:13:33.347 --> 00:13:36.083 
不像普通的C++程序

00:13:36.183 --> 00:13:38.418 
我們相用這些修飾符來表示

00:13:38.552 --> 00:13:40.854 
這些函數和哪個階段相關

00:13:41.321 --> 00:13:42.856 
我們有一個頂點函數在上面

00:13:42.923 --> 00:13:44.591 
和一個片段函數在下面

00:13:46.026 --> 00:13:48.795 
我將簡單展示怎麼實際把這些

00:13:49.429 --> 00:13:51.865 
和你的管線結合在繪製的時候

00:13:52.266 --> 00:13:55.035 
我們還會看看這些函數的內部實現

00:13:55.269 --> 00:13:58.105 
在以後的2D和3D展示中

00:13:59.006 --> 00:14:01.074 
我提過好幾次Metal可以

00:14:01.141 --> 00:14:03.644 
直接把着色器編譯到程序包裏

00:14:03.710 --> 00:14:07.915 
方法是即使你有一個.Metal文件

00:14:08.282 --> 00:14:11.318 
在你的工程中的編譯源碼層

00:14:11.385 --> 00:14:13.720 
Metal會自動生成

00:14:13.787 --> 00:14:16.390 
一個Metal庫文件
default.Metallib

00:14:16.657 --> 00:14:17.958 
同時會拷貝到你的包中

00:14:18.158 --> 00:14:19.860 
在你的程序編譯的時候

00:14:19.927 --> 00:14:21.562 
除此之外不會再編譯

00:14:22.763 --> 00:14:24.831 
所以它會在你程序包中

00:14:25.732 --> 00:14:27.301 
這是
default.Metallib

00:14:28.502 --> 00:14:29.436 
簡單說

00:14:31.438 --> 00:14:33.273 
你可在運行時編譯Metal着色器

00:14:33.540 --> 00:14:36.176 
如果你程序裏有一個.Metal文件

00:14:36.243 --> 00:14:37.845 
它會被Xcode用
Metal工具鏈編譯

00:14:38.111 --> 00:14:41.248 
生成一個default.Metallib
打到你的應用包中

00:14:42.115 --> 00:14:44.051 
這裏很自然會有個問題

00:14:44.117 --> 00:14:47.955 
運行時怎麼使用這些函數

00:14:48.021 --> 00:14:49.389 
答案是你會用一個叫做

00:14:49.456 --> 00:14:51.058 
Metal Library的類

00:14:51.124 --> 00:14:52.693 
Metal Library
是一個集合

00:14:52.759 --> 00:14:55.596 
編譯器編譯的函數對象

00:14:55.996 --> 00:14:57.598 
有幾種方法創建

00:14:57.664 --> 00:14:59.466 
你可以通過我們討論的流程

00:14:59.800 --> 00:15:02.503 
創建一個
default.Metallib

00:15:02.569 --> 00:15:04.872 
到你的應用包
然後在運行時加載

00:15:04.938 --> 00:15:09.576 
你還可以用我們的命令行工具鏈
編譯一個.metallibs

00:15:10.344 --> 00:15:13.347 
運行時你還可以用代碼串創建一個目錄

00:15:13.413 --> 00:15:16.750 
例如 通過字符串來編譯一個渲染器

00:15:18.085 --> 00:15:19.853 
在代碼裏看起來像這樣

00:15:20.020 --> 00:15:22.022 
爲了加載
default.Metallib

00:15:22.089 --> 00:15:24.491 
調用
newDefaultLibrary

00:15:24.992 --> 00:15:26.627 
用你已經創建的Metal設備

00:15:27.361 --> 00:15:30.297 
還有其他的API加載 例如

00:15:30.364 --> 00:15:32.799 
從編譯好的.Metallib
或者從源代碼

00:15:32.866 --> 00:15:35.002 
你可以詳細查看文檔
來瞭解這些API

00:15:37.671 --> 00:15:40.107 
現你已有Metal Library

00:15:40.207 --> 00:15:42.876 
能從中得到什麼
可以得到Metal函數

00:15:42.943 --> 00:15:46.380 
現在Metal函數是一個簡單對象
代表一個函數

00:15:46.880 --> 00:15:49.183 
它和一個特定的管線階段關聯

00:15:49.249 --> 00:15:50.884 
記得我們剛纔看過的圖麼

00:15:50.951 --> 00:15:52.519 
頂點或片段階段

00:15:52.853 --> 00:15:55.856 
我們還有一個額外的
描述符叫“kernel”

00:15:55.923 --> 00:15:58.825 
表示並行處理數據的函數

00:16:01.795 --> 00:16:04.498 
這裏有段代碼 你可以看到

00:16:04.565 --> 00:16:07.768 
函數名是
vertex transform

00:16:08.001 --> 00:16:11.405 
fragmentFunction名是fragment lighting

00:16:11.738 --> 00:16:14.641 
我重改下以便我能給你展示API

00:16:14.708 --> 00:16:16.743 
如何在你的庫中加載函數

00:16:16.810 --> 00:16:17.945 
像這樣

00:16:18.011 --> 00:16:19.780 
我們先調用
NewFunctionWithName

00:16:19.847 --> 00:16:22.249 
傳一個代表函數名的字符串

00:16:22.616 --> 00:16:26.520 
獲得一個Metal函數 引用它

00:16:27.588 --> 00:16:30.457 
稍後將展示實際中如何使用這些對象

00:16:30.724 --> 00:16:33.794 
但也只是簡要介紹Metal着色語言

00:16:34.695 --> 00:16:38.232 
讓我們介紹下創建預驗證的管線狀態

00:16:40.701 --> 00:16:42.769 
但首先 我們先預熱下

00:16:42.970 --> 00:16:45.439 
像OpenGL中的API

00:16:45.706 --> 00:16:48.008 
你經常需要設置許多狀態

00:16:48.375 --> 00:16:50.043 
然後觸發繪製調用

00:16:50.110 --> 00:16:53.280 
在這之間驅動負責驗證

00:16:53.347 --> 00:16:56.250 
你設置的狀態是有效的

00:16:56.650 --> 00:16:59.052 
然後 最壞的情況

00:16:59.219 --> 00:17:01.255 
你還得付出運行時
重新編譯着色器的代價

00:17:01.922 --> 00:17:03.724 
我們想要避免這些

00:17:04.590 --> 00:17:07.261 
在Metal中 它看起來像這樣

00:17:08.228 --> 00:17:10.564 
你設置一個預驗證的管線狀態對象

00:17:10.631 --> 00:17:12.933 
可能還有其他少數輔助狀態

00:17:12.999 --> 00:17:14.468 
然後觸發繪製調用

00:17:14.867 --> 00:17:17.604 
我們這裏想要減少繪製調用的負擔

00:17:17.671 --> 00:17:20.374 
把更多工作提前進行

00:17:21.375 --> 00:17:27.146 
這裏有幾個你可以在管線狀態對象中
設置的樣例狀態

00:17:27.214 --> 00:17:30.384 
這些狀態繪製時你可以在任何時間設置

00:17:30.617 --> 00:17:32.085 
你看到左面這欄

00:17:32.152 --> 00:17:33.987 
你可能設置的管線狀態

00:17:34.054 --> 00:17:37.157 
有頂點和片段函數用來繪製的

00:17:37.391 --> 00:17:40.127 
還有透明渲染狀態

00:17:42.162 --> 00:17:44.364 
右面 我們看到的狀態是

00:17:44.431 --> 00:17:46.700 
你可以在觸發繪製函數前設置

00:17:46.767 --> 00:17:49.603 
包括front face winding
和cull mode

00:17:50.971 --> 00:17:53.173 
來講一下如何創建對象

00:17:53.240 --> 00:17:55.242 
包括這些預驗證的狀態

00:17:56.276 --> 00:17:59.179 
主要對象是
Metal RenderPipelineState

00:17:59.880 --> 00:18:02.983 
它代表一類GPU的管線配置

00:18:03.217 --> 00:18:06.820 
它包括你會在加載時創建的
一個預驗證集合

00:18:08.055 --> 00:18:09.423 
像設備

00:18:09.489 --> 00:18:11.992 
RenderPipelineStates
是持久對象

00:18:12.059 --> 00:18:16.063 
你想讓它在你的整個程序
生命週期都存在

00:18:16.597 --> 00:18:18.365 
如果你有很多不同的函數

00:18:18.432 --> 00:18:20.033 
你可以異步創建管線狀態對象

00:18:20.100 --> 00:18:22.269 
在程序運行的時候

00:18:23.270 --> 00:18:25.372 
實際上在創建
RenderPipelineState時

00:18:25.439 --> 00:18:26.673 
我們不會直接創建

00:18:26.740 --> 00:18:29.443 
反而 我們會用一個叫做
Descriptor的對象

00:18:30.577 --> 00:18:34.014 
它打包了所有參數用來創建
RenderPipelineState

00:18:34.515 --> 00:18:37.551 
通常在Metal中
我們創建Descriptor對象

00:18:37.618 --> 00:18:40.354 
它會把所有不同的參數弄在一起

00:18:40.420 --> 00:18:42.623 
我們在創建其他對象時也會使用

00:18:42.689 --> 00:18:45.158 
對於RenderPipelineState對象

00:18:45.225 --> 00:18:47.227 
它被叫做渲染管線描述符

00:18:47.294 --> 00:18:50.230 
你會發現它包含指向頂點函數

00:18:50.297 --> 00:18:52.232 
和片段函數的指針
我早先曾介紹過

00:18:52.299 --> 00:18:55.202 
它還包含一個附件集合

00:18:55.569 --> 00:18:59.506 
附件是一些紋理我們會在

00:18:59.573 --> 00:19:01.341 
實際渲染中用到

00:19:01.708 --> 00:19:04.344 
現在在Metal中
所有的渲染都會被渲染到紋理中

00:19:04.678 --> 00:19:08.081 
但我們不需要提前指向
那些紋理的指針

00:19:08.348 --> 00:19:11.552 
我們只需要提供你要渲染的像素格式

00:19:11.618 --> 00:19:15.255 
這樣我們對它們的管線狀態優化

00:19:15.689 --> 00:19:18.258 
若你使用了深度
或者Stencil Buffer

00:19:18.325 --> 00:19:21.361 
你也可以指定它們的像素格式

00:19:22.229 --> 00:19:24.831 
你一旦創建了一個管線描述符

00:19:25.199 --> 00:19:27.201 
你可以傳遞給你的Metal設備

00:19:27.267 --> 00:19:29.937 
然後得到一個
MTLRenderPipelineState對象

00:19:30.504 --> 00:19:32.039 
讓我們在代碼中看一下

00:19:32.673 --> 00:19:35.375 
這是一個RenderPipelineState
的最小化配置

00:19:35.442 --> 00:19:37.611 
你會發現我們設置了頂點函數

00:19:37.678 --> 00:19:39.780 
和片段函數屬性給

00:19:39.847 --> 00:19:43.116 
我們先前從我們庫中創建的
頂點和片段對象

00:19:44.284 --> 00:19:46.453 
同時我們也創建了

00:19:46.520 --> 00:19:49.857 
主要顏色附件的像素格式
爲.bgra8Unorm

00:19:49.923 --> 00:19:53.560 
它是一個可顯示和渲染的像素格式

00:19:55.429 --> 00:19:57.331 
這代表我們最終要

00:19:57.397 --> 00:19:59.666 
在繪製的時候繪製的紋理

00:20:00.367 --> 00:20:03.270 
最後 一旦我們創建了管線描述符

00:20:03.737 --> 00:20:06.540 
我們可以用設備新的
RenderPipelineState函數

00:20:06.607 --> 00:20:10.077 
來獲得實際的預驗證對象

00:20:11.945 --> 00:20:14.715 
我還行強調下PipelineStates
是持久的對象

00:20:14.781 --> 00:20:16.450 
你應該在加載時創建

00:20:16.517 --> 00:20:19.086 
在使用設備和資源的時候需要保持

00:20:19.186 --> 00:20:20.921 
你可以在繪製時在它們之間切換

00:20:20.988 --> 00:20:22.489 
來達到不同的效果

00:20:22.789 --> 00:20:26.693 
通常會有一對頂點和片段函數

00:20:28.862 --> 00:20:31.765 
現在我們已經討論了
如何創建預驗證的狀態

00:20:32.132 --> 00:20:34.535 
和如何加載資源到內存中

00:20:34.601 --> 00:20:37.905 
接下來我們說下觸發GPU指令
包括繪製調用

00:20:39.640 --> 00:20:41.341 
我們通過幾個階段介紹

00:20:41.408 --> 00:20:43.877 
我們還會討論和
UIKit AppKit交互

00:20:44.378 --> 00:20:47.314 
稍微討論下Metal指令提交模型

00:20:47.414 --> 00:20:49.950 
然後到渲染和繪製調用 最終

00:20:50.017 --> 00:20:52.052 
如何展現你的內容到屏幕上

00:20:53.153 --> 00:20:55.322 
就與UIKit和AppKit
交互而言

00:20:55.389 --> 00:20:59.092 
我們用MetalKit裏的
一個工具MTKView

00:20:59.660 --> 00:21:02.729 
MTKView是一個跨平臺的視圖類

00:21:02.796 --> 00:21:05.265 
繼承自Mac OS的NSView

00:21:05.799 --> 00:21:08.068 
iOS和tvOS中的UIView

00:21:09.269 --> 00:21:11.405 
它可以減少你要寫的代碼

00:21:11.471 --> 00:21:13.173 
爲了讓它在Metal中運行起來

00:21:13.473 --> 00:21:17.010 
例如 它會創建和管理一個
CA Metal Layer

00:21:17.077 --> 00:21:20.147 
是CALayer的一個特殊子類

00:21:20.214 --> 00:21:23.784 
可以和窗口服務或者顯示循環交互

00:21:23.851 --> 00:21:25.352 
來讓你的內容顯示到屏幕上

00:21:25.419 --> 00:21:29.256 
通過CV或CA顯示鏈

00:21:29.456 --> 00:21:31.892 
可管理繪製回調循環

00:21:31.992 --> 00:21:33.627 
通過循環觸發回調

00:21:34.027 --> 00:21:35.729 
來完成你的繪製

00:21:35.796 --> 00:21:38.765 
同時它還可以管理要渲染的紋理

00:21:39.766 --> 00:21:41.835 
具體的方面我想強調

00:21:42.135 --> 00:21:45.439 
它可以做什麼和那些繪圖資源

00:21:46.306 --> 00:21:50.944 
在CA Metal Layer中
由MTKView管理

00:21:51.011 --> 00:21:52.913 
有一個可繪製資源集合

00:21:53.013 --> 00:21:54.848 
可繪製資源包含一個紋理

00:21:54.915 --> 00:21:56.717 
將要顯示到屏幕上

00:21:57.084 --> 00:21:59.486 
這些在一個內部的隊列中保存
會在幀間複用

00:21:59.553 --> 00:22:02.155 
因爲它們相對來說要耗費資源

00:22:02.489 --> 00:22:05.058 
它們需要由系統管理

00:22:05.125 --> 00:22:07.661 
因爲它們和東西

00:22:07.728 --> 00:22:09.663 
如何在屏幕上顯示息息相關

00:22:09.730 --> 00:22:12.966 
我們替你管理並給你

00:22:13.033 --> 00:22:15.636 
包含紋理的可繪製對象
讓你來繪製

00:22:16.470 --> 00:22:18.272 
這裏有幾個屬性

00:22:18.338 --> 00:22:20.340 
你可以給MTKView設置

00:22:20.407 --> 00:22:24.044 
來定義如何管理紋理並往裏面繪製

00:22:24.111 --> 00:22:26.914 
特別是 你還可以設置一個純色

00:22:26.980 --> 00:22:29.483 
讓主色更清楚

00:22:29.950 --> 00:22:32.753 
可以指定顏色像素格式

00:22:33.120 --> 00:22:36.123 
需要匹配你指定的

00:22:36.190 --> 00:22:37.791 
固定管線的狀態對象的顏色格式

00:22:37.858 --> 00:22:41.161 
同時制定深度或模板顏色格式

00:22:41.562 --> 00:22:43.630 
最後一個屬性可能是最重要的一個了

00:22:43.697 --> 00:22:45.699 
我們在這裏設置代理

00:22:45.832 --> 00:22:49.603 
MTKView實際上不會做任何繪製

00:22:49.670 --> 00:22:51.071 
你可以將它歸爲一個子類別

00:22:51.205 --> 00:22:54.341 
或者你實現一個代理負責繪製

00:22:54.708 --> 00:22:56.577 
我們通過接下來的例子來介紹

00:22:56.844 --> 00:22:59.346 
我們看看你需要怎麼做

00:22:59.413 --> 00:23:02.382 
才能實現一個MTKView代理

00:23:03.584 --> 00:23:06.119 
可歸結需要實現兩個方法

00:23:06.353 --> 00:23:09.423 
繪製大小變化和繪製

00:23:10.023 --> 00:23:13.126 
在繪製大小變化裏你負責

00:23:13.193 --> 00:23:18.031 
響應如窗口大小發生變化
或者設備旋轉

00:23:18.098 --> 00:23:20.667 
比如 如果你的投影矩陣依賴

00:23:20.734 --> 00:23:23.604 
窗口大小 那麼它可以讓你

00:23:23.670 --> 00:23:26.240 
響應來替代重建所有幀

00:23:27.140 --> 00:23:30.511 
繪製方法會固定的被調用

00:23:30.611 --> 00:23:33.514 
可以讓你編碼你想的執行指令

00:23:33.580 --> 00:23:36.116 
包括繪製調用

00:23:36.183 --> 00:23:39.920 
我們沒有展示這個方法的
完整的內部內容

00:23:41.255 --> 00:23:44.324 
但是這是對指令提交的簡單介紹

00:23:44.558 --> 00:23:48.529 
你要創建commandBuffer
做些事情 然後提交

00:23:48.829 --> 00:23:50.964 
稍後我們會做更多介紹

00:23:51.031 --> 00:23:55.068 
但是這是一種使用MTKView
的繪製功能的hook函數

00:23:55.903 --> 00:23:58.238 
我們推薦使用MTKView
尤其是在開始時

00:23:58.305 --> 00:24:00.507 
因爲它已經爲你做了不少其他的東西

00:24:01.408 --> 00:24:03.810 
我們說下Metal的指令提交模型

00:24:04.244 --> 00:24:06.079 
這裏有張我們要做的圖

00:24:06.146 --> 00:24:07.714 
在接下來幾張幻燈片中

00:24:08.682 --> 00:24:12.052 
你不需要記住所有的東西

00:24:12.119 --> 00:24:14.188 
我們將要把這個圖繪出來

00:24:14.288 --> 00:24:15.756 
這僅是個大體介紹

00:24:15.822 --> 00:24:19.359 
我們會創建這個對象

00:24:20.627 --> 00:24:24.464 
Metal的指令提交模型非常明確

00:24:24.698 --> 00:24:26.934 
表示你需要自己構造

00:24:27.000 --> 00:24:28.969 
和提交commandBuffers

00:24:29.336 --> 00:24:32.005 
可把commandBuffer當作

00:24:32.072 --> 00:24:34.007 
一個打包的工作交給GPU執行

00:24:34.208 --> 00:24:37.744 
不同於我們存數據的Metal緩存

00:24:38.078 --> 00:24:40.380 
指令緩衝存了GPU需要完成的工作

00:24:40.848 --> 00:24:43.817 
同時commandBuffer的
提交完全由你控制

00:24:43.884 --> 00:24:46.019 
就是當你構造了一個
commandBuffer

00:24:46.086 --> 00:24:49.289 
你負責告訴GPU何時執行

00:24:49.590 --> 00:24:51.258 
稍後會詳細介紹

00:24:51.491 --> 00:24:53.594 
我們先說說指令編碼器

00:24:53.660 --> 00:24:56.363 
把對象的API調用翻譯成

00:24:56.763 --> 00:24:58.432 
GPU需要做的工作

00:24:58.498 --> 00:24:59.399 
你要明白這很重要

00:24:59.466 --> 00:25:02.603 
這些指令編碼器不會有狀態驗證延時

00:25:02.669 --> 00:25:05.305 
所以所有預驗證狀態捆綁到

00:25:05.372 --> 00:25:07.140 
管線的狀態對象裏了

00:25:07.908 --> 00:25:10.878 
我們假設它是合法的
因爲我們已經提前驗證了

00:25:11.144 --> 00:25:13.981 
所以這裏沒有額外的工作要做

00:25:14.047 --> 00:25:17.117 
在你的編碼器或驅動
調用渲染指令的時候

00:25:19.920 --> 00:25:22.856 
還有 Metal的指令提交模型
是多線程的

00:25:22.923 --> 00:25:26.326 
你可以並行的創建多個指令緩存

00:25:26.493 --> 00:25:28.896 
讓應用決定執行順序

00:25:29.162 --> 00:25:33.534 
這可以讓你的每一幀的繪製
執行上萬次調用

00:25:33.934 --> 00:25:36.370 
使用Metal 第二部分會深入探討

00:25:36.470 --> 00:25:40.374 
但這裏因爲提到了所以說一下

00:25:41.775 --> 00:25:44.211 
讓我們深入瞭解下這些對象

00:25:44.978 --> 00:25:47.548 
首先是指令隊列

00:25:48.081 --> 00:25:50.317 
指令隊列這裏是說

00:25:50.384 --> 00:25:52.519 
一個叫做
MTLCommandQueue的類

00:25:52.586 --> 00:25:55.822 
它把設備需要執行的指令
都放在隊列裏執行

00:25:56.924 --> 00:25:59.493 
像設備和資源和管線狀態

00:25:59.826 --> 00:26:02.796 
隊列是一直存在的對象

00:26:02.963 --> 00:26:06.200 
在程序的整個生命週期會保持引用

00:26:06.266 --> 00:26:07.935 
通常你只需要創建一個

00:26:08.502 --> 00:26:12.072 
這樣可以保證Metal API
是線程安全的

00:26:12.239 --> 00:26:16.310 
你可以創建指令緩衝渲染

00:26:16.376 --> 00:26:18.445 
並在多線程中使用它

00:26:18.745 --> 00:26:22.349 
隊列可以讓你創建和提交它們

00:26:22.583 --> 00:26:25.752 
並在自己不加鎖的情況下
保證是線程安全的

00:26:27.354 --> 00:26:29.323 
創建一個指令隊列很簡單

00:26:29.790 --> 00:26:32.159 
用設備調用
newCommandQueue()

00:26:32.459 --> 00:26:34.328 
你將會得到一個Metal指令隊列

00:26:36.463 --> 00:26:39.466 
當然只有你往裏放入
指令的時候它纔會工作

00:26:39.666 --> 00:26:41.101 
我們說一下

00:26:44.137 --> 00:26:45.405 
我已經提過指令緩衝了

00:26:45.472 --> 00:26:48.809 
指令緩衝是GPU要執行的打包的工作

00:26:48.876 --> 00:26:51.512 
在Metal中 它們用

00:26:51.578 --> 00:26:53.680 
一個叫做MTLCommandBuffer的類表示

00:26:54.014 --> 00:26:55.983 
MTLCommandBuffer
包含一系列指令

00:26:56.049 --> 00:26:59.920 
由GPU來執行 它們被放進

00:26:59.987 --> 00:27:02.322 
一個指令隊列等待驅動來調度

00:27:02.789 --> 00:27:04.858 
根據我們目前講的這些

00:27:04.925 --> 00:27:07.060 
它是臨時對象

00:27:07.127 --> 00:27:09.630 
就是說每一幀你都要
創建一個或多個

00:27:10.230 --> 00:27:12.466 
然後往裏給它編碼指令

00:27:12.533 --> 00:27:15.135 
然後讓讓它們脫離GPU

00:27:15.202 --> 00:27:17.905 
你不會重用它們 不用引用它們

00:27:18.272 --> 00:27:19.640 
它們會自己消失

00:27:20.774 --> 00:27:22.376 
創建一個commandBuffer

00:27:22.442 --> 00:27:25.078 
調用commandQueue.commandBuffer()

00:27:28.182 --> 00:27:31.385 
我們已經說了緩衝和隊列

00:27:31.451 --> 00:27:33.187 
我們討論下如何把數據和指令

00:27:33.654 --> 00:27:36.089 
放到指令緩衝中

00:27:36.156 --> 00:27:38.825 
通過一個叫做指令編碼器的類

00:27:39.026 --> 00:27:40.861 
這裏有幾種類型的指令編碼器

00:27:40.961 --> 00:27:43.163 
包括渲染 位傳輸和計算

00:27:43.597 --> 00:27:45.766 
這些分別實現不同的功能

00:27:45.832 --> 00:27:49.002 
它們都差不多 都可以把你的

00:27:49.069 --> 00:27:51.638 
工作編碼到指令緩存中

00:27:51.905 --> 00:27:55.576 
比如 一個渲染指令編碼器

00:27:55.642 --> 00:27:57.644 
可以設置狀態和執行繪製調用

00:27:57.911 --> 00:28:00.514 
一個計算指令編碼器可以

00:28:00.848 --> 00:28:05.319 
把工作添加到隊列中
並像數據一樣並行計算 不像渲染工作

00:28:05.385 --> 00:28:07.955 
它像GP GPU或者類似的東西

00:28:08.655 --> 00:28:11.058 
位傳輸指令編碼器用來

00:28:11.124 --> 00:28:13.927 
在緩存和紋理之間相互拷貝數據

00:28:16.330 --> 00:28:19.766 
這節課中我們會詳細
看看渲染指令編碼器

00:28:20.467 --> 00:28:24.605 
我剛纔提到 它負責編碼指令

00:28:24.671 --> 00:28:26.673 
每一個渲染指令編碼器

00:28:27.040 --> 00:28:30.210 
單獨編碼每個工作

00:28:30.544 --> 00:28:32.579 
如果你觸發狀態變化

00:28:32.946 --> 00:28:35.916 
然後觸發繪製

00:28:36.149 --> 00:28:39.887 
然後管理一個渲染附件集合 代表

00:28:39.953 --> 00:28:42.923 
將要繪製的紋理

00:28:43.924 --> 00:28:48.028 
概要來說 我們說的是最後這個階段

00:28:48.095 --> 00:28:50.364 
你能看到我們有這些附件

00:28:50.430 --> 00:28:55.169 
被掛到管線的幀緩存合適的階段

00:28:55.802 --> 00:28:58.972 
如果我們做多通道渲染

00:28:59.039 --> 00:29:02.643 
那麼一個或多個渲染目標可能
會變爲接下來的輸入

00:29:02.709 --> 00:29:05.846 
這裏只有一個通道 比較簡單

00:29:06.780 --> 00:29:09.816 
附件表示紋理貼圖

00:29:09.883 --> 00:29:13.320 
我們將要這個階段的最後繪製

00:29:14.521 --> 00:29:17.157 
就是說 實際上創建一個
渲染指令編碼器

00:29:17.224 --> 00:29:20.561 
使用另一種類型描述對象
一個RenderPassDescriptor

00:29:21.028 --> 00:29:24.031 
一個RenderPassDescriptor
包含一系列的附件

00:29:24.331 --> 00:29:28.602 
每一個都有加載存儲操作 純色和值

00:29:28.669 --> 00:29:31.205 
和將要被渲染的Metal紋理

00:29:31.939 --> 00:29:35.442 
我們用幾頁講一下加載和存儲操作

00:29:35.776 --> 00:29:37.945 
這裏有很重要的一點需要明白

00:29:38.145 --> 00:29:41.815 
你需要構造一個
RenderPassDescriptor

00:29:42.115 --> 00:29:45.352 
在幀開始的時候並且把需要它

00:29:45.419 --> 00:29:47.454 
和將要繪製的紋理相關聯

00:29:47.688 --> 00:29:53.527 
相比只需要知道像素格式
的renderPipelineState

00:29:53.694 --> 00:29:55.295 
這是最重要的部分

00:29:55.362 --> 00:29:58.799 
而你必須有我們將在
其中進行繪製的紋理

00:30:01.235 --> 00:30:03.637 
RenderPassDescriptor包含

00:30:03.704 --> 00:30:06.406 
渲染通道附件
每一個可能是一個顏色

00:30:06.473 --> 00:30:07.774 
深度或者模型目標

00:30:08.041 --> 00:30:09.943 
或者指向需要渲染的紋理

00:30:10.577 --> 00:30:13.380 
指定這些東西叫做加載和存儲操作

00:30:13.680 --> 00:30:16.383 
我們更深入的說下是什麼意思

00:30:16.950 --> 00:30:19.987 
開始的通道中你有顏色緩存

00:30:20.053 --> 00:30:23.590 
有深度緩存它們包含未知的內容

00:30:24.258 --> 00:30:27.995 
爲了做些真正的工作
我們先清空它

00:30:28.295 --> 00:30:30.898 
我們通過設置和其相關的加載動作

00:30:31.231 --> 00:30:33.033 
在RenderPassDescriptor中

00:30:34.101 --> 00:30:37.638 
我們顏色和深度目標
設置一個清空加載動作

00:30:38.105 --> 00:30:40.807 
那它會把相應的顏色設置爲清空色

00:30:40.874 --> 00:30:42.643 
或者值 根據實際情況

00:30:43.410 --> 00:30:44.711 
然後我們開始繪製

00:30:44.845 --> 00:30:46.113 
會把我們作用的結果

00:30:46.180 --> 00:30:48.048 
繪製到紋理上

00:30:48.582 --> 00:30:50.984 
然後存儲操作會觸發

00:30:51.251 --> 00:30:53.820 
存儲操作包含兩部分

00:30:54.188 --> 00:30:57.424 
存儲操作的存儲

00:30:57.491 --> 00:30:59.193 
渲染的結果應該被寫會

00:30:59.259 --> 00:31:00.894 
內存並且存儲

00:31:00.961 --> 00:31:03.263 
對於顏色緩存

00:31:03.330 --> 00:31:05.032 
我們儘可能的在屏幕上展現

00:31:05.199 --> 00:31:07.968 
對於深度緩存 我們只在

00:31:08.035 --> 00:31:11.438 
實際繪製和渲染時用到

00:31:11.638 --> 00:31:15.209 
所以我們在最後的通道中
不關心它的結果

00:31:15.409 --> 00:31:18.779 
我們可以設置一個存儲動作爲不關心
爲了節省些帶寬

00:31:19.112 --> 00:31:21.014 
這也是你可以做的優化

00:31:21.081 --> 00:31:23.450 
如果你並不需要

00:31:23.517 --> 00:31:25.152 
渲染的結果寫會渲染對象

00:31:27.087 --> 00:31:29.556 
再深入說下加載和存儲操作

00:31:29.623 --> 00:31:31.391 
它決定了紋理內容如何被處理

00:31:31.458 --> 00:31:32.960 
在開始和結束的時候

00:31:33.293 --> 00:31:36.597 
另外對清空操作

00:31:36.730 --> 00:31:39.366 
也有加載操作讓你

00:31:39.433 --> 00:31:43.136 
加載紋理的像素內容

00:31:43.370 --> 00:31:44.972 
用之前的處理結果

00:31:45.072 --> 00:31:46.373 
它也不用關心

00:31:46.573 --> 00:31:49.843 
比如 你想從頭到尾渲染一個目標

00:31:49.910 --> 00:31:53.180 
所有的像素 那麼你不用關心

00:31:53.247 --> 00:31:56.583 
之前的紋理 你也不用清空它

00:31:57.017 --> 00:31:58.619 
因爲你知道你將會設置

00:31:58.685 --> 00:32:00.954 
每一個像素爲一些值

00:32:01.255 --> 00:32:02.823 
還一種你可以做的優化

00:32:02.890 --> 00:32:04.458 
如果你知道你會

00:32:04.525 --> 00:32:07.261 
在這個階段處理每個像素

00:32:10.063 --> 00:32:13.534 
我會告訴你 如何創建
RenderPassDescriptor

00:32:13.734 --> 00:32:16.370 
然後創建一個渲染器指令編碼器
幸運的是

00:32:16.603 --> 00:32:18.872 
MTKView使這些變得很簡單

00:32:19.273 --> 00:32:21.708 
之前我們配置MTKView

00:32:21.942 --> 00:32:23.076 
用幾個屬性

00:32:23.143 --> 00:32:25.612 
我希望你們熟悉它
像清空色

00:32:25.679 --> 00:32:27.948 
還有渲染目標的紋理格式

00:32:28.248 --> 00:32:30.317 
實際上你可以通過請求視圖得到

00:32:30.417 --> 00:32:32.319 
當前的RenderPassDescriptor

00:32:32.386 --> 00:32:35.122 
你會獲得一個設置的
RenderPassDescriptor

00:32:35.422 --> 00:32:36.890 
接下來你就可以使用它

00:32:36.957 --> 00:32:39.960 
創建渲染指令編碼器了

00:32:41.929 --> 00:32:44.364 
你該這麼做 調用渲染指令編碼器

00:32:44.431 --> 00:32:46.033 
在你的指令緩存上

00:32:46.099 --> 00:32:49.269 
你需要重點關注當前的
RenderPassDescriptor是

00:32:49.336 --> 00:32:50.804 
一個潛在的塊調用

00:32:51.038 --> 00:32:53.540 
這樣的原因是 實際上它會調用

00:32:53.607 --> 00:32:57.144 
CA Metal Layers的
下一個可繪製函數

00:32:57.444 --> 00:33:00.280 
我們不會詳細介紹
但它是用來

00:33:00.347 --> 00:33:02.516 
獲取包含紋理的可繪製對象

00:33:02.583 --> 00:33:04.184 
來展示到屏幕上

00:33:04.318 --> 00:33:06.620 
因爲那是個有限的資源

00:33:06.854 --> 00:33:09.756 
如果當前沒有可繪製的對象

00:33:09.823 --> 00:33:12.993 
如果他們所有的在運行
然後這個調用會阻塞

00:33:13.293 --> 00:33:14.995 
所以這裏需要注意

00:33:16.597 --> 00:33:18.866 
我們已經說了加載資源到內存

00:33:18.932 --> 00:33:21.034 
我們說了創建預驗證狀態

00:33:21.101 --> 00:33:24.137 
和創建渲染通道

00:33:24.304 --> 00:33:25.739 
和渲染指令編碼器

00:33:25.806 --> 00:33:28.141 
如何把數據弄到着色器中

00:33:29.376 --> 00:33:32.212 
第一我們需要說下參數表

00:33:33.146 --> 00:33:36.617 
參數表是Metal資源到

00:33:37.484 --> 00:33:38.819 
着色器參數的映射

00:33:39.152 --> 00:33:41.755 
你用的每一種資源

00:33:41.822 --> 00:33:43.323 
如緩存或者紋理

00:33:43.390 --> 00:33:45.459 
都有他們自己的緩存參數表

00:33:45.726 --> 00:33:46.994 
在右面你能看到

00:33:47.060 --> 00:33:49.396 
我們有緩存參數表

00:33:49.463 --> 00:33:52.466 
和紋理參數表
它們中每個都包含幾個

00:33:52.533 --> 00:33:56.837 
緩存對應着參數表中的索引

00:33:57.671 --> 00:33:59.473 
給定參數表的插槽的可用數量

00:33:59.540 --> 00:34:02.743 
根據設備決定

00:34:02.843 --> 00:34:04.378 
你需要先查詢

00:34:05.579 --> 00:34:07.481 
我們具體說下

00:34:07.548 --> 00:34:10.150 
在渲染指令編碼器有個函數

00:34:10.217 --> 00:34:11.918 
叫setVerTextBuffer

00:34:12.252 --> 00:34:14.188 
它有三個參數

00:34:14.254 --> 00:34:17.257 
一個buffer 一個offset
一個index

00:34:17.491 --> 00:34:19.893 
最後一個是我們最關心的

00:34:19.960 --> 00:34:23.297 
因爲它是我們的參數表索引

00:34:25.264 --> 00:34:29.735 
這是主機端設置資源

00:34:29.803 --> 00:34:31.638 
在使用着色器的時候

00:34:31.839 --> 00:34:34.608 
也有個對應的着色器端

00:34:34.875 --> 00:34:36.243 
像這樣

00:34:36.443 --> 00:34:38.645 
在着色器語言中間

00:34:38.745 --> 00:34:41.882 
在你的着色文件中 你指定

00:34:42.248 --> 00:34:46.453 
每一個給定的參數
對應一個你要訪問的資源

00:34:46.520 --> 00:34:50.123 
有個屬性像這樣

00:34:50.591 --> 00:34:52.993 
這是第一個緩存索引

00:34:53.060 --> 00:34:54.995 
索引0在參數表中

00:34:55.161 --> 00:34:59.533 
代表我們剛纔在渲染指令編碼器的緩存

00:35:02.069 --> 00:35:04.538 
我們詳細看下

00:35:04.605 --> 00:35:06.974 
當在2D繪製中

00:35:10.744 --> 00:35:12.212 
我們創建了renderPipelineState

00:35:12.279 --> 00:35:14.815 
我們需要告訴渲染指令編碼器

00:35:14.882 --> 00:35:17.584 
在繪製前需要用哪個管線狀態

00:35:17.718 --> 00:35:18.986 
這個API就是幹這個的

00:35:19.419 --> 00:35:21.288 
我們調用setRenderPipelineState

00:35:21.355 --> 00:35:23.790 
用剛纔創建的
PipelineState對象

00:35:23.957 --> 00:35:27.194 
用我們創建的着色器配置

00:35:27.261 --> 00:35:30.364 
我們用先前創建的來繪製

00:35:31.164 --> 00:35:32.666 
現在RenderPipelineState

00:35:32.733 --> 00:35:36.170 
有相關的頂點和片段函數了

00:35:36.403 --> 00:35:38.639 
我們看看頂點和片段函數

00:35:38.705 --> 00:35:40.941 
我們在2D繪圖中主要用這個

00:35:41.975 --> 00:35:44.311 
回到Metal着色語言
看起來像這樣

00:35:44.645 --> 00:35:48.482 
大體上是一個直接的頂點函數

00:35:48.549 --> 00:35:51.018 
沒有複雜的數學操作

00:35:51.084 --> 00:35:53.954 
它會複製所有的屬性 直接連接

00:35:54.555 --> 00:35:59.860 
函數的第一個參數是一個頂點列表

00:35:59.927 --> 00:36:02.162 
我們剛纔創建的緩存

00:36:02.629 --> 00:36:05.165 
第二個參數是屬於

00:36:05.232 --> 00:36:08.202 
頂點ID的屬性

00:36:08.268 --> 00:36:11.638 
表示正Metal在處理的定點的

00:36:11.705 --> 00:36:13.073 
索引

00:36:13.473 --> 00:36:15.342 
它比較重要的原因

00:36:15.409 --> 00:36:17.544 
vertexBuffer
包含所有的點

00:36:17.611 --> 00:36:19.046 
我們可以隨機獲得

00:36:19.479 --> 00:36:22.883 
實際上我們想在我們頂點函數

00:36:22.950 --> 00:36:24.985 
一次對一個點操作

00:36:25.052 --> 00:36:27.321 
這告訴我們正在操作哪一個

00:36:27.554 --> 00:36:30.691 
我們創建一個
VertexOut結構的實例

00:36:30.791 --> 00:36:34.294 
代表定頂點的各種屬性

00:36:34.728 --> 00:36:36.964 
然後我們傳給給光柵

00:36:37.097 --> 00:36:39.900 
我們創建一個實例 並設置位置

00:36:40.000 --> 00:36:44.371 
爲向量位置vertexId的頂點

00:36:44.671 --> 00:36:46.039 
顏色也是類似

00:36:46.106 --> 00:36:48.909 
這裏進傳遞了
vertexBuffer數據

00:36:49.243 --> 00:36:52.112 
給結構體供光柵來做插值

00:36:52.579 --> 00:36:55.816 
然後我們返回這個結構

00:36:57.384 --> 00:36:59.219 
讓我們看看
fragmentFunction

00:36:59.286 --> 00:37:00.954 
它更簡單

00:37:01.088 --> 00:37:05.759 
所以我們得到了插值結構

00:37:05.826 --> 00:37:07.761 
它表示

00:37:07.828 --> 00:37:10.464 
光柵化得來的數據

00:37:10.998 --> 00:37:12.466 
我們剛抽取了顏色

00:37:12.699 --> 00:37:15.702 
顏色來自結構

00:37:16.036 --> 00:37:17.304 
然後再傳回去

00:37:17.604 --> 00:37:20.541 
這個過程中頂點發生了什麼

00:37:20.607 --> 00:37:23.277 
在這個例子裏截取空間指定的

00:37:23.710 --> 00:37:27.514 
被插值然後光柵化然後

00:37:27.581 --> 00:37:29.283 
被每個片段處理

00:37:29.349 --> 00:37:32.753 
我們返回由光柵創建的插值顏色

00:37:34.988 --> 00:37:37.558 
一旦我們指定RenderPipelineState

00:37:37.624 --> 00:37:39.693 
包含我們的頂點和片段函數

00:37:39.760 --> 00:37:42.930 
我們可以設置額外狀態
就像我之前介紹的

00:37:42.996 --> 00:37:45.832 
包括front facing狀態

00:37:46.066 --> 00:37:49.203 
如果你想指定不同的
front facing順序

00:37:49.269 --> 00:37:52.005 
而不用Metal默認的

00:37:52.139 --> 00:37:53.240 
你可以在這裏實現

00:37:54.808 --> 00:37:56.810 
這裏有許多配置項
但我們只看

00:37:56.877 --> 00:37:58.478 
一些繪製調用

00:37:59.613 --> 00:38:00.547 
現在

00:38:00.647 --> 00:38:02.049 
Metal有很多函數

00:38:02.115 --> 00:38:05.152 
繪製幾何圖形包括indexed
instance和indirect

00:38:05.219 --> 00:38:07.287 
我們只看基本的索引繪製

00:38:07.654 --> 00:38:10.224 
這裏我們想畫一個三角形

00:38:10.757 --> 00:38:13.393 
我們調用drawIndexedPrimitives

00:38:13.760 --> 00:38:16.663 
我們指定原型爲三角形

00:38:16.830 --> 00:38:18.365 
因爲我們想畫三角形

00:38:18.498 --> 00:38:21.201 
我們傳遞三個索引

00:38:21.268 --> 00:38:22.603 
來畫一個三角形

00:38:23.203 --> 00:38:26.907 
我們同時需要制定索引的類型

00:38:26.974 --> 00:38:31.044 
我們之前聲明瞭一個Swift
的數組集合

00:38:31.111 --> 00:38:32.746 
我們這裏複製一下

00:38:32.813 --> 00:38:36.550 
我們還要把
indexBuffer傳遞下去

00:38:36.650 --> 00:38:38.285 
來表示哪些點應該繪製

00:38:38.385 --> 00:38:40.220 
我們把位移設置爲0

00:38:40.621 --> 00:38:42.589 
這會畫一個

00:38:42.656 --> 00:38:45.058 
三角形在屏幕上

00:38:46.693 --> 00:38:48.695 
我們可以添加些其他狀態

00:38:48.762 --> 00:38:50.731 
觸發一些其他繪製調用

00:38:50.797 --> 00:38:53.066 
但第一個演示我們就做這些

00:38:53.600 --> 00:38:55.402 
爲了完成一個渲染過程

00:38:55.802 --> 00:38:59.606 
我們調用Render Command
Encoder的endEncoding

00:39:00.641 --> 00:39:03.977 
回顧一下
你需要創建一個請求

00:39:04.044 --> 00:39:06.680 
在開始時獲得RenderPassDescriptor

00:39:07.614 --> 00:39:10.918 
用這個描述符創建
一個Render Command Encoder

00:39:11.752 --> 00:39:13.520 
設置RenderPipelineState

00:39:14.054 --> 00:39:15.589 
設置其他必要的狀態

00:39:15.856 --> 00:39:18.559 
觸發調用最後結束編碼

00:39:19.359 --> 00:39:21.862 
這是我們看到的代碼的一個概括

00:39:22.262 --> 00:39:23.263 
沒有啥新東西

00:39:23.330 --> 00:39:26.099 
和剛纔我說的一樣

00:39:26.834 --> 00:39:31.738 
創建一個Render Command Encoder
設置狀態 設置狀態

00:39:33.006 --> 00:39:34.575 
綁定緩存 然後繪製

00:39:36.243 --> 00:39:38.212 
你已經渲染了這些內容

00:39:38.412 --> 00:39:40.147 
怎麼樣讓它顯示在屏幕上

00:39:40.214 --> 00:39:41.682 
非常簡單

00:39:41.949 --> 00:39:44.585 
首先 渲染路徑的顏色附件

00:39:44.651 --> 00:39:47.154 
通常是可繪製的紋理

00:39:47.287 --> 00:39:50.824 
你可從CA Metal Layer
或者MKTView獲得

00:39:51.525 --> 00:39:54.862 
爲了獲得在實際上顯示的紋理

00:39:55.662 --> 00:39:57.197 
你可調用commandBuffer
的present

00:39:57.264 --> 00:39:59.533 
並給它傳遞那個drawable

00:39:59.600 --> 00:40:01.535 
它將會顯示到屏幕

00:40:01.602 --> 00:40:04.638 
一旦所有的處理路徑完成

00:40:06.740 --> 00:40:08.642 
要向實際完成這一幀

00:40:08.709 --> 00:40:10.811 
由於我們把指令編碼進
commandBuffer

00:40:10.878 --> 00:40:11.979 
我們要表明下我們完成了

00:40:12.045 --> 00:40:14.047 
通過調用commandBuffer.commit()

00:40:14.448 --> 00:40:16.483 
提交告訴驅動
commandBuffer

00:40:16.550 --> 00:40:18.085 
已經準備好給GPU運行了

00:40:19.853 --> 00:40:21.421 
總結一下

00:40:22.856 --> 00:40:24.391 
我們創建了一個指令隊列開始

00:40:24.458 --> 00:40:27.861 
它是一個持久對象
我們需要引用它

00:40:28.462 --> 00:40:30.697 
每一幀我們創建一個
commandBuffer

00:40:30.764 --> 00:40:33.834 
使用渲染指令編碼器編碼
一個或多個渲染路徑

00:40:34.935 --> 00:40:37.738 
通過提交commandBuffer
來在屏幕上顯示

00:40:39.273 --> 00:40:41.508 
現在交給我同事Matt

00:40:41.575 --> 00:40:43.610 
帶我們完成這個2D demo繪製

00:40:43.944 --> 00:40:45.012 
謝謝 Warren

00:40:53.120 --> 00:40:54.388 
這裏是驗證部分

00:40:54.454 --> 00:40:57.524 
一個2D的三角形
這是Metal三角形演示

00:40:57.591 --> 00:40:58.959 
從題目可以看出

00:40:59.459 --> 00:41:01.562 
非常簡單 就是一個三角形
三種顏色

00:41:01.628 --> 00:41:03.931 
在邊上被插值

00:41:05.165 --> 00:41:06.667 
我們看下代碼

00:41:07.835 --> 00:41:11.171 
首先是MTKView的代理

00:41:11.538 --> 00:41:13.507 
Warren說我們需要實現個函數

00:41:13.607 --> 00:41:17.044 
這裏是MTKView的drawable
和sizeable change

00:41:17.344 --> 00:41:19.112 
它將會在window變化時

00:41:19.179 --> 00:41:21.181 
響應

00:41:21.949 --> 00:41:24.318 
例子很簡單我們不會實現它

00:41:24.384 --> 00:41:27.120 
你們在應用中自己實現

00:41:28.121 --> 00:41:29.890 
另一個是繪製

00:41:31.325 --> 00:41:33.327 
我們選擇把它放到渲染函數

00:41:33.493 --> 00:41:34.928 
當我們的繪製被調用

00:41:35.929 --> 00:41:37.231 
我們進入渲染

00:41:39.333 --> 00:41:41.702 
渲染也很簡單

00:41:43.270 --> 00:41:46.139 
當我們拿到MTKView的
當前RenderPassDescriptor

00:41:46.673 --> 00:41:48.642 
你把它弄出來 如Warren所說

00:41:48.876 --> 00:41:50.344 
然後你創建RenderPassDescriptor

00:41:50.410 --> 00:41:51.678 
然後用它編碼

00:41:51.745 --> 00:41:53.380 
大家注意這裏

00:41:53.447 --> 00:41:54.715 
“pushDebugGroup.”

00:41:55.015 --> 00:41:57.251 
這裏你可以和Metal工具交互

00:41:57.351 --> 00:42:00.287 
當你做幀捕獲

00:42:00.354 --> 00:42:02.623 
這裏會列出調試組信息

00:42:02.689 --> 00:42:04.892 
這裏 我們有一個繪製和
一個繪製三角形

00:42:06.760 --> 00:42:08.795 
繪製完我們會彈出調試組

00:42:08.862 --> 00:42:11.398 
所以繪製顯示標籤爲
Draw Triangle

00:42:13.634 --> 00:42:15.169 
我們看下着色器

00:42:17.504 --> 00:42:18.939 
正如Warren說的

00:42:19.006 --> 00:42:21.041 
我們已經有了結構
有頂點結構

00:42:21.108 --> 00:42:23.143 
這是我們放入着色器的數據格式

00:42:23.210 --> 00:42:24.945 
只有位置和顏色

00:42:25.345 --> 00:42:26.947 
有vertex out結構

00:42:27.147 --> 00:42:29.249 
我們會傳給光柵

00:42:29.316 --> 00:42:31.185 
你看到位置被

00:42:31.251 --> 00:42:32.786 
位置屬性標記

00:42:32.920 --> 00:42:35.088 
這裏代表截取空間位置

00:42:35.189 --> 00:42:37.758 
每個點着色器或點函數 抱歉

00:42:37.824 --> 00:42:39.059 
都需要有一個

00:42:40.327 --> 00:42:43.197 
看起來都很熟悉 都很簡單

00:42:43.530 --> 00:42:45.632 
頂點進來 我們有個路徑

00:42:46.266 --> 00:42:47.401 
同時你把它們寫出去

00:42:47.568 --> 00:42:50.938 
在片段函數裏我們拿到頂點

00:42:51.004 --> 00:42:54.474 
被光柵化後 我們讀取顏色並且傳下去

00:42:55.275 --> 00:42:56.910 
這個三角形演示很簡單

00:42:56.977 --> 00:42:58.545 
下面由Warren繼續

00:42:58.712 --> 00:42:59.913 
謝謝 Matt

00:43:03.817 --> 00:43:06.520 
我們已經展示瞭如何繪製2D內容

00:43:07.321 --> 00:43:10.090 
2D非常酷
什麼更酷呢

00:43:12.025 --> 00:43:15.729 
3D 我麼說說Metal中的
動畫和紋理繪圖

00:43:18.398 --> 00:43:19.933 
進入3D前

00:43:21.068 --> 00:43:22.936 
我們會經過幾個階段

00:43:23.003 --> 00:43:24.371 
我們討論如何真正實現3D

00:43:24.905 --> 00:43:27.107 
我們用constant緩衝實現動畫

00:43:27.174 --> 00:43:29.910 
我們還會介紹紋理繪圖樣例

00:43:30.611 --> 00:43:31.812 
爲了進入3D

00:43:32.446 --> 00:43:34.948 
我們已經指定了我們的頂點在截圖空間

00:43:35.015 --> 00:43:37.751 
我們現在需要在一個模型本地空間指定

00:43:38.185 --> 00:43:42.923 
然後用一個合適的模型視圖做投影矩陣

00:43:43.190 --> 00:43:45.158 
爲了回到截取空間

00:43:45.926 --> 00:43:48.929 
同時我們將給普通頂點添加屬性

00:43:49.196 --> 00:43:51.665 
和紋理座標 這樣我們可以

00:43:51.732 --> 00:43:54.601 
在我們的fragmentFunction中
設置光照

00:43:54.735 --> 00:43:57.070 
和設置紋理映射

00:43:58.272 --> 00:44:00.641 
這裏是我們擴展過的頂點

00:44:00.941 --> 00:44:05.012 
我們移去了顏色屬性 添加進一個向量

00:44:05.345 --> 00:44:07.381 
和一組紋理座標

00:44:08.549 --> 00:44:11.185 
和2D中的相似

00:44:11.585 --> 00:44:16.857 
我們會添加一個新的緩衝
存儲所有需要的常量

00:44:17.224 --> 00:44:21.395 
引用我們的頂點和片段函數

00:44:21.828 --> 00:44:25.165 
用來合適的轉換那些頂點

00:44:25.899 --> 00:44:27.167 
你會發現這個緩存的輪廓

00:44:27.234 --> 00:44:30.704 
是虛線 這是有原因的

00:44:31.805 --> 00:44:34.308 
因爲我們不想創建另一個Metal緩存

00:44:34.775 --> 00:44:37.277 
僅僅是出於要管理這一小部分數據

00:44:37.344 --> 00:44:38.879 
只有幾個矩陣

00:44:38.946 --> 00:44:41.648 
實際上Metal也有很棒的API

00:44:41.915 --> 00:44:45.452 
用來綁定和管理非常小緩存

00:44:47.387 --> 00:44:49.523 
所以 對於小數據

00:44:49.590 --> 00:44:51.258 
小於4K的

00:44:51.725 --> 00:44:54.261 
你可以用這些API設置頂點字節

00:44:54.628 --> 00:44:57.397 
直接把數據的指針傳給他

00:44:57.731 --> 00:44:59.399 
當然需要告訴我們大小

00:44:59.900 --> 00:45:04.204 
Metal會創建和重用緩存

00:45:04.271 --> 00:45:05.472 
包含那些數據

00:45:06.039 --> 00:45:10.244 
你可以指定表的索引

00:45:10.911 --> 00:45:12.012 
這裏設置爲1

00:45:12.079 --> 00:45:14.781 
因爲我們的頂點已經被
綁定在索引0

00:45:15.249 --> 00:45:18.018 
所以我們綁定在1
這樣我能從其中讀取

00:45:18.085 --> 00:45:20.087 
在我們的函數中

00:45:20.721 --> 00:45:24.458 
我們看看函數如何響應

00:45:25.158 --> 00:45:27.327 
開始之前 我們看一個例子

00:45:27.394 --> 00:45:29.997 
如何在應用中調用
setForTextBytes

00:45:30.664 --> 00:45:32.799 
我們創建了Constant結構

00:45:32.866 --> 00:45:34.034 
同時創建

00:45:34.101 --> 00:45:37.171 
包含兩個矩陣相乘

00:45:37.237 --> 00:45:40.641 
通過模型視圖投影和普通矩陣

00:45:40.707 --> 00:45:42.409 
這個矩陣會變換

00:45:42.476 --> 00:45:45.078 
本地空間爲iSpace

00:45:45.546 --> 00:45:47.581 
我們用自己的矩陣工具構造

00:45:47.648 --> 00:45:50.284 
然後把它們相乘

00:45:50.450 --> 00:45:53.987 
最後用setVertexBytes
傳遞結構引用

00:45:54.054 --> 00:45:57.124 
然後Metal會拷貝

00:45:57.191 --> 00:46:00.194 
這個緩存用於繪製

00:46:00.327 --> 00:46:01.995 
在接下的繪製調用

00:46:03.830 --> 00:46:04.731 
現在

00:46:05.832 --> 00:46:09.803 
在去年的 WWDC
我們介紹了Model I/O框架

00:46:10.237 --> 00:46:13.574 
Model I/O包含許多工具

00:46:13.974 --> 00:46:16.043 
最棒的是Model I/O包含

00:46:16.109 --> 00:46:19.980 
可以讓你生成常用圖形的方法

00:46:20.581 --> 00:46:22.449 
由於MetalKit

00:46:22.516 --> 00:46:25.352 
和Metal集成非常緊密

00:46:25.419 --> 00:46:29.990 
你可以創建頂點數據Metal
可以直接渲染

00:46:30.991 --> 00:46:34.494 
我們可以不必手動指定所有頂點

00:46:34.561 --> 00:46:37.731 
我們可以這樣
在一些內容創建包

00:46:38.065 --> 00:46:40.067 
裏面繪製模型 導出

00:46:40.133 --> 00:46:41.368 
然後用Model I/O加載

00:46:41.435 --> 00:46:43.737 
或在這個例子中 用程序生成

00:46:44.938 --> 00:46:46.640 
我們看看代碼

00:46:46.740 --> 00:46:49.843 
想生成些vertexBuffers
表示立方體

00:46:50.477 --> 00:46:53.547 
爲了在Metal中
使用Model I/O

00:46:53.881 --> 00:46:56.450 
我會創建一個MeshBufferAllocator

00:46:57.384 --> 00:47:02.055 
MeshBufferAllocator作爲
Model I/O和Metal間的膠水程序

00:47:02.923 --> 00:47:05.893 
傳遞一個設備給
MeshBufferAllocator

00:47:06.193 --> 00:47:09.263 
然後我們可以讓Model I/O
直接創建Metal緩存

00:47:09.329 --> 00:47:10.898 
然後傳回給我們

00:47:12.999 --> 00:47:16.136 
所以我們用工具方法創建了
MDLMesh

00:47:16.236 --> 00:47:20.174 
boxWithExtent等等
傳進我們的分配器

00:47:20.240 --> 00:47:23.143 
這將會創建一個MDLMesh
一個Model I/O網

00:47:23.644 --> 00:47:26.346 
包含相關數據

00:47:26.780 --> 00:47:30.450 
我們然後用MetalKit的工具類
提取出來

00:47:31.051 --> 00:47:32.853 
就是爲我們提供的

00:47:32.953 --> 00:47:34.154 
這看起來像這樣

00:47:34.254 --> 00:47:36.523 
首先 我們生成了MTKMesh

00:47:36.590 --> 00:47:39.760 
包含我們剛纔創建的MDLMesh
同時包含設備

00:47:42.162 --> 00:47:45.065 
爲了得到vertexBuffer

00:47:45.132 --> 00:47:46.733 
把它放進mesh然後抽出來

00:47:47.267 --> 00:47:49.102 
對於indexBuffer
需要進行類似操作

00:47:49.670 --> 00:47:51.071 
這裏還有幾個參數

00:47:51.138 --> 00:47:52.139 
我們見過

00:47:52.206 --> 00:47:53.574 
繪製調用的時候用的

00:47:54.174 --> 00:47:56.910 
這裏強調一下

00:47:57.077 --> 00:47:59.847 
用Model I/O
生成進程幾何圖形很容易

00:48:00.013 --> 00:48:03.717 
然後可以將緩衝提取出來
直接在Metal中應用

00:48:05.352 --> 00:48:07.287 
下面說說紋理

00:48:07.354 --> 00:48:08.455 
我們有了頂點數據

00:48:08.522 --> 00:48:11.792 
我們想用紋理映射上去 並添加些細節

00:48:11.992 --> 00:48:14.494 
像你知道的那樣
紋理是一塊內存

00:48:14.595 --> 00:48:16.830 
用特定的像素格式預先指定

00:48:16.997 --> 00:48:19.867 
主要用來存儲圖像數據

00:48:20.968 --> 00:48:24.671 
在Metal中 創建一個紋理

00:48:24.738 --> 00:48:25.973 
用描述符對象 很常見

00:48:26.240 --> 00:48:28.509 
特別是Metal紋理描述符

00:48:29.109 --> 00:48:31.245 
紋理描述符是參數對象

00:48:31.311 --> 00:48:34.381 
它把紋理屬性弄在一起 比如高和寬

00:48:34.448 --> 00:48:37.918 
還有像素格式 設備會用

00:48:37.985 --> 00:48:41.588 
它們生成紋理對象：Metal紋理

00:48:42.155 --> 00:48:43.557 
我們看看

00:48:44.525 --> 00:48:46.059 
我們有這些方便的函數

00:48:46.126 --> 00:48:48.695 
在Metal Texture
Descriptor中

00:48:48.762 --> 00:48:51.398 
可以讓你得到一個2D的描述符

00:48:51.932 --> 00:48:55.369 
僅提供必要的參數：高 寬

00:48:55.769 --> 00:48:58.605 
像素格式或者你是否想
mipmapped

00:49:00.641 --> 00:49:04.211 
你可調用設備的newTexture
創建一個新紋理

00:49:04.811 --> 00:49:07.714 
這是一個不包含實際圖像的紋理

00:49:07.781 --> 00:49:11.218 
你需要使用替換區域或者相似的方法

00:49:11.618 --> 00:49:14.321 
你可以查查文檔怎麼做
這裏我們用

00:49:14.388 --> 00:49:17.257 
另一個簡單點的工具

00:49:17.591 --> 00:49:19.293 
叫做TKTextureLoader

00:49:19.359 --> 00:49:22.496 
這是MetalKit提供的工具
用來加載圖像

00:49:22.563 --> 00:49:24.898 
從資源包中 包括資源目錄

00:49:24.965 --> 00:49:27.768 
或者從一個文件URL 還有CG圖像

00:49:27.835 --> 00:49:29.336 
內存中已經有了

00:49:29.403 --> 00:49:31.638 
以NSImage或UIImage
的形式

00:49:32.105 --> 00:49:34.541 
它們生成填充Metal紋理

00:49:34.608 --> 00:49:36.610 
用合適的大小和格式

00:49:36.677 --> 00:49:38.612 
與你已經有的的圖像數據有關

00:49:39.513 --> 00:49:41.114 
我們看看代碼

00:49:41.181 --> 00:49:43.684 
你可以創建一個
MTKTextureLoader

00:49:43.750 --> 00:49:45.252 
通過傳入Metal設備

00:49:45.686 --> 00:49:47.354 
你會得到一個
TextureLoader

00:49:47.554 --> 00:49:50.958 
同時你可以接着或許一個數據集合

00:49:51.024 --> 00:49:52.559 
或你的集合目錄中的其他東西

00:49:52.626 --> 00:49:54.127 
一旦你拿到了數據

00:49:54.194 --> 00:49:57.197 
你可調用textureLoader.newTexture

00:49:57.531 --> 00:50:00.434 
然後傳遞數據
那麼將會返回一個Metal紋理

00:50:03.971 --> 00:50:07.508 
你可能熟悉取樣的概念

00:50:07.574 --> 00:50:10.143 
Samplers和Metal
從紋理來說不同

00:50:10.210 --> 00:50:12.112 
他們沒有綁定在一起

00:50:13.313 --> 00:50:16.550 
Samplers只包含
紋理相關的取樣狀態

00:50:16.617 --> 00:50:20.454 
一些如過濾模式 地址模式

00:50:20.521 --> 00:50:22.322 
還有層級詳細的參數

00:50:22.489 --> 00:50:24.791 
這裏展示的我們都支持

00:50:26.126 --> 00:50:28.996 
爲了獲得我們竟來要綁定
的Sampler狀態

00:50:29.062 --> 00:50:31.765 
在Render Command
encoder中做紋理繪製

00:50:32.266 --> 00:50:34.668 
我們會創建一個
Metal Sampler Descriptor

00:50:34.735 --> 00:50:36.036 
像這樣

00:50:36.436 --> 00:50:39.072 
我們創建了個空的Metal Sampler Descriptor

00:50:39.139 --> 00:50:40.707 
擁有默認的屬性

00:50:40.774 --> 00:50:42.643 
我們可以設置想要的屬性

00:50:42.709 --> 00:50:45.412 
這裏我們讓紋理在各個軸

00:50:45.479 --> 00:50:46.747 
上重複

00:50:47.314 --> 00:50:50.050 
當縮小的時候使用
nearest filtering

00:50:50.117 --> 00:50:52.219 
當放大時用
linear filtering

00:50:52.853 --> 00:50:54.988 
一旦我們創建了描述符對象

00:50:55.355 --> 00:50:56.523 
我們調用
newSamplerState

00:50:56.590 --> 00:50:59.193 
得到
Metal Sampler State對象

00:50:59.493 --> 00:51:03.630 
我們可以用來在紋理中綁定採樣

00:51:04.765 --> 00:51:07.367 
在Render Command Encoder中
API看起來像這樣

00:51:07.434 --> 00:51:11.338 
我們創建一個紋理 把它放在
插槽0

00:51:11.839 --> 00:51:13.774 
在片段紋理參數表中

00:51:14.808 --> 00:51:18.745 
然後我們綁定Sampler
State在索引0

00:51:18.912 --> 00:51:21.849 
在Sampler State
參數表中

00:51:23.750 --> 00:51:25.886 
我們看看這些函數

00:51:26.720 --> 00:51:29.122 
頂點函數這次會和

00:51:29.189 --> 00:51:32.893 
MVP矩陣相乘
矩陣從constant buffer中獲得

00:51:33.360 --> 00:51:35.229 
它會變換頂點的位置

00:51:35.295 --> 00:51:37.197 
從本地空間到截取空間

00:51:37.497 --> 00:51:40.701 
我們會從頂點函數返回

00:51:40.767 --> 00:51:42.736 
同時它還會變換那些頂點

00:51:42.803 --> 00:51:44.505 
從Models Local
Space到Eye Space

00:51:44.571 --> 00:51:46.240 
然後我們做光照渲染

00:51:46.406 --> 00:51:47.975 
代碼裏看起來是這樣

00:51:48.108 --> 00:51:51.612 
我們添加了一個參數屬性通過緩存1

00:51:51.678 --> 00:51:54.815 
像我之前說的通過
constants緩存獲得

00:51:54.882 --> 00:51:56.283 
我們已創建了一個結構類型

00:51:56.850 --> 00:51:58.752 
在我們的Metal着色代碼中

00:51:58.819 --> 00:52:01.455 
和SWF代碼中創建
constant結構關聯起來

00:52:01.622 --> 00:52:04.958 
這樣我們可得到
MVP通過普通的矩陣

00:52:05.192 --> 00:52:08.028 
再一次 這個綁定在索引1的參數表

00:52:08.328 --> 00:52:11.031 
和你看到的屬性關聯起來

00:52:12.199 --> 00:52:16.103 
爲了進入截取空間

00:52:16.170 --> 00:52:18.605 
獲取vertexBuffer
位於VertexID的索引

00:52:18.872 --> 00:52:20.107 
得到一個位置向量

00:52:20.207 --> 00:52:23.343 
和MVP矩陣相乘然後賦值給結構

00:52:23.944 --> 00:52:25.445 
對普通的 進行相同的操作

00:52:27.281 --> 00:52:29.283 
我們還拷貝紋理座標

00:52:29.349 --> 00:52:31.051 
給傳出結構

00:52:31.118 --> 00:52:33.954 
這些都會被光柵插值

00:52:34.021 --> 00:52:35.889 
我們接着進行返回結構

00:52:36.256 --> 00:52:39.359 
fragmentFunction
比之前更參與

00:52:39.760 --> 00:52:42.095 
我們想要計算些光照

00:52:42.162 --> 00:52:44.865 
我們引用兩種環境光和漫反射

00:52:45.399 --> 00:52:48.001 
同時從紋理中採樣

00:52:48.435 --> 00:52:50.838 
應用到表面紋理中

00:52:51.405 --> 00:52:52.439 
像這樣

00:52:52.506 --> 00:52:55.142 
我們不會詳細介紹

00:52:55.742 --> 00:52:57.244 
需要注意的是

00:52:57.311 --> 00:52:59.413 
我們添加了一個參數

00:52:59.479 --> 00:53:00.981 
我們創建和綁定的

00:53:01.181 --> 00:53:03.617 
我們給它一個訪問標識符

00:53:03.717 --> 00:53:05.185 
我們用來採樣

00:53:05.586 --> 00:53:07.788 
在Argument Table Index的0位置

00:53:07.855 --> 00:53:09.556 
我們創建的
Sampler State在

00:53:09.623 --> 00:53:13.827 
samplers的Argument
Slot Zero

00:53:13.894 --> 00:53:18.098 
想獲得實際的文本

00:53:18.565 --> 00:53:20.601 
調用紋理的Sample

00:53:20.667 --> 00:53:24.004 
Text2D.Sample
有個採樣狀態

00:53:24.872 --> 00:53:28.442 
和紋理座標給到顏色向量

00:53:30.344 --> 00:53:33.580 
我們接着做光照

00:53:33.647 --> 00:53:35.382 
我不會詳細介紹

00:53:35.449 --> 00:53:39.119 
它根據正常和光照方向的積來得到

00:53:39.186 --> 00:53:41.922 
我們設置了一些常量

00:53:42.022 --> 00:53:45.559 
在我們之前的着色文件
演示中可以看到

00:53:46.126 --> 00:53:47.494 
這相當多

00:53:47.561 --> 00:53:52.165 
我們構造特定片段的顏色

00:53:52.366 --> 00:53:54.835 
通過乘以從紋理中採樣的值

00:53:54.935 --> 00:54:00.340 
通過光照反映到動畫紋理的立方體上

00:54:00.707 --> 00:54:03.510 
現在讓Matt給大家展示下

00:54:05.379 --> 00:54:07.481 
好的 我們看看演示

00:54:07.881 --> 00:54:09.583 
這裏有個Metal紋理網

00:54:09.683 --> 00:54:11.718 
你可以看到
它是個很複雜的立方體

00:54:11.952 --> 00:54:13.854 
一些簡單的光照和紋理貼圖

00:54:13.921 --> 00:54:15.923 
在一個設置好顏色的背景上

00:54:18.458 --> 00:54:19.860 
欣賞下它

00:54:19.927 --> 00:54:22.563 
我們看看着色器

00:54:23.297 --> 00:54:26.233 
比起上一次 你能看到一些新的東西

00:54:26.300 --> 00:54:28.869 
首先是Constants結構體

00:54:29.136 --> 00:54:30.704 
是Swift寫的

00:54:30.771 --> 00:54:33.173 
有4 X 4的模型投影矩陣

00:54:33.473 --> 00:54:37.010 
和3 X 3的普通矩陣
它們是用來做變換的

00:54:37.744 --> 00:54:40.714 
如Warren所說
我們有些光照數據

00:54:41.215 --> 00:54:43.350 
環境光強度 這裏很弱

00:54:43.417 --> 00:54:45.452 
但漫射光 卻很高

00:54:45.519 --> 00:54:47.321 
光的方向

00:54:47.387 --> 00:54:49.256 
我們用來計算點積

00:54:51.158 --> 00:54:52.893 
輸入和輸出結構有點不同

00:54:52.960 --> 00:54:55.762 
我們現在有更多的信息需要向下傳遞

00:54:55.829 --> 00:54:56.697 
我們有position

00:54:56.763 --> 00:54:58.298 
有normal 用來光照

00:54:58.365 --> 00:55:01.368 
和紋理座標 用來紋理貼圖

00:55:01.435 --> 00:55:04.137 
相似的 當從頂點函數輸出時

00:55:05.472 --> 00:55:06.640 
我們需要相似的數據

00:55:06.773 --> 00:55:08.575 
我們看下頂點函數

00:55:08.642 --> 00:55:09.476 
如Warren所說

00:55:10.010 --> 00:55:12.679 
就是些簡單的矩陣 乘法運算

00:55:12.746 --> 00:55:15.315 
然後傳給紋理座標

00:55:16.083 --> 00:55:18.151 
快速的看下片段函數

00:55:18.218 --> 00:55:20.287 
就是剛纔給你展示的

00:55:22.256 --> 00:55:24.291 
我們看看渲染器

00:55:26.326 --> 00:55:27.828 
接着往前

00:55:28.962 --> 00:55:30.097 
我們有個小動畫

00:55:30.163 --> 00:55:33.867 
所以我們需要每段時間更新
我們需要知道立方體需要旋轉多少

00:55:34.568 --> 00:55:36.069 
這裏有個幫助函數

00:55:36.136 --> 00:55:38.305 
來更是時間間隔

00:55:41.308 --> 00:55:43.043 
這將修改Constants

00:55:43.777 --> 00:55:45.946 
像Warren說的
我們不想讓很多數據通過GPU傳遞

00:55:46.013 --> 00:55:48.448 
所以當你設置頂點字節

00:55:48.849 --> 00:55:51.885 
傳一個小的結構 之前的兩個矩陣

00:55:52.519 --> 00:55:57.090 
我們用來計算變動的位置

00:55:58.325 --> 00:56:00.827 
放入紋理和採樣 觸發繪製

00:56:01.195 --> 00:56:02.763 
我建議你們記住

00:56:02.829 --> 00:56:04.631 
用你的調試組 這樣你可以知道

00:56:04.865 --> 00:56:07.935 
現在在什麼位置
如果你想稍後捕獲幀的話

00:56:08.001 --> 00:56:11.104 
展示繪製內容 提交 然後就可以了

00:56:14.741 --> 00:56:15.909 
很棒 謝謝 Matt

00:56:19.847 --> 00:56:21.782 
通過這些使用Metal的課程

00:56:22.349 --> 00:56:25.586 
我們想充分利用我們這幾年的

00:56:25.652 --> 00:56:27.087 
成果 教授Metal

00:56:27.454 --> 00:56:29.323 
同時介紹非常棒的新工具

00:56:29.590 --> 00:56:31.225 
讓Metal更容易使用

00:56:31.325 --> 00:56:32.793 
我們希望

00:56:33.126 --> 00:56:35.395 
這兩部分課程對此有幫助

00:56:35.696 --> 00:56:38.799 
你看到Metal是強大的低負載的

00:56:38.866 --> 00:56:42.369 
GPU編程技術 幸運的

00:56:42.436 --> 00:56:45.172 
你現在已經熟悉它

00:56:45.239 --> 00:56:46.707 
其中的一些API

00:56:48.242 --> 00:56:50.143 
Metal非常接近

00:56:50.210 --> 00:56:52.980 
和符合GPU的實際運轉情況

00:56:53.347 --> 00:56:57.584 
概念上也是這樣 我們想把

00:56:57.651 --> 00:57:00.654 
耗費資源的操作儘可能提前

00:57:00.754 --> 00:57:02.389 
你已經看到了幾種方式

00:57:02.456 --> 00:57:04.892 
怎麼安排這些API

00:57:05.325 --> 00:57:09.429 
這個課程不是強調一些限制和細節

00:57:09.496 --> 00:57:10.564 
主要是

00:57:10.631 --> 00:57:12.132 
想給你灌輸些能力

00:57:12.533 --> 00:57:14.401 
你已經看到如何明確的
進行內存管理

00:57:14.468 --> 00:57:17.337 
和指令提交 可以讓你的工作更智能些

00:57:17.404 --> 00:57:19.740 
如果你知道你的應用是怎麼回事

00:57:19.806 --> 00:57:22.209 
你知道它在做什麼 然後你可以

00:57:22.409 --> 00:57:25.479 
直接控制GPU

00:57:26.713 --> 00:57:30.117 
當然接下來的幾節關於Metal課程

00:57:30.517 --> 00:57:33.420 
在今年的 WWDC
我們會給你展示更多

00:57:33.487 --> 00:57:34.821 
的Metal的內容

00:57:35.055 --> 00:57:38.492 
當然 它會讓你創建有更好體驗的應用

00:57:38.825 --> 00:57:41.328 
想要了解更多的關於602會話的信息

00:57:41.395 --> 00:57:44.998 
你可以訪問這個URL
同時可以參考其他相關課程

00:57:45.332 --> 00:57:48.936 
第二部分還會在這個教室

00:57:49.736 --> 00:57:53.307 
明天我們會有
Metal的新東西Parts I和II

00:57:54.007 --> 00:57:57.377 
和高級Metal着色優化課程

00:57:57.711 --> 00:57:59.947 
謝謝
祝你們在 WWDC 中大有收穫