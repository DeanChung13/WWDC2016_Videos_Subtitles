00:00:19.353 --> 00:00:23.357
Core Data的新特性

00:00:23.423 --> 00:00:24.892
大家好

00:00:30.964 --> 00:00:33.367
我是Melissa
Core Data工程師

00:00:33.767 --> 00:00:35.903
不誇張地說這是第一年
上臺前沒有人跟我說

00:00:35.969 --> 00:00:37.971
祝你好運

00:00:38.038 --> 00:00:41.575
因爲我實際一個月前腿折了
這是我第一天脫離石膏繃帶

00:00:41.975 --> 00:00:44.311
所以如果我一瘸一拐
你們知道是怎麼回事

00:00:47.915 --> 00:00:49.917
在Core Data團隊工作
最好的是

00:00:49.983 --> 00:00:52.286
實際上每年能站在這個舞臺上

00:00:52.352 --> 00:00:55.289
告訴大家我們都做了
哪些新鮮有趣的事情

00:00:55.355 --> 00:00:58.292
不可思議 我們今年做了
很多 而且都非常有用

00:00:58.358 --> 00:00:59.960
我們希望大家喜歡這些新內容

00:01:01.195 --> 00:01:03.630
好 我要介紹一項新功能
查詢生成

00:01:03.997 --> 00:01:06.099
Core Data併發領域的
一些變化

00:01:06.633 --> 00:01:08.502
我要介紹我們
在Core Data堆棧配置領域

00:01:08.569 --> 00:01:10.704
的一些新進展

00:01:10.771 --> 00:01:12.206
及我們新添加的一些API

00:01:12.806 --> 00:01:15.542
我們也會簡單介紹下
爲了更靈巧利落地

00:01:15.609 --> 00:01:17.744
與Swift集成
我們都做了哪些事情

00:01:18.011 --> 00:01:21.782
還有我們在Xcode集成
方面的一些改進

00:01:22.683 --> 00:01:26.420
內容不少 現在第一項 查詢生成

00:01:27.554 --> 00:01:29.423
查詢生成是我們添加的一項新功能

00:01:29.489 --> 00:01:32.059
不過在開始介紹查詢生成前

00:01:32.125 --> 00:01:33.727
我需要簡單介紹下fault

00:01:34.394 --> 00:01:37.264
可能有人知道
Core Data常使用fault

00:01:38.265 --> 00:01:41.602
管理對象可能是fault
它們之間的關係可能是fault

00:01:41.668 --> 00:01:43.470
如果你在使用批量提取

00:01:43.537 --> 00:01:45.005
那你執行抓取請求獲得的陣列

00:01:45.072 --> 00:01:47.708
從NSManagedObjectContext

00:01:47.774 --> 00:01:49.510
也會是
一種非常特殊的fault

00:01:49.910 --> 00:01:52.746
話雖這麼說 什麼是fault？

00:01:53.013 --> 00:01:57.351
現在 在屏幕上
有一張對象圖

00:01:57.417 --> 00:01:59.486
其中有國家 美國

00:01:59.920 --> 00:02:03.457
州 加利福尼亞 若干的郡
聖克拉拉和舊金山

00:02:03.790 --> 00:02:07.861
以及聖克拉拉的若干
城市 聖何塞和庫比蒂諾

00:02:08.662 --> 00:02:11.765
這很像是旅遊指南
指南書籍的一部分

00:02:12.099 --> 00:02:15.502
你可以翻開 瀏覽
從而在你計劃遊玩的

00:02:15.569 --> 00:02:18.505
城市中找到
你感興趣的地方

00:02:19.606 --> 00:02:22.476
不過 僅基於我們
對美國的瞭解

00:02:22.543 --> 00:02:23.911
這不是完整的對象圖

00:02:23.977 --> 00:02:26.780
實際上只是對象圖的一部分
是子圖

00:02:26.847 --> 00:02:29.283
因爲我們知道美國有其他州

00:02:29.349 --> 00:02:31.618
這些州有其他郡

00:02:31.685 --> 00:02:34.054
這些郡有其他城市

00:02:34.454 --> 00:02:35.756
你也知道 除此之外

00:02:35.822 --> 00:02:38.792
我們知道美國只是
衆多國家之一

00:02:40.627 --> 00:02:42.996
即使是在指南書籍中
我一次想看的

00:02:43.063 --> 00:02:44.464
也僅是一個數據集

00:02:44.531 --> 00:02:46.166
如果我計劃到聖何塞旅行

00:02:46.233 --> 00:02:49.703
我不會關心俄勒岡或華盛頓
或其它類似的地方

00:02:49.770 --> 00:02:51.505
我甚至不會關心舊金山

00:02:52.072 --> 00:02:55.676
我需要能夠鎖定這些對象
到達這些目的地

00:02:55.742 --> 00:02:56.910
如果我感興趣

00:02:56.977 --> 00:02:59.613
我可以隨後改主意
改變想要瀏覽的內容

00:02:59.680 --> 00:03:01.915
但就目前短期而言
當我在計劃

00:03:01.982 --> 00:03:05.452
到聖克拉拉的旅行時
我不在意其它地方

00:03:06.386 --> 00:03:09.890
這種不在意
在內存中表示爲

00:03:09.957 --> 00:03:12.860
fault
它是一種對象

00:03:12.926 --> 00:03:16.530
瞭解在隨後的某個
時間點如何開始檢索數據

00:03:16.597 --> 00:03:18.098
如果我確定我想使用它

00:03:18.165 --> 00:03:20.267
比如 我發現我朋友
要結婚了

00:03:20.334 --> 00:03:22.402
婚禮在西雅圖 我想去

00:03:22.469 --> 00:03:23.837
計劃到西雅圖的旅行

00:03:24.271 --> 00:03:26.440
此時 我會再次瀏覽美國

00:03:26.507 --> 00:03:28.308
下一層
我想瀏覽華盛頓州

00:03:28.375 --> 00:03:31.445
Core Data會自動檢索

00:03:31.512 --> 00:03:35.182
關於華盛頓的信息
即使當我首次加載子圖時

00:03:35.249 --> 00:03:37.317
華盛頓信息不在內存中

00:03:37.751 --> 00:03:41.021
你知道 我可以接着向下瀏覽
等等...

00:03:41.655 --> 00:03:44.992
這就是fault
它是未來 或承諾

00:03:45.058 --> 00:03:46.193
或延遲加載

00:03:46.260 --> 00:03:49.196
這些不同的名稱
指的都是同樣的東西

00:03:49.263 --> 00:03:51.498
Core Data可進行這操作
幫你儘量減少

00:03:51.565 --> 00:03:53.333
在任意給定時間點
內存中的數據量

00:03:54.635 --> 00:03:55.569
我們爲什麼使用fault？

00:03:55.636 --> 00:03:58.805
答案是 性能 性能 性能
還是性能

00:04:00.007 --> 00:04:01.942
性能最好的應用

00:04:02.009 --> 00:04:03.944
是那些不做任何額外功的應用

00:04:04.711 --> 00:04:07.948
你不會在iobus上加載
任何不需要的對象

00:04:08.015 --> 00:04:11.051
你不會在不需要的對象上
花費任何時間

00:04:11.552 --> 00:04:14.955
你也不想
在用戶不注意的時候

00:04:15.022 --> 00:04:16.656
這些對象閒置在那裏

00:04:17.057 --> 00:04:18.926
推高你的內存佔用

00:04:19.159 --> 00:04:21.528
不過fault有一個小問題

00:04:22.262 --> 00:04:23.564
基本上是這樣的

00:04:23.864 --> 00:04:25.999
這裏我們再看對象圖

00:04:26.500 --> 00:04:28.902
在這個案例中
我們有很多fault

00:04:29.369 --> 00:04:31.872
我順着樹形結構向下瀏覽
來到聖克拉拉

00:04:31.939 --> 00:04:34.041
我想啓動
庫比蒂諾fault

00:04:34.508 --> 00:04:35.609
但同時

00:04:36.076 --> 00:04:38.612
一個外部過程已經
開始從網站導入數據

00:04:38.679 --> 00:04:40.881
而且不知爲何
庫比蒂諾被刪除了

00:04:41.315 --> 00:04:42.916
發生了什麼？

00:04:42.983 --> 00:04:44.518
我有一個fault
它應開始

00:04:44.585 --> 00:04:47.254
檢索關於
庫比蒂諾的信息

00:04:47.321 --> 00:04:49.223
但那裏卻沒有任何信息了

00:04:50.390 --> 00:04:53.126
我說過 我多次介紹
不要加載不需要的數據

00:04:53.193 --> 00:04:55.195
但在這個案例中
你會問自己

00:04:55.262 --> 00:04:58.432
我是不是實際上需要
那個數據呢？

00:04:59.499 --> 00:05:00.334
哎喲

00:05:02.736 --> 00:05:03.937
現在Core Data中

00:05:04.071 --> 00:05:06.840
通過NSManagedObjectContext
上的shouldDeleteInaccessibleFaults

00:05:06.907 --> 00:05:08.642
屬性 你可以應對這種情況

00:05:09.142 --> 00:05:11.478
如果你設置了這個屬性
然後當上下文注意到

00:05:11.545 --> 00:05:14.147
你正在試圖啓動
已刪除對象的fault

00:05:14.214 --> 00:05:16.049
上下文會將fault
標記爲已刪除

00:05:16.116 --> 00:05:18.819
並將fault的所有屬性
標記爲零

00:05:19.186 --> 00:05:22.189
大多情況下 這就是你需要的
但有時候這也會不便利

00:05:22.256 --> 00:05:25.726
因爲你的UI不知道如何處理
爲零的標識符

00:05:26.293 --> 00:05:28.562
另一種方法是
預提取所有內容

00:05:28.629 --> 00:05:31.431
使用關係小鍵盤進行預提取
從而加載你認爲你用戶

00:05:31.498 --> 00:05:33.800
可能需要的所有對象

00:05:34.034 --> 00:05:35.736
這樣 你的任務就升級了

00:05:35.802 --> 00:05:38.071
你需要更努力瞭解
確切地

00:05:38.505 --> 00:05:40.107
預測用戶未來可能的需要

00:05:40.340 --> 00:05:42.676
這會很棘手 我們都知道
用戶是不可預測的

00:05:43.277 --> 00:05:44.945
另一種方法
存在第三種方法

00:05:45.012 --> 00:05:47.181
始終都存在第三種方法
就是寫很多代碼

00:05:47.381 --> 00:05:49.349
首先在管理對象上下文中

00:05:49.416 --> 00:05:51.919
使用帶ID的既有對象
確保在嘗試fault前

00:05:51.985 --> 00:05:53.787
對象位於數據庫中

00:05:54.488 --> 00:05:55.956
編寫很多try catch

00:05:56.156 --> 00:05:58.859
圍繞着所有fault啓動的
異常處理程序

00:05:58.926 --> 00:06:01.028
實話說 這個代碼寫起來
可不怎麼有意思

00:06:01.094 --> 00:06:03.463
你實際上會更願意
寫一些用戶會使用的

00:06:03.530 --> 00:06:05.766
有趣功能
因爲那纔是用戶

00:06:05.832 --> 00:06:08.001
使用你應用的原因
即你的應用提供靈巧功能

00:06:08.635 --> 00:06:09.970
不過讓我們後退一步

00:06:10.037 --> 00:06:13.006
稍稍想一下你的用戶
與你應用的交互

00:06:14.308 --> 00:06:16.510
用戶視圖和UI
通常不關心

00:06:16.577 --> 00:06:20.180
是否看到絕對的最近
最新和最快的數據

00:06:20.247 --> 00:06:21.448
我們怎麼知道這一點？

00:06:22.449 --> 00:06:24.284
讓我們先想想氣泵

00:06:24.852 --> 00:06:28.322
大多數人對氣泵很熟悉
你有時會給汽車加油

00:06:28.822 --> 00:06:30.858
氣泵的顯示屏會告訴你

00:06:30.924 --> 00:06:33.627
你實際已經給汽車加了
多少加侖或升的油

00:06:34.127 --> 00:06:36.763
顯示數字有千分位

00:06:37.197 --> 00:06:40.634
我想問下大家
在給車加油時

00:06:41.301 --> 00:06:43.537
誰能實時讀到
千分位請舉手

00:06:44.071 --> 00:06:46.240
正如我所料
沒有人能做到

00:06:46.306 --> 00:06:48.775
人類大腦喜歡數字

00:06:48.842 --> 00:06:50.577
以一定間隔整齊排列
這樣容易理解

00:06:51.111 --> 00:06:54.648
所以用戶實際不需要最近
最新的數據 他們只需要數據...

00:06:55.482 --> 00:06:56.884
合理快速地更新

00:06:57.918 --> 00:07:00.320
保存數據的用戶
對此也不在乎

00:07:00.420 --> 00:07:02.189
正因如此
Core Data纔有合併策略

00:07:02.256 --> 00:07:04.658
這些策略規定進行一連串
編輯並將這些編輯保存

00:07:04.725 --> 00:07:06.493
並與數據庫中的內容混合

00:07:06.560 --> 00:07:07.928
以及產生預期的效果

00:07:08.529 --> 00:07:11.665
你可以選擇你需要的合併策略
因爲你比我們更瞭解你的用戶

00:07:13.100 --> 00:07:16.069
那麼 如果我們能夠汲取這個
洞見並進一步延伸會怎樣？

00:07:16.737 --> 00:07:19.306
如果我們有方法
使你通過UI看到數據庫中

00:07:19.373 --> 00:07:21.508
數據的穩定視圖
會怎樣？

00:07:22.543 --> 00:07:24.344
如果我們有方法
應對變化

00:07:24.411 --> 00:07:26.146
更確定地更新變化
會怎樣？

00:07:27.347 --> 00:07:30.284
如果我們能做到所有這些
你不會再看到這個 會怎樣？

00:07:36.590 --> 00:07:38.559
現在 我可以介紹
查詢生成了

00:07:39.660 --> 00:07:40.928
查詢生成是一種方法

00:07:40.994 --> 00:07:43.397
能使你的管理對象上下文

00:07:43.463 --> 00:07:46.366
基本上 執行讀取數據庫中
數據的操作

00:07:46.834 --> 00:07:48.802
所有向管理對象
上下文的讀取操作

00:07:48.869 --> 00:07:52.606
都將看到同樣的數據視圖
直到你選擇向前進

00:07:52.840 --> 00:07:55.576
你永遠不會再看到
無法完成fault的消息

00:07:56.043 --> 00:07:57.978
而且重要的是
我們能高效完成這一操作

00:07:58.345 --> 00:08:00.080
這永遠都是棘手的部分

00:08:01.348 --> 00:08:02.182
這些是怎麼實現的？

00:08:02.249 --> 00:08:06.153
這裏有一個數據庫 裏面有
一個對象id是1名字是fred

00:08:06.220 --> 00:08:07.988
因爲這些是幻燈片

00:08:08.488 --> 00:08:09.356
我將進行刪減

00:08:09.423 --> 00:08:11.491
因爲我需要完成此構建
需要的所有資產

00:08:12.826 --> 00:08:15.262
在傳統數據庫中
這就是你得到的

00:08:15.329 --> 00:08:17.698
你有一個文件 該文件有
對所有數據的單一視圖

00:08:18.131 --> 00:08:19.800
但是使用查詢生成

00:08:20.367 --> 00:08:23.570
那就變成了你數據庫中的
第一代數據

00:08:25.038 --> 00:08:27.708
隨着過程的進行
這可能會成爲你的應用

00:08:27.774 --> 00:08:30.978
它可以是導入程序
可以是watch上的擴展

00:08:31.044 --> 00:08:33.013
某物對數據庫進行修改

00:08:34.881 --> 00:08:36.383
新一代創建了

00:08:37.650 --> 00:08:40.754
而且更多的數據被創建
新的對象

00:08:41.054 --> 00:08:44.525
此時 用戶啓動你的應用

00:08:47.194 --> 00:08:49.696
創建管理對象上下文
你加載數據

00:08:50.130 --> 00:08:51.598
該上下文現在知道

00:08:51.665 --> 00:08:54.535
它是從數據庫中的哪一代
加載數據

00:08:54.968 --> 00:08:59.306
所以隨着其他過程或上下文
等的繼續進行

00:08:59.373 --> 00:09:01.742
並進一步修改數據庫

00:09:03.143 --> 00:09:06.847
更多代的數據被創建
該上下文仍然知道它所屬的代

00:09:06.914 --> 00:09:11.685
第二個上下文出現
加載一些數據 進行一些編輯

00:09:12.719 --> 00:09:16.223
進行保存 保存之後
便創建了新一代

00:09:16.290 --> 00:09:19.493
並追蹤它現在
代表的一代

00:09:19.560 --> 00:09:21.361
在本例中
是數據庫中的第6代

00:09:21.828 --> 00:09:25.299
此時 如果我們
在上下文1中啓動fault

00:09:25.365 --> 00:09:27.167
即使fault對應的對象

00:09:27.234 --> 00:09:29.570
可能在第6代中
已經被刪除

00:09:29.636 --> 00:09:32.673
上下文中仍可看到該對象
因爲它仍然在數據庫中

00:09:32.739 --> 00:09:34.341
就在標籤第3代下

00:09:35.576 --> 00:09:39.313
此時 用戶可以
在上下文1中略微編輯

00:09:39.379 --> 00:09:43.383
刪除一些對象 更改一些對象
插入新的對象

00:09:43.684 --> 00:09:47.054
當保存上下文時
Core Data將使用合併策略

00:09:47.120 --> 00:09:50.190
將所有這些變更
與數據庫中的內容合併

00:09:50.991 --> 00:09:53.260
並創建新的第7代

00:09:55.462 --> 00:09:57.197
以與上下文1
相同的

00:10:00.367 --> 00:10:03.604
上下文1
在固定到第3代時

00:10:03.670 --> 00:10:05.672
能夠看到第3代
同樣地

00:10:06.240 --> 00:10:09.810
上下文2能夠對其對象
作出任意操作

00:10:09.877 --> 00:10:12.212
將對象變成fault
重新啓動這些fault

00:10:12.279 --> 00:10:14.448
且上下文2將仍能看到

00:10:14.515 --> 00:10:16.550
數據庫第6代中的數據

00:10:17.618 --> 00:10:20.387
所以 基本上
它是管理對象上下文級別的

00:10:20.454 --> 00:10:22.155
完全讀取事務

00:10:22.923 --> 00:10:25.993
我們長篇介紹了
爲什麼上下文

00:10:26.426 --> 00:10:27.928
本質上是對的事務

00:10:27.995 --> 00:10:30.030
現在我們也將它們變成讀取事務

00:10:30.097 --> 00:10:34.001
使你能夠在上下文的
級別上立即隔離你的工作

00:10:34.067 --> 00:10:38.205
並最小化預防性預提取等
這意味着 所有人都獲益

00:10:40.274 --> 00:10:41.108
基本要點

00:10:41.175 --> 00:10:43.844
單個上下文
可以選擇想要的行爲

00:10:44.311 --> 00:10:46.914
它可以決定它想要

00:10:46.980 --> 00:10:51.251
你在iOS 9和macOS 11上
適應的當前行爲

00:10:52.553 --> 00:10:55.689
我們稱爲已取消固定 注意看
加載數據時樹形結構頂端

00:10:55.756 --> 00:10:57.624
你也可以指定
上下文應固定到

00:10:57.691 --> 00:10:59.893
數據庫中任意當前的世代

00:10:59.960 --> 00:11:02.362
當數據首次加載到
該上下文時

00:11:02.429 --> 00:11:05.832
或者 你可以指定
你想要它固定到特定世代

00:11:05.899 --> 00:11:08.402
如果另一個上下文
固定到該世代

00:11:09.570 --> 00:11:12.639
嵌套上下文
將繼承父級的世代

00:11:12.940 --> 00:11:15.676
它們悄悄取消固定
但是能夠看到

00:11:15.742 --> 00:11:18.145
通過父級世代查看的數據

00:11:18.212 --> 00:11:21.949
以及父級閒置未保存的
任何掛起的變更

00:11:24.818 --> 00:11:27.187
更新一定程度上很重要
我們都認可這一點

00:11:27.254 --> 00:11:28.488
用戶不想看到更新

00:11:28.555 --> 00:11:30.991
最終 他們不希望看到10年前的數據

00:11:32.526 --> 00:11:35.262
世代的更新
發生在你通過設置

00:11:35.329 --> 00:11:37.664
新世代標記
明確告訴上下文更新時

00:11:37.731 --> 00:11:38.999
它們在保存時更新

00:11:39.466 --> 00:11:42.703
它們在你調用mergeChanges時更新
這時它們將更新至樹的頂端

00:11:42.769 --> 00:11:44.371
既然你已經告訴上下文

00:11:44.438 --> 00:11:47.541
你知道它應該在查看
數據庫中的一組新變化

00:11:47.841 --> 00:11:50.711
它的更新是調用重置引起的

00:11:53.714 --> 00:11:55.382
需要注意的是

00:11:55.983 --> 00:11:57.618
當你更新世代時

00:11:57.684 --> 00:12:00.420
已註冊的對象不會被刷新
你可能不想要那樣

00:12:00.654 --> 00:12:02.623
我們可以很輕鬆地
讓你這麼做

00:12:02.689 --> 00:12:05.759
如果我們選擇代你做
再讓你取消難度會加大很多

00:12:06.727 --> 00:12:08.095
如果你想要刷新數據

00:12:08.161 --> 00:12:10.831
你必須調用fetch或
refreshAllObjects

00:12:10.898 --> 00:12:14.334
但是當數據實際得到更新時
這樣會使你獲得控制

00:12:16.069 --> 00:12:19.173
如果你想使用查詢生成
你必須使用SQL store

00:12:19.239 --> 00:12:21.175
且SQL store應在
wall模式下

00:12:21.241 --> 00:12:22.843
儘管如果你
嘗試使用查詢生成

00:12:22.910 --> 00:12:25.846
你並未滿足上述兩項要求
系統會正常退出

00:12:25.913 --> 00:12:27.614
只是恢復到
已取消固定的行爲

00:12:29.216 --> 00:12:30.184
我們是如何做的？

00:12:30.250 --> 00:12:33.420
好 現在有一種opaque
標記 你可以使用它

00:12:33.487 --> 00:12:34.755
跟蹤查詢生成

00:12:34.821 --> 00:12:39.059
這將告訴上下文 什麼時候
從什麼存儲加載了數據

00:12:40.594 --> 00:12:43.463
查詢生成標記
有一個方法current

00:12:43.530 --> 00:12:45.399
你可以使用它檢索標記

00:12:45.465 --> 00:12:47.801
以表明在它加載數據時
上下文應固定

00:12:50.070 --> 00:12:52.439
ManagedObjectContext
我們有若干新方法

00:12:52.506 --> 00:12:54.274
有一個屬性
QueryGenerationToken

00:12:54.341 --> 00:12:58.078
它將會告訴你 上下文
正在使用哪個查詢生成

00:12:58.478 --> 00:13:00.547
如果上下文取消固定
則該屬性爲零

00:13:01.048 --> 00:13:03.283
你可以由標記設置查詢生成

00:13:03.350 --> 00:13:07.020
或者是來自類屬性的
current標記

00:13:07.354 --> 00:13:09.122
或是在另一個管理對象上下文調用

00:13:09.189 --> 00:13:10.958
queryGenerationToken的結果

00:13:12.993 --> 00:13:16.496
一個世代創建後
該世代不會包含添加到

00:13:16.563 --> 00:13:18.232
存儲協調器的存儲

00:13:18.498 --> 00:13:21.134
如果你將數據加載
到管理對象上下文

00:13:21.201 --> 00:13:23.403
將存儲添加到
協調器然後進行提取

00:13:23.470 --> 00:13:25.539
你不會從該新存儲
看到結果

00:13:26.139 --> 00:13:28.575
但是它不會阻止你
從協調器移除存儲

00:13:28.642 --> 00:13:29.810
儘管當你已移除
從中加載數據的所有存儲時

00:13:29.877 --> 00:13:33.814
如果你嘗試將數據加載到上下文

00:13:33.881 --> 00:13:36.750
你會發現錯誤

00:13:38.886 --> 00:13:41.288
現在 我將談論併發
因爲

00:13:41.722 --> 00:13:43.557
我們總是談論併發

00:13:45.425 --> 00:13:47.694
這是Core Data
當前的情況

00:13:47.761 --> 00:13:49.830
它的管理對象
上下文是執行者

00:13:51.865 --> 00:13:54.568
你使用perform以及
performAndWait與它交互

00:13:54.635 --> 00:13:58.138
做調度塊 以便
執行管理對象上下文隊列

00:13:58.472 --> 00:14:00.574
還有第三個模型
或者說另一個模型

00:14:00.641 --> 00:14:02.676
它使用
confinementConcurrencyType

00:14:02.743 --> 00:14:04.511
允許你直接對上下文
發出通知

00:14:04.578 --> 00:14:08.415
不過我們不推薦使用
因爲在任何線程情景下

00:14:08.482 --> 00:14:10.817
它都很難操作正確

00:14:11.585 --> 00:14:14.788
永久性存儲協調器
也是執行者

00:14:14.855 --> 00:14:17.624
擁有同樣的API
perform和performAndWait

00:14:17.691 --> 00:14:19.793
協調器將對來自
單個管理對象上下文的

00:14:19.860 --> 00:14:22.462
請求進行序列化操作

00:14:22.529 --> 00:14:24.898
同樣也對你在座標上使用
perform和performAndWait API

00:14:24.965 --> 00:14:28.402
直接安排的任何請求
進行序列化操作

00:14:30.571 --> 00:14:32.773
現在 我想宣佈一件
重要的事情

00:14:33.240 --> 00:14:36.009
我們爲在ObjC中編程

00:14:36.076 --> 00:14:39.213
並使用手動保留釋放的
開發者

00:14:39.279 --> 00:14:40.814
在執行、阻攔和等待
周圍添加了自動釋放池

00:14:41.381 --> 00:14:43.150
這意味着 你將負責

00:14:43.217 --> 00:14:46.553
延長你安排的組塊內

00:14:46.620 --> 00:14:48.088
創建的任何對象的壽命

00:14:48.155 --> 00:14:50.591
如果你想要在組塊外
使用這些對象

00:14:50.958 --> 00:14:52.693
要記住進行這個操作
很簡單

00:14:52.759 --> 00:14:54.328
對於 比如執行提取
導致的結果

00:14:55.829 --> 00:14:57.431
有一點不是特別明顯

00:14:57.497 --> 00:14:59.466
你還需對可能返回的NSErrors

00:14:59.533 --> 00:15:00.601
進行此操作

00:15:01.368 --> 00:15:03.837
這不僅影響使用
手動保留釋放的開發者

00:15:03.904 --> 00:15:06.373
我們有鏈接時間檢查
這樣你就不會看到此行爲

00:15:06.440 --> 00:15:10.143
直到你針對iOS X
或macOS 12進行重新編譯

00:15:11.979 --> 00:15:14.948
不過讓我們討論下
當今世界中存在的併發

00:15:15.749 --> 00:15:18.986
或者說截止昨天爲止
世界上存在的併發

00:15:20.187 --> 00:15:25.626
上下文1試圖進行進入
永久性存儲所需的操作

00:15:25.959 --> 00:15:27.628
所以它通知協調器

00:15:28.228 --> 00:15:30.797
協調器由於清理請求
鎖定了

00:15:30.864 --> 00:15:32.065
而此時 上下文2

00:15:32.132 --> 00:15:35.068
可能作爲你的UIContext
想要採取些行動

00:15:35.135 --> 00:15:36.837
並試圖通知協調器

00:15:37.070 --> 00:15:40.607
但由於協調器被鎖定
所以上下文2必須等待

00:15:40.841 --> 00:15:45.646
同時來自上下文1的請求
傳遞到永久性存儲

00:15:45.712 --> 00:15:49.716
任何需要被評估的工作
得到評估

00:15:49.983 --> 00:15:53.887
只有當這些工作完成
並且執行線程返回時

00:15:54.888 --> 00:15:57.291
上下文2才能鎖定協調器

00:15:57.357 --> 00:15:59.960
並將其工作向下分派給存儲

00:16:00.027 --> 00:16:02.196
這意味着上下文2基本上

00:16:02.262 --> 00:16:04.798
對於上下文1在進行的
所有工作都會被鎖定

00:16:06.266 --> 00:16:08.435
最終會恢復
但同時你的IU

00:16:08.502 --> 00:16:10.370
可能會比較慢

00:16:11.972 --> 00:16:15.709
新東西 SQL存儲目前有
連接池

00:16:15.776 --> 00:16:18.679
並且能夠處理多個併發請求

00:16:18.745 --> 00:16:22.549
具體地 它現在能夠處理
多個讀取器和單個編寫器

00:16:23.116 --> 00:16:26.086
不同平臺的連接池
大小各異

00:16:26.620 --> 00:16:30.824
我們已經採用了它 並將通過
幾張幻燈片向你展示如何更改

00:16:31.158 --> 00:16:32.459
現在這是怎麼實現的？

00:16:33.026 --> 00:16:36.263
上下文1分派到協調器

00:16:37.064 --> 00:16:39.066
且沒有任何鎖定

00:16:39.766 --> 00:16:44.538
上下文2 可能仍然作爲你的
UIContext 也分派協調器

00:16:45.405 --> 00:16:49.776
兩條消息同時都向下發送給
永久性存儲

00:16:50.544 --> 00:16:52.980
永久性存儲隨後會進行
所有必要工作以發現

00:16:53.046 --> 00:16:55.616
需要將什麼消息
發送到SQLite

00:16:55.883 --> 00:16:57.417
這些消息發送到SQLite

00:16:57.484 --> 00:16:59.620
只有在這時才進行鎖定

00:16:59.686 --> 00:17:02.155
這是標準的
SQLite文件鎖

00:17:03.090 --> 00:17:07.194
SQLite進行所有必要的操作
開始打開事務

00:17:07.261 --> 00:17:09.896
對了 就是一堆SQL
關閉事務

00:17:11.131 --> 00:17:14.800
在此時結束 返回

00:17:15.301 --> 00:17:18.105
所以 現在 我們確實
已經縮小了

00:17:18.172 --> 00:17:20.273
關鍵部分的範圍

00:17:21.175 --> 00:17:22.175
爲什麼要在意這一點？

00:17:22.242 --> 00:17:24.678
這會使你的UI反應更靈敏

00:17:25.412 --> 00:17:27.915
比如 當後臺工作
在不同的上下文進行時

00:17:27.981 --> 00:17:31.385
你可以在主UI上

00:17:31.451 --> 00:17:32.920
進行fault和提取操作

00:17:33.520 --> 00:17:35.222
這直接的附帶結果是

00:17:35.289 --> 00:17:37.524
簡化了應用架構

00:17:37.591 --> 00:17:41.361
一個相當標準的模式是

00:17:41.662 --> 00:17:45.332
人們會有一個導入程序上下文
其正在從網頁加載數據

00:17:45.499 --> 00:17:49.536
而另外 主UIContext正在
將數據傳送到主UI

00:17:50.504 --> 00:17:52.773
最終它們的數據
位於不同的堆棧上

00:17:52.840 --> 00:17:54.508
這是因爲UI需要快速響應

00:17:54.575 --> 00:17:58.111
它們需要關鍵部分的鎖定
儘可能小

00:17:59.379 --> 00:18:03.283
而以前 當你必須鎖定整個堆棧
唯一做到的方法是

00:18:03.350 --> 00:18:04.885
有兩個不同的堆棧

00:18:05.352 --> 00:18:07.654
這就導致了要在兩者
之間倒換的問題

00:18:07.721 --> 00:18:10.090
比如 有一個管理對象
上下文完成保存的通知

00:18:10.157 --> 00:18:12.593
但它是來自完全不同的
永久性存儲協調器

00:18:12.659 --> 00:18:14.194
我需要將它遷移過來

00:18:15.062 --> 00:18:18.398
現在這不再是問題
你現在可以將兩個上下文

00:18:18.465 --> 00:18:22.469
都附加到同一永久性
存儲協調器 它們將同時執行

00:18:22.970 --> 00:18:25.639
你僅需進行標準的合併

00:18:25.706 --> 00:18:29.076
而這其中的一大好處是
這意味着它們共享行緩存

00:18:29.142 --> 00:18:31.044
這樣將大大降低你的
內存佔用

00:18:31.111 --> 00:18:33.480
這將內存佔用減半

00:18:33.547 --> 00:18:35.415
因爲 我們現在只有
一個行緩存

00:18:41.622 --> 00:18:44.658
默認情況下它是打開的
它只針對SQL存儲

00:18:46.460 --> 00:18:48.562
它只有
在永久性存儲協調器上的

00:18:48.629 --> 00:18:51.098
所有協調存儲是SQL存儲時
纔有效

00:18:51.765 --> 00:18:54.434
你可以配置連接池的大小

00:18:54.501 --> 00:18:56.970
使用NSPersistentStore
ConnectionPoolMax SizeKey

00:18:58.305 --> 00:19:01.742
你將能夠確切地知道
連接池的最大容量

00:19:01.808 --> 00:19:05.379
如果你想要串行請求處理
舊有行爲 你可以設置爲1

00:19:06.013 --> 00:19:08.215
我們確實保留權利
你已經嘗試將它設置爲

00:19:08.282 --> 00:19:09.850
一百萬 而這有點蠢

00:19:09.917 --> 00:19:11.885
所以我們會使用
更合理的數字

00:19:13.787 --> 00:19:16.790
它應該立即
可爲你們大多數人所見

00:19:16.857 --> 00:19:19.426
你的UI可能會響應更快

00:19:20.360 --> 00:19:22.863
將此功能打開後
我們內部最大的發現是

00:19:22.930 --> 00:19:26.099
很多人說
哇 我能寫出

00:19:26.800 --> 00:19:29.136
幾百 幾千行的代碼

00:19:29.236 --> 00:19:31.572
你應該試試 因爲
天啊 這太過癮了

00:19:34.308 --> 00:19:35.175
有些人...

00:19:39.313 --> 00:19:43.717
有些人可能注意到
一些小小的時間問題

00:19:43.784 --> 00:19:47.354
若你有一個上下文
上下文1有執行、阻攔和等待

00:19:47.421 --> 00:19:49.823
上下文2也有執行
阻攔和等待

00:19:49.890 --> 00:19:53.360
最初 上下文2不會
開始執行其數據塊

00:19:53.427 --> 00:19:56.697
直到上下文1的數據塊返回
現在事實不是如此了

00:19:56.763 --> 00:20:00.133
所以 對於大概1%
遇到這種情況的人

00:20:00.200 --> 00:20:01.301
你的時間會發生改變

00:20:01.368 --> 00:20:05.038
你可能需要降低帶寬
連接池rearchitect

00:20:05.439 --> 00:20:06.340
而其他人

00:20:07.474 --> 00:20:09.910
你們只需編寫更新
更有趣更簡單的代碼就行了

00:20:10.944 --> 00:20:13.580
現在 我將邀請我的同事
Scott上臺

00:20:13.647 --> 00:20:15.682
他會介紹很多其它內容

00:20:22.789 --> 00:20:23.757
謝謝Melissa

00:20:27.494 --> 00:20:31.098
早上好
讓我們介紹下Core Data設置

00:20:32.599 --> 00:20:34.468
首先添加永久性存儲

00:20:35.169 --> 00:20:36.970
要對協調器
添加永久性存儲

00:20:37.037 --> 00:20:39.173
你需要四塊數據

00:20:39.239 --> 00:20:41.408
而完成大多數操作
你至少需要兩塊

00:20:42.176 --> 00:20:44.912
今年新內容中 Core Data
引入了一種新類型

00:20:44.978 --> 00:20:48.515
叫做NSPersistentStoreDescription
可以將所有

00:20:48.582 --> 00:20:50.184
描述存儲所需要的數據封裝

00:20:50.250 --> 00:20:53.687
同時包含方便的API
可用於一般的選項

00:20:53.754 --> 00:20:56.256
比如存儲是否應以只讀
形式打開

00:20:56.323 --> 00:20:58.258
協調器應使用的超時

00:20:58.926 --> 00:21:02.529
現在默認情況下均已啓用的
自動遷移和映射選項

00:21:02.930 --> 00:21:05.699
以及一個新增選項
用於異步添加存儲

00:21:07.501 --> 00:21:11.104
這種新類型適用於永久性
存儲協調器上的一種新方法

00:21:11.171 --> 00:21:15.242
該方法採取記錄圈號
附有用於描述存儲的參數

00:21:15.309 --> 00:21:18.712
以及一個可選NSError
該NSError在操作失敗時非零

00:21:19.713 --> 00:21:21.248
如果你異步添加存儲

00:21:21.315 --> 00:21:23.417
你可以在回調函數中
擴展條件

00:21:23.684 --> 00:21:27.454
針對的是發佈通知
或推送應用UI等

00:21:27.521 --> 00:21:29.623
時間是在成功添加存儲後

00:21:30.090 --> 00:21:33.760
這樣 你應用的模型設置
可以在主要線程外發生

00:21:33.827 --> 00:21:36.029
這在啓動應用時尤其有用

00:21:36.096 --> 00:21:38.031
因爲遷移可能導致延遲

00:21:38.332 --> 00:21:41.134
記住 如果iOS注意到
你的應用在啓動後

00:21:41.201 --> 00:21:43.604
一段時間仍不響應
則iOS將關閉應用

00:21:44.171 --> 00:21:46.507
這可能使遷移無法完成

00:21:46.573 --> 00:21:49.910
但現在如果你在異步
添加存儲 這不再是問題

00:21:52.045 --> 00:21:54.515
所以 那是
永久性存儲描述 不過

00:21:54.581 --> 00:21:57.050
設置Core Data堆棧
還涉及更多的東西

00:21:57.417 --> 00:21:59.987
要代表Core Data堆棧
你至少需要三個對象

00:22:00.053 --> 00:22:02.589
及將它們互相聯繫的
boilerplate樣板

00:22:03.757 --> 00:22:06.026
今年新內容中
Core Data有另一類型

00:22:06.093 --> 00:22:07.528
可以封裝這些對象

00:22:07.594 --> 00:22:10.564
及叫做NSPersistentContainer
的大多boilerplate樣板

00:22:11.565 --> 00:22:12.399
它不僅...

00:22:17.538 --> 00:22:20.874
我想很多人自己
已經寫過這種類型 不過...

00:22:21.808 --> 00:22:25.746
這個不僅封裝建模配置
它還有名稱

00:22:26.280 --> 00:22:31.251
存儲描述列表 以及
從該列表中加載

00:22:31.318 --> 00:22:33.387
尚未添加到協調器的
存儲描述的方法

00:22:34.121 --> 00:22:36.557
這意味着設置Core Data所需
項目boilerplate樣板

00:22:36.623 --> 00:22:40.961
從一整頁代碼
縮減到了僅幾行代碼

00:22:51.872 --> 00:22:54.775
所以現在少了很多代碼
讓我們看看這是如何實現的

00:22:55.209 --> 00:22:57.444
容器保證其屬性始終有效

00:22:57.511 --> 00:23:00.314
所以協調器和模型等的
接收方

00:23:00.380 --> 00:23:03.383
能夠始終返回可安全使用的
新對象

00:23:04.084 --> 00:23:06.820
容器的初始值設定項基於
你輸入初始值設定項的

00:23:06.887 --> 00:23:08.355
名稱找到模型

00:23:09.189 --> 00:23:12.526
還有另外一個初始值設定項
它採取明確的模型參數

00:23:13.660 --> 00:23:17.631
默認情況下 新容器在列表中
僅有一個存儲描述

00:23:17.698 --> 00:23:19.967
它是SQLite
附有默認選項

00:23:20.033 --> 00:23:23.170
以及基於容器名稱的
文件名稱

00:23:23.637 --> 00:23:25.439
它存儲在一個目錄中

00:23:25.506 --> 00:23:27.774
目錄由容器上的
類方法定義

00:23:28.509 --> 00:23:30.511
而默認情況下 永久性容器

00:23:30.978 --> 00:23:34.348
將基於你使用的平臺
向你返回目錄

00:23:34.414 --> 00:23:37.117
所以它會在macOS上使用
應用支持目錄

00:23:37.451 --> 00:23:40.487
在iOS和launchOS上使用
你的容器文檔結構

00:23:40.554 --> 00:23:44.024
以及tvOS上使用你的
容器緩存目錄

00:23:45.459 --> 00:23:47.828
若你想設置自己的目錄
那麼你可在永久性容器中

00:23:47.895 --> 00:23:50.230
劃分子類並替代直接

00:23:50.297 --> 00:23:53.100
不好意思 默認的
目錄URL類方法

00:23:54.401 --> 00:23:56.803
容器在設置
Core Data時真很有用

00:23:56.870 --> 00:23:59.606
不過它們也
給一般操作帶來了便利

00:24:00.207 --> 00:24:02.843
容器有一個主隊列
上下文屬性

00:24:02.910 --> 00:24:05.712
叫做查看上下文
你可以使用它驅動你的UI

00:24:06.246 --> 00:24:09.116
還有一種工廠方法
可以提供隨時可用的

00:24:09.183 --> 00:24:11.885
後臺上下文
但大多時候

00:24:11.952 --> 00:24:14.154
你可能要使用容器的方法

00:24:14.221 --> 00:24:17.791
來執行叫做performBackgroundTask的
後臺任務

00:24:19.626 --> 00:24:22.095
所以你無需安裝
新的後臺上下文 進行連接

00:24:22.162 --> 00:24:24.331
然後排列數據塊
以便在後臺進行操作

00:24:24.398 --> 00:24:26.200
你只需將數據塊
傳送到容器

00:24:27.167 --> 00:24:30.137
使用performBackgroundTask的
優勢遠不止獲得簡潔的代碼

00:24:30.204 --> 00:24:33.106
使用它可以使Core Data
減少爲完成你作業而

00:24:33.173 --> 00:24:36.643
創建的上下文數目
同時能夠與連接池一起

00:24:36.710 --> 00:24:39.646
確保你的應用響應快速
即使是在重負載的情況下

00:24:41.782 --> 00:24:43.884
說到一般上下文工作流

00:24:44.117 --> 00:24:47.020
NSManagedObjectContext
今年有一個新屬性 叫做

00:24:47.087 --> 00:24:49.189
自動合併來自父級的變更

00:24:49.723 --> 00:24:51.425
它是布爾值
當你將它設置爲真

00:24:51.491 --> 00:24:54.795
上下文會自動合併
保存其父級數據的更改

00:24:55.262 --> 00:24:56.129
這可以用於...

00:25:00.534 --> 00:25:02.903
這真的很便利
它可在父級

00:25:02.970 --> 00:25:05.005
保存變化時用於子上下文

00:25:05.539 --> 00:25:09.710
它也可以在同級保存到存儲時
用於頂層上下文

00:25:10.244 --> 00:25:12.179
它尤其適用於世代標記

00:25:12.246 --> 00:25:13.881
這個Melissa之前介紹過

00:25:14.781 --> 00:25:18.485
所以如果你把UI上下文固定到
最近的世代

00:25:18.552 --> 00:25:21.154
並且啓用自動合併
你可以不必維護你的UI

00:25:21.221 --> 00:25:23.190
你的fault會很安全
你的對象綁定

00:25:23.257 --> 00:25:26.126
以及提取結果控制器
將保持最新

00:25:30.364 --> 00:25:31.398
好

00:25:33.967 --> 00:25:35.469
讓我們討論下泛型

00:25:36.136 --> 00:25:37.971
Core Data今年採用了泛型

00:25:38.038 --> 00:25:40.541
而且它們在ObjC
和Swift中都很好用

00:25:41.008 --> 00:25:43.911
有一種新的協議叫做
NSFetchRequestResult

00:25:44.111 --> 00:25:47.314
所有你可能看到的類型

00:25:47.381 --> 00:25:49.516
都採用了這種新協議
從提取請求

00:25:49.583 --> 00:25:52.853
如NSManagedObject
或所有的實體子類

00:25:53.320 --> 00:25:57.291
對象ID、NSDictionary
以及NSNumber

00:25:58.692 --> 00:26:01.995
NSFetchRequest
現基於結果類型被參數化

00:26:02.062 --> 00:26:04.998
協議一致性限制結果類型
在Swift中

00:26:05.065 --> 00:26:08.869
NSManagedObjectContext上的提取
方法探究提取請求的類型

00:26:08.936 --> 00:26:10.571
一直探究到你的結果

00:26:12.139 --> 00:26:13.640
最後 提取結果控制器

00:26:13.707 --> 00:26:16.910
它採取了對創建
它的提取請求的參數化

00:26:18.879 --> 00:26:20.547
說到
NSFetchResultsController

00:26:20.614 --> 00:26:23.817
如果你正在使用UICollection
視圖 不好意思 在這兒

00:26:23.884 --> 00:26:25.385
UICollection視圖
若你使用Core Data

00:26:25.452 --> 00:26:28.222
採用新數據元預提取功能

00:26:28.288 --> 00:26:29.656
會非常簡單

00:26:29.723 --> 00:26:31.425
你需要做的只是
異步提取請求

00:26:31.491 --> 00:26:34.061
從而從主要線程獲得請求
而且你應該確保

00:26:34.127 --> 00:26:36.129
不會將對象作爲fault
返回

00:26:37.397 --> 00:26:39.199
關於數據源預提取的
詳細信息

00:26:39.266 --> 00:26:41.235
請查看Steve和Peter
昨天的分享

00:26:41.301 --> 00:26:43.170
UICollection視圖新特點

00:26:44.771 --> 00:26:47.374
如果你是Mac開發者
我也有好消息告訴你

00:26:47.441 --> 00:26:50.010
現在macOS提供
提取結果控制器

00:26:54.948 --> 00:26:58.352
好 讓我們討論下
Core Data中的一些常見操作

00:26:58.418 --> 00:27:00.687
從獲取實體描述開始

00:27:01.555 --> 00:27:03.257
額 這個 好了

00:27:04.858 --> 00:27:06.727
爲此 你需要
實體的字符串名稱

00:27:06.793 --> 00:27:08.495
以及一個管理對象上下文

00:27:09.463 --> 00:27:11.798
創建提取請求同樣
需要字符串常數

00:27:11.865 --> 00:27:15.068
以及類型轉換
如果你想利用新的泛型

00:27:15.536 --> 00:27:18.071
最後是
創建新的管理對象

00:27:18.138 --> 00:27:20.207
其中三樣都有 包括
字符串常數

00:27:20.274 --> 00:27:23.310
上下文參數
以及類型轉換

00:27:23.944 --> 00:27:25.879
今年 這些操作都變得簡單了

00:27:25.946 --> 00:27:28.715
因爲我們改進了
對象子類的管理

00:27:29.449 --> 00:27:32.319
實體描述現在是子類上的
類方法

00:27:39.092 --> 00:27:40.327
別擔心 這樣更好

00:27:41.328 --> 00:27:42.863
這一類也有工廠方法

00:27:42.930 --> 00:27:45.365
可用於創建新的
完全鍵入的提取請求

00:27:50.704 --> 00:27:52.739
最後 你可以創建
新的管理對象

00:27:53.407 --> 00:27:56.109
只需直接使用子類的
初始值設定項

00:28:04.384 --> 00:28:06.420
還有一件事值得介紹

00:28:06.486 --> 00:28:08.322
那就是執行提取請求

00:28:08.388 --> 00:28:11.725
我之前提到過 上下文提取
方法在Swift經過參數化

00:28:11.792 --> 00:28:14.461
但ObjC不支持方法級別的泛型

00:28:14.528 --> 00:28:17.831
所以我們也添加了像語義
之類的執行者以提取請求

00:28:17.998 --> 00:28:20.000
所以你只需從提交
到上下文的數據塊內

00:28:20.067 --> 00:28:22.035
調用執行方法

00:28:22.102 --> 00:28:24.404
就會返回正確鍵入的結果

00:28:29.576 --> 00:28:32.946
針對模型子類的新API
可以簡化很多事情

00:28:33.013 --> 00:28:34.748
不過我猜想
你可能真正期待的是

00:28:34.815 --> 00:28:36.850
重新生成你所有的子類

00:28:37.417 --> 00:28:39.219
但不用擔心 因爲

00:28:39.286 --> 00:28:41.688
這應該是你需要
處理它們的最後一年

00:28:41.955 --> 00:28:44.992
因爲Xcode 8現在能夠
爲你自動生成該代碼

00:28:49.696 --> 00:28:51.865
你可以按實體配置代碼世代

00:28:51.932 --> 00:28:55.068
Xcode會把生成的代碼寫入
你項目導出的數據

00:28:55.135 --> 00:28:57.571
所以不會導致未經你手的代碼
對源樹造成污染

00:28:58.405 --> 00:28:59.773
你無需編輯這些文件

00:28:59.840 --> 00:29:01.341
因爲當你變更模型時

00:29:01.408 --> 00:29:02.342
代碼會自動重新生成

00:29:02.409 --> 00:29:04.444
但如果你想進行

00:29:04.511 --> 00:29:07.281
在子類中添加自己的
實例變量等操作

00:29:07.347 --> 00:29:10.384
那麼你也可以告訴Xcode
僅生成一個類別或擴展

00:29:10.450 --> 00:29:12.219
然後你可以擁有類本身

00:29:15.189 --> 00:29:17.658
在Swift中 爲使用該功能
你需進行的操作是

00:29:17.724 --> 00:29:19.726
導入你實體所屬的模塊

00:29:19.793 --> 00:29:21.728
該模塊通常也是你代碼
所屬的模塊

00:29:22.062 --> 00:29:25.532
但是在ObjC中 你還需要了解
一些其中的工作原理

00:29:26.266 --> 00:29:31.004
ObjC中最需要了解的是
Core Data模型標題文件

00:29:31.638 --> 00:29:33.974
每個模型都有自己的標題文件
你需要將它導入

00:29:34.041 --> 00:29:36.743
以便訪問所有
該模型生成的類

00:29:37.544 --> 00:29:40.047
如果我們放大 看一下
生成的其他文件

00:29:40.113 --> 00:29:42.149
瞭解爲生成類而配置的實體

00:29:42.216 --> 00:29:45.018
Xcode創建了兩個標題
你在自己生成類時

00:29:45.085 --> 00:29:46.520
可能已看見過
因而可識別出

00:29:46.887 --> 00:29:48.355
其中一個聲明類界面

00:29:48.422 --> 00:29:50.724
另一個聲明管理屬性

00:29:52.025 --> 00:29:53.861
在ObjC中瞭解這點通常很重要

00:29:53.927 --> 00:29:55.829
因爲如果你在生成
一個類別

00:29:55.896 --> 00:29:58.298
那麼Xcode不會生成
類界面

00:29:58.799 --> 00:30:01.235
模型的標題將會
直接導入類別

00:30:02.302 --> 00:30:04.338
沒有類界面
就無法聲明類別

00:30:04.404 --> 00:30:06.773
所以生成的代碼的
預期是能夠

00:30:06.840 --> 00:30:09.476
在以該類命名的項目中
找到標題

00:30:09.710 --> 00:30:12.846
這是你擁有的文件
如果它不在你的項目中

00:30:12.913 --> 00:30:14.481
那麼你就無法構建
你的目標

00:30:16.016 --> 00:30:18.118
讓我們稍稍離開幻燈片
看一看

00:30:18.185 --> 00:30:20.187
這些新東西能爲你帶來什麼

00:30:24.858 --> 00:30:26.260
我打開了Xcode 8

00:30:26.326 --> 00:30:28.495
我們將創建新的
Xcode項目

00:30:29.830 --> 00:30:32.399
並使用iOS
主明細應用

00:30:33.133 --> 00:30:36.203
我們今年更新了模塊
以便使用新UI

00:30:36.436 --> 00:30:42.576
所以 如果我們將這個保存在
某位置 然後轉至應用代理

00:30:43.177 --> 00:30:44.945
接着我們會看到

00:30:45.712 --> 00:30:47.948
我們這裏使用的是
永久性容器

00:30:48.182 --> 00:30:52.219
我們將母版視圖控制器

00:30:52.286 --> 00:30:54.354
與容器的視圖上下文連接

00:30:56.123 --> 00:30:57.824
如果我們切換到
母版視圖控制器

00:30:57.891 --> 00:31:00.961
我們可以看到
在創建新對象的地方

00:31:01.028 --> 00:31:05.132
我們已經在使用
Core Data生成的子類

00:31:05.599 --> 00:31:07.267
初始值設定項

00:31:07.534 --> 00:31:09.903
我們不再使用KVC

00:31:09.970 --> 00:31:12.506
我們可以在管理對象上
直接設置屬性

00:31:12.573 --> 00:31:15.709
如果我們命令單擊
就會轉到生成的文件

00:31:19.046 --> 00:31:22.349
如果我們返回 看一下如何
設置提取結果控制器

00:31:22.916 --> 00:31:23.951
好了

00:31:25.752 --> 00:31:28.188
我們能看到
在事件分類上

00:31:28.255 --> 00:31:29.790
引發提取請求工廠方法

00:31:29.990 --> 00:31:33.927
這裏沒有額外明確的鍵入

00:31:33.994 --> 00:31:37.631
當我們創建提取結果控制器
但是它的類型

00:31:38.131 --> 00:31:40.200
非常小
如果我們在這兒放大

00:31:41.068 --> 00:31:42.936
它的類型通過提取請求
傳遞

00:31:43.937 --> 00:31:45.739
這意味着 其它地方

00:31:46.240 --> 00:31:48.775
比如
prepare for segue

00:31:51.578 --> 00:31:52.579
好了

00:31:53.847 --> 00:31:55.682
當我們從提取結果控制器
獲得對象

00:31:55.749 --> 00:31:57.518
會返回正確的類型

00:31:58.886 --> 00:32:01.221
這樣 都好了
我們不再有任何類型轉換

00:32:03.423 --> 00:32:06.527
不過 我不想讓這個應用
像默認設置這樣

00:32:06.593 --> 00:32:08.729
在母版視圖控制器中
顯示時間戳

00:32:08.795 --> 00:32:12.733
所以讓我們在這裏給事件
實體添加一個標題屬性

00:32:15.235 --> 00:32:18.205
我們希望它是字符串類型

00:32:20.541 --> 00:32:22.943
好了 我們重建並保存了模型

00:32:23.010 --> 00:32:25.979
如果我們返回到這兒
轉至配置單元格

00:32:28.315 --> 00:32:29.750
我們可在這裏刪除相應代碼

00:32:31.552 --> 00:32:33.453
使用Xcode的
自動完成功能

00:32:33.520 --> 00:32:36.290
獲取我們剛剛在模型中
設置的新屬性

00:32:43.063 --> 00:32:44.998
同樣 如果我們命令單擊它

00:32:45.065 --> 00:32:46.567
將更新所有的代碼

00:32:52.639 --> 00:32:54.641
這其中最大一個隱性的好處是

00:32:54.708 --> 00:32:56.777
如果你使用手動生成的子類

00:32:56.844 --> 00:33:00.080
甚至KVC 如果你更改
屬性的名稱

00:33:00.247 --> 00:33:01.882
你最後可能遇到非常奇怪的故障

00:33:01.949 --> 00:33:03.617
因爲你的項目會編譯

00:33:03.684 --> 00:33:08.789
但如果實際調用時
你會遇到運行時錯誤

00:33:08.856 --> 00:33:10.924
因爲註冊表項路徑
不再存在

00:33:11.458 --> 00:33:14.127
子類生成自動處理所有這些

00:33:17.197 --> 00:33:18.732
這就是自動分類生成

00:33:18.799 --> 00:33:21.835
以及Core Data新API的
一些工作實例

00:33:24.872 --> 00:33:27.407
最後 讓我們介紹下
SQLite的新特性

00:33:28.742 --> 00:33:31.011
操作系統附帶的
SQLite庫

00:33:31.078 --> 00:33:33.347
有一些你在其它地方
找不到的新功能

00:33:33.413 --> 00:33:35.949
首先是多線程聲明

00:33:37.317 --> 00:33:40.587
Apple平臺上的SQLite
沒有線程安全連接

00:33:40.654 --> 00:33:43.056
多線程故障很難診斷

00:33:43.123 --> 00:33:45.926
有時是因爲它們
通常顯示爲崩潰報告

00:33:45.993 --> 00:33:48.495
SQLite深處只有一個線程

00:33:49.463 --> 00:33:51.698
爲使這些問題更容易被
識別和重現

00:33:51.765 --> 00:33:54.067
系統SQLite支持新的
環境變量

00:33:54.134 --> 00:33:56.103
該變量可以啓用
多線程聲明

00:33:56.170 --> 00:33:59.139
當它們啓用時
你將在SQLite中看到兩個線程

00:33:59.206 --> 00:34:01.375
兩個線程均使用同一連接

00:34:03.911 --> 00:34:06.446
SQLite始終通過可使用
SQLite3 config進行配置

00:34:06.513 --> 00:34:09.882
支持用戶定義的記錄功能

00:34:09.949 --> 00:34:12.985
但是應在庫初始化之前
調用該功能

00:34:13.053 --> 00:34:14.688
而庫初始化可能已經發生

00:34:15.422 --> 00:34:17.157
SQLite的可配置性很棒

00:34:17.224 --> 00:34:20.194
不過我們在運行建模系統
該系統有內置記錄設施

00:34:20.260 --> 00:34:22.429
所以現在有另一個環境變量

00:34:22.496 --> 00:34:25.032
將SQLite記錄送到系統日誌

00:34:27.266 --> 00:34:30.938
最後 我要介紹下文件操作

00:34:32.072 --> 00:34:34.741
所有的數據庫
由一組文件表示

00:34:34.808 --> 00:34:37.444
當文件操作在多個文件中
進行時

00:34:37.511 --> 00:34:39.045
文件操作不可能是原子的

00:34:39.112 --> 00:34:41.014
這樣的結果是
所有的文件操作

00:34:41.081 --> 00:34:42.449
本身都是不安全的

00:34:42.850 --> 00:34:45.953
從Unix文件API
到NSFileManager 所有的

00:34:46.587 --> 00:34:47.688
這一點確實很重要

00:34:47.754 --> 00:34:49.889
我想分享幾個實際的例子

00:34:49.956 --> 00:34:51.024
表明問題如何產生

00:34:52.458 --> 00:34:55.362
比如 我發現目錄中
有兩個數據庫文件

00:34:56.263 --> 00:34:58.465
我的代碼要進行清理
所以刪除了兩個文件

00:34:58.532 --> 00:35:00.000
在刪除數據庫時

00:35:00.067 --> 00:35:02.236
日誌之類的東西
連接到數據庫文件

00:35:03.170 --> 00:35:05.405
該數據庫無法訪問日誌

00:35:05.539 --> 00:35:07.474
所以系統無法識別數據庫

00:35:07.541 --> 00:35:09.409
就立即報告錯誤

00:35:09.476 --> 00:35:10.978
因此影響你的應用

00:35:11.745 --> 00:35:13.914
除非你能保證
目前沒有任何東西

00:35:13.981 --> 00:35:16.083
將來也不會有任何東西試圖
連接到數據庫

00:35:16.149 --> 00:35:18.018
否則刪除文件都是不安全的

00:35:19.887 --> 00:35:21.588
比如 我有wall模式的數據庫

00:35:21.655 --> 00:35:23.357
該數據庫正在使用中

00:35:23.757 --> 00:35:26.426
由於某種原因 數據庫最終
被移開

00:35:27.661 --> 00:35:29.496
當數據庫在新位置打開時

00:35:29.563 --> 00:35:31.899
相應的連接創建了
新的日誌和鎖定文件

00:35:32.266 --> 00:35:33.200
現在你就有兩個連接

00:35:33.267 --> 00:35:34.902
分別使用不同日誌和鎖定

00:35:34.968 --> 00:35:37.571
不久 它們就會損壞數據庫

00:35:40.073 --> 00:35:42.042
這些例子可能有些
牽強不常見

00:35:42.109 --> 00:35:44.011
但是總共有超過十億的設備

00:35:44.077 --> 00:35:45.279
可能發生問題

00:35:45.345 --> 00:35:47.781
對每個可能文件的
每個可能的操作

00:35:47.848 --> 00:35:49.583
都可能導致使用你應用的
用戶遇到問題

00:35:49.650 --> 00:35:52.319
如果用戶數據丟失 就會很慌亂

00:35:53.787 --> 00:35:55.489
硬鏈接非常不好

00:35:55.556 --> 00:35:57.424
不要對數據庫文件
使用硬鏈接

00:35:59.126 --> 00:36:02.996
所以 今年的新內容是
操作系統附帶的SQLite庫

00:36:03.063 --> 00:36:05.199
充分利用分派源

00:36:05.399 --> 00:36:07.501
如果非法操作
對文件產生影響

00:36:07.568 --> 00:36:10.204
數據庫連接會報告錯誤

00:36:10.771 --> 00:36:13.240
系統自身解決
數據損壞問題

00:36:13.307 --> 00:36:15.609
大多情況下 損壞已經發生

00:36:15.876 --> 00:36:18.412
所以爲幫助你識別
並糾正這些問題

00:36:18.478 --> 00:36:22.516
我們添加了另一個環境變量
該變量可以使連接

00:36:22.583 --> 00:36:25.452
在發現非法操作影響其文件時
立即作出聲明

00:36:26.653 --> 00:36:27.754
如果你想知道

00:36:27.821 --> 00:36:29.056
數據庫損壞的更多原因

00:36:29.122 --> 00:36:31.425
SQLite在網站上有指導手冊

00:36:31.491 --> 00:36:34.228
名稱是“如何損壞
SQLite數據庫文件”

00:36:39.867 --> 00:36:41.668
幸運地是 這些問題是
可以避免的

00:36:42.302 --> 00:36:44.204
如果你直接使用SQLite
你應確保

00:36:44.271 --> 00:36:46.807
只有一段代碼擁有該數據庫

00:36:46.874 --> 00:36:49.376
該段代碼應進入
專門的文件訪問

00:36:49.443 --> 00:36:51.278
所以文件在打開時無法被修改

00:36:52.212 --> 00:36:54.181
若你正使用Core Data
你應該是在用

00:36:54.248 --> 00:36:56.216
永久性存儲協調器內
有一個API

00:36:56.283 --> 00:36:58.318
可以始終安全地用於
SQLite數據庫

00:36:58.385 --> 00:36:59.686
無論是數據庫打開與否

00:36:59.853 --> 00:37:02.789
replacePersistentStore
可將一個數據庫更換爲

00:37:02.856 --> 00:37:04.024
另一個數據庫的內容

00:37:04.258 --> 00:37:05.826
而destroyPersistentStore

00:37:05.893 --> 00:37:07.928
可以安全刪除數據庫中
所有內容

00:37:07.995 --> 00:37:09.663
並留下空白的數據庫

00:37:12.866 --> 00:37:16.103
好 上述就是今年
Core Data的新特性

00:37:16.170 --> 00:37:18.739
簡要回顧下 我們新增了一項
叫做查詢生成的功能

00:37:18.805 --> 00:37:21.942
這種功能可以使你
即刻看到數據的穩定視圖

00:37:23.076 --> 00:37:25.646
我們現在使用支持連接池
以及永久性存儲協調器

00:37:25.712 --> 00:37:27.781
這樣可以同時允許多個讀取器

00:37:27.848 --> 00:37:30.551
作爲單個編寫器
使你在進行大量數據操作的同時

00:37:30.617 --> 00:37:32.486
能夠保持漂亮的界面

00:37:33.820 --> 00:37:35.656
Core Data設置更簡單了

00:37:35.722 --> 00:37:38.025
新API也使Core Data
使用更簡單

00:37:38.091 --> 00:37:39.860
它在Swift中尤其好用

00:37:40.327 --> 00:37:43.330
這得到Xcode全新集成的
全面支持

00:37:43.397 --> 00:37:46.166
我們在SQLite中
也有新功能

00:37:46.333 --> 00:37:49.069
可以使一般問題的
調試更簡單

00:37:52.472 --> 00:37:53.340
要了解更多信息

00:37:53.407 --> 00:37:56.810
請查看我們的開發者網站
是在演講242

00:37:57.878 --> 00:38:00.247
如果你想了解更多
可以參考Swift新特性

00:38:00.314 --> 00:38:01.982
以及Cocoa的新特性

00:38:02.482 --> 00:38:03.417
感謝大家的到來