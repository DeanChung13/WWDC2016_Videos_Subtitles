Metal的新特性 第一部分
各位早上好
謝謝
我叫Aaftab Munshi
我和我的同事十分激動地
與大家分享Metal的新特性
macOS Sierra和iOS 10中
不過開始我先着重說說今年我們關於Metal的演講
在 WWDC
昨天我們有兩場演講談論了將Metal採用到
你的應用程序中
今天我們有三場演講
所以這一場 外加兩場演講覆蓋了Metal的新特性
之後還有另一場演講其中我們會講
Metal着色器優化
那麼我們...
看看我們將要講的功能
在第二場演講中我們要談的功能是
函數或着色器特殊化以及寫入資源的能力
例如來自片段和頂點着色器的緩衝和紋理
廣色域 在你的應用程序中使用廣色域顯示 以及紋理資源
還有在Metal性能着色器上添加的一些新內容
具體是通過Metal在GPU上使用輔助卷積神經網絡
本次演講中
我們將談談
我們在工具上加入的一些改進
我們認爲大家一定會喜歡的
我們也讓資源堆和資源分配更加快速
給你更多的控制
我們將談談那個資源堆和無記憶渲染目標
然後我將談談曲面細分
所以開始吧
好了 首先
我們花一點時間去理解
爲什麼需要曲面細分
我們看到應用程序例如遊戲
渲染越來越多的逼真視覺內容
所以這意味着爲了渲染那麼多內容
我們需要能將精細的幾何圖形發送給GPU
我們要將輸入發送過去
這意味着需要處理非常多的三角形
這會極大增加存儲帶寬
一件非常好的事是
如果我們能將這個發送給GPU的
幾何圖形只描述成一個低分辨率的模型
名爲Core Smash
然後讓GPU生成高分辨率的模型
事實上 這就是曲面細分的功能
曲面細分這種技術你可以用它來放大並細化
幾何對象的細節
我們必須要符合兩個重要的要求
第一個是那個生成的高分辨率
三角形模型不能存儲在顯存中
我們不想佔用帶寬
第二 所使用的方法需要是可編程的
所以我們來看一個例子
這是GFXBench 4.0的截圖
是一款由Kishonti發佈的測試程序
其注重的一個關鍵功能就是曲面細分
這張截圖是沒有使用曲面細分而渲染出的汽車
你看看那些輪圈
多邊形很明顯你不會開種車的
對吧？
就連車身板件上都有裂紋
因爲這就是實際發送過去的幾何圖形
你能看到 沒有很多三角形
這很好--正是我們想要的
曲面細分的功能是將那個輸入的幾何圖形
變成這個樣子
我認爲這十分炫酷
如果你看看線框圖你可以看到是GPU負責生成
現在我們渲染出非常多的三角形 是吧？
這就是曲面細分的威力
好了 我們來看看曲面細分如何在Metal中工作的
所以就像Metal那樣
我們想採用全新的設計方法
我們想設計出--
即使現在有支持曲面細分的API
你可能很熟悉
我們想要的是易於表達的東西
易於使用
而且我們不想保留任何性能
我們認爲我們做到了希望你也會認同
在這次展示之後
曲面細分在macOS Sierra和iOS上可以使用
搭載A9處理器
好了 我想談論的是
用於曲面細分的Metal圖形管線是什麼樣的？
如何使用曲面細分渲染我的幾何圖形？
以及如何將它應用到我的應用程序中？
所以開始吧
現在 當你用Metal將基元發送給GPU
你發送的是三角形線條或者是點
有了曲面細分 你發送的東西我們稱其爲面片
簡單來說面片就是參數曲面
是由樣條曲線構成但這意味着什麼？
你可能聽過Bezier面片或B樣條面片之類的東西
你通過一組控制點來描述面片
所以這個圖中你看到的是B樣條面片
所以你有16個控制點或者是控制頂點
曲面細分的作用是簡單來說 允許你控制
使用多少個三角形來渲染這個面片
所以你會決定“我不想要很多的三角形”
“我不在乎它什麼樣”
所以你可以決定四個三角形就足夠了
然後你會得到多邊形的外觀
或你決定 “我真的想讓它看起來精緻又平滑”
這會需要更多的三角形不過這是由你控制
所以我們開始
當我們做曲面細分時圖形管線中的第一階段
我們稱之爲曲面細分內核
它的作用是將面片
我們講了帶有控制點的面片 作爲輸入
並決定“我需要將它細分成多少？”
“我想讓GPU生成多少個三角形” 對吧？
這種信息是在曲面細分因子中捕捉到的
我會在幾個幻燈片之後稍微談談這些因子
你還可以生成額外面片數據
如果在隨後階段中需要的話
關鍵的是這是一個可編程階段
意味着你要寫代碼
一旦你寫完了生成了曲面細分因子
下一階段叫做鑲嵌器
這是一個固定函數階段所以沒有代碼可寫
不過你確實會得到配置它的旋鈕
所以它使用那些曲面細分因子然後將面片分解成三角形
鑲嵌器在這裏的關鍵作用是它不將
生成的三角形列表存儲在顯存中
除了其生成的三角形列表之外
對於三角形列表中的每個頂點它會生成我們所稱的
參數座標 U和V值
它將這個和控制點一起使用
來計算在表面上的實際位置
鑲嵌器會生成三角形
今天在Metal中當你想渲染基元時
你將三角形發送給GPU
首先會發生什麼？執行頂點着色器
在這裏是鑲嵌器生成三角形 所以...
如果你邏輯思考一下下一階段就會是頂點着色器
確實如此
我們將其稱爲後曲面細分頂點着色器
因爲它在由鑲嵌器生成的三角形上運行
所以它會在三角形的頂點上執行
三角形由鑲嵌器生成的
然後會輸出變換位置
如果你熟悉DirectX這個着色器所扮演的角色
和DirectX中的域着色器相似
好了 之後剩下的管線都是一樣的
我們有光柵器和片段着色器
你可能會問 “所以我需要寫這個計算內核
來生成曲面細分因子嗎？”
“我能使用頂點或片段着色器嗎？”
你當然可以
事實上 你根本不需要編寫着色器來生成這些因子
你可能預先計算好它們了
你就能將它們加載到緩衝中然後將其傳給鑲嵌器
所以你有很多控制
不過如果你在GPU中生成這些因子
我們建議你使用計算內核
因爲你知道嗎？
這會允許我們將那個內核和其他繪製指令異步運行
所以讓你提高性能我認爲你們會喜歡的
讓我們更進一步
你不需要每一幀都運行這個內核
因爲你知道嗎？
如果你已經計算了曲面細分因子--
假如你決定
“離鏡頭更近的物體會有更多的曲面細分”
“更遠的物體就沒那麼多”
一旦計算完了 之後根據物體的運動方式
我可以應用一個刻度然後鑲嵌器會接受它
所以管線真的十分簡單我們有四個階段
我們拿它和沒有曲面細分的圖形管線相比
沒有曲面細分的話我們有三個階段--
頂點着色器 光柵器和片段着色器階段
有曲面細分的話我們添加了新的階段 鑲嵌器
這是固定函數 所以你不需要寫任何着色器
然後頂點着色器成爲了後曲面細分頂點着色器
我們認爲這很容易理解
希望你們會認同
好了 如何用曲面細分來渲染我的幾何圖形？
這裏我要講四點
我們先看看後曲面細分
或後曲面細分頂點着色器
這與普通的頂點着色器有何不同？
如何傳遞我的面片輸入
我跟你說過鑲嵌器是可以配置的
我們來看看如何配置之後繪製面片
看看這就是新的着色器跟舊的着色器一樣
事實上 你聲明後曲面細分頂點着色器
要使用頂點限定符
除此之外你還要指定這個屬性
寫着“這是作用於面片的”
這裏有兩種面片--四邊形和三角形面片
你看到它邊上的數字了嗎？
那個數字就是告訴你那個面片作用於多少個控制點
如果你有普通的頂點着色器你會傳遞
一個頂點ID輸入
現在你將patchID作爲輸入傳遞
還記得我告訴你鑲嵌器生成參數UV座標嗎？
那就這個position_in_patch輸入
之後 如果你有普通頂點着色器
你要將其作爲stage_in傳遞
我們在stage_in傳遞的面片輸入
其他東西你就進行計算
然後就生成變換的頂點輸出
這實際上會完全相同
因爲下一階段 無論有沒有曲面細分 都是光柵器
好了 我們看看面片輸入
如果你有普通頂點着色器你會在着色器中將頂點輸入
描述爲結構體
如果你將數據類型解耦合了 這意味着
佈局和產生頂點輸入的緩衝
無法匹配着色器中的聲明
之後你要使用MTLVertexDescriptor
來描述佈局
這裏有兩種面片輸入一種是每面片輸入
還記得我告訴你的這裏有一個或以上的控制點嗎？
所以我們也需要將它們指定爲輸入
不過你指定它們的方法看起來一樣
你用MTLVertexDescriptor將面片輸入數據的
佈局在內存中指定
我之前展示過這個幻燈片我們還將輸入作爲stage_in聲明
你使用屬性索引在着色器中將元素識別爲輸入
通過MTLVertexDescriptor中相應的聲明
因爲會有不止一個控制點
基本上 我們要使用模板類型來對其聲明
我會在下一個幻燈片上講的
我們來看一個例子
這裏我有我的控制點數據上面有兩個元素
我使用0和1屬性
每面片數據是2和3屬性
我們將這兩個組合一起
這是每個面片的面片輸入
注意那個控制模板類型patch_control_point
這就在告訴Metal的着色編譯器
“這是引用控制點輸入”
還記得我告訴你的這個數字16嗎？數字多少無所謂
這也在告訴Metal着色編譯器這裏有多少個控制點
現在我們有了爲獲取面片輸入所需的所有信息
所以我們將它作爲stage_in傳遞
非常簡單
我認爲
好了
我如何配置旋鈕呢？
這裏有屬性
你可以設置在MTLRenderPipelineDescriptor中
幾個例子是你可以告訴鑲嵌器
你想用的三角形生成方法
叫做分區模式
你還可以指定最高曲面細分等級
我們認爲這是非常有用的
因爲這允許你控制所生成的幾何圖形最大量
由GPU爲曲面細分物體生成
記住鑲嵌器需要讀取這些因子
所以你需要指定產生它們的緩衝
所以使用setTessellationFactorBuffer API
來完成
這些因子會說明沿着邊緣將這些面片細分成什麼程度
還有在內部
所以我們有兩種面片
如果是三角形面片會有三個邊和一個內部
如果是四邊形那就會有四個邊和兩個內部
所以你將它們指定爲半精度浮點值
傳遞進去
然後是繪製
現在 當你繪製基元時
你發送的三角形由GPU渲染
你要麼調用drawPrimitives或者drawIndexPrimitives
你指定起始頂點頂點數量
如果你的頂點索引不是連續的你就傳遞一個索引緩衝
要想繪製面片你就調用drawPatches
或者drawIndexedPatches
你指定起始面片面片數量
如果你的控制點索引不是連續的你就指定一個索引緩衝
所以這是一對一映射
然後這裏有DrawIndirect變體
它們的功能是你不指定出
哪個是起始面片以及面片數量
以及當你進行繪製調用時的其他信息
相反 你傳遞一個緩衝
這些信息會填寫在其上面
通過一個在GPU上運行的指令 就像你在
drawPrimitives上做得那樣
如果你不知道如何使用drawPrimitives
drawPatches的效果非常相似
所以我們認爲這非常易於使用
好了
稍等
我給你展示了什麼是Metal曲面細分
以及使用方法
在座很多人可能熟悉
或者已經在你的應用程序中使用了曲面細分 通過DirectX
或者OpenGL
你會注意到Metal曲面細分有點不同
別擔心
我們設計的Metal曲面細分可以極其直截了當地
將你現有的曲面細分代碼轉移到Metal上
例如 在過去幾周裏我們與Unity合作
在極短的時間裏他們能夠
將Metal曲面細分整合到他們的引擎中
他們是這樣評價的
我們非常激動地宣佈對Metal曲面細分
Metal Compute和在Unity中編寫原生Metal着色器的功能支持
將於今年晚些時候推出這十分令人激動
而且我們也與Epic合作來有效地將
Metal曲面細分整合到Unreal Engine 4中
而且Epic計劃將於今年晚些時候發佈對UE4的支持
所以我們有UE4 我們有Unity支持Metal曲面細分
讓我給你展示曲面細分在這些遊戲引擎中的實際效果
通過演示兩種常用的渲染技術
叫做適配曲面細分和置換貼圖
好了
我們有一個簡單的演示...
由幾位Apple工程師開發的
使用Unreal Engine 4
我們已經關上曲面細分然後看看線框圖模式
你能看到沒有很多的三角形發送給GPU
非常好這正是我們想要的
我們要將發送給GPU的幾何圖形量維持得越少越好
我們啓用曲面細分看看會發生什麼
你能看到現在GPU生成了非常多的三角形
適配曲面細分這種技術允許你控制
重要地方的幾何細節
在這個例子中
我們決定離鏡頭更近的物體需要更多的細節
所以繪製上更多的三角形
相反 遠處的物體則不會
藍色的區域代表着曲面細分量最少的區域
然後紅色的區域代表着
曲面細分量最大的區域
我可以展示隨着我將滑動器向右滑動
我可以用它來增加曲面細分級別
你能看到更近的物體變成了紅色
好了 我們將線框圖關掉
如果你跑動隨着我們通過這個洞穴
你可以看到這裏有更多的細節 對吧？
如果我將曲面細分關掉所有的細節都沒了 丟失了
打開曲面細分看起來非常驚豔
所以這個例子演示了如何使用曲面細分
在我的應用程序中構建豐富的視覺場景
我想感謝那些在Epic的能人他們讓這一切成爲現實
所以下一個演示...
是置換貼圖...
在Unity上運行
這裏我們渲染出一個球體
我們看看用了多少個三角形來渲染這個球體
不多 對吧？
大概有3000個三角形
置換貼圖指的是一種技術
允許你置換幾何圖形來創建驚人的細節
其做法是使用一個置換貼圖 是一種紋理
所以你從紋理查找從這個紋理
之後用它將頂點位置偏移
或者如果你想的話你可以按順序地做
不過置換貼圖需要
你要繪製數量衆多的
非常小的三角形
否則不會有效它創建一個工件 只是裂紋
不過這沒問題的
我們可使用曲面細分它是專門做這個的
因爲我們還想要將3000個三角形
更小的三角形發送給GPU然後用曲面細分來生成它
我們將線框圖模式關掉
我們啓用置換貼圖
如你所見 現在球體上的細節非常驚人
如果我將線框圖模式打開
你可以看到我們生成了非常多的三角形 而且都非常小
實際上 我們看看這個置換貼圖的動畫效果
你能看到形狀變化我們放大來看看細節
你可以看到自陰影的出現
自陰影在這裏出現的原因是
因爲我們在改變幾何圖形
與在座很多人可能熟悉的凹凸貼圖技術不同
那只是創建虛假的現實
所以這是另一種技術你可以用上曲面細分
在所渲染的應用程序中創建出驚人的細節
還有 非常感謝Unity提供這個演示
演示曲面細分實際效果
好了 所以...
Metal曲面細分還可以用於加速數字內容創作工具
例如 OpenSubdiv是由Pixar發佈的開源庫
它會實現高性能細分表面
實際上 它集成到了多個
第三方數字內容創作工具
例如Autodesk的Maya
OpenSubdiv使用曲面細分來渲染這些細分表面
Apple在OpenSubdiv中加入了Metal曲面細分
我很激動地在這裏宣佈我們計劃將這些變更
今夏晚些時候在OpenSubdiv開源項目上發佈
這是Pixar的評價
如你所見 Pixar非常激動看到在iOS和macOS中
實現了OpenSubdiv上的原生Metal
好了 現在你可能會問“那我呢？”
“我如何將現有的曲面細分代碼轉移到Metal中？”
我來展示給你看
所以我們以DirectX爲例不過對OpenGL的規則也是一樣的
這是帶有曲面細分的DirectX圖形管線
我們有三個新的階段--其中兩個是可編程的
它們叫做外殼和域着色器
然後我們在中間有鑲嵌器
那我如何將它轉移到Metal中？
注意域着色器的位置正好在鑲嵌器的後面
這讓你想起其他我在Metal管線中展示的着色器嗎？
“我想是吧”
沒錯 後曲面細分頂點着色器不過你知道嗎？
曲面細分的域着色器就會成爲新的頂點着色器
就像你可很容易將HLSL或GLSL頂點函數移動至Metal中
你可以非常容易地將這些域着色器移動到
後曲面細分頂點着色器
鑲嵌器是完全相同的沒有改變
所以就是這個東西這兩個着色器
頂點和外殼着色器
我們要將它們放入內核中
那麼我們看看如何去做
我們看看一些因爲我們已經有了頂點着色器
這意味着這裏可能有頂點描述符在運行時
由應用程序所描述
因爲數據可能會解耦合
這意味着我要聲明stage_in但我無法在內核中stage_in
對吧？不過現在可以了
我們添加了支持
所以就像在頂點着色器中你使用stage_in來說
“這是我的頂點輸入”你可以用stage_in來說
“這是我的每線程輸入”
而且你可以指定實際數據佈局
在MTLStageinputOutputDescriptor中
表現相同
非常相似於MTLVertexDescriptor
有一些你指定的東西有一點不同
因爲這是用於計算的而不是頂點的
然後 要觀察兩點
DirectX或OpenGL的曲面細分頂點着色器執行於
面片的控制點
外殼着色器有這兩個函數
一個是在控制點上執行
另一個是在面片上執行
每面片外殼函數纔是真正生成
你的曲面細分因子
那最好的做法是？
將所有這三個函數轉化成Metal函數
然後我們寫一個Metal內核來調用這些函數
不過別擔心我們不會做函數調用
Metal編譯器會將它們內聯的
我們來看看這是怎麼起作用的
基本上 每個線程會調用控制點函數 用於頂點的
和外殼的
假設這裏有16個控制點所有第一個線程調用頂點
和控制點外殼函數
第二個也是一樣如此類推
它們產生的任何間歇數據如果想分享的話
會放入線程組內存中
就是高性能極低延遲的本地內存
我們不會去使用顯存
之後 如果有16個控制點這就會有16個線程
在上面運行
只需其中一個執行每面片外殼函數
這意味着通常會遇到柵欄之後你只會執行
其中的一個線程會執行外殼函數
你會遇到條件性檢查 會說
“我的線程是在線程組ID0嗎？之後調用這個”
這個函數會將曲面細分因子輸出到
顯存中
如果你有額外想要輸出的面片數據 你可以做到
如果你真的非常想輸出控制點數據 你可以做到
但我們發現在大多數情況中控制點數據只是通過
是這些現有API中圖形管線的性質
需要你將它們傳遞過去
不過你只是讓它們傳遞過去不要寫出來
你已經在緩衝中有了
好了 讓我總結一下
我希望給你展示了MetalTessellation是很簡單的
而且易於使用
我們從頭開始設計專注性能
我展示了將你現有的曲面細分代碼應用到Metal中是很簡單的
在iOS和macOS上可用
現在輪到你們了
展示出來 使用曲面細分並創建一些驚豔的畫面
在你的應用程序中渲染
我想感謝大家抽出寶貴時間我將請上我的同事 James
他將談談關於資源堆
和無記憶渲染目標謝謝大家
好了 謝謝你 Aaftab
本次演講的下一部分我很激動地介紹
在iOS和tvOS上可用的兩項新Metal功能
資源堆和無記憶渲染目標
這些功能可以讓你控制你的資源管理
從而實現更大的CPU和內存效率
我將首先介紹資源堆之後再講無記憶渲染目標
資源堆是Metal中的一個新的較低開銷資源管理選項
你早就可以在Metal中創建緩衝和紋理了
那爲什麼還要另一種方式？
在設備上通過現有Metal API
創建資源是既容易又方便的
而且很多開發者很讚賞這種簡單
另一方面
隨着Metal應用渲染越來越豐富複雜的場景
你會尋求更完善的Metal資源控制
來解鎖更大的CPU和內存效率
這就是我們推出資源堆的原因
資源堆可以實現快速的資源創建和綁定
通過資源子分配
資源堆的靈活性會節省你的內存
通過允許多個資源在內存中取別名
最後 資源堆的效率和靈活性的實現是靠
你控制資源依賴性跟蹤
通過使用顯式指令同步
我們來深入瞭解這些功能
從資源子分配開始
在談子分配的細節之前
我們首先討論爲什麼基於設備的資源創建耗費巨大
創建單個資源
使用Metal設備涉及多個步驟
分配內存準備內存用於GPU
清除內存保證安全
最後創建Metal對象
每一步都需要時間而大多數時間
都花在內存操作上
不過也有這種情況當你需要創建資源
在性能關鍵的路徑上並且不出現性能故障
紋理流就是一個例子
或者也許你有一個圖像處理應用
需要生產多個臨時紋理來執行一個濾鏡
綁定資源的成本
對於指令編碼器來說也會成爲性能問題
Metal必須跟蹤每個綁定到指令編碼器
的獨特資源來確保GPU能夠訪問內存
對於複製的場景這個成本也會水漲船高
資源子分配解決了這兩個性能問題
記住資源創建中開銷大的部分
是在內存操作中
有了資源堆你可以提前執行
內存操作在遊戲循環之外
資源堆解決了綁定成本做法是允許你
從單個堆中對許多邏輯資源進行子分配
通過從一個堆中對多個資源進行子分配
Metal跟蹤的是一個內存分配而不是每個資源的內存分配
這會顯著降低你的驅動過載
我們給資源創建做對比
在Metal設備和新的Metal資源堆之間
當你使用設備創建資源
Metal會分配並準備一個內存塊
然後創建Metal對象
對於四個資源 Metal會分配並準備四個內存塊
這與MTLHeap相比
將MTLHeap用於資源創建時
你首先要提前創建堆對象
內存會按請求的大小分配並準備一個內存塊
如果你在渲染循環之外提前做了這件事
資源創建中開銷大的部分就完成了
要從MTLHeap中創建出四個資源
Metal只需要保留一塊堆的內存
然後創建資源元數據
這會更加快速
現在來看看當我們想釋放一些資源時會發生什麼
當基於設備的資源釋放後Metal對象就會被破壞
不過設備也會釋放內存資源分配
另一方面當釋放堆資源時
只有對象被破壞內存還由堆所佔有
所以在設備上創建新資源
會引起另一次高開銷內存分配
而堆可以快速將閒置內存再分配給另一個資源
我給你展示這有多容易
用Swift對Metal資源進行子分配
所以跟很多Metal對象一樣
Metal資源堆有一個相應的描述符對象
我們創建堆描述符然後將大小設置成
支持堆的內存量
憑藉堆描述符我們可以請求設備
給我們創建一個堆對象
記住 這個操作會比較慢所以要提前做
例如當應用啓動時或是內容加載時間
有了這個創建出的堆我們可以調用其資源創建方法
這看起來非常眼熟因爲名稱和參數
與設備上的名稱和參數相同
在進行下一個話題之前
我想分享一些使用資源堆進行子分配的最佳做法
最重要的一點就是使用資源堆
在性能關鍵的路徑上創建資源
使用設備去創建資源不是專門
用於遊戲循環的資源堆是專門的
分配大小不同的資源可能會導致堆內存出現碎片
如果資源有不同的生命週期
所以使用多個堆並按照大小將資源裝好
來限制碎片的影響
你可以還在想如何選擇合適的堆大小
Metal在Metal設備上提供了兩種新的方法
來查詢紋理和緩衝的大小與排列
使用這些查詢來幫助你計算所需堆的大小
好了 我們來看看資源堆的下一項功能：資源別名
資源別名允許多個動態資源
佔用相同的內存
因此減少了資源的總體
內存佔用
動態資源的內容每一幀都是再生成的
內容包括陰影貼圖G緩衝數據
或是用於後處理的臨時紋理
我們這裏有一個堆包含兩個非別名的資源
與這個包含兩個相同資源的堆相比
不過現在用了別名
你能明顯看到使用別名的資源
可以放入更小的堆中
我們將資源別名應用到這個遊戲幀中
陰影貼圖過程會渲染一組陰影貼圖
用於場景中的每個光源
所以在這裏的堆中我們有多個陰影貼圖
在主過程的碎片加工中
着色器會採樣陰影貼圖來判定
是否每個對象都在陰影中
在主過程結束後陰影貼圖的內容
就會被完全消耗
它們會在下一幀中再生成
在主過程結束後我們會執行後處理鏈
這個可能包含多個離屏渲染過程
每個都執行特定的濾鏡像是模糊或者高光
這些濾鏡會將其內容存儲進紋理中
來將濾鏡結果傳遞給鏈中的下一個階段
這裏的要點是陰影貼圖的
內容和後處理紋理
從來不是同時使用的
所以爲何不共享內存呢？
我來給你展示如何用Swift創建這些別名資源集
這第一部分應該看起來眼熟
首先我們請求設備創建一個堆
然後我們創建三個陰影貼圖
現在我們看到了一個新方法makeAliasable
通過在堆資源上調用makeAliasable
你告訴那個堆將資源的內存視爲閒置的
陰影貼圖仍在啓用中但是它們的內存可以自由
被堆再分配給新的資源
現在當我們在相同的堆上創建後處理紋理時
它們可以作爲陰影貼圖佔用相同的內存
現在我們來談談一些最佳做法
用於資源別名
爲了實現動態資源的內存再使用最大化
調用資源創建方法
在一個幀裏資源所使用的相同序列中
允許你調用makeAliasable
會允許你交錯makeAliasable調用
當資源內容被消耗的時候
而且你要將動態資源和靜態資源保持在分隔的堆中
靜態資源一般無法進行別名而且會導致
動態資源無法互相使用別名
由於堆的內存碎片
接下來我將談談如何實現堆資源的
同步指令訪問
目前我們討論了憑藉子分配實現的快速資源創建
以及通過資源別名實現的高效內存使用
但要記住資源堆是快速靈活的
因爲你控制堆資源的同步
你在設備資源上不必這樣做
但與設備資源不同Metal不知道
指令會什麼時候修改堆資源的內容
例如當渲染過程將新內容存儲到紋理中
Metal也不知道你何時會將堆內存的
解釋從一個別名集改成另一個
不過爲了正確性 Metal需要知道何時指令會更新堆資源
這樣其他指令可以安全地讀取結果
這尤爲重要
因爲GPU可以並行執行多個指令
爲了實現堆資源的同步訪問
你的應用程序會創建並管理GPU柵欄
來在指令之間溝通資源依賴性
我們深入看看GPU柵欄的工作原理
GPU柵欄就是時間戳
是GPU執行時間軸上的一個參考點
你可以用柵欄編碼兩種行動來同步指令
指令可以更新柵欄將時間戳向前移
當指令完成後
而且指令可以等待柵欄
在執行之前 等到GPU觸及最新的柵欄更新
那我們回來看看之前的遊戲幀
我會展示給你如何使用柵欄
來實現別名堆資源的同步指令訪問
這就是示例幀這個幀有三部分
但現在我們有五個方框因爲兩個渲染階段
渲染過程分成了頂點和片段處理步驟
我們有陰影過程主過程
最後是後處理過程我們會使用計算來執行
Metal指令是按順序提交給指令隊列的
所以可能目前不清楚
爲什麼我們需要指令間的同步
不過GPU是並行機可以並行地
執行多個指令
我們iOS和tvOS產品中的GPU可以執行頂點
片段和計算指令全部並行執行
將GPU的利用率最大化
GPU甚至可以同時執行多個幀
好了 現在你可能會發現一個問題
看看這兩個突出顯示的指令
它們都是在同時更新
別名堆資源
我們要使用柵欄來修復它
首先我們將柵欄帶入
後處理指令更新柵欄
所以陰影指令片段處理階段
可以等待柵欄
現在這兩個指令不再同時執行了
我將展示給你如何使用Swift
給柵欄更新和柵欄等待編碼
首先 我們用設備創建柵欄
這是新方法--不帶參數
接下來 我們編碼後處理計算編碼器
在第一幀的結尾
我們首先創建computeCommandEncoder
然後編碼分派
在我們結束編碼器之前我們首先更新柵欄
這樣後續指令可以等待直到這個指令執行完成
在下一個幀中我們會編碼陰影渲染
我們創建renderCommandEncoder
在commandBufB中代表指令緩衝
用於下一幀
不過在繪製場景之前我們首先編碼柵欄等待
來等待到GPU上的後處理完成
注意這一次這裏有兩個參數
第二個參數叫做beforeStages
渲染指令在兩個階段中執行--頂點和片段
所以Metal允許你指定特定的需要
等待柵欄的階段
在我們的例子中只有片段階段需要
訪問堆資源所以我們指定片段階段
最後 我們可以安全地渲染我們的陰影貼圖
因爲我們知道這個指令只有在
前一幀的後處理完成後纔會執行
讓我談談一些指令同步的最佳做法
你知道如果使用堆你必須使用柵欄
來同步指令訪問
但你有這個控制是因爲你非常清楚
你的資源是如何使用的
而且你的應用程序會有更高的CPU效率
如果使用Metal爲你進行跟蹤
例如只初始化一次的紋理
並且未被修改是不需要跟蹤的
另一個例子
一起使用的資源可以通過單個柵欄一同跟蹤
所以讓我總結資源堆的主旨
憑藉子分配更快速創建資源
通過資源別名更加有效使用內存預算
然後使用GPU柵欄實現GPU指令間的堆更新同步
好了 現在我想介紹另一項在iOS和tvOS上可用的新功能
無記憶渲染目標
這聽起來有點魔幻
不過我會給你展示幾乎所有Metal應用都能使用該功能
只通過一行代碼就節省大量的內存
無記憶渲染目標這種紋理
不將任何系統內存分配給紋理內容
沒有任何內存存儲紋理內容
剩下的就是紋理元數據
例如紋理尺寸和內部紋理格式
很明顯 這節省了大量的內存
但什麼時候能用無記憶渲染目標呢？
你可以將它們用於未保存的渲染過程附件
大多數Metal應用會有一些附件與
存儲不在意行動或多重採樣解析有關
而且用於那些渲染過程附件的紋理可以是無記憶的
要製作無記憶渲染目標
你可以像平常創建紋理那樣
使用額外存儲模式標記
MTLStorageModeMemoryless
這就行了
該功能只支持iOS和tvOS因爲它依靠於
A7及其之後GPU的磚牆式渲染架構
我來給你展示其工作原理
在你的右邊我們有兩個渲染過程附件
一個色彩附件一個深度附件
A7及其之後GPU以每次一個分塊執行渲染過程
利用快速的GPU分塊存儲
在GPU的核心
GPU分塊存儲包含分塊大小的
深度 模板以及色彩附件的代表
這個分塊存儲是完全隔離於
紋理支持和系統內存
在Metal中 你的加載和存儲動作控制着
如何初始化GPU分塊存儲 以及是否
將GPU分塊存儲的結果複製回系統內存裏
如果附件未從內存中加載
而且未保存在內存中
你可以使那個附件的紋理變得無記憶
來消除內存分配
接下來 我會描述一些很常見的情景
你可以將該功能應用到你的應用上
深度附件經常在3D場景中用於啓用深度測試
不過A7及其之後GPU的深度測試是完全在
GPU分塊存儲中進行每次一個分塊
深度測試不需要使用系統內存
如果你不保存深度紋理爲之後過程所用
那就將紋理變得無記憶並節省下內存
我來給你展示另一個機會
當執行多重採樣渲染時
A7及其之後GPU在GPU分塊存儲中進行所有渲染
MSAA色彩附件紋理會被使用
只有在你選擇保存採樣數據以備後用
不過大多數應用會選擇多重採樣解析存儲動作
這直接源於從GPU分塊存儲
到解析色彩附件紋理
在那種情況下 確保多重採樣色彩附件紋理是無記憶的
而且這會節省大量的內存
如你所見 採用該功能所帶來的節省是顯著的
通過將1080p深度紋理變成無記憶的
你的應用會省下將近8MB空間
若你在12.9英寸iPad Pro上渲染原始分辨率
深度緩存的節省會高達20MB
而且將四倍多重採樣渲染目標變得
無記憶 會節省下更多4倍之多
所以使用無記憶渲染目標來最大程度使用
你的應用程序的內存預算
使用這省下的空間降低你遊戲的內存佔用
或更好用省下的空間
在遊戲中加入更加精美獨特的內容
我想邀請Jose上臺告訴大家關於Metal工具上的所有改進
謝謝 James
除了Metal API上新加的出色功能
我們在Metal Developer Tool上有一些出色的改進 給大家展示
首先我們會談談Metal System Trace的新功能
之後介紹一項新功能叫做GPU Overrides
我們有一些非常激動人心的新功能
登錄到GPU Frame Debugger
什麼是Metal System Trace？
在之前的Metal演講中我們出示了這個圖表
展示了Metal在CPU和GPU上的工作情況
Metal System Trace這一套工具可以將其可視化
幫助你瞭解你的Metal應用程序的時間軸
通過整體圖形管線從CPU
到GPU再到顯示器
去年 WWDC 我們推出了iOS平臺的Metal System Trace
我極力推薦去觀看去年的展示
來更好地總覽MetalSystem Trace
之後在秋季我們加入了tvOS支持
今天我們很高興宣佈MetalSystem Trace
登錄macOS 幫助你榨乾最後一滴性能
在所有Metal平臺上
我們全方位地改進了MetalSystem Trace
擴展我們報告的事件
對於資源事件
我們將高開銷的資源操作變得直觀 例如選取數據
從系統內存到顯存
這種案例中我們能看到macOS中的繪製
這導致了GPU執行延遲
Metal SystemTrace還顯示調試組
這讓你更容易讓你瞭解跟蹤中的指令編碼關係
在macOS上 我們支持同時跟蹤多個GPU
這對一些使用案例來說這難以置信
比如你在不同GPU之間分配工作
在iOS上我們現在顯示定標器工作量
所以當你遇到延遲時可以進行診斷
通過旋轉或縮放你的視圖
你現在可以將種類更多的工具
與Metal SystemTrace一同使用
例如Time ProfilerFile Activity
Allocations 還有更多
甚至不同的視圖 例如CPU數據這會展示CPU核心時間片段
這會幫助你將Metal事件與內容進行關聯
深入瞭解
系統運行應用程序的情況
允許你診斷像是由CPU停滯引起的GPU飢餓
由於錯誤的I/O操作
Metal SystemTrace會捕捉大量的數據
所以我們讓解釋和導航變得更容易
使用新的工作量突出顯示
你可以注重於任何指令編碼器或編碼緩衝
隨着它在管線中通過
通過鍵盤導航支持
你可以將你的選擇快速地在跟蹤中移動
最後我想介紹PerformanceObservation
PerformanceObservation是給你呈現
潛在問題的完整列表這是我們在
跟蹤中通過分析找到的
從顯示面耗時過長
到意外着色器彙編
或者高GPU執行時間
Performance Observations替你發現你在尋找的事件
你能從PerformanceObservation列表直接導航
所有這些新功能會允許你
調整你的Metal應用程序使其如你所想的那樣流暢運行
現在爲了展示我們在GPU調試上做出的出色改進
讓我交給我的同事 Alp
演示GPUFrame Debugger
謝謝 Jose
我今天有很多出色的功能要給大家展示
我們直接開始吧
我的應用在這裏運行
漫遊過美麗的地形細節由曲面細分做到了極致
在線框圖中查看這個地形該多好
去查看每一個三角形
好消息是 我們最新的功能GPU Overrides
讓你能夠修改你的Metal渲染
直接從調試欄當應用還在運行時
我們有多個不同的覆蓋你可以混搭使用
包括線框圖模式
我們切換到線框圖模式來看看地形的曲面細分程度
顯示每個三角形
你可能想要調整曲面細分來找到
性能和視覺品質之間平衡
通常你需要回去更改你的代碼重新編譯 然後運行
但是有了GPU Overrides你可以
直接從Overrides菜單試驗曲面細分比例
我們將比例設置到25%
現在我們有更少的三角形而且還丟失了一些有趣的細節
我們試試75%
我認爲這個效果更好我們看看沒有線框圖的樣子
可以 我喜歡這個
這比開始少了很多三角形
不過還是有全部的細節
外加提升的性能 我可以在場景中加入更多炫酷效果
如你所見 GPUOverrides這工具非常有助於
初次診斷場景中的
一些視覺和性能問題
接下來我們捕捉這一幀來給你展示一些功能
來極大提升你的調試工作流
幀捕捉已經完成
我在查看地形資源來看看地形面片的情況
在Resource Center中切換到所有GPU對象
你能看到所有的紋理和緩衝
我們這裏有全部的資源
我要一個個地查看
來找地形資源會花一些時間
這就是新的篩選條發揮作用的時刻
你可以按這裏的任何屬性進行篩選 例如標籤
類型 大小或者細節
因爲我標註了所有的資源我就只按地形篩選
在這裏 我有所有用於渲染地形的資源
現在我找到了地形面片緩衝
我想做的是看看它用在什麼地方
通過簡單的拖放我可以篩選功能導航器
給我展示所有用於地形面片緩衝的調用 就像這樣
在這個案例中 我使用計算得知了它的計算位置
以及當渲染地形時它的讀取位置
這個篩選十分強大
我還可以使用綁定資源的
其他任何屬性來篩選繪製調用
例如 如果你按sRGB篩選
你會看到所有繪製調用使用的紋理
都是sRGB像素格式
這是很自然的方式快速地在幀上導航
接下來 我們進入綁定GPU對象
來看看我們是如何使用資源來渲染地形的
在綁定模式中你的資源歸入在
不同的部分中基於使用它們的
Metal管線階段所以你知道到哪裏去找
看看頂點階段
地形面片是一個綁定到多個綁定點的緩衝
擁有不同的偏移量
我們使用唯一的緩衝來檢查數據
所有的頂點數據的佈局
排列整齊 除了這是來自帶有面片的Metal函數
所以這使用了與後頂點函數完全相同的結構體
我們這裏有顏色數據
它識別顏色單詞然後在這裏顯示
值的真正顏色
因爲這是包含不同數據類型的大型緩衝
我用新的MTLBuffer API添加了一些調試標記
這會讓你極其輕鬆地找到你想要的東西
通過佈局菜單你可以直接跳入
其他你想檢查的可用佈局
查看單個緩衝是很好的
更好的是新的輸入屬性視圖
讓你看到所有的頂點數據
與頂點着色器的視角一樣
輸入屬性從你的實例中收集所有數據
曲面細分因子緩衝和stage_in數據
之後提供給你單個視圖來一同查看它們
在這個案例中我們用多個面片渲染實例
我可以看出什麼數據屬於實例的哪個面片
所以這簡短介紹了
GPU FrameDebugger上的一些最新功能
我們切回幻燈片做個總結
演示GPUFrame Debugger
你剛纔看到了一些最新的GPUFrame Debugger功能
我想再告訴大家兩個
有了新Extended Validation模式GPU Frame Debugger可以
進行更加深入的應用分析
在選擇最佳紋理使用上提供推薦
或者資源的存儲模式
你可以從Xcode方案編輯器中啓用這個模式
獨立Metal LibraryProjects的新支持
讓你創建Metal庫在多個應用中共享
或者將多個庫包含在一個應用中
就像其他任何框架或庫
使用我們講的功能
能極大提升你的工具體驗
現在我們總結本次演講中看到的內容
我們看到通過曲面細分給Metal API新增的功能
資源堆和無記憶渲染目標
之後我們展示了改進的工具
Metal System Trace和GPU Frame Debugger
一定要看看下午的第二部分
我會講講關於函數特殊化
和函數資源讀寫
廣色域和紋理資源
以及Metal性能着色器的增加功能
有關更多本次演講的信息請訪問這個網絡連接
你可以補看視頻 並得到資料和示例代碼鏈接
我們昨天的演講十分精彩你可以在線觀看
這個下午 我們有Metal的新功能 第二部分
之後高級Metal着色器優化就在這個演講廳
感謝大家的到來祝各位 WWDC 過得愉快