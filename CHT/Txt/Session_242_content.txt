Core Data的新特性
大家好
我是MelissaCore Data工程師
不誇張地說這是第一年上臺前沒有人跟我說
祝你好運
因爲我實際一個月前腿折了這是我第一天脫離石膏繃帶
所以如果我一瘸一拐你們知道是怎麼回事
在Core Data團隊工作最好的是
實際上每年能站在這個舞臺上
告訴大家我們都做了哪些新鮮有趣的事情
不可思議 我們今年做了很多 而且都非常有用
我們希望大家喜歡這些新內容
好 我要介紹一項新功能查詢生成
Core Data併發領域的一些變化
我要介紹我們在Core Data堆棧配置領域
的一些新進展
及我們新添加的一些API
我們也會簡單介紹下爲了更靈巧利落地
與Swift集成我們都做了哪些事情
還有我們在Xcode集成方面的一些改進
內容不少 現在第一項 查詢生成
查詢生成是我們添加的一項新功能
不過在開始介紹查詢生成前
我需要簡單介紹下fault
可能有人知道Core Data常使用fault
管理對象可能是fault它們之間的關係可能是fault
如果你在使用批量提取
那你執行抓取請求獲得的陣列
從NSManagedObjectContext
也會是一種非常特殊的fault
話雖這麼說 什麼是fault？
現在 在屏幕上有一張對象圖
其中有國家 美國
州 加利福尼亞 若干的郡聖克拉拉和舊金山
以及聖克拉拉的若干城市 聖何塞和庫比蒂諾
這很像是旅遊指南指南書籍的一部分
你可以翻開 瀏覽從而在你計劃遊玩的
城市中找到你感興趣的地方
不過 僅基於我們對美國的瞭解
這不是完整的對象圖
實際上只是對象圖的一部分是子圖
因爲我們知道美國有其他州
這些州有其他郡
這些郡有其他城市
你也知道 除此之外
我們知道美國只是衆多國家之一
即使是在指南書籍中我一次想看的
也僅是一個數據集
如果我計劃到聖何塞旅行
我不會關心俄勒岡或華盛頓或其它類似的地方
我甚至不會關心舊金山
我需要能夠鎖定這些對象到達這些目的地
如果我感興趣
我可以隨後改主意改變想要瀏覽的內容
但就目前短期而言當我在計劃
到聖克拉拉的旅行時我不在意其它地方
這種不在意在內存中表示爲
fault它是一種對象
瞭解在隨後的某個時間點如何開始檢索數據
如果我確定我想使用它
比如 我發現我朋友要結婚了
婚禮在西雅圖 我想去
計劃到西雅圖的旅行
此時 我會再次瀏覽美國
下一層我想瀏覽華盛頓州
Core Data會自動檢索
關於華盛頓的信息即使當我首次加載子圖時
華盛頓信息不在內存中
你知道 我可以接着向下瀏覽等等...
這就是fault它是未來 或承諾
或延遲加載
這些不同的名稱指的都是同樣的東西
Core Data可進行這操作幫你儘量減少
在任意給定時間點內存中的數據量
我們爲什麼使用fault？
答案是 性能 性能 性能還是性能
性能最好的應用
是那些不做任何額外功的應用
你不會在iobus上加載任何不需要的對象
你不會在不需要的對象上花費任何時間
你也不想在用戶不注意的時候
這些對象閒置在那裏
推高你的內存佔用
不過fault有一個小問題
基本上是這樣的
這裏我們再看對象圖
在這個案例中我們有很多fault
我順着樹形結構向下瀏覽來到聖克拉拉
我想啓動庫比蒂諾fault
但同時
一個外部過程已經開始從網站導入數據
而且不知爲何庫比蒂諾被刪除了
發生了什麼？
我有一個fault它應開始
檢索關於庫比蒂諾的信息
但那裏卻沒有任何信息了
我說過 我多次介紹不要加載不需要的數據
但在這個案例中你會問自己
我是不是實際上需要那個數據呢？
哎喲
現在Core Data中
通過NSManagedObjectContext上的shouldDeleteInaccessibleFaults
屬性 你可以應對這種情況
如果你設置了這個屬性然後當上下文注意到
你正在試圖啓動已刪除對象的fault
上下文會將fault標記爲已刪除
並將fault的所有屬性標記爲零
大多情況下 這就是你需要的但有時候這也會不便利
因爲你的UI不知道如何處理爲零的標識符
另一種方法是預提取所有內容
使用關係小鍵盤進行預提取從而加載你認爲你用戶
可能需要的所有對象
這樣 你的任務就升級了
你需要更努力瞭解確切地
預測用戶未來可能的需要
這會很棘手 我們都知道用戶是不可預測的
另一種方法存在第三種方法
始終都存在第三種方法就是寫很多代碼
首先在管理對象上下文中
使用帶ID的既有對象確保在嘗試fault前
對象位於數據庫中
編寫很多try catch
圍繞着所有fault啓動的異常處理程序
實話說 這個代碼寫起來可不怎麼有意思
你實際上會更願意寫一些用戶會使用的
有趣功能因爲那纔是用戶
使用你應用的原因即你的應用提供靈巧功能
不過讓我們後退一步
稍稍想一下你的用戶與你應用的交互
用戶視圖和UI通常不關心
是否看到絕對的最近最新和最快的數據
我們怎麼知道這一點？
讓我們先想想氣泵
大多數人對氣泵很熟悉你有時會給汽車加油
氣泵的顯示屏會告訴你
你實際已經給汽車加了多少加侖或升的油
顯示數字有千分位
我想問下大家在給車加油時
誰能實時讀到千分位請舉手
正如我所料沒有人能做到
人類大腦喜歡數字
以一定間隔整齊排列這樣容易理解
所以用戶實際不需要最近最新的數據 他們只需要數據...
合理快速地更新
保存數據的用戶對此也不在乎
正因如此Core Data纔有合併策略
這些策略規定進行一連串編輯並將這些編輯保存
並與數據庫中的內容混合
以及產生預期的效果
你可以選擇你需要的合併策略因爲你比我們更瞭解你的用戶
那麼 如果我們能夠汲取這個洞見並進一步延伸會怎樣？
如果我們有方法使你通過UI看到數據庫中
數據的穩定視圖會怎樣？
如果我們有方法應對變化
更確定地更新變化會怎樣？
如果我們能做到所有這些你不會再看到這個 會怎樣？
現在 我可以介紹查詢生成了
查詢生成是一種方法
能使你的管理對象上下文
基本上 執行讀取數據庫中數據的操作
所有向管理對象上下文的讀取操作
都將看到同樣的數據視圖直到你選擇向前進
你永遠不會再看到無法完成fault的消息
而且重要的是我們能高效完成這一操作
這永遠都是棘手的部分
這些是怎麼實現的？
這裏有一個數據庫 裏面有一個對象id是1名字是fred
因爲這些是幻燈片
我將進行刪減
因爲我需要完成此構建需要的所有資產
在傳統數據庫中這就是你得到的
你有一個文件 該文件有對所有數據的單一視圖
但是使用查詢生成
那就變成了你數據庫中的第一代數據
隨着過程的進行這可能會成爲你的應用
它可以是導入程序可以是watch上的擴展
某物對數據庫進行修改
新一代創建了
而且更多的數據被創建新的對象
此時 用戶啓動你的應用
創建管理對象上下文你加載數據
該上下文現在知道
它是從數據庫中的哪一代加載數據
所以隨着其他過程或上下文等的繼續進行
並進一步修改數據庫
更多代的數據被創建該上下文仍然知道它所屬的代
第二個上下文出現加載一些數據 進行一些編輯
進行保存 保存之後便創建了新一代
並追蹤它現在代表的一代
在本例中是數據庫中的第6代
此時 如果我們在上下文1中啓動fault
即使fault對應的對象
可能在第6代中已經被刪除
上下文中仍可看到該對象因爲它仍然在數據庫中
就在標籤第3代下
此時 用戶可以在上下文1中略微編輯
刪除一些對象 更改一些對象插入新的對象
當保存上下文時Core Data將使用合併策略
將所有這些變更與數據庫中的內容合併
並創建新的第7代
以與上下文1相同的
上下文1在固定到第3代時
能夠看到第3代同樣地
上下文2能夠對其對象作出任意操作
將對象變成fault重新啓動這些fault
且上下文2將仍能看到
數據庫第6代中的數據
所以 基本上它是管理對象上下文級別的
完全讀取事務
我們長篇介紹了爲什麼上下文
本質上是對的事務
現在我們也將它們變成讀取事務
使你能夠在上下文的級別上立即隔離你的工作
並最小化預防性預提取等這意味着 所有人都獲益
基本要點
單個上下文可以選擇想要的行爲
它可以決定它想要
你在iOS 9和macOS 11上適應的當前行爲
我們稱爲已取消固定 注意看加載數據時樹形結構頂端
你也可以指定上下文應固定到
數據庫中任意當前的世代
當數據首次加載到該上下文時
或者 你可以指定你想要它固定到特定世代
如果另一個上下文固定到該世代
嵌套上下文將繼承父級的世代
它們悄悄取消固定但是能夠看到
通過父級世代查看的數據
以及父級閒置未保存的任何掛起的變更
更新一定程度上很重要我們都認可這一點
用戶不想看到更新
最終 他們不希望看到10年前的數據
世代的更新發生在你通過設置
新世代標記明確告訴上下文更新時
它們在保存時更新
它們在你調用mergeChanges時更新這時它們將更新至樹的頂端
既然你已經告訴上下文
你知道它應該在查看數據庫中的一組新變化
它的更新是調用重置引起的
需要注意的是
當你更新世代時
已註冊的對象不會被刷新你可能不想要那樣
我們可以很輕鬆地讓你這麼做
如果我們選擇代你做再讓你取消難度會加大很多
如果你想要刷新數據
你必須調用fetch或refreshAllObjects
但是當數據實際得到更新時這樣會使你獲得控制
如果你想使用查詢生成你必須使用SQL store
且SQL store應在wall模式下
儘管如果你嘗試使用查詢生成
你並未滿足上述兩項要求系統會正常退出
只是恢復到已取消固定的行爲
我們是如何做的？
好 現在有一種opaque標記 你可以使用它
跟蹤查詢生成
這將告訴上下文 什麼時候從什麼存儲加載了數據
查詢生成標記有一個方法current
你可以使用它檢索標記
以表明在它加載數據時上下文應固定
ManagedObjectContext我們有若干新方法
有一個屬性QueryGenerationToken
它將會告訴你 上下文正在使用哪個查詢生成
如果上下文取消固定則該屬性爲零
你可以由標記設置查詢生成
或者是來自類屬性的current標記
或是在另一個管理對象上下文調用
queryGenerationToken的結果
一個世代創建後該世代不會包含添加到
存儲協調器的存儲
如果你將數據加載到管理對象上下文
將存儲添加到協調器然後進行提取
你不會從該新存儲看到結果
但是它不會阻止你從協調器移除存儲
儘管當你已移除從中加載數據的所有存儲時
如果你嘗試將數據加載到上下文
你會發現錯誤
現在 我將談論併發因爲
我們總是談論併發
這是Core Data當前的情況
它的管理對象上下文是執行者
你使用perform以及performAndWait與它交互
做調度塊 以便執行管理對象上下文隊列
還有第三個模型或者說另一個模型
它使用confinementConcurrencyType
允許你直接對上下文發出通知
不過我們不推薦使用因爲在任何線程情景下
它都很難操作正確
永久性存儲協調器也是執行者
擁有同樣的APIperform和performAndWait
協調器將對來自單個管理對象上下文的
請求進行序列化操作
同樣也對你在座標上使用perform和performAndWait API
直接安排的任何請求進行序列化操作
現在 我想宣佈一件重要的事情
我們爲在ObjC中編程
並使用手動保留釋放的開發者
在執行、阻攔和等待周圍添加了自動釋放池
這意味着 你將負責
延長你安排的組塊內
創建的任何對象的壽命
如果你想要在組塊外使用這些對象
要記住進行這個操作很簡單
對於 比如執行提取導致的結果
有一點不是特別明顯
你還需對可能返回的NSErrors
進行此操作
這不僅影響使用手動保留釋放的開發者
我們有鏈接時間檢查這樣你就不會看到此行爲
直到你針對iOS X或macOS 12進行重新編譯
不過讓我們討論下當今世界中存在的併發
或者說截止昨天爲止世界上存在的併發
上下文1試圖進行進入永久性存儲所需的操作
所以它通知協調器
協調器由於清理請求鎖定了
而此時 上下文2
可能作爲你的UIContext想要採取些行動
並試圖通知協調器
但由於協調器被鎖定所以上下文2必須等待
同時來自上下文1的請求傳遞到永久性存儲
任何需要被評估的工作得到評估
只有當這些工作完成並且執行線程返回時
上下文2才能鎖定協調器
並將其工作向下分派給存儲
這意味着上下文2基本上
對於上下文1在進行的所有工作都會被鎖定
最終會恢復但同時你的IU
可能會比較慢
新東西 SQL存儲目前有連接池
並且能夠處理多個併發請求
具體地 它現在能夠處理多個讀取器和單個編寫器
不同平臺的連接池大小各異
我們已經採用了它 並將通過幾張幻燈片向你展示如何更改
現在這是怎麼實現的？
上下文1分派到協調器
且沒有任何鎖定
上下文2 可能仍然作爲你的UIContext 也分派協調器
兩條消息同時都向下發送給永久性存儲
永久性存儲隨後會進行所有必要工作以發現
需要將什麼消息發送到SQLite
這些消息發送到SQLite
只有在這時才進行鎖定
這是標準的SQLite文件鎖
SQLite進行所有必要的操作開始打開事務
對了 就是一堆SQL關閉事務
在此時結束 返回
所以 現在 我們確實已經縮小了
關鍵部分的範圍
爲什麼要在意這一點？
這會使你的UI反應更靈敏
比如 當後臺工作在不同的上下文進行時
你可以在主UI上
進行fault和提取操作
這直接的附帶結果是
簡化了應用架構
一個相當標準的模式是
人們會有一個導入程序上下文其正在從網頁加載數據
而另外 主UIContext正在將數據傳送到主UI
最終它們的數據位於不同的堆棧上
這是因爲UI需要快速響應
它們需要關鍵部分的鎖定儘可能小
而以前 當你必須鎖定整個堆棧唯一做到的方法是
有兩個不同的堆棧
這就導致了要在兩者之間倒換的問題
比如 有一個管理對象上下文完成保存的通知
但它是來自完全不同的永久性存儲協調器
我需要將它遷移過來
現在這不再是問題你現在可以將兩個上下文
都附加到同一永久性存儲協調器 它們將同時執行
你僅需進行標準的合併
而這其中的一大好處是這意味着它們共享行緩存
這樣將大大降低你的內存佔用
這將內存佔用減半
因爲 我們現在只有一個行緩存
默認情況下它是打開的它只針對SQL存儲
它只有在永久性存儲協調器上的
所有協調存儲是SQL存儲時纔有效
你可以配置連接池的大小
使用NSPersistentStoreConnectionPoolMax SizeKey
你將能夠確切地知道連接池的最大容量
如果你想要串行請求處理舊有行爲 你可以設置爲1
我們確實保留權利你已經嘗試將它設置爲
一百萬 而這有點蠢
所以我們會使用更合理的數字
它應該立即可爲你們大多數人所見
你的UI可能會響應更快
將此功能打開後我們內部最大的發現是
很多人說哇 我能寫出
幾百 幾千行的代碼
你應該試試 因爲天啊 這太過癮了
有些人...
有些人可能注意到一些小小的時間問題
若你有一個上下文上下文1有執行、阻攔和等待
上下文2也有執行阻攔和等待
最初 上下文2不會開始執行其數據塊
直到上下文1的數據塊返回現在事實不是如此了
所以 對於大概1%遇到這種情況的人
你的時間會發生改變
你可能需要降低帶寬連接池rearchitect
而其他人
你們只需編寫更新更有趣更簡單的代碼就行了
現在 我將邀請我的同事Scott上臺
他會介紹很多其它內容
謝謝Melissa
早上好讓我們介紹下Core Data設置
首先添加永久性存儲
要對協調器添加永久性存儲
你需要四塊數據
而完成大多數操作你至少需要兩塊
今年新內容中 Core Data引入了一種新類型
叫做NSPersistentStoreDescription可以將所有
描述存儲所需要的數據封裝
同時包含方便的API可用於一般的選項
比如存儲是否應以只讀形式打開
協調器應使用的超時
現在默認情況下均已啓用的自動遷移和映射選項
以及一個新增選項用於異步添加存儲
這種新類型適用於永久性存儲協調器上的一種新方法
該方法採取記錄圈號附有用於描述存儲的參數
以及一個可選NSError該NSError在操作失敗時非零
如果你異步添加存儲
你可以在回調函數中擴展條件
針對的是發佈通知或推送應用UI等
時間是在成功添加存儲後
這樣 你應用的模型設置可以在主要線程外發生
這在啓動應用時尤其有用
因爲遷移可能導致延遲
記住 如果iOS注意到你的應用在啓動後
一段時間仍不響應則iOS將關閉應用
這可能使遷移無法完成
但現在如果你在異步添加存儲 這不再是問題
所以 那是永久性存儲描述 不過
設置Core Data堆棧還涉及更多的東西
要代表Core Data堆棧你至少需要三個對象
及將它們互相聯繫的boilerplate樣板
今年新內容中Core Data有另一類型
可以封裝這些對象
及叫做NSPersistentContainer的大多boilerplate樣板
它不僅...
我想很多人自己已經寫過這種類型 不過...
這個不僅封裝建模配置它還有名稱
存儲描述列表 以及從該列表中加載
尚未添加到協調器的存儲描述的方法
這意味着設置Core Data所需項目boilerplate樣板
從一整頁代碼縮減到了僅幾行代碼
所以現在少了很多代碼讓我們看看這是如何實現的
容器保證其屬性始終有效
所以協調器和模型等的接收方
能夠始終返回可安全使用的新對象
容器的初始值設定項基於你輸入初始值設定項的
名稱找到模型
還有另外一個初始值設定項它採取明確的模型參數
默認情況下 新容器在列表中僅有一個存儲描述
它是SQLite附有默認選項
以及基於容器名稱的文件名稱
它存儲在一個目錄中
目錄由容器上的類方法定義
而默認情況下 永久性容器
將基於你使用的平臺向你返回目錄
所以它會在macOS上使用應用支持目錄
在iOS和launchOS上使用你的容器文檔結構
以及tvOS上使用你的容器緩存目錄
若你想設置自己的目錄那麼你可在永久性容器中
劃分子類並替代直接
不好意思 默認的目錄URL類方法
容器在設置Core Data時真很有用
不過它們也給一般操作帶來了便利
容器有一個主隊列上下文屬性
叫做查看上下文你可以使用它驅動你的UI
還有一種工廠方法可以提供隨時可用的
後臺上下文但大多時候
你可能要使用容器的方法
來執行叫做performBackgroundTask的後臺任務
所以你無需安裝新的後臺上下文 進行連接
然後排列數據塊以便在後臺進行操作
你只需將數據塊傳送到容器
使用performBackgroundTask的優勢遠不止獲得簡潔的代碼
使用它可以使Core Data減少爲完成你作業而
創建的上下文數目同時能夠與連接池一起
確保你的應用響應快速即使是在重負載的情況下
說到一般上下文工作流
NSManagedObjectContext今年有一個新屬性 叫做
自動合併來自父級的變更
它是布爾值當你將它設置爲真
上下文會自動合併保存其父級數據的更改
這可以用於...
這真的很便利它可在父級
保存變化時用於子上下文
它也可以在同級保存到存儲時用於頂層上下文
它尤其適用於世代標記
這個Melissa之前介紹過
所以如果你把UI上下文固定到最近的世代
並且啓用自動合併你可以不必維護你的UI
你的fault會很安全你的對象綁定
以及提取結果控制器將保持最新
好
讓我們討論下泛型
Core Data今年採用了泛型
而且它們在ObjC和Swift中都很好用
有一種新的協議叫做NSFetchRequestResult
所有你可能看到的類型
都採用了這種新協議從提取請求
如NSManagedObject或所有的實體子類
對象ID、NSDictionary以及NSNumber
NSFetchRequest現基於結果類型被參數化
協議一致性限制結果類型在Swift中
NSManagedObjectContext上的提取方法探究提取請求的類型
一直探究到你的結果
最後 提取結果控制器
它採取了對創建它的提取請求的參數化
說到NSFetchResultsController
如果你正在使用UICollection視圖 不好意思 在這兒
UICollection視圖若你使用Core Data
採用新數據元預提取功能
會非常簡單
你需要做的只是異步提取請求
從而從主要線程獲得請求而且你應該確保
不會將對象作爲fault返回
關於數據源預提取的詳細信息
請查看Steve和Peter昨天的分享
UICollection視圖新特點
如果你是Mac開發者我也有好消息告訴你
現在macOS提供提取結果控制器
好 讓我們討論下Core Data中的一些常見操作
從獲取實體描述開始
額 這個 好了
爲此 你需要實體的字符串名稱
以及一個管理對象上下文
創建提取請求同樣需要字符串常數
以及類型轉換如果你想利用新的泛型
最後是創建新的管理對象
其中三樣都有 包括字符串常數
上下文參數以及類型轉換
今年 這些操作都變得簡單了
因爲我們改進了對象子類的管理
實體描述現在是子類上的類方法
別擔心 這樣更好
這一類也有工廠方法
可用於創建新的完全鍵入的提取請求
最後 你可以創建新的管理對象
只需直接使用子類的初始值設定項
還有一件事值得介紹
那就是執行提取請求
我之前提到過 上下文提取方法在Swift經過參數化
但ObjC不支持方法級別的泛型
所以我們也添加了像語義之類的執行者以提取請求
所以你只需從提交到上下文的數據塊內
調用執行方法
就會返回正確鍵入的結果
針對模型子類的新API可以簡化很多事情
不過我猜想你可能真正期待的是
重新生成你所有的子類
但不用擔心 因爲
這應該是你需要處理它們的最後一年
因爲Xcode 8現在能夠爲你自動生成該代碼
你可以按實體配置代碼世代
Xcode會把生成的代碼寫入你項目導出的數據
所以不會導致未經你手的代碼對源樹造成污染
你無需編輯這些文件
因爲當你變更模型時
代碼會自動重新生成
但如果你想進行
在子類中添加自己的實例變量等操作
那麼你也可以告訴Xcode僅生成一個類別或擴展
然後你可以擁有類本身
在Swift中 爲使用該功能你需進行的操作是
導入你實體所屬的模塊
該模塊通常也是你代碼所屬的模塊
但是在ObjC中 你還需要了解一些其中的工作原理
ObjC中最需要了解的是Core Data模型標題文件
每個模型都有自己的標題文件你需要將它導入
以便訪問所有該模型生成的類
如果我們放大 看一下生成的其他文件
瞭解爲生成類而配置的實體
Xcode創建了兩個標題你在自己生成類時
可能已看見過因而可識別出
其中一個聲明類界面
另一個聲明管理屬性
在ObjC中瞭解這點通常很重要
因爲如果你在生成一個類別
那麼Xcode不會生成類界面
模型的標題將會直接導入類別
沒有類界面就無法聲明類別
所以生成的代碼的預期是能夠
在以該類命名的項目中找到標題
這是你擁有的文件如果它不在你的項目中
那麼你就無法構建你的目標
讓我們稍稍離開幻燈片看一看
這些新東西能爲你帶來什麼
我打開了Xcode 8
我們將創建新的Xcode項目
並使用iOS主明細應用
我們今年更新了模塊以便使用新UI
所以 如果我們將這個保存在某位置 然後轉至應用代理
接着我們會看到
我們這裏使用的是永久性容器
我們將母版視圖控制器
與容器的視圖上下文連接
如果我們切換到母版視圖控制器
我們可以看到在創建新對象的地方
我們已經在使用Core Data生成的子類
初始值設定項
我們不再使用KVC
我們可以在管理對象上直接設置屬性
如果我們命令單擊就會轉到生成的文件
如果我們返回 看一下如何設置提取結果控制器
好了
我們能看到在事件分類上
引發提取請求工廠方法
這裏沒有額外明確的鍵入
當我們創建提取結果控制器但是它的類型
非常小如果我們在這兒放大
它的類型通過提取請求傳遞
這意味着 其它地方
比如prepare for segue
好了
當我們從提取結果控制器獲得對象
會返回正確的類型
這樣 都好了我們不再有任何類型轉換
不過 我不想讓這個應用像默認設置這樣
在母版視圖控制器中顯示時間戳
所以讓我們在這裏給事件實體添加一個標題屬性
我們希望它是字符串類型
好了 我們重建並保存了模型
如果我們返回到這兒轉至配置單元格
我們可在這裏刪除相應代碼
使用Xcode的自動完成功能
獲取我們剛剛在模型中設置的新屬性
同樣 如果我們命令單擊它
將更新所有的代碼
這其中最大一個隱性的好處是
如果你使用手動生成的子類
甚至KVC 如果你更改屬性的名稱
你最後可能遇到非常奇怪的故障
因爲你的項目會編譯
但如果實際調用時你會遇到運行時錯誤
因爲註冊表項路徑不再存在
子類生成自動處理所有這些
這就是自動分類生成
以及Core Data新API的一些工作實例
最後 讓我們介紹下SQLite的新特性
操作系統附帶的SQLite庫
有一些你在其它地方找不到的新功能
首先是多線程聲明
Apple平臺上的SQLite沒有線程安全連接
多線程故障很難診斷
有時是因爲它們通常顯示爲崩潰報告
SQLite深處只有一個線程
爲使這些問題更容易被識別和重現
系統SQLite支持新的環境變量
該變量可以啓用多線程聲明
當它們啓用時你將在SQLite中看到兩個線程
兩個線程均使用同一連接
SQLite始終通過可使用SQLite3 config進行配置
支持用戶定義的記錄功能
但是應在庫初始化之前調用該功能
而庫初始化可能已經發生
SQLite的可配置性很棒
不過我們在運行建模系統該系統有內置記錄設施
所以現在有另一個環境變量
將SQLite記錄送到系統日誌
最後 我要介紹下文件操作
所有的數據庫由一組文件表示
當文件操作在多個文件中進行時
文件操作不可能是原子的
這樣的結果是所有的文件操作
本身都是不安全的
從Unix文件API到NSFileManager 所有的
這一點確實很重要
我想分享幾個實際的例子
表明問題如何產生
比如 我發現目錄中有兩個數據庫文件
我的代碼要進行清理所以刪除了兩個文件
在刪除數據庫時
日誌之類的東西連接到數據庫文件
該數據庫無法訪問日誌
所以系統無法識別數據庫
就立即報告錯誤
因此影響你的應用
除非你能保證目前沒有任何東西
將來也不會有任何東西試圖連接到數據庫
否則刪除文件都是不安全的
比如 我有wall模式的數據庫
該數據庫正在使用中
由於某種原因 數據庫最終被移開
當數據庫在新位置打開時
相應的連接創建了新的日誌和鎖定文件
現在你就有兩個連接
分別使用不同日誌和鎖定
不久 它們就會損壞數據庫
這些例子可能有些牽強不常見
但是總共有超過十億的設備
可能發生問題
對每個可能文件的每個可能的操作
都可能導致使用你應用的用戶遇到問題
如果用戶數據丟失 就會很慌亂
硬鏈接非常不好
不要對數據庫文件使用硬鏈接
所以 今年的新內容是操作系統附帶的SQLite庫
充分利用分派源
如果非法操作對文件產生影響
數據庫連接會報告錯誤
系統自身解決數據損壞問題
大多情況下 損壞已經發生
所以爲幫助你識別並糾正這些問題
我們添加了另一個環境變量該變量可以使連接
在發現非法操作影響其文件時立即作出聲明
如果你想知道
數據庫損壞的更多原因
SQLite在網站上有指導手冊
名稱是“如何損壞SQLite數據庫文件”
幸運地是 這些問題是可以避免的
如果你直接使用SQLite你應確保
只有一段代碼擁有該數據庫
該段代碼應進入專門的文件訪問
所以文件在打開時無法被修改
若你正使用Core Data你應該是在用
永久性存儲協調器內有一個API
可以始終安全地用於SQLite數據庫
無論是數據庫打開與否
replacePersistentStore可將一個數據庫更換爲
另一個數據庫的內容
而destroyPersistentStore
可以安全刪除數據庫中所有內容
並留下空白的數據庫
好 上述就是今年Core Data的新特性
簡要回顧下 我們新增了一項叫做查詢生成的功能
這種功能可以使你即刻看到數據的穩定視圖
我們現在使用支持連接池以及永久性存儲協調器
這樣可以同時允許多個讀取器
作爲單個編寫器使你在進行大量數據操作的同時
能夠保持漂亮的界面
Core Data設置更簡單了
新API也使Core Data使用更簡單
它在Swift中尤其好用
這得到Xcode全新集成的全面支持
我們在SQLite中也有新功能
可以使一般問題的調試更簡單
要了解更多信息
請查看我們的開發者網站是在演講242
如果你想了解更多可以參考Swift新特性
以及Cocoa的新特性
感謝大家的到來