SWIFT API設計準則GRAND RENAMING
謝謝
歡迎 我是Doug Gregor
在這裏 我要跟同事Michael Ilseman
談論關於設計的問題
因爲好的設計能提高效率
而好的API設計能幫助我們使用Swift語言
寫出清晰 簡練 優美的代碼
這一點完全正確無論是當你在爲上百萬
其他開發者編寫API時
還是你在自己的應用裏爲自己寫代碼時
因爲好的設計真的很重要
所以...
今天我們將介紹Swift API設計準則
這些是我們要介紹的Swift 3的新準則
我們將介紹這些準則背後的原則
對其中一些準則進行討論從而瞭解
如何構建優質的Swift API
然後 我們會討論下Grand Renaming
我們將用這個名詞來指代這些準則
在你日常所有API中的應用
包括Swift標準庫
Cocoa和Cocoa Touch API
現在 這個Grand Renaming將影響你的很多代碼
基本上使用Swift 2語言的所有代碼
在Swift 3中都將有一定程度的改變
所以...沒錯！
所以 我們將討論下這對你的代碼意味着什麼
以及如何應對開始適應Swift 3的思維
最後 我們將討論下我們的一些新工具和技巧
以便將C和Objective-C API
映射到優美的Swift API
這可涉及大量的概念和原因解釋啊
你關於準則的最大疑問可能是:
爲什麼？
爲什麼在使用Swift兩年後
我們要改變你日常工作接觸的所有API
答案可以歸結爲語言的特點
因爲每種編程語言都有自己鮮明的特點
都有自己的句法風格
但這又不光是句法
也是一種語言選擇做出的
一種折衷
它是傾向於安全還是性能？
你是更喜歡數學的精煉性
還是更喜歡清晰易讀的東西？
你看一下Swift代碼就能馬上讀懂代碼
這裏 你能夠看到Swift呈現出關於特定事物的觀點
它使用結尾閉包
所以控制流能很好地用於庫和API
它有可能選項 所以你必須時刻記住零值的可能性
而不能簡單忽略這種可能性的存在
這樣 使用Swift語言時你會有Swift的感覺
但這不光是語言引起的
而實際上是你日夜使用的API引起的
而且API必須與語言的特徵融合
這樣 你才能得到優美的Swift代碼帶來的一致全面的體驗
這裏是一些Cocoa和Cocoa Touch API
這些API的設計基於針對Cocoa的編碼準則
你可能之前讀過這些準則希望你讀過
這些準則提倡在API設計中
注重清晰度和一致性
而過去十多年我們已將這些準則
應用到成千上萬的API
用於開發Cocoa和Cocoa Touch平臺
以及我們使用的絕妙的API
現在 而這些準則針對
具有不同特徵的另一種語言設計
所以 當你將爲Objective-C寫的
所有API毫不修改地放到Swift中
就會看起來個性不合
這些API不怎麼Swifty
這又意味着什麼呢？
不Swifty？
你聽到很多人這麼說
不過 本質上這就是爲什麼在成千上萬
開發者使用Swift平臺兩年後
現在是進行重新評估的時候
因爲我們擁有更廣大的開發者社區經驗
可以瞭解在Swift代碼中什麼是有效的
所以我們開始設計API設計準則
嘗試規定 怎樣算是構建具有Swift特徵 即Swifty的API
以及幫助所有人使用我們喜愛的語言
構建更加一致和清晰的API
現在你在左下方能看到SE-0023
這是Swift的演變提案編號
其中包含所有的API設計準則
在整個演講過程你將看到這些提案編號
此外 你可訪問Swift.org
查找這個提案代碼瞭解關於Swift語言
這一特定變化的詳細信息
不過現在讓我們討論下準則本身
Swift API 設計準則的主要原則是
在使用時清晰明瞭
就是你的API在他人代碼中顯示時能夠清晰明瞭
我們喜歡簡練的代碼
但清晰明瞭是最重要的方面
這比寫出簡練的代碼要更重要
雖然如此 Swift中確實也有簡練的代碼
Swift代碼確實會更簡練
看到Swift語言時我們能感到該簡練性
而在討論各種導入Swift或使用Swift寫的應用時
我們可以實際衡量這種簡練性
不過這要源於使用正確的語境線索
讓我們更深入地瞭解下這些準則並看一下一些API
現在 我們先討論下使用
爲什麼要關注使用站點呢？
嗯 一方面這不過是簡單的數字遊戲
你寫你的API只要一次
而人們會多次看你的API代碼
或者API文檔
但API真正重要的大多情況下
API被看到次數最多的時候將是處在上下文語境中
周圍有大量其它代碼
當你處在這樣的語境中
你就擁有所有額外豐富的語境信息
你擁有局部變量及其名稱和類型
你擁有相關API的使用
而你的API的目的不是站起來說：
“嗨 我在這兒我信譽好 名號大”
你的API的目的是適應其它代碼
從而產生完美的結果
那麼 當你關注用例時一定要避免
去針對不好的代碼進行優化
這一點絕對會發生有的人寫代碼
會對所有的變量使用A、B和C這樣的名字
這樣的代碼不再清晰
而僅憑API並不能改善這種不好的代碼
你能做的就只是讓其它代碼更囉嗦或更不清楚
所以請關注適當的用例
關注好的代碼針對好的代碼去調整API
這裏 讓我們實際看一個具體的例子
那麼 讓我們首先看一個API
從集合中刪除一個項目
首先 我們將它命名爲“removeItem”
聽起來不錯但這是我犯的第一個錯誤
這不是用例
這只是簡要的名稱
那麼 讓我們顯示今天我想到的一個用例
不要問爲什麼
他知道 將項目“ted”從好友列表中刪除
現在 你會注意到該用例中實際有兩個東西
指示參數是什麼
這兩個東西都試圖對參數進行描述
其中一個是單詞“item”也是名稱的一部分
另一個是參數“ted”
即一定類型的某個局部變量
這兩個符號中 變量“ted”實際能更好地描述
參數是什麼
它是處在語境中的
在語境中讀取此調用時你會知道這個局部變量是什麼
它表示一定意義它具備強類型
所以這裏的問題實際可能是
單詞“item”描述性不夠強
也許改爲“removeObject”
我們會覺得舒服點
不過也許事實也不是這樣
因爲無論如何我們很可能用的是值類型
所以這只是活躍性的錯誤
我們可以改爲“removeElement”
好 Swift語言的集合也使用element術語
不過 這樣也不起作用
而且 如果我們開始寫下不同的用例
實際上可能會更不清晰
我想將“caffeine”
這個元素從有機化合物列表中移除
這是誤導性的錯誤的
“咖啡因”不是元素
它是元素組成的化合物
所以 這裏我們試圖使用一些無傷大雅的詞
來描述參數 這實際讓我們寫出了更模糊的用例
好
所以 可能問題是我們應該停止
將這些看似無傷大雅的概括詞用在那裏
我們應該特別具體
將“ted”這個人從好友列表中移除
這句英語有點怪
我不會這麼說 我只會說“remove(ted)”移除ted
不過進一步講
如果我這麼做了如果對這種一般性的API
我做到了特別具體 那麼我會期待任何時候都很具體
現在 有一個概念性的API即 只是將某個項目
從集合中移除 而該項目在源數據庫基中有不同的名稱
這樣就更難理解了
很難識別出我們實際說的
是在不同語境中的同一樣東西
所以 Swift API設計準則採取了不同的方法
略去不必要的單詞
如果一個單詞不能使使用站點更清晰
就不用這個單詞
所以我們可以只是說從好友列表中“remove(ted)”
這樣讀起來很順
這種做法之所以在Swift中如此出色地實現
原因之一是 Swift有強大的靜態類型系統
可以確保你不會寫出無意義的代碼
或者對代碼解釋錯誤
所以 強大的靜態類型系統能確保
你允許移除的參數
是相應集合中的元素
如果你要做出任何失策的舉動
比如 試圖從好友列表中移除“caffeine”咖啡因
你會收到編譯器發出的錯誤消息告訴你代碼不符合邏輯
所以 我們討論了使用站點的可讀性
我們排除了很多的單詞
你可能因此覺得我們追求的是簡練的代碼
事實並非如此我們想要清晰的代碼
不過...
清晰的代碼也需要達到適當的平衡
不能過短或過長
如果想知道什麼代碼過長
過長的代碼是包含不必要額外信息的代碼
過長的代碼實際會影響清晰度
因爲 在讀這種冗長代碼時你的腦子在做什麼？
它在努力篩除所有額外的噪聲
篩除所有冗餘的不必要的東西
從而找到代碼中實際的信息
而這個平衡的另一端也不可取
如果你的代碼過於簡練
那麼你可能遺漏必要的信息
以致使代碼難以理解
什麼表明代碼過於簡練
如果你在讀代碼你發現自己會總是參考
API文檔因爲API本身描述不夠清楚
則說明代碼過於簡練
所以我們要找到中間最佳的平衡點
使代碼既清晰
又簡練
這樣 瞭解API和API工作方式需要的所有信息
都在語境信息中
這實際上是Swift語言本身的原則
所以 這裏我提供一些代碼
在這些代碼中實際存在
Swift中不需要的冗長信息
就是這些直白的類型註解
這些註解沒有增強代碼的可讀性
僅通過讀API你就可以瞭解這些類型是什麼
實際上 在Swift中你很可能不會這樣寫代碼
你可能會匹配這種類型信息
讓靜態類型trebicore
幫你作註解從而使代碼更簡練
也仍然清晰可讀
當然 類型很重要
類型就在那裏
如果你需要確定特定的類型是什麼
而這樣能有助於你理解
當然 你可以選擇獲取答案只需在Xcode內單擊
那麼 讓我們看一下另一個API
並討論下什麼時候實際需要一個單詞
纔有助於描述參數
我們以這個小API爲例即 將“子視圖”
添加到某個“主視圖”中的某個特定點
因此 我們寫出用例
記住始終從用例開始
想一下用來描述參數的詞
在第一種情況下單詞“child”用在了
這個“視圖”參數中也就是我們第一參數
“child” 表達了什麼信息嗎?
嗯 從靜態類型系統中我們知道
邊欄會是某種視圖
但單詞“child”可以說明操作中
此參數的作用
它表明了這裏的參數將成爲“child”
它建立了層次結構
這確實是很重要的信息便於我們瞭解這個API的作用
現在 第二個參數中存在“atPoint”和“origin”
“origin”會是什麼？嗯 它將會是CGPoint
這個API會使用CGPoint
這裏除了CGPoint你也提供不了什麼
所以這個單詞不能表示實際意義
它只是在重複說明強靜態類型系統中
已經存在並將被Swift語言
實施的信息
所以去掉這個詞你不需要它
現在看看這裏調用站點的樣子
如果大聲讀出來你在“origin”添加“child”邊欄
讀起來語法很對
這是這種
特定API設計準則的原則之一
即 我們力爭達到使用點通順並語法正確
這裏的例子 從我們的好友列表中移除“remove(ted)”
就具備這種特點
現在 讓我們看看一個非常相關的API
這個API是要移除特定的元素
如果我們看 比如移除特定位置某項目的API
讀出來
從集合中移除之前好友的位置
讀起來不對
這不是位置的集合
而是人的集合
讓這句話實際讀起來符合邏輯 我們要說“remove at”
讓我們讀出來：
在之前好友的位置移除
請注意我們澄清API行爲的方法
是放入第一個參數標籤 以描述
參數與該方法的關係
這就涉及命名和命名的概念
所以 在Swift中一個函數的名稱包括
所謂的基名稱在這兩個API中即“remove”
以及參數的所有參數標籤
所以這兩個相關的API它們有相同的基名稱
即“remove” 因爲它們屬於相同操作方法系列
即從集合中移除某項目
但它們的參數標籤不同
因爲它們做的事情不同
一個是按照身份移除元素
另一個是基於在系列中的位置移除元素
所以略微不同的API擁有不同的名稱
現在 你可以基於類型信息進行重載
如果兩個API擁有同一複合名稱
但只有當API的語義
相同時你才能這樣做
所以這裏你可以重載
沒有參數標籤的附加名稱從而將字符
或字符串附加到某些文本
因爲它們根本上屬於相同的操作
它們只是出於方便起見被重載到不同的類型上
現在寫出第一參數標籤後
同樣 你需要保證用例讀起來符合語法規則
這包括方法的基名稱
以及參數標籤
所以這是我第一個API：removeBoxes (withLabel:WWDC)
注意這讀起來順不順
注意 這個API內有一個介詞短語
所以這有點像英語語法本質上這個短語是“withLabel”
它描述參數與移除方框的實際操作
之間的關係
當存在這些介詞短語中之一時
將它放在第一參數標籤上以描述第一個參數
如果你根本無法構成符合語法規則的短語
也可以使用第一參數標籤
因爲如果將第一參數放在那兒
具有一定誤導性
所以這裏 我們有“viewController”我們說“dismiss(true)”
那是什麼？我不能把布爾常數到處亂放
所以 要讓這句符合語法規則
我需要在那兒放上一個參數標籤
解除“viewController”
變成動畫Animated爲真
所以這是附帶的額外信息
第一參數標籤將它分解開所以讀起來很順
而且很清楚 我們解除的就是實際的視圖控制器
你可以訪問Swift.org閱讀其它若干規則
但本質上 你仍會在某些情況下略去第一參數標籤
這些情況下在API中僅僅是有自變量
就讀着很順：
在好友的起始索引處插入“michael”
這讀起來很順
我們不需要第一參數標籤使它讀起來通順
所以我們將標籤省略
好
在繼續之前我們稍稍再介紹下命名
在對方法進行命名時基於方法的副作用命名
所以 請使用英語動詞和命令
告訴接收方“做某事”
所以這裏 我們可能說我們有好友集合
對它進行反轉“viewController”　請顯示
“Organic compounds”請附加
對吧？這些是採取的操作
我們基於採取的操作命名
現在 我們有一些方法其主要作用就僅僅是
返回某值
我們使用名詞
描述返回的東西
所以 這裏我們可以要求獲取按鈕的背景標題
或者好友陣列的後綴
當你在處理值類型時
有時情況是這樣的你擁有本質上相同操作的
轉變和未轉變形式
這裏我們喜歡稱作
使用我們喜歡稱作“ed/ing規則”的東西
這來自英語語法
基本上你要從動詞形式開始
所以這裏 我們有“reverse a collection”
你命令X自身反轉
而對於更像是名詞的其他形式
使用“ed規則”
我們要求X被反轉
我們描述我們想要的結果
這就與轉變形式對應
而“ed規則”不適用時
一般適用“ing規則”
通常這時這裏有一個參數
我們有一個文檔目錄
我們可以對目錄附加路徑組件
這就是轉變我們告訴它附加這個
現在我們有未轉變形式
給我這個文檔目錄附加這個特定的路徑組件
所以這些規則 以及許多其他規則 在Swift.org上
作爲API設計準則文檔的一部分 都有描述
強烈推薦大家進行閱讀
並努力在自己的API中應用
不過 當然
只有實際廣泛應用了這些準則纔會變得有趣
所以我們要進行Grand Renaming
就是將這些準則
應用於Swift標準庫
應用於Cocoa和Cocoa Touch API
以及應用於指向性地
改進API 如Core Graphics以及Grand Central Dispatch
這些準則可用在所有情況下讓這些API經過Swifty整容
從而在Swift中更美觀
我之前稍微提到Grand Renaming的規模
所以 這是一個小Swift應用的截屏
應用叫做Lister這個應用已經發售幾年了
在從Swift 2遷移到Swift 3時Lister是樣本應用之一
大家可以看到左邊有很多.swift文件
基本上 整個項目中每一個Swift文件
都因爲從Swift 2到Swift 3的過渡而改變了
如果你們留意這裏中間和右側窗格中的一些細節
你們可能發現這些Cocoa API名稱都變了
所以 這裏有很多改變我們將就此進行介紹
不過 非常有趣的是這些你們可能
已使用很長時間的Cocoa API這些API是一樣的
但現在 一個特定的API有兩個不同的名稱
一個名稱適用於Objective-C
另一個名稱適用於Swift
作爲Swift程序員大多時候你不必在意這一點
你完全可以在Swift名稱下工作
使用你生成的界面和文檔
所有材料都將顯示Swift名稱Swift名稱就是你要應對的
不過 有時你跟系統交互這種情況下
你實際上確實需要Objective-C名稱
比如 如果你要激活目標操作
所以 這裏我們實際需要
爲目標操作提供選擇器
我們有這個字符串參數
在這裏寫什麼呢？
我不知道你可以看看生成的界面
或者在Twitter之類網站上問你的Swift編程朋友
你能得到答案這沒問題
但是 請不要這樣做
因爲這個鏈接非常非常薄弱
這個字符串參數非常容易輸錯
它跟上面你實際想要調用的方法之間的鏈接很薄弱
爲此 在Swift 2.2中我們引入了#selector
#selector非常簡單就是一個表達式
它接收Swift方法的名稱
然後產生該方法的Objective-C名稱
你不需關心Objective-C名稱是什麼
編譯器會搞清楚
當然 這一點最棒的是
Swift確保存在該方法
確保該方法向Objective-C公開
並計算出正確的名稱
當然這可防止重構
可以使用代碼補全
讓你享受更舒適的開發體驗
這意味着你無需擔心Objective-C名稱
在Swift 3中 對此進行了延伸 你也可以參考屬性的
接受方和設置方
所以我們完成了
實際能計算的Objective-C方法名設置
這使用起來非常簡單
你只需輸入參數標籤設置方或接受方
就可以分別獲得設置方或接受方
然後參看Objective-C屬性
當然編譯器會驗證
該屬性是否存在並向Objective-C公開
爲該屬性獲取正確Objective-C名稱
現在 提到Objective-C方法名
選擇器並不是唯一字符串類的東西
我們也有項路徑當作爲字符串參數
編寫而沒有任何驗證時項路徑是出了名的難寫對
所以在Swift 3中我們也將引入#keyPath
#keyPath的作用跟你們料想的一模一樣
你可以參考圓點間隔的屬性訪問序列
編譯器會驗證這些屬性實際上是Objective-C屬性
獲取正確的名稱
然後生成我們傳遞到框架中的字符串
所以通過#selector和#keyPath
你基本不需要擔心Objective-C名稱
你只需要使用Swift名稱編程
然後停留在這套Swift名稱裏
你無需遊走於邊界兩邊
現在 有的情況下你確實需要考慮
Objective-C名稱爲何
你可能有一個混合項目裏面有Objective-C代碼
需要關聯到你Swift代碼中的名稱
像這樣的名稱：“handleDragWithSender4”
在Objective-C中時感覺就是不太對
所以這些情況下你可以使用@objc屬性
在圓括號中 輸入你想要的確切的Objective-C名稱
該名稱會體現到你生成的標頭和所有元數據
等等當中這樣你能夠具體控制
Objective-C名稱
但是你Swift代碼的其他部分都無須在意這一點
當然 這個@objc具備名稱 適用於屬性
適用於方法、類和協議
任何可以從Swift向Objective-C公開的對象
你可以在這裏控制名稱
所以對於Swift代碼你可得到漂亮的Objective-C API
好
Swift 3 發生了很多改變
Swift語言本身讓你無需考慮
Objective-C名稱
然而當你確實在意Objective-C名稱時
它又讓你可以獲取所需的掌控力
我們有這些工具幫助你
所以Swift 3遷移器進入Swift 2代碼並將它
遷移到Swift 3名稱和Swift 3語法
這涉及很多變化
但這些工具可以幫助你渡過難關
適應Swift 3下的工作
Swift 3遷移器是很棒的工具
但它不能遷移你的肌肉記憶
當然也無法遷移從堆棧溢出複製粘貼的所有代碼
所以 Swift編譯器也可以爲你提供幫助
Swift編譯器瞭解所有這些API的
Swift 2名稱和Swift 3名稱
所以如果你在一些Swift 2代碼中編寫或複製
編譯器會識別舊的API名稱並向你提供診斷
使用Fix-its更新代碼幫助你快速適應並工作
此外 我們引入了相近差錯檢測
在實施可選協議方法時可用
所以 當你在實施委託時 這個功能很棒
你犯了個小錯誤
你想要實施的委託方法名稱錯了
現在你收到警告消息附帶Fix-it 以便修復名稱
這樣你可以放心你的方法會被準確調用
現在 我想將舞臺交給我的同事Michael
他將介紹將C和Objective-C API映射到Swift
所以Swift很了不起
但如果你是Objective-C開發者呢？
或者你的項目是混合項目呢？
所有Objective-C API在Swift中都有
它們一直都在那裏
但正如Doug解釋的這些API是針對另一種語言設計的
在Swift中 它們日漸顯得有點格格不入
所以今天我將展示你將如何控制局面
使你的Swift用戶獲得應有的優質API
我會先開始展示幾個Objective-C API
它們被導入到了Swift 2中
這裏有兩個方法saveToURL forSaveOperation
和revertToContentsOfURL
不過這些確實沒有體現Doug介紹的API設計準則
裏面有很多冗餘的類型信息
我們沒有有效地利用第一參數標籤
第一參數標籤
我會先開始介紹你在Swift 3編譯器中
自動免費獲取的功能
Swift 3改進了Objective-C API的導入方法
Swift編譯器將檢查方法名並使用語法正確的提示
以便推斷第一參數標籤
Swift編譯器將檢查名稱
從而消除冗餘類型信息
編譯器甚至可以推斷一般Objective-C習慣用語的
默認參數如完成處理程序
或選項集
同時 有新的值類型如連接到NSURL的URL
所以導入時我們只需直接導入
要了解這些值類型的詳細信息 請訪問
今天隨後的“Swift基礎的新特性”
所以 自動推斷非常棒
但根本上它是啓發式推動的
編譯器不懂讀心術
它不知道你的意圖
經常你需要指定自己的名稱
爲此 我們擴展了NS Swift名稱
現在 自從Swift 2起NS Swift名稱就存在了
但在Swift 3中 我們支持完整的複合命名
複合名稱是基名稱加參數標籤
所以這種情況下我們有兩個方法
它們執行語義十分相似的操作
但它們的不同點基本在於它們處理參數的方式
所以在同樣的基名稱約束下我們導入它們
但我們說我們希望它等於此定位標記或
大於等於此定位標記
現在方法名可以推動你朝向Swifty API行進一大步
但行進的距離仍然不夠遠
這裏 我有一些簡單的代碼可以創建標準的
格利高裏日曆
但如果你看一下這個這真的不怎麼Swifty
尤其是NSCalendarIdentifierGregorian
這是個普通的字符串全局變量
普通字符串全局變量這可不是使用Swift編程的方法
這就是我們戲謔爲字符串型API的東西
而這種API使用字符串
這一定程度上導致簡單錯誤的發生
沒錯 故障很簡單開發者可以馬上發現
但是此API的用戶必須記得這是什麼
以及這不是可以用在這裏的有效字符串
這樣對用戶造成了不必要的認知負擔
所以 爲什麼這個API是這樣的？
我們都知道爲何該API是這樣的因爲它來自Objective-C
但該API來自Objective-C的事實
這是實施信息
而這種實施信息泄露了
在Apple我們並不喜歡信息泄露
要搞清楚哪裏出錯了
讓我們看一下Objective-CAPI如何映射到Swift的
我們的全局變量作爲全局變量進入 當然
但除了全局變量的名稱外
沒有什麼可以告訴你
這是針對特別具體的API的特別具體的字符串
現在 我們可以嘗試添加typedef以試驗並暗示我們的意圖
但是typedef不過是個類型別名
它是舊類型的新名稱
所以這實際上不能解決這裏的問題
所以 API會是什麼模樣
如果我們要在Swift 3中重新設計？
我們可能會在字符串周圍形成新的包裝類型
從而獲取一些強類型
而這些全局變量相反 會是靜態屬性
所以在Swift 3中 我們引入了僅針對該用例的新屬性
你可以通過NS ExtensibleString Enum訪問該屬性
當你想要告訴Swift編譯器
圍繞字符串形成新的包裝類型時
你可將此添加到typedef
導入程序將圍繞此爲你創建新類型
任何此類型的全局變量將作爲此類型的
靜態屬性自動導入
因爲這是可擴展的我們在這裏選擇一個結構
就是說 其他模塊可能需要定義自己的結構
而如果它們定義了 它們也將作爲靜態屬性被導入
到該結構的延伸部分
現在 在幕後Swift編譯器會直接將此映射到
潛在的存儲值中
意味着這其中沒有額外的經費或裝箱
或中間過程
所以 讓我們關注使用站點
因爲好的API設計始終關注使用站點
過去如此...
以後也如此
因爲類型語境更清楚
我們甚至可以只是說“.gregorian”
下次 我會自己開始領頭鼓掌
同樣 在Swift 3 NSCalendar中現在 它作爲日曆爲我們所知
這是個小改進
所以 我們有方法名以及類型
我們還有什麼？
好 我們有大象
就是說 我們在屋內有大象
我們一直假裝看不見它
但它始終在那裏
它就是C
現在 通過Objective-CAPI已經面向對象了
所以導入時 我們只需更改幾個字符串 添加幾個類型
這相對簡單
但是C呢？
我將主要介紹核心圖像
現在 核心圖像是一種非常流行的API
基本每個Swift應用都會用
這是一種強大的API但它的外觀和感覺都像C
讓我們從一些代碼開始
我這裏有兩個函數
第一個轉換 嗯...
進行轉換並旋轉特定偏移量
第二個函數跟蹤紅色路徑
現在 兩個函數都不怎麼複雜
而且細節並不重要
但我只是想看看這看起來怎麼樣？
感覺如何？
繼續 等等
所以 如果你注意你會發現代碼完全充斥着
全局變量和全局函數
當然 我們不怎麼喜歡全局函數
或全局變量
所以我們怎麼拿到一個這樣的API
然後使它變Swifty？
我們如何使它有Swifty的感覺？
好 爲此 我們再次看一下NS Swift名稱
你可以使用NS SwiftName將全局作爲類型成員導入
讓我從全局變量開始向你展示我的意思
在這裏 頂部有C的定義
下面是生成的Swift界面
下面是Swift使用站點
將重點關注Swift使用站點
並改進Swift使用站點
我們添加NS Swift名稱並使用typename.membername
從而告知Swift編譯器應將kCGColorWhite
作爲CGColor上的靜態屬性導入
當然 Swift使用站點現在可以使用正確嵌套的屬性
當然 如果類型語境清楚
用戶甚至可以略去CGColor
新的核心圖像有很多不同的全局函數
可以創建不同類型的CG Affine Transform
這是CGAffineTransformMakeTranslation
以及CGAffineTransformMakeRotation在所有這些上面
但在Swift中我們更喜歡初始值設定項
所以我們使用TypeName.Init並提供參數標籤
以便告知Swift編譯器
這應該只是一個初始值設定項
我們使用參數標籤
以便明確參數的角色
你也可以作爲實例成員導入
使用特殊參數標籤self
以告知Swift編譯器
將參照self插到什麼參數中
所以現在CGContextFillPath僅僅是一種方法填充路徑
當然Swift使用站點
只是像是方法一樣調用它
編譯器將獲取圓點左邊的內容
將其插入相應的參數位置
就按照特殊參數標籤self指示
我們可編寫更復雜的代碼
你可以在Swift名稱前加上接受方或設置方
告訴編譯器將此函數
作爲計算的屬性導入接受方或設置方
ArtistGetName
ArtistSetName現在就是
計算屬性Artist接受和設置方
讓我們關注使用站點
因爲好的API設計始終關注使用站點
以前 我們會使用全局函數
記住藝術家曾用名
並使用另一個全局函數設置新名稱
現在 我們的用戶可以直接使用計算的屬性
所有情況下經費成本都是零
編譯器看到myArtist.Name時就會將其
直接映射到相應的C函數
而不調用任何包裝或中介或覆蓋
你也可以使用NS Swift名稱嵌套類型
還記得先前我們創建了新的標識符類型嗎？
好 你可以使用typeName
好 成員名稱
嵌套類型名稱從而嵌套類型名稱
所以 這種情況下我們得到了Calendar.Identifier
現在 我們喜歡新的NS Swift名稱
我們這麼喜歡它
以致於我們完全徹底發狂了
這裏不要鼓掌
僅在覈心圖像中
我們就將它用在超過600個API中 600個
現在可以鼓掌了
這確實很瘋狂
那麼 讓我們再看看之前的代碼
之前 我們的全局變量
全局得非常痛苦現在它成爲成員了
而且因爲類型語境更清楚了
我們甚至可以略去類型名稱
我們的全局函數現在是方法
實際上 現在我看着這個我覺得代碼更簡單了
我們不需要額外的變量結果
所以現在代碼讀起來...
讀起來非常美自然又Swifty
我們獲取轉換
進行翻譯
進行旋轉然後翻譯回去
非常簡單
繼續
CGColorCreateGenericRGB
以及所有其他很多很多創建顏色的方法
這些現在是帶有參數標籤的初始值設定項
當然 先別鼓掌
而且 當然CGContextAddPathContextPath
以及所有其它瘋狂冗餘的東西
它們現在都是方法
我們希望你們喜歡這些新的API
所以 總結下 首先我們展示了Swift中新的API設計準則
好的API設計始終關注使用站點
第二 我們瞭解了Grand Renaming
也是我們熟悉的：“哦 不！什麼都變了”
但是別慌一切還好
名稱改進了代碼更清楚了
你得到遷移工具了
最後我們介紹了Swift編譯器的新功能
以便於你擁有自己的Great Renaming
要了解更多信息請訪問該站點頁面
網址爲developer.apple.com並瀏覽Swift.org
開源Swift項目的主頁上
你可以看到Swift的所有演變
我也顯示了核心圖像
不過Grand Central Dispatch有自己的Great Renaming
使用的方法跟我今天展示的很多相同
所以 星期五請關注Swift 3中
使用Grand Central Dispatch技術的併發程序設計
星期五