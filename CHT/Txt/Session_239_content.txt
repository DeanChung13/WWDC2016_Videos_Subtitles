製作現代化Cocoa應用
大家好 歡迎來到“製作現代化Cocoa應用”
我是Corbin Dunn
我將和同事Jeff一起來做本次演講
我們都是AppKit的軟件工程師
讓我們直入正題今天我們將會討論什麼呢？
我們將涉及一大捆的話題
我們來談論下創建一個現代化外觀
如何正確拖放容器視圖控制 表視圖
使用系統外觀storyboard設計
和其他一些酷酷的Mac特性
非常多的東西
我們快速通過一個演示應用來強調
就像我們看到的這個截圖
它如何使用新特性或者如何使用已存在的特性
所有的這些技術
大多數你早已可在MacOSX 10.10或10.11使用了
10.12中的任何新技術我們都會重點指出
關於這個演示應用我們希望你能下載
儘管這個應用還不能下載不過很快就可以
並且該應用和這次演講有關聯
讓我們進入正題
討論一下如何用現代化視圖
構建一個現代化外觀並且你可以做什麼
現代化外觀意味着現代化窗口和現代化工具欄
就像這裏展示的演示應用
其中一個你需要做的是使用全尺寸內容視圖
這個全尺寸內容視圖
允許你的內容視圖進行延伸
在工具欄下面的區域這裏我用白色標記強調
這意味着全尺寸內容視圖
自動地在工具欄和標題欄旁模糊
不需要你做任何事
使用全尺寸內容視圖非常簡單
只是一個窗口樣式的掩碼
你可以使用.fullSizeContentView位設置它
或若你使用Interface Builder
你可直接在勾選框中的全尺寸內容視圖上打勾 就可應用它了
所以如果你要使用全尺寸內容視圖
你可能需要抵消在它下面的內容
例如 假如說
我們想讓一些東西在工具欄或者標題欄下面
我們可能會
在那裏放一個標籤或什麼
若我們想把標籤放那裏如何來完成
在工具欄或標題欄下面
如果有 比如動態高度改變
並且我們不想讓這個標籤擁有一個寫死的Y位移
因爲寫死的位移實在是太糟糕了
所以我們要的是
NSWindow的contentLayoutRect屬性
這是一個可觀測的鍵值一個可觀測的KVO屬性
任何時候你可用它發現contentLayoutRect
藍綠色的區域改變
在這基礎上 你可以把你的視圖
直接放到標題欄或工具欄下面
但是我們也鼓勵使用自動佈局
並且如果你使用自動佈局
你可以使用contentLayoutGuide一個NSWindow上的屬性
例如 在NSViewController子類裏
你可能重寫updateViewConstraints
並且你想創建一個約束
你得到window的contentLayoutGuide
爲它標記上錨點並且你會得到一個文本區域
然後應該創建了一個約束
在這個文本區域的頂部錨點並且激活它
如果你這樣做
在文本視圖會自動在標題欄或者工具欄下面的區域
不用你做任何事
十分容易
接下來 關於現代化的應用你該用一個流線型工具欄
這是一個常規應用的截圖
值得注意的是這裏有一個明顯標題欄
或者 抱歉它在頂部有一個明顯的標題
並且在那應該有一個圖標
若這個應用確實有一個關於這個文檔的圖標
如果使用一個流線型的工具欄那個標題會消失
這個工具欄將會向上移動一點
並且窗口按鈕 關閉按鈕等等
會和標題欄或者工具欄區域在一條直線上
做到這些十分容易
你需要做的僅僅是設置一下標題的visibility屬性
爲.hidden
那麼標題將會被隱藏
工具欄將會被向上推並且所有的東西都會在一條線上
你何時想做這些？
你可能想爲應用做這些例如shoebox應用
例如地圖 日曆
系統設置 具有這類屬性
像是這些一個窗口的應用都非常適用這種風格
還有其他的事可以做嗎？好吧 你也許想完善
標題欄或工具欄的區域
用輔助視圖控制器
例如
你可能想有一個輔助視圖控制器
就在標題欄下面
通過這樣做你想讓它自動變模糊
你不用做任何事
尺寸將會跟隨窗口的尺寸自動改變
不需要你做任何事如何做到這些？
這十分簡單我們有一個視圖控制器子類
叫做NSTitlebarAccessoryViewController
你可以給這個視圖控制器設置視圖
除此之外它還暴露了一個佈局屬性
所以佈局屬性可被設置爲.bottom 意思是
這個輔助將會在標題區域的底部
注意出現在它下面的文本因爲
我們使用符合內容佈局指導的合適的內容佈局
不需要做任何事
除了設置在底部
佈局屬性還可以設置在leading或者trailing
意思是你可以有一個輔助視圖控制器在標題區域上面
例如一個註冊按鈕
或者其它你想添加的
macOS X 10.12上的新特性是使用leading和trailing的能力
和之前發佈的left和right相反
我們更推薦你使用leading和trailing因爲它讓你窗口運作得更好
當你使用從右到左的本地化
這樣 例如
如果我僅僅在從右向左的模式下運行
你可以看到輔助視圖控制器自動反轉
到另一邊什麼都不用做的情況下
接下來我們 系統
可能添加我們的輔助視圖控制器到你的窗口
例如 我們可能爲了創造標籤窗口而使用它
我們聚集多個窗口
到一個類似虛擬窗口
我們如何實現窗口分頁並且你作爲一個開發者應做什麼？
你不需要做任何事情
若你命令一個窗口前
我們做的是尋找和那個窗口相似的窗口
相似是說尋找tabbing identifier屬性
如果它有相同的tabbing identifier
我們優先聚集起這些窗口
到一個單獨被做了標籤的窗口
這些窗口都被認爲是可視的
即使它可能是一個隱藏的標籤
但我們實際將它們隱藏在覈心圖像中
若你使用NSDocument大量的東西 如plus按鈕
在標籤欄裏面的將會自動工作不需要你的任何支持
但若你不使用NSDocument你可以實現一個響應鏈方法
新標籤窗口來創建一個新文檔
或在plus按鈕上的新窗口
欲知更多信息請觀看“Cocoa的新特性”
來瞭解更多的細節
關於標題欄的更多信息
關於輔助視圖控制器及它們怎麼和全屏幕交互的
我強烈推薦你們去看一下2015年的演講
“改善全屏幕窗口體驗”
接下來我們會談論下核心動畫
什麼是核心動畫？
它是一個圖形渲染引擎
在GPU上做大量工作而不是在CPU上
所以任何東西都可以非常快地滾動
所以我們可以很快並且很流暢的動畫
它的一個基礎結構是一個CA layer
我們實際上是怎麼使用圖層創建佈局和視圖的
或者視圖本身呢
這是一個你可能用到背景圖層的動畫實例
一箇中間的圖層 再來一個前面的圖層做一個動畫
你想用多個子視圖中合成你的視圖
來創造一個最終的畫面
讓我們看一下核心動畫的屬性
CALayer允許你創建你可以在屏幕上看到的內容
說到內容 CALayer有一個contents屬性
這個contents屬性可以是NSImage或CGImageRef
恰好呈現出你所看到的
在那個層的contents裏
但你也可以在CALayer上設置其它屬性
比如背景顏色
比如邊框的顏色 邊框的寬度
比如圓角弧度
你還可以在CALayer上發現更多的屬性
看到其他可操作東西並且學會如何來操作
這有些基礎的方式
用來創建一個CALayer的外觀
對此 我們稍後再談
你應該使用一個置爲底層的視圖
所以你將會用NSViews
僅需設置層爲“是”
接下來我將爲你們演示如何操作
它將會爲你隱式創建一個層
意思是你可以通過draw方法提供層的內容
但如果你要使用層我們有兩個更重要的方法
updateLayer和wantsUpdateLayer
接下來我將告訴你這些如何實現
何時你想使用它們
我們用核心動畫來做什麼
該何時用核心動畫和置爲底層？
我們建議你將窗口內容視圖置爲底層
當你將某特定視圖置爲底層時
所有子層也將自動變爲底層
不用你爲每一個子視圖選擇一個層
我們推薦你將視圖置爲底層
並且不要直接把CALayer作爲子層添加
因爲它自動爲你做事
例如當在一個層在視網膜顯示屏上顯示時
我們將會做更多的設置來完成這個工作
打開“置爲底層”非常簡單
在窗口的內容視圖 可將wants layer設爲真並編碼
或者 當然你可以在界面文件夾裏
勾選CoreAnimationLayer
在最頂部的視圖上
所以 一個重要的屬性
置底層視圖屬性是layerContentsRedrawPolicy
你可以設置值爲.onSetNeedsDisplay
它並不是NSView的默認值
意思是 作爲一個開發者的你無論何時
想改變層中的內容或改變視圖
你都得調用SetNeedsDisplay
這與普通的視圖工作方式在語意上稍微不同
當它們移動時它們可能會重新顯示在那裏
改變框架的原點
這是一些你需要明確選擇的
這尤其可以讓動畫效果更出色
所以如何使內容放到層呢？
你的視圖是需要刷新的
你標記爲setNeedsDisplay
並且
我們問你的視圖 嘿
你爲wantsUpdateLayer做了什麼？
給wantsUpdateLayer的答案是什麼？
在這裏出現分支
若wantsUpdateLayer爲是
我們會調用wantsUpdateLayer
若回答否我們會調用drawRect
所以這是一個完整的分支
必須要二選一
然後你可能會奇怪
“好吧 何時該選擇updateLayer或drawRect呢”
這回到我給你們演示核心動畫和NSLayer屬性的位置
所以如果你可以代表你視圖的表現
直接通過設置CALayer屬性
這時你該使用updateLayer
這將會更高效
若你可以設置分層內容
層背景顏色 更傾向於做這些
如果不可以
這裏你該重寫draw或者drawRect
在子類裏做手動繪製
每一個實現drawRect的事件
將有它們自己特有的backing score你可把其看作圖片
因此如果這種東西太多
它將會佔用太多內存
讓我們快速看一個例子
用updateLayer你如何使用它
首先 你將重寫wantsUpdateLayer
你會有一個
updateLayer回調通過返回真
然後將得到一個updateLayer回調
你可以設置層屬性
所以我們得到視圖的屬性self.layer內容
還有self.layerbackgroundColor
或者任何其他的你想設置的東西這次你可以設置
我們再談論一下現代視圖
和如何爲標題欄和工具欄創建一個現代化的外觀
來說一下拖放和來做一些事件跟蹤
對於現代化的拖放
你需要採用的是drag flocking
像視頻中展示的這樣
Drag flocking是每一個獨立的項目
獨立的移動但是會聚集在一起或同時散開
當你將鼠標放開以後
它們將會散回到初始的位置
你只需要使用NSView的方法來用drag flocking
beginDraggingSession
當傳遞一個數組
包含實際你想拖拽的項目
這十分簡單
關於更多的複合控制像一個表視圖
對集合視圖我們提供代理方法供你使用
對於表視圖你應該優先使用代理方法
tableView pasteboardWriterForRow
可提供一獨立NSPasteboard編輯項目
爲表視圖的每一個被拖動的項目
與老方法相反tableView writeRowsWith
到一粘貼板
你編輯的所有東西將會在一塊到粘貼板上
同樣 集合視圖
有兩個代理方法和這個非常相似
對於集合視圖你該優先使用
pasteboardWriter ForItemAt版本而非其它版本
對於drag flocking
macOS X 10.12上的新功能是對drag file promises的支持
這就是你現在才用drag flocking的原因
並且你可以用NSFile PromiseReceiver和NSFile PromiseProvider
來讀和寫文件promises
看下這次的演講
“Cocoa的新特性”瞭解更多信息和細節
讓我們看一下事件跟蹤
假如你有一個窗口
並且頂部有一個按鈕
所以你有這個按鈕
你想讓它發生的是
當你點擊這個按鈕時
從上到下它都像常規按鈕一樣工作
你將做什麼來表現一個彈出
但是你也想弄清楚你點擊的按鈕
並且如果你拖動鼠標拖拽一個窗口
所以怎樣使這些行爲聚到一塊呢
在現代系統上新特性中以恰當現代的方法？
好吧 讓我們討論一下事件追蹤
和如何追蹤事件來做到這個
這個窗口有個方法跟蹤事件匹配掩碼
用一個超時模式處理器
並且這個處理器是一個塊回調
我們更希望你用這個方法而不是用老方法
在NSApplication
它是nextEventmatchingMask
用過去的方法你創建自己的循環
在新的方法中你僅需使用一個塊回調就可以完成工作了
看下這塊回調比如在那個按鈕中
我們將mouseDown分成子類並重寫
首先我們應在mouseDown做的
是調用窗口跟蹤事件
我們想爲drag和leftMouseUp追蹤所有事件
如果用戶點擊 然後後退
我們需要停止
我們會說
我們需要調用super
因爲通過那方式 每件事都會像NSButton一樣正常工作
但這有額外的部分
比如 你點擊並拖拽
並且如果在按鈕裏點擊和拖拽
我們會判斷你是否拖拽得足夠遠
如果拖拽得足夠遠
將不再只作爲一個窗口而是去完成一個performDrag
意思是
當你傳遞窗口performDrag時
窗口和系統將會在那一點接替這個拖拽窗口
不能拖拽和移動窗口
通過在窗口一次次調用set frame
如果你傳遞給系統
一旦你傳遞
如果你的應用卡住了
然後
這個窗口將繼續可被移動
即使應用正在運行
除此之外 其它系統特性將運行
像空間切換
當你移動到窗口頂端空白欄將會向下移動
窗口捕捉 窗口對齊
任何其它新加入的系統特性
在窗口的移動下會自動工作不需要你做任何事
所以我們希望你向下傳給系統
通過調用performDrag
剛纔討論了拖拽和事件處理
讓我們談論一下容器試圖控制
和如何適當的使用這些
容器視圖控制我們應該使用
基於表視圖的視圖
你通過使用代理方法tableViewviewFor: row: 來做這些
或者你可以在InterfaceBuilder裏設置一些東西
直接通過InterfaceBuilder本身
這樣做的原因是你可以像視頻中我們看到的那樣
新特性 例如滑動刪除
這僅僅存在於基於表視圖的視圖裏
通過滑動來刪除非常簡單的
這有一個表視圖方法
rowActionsForRow
在一個特殊的邊緣
在左邊或右邊的邊緣 抱歉應該是在頂部和底部的邊緣
並且你可以返回一個數組一個或多個或沒有或更多行的操作
在NSTableView的行操作中
允許你給按鈕的標題創造一個字符串值
和一個處理方法
當用戶點擊時才觸發的代碼
或者滑動屏幕足夠遠才觸發的代碼
接着我們談論下滾動視圖和它的複合控制
到目前爲止我們談論的技術
例如滾動視圖...比如我們獲取窗口
和設置窗口標題欄顯示透明
它使標題欄看上去透明
如Messages這類應用充分利用該特性
允許內容在下部顯示
我們來看一下發生了什麼
在一邊的滾動視圖顯示
在標題欄/工具欄下部區域的內容並會自動將其變模糊
但是這呈現出兩難處境
如何使滾動視圖被自動插入
以致你不需要添加一個空行
或其他什麼奇怪東西？
做這些十分方便和簡單
滾動視圖有個方法
或屬性叫contentInsets
允許你將內容稍微向下移動一點
實際上 我們讓它自動實現
我們有個屬性automaticallyAdjust ContentInsets
如果你設置它爲真
然後我們讓滾動視圖使用KVO
之前說的跟蹤contentLayoutRect
自動設置內容插圖
爲一個合適的值
但作爲開發者 你可能想更自由控制內容插圖
你可能想讓它更向下
來添加一切其他的幫助控件
比如一個搜索區域或者其它東西
在我們的系統中的一個例子是
Mail向下了一點添加了排序指示器
這就是我們在系統應用中的使用方式
下面說說自動佈局
你應該使用自動佈局
你也應該使用base localization
你所有的nymphs都該在base.lproj中
除了使用多個不同文件夾和本地化副本
你不應該使用固定寫法
你想用控制去得到內在的內容大小
而不是寫死大小
優先使用堆視圖
使用leading和trailing屬性 這些都正確
對於創建一個合理的本地化應用
我們看一下IB中的本地化選項
尤其文本方向、佈局和鏡像部分
文本方向有三個值
自然的 從左到右 從右到左
自然的意思是
實際的控制器將根據字符串值
你給你這個控制器設置的 如文本域根據字符串值
如果字符串是從右向左的
我們將實際把方向設置爲從右向左
如果是從左到右的字符串我們將設置爲從左到右
或者你可以手動設置爲從左到右或者從右到左
下一個屬性是userInterface LayoutDirection
對於佈局非常重要
它可以從左到右或者從右到左
系統控制如表視圖要參考這個屬性
還可能做自動反轉表的列之類的事
當設置爲從右向左時
默認值根據應用值來定
有趣的是鏡像屬性
因爲它有點迷惑
若一個鏡像被設爲自動
然後userInterfaceLayoutDirection
剛纔我們看的最後一個屬性
會自動由從左到右變爲從右到左
當它是從右到左的本地化
反之亦然
它還會反轉自動其他屬性
像按鈕單元圖像的位置
按鈕的圖像在左面 我們會反轉它
會自動放到右面
我們不會反轉的一個屬性是文本對齊
若你設爲居中兩端對齊或自然
反轉它們沒有意義所以我們不會反轉
你可能會想
“我什麼時候不需要設置鏡像？”
你可能想設置鏡像爲否
在你想要一個控制器有一個非常實際的代表
像一個播放按鈕 快進按鈕或快退按鈕
然後
這些是關於Interface Builder的那麼在代碼裏你該怎麼做？
在代碼裏你必須參考控制器值
關於userInterfaceLayoutDirection如果它設置爲從左向右
你必須說“嘿 按鈕
我想讓圖片在左面當從左到右本地化時
我想設置圖像在右面當從右向左本地化”
你必須手動完成設置它
在10.12中 這個更容易了些
我們給按鈕添加了一個快捷方法
一個初始化方法可以傳入一個字符串
一個圖片 一個目標和一個動作
還有自動反轉
這是我講的第一部分
下面讓Jeff講講外觀
storyboards和其他一些Mac特性
謝謝大家
好的 謝謝 Corbin
在這個課程我們有大量的內容去講
所以現在我說說系統外觀
這裏是我們的應用
我們剛纔已經看了一會兒
我們想提升下我們的UI
我們已經決定採用這個花哨的黑色外觀
這通常是高級應用的外觀
我們要對我們這個小演示程序有點野心
但看看這個這個看起來確實很複雜
我們有一個完全不同的系統Window Chrome
我們要所有控制器artwork改變片段控制器 按鈕 滑塊
所有的文本標籤
需要從黑色字體變爲淺色字體
看起來有很多工作
但實際上餓哦們可以用一行代碼實現通過使用NSAppearance
我們需要做的是創建一個系統外觀
賦值給窗口
會自動的應用所有的工作
你可以認爲外觀是一種顏色調節盤
我們用來解決
繪製所有的標準系統控制器
還包括所有我們命名的顏色
像標籤顏色 控制器顏色
由於這個原因適時使用這些顏色很重要
不僅更適合整個系統主題
同時 如果以後主題變了仍然適合
或者以後你改變了你的外觀
我們仔細的看看
這裏有個面板
有許多很棒的標籤控制器等等在上面
我們只需應用暗色外觀
我們看到了相當戲劇性的變化
控制器artwork變了
當然其他所有的標籤由深色到淺色轉變
我們可以再進一步
應用這些很酷的活力效果
你剛可能已注意到一個幻燈片
那個我們應用過的外觀叫做活力黑
不是說你有義務使用“活力”
而是說artwork在充滿活力的上下文中看起來很棒
想要這種外觀 你只需要
添加你所有控制器作爲NSVisualEffectView的子視圖
你會自動獲得這個很棒的窗口後模糊
還有在這上面所有的很酷的渲染效果
現在 你可能認爲這很棒
但我的設計師有很酷的
特定顏色針對我們的文本標籤
所以我不會使用標籤顏色
我也不會把其從暗變淺或者反過來
我很好 是的 我很安全
我們加點東西
我們檢查下可訪性面板
我們會打開中間叫做增加對比度的設置
看看會對UI帶來什麼影響
在左面我們有標準的面板
但是右面我們有
增加對比度開啓的面板
雖然我們沒有反轉所有顏色
這個轉換很像
有淺變深的轉換
你可以看到窗口背景色變淺了
在每一個層級文本都變暗了
我們的控制器有很棒的加粗輪廓
讓它和背景區分更明顯 更立體
現在 當你用一個寫死的顏色值
我們就不能猜測我們不能像這樣調整設置
所以
如果你沒有像標籤顏色
第二選擇標籤顏色你可能在幫倒忙
對想要在他們Mac上設置像增加對比度的用戶
現在說我剛暗示的視覺效果和活力
我們現在不會深入那個API
但是你可以參考我們2014年的演講
“採用OS X Yosemite新UI的高級特性”
那是外觀
是設置你應用主題的簡單方式
同時能和整個運作系統的外觀保持和諧
下一個話題storyboards
Storyboards是一種可以讓你設計
不僅是單個組件的技術
和構成你應用的其他視圖
並且在視覺上設計這些組件間的關係
在這個例子中 當我說部件時
storyboards操作的控制器
是我們的窗口控制器和視圖控制器
我們用這些segues把它們連起來
在我的截圖上的那些箭頭
segues抽象所有的膠水代碼
讓這些部件放在一起
就像添加子視圖 添加約束
創建彈出框一樣方便
現在
一個我們需要考慮的關於storyboards的是
當我們有可分離的組件時如這些
我有一個拆分視圖storyboard創建的
所有這些小組件做它們自己的事
每一部分UI都有些數據需要用
或者修改
我們不能僅從一個到另一個場景拖拽outlets或actions
當然 如果我們這麼做了
它們就不是可分離的組件了
然後我們就破壞這件事的本來目的
有時 我們用的數據
不是呈錐形存在於場景中
在下面的葉子節點
有時它可能存在在窗口或者文檔中
所以我們如何傳遞數據
從上直到葉子節點？
好的 我們有幾個經驗法則
不是硬性的規則
僅是幾個主意我們認爲對處理這個有幫助
第一個
依賴應該大體級聯向下
如果你想
如果你需要某些法則
在segues中跟隨箭頭
如果沒有其它這讓你
在應用中有很好的單向信息流
這讓人很容易理解
另一個是儘量減少UI結構的假設
你寫死到代碼裏的
你設計完UI和storyboard
若你在代碼裏寫死了一些假設
關於結構是如何放到一起的
當你想要改變storyboard時
你得來來回回
修改代碼和storyboard
現在你和自己過不去
我們不要那麼做
讓我們把代碼集中在數據上
集中在設計界面和Interface Builder上
一個我們可以用來解決該問題的技巧是
使用符合協議貫穿UI
這裏有個例子
假設有一個屬性在窗口控制器上
我們想自動提供那個屬性
給我們視圖階梯中理解它的任何東西
在didSet中
我們會調用propagate方法
我們得到了在屏幕外定義的協議
叫作photoControllerConsumer
這代表我知道如何使用photoController
且若我們看看childViewController
會發現它遵守了我們可以設置屬性的協議
同時我們自動遞歸傳遞給其所有子項
但是像
彈出或者表單展示
這些必須嗎？
當你設置這樣的屬性的時候這些可能不存在
我們根據需要來給他們提供數據
在他們出現在屏幕之前
即prepare forsegue方法的作用
它會在展示視圖控制器或窗口控制器的時候被調用
當展示發生時
在這個例子中
除了做像檢查或者segue標識符
強制轉換成我們希望的控制器類
然後做些特定的設置
這裏我們做相同的事情
我們檢查什麼協議被遵守
然後設置合適的屬性
此舉是
它改變我們的邏輯從嚴格聚焦
身份變爲能力
我們說我有這方面的知識
任何展現給我的
可以潛在自動獲得那個知識
通過一個一致的協議
這真的很方便
再講講“動作”
那很常見
UI中觸發的處理動作的最佳對象
實際上並沒有在同一個場景
那個控制器定義的地方
這被它們自己的小場景中菜單單元證明瞭
完全從你的UI斷開
同時
幸運的是我們有一個很棒的機制來處理這種情況
就是事件響應鏈
如果你來自iOS平臺
你可能不會使用太多的事件響應鏈
就是那個小的橘黃色立方體
在每個storyboard場景上面
它是第一個相應者的代理
如果你關聯了一個控制器的動作到代理上
它會自動的發送給響應鏈
當控制器被觸發
如果在響應鏈中沒有對象處理方法怎麼辦？
或者在放大的情況下
發送動作不總是很恰當怎麼辦？
例如我們在最大化縮放層級
我們不想讓放大按鈕不起作用
在我們動作之前我們可以看到
這就是UI驗證的作用
我們看看一段代碼會自己審查驗證UI
來判斷一個控制器是否是可操作的
第一步我們需要做的是請求NSApp
獲得一個控制器的目標動作
這會自動遍歷響應鏈
尋找實現那個動作的某個對象
或者可能沒有發現任何動作甚至沒有發現任何對象
我們想要看的第一個例子的結果
是實現NSUserInterface驗證協議的任何對象
這意味着你可以主動請求
一個控制器是否有效
如果你在等式的另一邊
並且你有一個控制器某些條件下有效
你可以實現這個方法
像NSMenuItem控制器和工具條單元
會自動驗證那個方法
所以我們可以請求那個方法
然後 當然 有些情況下某個對象
無條件處理了那個方法
或者一個對象也沒有意味着我們沒有準備好處理那個動作
這是些專門應對storyboards的技巧
現在我們已經討論了很多關於
創建應用程序設計時間方面的事情
我們看看一些面向用戶的特性
可以幫助你充分利用我們的平臺
首先是用戶活動
NSUserActivity是這個對象
描述了你的應用現正在做什麼
在看什麼 在編輯什麼
等等
並且
Handoff使用這個對象使這些活動在各設備間移動
有點類似把你的整個上下文在它們之間移動
我沒時間來深入看整個的API
我想說這個對象確實比較簡單
你可用activityType構造它
它是描述你正做的活動的唯一標識符
同時也有一個密鑰需要放到info plist中
聲明我是個好應用在其他設備上選擇該活動
然後你填充一些基本的配置信息
來描述你的活動
一個好的面向用戶的標題或者一些用戶信息
基本上只是基本的必需數據
稍後跳回到那個任務
我們想讓這個字典一直保持較小因爲它需要頻繁無線傳送
我們也想讓handoff交互快一點
我們也需要在代理中
添加關於上下文的絕對最新信息
在我們執行handoff之前或前一刻
它會被調用
在你標記一個活動來保存後
我們替你調用這個方法這樣你可以填上最新數據
我們如何確定哪個活動是當前活動？
因爲 當然 我們當然需要決定
現在我們在看什麼
你可通過becomeCurrent手動管理
和NSUserActivity上的resignCurrent方法
就是說你可能需要跟蹤你的用戶
在你的應用上搞清楚他們點擊了什麼
並嘗試搞清楚他們在做什麼
AppKit讓這些變更簡單
通過讓你附上活動
到響應鏈可以自動管理
比如
假如我們創建了一個日曆應用看起來就像我們的日曆應用
我們有兩個活動想要放到響應鏈
我們有該視圖更高級的活動
這整個這裏的這個日視圖
然後我們有一個更具體的活動對這個具體的事件
我們在這裏看到
通過添加這個到響應鏈
當我們點擊的那個事件讓它成爲第一個響應者
那個活動變成了最近的一個
在響應鏈中通過第一響應者
它自動變成了當前的
現在
你之前可能沒考慮使用Handoff或NSUserActivity API
你可能沒有iOS配套應用
或者你不認爲Handoff特別引人注目
對你的應用和你的特定的需求
但活動不僅Handoff使用
Sierra新特性中我們在Mac上引入了Siri
Siri使用當前活動提供上下文命令
例如 若你說在某個日期提醒我這事
Siri會推斷這個是指當前活動
其實它甚至會用這個活動並把它嵌入
到你的提醒裏然後你可以在未來找到它
所以我們認爲活動是一種通用機制
爲了描述這一類信息不僅僅是爲了Handoff
現在關於Handoff API的信息
我推薦大家看看2014的講座
“在OS X與iOS中採用Handoff”
它涉及到許多高級話題
像持續流可以讓你在設備間傳遞更多數據
下一個特性 恢復
我們有時叫狀態恢復
它是Mac最棒的特性之一當你退出一個應用
然後重新啓動它它會回到你離開它時候的樣子
實際上 這個也會恢復
如果你的應用崩潰或者重啓了機器
所有的東西恢復到之前的樣子
現在 實現這個效果
我們需要
保存所有的UI狀態
隨着時間的推移積累
然後恢復它當應用重新啓動時
明確說我們不想在模型裏保存狀態
它並不真正屬於那裏
所以一個狀態恢復API給你
一個明確的地方單獨保存UI狀態
它給你一個好的地方恢復那個狀態當你啓動應用時
但是在你的UI在屏幕上展示出來之前
基本上你可在每個窗口啓用它
那相當簡單設置isRestorable爲真
然後你提供一個恢復類
處理創建你窗口的事件
從編碼的數據中
好消息是若你用NSDocumentNSDocument會處理這些
我們想要恢復什麼樣的狀態？
我們可能選擇保存
當前應用中激活的工具
我們還可能想保存側邊欄的狀態
我們選擇了什麼 我們滑動了多少位移
我們如何來做？
好吧 若你之前用過NSCoding那是非常非常簡單
第一個方法帶有編碼器的encodeRestorableState
你可以在任何NSResponder方法上實現
並且就像使用NSCoding一樣但是這是爲了控制器的高效率
另一個重要的調用是invalidateRestorableState
這就是說無論如何我的支持數據是什麼
對encodeRestorableState已經在某種程度上改變了
我們將安排確保再一次保存狀態
在未來的某時
並且最終簡單的恢復
這確實像你想的一樣非常像initWithCoder
你只需調用super
解碼您已編碼的所有已編碼的數據
然後根據你已編碼的信息設置你的UI
現在 這太容易了但是可以使它變得更容易
你只需實現一個類方法restorableState KeyPaths
請求一下super因爲這是有禮貌的行爲
但接着也得添加我們的關鍵路徑
並且這是你希望的可以自動恢復的屬性
或者通過系統存儲和恢復
這些屬性需爲KVC
這些鍵值編碼可以訪問就像我們通過關鍵路徑訪問
並且它們也需要有可觀察性以便於我們可以隨時觀察它們
當它們變得無效或者狀態改變時
這是狀態恢復
我們接下來看第三個和最後一個技術在雲端的文件
很久以前
在雲端選擇文件
不得不主動選擇並創建一個容器
但伴隨着iCloud Drive尤其現iCloud Desktop
和文檔的發展
很可能你的應用正使用文檔
存於雲端
這很重要因爲10.12版本新特性中
本地的文件可能因爲要騰出空間而被移除
這意味着你可能會正在使用一些
並不是真的在本地硬盤上的文件
我們如何處理這問題呢？這看起來非常可怕
幸運的是若你使用NSDocument
它將爲你處理一切因此你無需擔心
如果你沒有使用你需要確定你正使用文件協調器
若你將自己註冊爲文件演示者
通過文件協調器API
我們將確認文件沒有被程序移除
這是一件好事
接下來如果你使用文件協調器
來協調文件IO
我們將會確保方便安排你的IO
當這個文件被完全下載以後
這些在雲裏的文件
這有一些技術我們沒有時間詳細論述
但是我確實想要給你們一個提示
首先是資源目錄
比在你包裏鬆散資源更快更小
它們也可以幫助你比如廣色域和從右向左
可訪問性 十分重要
Cocoa搭載了功能確實強大的可訪問性技術
你的應用輕鬆擁有的技術
你得確保
學着使用voice over和所有這些可訪問技術十分重要
確保你的應用做正確的事情
你永遠不應該發佈一個用戶界面有問題的應用
所以不要讓一個UI有問題的應用上市
沙盒和XPC服務
兩個不同的但有關連的技術
這兩個技術可以幫你隔離代碼
從系統的其他部分和其他進程中
沙盒對於MacApp Store是強制性的
但它對每一個應用都是合適的
XPC服務 可以幫助你分離出代碼
到分離的進程中
這是非常棒的對一些事 如
處理一些不可信網絡的數據
或者做一些分析工作
我們都認爲我們的代碼是最棒的
但是如我們開車時系安全帶
這樣在發生問題時我們會有保障
我們在短短的時間內講了大量的內容
所以我想帶你們重溫一下重點內容確保你們都還記得
就像我們剛剛談論的
我們以創造一個“現代化外觀”開始
通過我們的現代化視圖與窗口管道
確保你可以做出流暢的動畫
接下來我們講了拖放與事件追蹤
確保你得到一個非常酷的拖動羣集效果
現代化拖動file promises
接着我們講了容器視圖像是滾動視圖和表視圖
並且確保可以正確將其本地化
然後我們講了系統的外觀storyboards
還有一些現代的Mac特性
使Mac平臺炫目 並且確實有益
這有我們演講的永久鏈接你應該可以從這裏找到相關資源
包括我們的演示應用下載
一旦該應用就緒
所有相關演講已結束
我希望你出席了那些演講
如果沒有希望你一定要在線觀看視頻
就這樣謝謝大家的參與