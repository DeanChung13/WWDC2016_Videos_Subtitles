iOS 10中UICollection的新特性
早上好
我叫Steve Breen
我叫Peter Hajas
我們都是UIKit框架團隊的工程師
我們很高興跟大家分享CollectionView上的新特性
讓我們開始吧
我們今天早晨要講三個話題
第一個話題是平滑滾動
每個iOS應用都希望有一個不錯的滾動體驗
在CollectionView上我們添加了一些了不起的新功能
幫助你的應用比以前任何時候都能更好地滾動
其中最精華的部分是很多改進
在你的應用中不需要或只需要少量工作
接下來 我們會講自動調整單元格中的改進
我們在iOS 8中引入了這個API
我們在iOS 10中做了很多不錯的改進
使它更易用
最後 我們會回顧一下交互式重排序
去年在iOS 9中我們引入了這個API
在iOS 10中我們又改善了很多功能
讓我們從平滑滾動開始講吧
iOS設備體驗的一個標誌是
對用戶的觸摸立即響應
響應式用戶體驗的一個重要部分
是確保我的手指在屏幕上滾動
這種對象在屏幕上的移動就像在真實的世界中移動一樣
這對於使用戶全神貫注於應用非常重要
我們要討論一下平滑滾動
及我們在UI CollectionView上所做的改進
通過討論一個演示應用
正如你即將看到這個應用滾動效果並不是那麼好
我們想像黃油一樣滾動但目前
需要太多滾動就像一塊花生醬
讓我們看看iPad
我要切換到iPad上
澄清一點藍色方塊通常消耗較少
但是我們故意把這些變慢了
想象一下若更復雜會怎麼樣
比如也許它們有兩種顏色
無論如何...
有了CollectionView我們可以看到
滾動已經加載了內容很好 很快
但是 讓我們仔細查看一下
Steve 請注意看
當我再往下滾動時
哦 哎呦
一顆星 不能買
我也不會買
這種用戶體驗是我們要極力避免的體驗
這是怎麼回事？
嗯 我們之前說過 這些是非常簡陋的藍色方塊
在你的應用中模擬高消耗的複雜單元格
遇到CollectionView時
加載單元格的時間恰好是它們請求被加載的時候
讓我演示一下
我們要在這兒重新加載數據
我會打開一個視圖
這個視圖將顯示在CollectionView中加載的所有單元格
這樣你可以看到那些底部的單元格超出了
可見的邊界
現在看看當我滾動時會發生什麼
我們一下帶入了一整行單元格
這就是導致滾動體驗磕磕絆絆的原因
在性能術語中
我們可以稱之爲應用掉幀
讓我們再切回幻燈片瞭解更多的信息
我們究竟要表達什麼意思呢當提到掉幀時
在你的應用中
用戶期待平滑的滾動體驗
意思是你的應用要達到那個神奇的數字
每秒60幀
讓我們算一下
這意味着每次刷新時
我們需要在16毫秒內顯現那個窗口
好了 讓我們看幾幀
我們這兒有一個圖表顯示了三個不同的幀
在第一幀中...
我們幾乎不需要做什麼
正如Peter剛提到的那樣
我們在顯示屏中上下移動當前內容
這是iOS上的一個高度優化的情形
所以速度超快
不需做很多工作就能達到
我們獲得了這個很棒的五星級滾動體驗
這幀不錯
掉幀剖析
但是在演示中並不總那麼好
偶爾 會有這樣的情況我們需要做大量的工作
不僅裝載當前幀還會摻雜下一幀
這是我們的廣告幀
我們掉了一幀 一顆星
讓我們以一種不同的視角來看它
在這個圖中我們可以看到有兩個不同的區
頂部有一個區我們把它叫做紅區
這是我們失了一幀的地方
我們比那個神奇的16毫秒線高了
讓我們查看一下座標軸上的標籤
那麼 在我們的y軸上
我們要用圖表示出主線程上的CPU時間
x軸
顯示滾動發生時的最新事件
好的 讓我們看一個圖表
好吧 那麼在這個圖表中
顯示了Peter剛剛闡述過的內容
這些訪問進入到紅區了
丟幀的地方
但最重要的是看看這些平靜時期
CollectionView幾乎什麼都沒做
然後 我們在最後又一次進入到紅區
如果我們稍微改變一下這種現象會怎麼樣呢
並且降低我們的工作量
當用戶滾動時
好的 酷 請看
現在 這些不再進入到紅區了
並且形成了平靜週期
我們讓工作量均勻分佈
我們平攤了時間
爲了幫助討論
如何把這些峯值變平以及如何拉起這個谷值
來打造一個美好的、始終如一的體驗
我想談一下單元格生命週期
在iOS 9上的
我們要討論的是單元格的整個生命週期
很漂亮
讓我們加入CollectionView單元格
我們滾動時 可以說是我們需要加入一個新的單元格
我們把它從重用隊列中拿出來叫做prepareForReuse
這就給了單元格一個把自己重設爲預設狀態的機會
準備接收來自應用的新數據
接下來 我們繼續調用其餘的cellForItemAtIndexPath
這是你要做大量工作的地方填充單元格
你要建立數據模型在單元格上設置數據模型
然後再把數據模型帶回系統
在那個單元格即將在屏幕上顯示之前
我們會調用willDisplayCell
這可以給應用一個機會完成最後一刻要做的工作
當單元格在屏幕上顯示之前
對於即將要顯示的單元格我們會調用didEndDisplayingCell
好的 這就是單元格生命週期
iOS 10之前的版本
現在 讓我們查看一下在iOS 10上是怎麼樣的
我們有跟 Peter剛提過的佈局相同類型的佈局
單欄很適合演示用
那麼現在 當用戶向上滾動時
請注意這裏
就在這個單元格要顯示在屏幕上之前
我們要把它從重用隊列中拿進去
然後按照Peter剛講的那個熟悉的模式
我們會給它發送一個prepareForReuse
然後 構造單元格中餘下的內容
用cellForItemAtIndexPath
當用戶繼續滾動時這裏有點不一樣了
我們不調用willDisplayCell當我們創建這個單元格時
我們有個遲疑 延遲然後就在它要顯示時
我們會調用willDisplayCell
好的 現在用戶繼續滾動
我們會讓其他單元格淡出聚焦在這個單元格的生命週期上
現在這個單元格要退出
可見的邊框從CollectionView中
那麼我們會給它發送didEndDisplayingCell
Peter談的是iOS 9此時
單元格進入重用隊列然後就結束了
要使這個單元格再次顯示數據
我們得重新開始一個單元格的生命週期
並且調用cellForItemAtIndexPath
但在iOS 10中 我們會讓那個單元格保留較長的時間
因此 若用戶稍微向上滾動然後說 “哦 等一會兒
那是我妹妹剛生的小孩的照片我要滾動回來”
我們將繼續保留那個單元格並再次發送willDisplayCell
然後 內容將繼續在單元格中顯示出來
請注意 Steve在這裏展示的東西同樣適用於多欄佈局
我們要一次一個地引入單元格
而不是一次全部引入以便獲得更好的滾動體驗
你說的對 Peter 請注意
這些單元格實際上還不能在屏幕上顯示出來
它們仍然在屏幕外
現在 我們發送我們DQ的第二個單元格
cellForItemIndexPath並向上滾動兩個單元格
現在我們要發送willDisplayCellMessage
給那兩個單元格就在它們在屏幕上顯示之前
這聽起來像是一個很微妙的變化
實際效果要明顯得多
通過在iOS 10中應用這個新生命週期
我們獲得了自動的、更快的滾動體驗
讓我們回到iPad上
我要切回iPad
你可以看到跟剛在iOS 9上看到的相同的CollectionView
請記住 滾動當前內容很好 很快
但當我們引入更多單元格時
就開始不流暢了
準備CollectionView時
我們同時也在烤箱裏準備了一個CollectionView正在iOS 10下烤着呢
我要轉到那個CollectionView
在此 我們已經有了兩個完全相同的CollectionView
有同樣的高消耗在iOS 10上運行的藍色方塊
我們可以看到滾動當前內容
仍然很好 很快 很流暢
-但請仔細看 Steve-好吧
當我再滾動時
哦 很棒 五顆星
就是這樣
這是因爲我們使用了這個新的單元格生命週期
我們並沒有對應用做出任何變更
我要打開那個相同的視圖
展示CollectionView加載的所有單元格
幫助我們瞭解這個不同點
打開那個視圖
在這裏 你可看到底部的單元格行已經準備好了
但是請看當我快速滾動時會怎麼樣
並不是一次一行引入單元格
我們讓工作量均勻分佈在滾動過程中
這是促成更平滑的滾動體驗的原因
這樣是不是很好
要了解更多信息讓我們切回幻燈片
相當不錯
今天我們很高興地發佈一個新UICollectionView Cell Pre-Fetching
是默認開啓的當你在iOS 10上編譯你的應用時
不需要任何步驟
現在無論什麼原因
你想用iOS 10之前版本上的舊生命週期行爲
選擇關閉非常簡單
只需把UICollectionView的新屬性設爲
默認值isPrefetchingEnabled即可
我們有這個新技術應用相關的最佳範例
我們要談的第一點是
我們想在cellForItemAtIndexPath中完成所有繁重的工作
所有 給單元格創建的所有內容
在cellForItemAtIndexPath中無論什麼都應該居中
此外
我們想確保做最少量的工作
在willDisplayCell和didEndDisplayCell中
最後 很重要的一點是
cellForItemAtIndexPath
很可能還預備了一個單元格這個單元格實際上永遠不會被顯示出來
用戶可能已滾動到別處了
在那個單元格有機會被顯示出來之前
這很棒
只需在iOS 10中進行重新編譯即可
並且做好你很可能已經在做的
在cellForItemAtIndexPath中的大部分工作
你自然而然會免費獲得更好的滾動體驗
但是 我們想再進一步
我們知道有一大類應用
對於預備CollectionView有個小問題
我該怎麼處理高消耗的數據模型呢？
事實的真相是
很多CollectionView單元格
需要使用高消耗的數據模型來創建
我指的是像這樣的東西
解碼圖片、和數據庫通訊、
或在覈心數據存儲之外加載
我們知道對於這類應用
我們並不想顯示像模板單元格這樣的東西
當我們在做異步網絡請求時
爲了解決這個問題我們在iOS 10中引入了新API
可以告知數據模型如何加載內容
自從引入它之後
就存在兩種伴生對象：
數據源和委託
在iOS 10中我們增加了第三個伴生對象
它是可選的叫做prefetchDataSource
只有一個必需的方法
用起來很簡單
ColletionViewprefetchItemsAt indexPaths
這將會在預取數據源上調用
當從異步模型中預加載內容時
那個參數索引路徑是一個索引路徑的有序數組
因此 那個數組中越靠前的項越先顯示出來
你可以用此改變異步模型讀取
在這個協議中 還有第二個可選方法
CollectionViewcancelPrefetcingForItemsAtindexPaths
將在預取數據源上調用
當我們決定不再
滾動一組索引路徑時
你可以用這個來取消或降低任何待加載的優先級
有一個關於此API的重要信息我想強調一下
這並不是替代現有的數據模型
而是要跟現有的異步方案共同使用
你已在應用中爲加載數據創建的
你要做的就是把這個當作額外提示
內容何時加載在CollectionView中
讓我們演示一下 把它們聯繫起來
這個演示包含我們目前提到的所有概念
而且我們要引入一點兒技術分析
來看看這個Steve會做一件非常神奇的事兒
是技術分析 同志們
好的 我們要切回演示應用
我們之前看到的
好的 那麼這是我們正在看的演示應用
但我們隱藏了這個很棒的功能我們把它叫做技術分析面板
好的 那麼 我現在要打開它
好的 那麼我們有兩個不同的區 對吧
我們有紅區一顆星 是個不好的區域
然後底部有很好很大塊的綠區
我們可以在這個區域獲得超級平滑的滾動體驗
我現在要做的是
運行iOS 9版本的應用
我要再現一個
我之前記錄的滾動會話
展示它是如何運作以及如何執行技術分析的
好的 現在開始吧
滾動 執行技術分析
咔 咔
好的 看這是什麼？
讓我們看看這個圖表
我們進入了八次紅區有八次掉幀
但同時 我們也可以看到我們有很長的平靜週期
就像我們之前提到的那樣
因此 圖表區域中都是這種又大又尖的東西
然後讓我們再看一下谷底
看看在iOS 10中是怎麼樣的
好的 切回iOS 10模式
Peter之前提到過的
現在 我要重現相同的滾動會話
哇 看啊 Peter
-平滑多了 Steve-是啊 看起來好多了
看看我們的成果
嘿 看那個
沒有失幀
非常棒
看看我們在這圖表曲線下得到了什麼
這些峯值並沒有上天並且與平靜週期
融合在了一起現在 我們得到了這種平滑的效果
使應用在主線程上更積極地響應
好的 你準備好了嗎Peter？
-準備好了-讓我們開始吧
好的 現在我們要看看iOS 10版本
但我們要使用API
Peter之前提到過的預取API
我們要把這些用到這個應用中
好的 我已經準備好了演示應用
我要重現相同的滾動會話
哇 Peter 看
-現在是黃油式的滾動了 Steve-看起來很不錯
五顆星
技術分析也表明足以達到五顆星
好的 但Peter這裏有點兒不一樣了 是吧
曲線上的區域中的主隊列活動
和之前的版本不一樣了
曲線下降了不少發生了什麼？
那麼 如果我們正確地使用預取API
我們很可能把數據模型讀取移動到
後臺隊列上釋放主隊列
就是這樣就是這麼回事
現在 我們把所有工作都挪到了後臺隊列上
我們不必再擾亂主線程了
讓我們切回幻燈片
接下來 我想談一點兒
預取API的小技巧
以最合適的方式使你的應用使用這個API
首先當你調用預取時
你想要保證立即在後臺隊列上完成所有工作
現在 我們有兩種很棒的技術可以實現：
GCD和NSOperationQueue
還有一點很重要預取是一種自適應技術
自適應技術是什麼意思呢？
嗯 記得我們談到那些平靜週期
和預取如何利用那些的嗎
通過額外工作
在應用中 有時候用戶滾動太快
沒有平靜時間
在這種情況下 當我們不得不很頻繁地更新顯示時
我們將不進行預取
這樣是正確的
最後使用cancelPrefetchingAPI
來適應用戶的焦點轉移
現在 可能用戶向上移動到了CollectionView
並且正與內容一起滾動
但然後 他們改變了主意開始向另一個方向滾動
我們將通過取消消息把這個事件通知給你
這樣你就可以忽略那些優先的內容
聚焦在視圖即將要滾動到的新內容上
對於CollectionView來說這真的很棒
你什麼也不用做就能得到更好的滾動體驗
只需要做一點兒工作
使用你已經寫好的類
你就能得到更好的滾動體驗
若你使用UITableView請別擔心
一點兒都不重要
我們也在表視圖中引入了完全一樣的API
有一個類似的可選預取數據源伴生對象
有一個類似的方法 只有一個方法
TableViewprefetchRowsAt indexPaths
索引路徑也是個數組
按照優先級排序在表的可見區域
越靠前的索引路徑越先顯示出來
跟CollectionView API一樣
你可以用此來通知異步數據模型讀取
還有相同的第二個可選委託方法
表視圖 cancelPrefetchingForRowsAtindexPaths
就像Steve剛提到的那樣你可以用此
來取消或降低任何待定數據模型加載的優先級
這是最棒的一點
就跟CollectionView API一樣
這也要跟當前異步模型方案一起使用
你不必丟掉任何東西
相反 使用這個通知你正在做的加載
那麼這就是iOS 10中的單元格預取
我們非常激動引入了這個技術
我們迫不及待要看到實際的應用有更平滑的滾動體驗
接下來 我們要講講我們今年所做的一些改進
針對自動調整單元格
我們在iOS 8中引入了這個API
今年我們又做了一些改進
使它更容易地應用到你的應用中
在我們講這個之前我想回顧一下現有的API
簡單聊一下
在CollectionView中我們發佈了一個具體佈局類
叫做UICollectionViewFlowLayout
並且完全支持這個類自動調整單元格
要開啓這個功能 我們只需要設置
預估尺寸把它設置爲一些非零CG尺寸
這就會告訴CollectionView你想 計算
動態佈局在顯示內容時
現在 獲得單元格的實際尺寸
有三種不同的方法可以實現
第一種方法是使用自動佈局
如果你可以完全把層級的內容視圖限制到
CollectionView單元格的內容視圖中
我們就會請求自動佈局系統計算單元格的尺寸
並使用那個值
如果你不使用自動佈局或你需要更多手動控制
你可以重寫sizeThatFits
最後 實現最終控制
你可以重寫 preferredLayoutAttributesFittingAttributes
不僅提供尺寸信息還可以調整屬性
比如阿爾法和變形
因此 指定單元格尺寸使用三種機制中的一種
非常簡單
大部分應用使用自動佈局但對於不使用自動佈局的應用
可以通過第二個機制實現更多的手動控制
但是我們發現對於某些類型的佈局
選擇一個適當的預估尺寸非常有挑戰性
因爲有時候很難猜測
我的意思是有時候你要用哪個？
50乘50、100乘100 等等
很難說
對於這種類型的佈局來說很酷的是
如果流佈局能適應它的預期尺寸
然後使用這個數而不是計算預估尺寸
通過我們已經訂好的內容的實際尺寸
在iOS 10中 我們有個新API可以在流佈局中實現那個功能
你要做的就是將流layout.EstimatedItemSize設置爲
新常量 UICollectionViewFlowLayoutAutomaticSize
通過將預估尺寸設爲自動調整尺寸
這就表示CollectionViewFlowLayout
會替你計算
它將保留一個已訂好尺寸的全部單元格的流水賬
並使用那個流水賬來影響之後的尺寸預估值
等會兒就看到了
這使得流佈局更精確
當指定CollectionView單元格的尺寸時
以獲得更好的性能和更精確的佈局
在我們指定尺寸時
我們要做一個演示來展示
UICollectionViewFlowLayout自動調整尺寸的好處
我要切回到iPad
在這裏我們有一個使用流佈局的CollectionView
每個單元格代表文本運行中的一個詞
澄清一下 我們不提倡創建文本查看器
或使用UICollectionView編輯器
但作爲演示效果很好
我要把應用放在模式中
可以觀察到流佈局當給每個單元格指定尺寸時
用戶永遠不會看到這些
但這種方式可以很好地瞭解這個新API的優點
讓我們以固定的預估值開始吧就像我們在iOS 9上使用的那樣
那麼 我要打開模擬器
在這裏 你可以看到我們已經給每個單元格填充了
初始預估尺寸就像我們剛剛猜想的那樣
在文本運行中我要給第一個詞Lorem指定一下尺寸
看看會怎麼樣
那麼 我們給Lorem制定了尺寸現在已經是正確的尺寸了
請注意CollectionView實際上並不接近
應有的目標佈局尺寸
我們並沒有使用那個預估值來影響任何東西
一切都還是那麼大跟我們傳過來的初始預估值一樣
現在 這種情況會持續發生當我們分別給每個單元格制定尺寸時
在CollectionView中
請注意 實際上我們並不能把任何其他單元格的尺寸
調整爲我們之前計算好的尺寸
很明顯
在文本運行中 當我們給最後一個詞Fusce制定尺寸時
當我們要給這個詞制定尺寸時
你會注意到 我們向上滑動了所有其他單元格
使它們的y-位置失效
我們沒有使用第一行文本的信息
來影響任何其他單元格的尺寸
現在我要把設備調成iOS 10模式
使用UICollectionViewFlowLayout自動調整尺寸
讓我們切換一下
好的 切換好了我們已填充
相同的初始尺寸幫助你觀察不同之處
我要給第一個詞Lorem定個尺寸
看看會發生什麼
哇哦 我們給第一個單元格重定了尺寸
並使用那個單元格尺寸作爲所有其他CollectionView單元格
運行中的預估值
現在佈局還不是那麼精確
但請注意 已經非常貼近最終的結果了
事實上 y-位置的高度非常正確
請注意 當我給這個文本運行重新制定尺寸時
我們實際上是正使它越來越精確
全面地爲CollectionView單元格調整預估尺寸
請注意 在文本運行中給最後一個詞重定尺寸時
不再使其他單元格的y-位置失效
這很棒可以很大程度上幫助我們
當你做這樣的操作時比如scrollToItemAt indexPath
現在 由於這個API的性質
你將得到最貨真價實的東西
使用自動調整尺寸
如果你的單元格有相似的寬或高
這就是自動調整在iOS 10上的改進
讓我們再返回去看幻燈片
這就是自動調整單元格
並且現在 我們要談一下關於我們去年引入的API的信息
交互式重排序
這是個很熟悉的用戶體驗對於表視圖單元格用戶來說
他們希望用戶能抓住一段內容然後移動它
並在你的表視圖中垂直地重新排列
去年我們的技術引入了CollectionView
通過一個新的交互式重排序API
讓我們再回到iPad
看看在演示中是什麼樣的
切回iPad
好的切換好了
好的 那麼我們有一個非常漂亮的自定義佈局
哦 快看這個滾動 Peter
我們很可能應用了預取
-非常簡單-很可能是
好的 讓我們看一下
假如用戶喜歡這個內容但他們想要重新排列這個內容
可能會用手指拖拽
在CollectionView中平滑地移動內容
請注意 它是如何自動迴流的
不只是那樣 如果我們改成一個有着不同尺寸的項
你也可以進行以上操作
現在 當用戶完成重新排序後他們可能會鬆手
平滑地嵌入就是這樣
讓我們再切回幻燈片讓Peter演示一下API
這就是iOS 9上的交互式重排序
這個API
非常簡單
要開始一個交互式移動你要先調用CollectionViews
beginInteractiveMovementForItematindexPath
索引路徑體現的是單元格的索引路徑
我們想要移動的
如果你這樣做是爲了響應某個手勢
你可以點擊測試CollectionView
使用本地項的索引路徑
接下來 手勢每次更新時
我們都想更新單元格的位置
響應手指的操作
爲此 我們要調用updateInteractiveMovementTargetPosition
在CollectionView的座標空間傳遞手勢的位置
接下來 當我們想結束交互式移動
並確認重新排序時
我們要在CollectionView上調用endInteractiveMovement
CollectionView會釋放單元格
正確處理所有佈局屬性
然後 返回一條信息給應用的數據源
這樣你可以在模型中實現真正的重新排序
現在
如果手勢取消了
或你不允許重新排序此時
你可調用CollectionView的cancelInteractiveMovement
在這裏 我們會把一切恢復成原來的樣子
並且我們不會調用數據源
現在對於使用了UICollectionViewController的人來說
你的使用更加方便
你只需要設置安裝交互式移動
標準手勢屬性爲真
CollectionViewController將添加一個手勢
替你調用這些方法
你要做的就是實現數據源部分
這就是我們去年在iOS 9中發佈的API
今年 我們非常驕傲地宣佈我們即將在這個功能中添加分頁支持
現在 沒有新API就是最好的API
自CollectionView從UIScrollView中衍生出來之後
你所要做的就是
設置isPagingEnabled屬性
ScrollView的交互式屬性爲真
這樣就會開啓新API
讓我們切回iPad在演示中看一下
在這裏 我們有一個水平滾動的CollectionView
當前並沒有使用分頁而是連續的
看那個平滑的滾動體驗
耶
那麼在重新排序中當我們連續滾動時
我們選擇CollectionView單元格
並把它移動到屏幕的邊緣
然後我們就得到了非常好的自動滾動行爲
許多基於CollectionView的應用用戶應該很熟悉這個操作
現在 我要開啓分頁支持
我們可看到CollectionView現有了頁面尺寸遞增
對於某些類型的CollectionView來說這非常自然
這是新增的功能
我們調用的是相同的重排序API
但iOS 10中的新特性是重排序能和分頁可以同時使用
所以 當我把單元格移動到屏幕邊緣時
我們將以頁面尺寸遞增值自動滾動
這可以使應用獲得真正的主屏幕式重排序體驗
我鬆開手 就是這樣
讓我們再返回幻燈片
這有點兒像內部戰術
那麼 我們早期開發iOS 10時
他經常來我的辦公室熱情高漲
“Steve 我正做一個很棒的功能
開發人員會蹦起來的”
他當時也蹦起來了
我同意這種說法 這是個很棒的功能
我要迫不及待地展示給開發人員
那麼在WWDC期間
他找到了一個能展示這個功能的地方
於是我們討論這個功能並跟人們一起分享
那麼 就在前幾天
他又說了“我們必須這樣做 ”
我說 “好的 沒問題 ”
兩個幻燈片 九十秒Peter 你能搞定嗎？
謝謝Steve只需要一分鐘
另一個令我非常激動的功能
iOS 10中CollectionView的新功能
就是UIRefreshControl！
就是這個！UIRefreshControl現在可以直接
在CollectionView的內部支持
但不只是如此還可以直接在
UITableView內部支持 而無需使用UITableViewController！
不只是這樣 還由UIScrollView內部支持
因爲RefreshControl現在只是一ScrollView屬性！
非常簡單易用
你所要做的就是創建RefreshControl
把自己添加爲它的一個目標通過動作
然後在CollectionView上進行設置
你將實現立即刷新
非常感謝Steve這對於我來說意義重大
嘿 做的不錯
幹得好
就像是我們今天談話的一個總結
我們回顧了全新的UICollectionView單元格預取功能
我們迫不及待地想看到你們如何在你們的應用中進行應用
然後我們又談了新的預取數據源API
Collection和表視圖
接下來 我們談了自動調整單元格的改進
通過新的自動調整尺寸常量
然後我們順帶談了
在iOS 9中引入的API交互式重排序
以及在iOS 10上的新的分頁支持
如果你想查看示例代碼和其他資源
關於這個應用和這場演講
你可以看開發者網站上的這個地址
我們有一些與這些技術相關的不錯的演講
我們再次感謝大家的到來
-希望你們度過美好的——-非常感謝