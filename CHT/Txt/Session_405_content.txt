LLVM的新內容
大家好我是Alex Rosenberg
我很興奮能在此跟你們分享一些
Apple LLVM編譯器的新特性
但首先我想講一下LLVM
基於這個項目我們創建了Apple LLVM編譯器
LLVM是一個模塊框架用來建立編譯器和其他相關工具
但它的使用不一定非要按照傳統方法
我們都瞭解並且喜愛Xcode
它使用了大量的LLVM框架在裏面
這個很棒的新應用SwiftPlaygrounds也加入了
也在內部使用LLVM
LLVM也是組成Metal應用內部工作的一部分
以及其他繪圖應用編程接口
LVVM是開放資源
Apple長期以來一直堅持開放編譯器和語言資源
Swift語言就誕生於LLVM工程
我們很高興你們還有所有的貢獻者
能推動Swift在Swift.org的進化中不斷髮展
這個進程和Swift的發展進程
受到的啓發都來自LLVM項目的發展
LLVM有一個廣闊的開放資源社區
由非盈利LLVM Foundation支持
LLVM有很強的自定義性和可組合性
通過利用同樣強健和成熟的基礎設施
支持Clang前端
我們爲Swift編譯器提供動力
想要了解有關Swift的更多信息請回顧之前的演講
現在來簡單看一些開放資源裏的可用框架
以及可以如何使用它們
Clang是編譯器前端支持C Objective-C和C++語言
它的代碼庫裏有很多先進的功能
比如靜態分析
編寫中會用到代碼遷移和代碼改寫
它也支持開發環境集成
比如源代碼索引
以及代碼智能補全這是Xcode最受歡迎的功能
開放資源工具庫
幫助你利用Clang的力量使用你自定義的命令行工具
來處理源代碼
想想看你能做到多少不可思議的事情
有這樣完善的語法分析器運行於你的代碼
LLVM優化程序這個我們會多講一點
有一套完整的現代編譯器優化
就是這個功能實現了鏈接時間優化
敬請期待LTO的新發展
然後我們有個後端就是最終代碼生成的地方
這裏是目標文件操作庫
功能有彙編和反彙編
還有更高級的功能
比如即時編譯可以很簡單的編在一起
LLVM還有很多其他的工具由它的框架組成
讓我們來看一看
作爲完整的LLVM工具鏈的一部分
就是常見的一套二進制文件組件
包括開源社區努力做出的一個框架
用來製作鏈接器和其他相關工具
其他工具概覽
但也許之中最出色的工程就是LLDB
LLDB結合了許多庫包括Clang Swift
Code Generator以及它自己的一套調試框架
在週五 有一場很棒的演講
關於LLDB使用技巧和竅門
這些好的特性無論是Xcode還是Swift Playgrounds
還是Apple LLVM編譯器都不可能實現
如果沒有LLVM開放資源社區的貢獻的話
這個社區裏都是跟你們一樣的開發者
他們很有思想並把他們的想法帶入LLVM框架
LLVM開放資源工程發展速度之快令人咂舌
這頗有挑戰性無論是團隊裏的哪一個人
或者哪一個公司都很難趕上
我們想邀請你來LLVM.org參與這個工程
看看你能否融入這個羣體貢獻你獨到的見解
現在我來爲大家介紹Duncan
他會跟大家講一些很棒的語言新特性
在Apple LLVM編譯器裏
語言支持
我們來講講語言支持
首先我們來講新的語言特性
然後再講升級C++庫
最後講新的錯誤和警告來幫助你完善代碼
就從新的語言特性開始講吧
Objective-C現支持類屬性
這個功能一開始是Swift中的類型屬性
我們將它帶入Objective-C
互操作運行良好
這個例子中類屬性someString聲明瞭
使用屬性語法通過添加class標誌
之後這個someString屬性使用點語法訪問
類屬性永遠無法合成
你可以提供儲存 一個getter一個setter在執行的時候
Objective C類屬性
或者你可以用@dynamic來推遲解析到運行時
轉過來看C++
C++線程本地存儲（TLS）
LLVM很好地支持C++11很多年了
唯一不支持的是線性本地關鍵字
今年 我們添加了這個支持
我這就講一下
如果一個變量是以線程本地關鍵字來聲明
LLVM會創建一個單獨的變量給每個線程
調出初始化器在第一次進入線程開始使用之前
退出線程的時候調出析構函數
C++類的線程本地存儲支持任何C++類型
它的語法可以移植到其他C++編譯器中
Apple LLVM編譯器已經支持C-style線程本地存儲
即便是在編譯C++代碼的時候
有兩種可用的語法
一種是帶GCC關鍵字另一種來自C11標準
C風格線程本地存儲負載較低較C++本地線程而言
但是它也受限制
它要求使用連貫的初始化器和簡單的老數據類型
哪種TLS適合我？
如果你的代碼符合這些限制
你就可以繼續使用C-style線程本地存儲
以便獲得最高性能
如果不符合就用C++線程本地關鍵字
這兩個都很好用
線程本地變量可以幫助修復用戶線程代碼中的錯誤
要了解更多線程相關錯誤的信息
請觀看演講線程檢查工具和靜態分析
這就是我要講的新的語言特性
C++庫升級
接下來我們看C++標準庫
Libc++多年來一直是默認的C++標準庫
我們一直建議你們棄用Libstandardc++
在Xcode8的所有平臺我們都已棄用
請你也儘快升級
Libstdc++要棄用
如果你的Xcode工程仍使用Libstandardc++
你必須要升級到Libc++
通過更改C++標準庫的建立設置
Xcode工程現代化會自動完成這個升級
Libc++.dylib今年在我們所有平臺上做了很大改進
它的庫現在完全支持C++14還有其他的改善
Libc++Availability屬性
需要dylib的標準庫特性現也有Availability屬性
當Apple框架要部署給過去的目標
鼓勵在運行時檢查
C++標準庫的有效性檢查在編譯時就已經完成
要使用C++功能需要最新的dylib
所以你指向的平臺必須支持它們
這就是C++庫
在Xcode7和Xcode8之間
我們添加了100多個新的錯誤與警告
來幫助你找到代碼中的故障
我們簡單講講其中幾個
在Xcode 7
我們給Objective-C添加了很棒的新特性叫做Lightweight Generics
這種_kindof類型修飾符具有十分重要的作用
允許隱式轉換到_kindof任意子類
_kindof類層次結構之外的方法
在Xcode 8我們完善了_kindof類型的方法查找診斷
看這個例子
getAwesomeNumber在My Custom Type中聲明
這是NSObject的繼承類
之後getAwesomeNumber在kindof UIView中調出
這個代碼是壞的因爲My Custom Type與UIView沒有關聯
Xcode 8這裏就會報錯
方法類型檢查調出_kindof類型
限制於同一類層次結構
完善後的類型檢查也可以避免誤導性的警告
當一個無關的類型聲明一個名字相同的方法
在Xcode 8 _kindof類型使用起來方便多了
容器的循環依賴
接下來 Objective-C容器比如NSArray和NSMutableSet
可以包含任意對象
NSMutableSet調出“s”在這個例子裏添加給了自身
這就造成了循環依賴導致了Xcode 8的警告
除了創建循環強引用
循環依賴可以避免一些方法被明確定義
無限遞歸
這個例子執行了階乘函數
如果n是正值就會返回n乘以階乘n-1
不斷遞歸來計算答案
如果n是0 返回階乘1還是會遞歸
編譯器這時會收到一個警告
說所有通過此函數的路徑都會調出自己
這是最典型的無限遞歸
這裏的一個可能的解決辦法就是當n是0的時候返回1
無用移動阻止返回值優化（RVO）
標準轉移是C++最好的語言特性之一
它允許你定義所有者可以被傳遞
從一個container到另一個
轉移資源比深拷貝要快
但是要將標準轉移用於返回值
就阻止了具名返回值優化
通常當一個本地變量以值來返回
編譯器就可以完全避免複製
在generateBars裏調用標準轉移使編譯器移動bars
雖然移動很快但是什麼都不做不是更快
LLVM現在就會警告這種無用移動
這種修復是爲了避免標準移動返回值
使性能再次下降
同樣 當一個函數以值接收一個參數
返回的也是一個值
編譯器會自動用標準轉移返回
無需額外調出
多餘移動幹擾樣板
如標準移動在rewriteText的返回值是多餘的
儘管這不會實質上減低性能
但還是降低了代碼的可讀性
最好還是直接返回文本
這更方便保持和連貫返回本地變量
參考隱式變換C+- range-based循環
最後這個新的警告是關於臨時引用
在C++ range-based循環
這裏這個循環是通過一個shorts矢量
但是循環變量 i是一個常用引量到而不是int
由於隱形變換
出現在short和int之間i 就是一個臨時量
這會導致一些細微的故障
因爲看上去i是在範圍內指向但實際不是
編譯器這時就會警告這個意外變換
一個解決辦法是將 i改成一個short常用引量
另外一個方法是聲明i是個臨時量通過去掉引用
類似的警告也會出現
如果range沒有返回任何一個引用
引用複製
一個用博爾值的標準矢量迭代器無法返回引用
所以迭代器變量b在這裏就是臨時量
出乎意料的是b並不指向矢量之內
於是編譯器警告這個意外複製
解決辦法就是去掉引用明確定義b是臨時量
這些新警告包括無限遞歸標準移動,
和C++ range-based循環是默認啓用的
要在你的expo進程中實驗它們
就把它們添加到其他警告標誌的設置中
新的診斷就講完了
編譯器優化
下面來講講編譯器優化的進步
我們整體上完善了LLVM編譯器
來優化你的代碼的運行時性能
我們只選擇了幾個在今天着重講解
我們會講到鏈接時間優化的改進
重點講新代碼生成優化
然後再講講arm64緩存調整
鏈接時間優化
在過去幾年裏我們討論過了鏈接時間優化
現在我們有重大進步要跟大家分享
鏈接時間優化也叫LTO
它優化了可執行文件把它們作爲單一的完整單元
它在源文件中內聯函數刪除死代碼
執行其他功能強大完整的工程優化
什麼是鏈接時間優化（LTO）？
LTO消除了編譯器和鏈接器間的界限
要了解LTO的工作原理
首先要看看傳統的編譯模型
假設我們有四個源文件
第一步是編譯產生四個目標文件
目標文件鏈接到框架產生應用
LTO的建立一開始是一樣的
都是編譯源文件到目標文件
在LTO裏的這些目標文件包含了額外的優化信息
這些信息讓鏈接器可以執行鏈接時間優化
從而產生單一的單片集成目標文件
LTO編譯模型
LTO的輸出與框架相連
比如Foundation從而形成應用
LTO能讓性能最大化
Apple大量運用LTO在我們的軟件裏
通常可執行檔的速度可以提高10%相較於其他普通的發佈版本
它的效果會更明顯如果跟性能分析引導優化結合使用
LTO運行時性能用LTO使性能最大化
它還可以極大地降低代碼長度在優化大小的時候
但是在編譯時會產生成本
LTO編譯時間的折中
集成優化步驟會需要大量的記憶
不能利用你所有的核
而且會不斷重複出現在增量編譯中
帶有調試信息的大型C++項目編譯成本是最高的
在過去的兩年裏我們一直致力於降低負載
比如研究內存用量
條件是Apple LLVM編譯器與LTO和調試信息相鏈接
這個條越短越好
在Xcode 6佔用400億字節
LTO內存用量完整調試信息
從那時起我們就將內存用量減少了4倍
也將編譯時間減少了33%
Line Tables Only調試信息水平佔用的內存比LTO還少
鏈接LLVM自己現在只佔7千兆
LTO內存用量Line Tables Only
LTO從來沒有這麼好過
但現在還是有編譯時間折中的問題
特別是對增量編譯
但我們有一個很棒的新技術可以減免這些成本
增量LTO能夠擴展你的系統
它執行整體分析和內聯不需要結合目標文件
增量LTO
它的建立更加快速因爲它可以同時優化每個目標文件
另外由於目標文件都是單獨的
而且你的緩存建立在鏈接器上因此增量編譯能超速運行
我們來看增量LTO編譯如何運行
增量LTO編譯模型
編譯步驟與單片集成LTO一樣
爲每個源文件產生一個目標文件
不需要合成目標文件
鏈接器運行LTO分析在整個工程裏
這個分析爲每個目標文件傳送優化
使各個目標文件的函數內聯
也會內聯其他強大的全工程優化
LTO優化的目標文件儲存在鏈接器緩存裏
之後纔會鏈接到框架以形成應用
根據計算後的運行期性能
增量LTO創立的工程與單片集成LTO差不多
有幾個benchmark慢點兒另外幾個快點兒
但是編譯時間很快
那麼來看看我最喜歡的C++工程的創立時間
Apple LLVM編譯器本身
在這個表裏條越短越好
最上面這一條是不用LTO建立的時間
單片集成LTO建立所用的時間遠遠超過上面的
用了將近20分鐘可不是6分鐘
創建大型C++工程的時間
增量LTO要快很多用時少於8分鐘
負載只增加了25%
再單獨來看一下鏈接步驟LTO就在這裏運行
不用LTO只鏈接Apple LLVM編譯器自身
所用時間小於兩秒
在圖上看不到條
因爲鏈接器不執行任何編譯器優化
單片集成LTO用時將近14分鐘因爲它可以用到所有的核
增量LTO用時2分14秒
比單片集成LTO快了6倍多
內存用量也很小
不用LTO單連Apple LLVM編譯器所佔內存
也就200多兆
跟我們之前看到的一樣單片集成LTO佔了70億字節
增量LTO佔用內存小於800兆
這個比例令人不可思議
所有這些結果都是新版本
以後還會更好
有了增量LTO
增量編譯不會再重複無用功
再看一個例子當控制器改變時
怎麼開始App的增量編譯
增量編譯示例
改變控制器會讓鏈接失效
但其他的LTO目標文件還存在鏈接器緩存裏
但若一個控制器函數被內聯到主方法
那麼主方法需要重新優化在LTO時間
那麼我們開始構建只有控制器需要重新編譯
重新運行LTO分析之後controller.O和main.O
都被優化了新的LTO目標文件存入鏈接器緩存
LTO目標文件就如以往一樣連在一起產生應用
增量LTO提供的性能正是對增量編譯性能的期待
當帶有小輔助函數的源文件被更改
使用它們的目標文件會被重新優化
但對於典型的增量編譯
大部分LTO目標文件直接從鏈接器緩存鏈接
最後再看一下鏈接到Apple LLVM編譯器本身時間
最上面三條顯示的時間是從之前的fresh build
大型C++工程的增量鏈接
如果我們更改了優化遍數的執行
單片集成LTO用時是一樣的
跟fresh build一樣
但是增量LTO只需要8秒
這比初始化版本快16倍比單片集成LTO快100倍
真是令人驚歎
最新的科技鏈接時間優化
低內存用量快速增量編譯
今天就去試一下增量LTO吧
啓用增量LTO
LTO的改進十分出色
但如果你用LTO處理大型C++工程
編譯時間要降到最低就只用line tablesonly
調試信息層
這樣調試器裏可以獲得許多追蹤信息而且成本最低
LTO和調試信息
以上就是鏈接時間優化
現在有請Gerolf上臺爲大家講講新的代碼生成優化
代碼生成
好 接下來就講講代碼生成優化
我們努力研究Xcode 8Apple LLVM編譯器
爲了能提高所有應用的性能
在這一環節我要講其中三個
Stack packing和shrink wrapping
以及選擇混合型乘加運算
首先來講stack packing
這是關於本地變量運行時棧內存
Apple LLVM編譯器一直都帶有優化
努力壓縮棧內存大小
Xcode 8的編譯器是優化最好的
原因就是這個來看看這個例子
注意x的定義要在if陳述的作用域之內
然後看一下y的定義在if陳述之後
如果編譯器不去優化這個代碼片段
那麼就是說x和y這兩個變量
在運行時內存棧上不同的兩個棧單元
但是根據C-style語言規則
一個變量的生存期結束於它所定義的作用域
這也就是編譯器所利用的一點
那麼來看看這對我們的兩個變量有何影響
x被定義於if陳述之內
if陳述的作用域就在y被定義之前結束
當y被定義之後y就有了一個生存期
在這張圖上你可以看到
x和y 以及x和y的生存期不會重疊
於是編譯器就可以給它們一個相同的棧單元
這就減少了程序用的總棧內存
就可能會提高應用的性能
目前一切都是完美
但是這裏有一個小小的警告
編程語言的規則有時很難去檢查
所以一旦出錯
你的程序可能就會產生意外的結果
技術術語就是未定義行爲
我們來看個例子
注意這個指針變量
在if代碼塊中它的賦值是x的地址
現在看這個print陳述
這個時候x的地址通過這個指針變量而使用
這麼這裏所看到的
就是x的地址跑出了if陳述的作用域
這樣我們的語言規則被視爲是未定義行爲
脫離本地地址
所幸這個修復很簡單
這只是個需要注意的地方
修復的方法很簡單只要拓展作用域
給x的生存期通過刪除x的定義
在if陳述之外的定義在條件被檢查之前
那麼現在x的定義所在的作用域
就與print陳述一致了
刪除很簡單
請一定要盡所有努力
讓你的程序符合編程語言規則
這能帶來更好的體驗給你
給編譯器以及我們的用戶
以上就是stack packing
下面來說shrink wrapping
Shrink wrapping是關於編譯器生成的代碼
在函數進入和退出的時候
這是一個資源管理代碼
管理運行時堆棧和寄存器
這裏觀察到的是
這個代碼並不需要作用於函數的所有路徑
shrink wrapping會把這個資源管理指令
放在真正需要它們的地方
那麼來看一個簡單的例子
這是一個簡單函數有兩個參數a和b
將它們進行簡單比較
如果a小於b就會調出一個函數foo
它以本地變量的位置作爲一個參數
最後返回
瞭解shrink wrapping來看一下僞彙編代碼
類似於編譯器真正生成的代碼
這裏你看到的入口碼分配堆棧內存
節省寄存器運行比較和分行
出口代碼塊會儲存寄存器
刪除堆棧並返回
如果條件正確函數foo會被調出
所以這裏看到我們的程序中有兩個路徑
一個是直接從入口碼到出口代碼塊
另一個從入口代碼塊到出口代碼塊
這裏主要的發現就是這個資源管理指令
指令運行時棧內存和指令寄存器
只需要用在調出函數指令時
shrink wrapping所做的是識別這個條件
將這些指令移出入口代碼塊
移出出口代碼塊放到真正需要的地方
因此它縮短了生存期
資源管理指令的生存期並在這個region中將它們打包
轉移到真正需要的地方
這裏的region就只是調令
現在設想一下這個熱代碼
在你的函數裏是從入到出的路徑
我們就不再需要執行資源分配指令
如果這是個熱點函數你會有很多這樣的熱點函數
你可以想象這種方法可以節省幾百萬個
指令讓性能更好的提升
也節省應用的用電量
以上即shrink wrapping
接着我們談談混合加乘運算
這把我們帶回到很簡單的數學運算
加法和乘法
arm64處理器
有一個指令就是混合加乘指令
這個指令會計算一個表達式
比如a加b乘以c只用一個指令
選擇性加乘運算
你可能會天真地以爲無論何時看到這樣一個表達式
最好的方法就是隻生產這個指令
這也就是編譯器現在所做的事情
但這一定出乎你的意料
在某些情況下生產兩個指令實際上比一個要快
一個加法指令和一個乘法指令
這會讓你的應用的性能變得更快
爲什麼？
我準備了一個簡單的例子來進行演示
這個函數使用四個整數參數
並計算一個簡單表達
a乘以b加c乘以d
選擇性混合加乘運算
代碼會是什麼樣子？
當編譯器生成一個單一混合加乘指令的時候？
它會計算a乘以b
然後加乘運算需要等待這個結果
然後加乘運算會計算這個表達式的值
要用多長時間？
乘法需要四個循環加法也是
所以這個簡單序列總共需要八個循環
當我們要生成2個乘法和1個加法
怎麼可能更快呢？
那麼我們來看看這個序列
首先編譯器發出乘法指令a乘以b
然後計算c乘以d
最後把結果相加
祕訣在於現代處理器可以指令級並行
它們可以執行2個甚至更多乘法
兩個乘法 代碼更快
同時並列計算
因此在這裏
兩個乘法是並列執行的
所以在四個循環中我們得到的不是一個乘法的結果
而是兩個
然後我們只要把結果相加一個循環裏完成
現在我們看到要計算這個表達式的值
我們只需要五個循環
現在比較一下這個序列
與一個最少加乘的序列
那麼在這個簡單序列中運算速度快了兩倍
因此使用選擇性加乘運算
就可以加速計算應用裏的許多簡單表達式
以上就是混合加乘運算
接着我們講arm64緩存優化
這裏我要講兩個技術
編譯器決定哪些數據會存在緩存裏
而緩存中的數據
決定了應用的性能
在我們詳細講解編譯器的工作原理之前
我想快速的回顧一下存儲層次
在頂部你看到的是主存儲控制程序變量
這是上面這一條
在最底下你看到是寄存器
從主存儲器下載數據到寄存器十分緩慢
要鏈接這兩個部分需要一個緩存就是臨時存儲
它比主存儲小1萬到10萬倍
但是從緩存下載數據的速度要快很多
大概快10到100倍
然後數據從主存儲中下載
我們下載的不僅僅是單一的寄存值
而是把一整個緩存行從主存儲中下載下來
所以緩存行中包括了不止一個註冊值
這個設計之所以能如此成功
是因爲你的程序數據有兩個局部屬性
時間局部性和空間局部性
時間局部性指的是程序現在訪問的數據
很快會被再次訪問
空間局部性指的是程序現在訪問的數據
隨後還會訪問相鄰的數據
所以當你訪問一個數組區域它還會訪問相鄰的域
當它訪問你數據結構裏的一個域
它還會訪問相鄰的一個域
以此類推
現在你看着這個設計
而且你覺得
從緩存裏下載數據很快
那是不是可以將數據預先加載到緩存裏
從主儲存中加載在處理器處理其他操作的時候
這樣所有數據的加載都很快
當我們需要這些數據時當程序需要這些數據時
你可能會感到吃驚
因爲你的iPhone處理器已經實現了這個神奇的事情
這就是硬件預取
處理器會觀察加載的每一個地址
試圖在這些地址裏找到模式
一旦這個模式找到
就可以預測你的程序在將來需要什麼樣的數據
從主存儲中再次預取這個數據
在其他並行處理還在運行中的時候
將數據存進緩存最後當程序需要他們
程序可以很快的將它們從緩存中加載
那麼今年我們研究了硬件結構
來看看編譯器可以做到什麼
讓這個神奇預取使應用運行得更好
軟件預取
我們找到了幾個模式
所以編譯器現在做的就是分析源代碼
預測以後應用可能需要的數據
發出預取指令讓應用獲取這個數據
在應用運行的時候
預取指令執行
從主存儲獲取數據放入緩存中
當程序需要這些數據時
就可以很快很簡單的從緩存中下載
程序就不需要再等待數據從主存儲中下載
這就是軟件預取所實現的魔法
到這兒....
我講的這個優化是編譯器自動爲你做好的
下一個我要講的優化
非臨時存儲是需要你幫助的
要了解怎麼回事我們要看一看
數據存進主存儲的過程
那麼讓我們再來看看存儲層次結構
假設程序要做一個簡單的任務
賦值的話假設100
給主存儲變量現在的值是55
第一件事就是
本想把新值存到的舊數據的地址
加載到了緩存
由於我們從主存儲加載數據
不只是加載變量的舊數據
還有相鄰的數據
因爲我們填寫了整個緩存行
第二步把值存入寄存器
存到緩存行
存到緩存裏
最後
緩存行的數據或者是需要其他數據的緩存行
還有值會在第三步從主存儲返回
所以總共是三步
從主存儲加載數據到緩存
緩存寄存器的值
最後將數據返回主存儲
這麼做的原因是數據
通常都有局部性特別是時間局部性
但是如果你的數據沒有空間局部性呢？
會不會能更快速更方便的將值直接從
寄存器存入主存儲...
更快地儲存數據？
...只用一個步驟？
這正是非臨時存儲的做法
它能避免下載多餘的緩存行
還有一個好處就是
這個數據不再需要不會再存入緩存
那麼緩存中就存儲其他數據能對應用更有用
如何指令編譯器
生成非臨時存儲是通過一個編譯器內置組件
非臨時存儲
那麼你用這個內置來指令編譯器
生成非臨時存儲
這需要兩個參數
一個是你要存的值一個是你要存的地址
什麼時候要用非臨時存儲？
當沒有重複使用沒有時間局部性
在你的代碼中你可複製一大段數據
最好比緩存還多
讓應用更有價值
在性能缺失的地方
所以這必須是個熱循環
當全部條件無法滿足時
你不會想使用非臨時存儲
你能獲得什麼？
在這一張幻燈片
我們演示的是非臨時存儲帶來的好處
從三個含有熱循環的benchmark
這個看上去跟我之前展示的例子差不多
所以這個數據告訴你對於普遍的循環體
速度可以加快30%到40%
這就是非臨時存儲
可以爲應用熱循環所做的事情
這是個漫長的進程
我們看過了很多新特性和很棒的新優化
都是新的編譯器提供給應用
我們也講了
Apple LLVM編譯器是基於開放資源工程
你可以與我們互動到我們的開放資源社區來
甚至提供一些補丁給你喜愛的編譯器
我們看到了這麼多新的特性
比如objective類屬性和C++線程本地存儲支持
現在...
新的Libc ++完全支持C++14
而且有了許多新的改進特性
但是要記住Libstandardc++是棄用的
現在有更多的警告和診斷
讓你的代碼比以前更清楚
你也聽到了這個神奇的新特性
增量LTO爲你提供一樣的性能
與單片集成LTO相比而且編譯時間令人驚歎
之後我們講了一些代碼生成優化
可以自動加速所有應用的運行
最後我們講的是長期的專業存儲
就是編譯器提供方法
而你用你的智慧然後去使用他們
所以我希望這些能說服你
我們做的新編譯器是一個真的很棒的版本
我們高興極了
請一定試一試
看看它能爲你的應用做什麼
你可以在我們網站上找到更多信息
這裏還有更多精彩的演講...
相關演講
...應該會讓你感興趣
關注一下
謝謝觀看
謝謝你們來到現場
祝你們在大會中過得愉快