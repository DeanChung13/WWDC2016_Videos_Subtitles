UIKit應用基於協議與值的編程
大家下午好 歡迎大家的到來
我叫Alex 我和Jacob今天將會跟大家談一下
如何使用值類型和協議
來提高應用的性能
我們今天的重點是
一個叫做局部推理的東西
局部推理的意思是當你看眼前的代碼時
你不必考慮其他代碼
與那個函數如何互動
你之前可能有過這種感覺
而這就是那種感覺的一個稱呼
比如 也許你剛加入一個新團隊
你要看大量的代碼但是環境很少
你能明白那一個函數正在實現什麼功能嗎？
所以瞭解這個信息是非常重要的
因爲這樣維護起來更容易
寫起代碼來更容易
測試起來更容易
首次參與編碼也更容易
所以我們要談一下局部推理會如何
在模型視圖控制器設計範例環境下
改善我們的UIKit應用
就是Cocoa所使用的模型存儲數據
視圖呈現數據
控制器在兩者之間協調
我們需要一個真實的應用來驗證我們的答案
不幸的是在Apple中我們實際上有一個問題需要解決
我要跟你們說個祕密
關於我們每年是如何準備 WWDC 的
工程師都有夢想
他們要呈現他們所夢想的東西
無論用什麼方式 我們要了解這些夢想 並把它們記錄下來
但我們注意到許多工程師實際上在工作時
就不再記得他們的夢想了
他們忘了自己的夢想
所以我和Jacob開發了這款很棒的應用
可讓你們記起自己的夢想
該應用就叫Lucid Dreams
我要展示去年人們的一些夢想
有些人夢想成爲麒麟
這是認真的
很奇怪的是 有些人
仍然被工作壓力問題所束縛
他們更想離開辦公室去騎車
有些工程師甚至夢想成爲Crusty
那就是我們應用的靈感
由於我們將在演講中使用這個應用
我想快速給你們展示一個演示
這樣你就能明白這個應用是做什麼的
如果我們啓動應用你會注意到它會把我們帶到
我們現有的夢想列表中
如果你輕觸其中一個夢想你可以編輯它
並且在頂部可以看到預覽
可以向下滾動並添加一些特效
比如激光束和雨
然後往回滾動到原來的位置你可以看到夢想的預覽
麒麟有激光束、雨和噴火特效
編輯完成後
返回夢想列表
這就是這個應用
我們要認真努力地思考如何寫出更優秀的代碼
所以我們去年參加了一些很不錯的Swift演講
這些演講的主題是值類型和麪向協議的編程
的好處
這些想法非常強大
我們想要利用它們
因爲它們可以幫助改善應用中的局部推理
所以我們用這種不一樣的思考方式寫出了這個應用
現在你可能覺得有些想法很陌生沒有關係
我們首次嘗試這些技術時
我們也覺得很陌生
所以不要擔心 繼續聽我們講
我們會快速地談一下模型層中
值類型的好處
去年已經談過了所以我們要快速回顧一下
然後我們重點講如何在視圖控制器層
使用值類型
因爲我們認爲絕大部分人認爲他們不會利用值類型
即使它們有一些切實的好處
在演講中 我會演示如何使用值類型和協議
使代碼變得可測試
你剛剛看到了這個很棒的應用我知道你想測試
我們已經發布了示例應用
你可以自己下載 查看代碼
並記錄你自己的夢想
好了 現在 是時候談模型層了
那麼夢想是什麼？
夢想是模型類型
會在應用中呈現夢想
夢想可以是描述、創造物和一組特效
正如你剛纔在UI上看到的一樣
我想展示夢想類型的一個版本
是我們去年在應用的第一個版本中使用的
最開始我們的夢想類型是一個類
類有引用語義
意思就是引用同一個實例會共享存儲
這樣的共享很含蓄
這爲什麼會是個問題呢？
嗯 假如某人嘗試修改dream2的描述
如果我們關注dream1我們會非常吃驚
因爲變量的值在我們的控制下發生了變更
這非常影響局部推理
而且我們自己的應用即使通過了測試
恰有這種漏洞
爲什麼會這樣呢？
這個圖表顯示了應用
第一個版本中的關係
有些關係可以同時兼具明顯和含蓄
有些關係既可以是單向的又可以是雙向的
有些關係甚至既可靜態又可動態
所以這些關係可以變得非常非常複雜
那麼當我們嘗試測試它自己的
夢想類型時發生了什麼呢？
嗯 即使你創建一個能自己支持自己的夢
也不會在應用中反映實際情況
因爲實際存在更多的依賴性
這樣很不好
我們可以通過使夢想類型成爲有值語義
的結構來解決這個問題
意思是每個變量都有獨立的存儲
改變其中一個變量的值
不會影響其他變量的值
如果我們修改dream2的描述
我們只能修改dream2的描述不會影響dream1的描述
這就確保夢想不會涉及
我們之前所看到的複雜關係
這也證明瞭我們有局部推理的能力
因爲沒有代碼能改變在我們的控制下正在使用的值
接下來講使用值類型
我們剛看到了我們是如何在模型層中利用值類型的
而且在模型層使用值類型實際上是沒有任何爭議的
但你們就不想在我們應用的其他部分
利用我們剛剛看到的這種好處嗎？
實際上可能會很吸睛
我想引用一句話是我最近在因特網上看到的
說“只在簡單的模型類型上使用值”
聽起來一點兒都不勵志
但我們會相信從因特網上看到的所有東西嗎？
答案是不會 如果你不瞭解的話
那麼 在接下來的演講中
我們主要談如何在應用複雜的
模型數據中使用值
同時我們將證明因特網上的那種說法是錯誤的
好的
讓我們邀請Jacob上臺講一下視圖層
謝謝Alex
我真的很樂於跟你們講我們是如何與視圖一起
使用基於協議的編程
我們在應用的表視圖單元上花了很多時間
我們對它們的佈局進行了精心設計我們想要實現
完全顯示出人們所夢想的麒麟
當開始開發應用時我們寫了這些佈局
作爲UITableViewCell抽象子類
比如 這個簡單佈局 我們把它叫做DecoratingLayoutCell
它左側顯示了一點兒裝飾
右側有大塊的內容
然後 我們做了一個佈局單元的具體子類
添加具體邏輯 比如顯示夢想
我們做了這種分離 因爲我們想
在不同的地方重新使用佈局
但隨着開發的繼續
我們發現越來越不好用了
它能幫助我們在不同的單元重新使用佈局
但很難在表視圖外使用
比如 我們有個詳細視圖
顯示夢想的更多信息
但我們不能在那兒重新使用佈局單元
我們想找到更好的方式來構造
以便我們能在表視圖單元上使用佈局
同時也能在普通UI視圖中使用佈局
我們還想在應用中添加SpriteKit
顯示那些很酷的粒子特效
並且我們也想在SpriteKit節點中使用佈局
這就是我們的目標 我們用從Swift學到的東西來實現這個目標
雖然我要具體地講佈局
我想讓你們記住一點
這些技術可以在整個應用中使用
好了 我們開始吧
這是我們以前的佈局單元
有兩個視圖
但這個佈局邏輯實際上不需要被困在單元內
只需要一些數學和幾何學就能算出一組框架
讓我們從不讓單元只是作爲普通結構開始吧
它仍會有兩個視圖
我們可以把所有佈局邏輯放在一個方法中
可以調用方法 顯示佈局
只做了這樣小小的變更
我們就擁有了非常獨立的代碼
這些代碼知道如何實現佈局僅此而已
然後 我們可以更新夢想單元使用新結構來展示它的子單元
好消息是我們現能在UIView子類中
使用獨立代碼了
現在 這個佈局邏輯已經跟表視圖單元不掛鉤了
我們可在任何UIView中使用
還有一個好處
我們能獨立使用佈局
可以非常方便地做單元測試
我們只需要創建一些視圖
並把它們添加到佈局中
然後在一個已知的矩形中展示出來
再然後 我們只需要驗證
結果展示的框架是否正是我們所期待的框架
我們的測試不必創建表視圖
或等待正確的視圖佈局回調函數起作用
只需要通知佈局開始運行然後驗證輸出
這是我們得到的其中一個好處
新佈局的結構很小、很緊湊
這種變更使它更容易對這個代碼進行局部推理
如果我們想了解對佈局的測試
我們只需要瞭解那個獨立的小結構
我們不想考慮 哪組視圖
它可能會使用或覆蓋
好的 現在讓我們返回DecoratingLayout代碼
現在 這個代碼只知道如何顯示視圖
但就像我剛纔所說的我們也想用這個
支持SpriteKit
所以 我們不想複製這個代碼
但SKNode並非UIView子類
所以這裏沒有可用的通用超類
那麼我們如何把這兩者結合到一個單一佈局中呢？
由於我們的佈局在這些子類中所實現的唯一功能
是設置它們的框架
這是我們需要的唯一功能
我們可以通過協議來實現這個需求
我們要做一個協議
這個協議只有一個單一框架屬性
這樣還不流暢我們要稍微改進一下
然後 我們使用這個協議作爲子類的類型
而不是把它們做成視圖
最後 我們可以使用追溯模型
使UIView和SKNode遵守新協議
現在 我們有一個能在兩種類型中使用的佈局了
這是使用協議 的好處之一
並非爲實現多態的超類
我們可以使用協議把這個功能添加
到不相關的類型並在兩種類型中使用
現在 我們的佈局不再依賴於UIKit了
我們能做的另一件事是
把同樣的體系帶到AppKit中並支持展示NS視圖
非常簡單
我覺得這很酷
我們已經很接近了
但仍然還有要改進的東西
當我們在視圖中使用DecoratingLayout時
我們想把所有內容添加爲子視圖
類似地 當我們在SpriteKit場景中使用它時
我們把內容添加爲子節點
但現在 內容和裝飾可以是有框架的任何類型
意思是 比如我們的內容可以是個UIView
而裝飾是一個SKNode
但相反 我們想讓佈局只有一組UI視圖
或只有一組SK節點作爲其子佈局
那樣 我們就能把它們添加到相應的父佈局中
現在Swift有一種方式就是用泛型表達
我們可以把佈局更新爲通用類型
類型參數叫child
然後我們可以使內容
和裝飾屬性使用child作爲它們的類型
這就正好提供了我們想要的結果
我們可以強制它們是同一種具體類型
這樣我們的DecoratingLayout
就只能有UI視圖或只包含SK節點的視圖
因此 泛型是一個很棒的工具可使我們對代碼中的類型
擁有更多的控制
泛型的另一個好處是
編譯器能獲得關於代碼功能的更多信息
因此可以進行更多優化
你可以從瞭解Swift的性能演講中
更詳細地瞭解這些信息
那是場不錯的演講可以瞭解Swift如何運作
以及如何寫出迅捷的Swift代碼
好了 我們現有一個不錯的DecoratingLayout實現
但是我們的應用還包含許多其他佈局
比如這個級聯佈局
這個佈局類似於我們剛看到的DecoratingLayout
右側都顯示一大塊區域
左側有詳細的裝飾區
我們不想粘貼複製代碼來創建這個新佈局
那樣可能會失去一個創建兩者
都能使用的共享抽象的好機會
我們要如何共享這個代碼呢？
你們之前幾乎都用過的一個共享代碼的工具是繼承
但如果用繼承你的確是有了代碼
但是請不要嘗試讀取這個代碼
而且你還要考慮超類可能會有什麼功能
以及子類想要變更或覆蓋什麼
除了只考慮你正在用的代碼
你還要考慮把分散在應用中的
大量代碼結合在一起
而這只是冰山一角
很多時候你還要從框架類繼承
如UIView或視圖控制器
還有大量數量級的代碼
所以 繼承是另一個
要使用局部推理的地方
但我們可以通過合成更好地共享代碼
合成是一個簡單的想法只是把一些小片段結合在一起
構建一個較大的片段
但是當合成時你可以瞭解那些獨立的片段
你還可以強制封裝
而不需要擔心子類或超類
在抽象中產生漏洞
但合成也不是個新功能
你以前可能在Objective-C或其他語言中用過
以前我們實現佈局的其中一種方式是
把視圖組合到一起
你可能會寫一個UIView
執行級聯佈局行爲
再寫另一個UIView執行裝飾佈局行爲
然後你可能會將這兩者作爲子視圖添加到表視圖單元中
但是有一個大問題
就是類實例的消耗很大
當你創建另一個對象時你會有一個額外的堆式分配
這比視圖更糟糕
因爲需要做很多工作來支持視圖
使視圖能實現像繪製和事件處理這樣的功能
正因爲如此 我們非常努力地嘗試把視圖數量最小化
所以創建一個不能繪製的視圖
並且只作爲佈局抽象是一種很大的浪費
這也是爲什麼合成視圖方案不太好的原因
但通過Swift 我們得到了一個好得多的方式進行合成
就是用值類型
結構是輕量級的 因此我們可以使用多個結構
而不需要付出像類和視圖那麼多的消耗
因爲結構有值語義所以就更好了
使用值類型會有更好的封裝
可以同時使用這些片段來進行合成
而不需要擔心別人修改你正在使用的代碼
那麼 讓我們在佈局中應用吧
嗯 我們可以這樣寫出佈局中的級聯部分
使用所列出的子佈局的一個數組
然後 我們想用DecoratingLayout構成佈局
獲得最終效果
但是還有另外一個小東西需要改變
這些佈局只能有UI視圖
或SK節點的的子佈局
讓我們推廣一下 這樣我們可以使用佈局並把它們合成到一起
我們爲子佈局使用的佈局協議需要一個框架屬性
永遠不需給那屬性調用getter
我們永遠只需要給它設置新值
我們並不關心子佈局是否有框架
我們只想使子佈局
在指定矩形中展示自己
因此 讓我們改變一下方法
當我們決定其中一個子佈局的矩形後
我們將告訴那個子佈局要在那個矩形中展示
UIView和SKNode仍會遵守我們的協議
當它們被要求在矩形中展示時它們將用它來設置它們的框架
但現在 我們也可以使佈局遵守這個協議
它們已經知道如何佈局
當給它們一個框架時它們只需要分割那個矩形
並提供給子佈局
我們現需稍微變更一下DecoratingLayout
允許它在子佈局的類型上有更多的靈活性
我們稍後會進行詳細解釋
現在 我們能創建我們喜歡的佈局了
通過把CascadingLayout和裝飾佈局
合成到一起
這種合成可以使我們以一種聲明的方式
創建這樣的高級佈局
示例代碼中還有更多的例子
當你創建自己的應用時
當你需要重新使用代碼或自定義一些行爲時
請嘗試用合成 這個工具很好用
那麼我之前提到了我們添加
佈局內容
到超級視圖或SpriteKit場景中
重點之一就是以正確的順序添加這些內容
比如 我們的CascadingLayout希望它的子佈局按一定的順序排列
這樣可以顯示成一豎排 一個在另一個的上面 就像這樣
我們可以擴展協議來支持這種需要
我們將在佈局協議中添加一個屬性
返回它的內容
我們的合成佈局將以正確順序
返回所有內容
然後葉視圖和節點只返回自己
但又一次 如果我們只把內容類型作爲協議
就會允許產生混合環境
作爲內容的UI視圖和SK節點
因爲我們把這些子佈局添加到了父佈局
我們只想實現同類集合
只有UI視圖或只有SK節點
爲了強制實現這個目標 我們可以向協議中添加一個關聯類型
關聯類型就像是一個類型佔位符
一致的類型選擇想要使用的具體類型
協議的關聯類型是我們要放在
佈局內容的數組中的類型
這就允許我們寫出一些只知道如何展示視圖
並指定其內容類型爲UIView的代碼
類似的 我們也可以寫出只有SK節點作爲內容的佈局
這種類型的安全性非常好
跟以前一樣 我們不想通過佈局的通用版本
分別給視圖和節點寫佈局
我們仍然擁有支持兩者的單一佈局
對於內容類型
我們只使用子佈局的內容無論內容是什麼
意思是我們可以創建DecoratingLayout
要麼只能跟UI視圖一起使用要麼只能跟SK節點一起使用
這兩個都是強型的因此我們可以取出它們的內容
並準確地瞭解它們
它們仍然可以共享所有的佈局邏輯
相關類型是使協議變得更健壯的一個好方法
現在我們改進了佈局協議
我們還可重新訪問DecoratingLayout的子佈局類型
在這裏我們需要它們是同一種類型
如果都是UI視圖用起來沒問題
但若我們想把CascadingLayout和UIView一起用就不行了
就像我們之前在合成中談到的那樣
我們真正想要的是使所有內容都擁有同一種類型
讓我們更新一下佈局
我們可以改變結構 使它有兩個不同的通用類型參數
每個子佈局一個
然後 我們還可以添加通用限制來要求
那兩種類型有同種類型的內容
這就使我們準確地表達出了限制條件
子佈局的內容必須是同一個類型的
這就是我們完成的協議
表達了我們的佈局抽象
比我們之前那個協議要好得多
這個協議有實際意義
它是一整套操作
表達了它作爲佈局進程的一部分的意義
你還可以查看我們的示例應用瞭解一切運作的
詳細信息
包括我們如何用它
在後臺線程上實現渲染圖片的佈局
我們可以利用新佈局協議的最後一點
就是單元測試
我們可以寫一個有框架屬性的結構
使結構服從我們的佈局協議
然後我們可以改變單元測試在單元測試中使用這個結構
而不是使用佈局中作爲子佈局的UI視圖
現在 佈局只會在這些簡單的結構上設置框架
意思就是 我們的測試跟UIView是完全隔離的
並且只依賴於我們自己的佈局和測試結構的邏輯
我們在不使用GUI的情況下對佈局進行單元測試
我認爲Crusty一定感到自豪
這些是如何在應用的視圖層以一種
你想象不到的方式使用類型和協議的一些示例
我們還瞭解了一些不錯的通用Swift技巧
你可以隨意應用
首先 我們瞭解瞭如何通過使用值類型
改進局部推理
然後我們瞭解了如何使用通用類型
來得到更好的類型安全和靈活的代碼
我們還瞭解了值的合成對於自定義
和創建複雜的行爲來說是個多麼棒的工具
現在讓我們歡迎Alex回到臺上 談一下
我們對應用中控制器的處理
謝謝Jacob
現在我想重點談一下我們如何在控制器層中使用值類型
讓我們談一下應用的撤銷功能
我們在夢想列表中實現了撤銷功能 很好用
但我們注意到有個小漏洞
就是不能撤銷最喜愛的創造物功能
爲了重現這個漏洞我們可以輕觸最喜愛的創造物
目前有隻粉色麒麟是我們最喜愛的創造物
現在讓我們把它變成龍
變更完成 我們只需要輕觸右上方的完成按鈕即可
好了 我們已經修改了最喜愛的創造物
但問題是 如果我們搖動設備來撤銷 什麼也不會發生
所以這是一個漏洞
讓我們看一下代碼看看爲什麼會這樣
目前 在視圖控制器上有兩個模型屬性
一個是夢想的模型屬性一個是最喜愛的創造物的模型屬性
這在UIKit應用中是個很典型的安排
尤其是當模型增加和功能增加時
再一次 我們只有夢想功能
那麼我們實現了撤銷 這很棒
但當我們添加最喜愛的創造物功能後
我們的撤銷代碼就不見了
漏洞的產生是因爲忘了添加那段代碼
要修復這個漏洞我們可以添加另一個代碼路徑
實現最喜愛的創造物的撤銷功能
聽起來像是一個噩夢
因爲每次要添加另一個模型屬性時
我們就不得不添加另一個代碼路徑來實現撤銷
這很糟糕
我們不希望這樣
我們往回退一步
當我們添加更多的模型屬性時
想要找到一個更好的解決方案
那麼方案就是把這些模型屬性合成
到一個單一值中我們的模型結構
撤銷邏輯會按照那一個類型單獨運行
請注意 模型仍然有值語義這很重要
那是因爲它是由兩個別的值合成的
這個方法很棒
因爲現在兩個模型屬性
只有一個單一代碼路徑
如果我們添加另一個模型屬性
我們仍然有一個代碼路徑
這很棒
我們可以通過把兩個模型屬性挪到視圖控制器上的
新模型結構中實現
這樣 我們要做的就是向視圖控制器添加新的模型屬性
這也是我們的構造方式
但現在 我們需要實現撤銷代碼
我們如何實現呢？
嗯 我首先要展示的是常見的實現方式
以及我們爲何認爲這種方式有漏洞
左側是視圖控制器的當前模型值
右側是運算和撤銷堆棧
在應用的原始版本中
我們認爲撤銷堆棧是一系列的小步驟
每個步驟都能響應對第一個模型的修改
和匹配的視圖
比如 在第一個撤銷步驟中
我們要移除用戶剛添加的夢想
然後我們要從那個表視圖中刪除那一行
然後繼續下一個撤銷步驟
在這個撤銷步驟中
我們要把模型重新變回粉色麒麟
那麼這個分別修改並更新
視圖個體模型屬性的方法
很容易出錯
因爲你需要精確地匹配模型中的變更
和視圖中的變更
如果失敗會導致模型和視圖
之間的很多矛盾
最後就會得到這樣的漏洞
我確定你們所有人都遇到過這樣的問題
我總會遇到這樣的問題
很難進行調試
爲什麼很難調試呢？
嗯 讓我們再看看
我們最初的撤銷堆棧
這些不可撤銷的變更實際上是從哪兒來的呢？
嗯 每個不可撤銷的變更都來自我們的視圖控制器
並且每個不可撤銷的變更都會影響順序
當我們嚮應用中添加功能時出錯的機率很大
我們的代碼中並沒有可以
讓我們在模型和視圖更新之間推理一致性的地方
這很不好 因爲太複雜了
讓我們尋找一種更簡單的方式來處理撤銷
如果不記錄小的變更
堆棧中的每一條都只是個完整的新值
完整的新模型
現在 在模型上
實施撤銷就非常簡單了
只需要用堆棧上的模型替換當前模型即可
這樣我們就不用再擔心順序問題了
然後我們只替換值
這樣我們就解決了模型的問題
我們還要解決如何更新UI的問題
在視圖控制器中 無論什麼時候只要模型發生變更
我們就調用modelDidChange方法
我建議你下載這個示例
瞭解這個方法具體是如何運作的更多信息
在那個方法中我們需要找到
新舊模型值之間的不同點
並更新我們的UI進行匹配
比如 我們可以查看
舊模型中最喜愛的創造物是不是跟
新模型中最喜愛的創造物不一樣
如果不一樣 我們就更新表視圖中
包含最喜愛的創造物的那一行
在對象中有一個更好的實現
就像我剛提到的那樣我建議你查看
關於更新UI的更多信息
最後 我們只需要註冊撤銷邏輯
把模型重設爲舊值
這很棒因爲我們現在只需要一個
或者說我們只需要在一個地方註冊撤銷
這有什麼好處呢？
正如我們所看到的 爲了更新UI我們生成了一個單一代碼路徑
所有操作都按順序獨立進行
以前並不是這樣的
這能幫助我們對代碼進行局部推理
和UI更新代碼
我們還能瞭解值之間是如何恰如其分地組合在一起的
如果單一值的屬性有兩個值
那個值仍然會有值語義
好了 讓我們談談如何在有模型屬性的控制器層
使用值類型
在控制器的UI狀態屬性中
我想實現同樣的功能
你以前看過這個屏幕
這是夢想列表
但這個視圖控制器有許多不同的狀態
我要給你們展示視圖控制器的狀態圖
因爲它跟我們一個很酷的功能有關
就是和朋友分享夢想
讓我們來看一下
這是基本狀態圖
我們要從瀏覽狀態開始
輕觸頂部的分享按鈕
將會把我們帶入選擇狀態
然後選擇要分享的夢想
然後輕觸完成按鈕返回分享狀態
分享完成後我們會回到瀏覽狀態
用起來很流暢
但讓我們再快速返回選擇狀態
你會注意到 我們可以通過輕觸
左上角的取消按鈕停止分享
這將把我們帶回瀏覽狀態
你會看到導航欄看起來顯示的是正確的
因爲它又顯示分享按鈕了
但其實在應用中有一個很小的UI漏洞
是由一種不一致狀態導致的
表視圖左側的UI
仍然可見 並仍然允許用戶選擇夢想並分享 這樣是不對的
當我們返回去調試這段代碼時
我們看到某些狀態屬性
在狀態變更時並沒有被全部清除
在這種情況下即使我們進入了瀏覽狀態
我們忘記去清除選擇狀態的
某些屬性
讓我們再看看狀態圖看是否修復了這個問題
這裏的每個狀態都有相應的屬性
並且這些屬性是視圖控制器上的屬性
狀態屬性的個數
隨着應用功能的增加視圖控制器中的
增長可能會很迅速
在這種情況下 重點是我們的屬性是相互排斥的
那麼 當我們瀏覽時我們就不分享
當我們分享時 我們就不選擇
但是 我們寫這段代碼的方式是當你設置一個屬性時
你需要清除其他所有屬性
這很容易出錯
我們要如何解決這個問題呢？
嗯 枚舉非常適合處理相互排斥的值
我們把所有UI狀態屬性都轉成了枚舉值
然後 我們只需要通過使用枚舉把狀態屬性添加到視圖控制器即可
 我們可以確保狀態是相互排斥的
這很棒因爲我們之前發現的無效狀態漏洞
現已不可能再發生了因爲它受類體系的迫使
這個方案也意味着我們的狀態變更
是突然發生的不需要任何可能的中間狀態
因此我們不需要協調該死的屬性
和隱含的時間依賴性
此外 使狀態多合一
更容易以用戶
上次離開時的完全相同的狀態啓動應用
我真心推薦你們再次查看和下載這個項目
看我們是如何在應用中實現狀態修復的
好了 我們今天講了很多內容
開始講了改進應用中的局部推理
通過把值類型和協議引入
到基於模型視圖控制器的應用
我們是如何實現的？
開始是通過把夢想類型做成結構
使模型有值語義
使我們更容易對代碼進行局部推理
因爲我們的夢想變量沒有隱含的分享
然後Jacob展示了如何創建小組件
如DecoratingLayout和CascadingLayout
這些小組件利用了通用協議
確保通用組件可以在視圖、中重新使用
SpriteKit節點和圖形渲染
這使我們得到了更好的局部推理
因爲每個類型都是小的、可測試的、分離的值類型
然後我們瞭解瞭如何利用視圖控制器上的模型屬性
合成到單一類型中
這使我們更容易用單一代碼路徑實現撤銷
即使我們的模型類型有更多的屬性
這個方案還給了我們一個更新UI的代碼路徑
使我們更容易理解
獨立視圖控制器的UI邏輯
最後 我們瞭解瞭如何把相互排斥的狀態屬性轉成
視圖控制器上的枚舉值
這降低了UI爲不一致狀態的潛在機率
並且這也是我們今天討論的值類型
但是 如果你下載示例項目
你將看到項目中的更多信息
而且我們整個應用也使用了很多值類型
除了我們需要用控制器或視圖對象的地方
現在 UIKit要求把這些作爲引用類型
但是我們仍然把絕大多數功能挪到了值類型中
我們今天講了很多 我希望你回家
的時候頭腦裏要記得這幾點
第一是通過合成而不是繼承
進行自定義
你再坐在辦公桌旁
繪製類圖來解決問題時
我希望你考慮如何使用合成
而不是繼承來解決那個問題
這樣你就能獲得我們今天講到的值類型的各種好處了
第二個技巧是給通用的可重複使用的代碼使用協議
你可以做可重複使用的小組件
很容易進行局部推理和測試
我強烈建議你們查看
我們是如何用通用類型而不是類層次
在那個示例中實現的
我們還展示瞭如何利用值語義
需要記住的重點是
如果有由其他屬性組成的值
較大的值也會有值語義
最後 我們談了局部推理
局部推理實際上是個非常通用的技巧
並不是UI編程專用的
也不是移動開發專用的也不是Swift專用的
這是所有編程語言的
一個非常重要的方面
當你回到辦公室並開始編碼時
我希望你思考 無論是哪種語言
如何使用那塊代碼看那塊代碼如何支持局部推理
Swift如此強調值類型絕不是偶然
因爲它們是個非常重要的方面
可以讓你對代碼進行局部推理
就是這樣了
你可以從這裏找到示例代碼和更多相關資源
我強烈建議你們這樣做
我們還有一些相關演講我們在演講中也提到了
我建議你們觀看相關視頻
謝謝大家 希望你們在WWDC期間過得愉快
優化應用的網頁內容
大家好
歡迎來到“優化應用的網頁內容”
我是Jonathan Davis
網絡技術的推廣人負責Safari和WebKit
現在我要先說明一些事情
很多人說我長得像Edward Snowden
但我向你保證 我不是他
但這麼多衛星在頭頂盤旋大概都是來抓我們的
除此之外 我很激動地要展示些新東西
它們可以幫助你提升應用網頁內容的性能
我們一直都知道
性能是提供最佳用戶體驗的關鍵
若你是個應用開發者並在應用裏用了WebViews和JSContext
而且你很關心性能那你就來對地方了
說到性能
在當今時代裏性能其實就是指電池壽命
我認爲電池壽命是最終的有限資源
它帶來很不同的結果如果你能撥出最後一通電話
或者發出最後一份重要的文件在電池耗光之前
性能對用戶來說事關重大
他們所選擇的應用不會讓設備變慢
而且耗電量低
我們的經驗就是根據用戶的反饋和各自的體會
性能很重要因爲電池壽命事關重大
所以今年我們致力於提供更好的工具
來找到和修復網頁內容的性能問題
現在我們爲應用提供了工具比如Swift
還有Objective-C代碼比如Instruments
我們還提供了網絡檢查器幫助網頁開發者創建網頁和網站
但不要覺得因爲你選擇了
在應用中用網絡技術就沒有其他工具可用了
實際上我今天展示給你的所有工具
就是開發給人們既能幫助他們建設網站
也能讓他們在應用裏用網絡技術
那麼我首先要向你展示
如何把網絡檢查器連接到JSContext的WebViews
這樣在你需要它的時候它就會立刻出現
之後你會瞭解一些新的功能
它們能讓你瞭解JavaScript代碼如何分配時間
以及這些新功能如何幫你迅速找到性能上的問題
如果你想要看到網絡內容的內存使用情況
我們也給網絡檢查器增添了新的時間線我都已等不及想展示了
它們會幫你節省很多時間來找到內存過大的問題
準備好了？那就開始吧
第一件我們要做的事
是把網絡檢查器連接到應用裏
在應用裏使用網絡技術有很多原因
如JS context裏的一些JavaScript模塊
可以讓你輕鬆交換邏輯並無編譯地添加新的模塊
可能有些人正在tvOS應用裏使用TVML的 JSContext
另外一個使用網絡技術的原因就是你要顯示的網頁內容
比如第三方網站的一個網頁
這個網站你不能控制
可能就要用到Safari視圖控制器
如果不是你也許可以去聽聽
去年的演講“介紹Safari視圖控制器”
但如果你顯示的內容是你自己的或者你可以控制的
或是可自定義的HTML CSS或JavaScript編寫的內容
或者是可以提升應用體驗的內容
WKWebView是最好的選擇
它實際上是個矩形把網頁內容拉入應用
它引入了iOS 8和OS 10 Yosemite
若你還在使用WebView或者UIWebView
那你一定要考慮升級到WKWebView
事實上 升級到WKWebView可以讓你利用
Nitro JavaScript核心引擎和四級JIT編譯器
這能大大提升速度
若想了解更多WKWebView信息
我推薦2014年的演講介紹了現代化的WebKit API
那麼去年我們給WKWebView添加了很多優秀的功能
比如 加載文件URL和自定義用戶代理字符串還有WK網站數據存儲API
現今有了iOS 10和macOS Sierra我們改進了3D-touch支持
現在你的應用就可以執行這些好用的
Peek和Pop事件在WKWebView裏
就像我之前說的因爲你選了
在應用裏應用網絡技術
並不意味着你沒有工具可用
不論哪種情況你可連接網絡檢查器
發掘網頁內容或JavaScript活動情況
但使用網絡檢查器前你必須要激活develop菜單
只要上傳Safari設置然後找到“高級”標籤
然後在底部你會看到這個複選框
寫着在菜單欄顯示Develop菜單
那就點擊它
Develop菜單就會出現在Safari的菜單欄裏
爲讓網絡檢查器連接到iOS設備
你要開啓一個設置
在iOS的設置應用裏點擊Safari
然後拉到底部 點擊“高級”然後把檢查器設置打開
現在你就可以把設備連到Mac上
在Safari裏檢查Develop菜單
Develop菜單裏有些很酷炫的東西
你之前可能從未注意到過
就是你能看到設備的列表
這裏有已連接的iPhoneMacBook Pro和模擬器
要連接一個設備並開始使用這些工具
進行調試那麼只要選擇Device菜單
就會收到 當前設備上運行的WebViews和JSContexts 的列表
這裏的Mac應用並沒有使用WebKit
而用JavaScript
所以我可以直接連接它並使用工具
iOS裏的應用只會出現在用Xcode創建和運行的時候
但是說到Mac應用你還要做一件事
就是保持應用的完整性我們不會讓任何人下載你的應用
並用網絡檢查器巡查你的應用
所以你要添加這個授權
到應用本地開發的授權文件裏
你可能已經有了一個授權文件
如果沒有創建一個也很簡單
你只要創建新的plist拓展名爲.entitlements
並且Xcode的創建設置裏定義一個代碼簽名的授權傳遞路徑
這個要在開發的時候添加
之後在運行應用的時候刪除
一旦有了這個授權
你的設備和應用就出現在Develop菜單
這樣就可以連接了
輕鬆把網絡檢查器連接到JSContext和WebViews上了
我們已正常運行了網絡檢查器和應用
該談談網絡檢查器裏新功能了
我想首先講講分析JavaScript代碼
分析JavaScript
JavaScript的分析器已經存在挺長時間了
今年它變得更好
更有效率能幫助你迅速找到
哪裏調出的JavaScript成本最高
原因很簡單
新的分析器採用了取樣技術不會影響性能
比以前好太多
我們的分析器在編譯器能用之前的時代
實際是個翻譯器
但是現在我們有了這個強大的四級JIT編譯器
那麼這個分析器就真正成爲樣本分析器
樣本分析器告訴你代碼把時間都用在哪裏
幫你解答哪個代碼佔用的時間最多？
它在運行程序中的取樣以每毫秒爲單位
並且短暫地停頓執行
並快照所有正在運行的代碼
它還可以取樣
在代碼運行於JIT編譯器所有四級的時候
所以它的取樣速度跟你代碼的實際速度差不多
由於斷點處理會導致代碼去優化
我們暫時不管它們
那麼當你分析的時候你就可以瞭解網頁應用的真實性能
使用樣本分析器對性能幾乎沒有損害
這就意味着當你分析代碼的時候
速度高達以前的30倍
這就讓代碼分析過程更快也更簡單
而且收到的數據也更準確
這個進步真令人振奮 因爲我們團隊和網絡檢查器團隊
能利用它來發現可以提升速度的地方
就在網絡檢查器本身
好了現在我們有了樣本分析器
看看如何利用網絡檢查器幫我們找到問題
這個內容很多但是可以簡單的拆分開來
更方便的是這都是你已經熟悉的代碼
當我們說到分析JavaScript時
意思是在Events裏爲JavaScript記錄時間線
這就是Events視圖
顯示了一列單獨而且具體的JavaScript事件
特別的是這裏都是D3庫的代碼
所以它能更方便調試代碼
和分析代碼在你正在使用的庫裏
而且這裏的每一條都是代碼運行的事件
這是代碼進出JavaScript核心引擎的情況
包括了監聽事件的回調
比如動畫框架的條目是在請求動畫框架處理器
腳本評估條目顯示JavaScript文件
的上傳和首次評估
這裏還有一些時間信息
告訴你運行的代碼所花費的時間
所以如果有哪個超過了10或15毫秒
你就快要打破
60幀每秒的流暢性能底線
Events視圖很有用但是還有另一個視圖
是我們爲你添加的叫做Call Trees視圖
如果你用過其他分析工具那麼對這個應該很熟悉
只要點擊這個菜單然後轉換到Call Trees視圖
現在顯示了調用堆棧裏函數的累計運行時間
這個叫做Top Down視圖
你可以用它深入發掘Call Tree
來找到耗費大量時間的熱函數
但我最喜歡的視圖是Bottom Up視圖
它能直接讓我找到最熱的函數
就是取樣最頻繁的函數
這裏羅列的是調出的函數
按照用時從大到小分類
它反轉了Call Tree讓你能直接對比各個函數的耗時
你能準確地看到耗時最多的地方
你可以展開這一條並按照路徑返回
找到耗時最多的函數
你就能知道這個成本最高的代碼是何時何地調出的
那麼關於這部分有請我的同事
Brian Burg上臺爲大家展示
謝謝你 Jon樣本分析器很好用
因爲它可以提取十分複雜的內容
並進行分析讓你看到十分精確的信息
而且你可以讓它跑的更快
爲了給你們展示我要用我製作的iPad應用
叫做衛星跟蹤器在這裏看看
衛星跟蹤器會展示給你現在或任何時間
衛星所在的位置
你可以選擇地球上的不同地點
也可以選擇不同的衛星
不同的時區
這很棒吧
如果你擔心頭上盤旋的衛星
要帶個錫紙帽子以防萬一這個應用就是理想之選
但是這裏有個小問題
如果很多衛星或者很多衛星組件
像這樣擠爆了那麼幀率的波動會很大
這肯定不是60幀每秒
它會一直波動
這樣就可以用樣本分析器來查找
發生了什麼爲什麼這麼慢
我們要做的就是打開Safari並進入Develop菜單
找到這裏的iPad並連接上
那麼我要做的第一件事就是進入Frames視圖
看看現在的位置幀率如何
那麼開始記錄
我再轉回iPad
做點什麼
比如轉動一下
或者換一個衛星
換個時區
好了現在回去看看
好的把這個縮小
所有的性能就都顯示在這裏了
有的時候是60幀每秒像左邊這些
在中間則上下都有
因爲我們在更改視圖
這一些就太慢了
我想知道出了什麼問題
那麼我就轉到Events視圖
點擊JavaScript和Events時間線
重點看看樣本分析器的數據
就像Jon之前演示的那樣這裏的Events視圖
會顯示所有運行循環裏的內容
這個例子裏就是動畫和模擬
就是我們在不斷地渲染幀
這不是很有用因爲無法找到耗時最多的地方
那麼我們轉到Call Trees視圖
這裏我們看到Top DownCall Tree
集合顯示了所有的渲染幀
都是最耗時的地方
展開這個就能看到D3有一個Timer函數
它調出一些代碼畫了一些場景
這些場景包括衛星
和時間等
這個很棒能讓我們瞭解代碼在做什麼
但是如果要想找出哪個函數最耗費
最好還是去看Bottom Up視圖
這裏我們列出了所有函數無論誰調用它們
我們看到這個fillText
和tangent是最耗費的兩個
那爲什麼會調出tangent呢？
我們展開這一行看看調令來源
就在這裏是_plotSatellites
好像正在計算轉換用來繪製地球
好的這些看着都很正常
也許我該找出數學課本讓它算得快一點
現在看看fillText
換個畫面回到這裏的應用
我們正在當前時間上繪製文本也在每個數據點上繪製
這說得通
但是如果仔細看我們實際上把這個時間畫了兩次
這就有點奇怪
所以我們展開這一行
就能看到調令來自哪裏
這裏我們好像一次畫了兩個不同的前景
這大概不是我們想要的
那麼來找找哪兒出了問題
如果像這樣畫了兩個前景
那麼我們的工作量實際就是所需的兩倍
爲了讓你的記憶更清晰記住我們有個平面地圖
然後有這個地球它在轉動
那麼現在回到代碼
找一找是什麼控制着兩個地圖的切換
估計哪裏弄錯了
改變地點的時候我們會讓兩個地球互換
這是 updateLocation
好的 因爲已經有一個地圖就不再需要另一個
這是有道理的因爲這裏我們添加了隱藏類
就爲了不讓它顯示出來
這裏在_globeMap我們定義running值爲真
在整個運行中
而且在place中聲明我們顯示的不是_globeProjection
這是對的
當我們顯示平面地圖
我們不會顯示地球它也不會運行
這個平面地圖看上去好像
一直在運行UI也在運行
這也挺奇怪的
那麼我們回到地圖試着做點兒什麼
這裏我們選擇這個數據組
然後進入Earth
它的幀率要好於只做世界地圖
那麼這就很有道理
我想我們在世界地圖活動的時候畫了兩張地圖
但是在平面地圖的時候只畫了一個
那麼我們就在這裏改變這個條件
糟糕應該反過來
好的 先停下看看有沒有修復
回到iPad
好的這看上去很流暢
來到這裏
恩 很好
看上去不錯
那麼我們再去檢查時間渲染
看看是不是60幀每秒
那麼回到Frames視圖
然後開始記錄很不錯
我轉動地球的時候有點慢
但穩定度看上去...
不錯絕對在60幀每秒以下
在這裏有一個條只要低於它就是好的
現在衛星跟蹤器快了很多
我們就知道什麼時候帶上帽子
這很棒
這就是個簡單的例子關於如何使用樣本分析器
來發現最繁忙的內容並讓它運行的更快
下面Jon會跟大家講講內存和分配
謝謝 Brian
你看到了分析很迅速
它能讓你瞭解代碼的真實速度
這樣你就能獲得十分精確的數據
再看看JavaScript和Events時間線
並用它們找到緩慢的回調處理器和定時器
或者在Events視圖裏緩慢的腳本初始化
請用新的Call Trees視圖來瞭解耗時
因爲它們會沿着你選擇的時間線堆積起來
記着Bottom Up是你的新朋友
它能幫助你找到最需要優化的地方
那麼現在我們已經看過了新的樣本分析器
和新的JavaScriptCall Trees視圖
我很激動能用更好的工具來優化CPU時間
這樣就能給用戶快速的體驗
並幫他們節省了電池
這真的不錯現在我們繼續
看看性能的另一方面
就是了解內存都去哪兒了
你肯定想更有效率地使用網頁內容的內存
因爲這是有限資源
有效地使用內存可以優化網頁內容的比例
並能處理大型數據組
而且內存佔用過多會降低性能我們並不想這樣
它也會讓你的網頁內容崩潰
這更非我們所願
好消息是若你運行WKWebView它會以單獨的進程運行
不會讓整個應用崩潰
但是這仍然不是一個好的用戶體驗
爲了幫你解決這些問題我們添加了兩個新時間線
給網絡檢查器和Safari 10
當啓動新網絡檢查器新時間線就默認關閉
所以要打開它們
你只要點擊Edit就在時間線上面
就可以配置自己想看的時間線
這樣就可以只研究自己想用的那個
就和Instruments應用一樣
只要開啓新的時間線就可以記錄新的時間線了
但你可能不想讓它們同時運行
JavaScript和Events時間線樣本分析器
雖然負載較少但還是有
而JavaScript Allocation的時間線會添加更多進程
在垃圾回收過程中這會影響性能
那我們就一直開着Memory時間線
那麼在記錄一個時間線的時候你會看到這個
這個新的Memory時間線圖表顯示了內存如何分配
到不同的目錄裏在不同的時間
這裏有一系列圖表
幫你瞭解內存的使用和劃分
Breakdown表顯示了內存如何分配給
JavaScript和圖畫和構成頁面的分層
以及其他引擎相關的網頁
Max Comparison圖幫你研究內存高峯
這裏有一個高的水印
幫你觀察過去的內存問題
你甚至可以分離各個峯通過選擇一個特定的部分
或者在一個峯值周圍選擇一個特定的時間段
然後你就可以使用下面的目錄分類
來看看是什麼造成了大部分高峯
這裏的每個圖表都是獨立測量的
所以你可以清楚地看到不同時間的變化
JavaScript裏的峯值顯示的是
大量新對象被創建和引用的地方
其中包括的對象有字符串對象和函數
以及所有支持它們的引擎數據比如結構數據和編譯代碼
當你看到JavaScript的用量下降
就是說垃圾回收在回收內存
圖片顯示了分配給圖片的內存
這些圖片都通過解碼顯示
這裏的圖片數據比較大
通常用於可以在視口顯示的圖片
層顯示的是圖層內存
分配在WebKitstileGrid複合層
和其他引擎層
頁面就囊括了所有其他的東西
引擎所追蹤的所有內容
比如DOM和頁面風格以及字體渲染數據
內存緩存和系統分配
所以這個分類能讓你很好的保證
內存用量符合你的預期
若你有很多JavaScript內容你要明白
JavaScript會是分類圖表裏用量最多的一類
在時間線圖表裏你可能會隨着時間看到更多變化
但是對於多圖片的頁面比如畫廊
那麼分層和圖片目錄就可能是最大的
隨着時間變化也更多
這就是Safari 10裏最新的Memory時間線
Memory時間線的補充就是新的JavaScript Allocations時間線
你不僅能看到不同時間裏內存的變化
還能更細的探究
JavaScript Allocations的真實情況
對此我們有個強大的工具JavaScript Allocation Snapshots
快照的強大之處
是你可在JavaScripts堆裏對一個時刻進行快照
然後你就可以深入看到所有被分配的東西
但是更強大的是你有兩個快照的時候
你就可以回頭再看並進行對比
對比快照是我們最強大的工具之一
它可以解答我是不是做了不必要的分配？
一定要利用它因爲你需要多個快照
這也就是爲什麼默認每10秒照一次
不僅要在記錄開始還要在結束
快照是在時間線上設計的所以它們能連到
其他時間線上發生的事情
在這裏其他的都被我關了
這些快照在下面列出並附了一些細節
比如堆的時間和大小
要了解一個特定的問題
就通常需要在開始和結束的時候快照
圍繞你認爲內存會出問題的地方
這裏有三個技巧
你可以依賴自動快照每10秒一次
或者可以親自快照就按快照鍵
或者用代碼執行
最簡單的找到問題的方法還是改代碼
調出takeHeapSnapshot API
傳遞一個自定義的標籤參數它可以是任何
之後能幫你識別它的東西
還有你要做一對快照
在你認爲導致問題的代碼的前後
你還可以通過快照來使用這個代碼
在一個循環內的工作之間
分析內存
下面講講要時刻牢記的幾點關於takeHeapSnapshot API
要記住快照會增添一些額外的進程在垃圾回收進程中
這會影響性能所以你一定要注意
你的代碼是否頻繁的發射快照
你也要捕捉到前後不同的信息
當代碼在一個循環之間的某個時刻運行時
不要留下這個
如果你把它留下對大部分用戶來說沒問題
但一旦有人運行網絡檢查器它們就會使用所有的快照
你大概也不想這樣
所以要記住在啓動前一定把它們刪除
那麼這些快照都顯示了什麼？
讓我們來看一看
你只要點擊時間線上的快照圖標
或者在快照列表條目裏點擊Arrow按鍵
你看到的這一列對象都是之前分配在堆裏的
快照有兩個視圖
這是Instances視圖
展示了堆裏的對象列表按照類來分組
另一個是對象圖像視圖
這實際上概括了所有東西
所有的所有
如果你很熟悉這個代碼
它就能很好地幫助你確認事情或者找到相應的位置
但是實際上更有用的視圖
是在Instances視圖裏
它的強大在於你可以輕鬆地找到對象
不論他們在屬性路徑裏藏得多深
這裏的Count可以幫你意識到潛在的問題
就是它們無法達到預期的時候
比如我能否實現4000多個字符串對象？
你可以展開這個Classes來看看所有分配到這裏的對象
然後判斷什麼是什麼通過這麼多不同的線索
Class是一線索
另外就是對象的實際屬性
這能讓我們很快了解什麼是什麼
但是最簡單的瞭解對象的方法
就是懸停在這個對象識別器上你就會看到這個
這裏實際上顯示的是到對象的最短路徑
它告訴了你究竟是什麼讓這個對象保持活動
它基本上總會給你你需要的答案
特別是在JavaScript的垃圾回收裏
這就是能立刻解開疑惑的方法
但是它最重要的功能和最關鍵的要點
在於它能比較兩個快照
看看這個當你已經收集了一些快照
只要點擊此處“比較快照”按鍵
然後選擇Baseline快照再選一個對比
一下子
你就有了一個新的對比快照可以研究
這個十分有意義
因爲現在只能看到新的對象
在兩個點之間在兩個快照之間
展開對象類分組可以看到所有的對象分配
預覽中顯示了它們的名字和類似遙測數據的東西
這裏就說明它是衛星對象
這裏的彈窗顯示_Satellites Array屬性
由於這是一個快照對比
衛星的對象都是新分配的
這是個很重要的線索顯示代碼在做什麼
那麼爲了讓你們實際看到這些新的存儲功能
我要有請Brian回到臺上來做另一個演示
謝謝 Jon
我把衛星跟蹤器給了我的朋友Ed
他熬了一夜在玩這個
他很開心因爲他從來沒有被衛星跟蹤過
但是這就有個問題
它運行時間越長最終會變得越來越慢
這在我看來很像傳統的內存
打開時間越久就越慢
我想在衛星跟蹤器裏用這些新存儲工具來看看
我們是否泄漏了一些內存
那麼第一件事
我的iPad在這兒
我要回到網絡檢查器...
並且檢查這個應用
我要做的第一件事
在我不知道問題在哪兒的時候就是要使用Memory時間線
它會告訴我頁面上大概發生了什麼
那麼我們開始記錄
轉回來
我在兩個衛星之間來回切換
也許我會在這裏添加一些效果
好的我在來回切換
好了現在去時間線看看
在時間線概覽中你看到一個堆積線形圖
顯示了所有不同的部分和相關的大小
如果你點擊這裏會看到更多的細節
那麼這個頁面上沒有圖片
都是畫布
分層也很平面
頁面有些波動有些內容在垃圾回收
沒有問題
如果你仔細看看JavaScript你會看到...
雖然有些東西被垃圾回收
但是整體來說它還是在隨着時間堆積
如果我們運行一整晚那估計會堆積更多
下一步就是啓用heap快照或allocation快照
這樣我們就能找到隨着時間而分配的內容
爲了實現這個我們要開始新的記錄
這有個快捷鍵Shift 點擊或Shift 空格
這樣就會啓動新的記錄而不是繼續之前那個
等等我忘了改時間線
去掉Memory
選上Allocations
好了開始記錄
回到iPad
添加了小小的takeHeapSnapshot鍵
我已給控制檯添加了一些takeHeapSnapshot的調令
用於切換兩個衛星小組和其他操作
對這個記錄我要轉動地圖
然後不斷在兩個衛星中切換
我們還要看看Spy Satellites看上去也有關聯
好了 你會發現開始有點卡了
因爲我們給JavaScript堆裏的所有東西拍了快照
因此產生了很多對象
這會大幅降低應用的速度
所以一定不要拍很多快照
只在重要的時候拍
這裏你可以看到方塊裏的S就是我們拍的快照
放大一下能看到
隨着時間過去內存十分穩定的增長
當我們開始在兩個衛星之間切換的時候
如果我們要研究這個像Jon說的那樣
我們就要啓動對比來看看是什麼被攔住了
那麼我們就對比快照9和11
立刻我們就看到很多東西
被分配在9和11之間並且仍然在活動中
這就清楚地說明瞭它們被留存了
雖然我們並不想這麼做
那麼我們來看看這些都是什麼
這是些陣列
看上去這個陣列裏全是座標
你知道在應用的不同部分我們會用大量的座標
但是如果我們停在這裏就會看到它的路徑
它們好像是被保存於trajectoryHistory
這是我們用來製作追蹤衛星的東西
好的這樣不錯
但是我想不應該
再在已不顯示的衛星裏用trajectoryHistory
這好像是個bug
我們也分配了一些對象
但奇怪的是在快照9和11之間
我們之前已經看到這些衛星
那麼我就不想再給每個衛星創建新的對象
我們只要直接使用它們只要我們已經爲他們獲取了資源
然後這裏有了很多座標和遙測
好像正在重新解析什麼
我不太確定那麼...
在這個視圖裏我們有很多對象
你不能讀取所有
所以我想做的就是找出很特別的那一個
那麼在這個快照裏
我們有很多字符串陣列和對象
但只有一個Promise
它停留在兩個快照之間
所以我認爲應該調試這個
那麼我就找到代碼看看是哪裏在用Promises
因爲好像它與別的什麼一起被泄露了
於是搜索Promise
好了 這是D3庫這是使用它的代碼
好的來看看這個
好了 在［聽不清］裏我們常常在衛星之間切換
代碼是loadDataset
有人寫了評論太好了
這裏看上去好像有人請求我們改變衛星
那麼這裏就可以異步從URL下載數據
當它返回我們就要解析
然後使用衛星繪圖庫 做更多的解析
然後我們把它存到衛星列表上
這都很不錯但是回到檢查器
我們好像每次都泄露該Promise
如果你更仔細的想想
如果切換到已經下載的數據組會怎樣？
我們甚至都沒有檢查過這個事情
你仔細的看看這裏
每次在兩個衛星之間轉換
我們就發出一個新的網絡請求
如果我們進入這個時間線
就會看到我們在不斷請求同樣的垃圾數據
這是正常的如果回到代碼 發出請求
解析的時候會產生大量的對象
然後我們把它推入衛星陣列
就目前來看它怎麼都不清楚
我們好像一直在做無用功然後不斷泄露
所以這裏我們要做的
是檢查我們是否已經解析了這個衛星對象
因爲這是Promise
如果它確實存在我們可以調出.then
由於這已解決下一次評估Promise的反應時
它就會進行檢查並將衛星放到地圖上
那麼在這裏添加代碼
如果不存在我們就創建一個
好了 現在停下來看看有沒有效果
我們就要回去重新連接
這是我們的應用開始記錄吧
當我們回到應用我就打開快照
打開一些效果
然後往南走
好的 間諜衛星
衛星的科學實驗
科學實驗
好了
如果我們回到這裏我們看到內存的增長大大降低
大概在1兆而不是四五兆
那麼這裏可能有更多的泄露
但是在快照結束的時候我們的內存
跟剛開始渲染的時候一樣大
這樣我們就修復了這個特殊的泄露
這就展示了我們如何使用Allocations和Memory時間線
來解決像這樣的應用的內存泄露問題
這很不錯因爲應用可以用更多的操作
有了diffing功能
我們就可以深入觀察我們所關心的衛星裏的變化
好了衛星跟蹤器就講到這
你回來吧 Jon
謝謝 Brian
你看到了真是不可思議的迅速和簡單
這些新的時間線讓內存零問題
所以請記住Memory時間線是瞭解
內存的使用情況和造成內存高峯的原因
這樣你就知道該去哪裏找問題
然後使用多個Heap快照在JavaScript Allocations時間線裏
以便單獨放大造成內存增長的代碼
還有不要忘了刪除takeHeapSnapshot
在代碼運行之前
要記住性能所受的影響
是JavaScript Allocations時間線記錄時產生的
那麼以上就是新的時間線工具
可用在Safari 10的網絡檢查器上
我想你一定會愛上它們
在結束之前我還想再說幾點
我要建議你們重新考慮下WKWebView
如果你還沒有換掉它
在Safari設置裏打開Develop菜單
連接網絡檢查器到你的應用
然後開始利用這些新功能
節省大量時間Bottom Up視圖和Call Trees用於
找到最需要優化的地方
Memory時間線可以快速看到內存高峯的情況
Heap快照可以輕鬆查找和比較對象分配
時刻關注新功能的更新
今年網絡檢查器和WebKit有更多內容
可以讓你利用應用的網頁內容
來創造絕佳的應用內的用戶體驗
除了Brian和我今天爲你們展示的功能
我們團隊過去一年也爲網絡檢查器添加了很多內容
Quick Open會讓你直接跳到頁面加載的資源
尾調用堆棧現在可顯示調試器裏的尾調用優化函數
初春的時候在OS 10系統下我們引進了Safari 9.1
並更新了網絡檢查器
它顯示了Elements標籤下DOM Tree裏的Pseudo Elements
這裏還有一個新的視覺風格邊欄
可能你還沒注意到
網絡檢查器是一個開發者工具
作爲WebKit開源項目的一部分
WebKit是網頁瀏覽器引擎用來支持你的應用
驅動WebViews和JSContext
當然它也是Safari背後的動力
在過去一年裏我們爲WebKit添加了好多新功能
我們對ES6100％支持
我們改進了對IndexedDBStandard的支持
還添加了Shadow DOM支持WebDriver和CSS變量
以及Picture Element
所以真的是很多內容而且作爲開源項目
一旦有新的出現你就能知道
你們在座大部分人肯定都想能利用它工作
如果你們想對這些內容作出改進
完全有機會
因爲WebKit是開放資源
你可在WebKit.org上找到更多WebKit項目信息
WebKit團隊及其背後的工程師們會在博客上寫他們的開發工作
實際上我們現在有兩個博客
關於Memory時間線和樣本分析器
就是今天講的內容
所以如果你想了解更多可以去那裏看看
我們還有一個功能狀態頁一目瞭然的列出了所有更新
針對網頁標準進程
這裏還有鏈接可以下載WebKit夜間建構
和最新的瀏覽器Safari技術概覽
每幾周更新一次附帶更新的WebKit引擎
所以你可以在WebKit上嘗試這些新的實驗性功能
它們每兩週改進一次
我們團隊投入了大量精力給SafariWebKit和網絡檢查器
網絡檢查器團隊可以使用這些新性能特性
就像我們今天展示的那樣去查詢問題並提高性能
對網絡檢查器本身
我已經迫不及待想看看你們會做些什麼
想了解更多信息請觀看這個演講
在developer.apple.com下載幻燈片
這周的前幾天有很多場相關演講
過去幾年也有不少
這些都能在developer.apple.com上找到
那麼代表Brian 我自己和Safari與WebKit團隊
感謝你們的到來祝大家在接下來的WWDC中過得愉快
優化應用的網頁內容
大家好
歡迎來到“優化應用的網頁內容”
我是Jonathan Davis
網絡技術的推廣人負責Safari和WebKit
現在我要先說明一些事情
很多人說我長得像Edward Snowden
但我向你保證 我不是他
但這麼多衛星在頭頂盤旋大概都是來抓我們的
除此之外 我很激動地要展示些新東西
它們可以幫助你提升應用網頁內容的性能
我們一直都知道
性能是提供最佳用戶體驗的關鍵
若你是個應用開發者並在應用裏用了WebViews和JSContext
而且你很關心性能那你就來對地方了
說到性能
在當今時代裏性能其實就是指電池壽命
我認爲電池壽命是最終的有限資源
它帶來很不同的結果如果你能撥出最後一通電話
或者發出最後一份重要的文件在電池耗光之前
性能對用戶來說事關重大
他們所選擇的應用不會讓設備變慢
而且耗電量低
我們的經驗就是根據用戶的反饋和各自的體會
性能很重要因爲電池壽命事關重大
所以今年我們致力於提供更好的工具
來找到和修復網頁內容的性能問題
現在我們爲應用提供了工具比如Swift
還有Objective-C代碼比如Instruments
我們還提供了網絡檢查器幫助網頁開發者創建網頁和網站
但不要覺得因爲你選擇了
在應用中用網絡技術就沒有其他工具可用了
實際上我今天展示給你的所有工具
就是開發給人們既能幫助他們建設網站
也能讓他們在應用裏用網絡技術
那麼我首先要向你展示
如何把網絡檢查器連接到JSContext的WebViews
這樣在你需要它的時候它就會立刻出現
之後你會瞭解一些新的功能
它們能讓你瞭解JavaScript代碼如何分配時間
以及這些新功能如何幫你迅速找到性能上的問題
如果你想要看到網絡內容的內存使用情況
我們也給網絡檢查器增添了新的時間線我都已等不及想展示了
它們會幫你節省很多時間來找到內存過大的問題
準備好了？那就開始吧
第一件我們要做的事
是把網絡檢查器連接到應用裏
在應用裏使用網絡技術有很多原因
如JS context裏的一些JavaScript模塊
可以讓你輕鬆交換邏輯並無編譯地添加新的模塊
可能有些人正在tvOS應用裏使用TVML的 JSContext
另外一個使用網絡技術的原因就是你要顯示的網頁內容
比如第三方網站的一個網頁
這個網站你不能控制
可能就要用到Safari視圖控制器
如果不是你也許可以去聽聽
去年的演講“介紹Safari視圖控制器”
但如果你顯示的內容是你自己的或者你可以控制的
或是可自定義的HTML CSS或JavaScript編寫的內容
或者是可以提升應用體驗的內容
WKWebView是最好的選擇
它實際上是個矩形把網頁內容拉入應用
它引入了iOS 8和OS 10 Yosemite
若你還在使用WebView或者UIWebView
那你一定要考慮升級到WKWebView
事實上 升級到WKWebView可以讓你利用
Nitro JavaScript核心引擎和四級JIT編譯器
這能大大提升速度
若想了解更多WKWebView信息
我推薦2014年的演講介紹了現代化的WebKit API
那麼去年我們給WKWebView添加了很多優秀的功能
比如 加載文件URL和自定義用戶代理字符串還有WK網站數據存儲API
現今有了iOS 10和macOS Sierra我們改進了3D-touch支持
現在你的應用就可以執行這些好用的
Peek和Pop事件在WKWebView裏
就像我之前說的因爲你選了
在應用裏應用網絡技術
並不意味着你沒有工具可用
不論哪種情況你可連接網絡檢查器
發掘網頁內容或JavaScript活動情況
但使用網絡檢查器前你必須要激活develop菜單
只要上傳Safari設置然後找到“高級”標籤
然後在底部你會看到這個複選框
寫着在菜單欄顯示Develop菜單
那就點擊它
Develop菜單就會出現在Safari的菜單欄裏
爲讓網絡檢查器連接到iOS設備
你要開啓一個設置
在iOS的設置應用裏點擊Safari
然後拉到底部 點擊“高級”然後把檢查器設置打開
現在你就可以把設備連到Mac上
在Safari裏檢查Develop菜單
Develop菜單裏有些很酷炫的東西
你之前可能從未注意到過
就是你能看到設備的列表
這裏有已連接的iPhoneMacBook Pro和模擬器
要連接一個設備並開始使用這些工具
進行調試那麼只要選擇Device菜單
就會收到 當前設備上運行的WebViews和JSContexts 的列表
這裏的Mac應用並沒有使用WebKit
而用JavaScript
所以我可以直接連接它並使用工具
iOS裏的應用只會出現在用Xcode創建和運行的時候
但是說到Mac應用你還要做一件事
就是保持應用的完整性我們不會讓任何人下載你的應用
並用網絡檢查器巡查你的應用
所以你要添加這個授權
到應用本地開發的授權文件裏
你可能已經有了一個授權文件
如果沒有創建一個也很簡單
你只要創建新的plist拓展名爲.entitlements
並且Xcode的創建設置裏定義一個代碼簽名的授權傳遞路徑
這個要在開發的時候添加
之後在運行應用的時候刪除
一旦有了這個授權
你的設備和應用就出現在Develop菜單
這樣就可以連接了
輕鬆把網絡檢查器連接到JSContext和WebViews上了
我們已正常運行了網絡檢查器和應用
該談談網絡檢查器裏新功能了
我想首先講講分析JavaScript代碼
分析JavaScript
JavaScript的分析器已經存在挺長時間了
今年它變得更好
更有效率能幫助你迅速找到
哪裏調出的JavaScript成本最高
原因很簡單
新的分析器採用了取樣技術不會影響性能
比以前好太多
我們的分析器在編譯器能用之前的時代
實際是個翻譯器
但是現在我們有了這個強大的四級JIT編譯器
那麼這個分析器就真正成爲樣本分析器
樣本分析器告訴你代碼把時間都用在哪裏
幫你解答哪個代碼佔用的時間最多？
它在運行程序中的取樣以每毫秒爲單位
並且短暫地停頓執行
並快照所有正在運行的代碼
它還可以取樣
在代碼運行於JIT編譯器所有四級的時候
所以它的取樣速度跟你代碼的實際速度差不多
由於斷點處理會導致代碼去優化
我們暫時不管它們
那麼當你分析的時候你就可以瞭解網頁應用的真實性能
使用樣本分析器對性能幾乎沒有損害
這就意味着當你分析代碼的時候
速度高達以前的30倍
這就讓代碼分析過程更快也更簡單
而且收到的數據也更準確
這個進步真令人振奮 因爲我們團隊和網絡檢查器團隊
能利用它來發現可以提升速度的地方
就在網絡檢查器本身
好了現在我們有了樣本分析器
看看如何利用網絡檢查器幫我們找到問題
這個內容很多但是可以簡單的拆分開來
更方便的是這都是你已經熟悉的代碼
當我們說到分析JavaScript時
意思是在Events裏爲JavaScript記錄時間線
這就是Events視圖
顯示了一列單獨而且具體的JavaScript事件
特別的是這裏都是D3庫的代碼
所以它能更方便調試代碼
和分析代碼在你正在使用的庫裏
而且這裏的每一條都是代碼運行的事件
這是代碼進出JavaScript核心引擎的情況
包括了監聽事件的回調
比如動畫框架的條目是在請求動畫框架處理器
腳本評估條目顯示JavaScript文件
的上傳和首次評估
這裏還有一些時間信息
告訴你運行的代碼所花費的時間
所以如果有哪個超過了10或15毫秒
你就快要打破
60幀每秒的流暢性能底線
Events視圖很有用但是還有另一個視圖
是我們爲你添加的叫做Call Trees視圖
如果你用過其他分析工具那麼對這個應該很熟悉
只要點擊這個菜單然後轉換到Call Trees視圖
現在顯示了調用堆棧裏函數的累計運行時間
這個叫做Top Down視圖
你可以用它深入發掘Call Tree
來找到耗費大量時間的熱函數
但我最喜歡的視圖是Bottom Up視圖
它能直接讓我找到最熱的函數
就是取樣最頻繁的函數
這裏羅列的是調出的函數
按照用時從大到小分類
它反轉了Call Tree讓你能直接對比各個函數的耗時
你能準確地看到耗時最多的地方
你可以展開這一條並按照路徑返回
找到耗時最多的函數
你就能知道這個成本最高的代碼是何時何地調出的
那麼關於這部分有請我的同事
Brian Burg上臺爲大家展示
謝謝你 Jon樣本分析器很好用
因爲它可以提取十分複雜的內容
並進行分析讓你看到十分精確的信息
而且你可以讓它跑的更快
爲了給你們展示我要用我製作的iPad應用
叫做衛星跟蹤器在這裏看看
衛星跟蹤器會展示給你現在或任何時間
衛星所在的位置
你可以選擇地球上的不同地點
也可以選擇不同的衛星
不同的時區
這很棒吧
如果你擔心頭上盤旋的衛星
要帶個錫紙帽子以防萬一這個應用就是理想之選
但是這裏有個小問題
如果很多衛星或者很多衛星組件
像這樣擠爆了那麼幀率的波動會很大
這肯定不是60幀每秒
它會一直波動
這樣就可以用樣本分析器來查找
發生了什麼爲什麼這麼慢
我們要做的就是打開Safari並進入Develop菜單
找到這裏的iPad並連接上
那麼我要做的第一件事就是進入Frames視圖
看看現在的位置幀率如何
那麼開始記錄
我再轉回iPad
做點什麼
比如轉動一下
或者換一個衛星
換個時區
好了現在回去看看
好的把這個縮小
所有的性能就都顯示在這裏了
有的時候是60幀每秒像左邊這些
在中間則上下都有
因爲我們在更改視圖
這一些就太慢了
我想知道出了什麼問題
那麼我就轉到Events視圖
點擊JavaScript和Events時間線
重點看看樣本分析器的數據
就像Jon之前演示的那樣這裏的Events視圖
會顯示所有運行循環裏的內容
這個例子裏就是動畫和模擬
就是我們在不斷地渲染幀
這不是很有用因爲無法找到耗時最多的地方
那麼我們轉到Call Trees視圖
這裏我們看到Top DownCall Tree
集合顯示了所有的渲染幀
都是最耗時的地方
展開這個就能看到D3有一個Timer函數
它調出一些代碼畫了一些場景
這些場景包括衛星
和時間等
這個很棒能讓我們瞭解代碼在做什麼
但是如果要想找出哪個函數最耗費
最好還是去看Bottom Up視圖
這裏我們列出了所有函數無論誰調用它們
我們看到這個fillText
和tangent是最耗費的兩個
那爲什麼會調出tangent呢？
我們展開這一行看看調令來源
就在這裏是_plotSatellites
好像正在計算轉換用來繪製地球
好的這些看着都很正常
也許我該找出數學課本讓它算得快一點
現在看看fillText
換個畫面回到這裏的應用
我們正在當前時間上繪製文本也在每個數據點上繪製
這說得通
但是如果仔細看我們實際上把這個時間畫了兩次
這就有點奇怪
所以我們展開這一行
就能看到調令來自哪裏
這裏我們好像一次畫了兩個不同的前景
這大概不是我們想要的
那麼來找找哪兒出了問題
如果像這樣畫了兩個前景
那麼我們的工作量實際就是所需的兩倍
爲了讓你的記憶更清晰記住我們有個平面地圖
然後有這個地球它在轉動
那麼現在回到代碼
找一找是什麼控制着兩個地圖的切換
估計哪裏弄錯了
改變地點的時候我們會讓兩個地球互換
這是 updateLocation
好的 因爲已經有一個地圖就不再需要另一個
這是有道理的因爲這裏我們添加了隱藏類
就爲了不讓它顯示出來
這裏在_globeMap我們定義running值爲真
在整個運行中
而且在place中聲明我們顯示的不是_globeProjection
這是對的
當我們顯示平面地圖
我們不會顯示地球它也不會運行
這個平面地圖看上去好像
一直在運行UI也在運行
這也挺奇怪的
那麼我們回到地圖試着做點兒什麼
這裏我們選擇這個數據組
然後進入Earth
它的幀率要好於只做世界地圖
那麼這就很有道理
我想我們在世界地圖活動的時候畫了兩張地圖
但是在平面地圖的時候只畫了一個
那麼我們就在這裏改變這個條件
糟糕應該反過來
好的 先停下看看有沒有修復
回到iPad
好的這看上去很流暢
來到這裏
恩 很好
看上去不錯
那麼我們再去檢查時間渲染
看看是不是60幀每秒
那麼回到Frames視圖
然後開始記錄很不錯
我轉動地球的時候有點慢
但穩定度看上去...
不錯絕對在60幀每秒以下
在這裏有一個條只要低於它就是好的
現在衛星跟蹤器快了很多
我們就知道什麼時候帶上帽子
這很棒
這就是個簡單的例子關於如何使用樣本分析器
來發現最繁忙的內容並讓它運行的更快
下面Jon會跟大家講講內存和分配
謝謝 Brian
你看到了分析很迅速
它能讓你瞭解代碼的真實速度
這樣你就能獲得十分精確的數據
再看看JavaScript和Events時間線
並用它們找到緩慢的回調處理器和定時器
或者在Events視圖裏緩慢的腳本初始化
請用新的Call Trees視圖來瞭解耗時
因爲它們會沿着你選擇的時間線堆積起來
記着Bottom Up是你的新朋友
它能幫助你找到最需要優化的地方
那麼現在我們已經看過了新的樣本分析器
和新的JavaScriptCall Trees視圖
我很激動能用更好的工具來優化CPU時間
這樣就能給用戶快速的體驗
並幫他們節省了電池
這真的不錯現在我們繼續
看看性能的另一方面
就是了解內存都去哪兒了
你肯定想更有效率地使用網頁內容的內存
因爲這是有限資源
有效地使用內存可以優化網頁內容的比例
並能處理大型數據組
而且內存佔用過多會降低性能我們並不想這樣
它也會讓你的網頁內容崩潰
這更非我們所願
好消息是若你運行WKWebView它會以單獨的進程運行
不會讓整個應用崩潰
但是這仍然不是一個好的用戶體驗
爲了幫你解決這些問題我們添加了兩個新時間線
給網絡檢查器和Safari 10
當啓動新網絡檢查器新時間線就默認關閉
所以要打開它們
你只要點擊Edit就在時間線上面
就可以配置自己想看的時間線
這樣就可以只研究自己想用的那個
就和Instruments應用一樣
只要開啓新的時間線就可以記錄新的時間線了
但你可能不想讓它們同時運行
JavaScript和Events時間線樣本分析器
雖然負載較少但還是有
而JavaScript Allocation的時間線會添加更多進程
在垃圾回收過程中這會影響性能
那我們就一直開着Memory時間線
那麼在記錄一個時間線的時候你會看到這個
這個新的Memory時間線圖表顯示了內存如何分配
到不同的目錄裏在不同的時間
這裏有一系列圖表
幫你瞭解內存的使用和劃分
Breakdown表顯示了內存如何分配給
JavaScript和圖畫和構成頁面的分層
以及其他引擎相關的網頁
Max Comparison圖幫你研究內存高峯
這裏有一個高的水印
幫你觀察過去的內存問題
你甚至可以分離各個峯通過選擇一個特定的部分
或者在一個峯值周圍選擇一個特定的時間段
然後你就可以使用下面的目錄分類
來看看是什麼造成了大部分高峯
這裏的每個圖表都是獨立測量的
所以你可以清楚地看到不同時間的變化
JavaScript裏的峯值顯示的是
大量新對象被創建和引用的地方
其中包括的對象有字符串對象和函數
以及所有支持它們的引擎數據比如結構數據和編譯代碼
當你看到JavaScript的用量下降
就是說垃圾回收在回收內存
圖片顯示了分配給圖片的內存
這些圖片都通過解碼顯示
這裏的圖片數據比較大
通常用於可以在視口顯示的圖片
層顯示的是圖層內存
分配在WebKitstileGrid複合層
和其他引擎層
頁面就囊括了所有其他的東西
引擎所追蹤的所有內容
比如DOM和頁面風格以及字體渲染數據
內存緩存和系統分配
所以這個分類能讓你很好的保證
內存用量符合你的預期
若你有很多JavaScript內容你要明白
JavaScript會是分類圖表裏用量最多的一類
在時間線圖表裏你可能會隨着時間看到更多變化
但是對於多圖片的頁面比如畫廊
那麼分層和圖片目錄就可能是最大的
隨着時間變化也更多
這就是Safari 10裏最新的Memory時間線
Memory時間線的補充就是新的JavaScript Allocations時間線
你不僅能看到不同時間裏內存的變化
還能更細的探究
JavaScript Allocations的真實情況
對此我們有個強大的工具JavaScript Allocation Snapshots
快照的強大之處
是你可在JavaScripts堆裏對一個時刻進行快照
然後你就可以深入看到所有被分配的東西
但是更強大的是你有兩個快照的時候
你就可以回頭再看並進行對比
對比快照是我們最強大的工具之一
它可以解答我是不是做了不必要的分配？
一定要利用它因爲你需要多個快照
這也就是爲什麼默認每10秒照一次
不僅要在記錄開始還要在結束
快照是在時間線上設計的所以它們能連到
其他時間線上發生的事情
在這裏其他的都被我關了
這些快照在下面列出並附了一些細節
比如堆的時間和大小
要了解一個特定的問題
就通常需要在開始和結束的時候快照
圍繞你認爲內存會出問題的地方
這裏有三個技巧
你可以依賴自動快照每10秒一次
或者可以親自快照就按快照鍵
或者用代碼執行
最簡單的找到問題的方法還是改代碼
調出takeHeapSnapshot API
傳遞一個自定義的標籤參數它可以是任何
之後能幫你識別它的東西
還有你要做一對快照
在你認爲導致問題的代碼的前後
你還可以通過快照來使用這個代碼
在一個循環內的工作之間
分析內存
下面講講要時刻牢記的幾點關於takeHeapSnapshot API
要記住快照會增添一些額外的進程在垃圾回收進程中
這會影響性能所以你一定要注意
你的代碼是否頻繁的發射快照
你也要捕捉到前後不同的信息
當代碼在一個循環之間的某個時刻運行時
不要留下這個
如果你把它留下對大部分用戶來說沒問題
但一旦有人運行網絡檢查器它們就會使用所有的快照
你大概也不想這樣
所以要記住在啓動前一定把它們刪除
那麼這些快照都顯示了什麼？
讓我們來看一看
你只要點擊時間線上的快照圖標
或者在快照列表條目裏點擊Arrow按鍵
你看到的這一列對象都是之前分配在堆裏的
快照有兩個視圖
這是Instances視圖
展示了堆裏的對象列表按照類來分組
另一個是對象圖像視圖
這實際上概括了所有東西
所有的所有
如果你很熟悉這個代碼
它就能很好地幫助你確認事情或者找到相應的位置
但是實際上更有用的視圖
是在Instances視圖裏
它的強大在於你可以輕鬆地找到對象
不論他們在屬性路徑裏藏得多深
這裏的Count可以幫你意識到潛在的問題
就是它們無法達到預期的時候
比如我能否實現4000多個字符串對象？
你可以展開這個Classes來看看所有分配到這裏的對象
然後判斷什麼是什麼通過這麼多不同的線索
Class是一線索
另外就是對象的實際屬性
這能讓我們很快了解什麼是什麼
但是最簡單的瞭解對象的方法
就是懸停在這個對象識別器上你就會看到這個
這裏實際上顯示的是到對象的最短路徑
它告訴了你究竟是什麼讓這個對象保持活動
它基本上總會給你你需要的答案
特別是在JavaScript的垃圾回收裏
這就是能立刻解開疑惑的方法
但是它最重要的功能和最關鍵的要點
在於它能比較兩個快照
看看這個當你已經收集了一些快照
只要點擊此處“比較快照”按鍵
然後選擇Baseline快照再選一個對比
一下子
你就有了一個新的對比快照可以研究
這個十分有意義
因爲現在只能看到新的對象
在兩個點之間在兩個快照之間
展開對象類分組可以看到所有的對象分配
預覽中顯示了它們的名字和類似遙測數據的東西
這裏就說明它是衛星對象
這裏的彈窗顯示_Satellites Array屬性
由於這是一個快照對比
衛星的對象都是新分配的
這是個很重要的線索顯示代碼在做什麼
那麼爲了讓你們實際看到這些新的存儲功能
我要有請Brian回到臺上來做另一個演示
謝謝 Jon
我把衛星跟蹤器給了我的朋友Ed
他熬了一夜在玩這個
他很開心因爲他從來沒有被衛星跟蹤過
但是這就有個問題
它運行時間越長最終會變得越來越慢
這在我看來很像傳統的內存
打開時間越久就越慢
我想在衛星跟蹤器裏用這些新存儲工具來看看
我們是否泄漏了一些內存
那麼第一件事
我的iPad在這兒
我要回到網絡檢查器...
並且檢查這個應用
我要做的第一件事
在我不知道問題在哪兒的時候就是要使用Memory時間線
它會告訴我頁面上大概發生了什麼
那麼我們開始記錄
轉回來
我在兩個衛星之間來回切換
也許我會在這裏添加一些效果
好的我在來回切換
好了現在去時間線看看
在時間線概覽中你看到一個堆積線形圖
顯示了所有不同的部分和相關的大小
如果你點擊這裏會看到更多的細節
那麼這個頁面上沒有圖片
都是畫布
分層也很平面
頁面有些波動有些內容在垃圾回收
沒有問題
如果你仔細看看JavaScript你會看到...
雖然有些東西被垃圾回收
但是整體來說它還是在隨着時間堆積
如果我們運行一整晚那估計會堆積更多
下一步就是啓用heap快照或allocation快照
這樣我們就能找到隨着時間而分配的內容
爲了實現這個我們要開始新的記錄
這有個快捷鍵Shift 點擊或Shift 空格
這樣就會啓動新的記錄而不是繼續之前那個
等等我忘了改時間線
去掉Memory
選上Allocations
好了開始記錄
回到iPad
添加了小小的takeHeapSnapshot鍵
我已給控制檯添加了一些takeHeapSnapshot的調令
用於切換兩個衛星小組和其他操作
對這個記錄我要轉動地圖
然後不斷在兩個衛星中切換
我們還要看看Spy Satellites看上去也有關聯
好了 你會發現開始有點卡了
因爲我們給JavaScript堆裏的所有東西拍了快照
因此產生了很多對象
這會大幅降低應用的速度
所以一定不要拍很多快照
只在重要的時候拍
這裏你可以看到方塊裏的S就是我們拍的快照
放大一下能看到
隨着時間過去內存十分穩定的增長
當我們開始在兩個衛星之間切換的時候
如果我們要研究這個像Jon說的那樣
我們就要啓動對比來看看是什麼被攔住了
那麼我們就對比快照9和11
立刻我們就看到很多東西
被分配在9和11之間並且仍然在活動中
這就清楚地說明瞭它們被留存了
雖然我們並不想這麼做
那麼我們來看看這些都是什麼
這是些陣列
看上去這個陣列裏全是座標
你知道在應用的不同部分我們會用大量的座標
但是如果我們停在這裏就會看到它的路徑
它們好像是被保存於trajectoryHistory
這是我們用來製作追蹤衛星的東西
好的這樣不錯
但是我想不應該
再在已不顯示的衛星裏用trajectoryHistory
這好像是個bug
我們也分配了一些對象
但奇怪的是在快照9和11之間
我們之前已經看到這些衛星
那麼我就不想再給每個衛星創建新的對象
我們只要直接使用它們只要我們已經爲他們獲取了資源
然後這裏有了很多座標和遙測
好像正在重新解析什麼
我不太確定那麼...
在這個視圖裏我們有很多對象
你不能讀取所有
所以我想做的就是找出很特別的那一個
那麼在這個快照裏
我們有很多字符串陣列和對象
但只有一個Promise
它停留在兩個快照之間
所以我認爲應該調試這個
那麼我就找到代碼看看是哪裏在用Promises
因爲好像它與別的什麼一起被泄露了
於是搜索Promise
好了 這是D3庫這是使用它的代碼
好的來看看這個
好了 在［聽不清］裏我們常常在衛星之間切換
代碼是loadDataset
有人寫了評論太好了
這裏看上去好像有人請求我們改變衛星
那麼這裏就可以異步從URL下載數據
當它返回我們就要解析
然後使用衛星繪圖庫 做更多的解析
然後我們把它存到衛星列表上
這都很不錯但是回到檢查器
我們好像每次都泄露該Promise
如果你更仔細的想想
如果切換到已經下載的數據組會怎樣？
我們甚至都沒有檢查過這個事情
你仔細的看看這裏
每次在兩個衛星之間轉換
我們就發出一個新的網絡請求
如果我們進入這個時間線
就會看到我們在不斷請求同樣的垃圾數據
這是正常的如果回到代碼 發出請求
解析的時候會產生大量的對象
然後我們把它推入衛星陣列
就目前來看它怎麼都不清楚
我們好像一直在做無用功然後不斷泄露
所以這裏我們要做的
是檢查我們是否已經解析了這個衛星對象
因爲這是Promise
如果它確實存在我們可以調出.then
由於這已解決下一次評估Promise的反應時
它就會進行檢查並將衛星放到地圖上
那麼在這裏添加代碼
如果不存在我們就創建一個
好了 現在停下來看看有沒有效果
我們就要回去重新連接
這是我們的應用開始記錄吧
當我們回到應用我就打開快照
打開一些效果
然後往南走
好的 間諜衛星
衛星的科學實驗
科學實驗
好了
如果我們回到這裏我們看到內存的增長大大降低
大概在1兆而不是四五兆
那麼這裏可能有更多的泄露
但是在快照結束的時候我們的內存
跟剛開始渲染的時候一樣大
這樣我們就修復了這個特殊的泄露
這就展示了我們如何使用Allocations和Memory時間線
來解決像這樣的應用的內存泄露問題
這很不錯因爲應用可以用更多的操作
有了diffing功能
我們就可以深入觀察我們所關心的衛星裏的變化
好了衛星跟蹤器就講到這
你回來吧 Jon
謝謝 Brian
你看到了真是不可思議的迅速和簡單
這些新的時間線讓內存零問題
所以請記住Memory時間線是瞭解
內存的使用情況和造成內存高峯的原因
這樣你就知道該去哪裏找問題
然後使用多個Heap快照在JavaScript Allocations時間線裏
以便單獨放大造成內存增長的代碼
還有不要忘了刪除takeHeapSnapshot
在代碼運行之前
要記住性能所受的影響
是JavaScript Allocations時間線記錄時產生的
那麼以上就是新的時間線工具
可用在Safari 10的網絡檢查器上
我想你一定會愛上它們
在結束之前我還想再說幾點
我要建議你們重新考慮下WKWebView
如果你還沒有換掉它
在Safari設置裏打開Develop菜單
連接網絡檢查器到你的應用
然後開始利用這些新功能
節省大量時間Bottom Up視圖和Call Trees用於
找到最需要優化的地方
Memory時間線可以快速看到內存高峯的情況
Heap快照可以輕鬆查找和比較對象分配
時刻關注新功能的更新
今年網絡檢查器和WebKit有更多內容
可以讓你利用應用的網頁內容
來創造絕佳的應用內的用戶體驗
除了Brian和我今天爲你們展示的功能
我們團隊過去一年也爲網絡檢查器添加了很多內容
Quick Open會讓你直接跳到頁面加載的資源
尾調用堆棧現在可顯示調試器裏的尾調用優化函數
初春的時候在OS 10系統下我們引進了Safari 9.1
並更新了網絡檢查器
它顯示了Elements標籤下DOM Tree裏的Pseudo Elements
這裏還有一個新的視覺風格邊欄
可能你還沒注意到
網絡檢查器是一個開發者工具
作爲WebKit開源項目的一部分
WebKit是網頁瀏覽器引擎用來支持你的應用
驅動WebViews和JSContext
當然它也是Safari背後的動力
在過去一年裏我們爲WebKit添加了好多新功能
我們對ES6100％支持
我們改進了對IndexedDBStandard的支持
還添加了Shadow DOM支持WebDriver和CSS變量
以及Picture Element
所以真的是很多內容而且作爲開源項目
一旦有新的出現你就能知道
你們在座大部分人肯定都想能利用它工作
如果你們想對這些內容作出改進
完全有機會
因爲WebKit是開放資源
你可在WebKit.org上找到更多WebKit項目信息
WebKit團隊及其背後的工程師們會在博客上寫他們的開發工作
實際上我們現在有兩個博客
關於Memory時間線和樣本分析器
就是今天講的內容
所以如果你想了解更多可以去那裏看看
我們還有一個功能狀態頁一目瞭然的列出了所有更新
針對網頁標準進程
這裏還有鏈接可以下載WebKit夜間建構
和最新的瀏覽器Safari技術概覽
每幾周更新一次附帶更新的WebKit引擎
所以你可以在WebKit上嘗試這些新的實驗性功能
它們每兩週改進一次
我們團隊投入了大量精力給SafariWebKit和網絡檢查器
網絡檢查器團隊可以使用這些新性能特性
就像我們今天展示的那樣去查詢問題並提高性能
對網絡檢查器本身
我已經迫不及待想看看你們會做些什麼
想了解更多信息請觀看這個演講
在developer.apple.com下載幻燈片
這周的前幾天有很多場相關演講
過去幾年也有不少
這些都能在developer.apple.com上找到
那麼代表Brian 我自己和Safari與WebKit團隊
感謝你們的到來祝大家在接下來的WWDC中過得愉快