用SiriKit擴展你的應用
大家好
我是Vineet Khosla
今天我將與Diana Huang和Scott Andrus一起
向你們展示如何利用SiriKit擴展你們的應用程序
在簡介的部分
大家瞭解了一款支持SiriKit的應用由三個核心部分組成
你們有意圖擴展
你們有意圖用戶界面擴展
當然 還有你們的應用程序
在意圖擴展下我們有三個主要的方法
它們分別是解析和確認還有處理
在這個部分我們將探索三個內容
首先 我們會聊一下如何讓你們的應用適用SiriKit
然後 我們會聊如何添加你們的第一個意圖擴展
最後 我們會聊一下如何將你們的應用程序
UI和樣式集成到Siri experience
通過編寫I意圖用戶界面擴展
在這個部分 我們將使用最愛的聊天應用獨角獸快信
你們有些人一定知道這款應用
它是一款人見人愛的應用被Siri團隊內部用來
與我們的獨角獸們聊天
這是一款標準的消息應用是可以用來收發信息
但它具備一些特有的不完美之處
它的特殊使得它能爲我們的目的服務
今天我們將會讓它支持SiriKit
SiriKit是構建在擴展之上的
但是 在你們的應用與擴展集成之前
可爲其與SiriKit相適做些準備
我先介紹一些涉及到的地方
我們將會聊一下如何準備你們的應用通過轉移一些你們的代碼
至embeddedframeworks
Embedded frameworks是一個很好的重用代碼的方式
在應用與擴展之間
轉移一些代碼至embedded frameworks
也將會提供給我們一個很好的單元測試的機會
然後 最後我們將簡單介紹一下什麼是合理的總體結構
用於構建你們的擴展
基於你們的應用所關聯的意圖
現在 讓我們進一步得看一下embedded frameworks
你們的擴展需要執行和應用一樣的任務
它要能操控意圖
還有當需要時也能渲染UI
利用embedded frameworks是很好的重用代碼方式
在應用之間 同樣也在擴展之間
因爲你們要保證用戶有一個統一的體驗
無論他們是從你的應用
或者是通過SiriKit進入程序
以獨角獸快信爲例我們找到了一些地方
應該可以被移到embedded frameworks
我們看了一下獨角獸快信的網絡層
這是所有關於傳送
和接收信息的部分
我們意識到這一部分代碼
很適合被全部移至embedded frameworks
進而 它能被我的應用和擴展重複調用
在完成以上的移動後我們看了一下數據模型
你們的應用和擴展應該使用同一個數據模型
在我們的聊天應用裏 它是一個數據庫
和其讀寫方法
它同樣可以被移到一個embedded framework裏
被應用和擴展調用
在完成上述的移動後我們看了一下決策邏輯
這是你們應用的業務邏輯
在早些時候我們已經提過
我們有解析和確認還有處理方法
這三個方法將與你們應用的實際業務邏輯一一對應
你們應該確保應用
和意圖擴展
提供給你們用戶一致的體驗當他們嘗試着去
完成一個任務無論他們從哪裏開始
所以我們也將決策邏輯移到了一個embedded framework裏
最後若你的應用與意圖關聯
需要讓UI返回至SiriKit
那部分代碼也應該被移至embedded framework
那樣 你可以重複調用代碼同樣
提供給你們用戶一個一致的體驗
無論你們用戶的入口點是你們的應用
或是一個意圖擴展
我建議大家觀看一個2015年的講座
應用拓展最佳實踐
我看了這個講座我感到很受益
在轉移了大部分我們的代碼至embedded frameworks之後
這給我們提供了一個很好的機會去寫一些高質量的單元測試
我知道大家會覺得這是一個老生常談的問題
我們在座的所有工程師都十分會寫單元測試
我們都遵循測試驅動開發
我相信每一次都是這樣的
但我們轉移這些代碼
至一個embeddedframework將會提供給你們
一個新的機會去寫一些高質量的單元測試
特別是針對SiriKit
你們可創建一些模擬的意圖
然後寫一些測試確保你們的應用
和擴展有正確的響應
你們無需實時的和Siri進行溝通
你們可以模擬期望中從Siri那裏接收到的意圖對象
然後 你們可以寫一些線下的測試
最後 讓我們來思考一下怎樣構建你們的應用
使其有合理的擴展的數量
一般來說 一個應用會與多個意圖關聯
因爲 應用要會執行多個任務
例子裏獨角獸快信使用SendMessageIntent
但讓我們假想一下我們想添加一個新的功能
我們可以用它來進行視屏和音頻通話
那問題是我們如何構建我們的擴展？
是否該把操控所有意圖的意圖放在一個擴展裏？
但這樣會使我們的代碼體積變得龐大進而難以管理
我們可以使用另一種構建
雖然不是那麼的簡潔
把所有意圖的操控分開放在獨立的擴展裏
那看起來不錯 但你也許會
重複寫些模版式的代碼
也會創建一些多餘的擴展
導致對內存施加不必要的壓力
那在獨角獸快信裏
我的宗旨是
考慮如何將有關係的意圖分類到一起
在我們的例子裏我們覺得視頻和音頻的意圖
可以被自然地分類到同一個擴展裏
因爲這樣可以讓我們最大限度地利用代碼
同時 消息發送的意圖可以被放在一個分開獨立的擴展裏
總而言之 沒有一個一勞永逸的辦法
你們是最瞭解你們的應用的人
你們知道你們的應用會使用哪些意圖
那你們需要選擇一種構件它能確保
你們的代碼容易被管理 同時
不會創建過多的擴展進而 對內存施加不必要的壓力
經過以上的討論之後
你的應用已準備好採用SiriKit
爲了幫助我們寫我們的第一個意圖擴展
我邀請Diana上臺
謝謝Vineet
大家好
我是Diana Huang我想在這裏和你們聊一下
如何創建第一個能與Siri交流的意圖擴展
在你們的應用已經完全準備好採用SiriKit的情況下
我也將會用Xcode向你們展示獨角獸快信的例子
那讓我們現在開始你們需要遵循有三個步驟
首先 你們要添加一個I意圖擴展 target到你的應用
接下來 你們要設置這個擴展的Info.plist
最後 你們需要看一下這個擴展的principal類
讓我們來分別看一下這三個步驟
要添加一個I意圖擴展 target
你需要依次進入Xcode文件新建Target
然後從列表裏選擇意圖擴展
對於你們曾經使用過擴展的人
就和創建其它的擴展targets方式一樣
現在 讓我們來看一下擴展的Info.plist
我們看到現有的NSExtension關鍵值
然後 在裏面我們看到NSExtensionAttributes
在字典裏面
我們引進兩個新的iOS X的關鍵值
分別是IntentsSupported和IntentsRestricted WhileLocked
IntentsSupported是一個必要的關鍵值
爲描述你們的擴展的具體功能
換句話說 你們需要將一組意圖類的名字添加到
在IntentsSupported下的一個數組進而才能被擴展支持
IntentsRestricted WhileLocked是一個可選的關鍵值
爲描述鎖屏狀態的行爲
在默認的情況下Siri限制了一些特定的域
爲在鎖屏狀態下不被隨意調用
例子有 付款域或圖片搜索域
但如果你們的應用有比Siri更高的安全要求
那你們可以把想限制的意圖類加入到一個數組
在IntentsRestrictedWhileLocked之下
這樣就可以指示Siri請提示用戶
先解除鎖屏再調用你們的擴展來操控意圖
現在我們擴展的Info.plist也已經被設置好了
接着讓我們看看principal類
意圖擴展的principal類
必須是INExtension的子類
這樣符合INIntentHandlerProviding協議
這個協議只有一個叫handlerForintent的方法
這個方法的名字清楚地解釋了它的用途
你們有一個意圖對象你們需要返回一個Handler對象
請注意返回的Handler對象必須符合
具體的意圖操控協議
以獨角獸快信爲例我們想支持INSendMessageIntent
那當任何時候我們傳遞一個INSendMessageIntent的實例
我們將返回一個符合INSendMessageIntent操控協議的handler
現在我們已經討論過了所有的三個步驟
接下來讓我們根據以上的步驟將獨角獸快信在Xcode裏打開
這裏有我們已經在Xcode裏打開了的獨角獸快信項目
時間關係 我已創建好了意圖擴展
讓我們直接來看一下第二步
設置Info.plist
首先 讓我們將它放大些那樣可以看得更清楚
好的
在這裏我們看見NSExtension字典
如果我們將它展開 你會看到NSExtensionAttributes字典
如果我們進一步地展開這個字典
你會看見那兩個我們之前介紹的新關鍵值
IntentsSupported和IntentsRestricted WhileLocked
首先 爲了支持INSentMessageIntent
在IntentSupported數組下添加一個項目
我們加入意圖類的名字
INSendMessageIntent
然後 讓我們看一下鎖屏狀態的行爲
因爲獨角獸快信是一款聊天應用
被用於獨角獸之間的私密交流
獨角獸們很注重隱私
所以 我們決定將它鎖定
用戶需要先將設備解鎖
才能通過Siri發送獨角獸快信消息
爲達到效果 我們將在IntentRestrictedWhileLocked的數組下添加一個項目
同樣的 添加意圖類的名字
INSendMessageIntent
這樣我們就完成了對擴展的Info.plist的設置
在第三個步驟裏我們看看擴展的principal類
當你們創建意圖擴展 target時
一個principal類會被自動地創建
我重命名了我的principal類爲UCIntentHandler
它是INExtension一個子類
這裏我們還有意圖方法的handler
你可以看到默認的實現返回self
它返回一個principal類本身的實例
但爲了讓我們的代碼更清晰
更容易被擴張
如果我們想將來讓這個擴展支持更多的意圖
那我們要創建一個獨立的intent handler類
我們現在就建立這個類
通過創建一個新的文件
取名爲UCSentMessageIntentHandler
我們也將導入一些框架然後加入一些類別的聲明
這裏我們導入意圖框架
它包含許多SiriKit API
我們也將UnicornCore框架導入
那是我們創建的embeddedframework
通過在應用與擴展之間分享代碼
這就是我們的UCSentMessage IntentHandler類
它符合INSentMessage IntentHandling協議
好的現在然我們回到principal類
取代這裏現有的實現
讓它爲傳遞進來的意圖返回一個UCSentMessageIntentHandler的實例
類型僅限爲INSentMessageIntent
至於其它的意圖我們將返回nil
大功告成
我們的三個步驟
用來添加和設置你們的第一個意圖擴展
現在讓我們來看一下應用邏輯
希望從SiriKit的簡介部分
和Vineet的重述
意圖擴展和Siri的互動會被分成三個階段
解析和確認還有處理
讓我們先來聊一下解析
在解析階段你要確認
和理清每一個意圖參數值
所以 我們給每一個意圖的參數提供了
解析方法在意圖操控協議裏
那你們或許會問我們應該實現它們之間的哪一個？
試想
你是否需要在Siri的幫助下獲取
意圖參數值的最終值？
如果回答是
那你或許應該要實現這個參數的解析方法
讓我們來看一下獨角獸快信的例子
發送消息時 我們需要收件人
爲了決定最終收件人的值
我們需要在獨角獸快信地址簿裏查詢聯繫人
查詢結果可能是多樣的
在最簡單的情況下
我們只找到一個聯繫人
任務完成
然而 也有可能我們找到兩個或多個聯繫人
在這樣的情況下 將會很便捷
如果Siri能幫助詢問用戶從候選名單裏挑出聯繫人
同樣也有可能我們沒有找到任何聯繫人
在這個情況下我們也想讓Siri告知用戶
那樣用戶或許會選一個其它的收件人
在選好了一個收件人之後我們還需要關聯的信息
在這個情況下我們只需要獲取一個值來繼續
如果用戶沒能提供關聯的信息
那我們希望Siri能幫助詢問關聯的信息
考慮到以上所有情況
聽起來好像 我們應該要爲收件人和信息實現解析方法
我們的確需要通過Siri的幫助從用戶那取得進一步的輸入
才能最終決定這些參數的最後的值
現在參數已經成功地決定了
我們到了確認階段
在這個階段你們有必要做一下情景模擬
試想若你們正在操控這個意圖
你們是否有了所有需要的信息？
或者 你們是否能夠成功地操控它？
你們要得到問題的答案外加一些額外的信息
你們可收集這些信息在爲Siri的意圖做準備同時
那樣Siri纔會適時地
傳達這些信息給用戶
最終用戶才能做出相應的決定
關於是否想繼續他們的活動
在獨角獸快信裏
由於我們的安全要求
我們需要用戶時不時地重新驗證身份
所以確認是最合適的階段
讓我們檢驗用戶的身份狀態
不管如何 我們都想告訴Siri狀態檢驗的結果
這樣Siri就可以讓用戶在Siri內部繼續
或許調出應用結束本次Siri操作
好的現在意圖也已經被確認
我們來到了最後階段操控它
但願這是簡單直接的 對你們來說最好理解的階段
你只需執行行動然後告訴Siri結果
在獨角獸快信裏
我們就只要發送消息
然後 報告消息是否被成功發送
講瞭解析和確認還有處理方法與有關的概念
讓我們用Xcode實現它們
這次我們將直接從IntentHandler類開始
在開始之前 一個提醒
所有這些簡單的代碼都會上傳
如果我跳過一些細節那或許意味着
對於你們 那部分代碼相對來說沒那麼重要
目前 無需看懂那部分的每行代碼
但如果你們感興趣你們一直都可以回到網上
然後自己查閱這簡單的項目
好的
像之前所提及的
我們將實現解析和確認和處理方法
我們將爲收件人和信息實現解析方法
讓我們從resolveRecipients入手
在這個方法裏我們要注意recipients這個參數
它由一個INPerson的數組代表
你們也可以從這個方法的簽名看出
你們需要使用這一個數組的解決結果進行回調
所以 有一個一一對應的映射關係
在recipients數組與解決結果數組之間
這意味着爲每一個收件人 你們要創建一個PersonResolutionResult
這裏唯一的特例是
當你想創建ResolutionResultNeedsValue
或ResolutionResultNotRequired的時候
這兩類型的resolutionResults
是在參數層面的解析 而其他的resolutionResults
是更多的注重於個別參數值
那在這個方法裏首先我們要
試着打開Recipients對象
然後我們將循環依次獲取每一個收件人
然後調出在UnicornCore框架裏的 API
根據名字尋找相應的聯繫人
接下來我們將用一個switch語句在覈對查找聯繫人的數量上
如之前所提到的我們將考慮不同的查找情況
兩個或多個相符的聯繫人
只有一個相符的聯繫人
沒有相符的聯繫人
如果我們找到了兩個或更多的聯繫人
我們將創建一個PersonResolutionResult.disambiguation
用我們所找到的結果
如果我們只找到了一個聯繫人
我們就可以繼續
我們可以告訴Siri通過創建一個PersonResolutionResult.success
用那一個我們找到的人
如果我們沒有找到聯繫人
我們將創建一個PersonResolutionResult.unsupported
我們switch語句在此結束
你們或許感覺到我講解這些代碼的速度很快
以至於你沒有機會讀每一行代碼
那沒有什麼問題
因爲只要你能明白
我們有不同的resolutionResults
它們適用於不同的情況
當你們自己爲結果方法實現你們的代碼邏輯
你們可以上網查閱關於resolutionResults的資料
完整的關於resolutionResults的列表
然後還有它們的用途
好的
現在我們有了所有的resolutionResults
那些我們爲recipients所創建的
至此 我們完成了對resolutionResults數組的構建
這樣我們也就完成了最後一行代碼給在我們能
從意圖獲取一些收件人的情況
但在如果用戶根本沒有收件人
那我們將創建一個PersonResolution Result.needsValue
然後結束流程 告訴Siri請提示用戶輸入收件人
以上就是我們result recipients的方法
接下來 我們來實現resolveContent方法
我將檢查值是否存在
如果不存在
我們指示Siri請幫助我們提示用戶
我們在resolveContent裏首先做的
還是試着拆包這個content屬性
然後查看它是否真的不爲空
如果content確實已經給定
建立ResolutionResult.success
通過已有的content
否則 我們就創建ResolutionResult.needsValue
就像我們在之前那個解析方法裏做的一樣
並以它爲參數調用completion函數
現在我們兩個解析方法都已經領略了
下面我們來看確認方法
我們用它來查看用戶的認證狀態
在確認方法裏
我們就調用Unicorn Core framework裏的shared API來查看
用戶是否還有有效的認證狀態
如果他/她有的話
那我們就創建一個INSentMessageIntentResponse
其code參數爲success而userActivity參數是nil
我一會兒會講解怎麼用這個userActivity
不過我們先來看這個情況
用戶不再是已認證的狀態
在這種情況下 我們就創建一個IntentResponse
code是.failureRequiringAppLaunch
所以這就是要告訴SiriSiri應該提供一個選項
讓用戶可以進入到我們的主應用
來登錄並完成這個發送操作
好的 以上這些就是我們的確認方法
最後 我們一起來實現處理方法
在處理裏我們就調用
UnicornCore框架裏的shared API
來用給定的content和recipients發送信息
我們還要獲取發送操作的狀態
如果信息成功發送
創建一IntentResponse並以success作爲code參數
否則就以failure作爲code參數來創建response對象
調用completion並賦給它IntentResponse
至此 我們一起討論瞭解析確認和處理方法
現在我履行之前的承諾來講解NSUserActivity
那些IntentResponse的初始化方法會用到它
我們暫時先拋開Xcode
說到NSUserActivity
在SiriKit的背景下
NSUserActivity被用來幫你的應用恢復狀態
用於它被Siri或者用戶啓用的時候
默認情況下 Siri會給你創建一個NSUserActivity
這是在你決定把nil賦給IntentResponse的初始化方法時的情況
並且 Siri在創建它時會以ActivityType作爲intent的類名
你還可以選擇用你自己的UserActivity
比如你想要加入一些自定義數據
但不論如何 Siri都會將INInteraction屬性設定
在NSUserActivity對象上
這個屬性是在iOS X裏新引進的
而且這個對象有意圖IntentResponse
還有意圖處理的狀態
Scott一會兒會更詳細講這個對象
現在我們再來看看NSUserActivity在我們程序裏的用法
如果你比較細心地看了這段程序的話
你可能會發現在確認和處理方法裏
我們一直把nil
作爲userActivity參數賦給我們的IntentResponse初始化方法
這樣做完全沒問題
這是在假設我們的主應用會處理UserActivity的情況下
就是Siri用INInteraction對象幫我們創建的UserActivity
不過在一些情況下 比較有用的做法是
給我們的應用加入一些擴展過程中的自定義字符串
比如說
在確認方法裏
當我們發現用戶不再是已登錄或已認證的狀態時
我們便需要將一些顯示錯誤的字符串加入到我們的主應用裏
具體做法是我們創建自己的userActivity
並在.userInfo字典裏設定
我們想要給我們主應用加入的顯示錯誤的自定義字符串
然後我們把nil刪掉 取而代之的是userActivity
就是我們剛創建的那個
好的 很好
所以現在我的獨角獸快信主應用有了
這些顯示錯誤的自定義字符串並且會提示用戶登錄
這是在用戶或者Siri此時要啓動應用的情況下
現在我們完成了意圖擴展的所有編程
我們來看看它真正在設備上運行的效果
用獨角獸快信給Scott發一條短信
說你準備好你的演示了嗎
沒錯
好的謝謝
是的 這個非常振奮人心
我們剛用Siri發送了第一條獨角獸快信信息
這絕對是棒棒噠
謝謝
不過 在獨角獸快信的主應用裏
當我給我的獨角獸小夥伴們發短信時
我會經常用他們的獨角獸暱稱
所以我實際上想跟Siri說
給Sparkle Sparkly發一條短信說你準備好演講了嗎
顯然Sparkle Sparkly是Scott的獨角獸暱稱
要實現這個功能我們就要進入我們下一個話題
就是用戶特定詞彙
是的
用戶特定詞彙
那麼
這是一些自定義單詞或短語它們對於你的應用獨一無二
並且因人而異
在我剛給的例子中
Sparkle Sparkly以及其他獨角獸暱稱
在這兒都可以作爲用戶特定詞彙
而要讓Siri理解用戶
所說的這些自定義詞彙
你需要把它們提供給Siri
你要從你的主應用調用INVocabulary API
我重複一遍
你要調用INVocabulary API
從你的主應用裏調用而不是從你的擴展裏調用
好我們來看看我們在獨角獸快信怎麼做到的
在獨角獸快信裏我們有UCAddressBookManager
它管理獨角獸快信自己的聯繫記錄
而我們創建了這個方法
來更新Siri讓Siri知道獨角獸暱稱
而一旦哪個聯繫記錄被添加 刪除或更新時 這個方法就會被調用
在這個方法裏我們首先想做的是
獲得一個排好序的獨角獸暱稱列表
並且 我們把更重要的獨角獸暱稱列在前面
把相對不重要的放在列表後面
像這樣優先處理 我們就能幫Siri
更好地對獨角獸暱稱進行優先學習和配對處理
在整理好這個獨角獸暱稱的有序列表後
我們調用INVocabularyAPI來把它們提供給Siri
我們還要給它提供這些字符串的詞彙類別
在這個例子裏獨角獸暱稱的類別是Type.contentName
關於這段程序 我想最後提一點讓你們注意
就是我們要將所有這些操作分派到不同的任務隊列裏
這是因爲像獲取你整個聯繫列表這樣的操作
會特別昂貴而你不想因爲這個來阻礙你的主線程
所以請務必用GCD
分派這些昂貴的操作到不同的任務隊列
好的
現在 在我們採用了用戶特定詞彙API後
我可以發信息給Sparkle Sparkly和Celestra
還有Buttercup以及我所有的獨角獸小夥伴們
這絕對是棒棒噠
現在我又有另外一個功能請求
在獨角獸快信裏
這個應用的畫風
實際上比你在Siri這兒看到的還要五彩斑斕 像彩虹一樣
那麼 我能讓我在Siri裏的獨角獸快信體驗
和在獨角獸快信主應用裏的一樣色彩繽紛嗎
關於這個話題 我現在邀請我的隊友
Scott也就是Sparkle Sparkly上臺
下午好
我是Scott AndrusSiriKit的工程師
現在我們來講講如何讓這個過程
感覺更像是跟獨角獸快信互動
要做到這一點我們要用SiriKit來建立一個用戶界面擴展
在iOS X裏 我們引進了意圖用戶界面擴展點
它能讓你創建很讚的用戶界面擴展
來在Siri體驗裏提供自定義的用戶界面
那麼 讓我們開始吧
你可能想這麼做的原因是
用戶界面擴展能增加你的應用對用戶的影響
通過引入一個用戶界面擴展
你可以在Siri體驗的基礎上展示你的視圖
然後 你可以融入自定義的體驗
這些體驗相對Siri通常顯示而言對你的應用更爲獨特
這會給開發你的應用帶來很多很好的機會
這些機會具有獨特性能讓你的應用脫穎而出
你還可以提供用戶定製
讓你可以跟用戶一對一互動
最後 你可以顯示Siri不會顯示的信息
這是你的工具庫裏很好的幫手
還有 它長這個樣兒
那麼首先 你要做的就是添加一個意圖用戶界面擴展
把它加到你的項目裏
並把它嵌入你應用的包裹裏
你便會看到Xcode給你生成的Info.plist文件
在裏面 你需要找到新的IntentsSupported關鍵詞
和你在意圖擴展看到的類似
在裏面 你要設置一個意圖
用它來在Siri體驗中展示自定義的用戶界面
用戶界面擴展在SiriKit中的結構其實很簡單
SiriKit針對你的用戶界面擴展
用互動配置
這個SiriKit 用戶界面擴展裏很關鍵的方法
你的用戶界面擴展有一個主要類
它是UIViewController遵循INUIHostedViewControlling協議
它會將一個INInteraction對象
在配置這一步賦給你的用戶界面擴展
現正如Diana提到的那樣
INInteraction類定義一個對象
它涵蓋三個重要的屬性
第一個是意圖對象它要經過確認
或者被你的意圖擴展處理
第二個屬性就是
Intent response對象你的意圖擴展把它傳給Siri 通過
確認和處理的completion
最後一個屬性是意圖處理狀態一個enum值
它描述互動的狀態
是你的應用和Siri間的互動
這些實現起來都是非常有用的屬性
對你給Siri製作用戶界面很有幫助
你的視圖控制器是操縱用戶界面擴展的途徑 它作爲一個主要類
你要用到它來創建你的用戶界面它作爲
UIViewController子類
你就可以用你可能習慣用的所有UIKit的強大功能
就像創建Cocoa Touch應用的用戶界面一樣
接着 用“互動”對象給它配置
對象由Siri經“互動配置”傳給你
此外 還有別的一些參數
在這個方法裏可能值得你注意
其中一個是providedViewContext參數
而在iOS X裏 這是一個enum值它在兩個可能值中取其一
Siri snippet或maps card
所以你可以給你的界面進行不同的配置
針對這些模態視圖跟用戶間不同的互動方式
而且如果你要做一個訂車擴展這個會對你很有幫助
最後
你會有一個completion你調用它來讓Siri知道
你已經完成對用戶界面的配置
你要返回一個desiredSize
告訴Siri怎樣在Sirisnippet調節視圖的大小
我想我們已經知道所有要知道的東西
示範如何給獨角獸快信建立一個SiriKit 用戶界面擴展
好
我們回到Diana給我們鋪墊的這個很棒的項目
項目用到了我們的Siri擴展它讓我們能將應用嵌入Siri體驗中
我們在意圖用戶界面擴展上更進一步
當Diana創建她的Siri擴展對象時
我們可以配套創建一個意圖用戶界面擴展對象
Xcode建了個分組專門在左邊這兒的
項目導航器建給Siri用戶界面擴展
我們打開它
可看到一些很讚的文件讓我們能開始編意圖用戶界面擴展
首先是IntentViewController類
它是我們擴展的主要類
還有給這個類的storyboard
以及Info.plist我們先來研究這個
用它來設定我們支持的意圖
在這裏面
NSExtension字典裏有個IntentsSupported列表
我直接在這兒加一個條目
現在 關於意圖用戶界面擴餐我們想做的
是在Siri顯示結果時給用戶展示一個用戶界面
用來給其他獨角獸發信息
而當顯示這個界面時
我們希望它是一個聊天記錄界面
希望它能彰顯我們應用的“獨角獸性質”
所以在這裏面 我要給INSendMessageIntent添加支持
聲明我們要展示一個用戶界面
在Siri給我們的應用處理意圖時顯示
好 編好Info.plist後
我們來實現IntentViewController
我縮小頁面回來
這兒有我們的IntentViewController類
注意到這是一個UIViewController的子類
遵循INUIHostedViewControlling協議
既然遵循協議就要相應地對它進行配置
要用“互動”這兒程序把它作爲模塊提供給我
現在我首先要做的
是把UnicornCore框架作爲模塊導入我的Swift文件
值得重申的是這個UnicornCore框架
是我們給我們應用實現的框架
所有獨角獸應用都用到它如Unicorn Pay或Unicorn Rides
這是給我們的應用和擴展共享程序的很好的方法
我們在Diana的演示中已經很好地用了它來共享
擴展中解析 確認和處理的業務邏輯
現在我們想用它來共享用戶界面
針對我們的用戶界面擴展和應用
以此達到我們會有熟悉感覺的效果
不論我們在哪兒發送獨角獸快信信息
我們來開始實現“互動配置”方法
在這裏面
我直接設置一個size變量
一旦我完成配置後就把它返回給Siri
現在我要查看interaction.representsSendMessageIntent是否爲真
這兒的用法很方便因爲我已把它實現爲類擴展
以UnicornCore framework裏的INinteraction爲基礎
然後 我建一個chatViewController實例
我們用它來代表一個信息發送界面
我們兩個獨角獸快信應用都用上
而且我們也要在我們的用戶界面擴展這兒使用
我們來配置chatViewController
用“配置”的messageContent
我還是用類擴展從“互動”中獲取它
建一個UCContact模型對象
它基於“互動”的屬性
接着 我把模型對象賦給chatViewController
來顯示信息的收件人
最後 我用switch語句
判斷“互動”的intentHandlingStatus
我們可以以此對我們的用戶界面進行不同的配置
以信息是否已經發送出去作爲基礎
比如在這個例子中如果信息未發送
即intentHandlingStatus是unspecified inProgress或ready
就把chatViewController的isSent設爲假
這說明我應該設定一個草稿式界面顯示給用戶
否則 如果發送已經完成我可以將isSent
在chatViewController裏設爲真
表明我已經發了信息而且要讓用戶也知道
最後我就呈現chatViewController它是一個子控制器
其母控制器是這個IntentViewController主要類
這是一個很有用的方法
來實現不同的視圖控制器
針對我用戶界面擴展裏的不同意圖
最後
我可以用iOS X裏用戶界面擴展的NSExtensionContext
來得到一個最大的大小
然後我默認地把它用在我的獨角獸快信裏
如因某些原因得不到extensionContext
我就用chatViewController的desiredSize
它對我來說夠好了
這是比較樂觀的一種情形
假如什麼出了錯給我們意想不到的“互動”
我們可以設大小爲0
讓Siri不要在Siri snippet裏畫我們用戶界面擴展的視圖
好
我最後要做的
是告訴Siri我已經完成實現
和配置我的用戶界面
這樣它就會在Sirisnippet裏給我們展示
好
我有這段程序的一個版本在我的設備上運行
我們現在來看看它是怎麼樣的
你可以看到我有獨角獸快信應用
我準備發信息給Diana
用獨角獸快信發信息給Diana說
“你的演示很棒！”
於是我們這兒有一個很棒的自定義用戶界面
但你還會注意到有些東西不太對
我們現在來看看是怎麼回事
我們剛給你們展示了
如何用SiriKit構建你的用戶界面擴展
這非常好
但你會意識到
有些東西還是有點不妥
特別是我們在Siri展示給用戶的用戶界面
於是我們弄了一個複製版聊天記錄界面
在Siri snippet裏展示
默認地 Siri對不同意圖都顯示用戶界面
如SentMessageIntent
剛用它在獨角獸快信給Diana發了信息
同理 對於我們的獨角獸快信用戶 我們想做的
是真正展示我們的自定義用戶界面
讓用戶們對“獨角獸性質”比較好的感覺
就在他們用獨角獸快信發信息時
我們在iOS X可以做到這一點用一個可選的新協議
通過實現INUIHostedViewSiriProviding協議
你可以讓Siri知道
你在把信息還是地圖畫在
你的用戶界面擴展視圖
所以你可以選擇顯示
不同的特定內容到你的用戶界面上
並代替Siri操控這個界面
最後 當你這麼做了
Siri便會調節你視圖的內容
所以你要確認畫出來的這些屬性準確
代表了用戶意願
我們來看IntentViewController
我們剛在我們的用戶界面擴展裏用了它
你可以在這兒看到
如果我們實現INUIHostedViewSiriProviding協議
我們就可以實現displaysMessage屬性並返回真值
告訴Siri我們正在獨角獸快信顯示信息內容
而這就是實現你自己的用戶界面所需要的一切
在Siri裏面
我們來看看這個在設備上運行的效果
我設備上有這個應用的一個一模一樣的版本
我們回到我的設備上
我們來發另一條信息給Diana
用獨角獸快信發信息給Diana說
“用獨角獸的蹄子很難打演示的代碼”
現在我們看到跟我們預期一模一樣的界面
也跟我們想展示給用戶的一樣
我們的界面不會被Siri默認顯示的界面所阻礙
這給我們一個很好的窗口來展示一個自定義的用戶界面
來真正反映我們應用的“獨角獸性質”的畫風
現在 我最後分享一些點子
在我們今天離開之前再談談用戶界面擴展
我想首先留給你們的
是你對待用戶界面擴展時應注意考慮存儲量
因爲擴展是默認爲暫時性的
僅僅在很短時間內展示給用戶
所以系統有一個強制的比較低的存儲量限制
比你在你一般的應用裏可能習慣的存儲量還要低
所以像MKMapView這樣的視圖用起來特別耗存儲量
在建立你的用戶界面擴展時你們要謹慎地使用這些視圖
正如我們所看到的我們可以獲得最小和最大的視圖大小
在用戶界面擴展裏通過NSExtensionContext獲得
這會對你特別有用特別是當你設計你的應用
而你的用戶界面擴展要在很多不同大小的配置下顯示的時候
但你返回給Siri的desiredSize正是你想要的
你想要的大小
所以 如果你要用不同的佈局
你要確保你的程序有很強的適應性
無論如何它的外觀都不錯不管大小是最小
還是最大不管Siri怎麼畫它
總之 我們看到了幾個關鍵點
關於延伸我們的應用來適應SiriKit
而首先要做的就是妥當地準備好你的應用
通過很好地利用共享的程序
比如嵌入框架還有實現單元測試
來正確地測試 Siri可能傳給我們的不同的意圖
並且規劃好我們的應用來使用合適數量的擴展
我們解決了添加第一個意圖擴展的問題
並實現瞭解析確認和處理的業務邏輯
它讓我們的應用跟Siri實現很好的對接
最後 我們展示瞭如何在Siri裏提供一個用戶界面
來將我們應用自定義的獨特體驗融入到Siri體驗之中
我們這個展示會的樣本代碼
以及關於SiriKit的幻燈片和一些很棒的參考文檔
都會公佈在我們的網站上
而且我們昨天也有一個很棒的會
叫“SiriKit入門”
我們談了我們對SiriKit的期望以及如何將它融入iOS
我們也有關於應用擴展最佳實踐的一個很棒的會
是WWDC 2015裏的會我強烈推薦你們去看
特別是如果你想實現SiriKit擴展
我希望你會覺得實現你的SiriKit擴展
及你的應用能像我們實現獨角獸快信一樣簡單有趣
謝謝