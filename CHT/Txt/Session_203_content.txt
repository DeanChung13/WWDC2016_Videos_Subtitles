Cocoa的新特性
上午好
我叫Ali Ozer
我和我的同事們
謝謝
我和我的同事Raleigh Ledet還有Taylor Kelly
來自Cocoa框架團隊將給大家講講
今年Cocoa的新特性
我們的議程非常簡單
首先 繼AppKit和Foundation新特性
之後的API更新
關於API更新方面我想跟大家講講
我們主要有兩類API更新
第一 由於新Swift API指南導致的API更新
第二 我們做的一些常用API改良
讓我們開始吧
無論你昨天是否聽過
今天上午 我們有關於Swift新API設計指南
並且這些指南包含Cocoa約定和實踐
我不過是要提醒你這些東西是什麼
使用清晰和一致性命名
追求流暢的使用大家都知道 調用的地方讀起來
應該像英文短句命名增強
和不可變方法保持對應一致sort與sorted
append與appending還有避免縮寫
這些都是我們多年來使用的主要指南
我們把它寫成文檔
在以前WWDC大會上我們也講過
正如這次演講你看到的一樣
現在我們把這些指南做了更新
使用了Swift的特性 比如強類型
類型推斷 還有重載
並且確保我們的API在Swift中能表現出來
我來講下API中的一些關鍵不同點
由於這些改變的結果
一方面 我們消除了重複和不必要的單詞
顯然使我們的API更加敏捷
你昨天可能聽了
昨天有個例子
如Chris Lattner關於“詳情諮文”的部分
這裏有另外一個例子contacts.arrayByAddingObject
比如這樣的一個方法調用“數組”和
“對象”並不能真實反應這個調用
所以這個名字現在改成了contacts.adding(person)
在NSColor這個類上還有另外一個例子
NSColor.blueColor我們現在NSColor類上
Blue已經是一個顏色了
color這個單詞其實在這調用中不需添加
所以在新的指南中
它將變成NSColor.blue
不過需要注意的是我們仍然追求清晰
這是NSColor另一方法NSColor.textColor
文本本質上不是一個顏色其實
談論文本的顏色可能會產生混亂
文本是代表顏色的RGB值還是其它的？
所以在此案例中 我們沒改變這個方法
還是作爲NSColor.textColor
跟它之前一樣
另外一些關鍵變化是類型的利用
這裏有個例子document.readFromURL ofType
現在這個API將變成document.readFrom ofType
你會注意到我們移除了這個單詞... URL
從我們的方法簽名中
那是因爲第一個參數的類型就是URL
根據類型推斷Swift知道該如何去處理它
通過移除這個單詞
其實在NSDocument上現有三個閱讀方法
他們都準確的命名了同樣一件事從ofType讀取
並且它是作爲第一個參數第一個參數的類型
URL 數據或者FileWrapper
把它們區分開來
現在這需要注意的一件事情就是利用
第一個參數
這裏從此以後就被拉到了括號內
我們這樣做是基於大量的案例
例如 當第一個參數表現成介詞短語的一部分時
我們會把這個短語拉到括號內正如你這看到的一樣
你可以從我們的API中看到大量這樣的例子
可能大家也注意到第二個參數ofType
我們並沒有把類型這個單詞從API中移除
因爲這個參數是一個字符串而且字符串是弱類型
我們其實要一個單詞來描述它們的角色
而這裏的角色就是我們打開的文件類型
所以我們在API中保留了類型這個單詞
現在很多框架和標準庫API都被改變了
基於這些新的指南
並且把Objective-CAPI映射到
Swift的輸入者也使用了這些新指南
不過你可能會注意到有些API還需要進一步調教
我們已在些API中做了如textColor API
前面提到過的它是一個例外
若你在Swift中暴露Objective-C API
你可能需要使用一些
像NS Swift Name它可以讓你覆蓋默認的
輸入者做的事情
大家知道移植器轉換你的——
移植器可將你現有Swift 2代碼
轉換成Swift 3並且它還會幫你使用這些新命名
在你現有的代碼中 當然
Swift API設計指南討論
在此之前你可以
從視頻中獲取一些細節
關於這些指南和它們的影響
現在我們已經有很多常用的API改良
有些我們已經完成有一段時間了有些我們還將繼續做
我們來快速過一下
可空性
去年我們已經在這方面做了很多
它通常用來聲明是否有參數返回值
屬性可以爲空或者是否可選
今年我們一直在持續完善它
例如 該方法在10.11版本中標明
返回一個可選值
NSMenu中的addItem方法但在10.12版本中 它並沒有標明
返回一個非可選值因爲我們決定
它永遠無法真正返回空值而且
最好由你的代碼來反應出來更爲適當
當然 也更簡單一點
我們一直在改進屬性把getter和setter對
轉換成正規屬性
今年我們同樣在實際中使用了Swift的能力
來聲明類中的屬性
例如 這是NSWindow中的一個新屬性
你會在後面的演講中聽到這個
allowsAutomaticWindowTabbing
這是在Swift中一個真實類中的屬性
你還會注意到我們同樣有能力
在Objective-C中做到這樣
在Objective-C中你也可定義類屬性
使用語法@property class
同樣特性引入到了Objective-C中
這確實很酷
這有個Core Data的例子NSPersistentStoreCoordinator
在10.11版本中 它有這個方法registeredStoreTypes
現在它被定義成了類的屬性
它是一個只讀屬性
所以它只有get方法正如你這裏看到的一樣
同樣在Objective-C它也變成了類的屬性 如你看到的一樣
泛型我們把它應用到了
集合類中不過它們真的
不僅用於集合
它們還用於其它任何地方
我敢肯定 你已經意識到了
這裏有一個Core DataNSFetchRequest的例子
這裏是10.11版本中定義的方式非常簡單
在10.12中 我們前進了一步
添加了一個ResultType類型參數
我們同樣在其它一些API中添加了一些東西
如這execute方法
返回一個這種結果類型的數組
因此 這個用例現在就變成這個樣了
你從一個管理對象獲得請求
比如員工
然後往前繼續執行它
現在返回值被自動推斷爲
一個員工數組
現在這個例子會是這樣不過我們希望
在將來的版本中我們可以像這樣表達得更乾淨
這確實很酷
所以從這兩行編譯器可以推斷
返回類型是一個被管理了的對象數組
我們一直在改進枚舉命名
來看一個我們在這方面已實施的例子NSColorPanelMode
變化是——這是一個Swift用例
你看它並非很吸引人
是因爲.NSCrayonModeColorPanel非常冗長
變化就是我們把通用後綴拉到前面
變成前綴使得Swift裏的名字
更清晰一點
你知道 出現這點的地方
用例就是.crayon
這是它之前的樣子
這是它現在的樣子 相當清晰
在枚舉這一塊
我們同樣對字符串枚舉做了改進
Swift支持字符串值的枚舉
許多Cocoa API都會暴露一組字符串
無論打開或者關閉的API在我們的API中
我們來看一個字符串轉換的例子
在Swift 2中我們有一堆全局常量
NSStringTransformLatinToGreek等等
有一個APIstringByApplyingTransform
把這些字符串作爲它的第一個參數
在Swift 3中我們添加了一種新類型
叫StringTransform還有一個擴展我們給它定義多種值
比如LatinToGreek
有API叫applyingTransform
它第一個參數現在是官方的StringTransform
所以這個字符串參數現在是StringTransform
類型更加安全
現在 注意這裏有一個開放式枚舉
這裏面你可以定義你自己的值
我演示下如何做到這點
你可以繼續添加一個擴展
到StringTransform然後定義你自己的類型
現在這裏的值就是ICU庫接受的值
用於做轉換
你可以使用任何有效的ICU提供的ID
它轉換成一個ICU擁有的需要出版的東西
這些我們API中並不暴露
所以 你可以定義你自己的出版轉換
然後把它傳給API如果它是一個內置的
字符串枚舉同樣在Objective-C可以使用
通過使用這兩個宏給開放或者封閉式的集合
這是添加字符串轉換聲明的方式
在10.11中 那是我們已有的方式
在10.12中 有一個新字符串轉換類型
被定義成NS ExtensibleString Enum
我們同樣使用了Swift能力來改進
在一個類型中嵌套聲明另一種類型
看一個NSData的例子
我們有一個可選的集合NSDataWritingOptions
NSData類有一個APIwriteToURL使用了這個值
在Swift 3中它變成NSData類
嵌套了WritingOptions如你在此所見
使用這個API實際上是指向
WritingOptions顯然是更加清晰更好作用域
除了這些嵌套的改變你可能注意到一些其它的東西
那就是類型的變化
你可能注意到我們現在提供了一個空集合默認值
大多數我們需要傳入可選值時
意味着我們不在需要傳入可選參數了
你可能還注意到這裏NSURL變成了URL
你可能已聽過這個了
不過我們後面還會有關於它的更多談論
現在 我離開舞臺前的最後一個主題是...
noescape
好的 noescape聲明
一個閉包的執行在函數調用後將不會退出
我的意思是什麼？
這裏有一個NSCollection view的方法performBatchUpdates
它有兩個閉包參數
你可能注意到了第一個參數標記爲noescape
意思是這個閉包的執行
將完成執行
在API performBatchUpdates方法返回之前
第二個參數沒有標記爲noescape
意思是這個閉包的執行將可能發生在
函數返回之後
所以 這對你來說是一個好的暗示
同樣對編譯器也是一個好的暗示
這個技巧同樣適用於Objective-C
我們可以使用NS NOESCAPE來裝飾閉包
以達到同樣的效果
這些就是我們常用API變化的概覽
現在大家擁有的版本中
我們已完成了所有想要做的事情
將會有一些字符串枚舉變化
類屬性變化將會在其它版本中出現
我們將會應用到更多的API中
接着我們來談談關於AppKit
我將給大家邀請RaleighLedet上臺給大家講講
謝謝
謝謝 Ali
大家 上午好
大家看到 在過去的一年裏我們在AppKit上下了很多功夫
現在我們深入一下來講講窗口捕捉
當你在macOS Sierra下拖動一個窗口
當你靠向一個邊緣的時候將產生邊緣粘連
還有與另外一個窗口的頂部對齊
甚至是在縮放大小的時候
所以現在將窗口對齊就簡單多了
或者以你想要的方式來縮放大小
我們付出很多努力在這裏提供摸索
來確保我們只提供捕捉行爲
第一時間推測你想對窗口做些什麼
在你的應用中獲取捕捉行爲的方式就是
讓系統來爲你處理窗口的拖拽
如果你自己跟蹤鼠標
然後手動控制窗口的位置
你將會繞開窗口捕捉我們會恰當地放置窗口
在這裏你要求我們放置它正如我們之前的發佈
如在keynote上看到的我們現有了窗口tabbing
這是一個TextEdit的例子有三個文檔tab打開
關於窗口tabbing其實他們就是多個窗口
所以此例中有三個tab的TextEdit
其實就是三個不同NS窗口支持
所以我們做的只是對這些當中的每一個窗口
只將一個tab設置可見就認爲是可見
若你檢查NSWindow的.visible屬性
它將返回真
只不過僅有可見的tab才正真被渲染到屏幕上
我們將其它窗口隱藏到窗口服務器級別
所以它們沒有被渲染也不佔用任何資源
而且我們自動處理這些過程
那如何給窗口添加一個New Tab呢？
創建一個新的窗口然後將它排到前面
然後我們將會繼續恰當地爲你創建一個tab
然後放置在窗口中
如果你要移除一個tab將你的窗口過濾掉
然後我們將繼續爲你移除掉tab
這些都是自動玩完成的
現在如果用戶縮放了窗口我們將僅僅
縮放與當前激活的tab相關聯的窗口
我們不會花費時間
去處理其它窗口當用戶並不想切換到它們的時候
不過當用戶要切換到其它tab中的某一個時
在那時AppKit將會繼續
適當的縮放窗口重新渲染它
然後將窗口服務器等級的隱藏屬性修改
所以用戶得到的是無縫的體驗
一個窗口擁有多個tab儘管在這背後
我們只是處理了三個窗口
我想談一些大家需要做的東西
當你準備給你的應用採取tab
這依賴於你的應用
是什麼類型
如果你有一個例如類似基於NSDocument一樣的應用
或者non-NSDocument的應用
你需要做些什麼
如果你已經存在一個tab實現
我講圍繞這一節來講解用一些大家可以使用的API
在你的應用中去定製tab
若是基於NSDocument的應用你不需要做什麼
這基本上是自動的其實此處TextEdit
我們幾乎完全是修改了0行代碼在TextEdit上
它完全支持標籤而且在這個方框下運行的非常正確
若是基於non-NSDocument的應用它大部分是自動的
不過你可能需要做的是開啓
New Tab按鈕在你的應用裏
New Tab按鈕在這裏是一個附加的按鈕
在所有tab的右邊
要開啓這個按鈕 你需要實現newWindowForTab NSResponder
在你的NSWindow子類中重寫
或者在響應鏈中某個更高的地方
例如NSWindow代理
或者NSWindow控制器或者NSWindow文檔
如果你在其中任何一個地方實現了重寫
AppKit將會看到它並且將繼續
自動爲你開啓New Tab按鈕
如果你有自己已存在的tab實現
你可能需要禁用
AppKit的自動窗口tabbing行爲
這裏是這個類的屬性
NSWindow的allowsAutomaticWindowTabbing
這是一個類屬性在你的應用啓動之初
叫做NSWindow
allowsAutomaticWindowTabbing等於假
這裏將關閉AppKit的tabbing行爲
然後你將可以繼續使用你自己的tabbing實現了
這裏非常重要你需要在應用啓動
且開始將窗口展示出來前調用它
你只需要在你的應用中添加tab支持
它大多數情況下是自動工作的
不過這裏有些API你可以用來自定義一些事情
首先 用戶可以定義一些行爲
指定在系統中他們想要的tabbing方式
且他們可以在系統設置中來這麼做
你獲取用戶設置
通過在NSWindow上用戶tabbing設置的類屬性
它們可以設置爲手動始終或者僅僅tabbing
在它們全屏的時候
在剩下的這些屬性和函數中
我講給大家討論下實例屬性以及
NSWindow的函數
一旦你有了一個NSWindow實例
你可將它設置爲tabbing模式
默認情況下這個tabbing模式是自動的
也就是說我們將使用用戶的tabbing設置
不過你可以將它設置爲首選或者禁用
取決於你的窗口類型和你的需要
當我們把窗口分組到一起變成一組tab的時候
我們只想把類似的窗口分組到一起我們判斷的方式就是
通過查看tabbing的標識符
若有相同tabbing標識符窗口
我們就可以把它們以tab的方式分組到一起
默認情況下 AppKit會使用一種啓發式搜索並且
從你的利益角度出發生成一個tabbing標識符
我們檢查這些東西例如窗口的子類名稱
窗口的屬性 文檔
還有一些其它各種屬性然後嘗試生成
適當的tabbing標識符
這種方式運作得非常好
如果它在你的應用中運作不夠好的話
或者你想要更多的控制它
你可以手動設置tabbing標識符
AppKit將會遵守它
你無法獲取到哪些窗口被分組到了一起
通過tab中的某個窗口實例
獲取所有tab窗口
注意它會返回一個可選數組
它可返回空 而且如果tab欄不顯示它必然返回空值
這裏根本沒有關聯的tab
你可以手動添加其它的tab窗口將它們分組到一起
因爲這些都是窗口這正好說明瞭API名稱
當你添加一個tab窗口而不是添加一個tab自身
添加了tab窗口之後可以使用
NSWindowOrderingMode進行排序它將使tab跟其他
tab關聯起來進行排序
AppKit會給菜單添加一些新項
也就是說在窗口菜單下添加了一些項目
以此來幫助用戶在tab之前進行導航
比如選擇下一個或者上一個tab
這只是NSWindow上的IB動作
而且你也可以基於你自己的用戶界面元素來編寫它們
例如 你可能想要一個按鈕來切換tab欄
你可以將那個按鈕連接到窗口
toggleTabBar IBAction
NSWindow將爲你處理切換tab欄
上面就是關於窗口捕獲和tabbing的所有內容
讓我們繼續來講下關於右-左的支持
我們在AppKit上做了很多工作
來加強現有的右-左的支持
大家這裏看到的截圖是運行在阿拉伯語中的TextEdit
標題欄是翻轉過來的
滾動條被放到了另外一邊
甚至New Tab按鈕也放到另一邊
並且所有的小屬性
還有各式各樣的標題欄按鈕都翻轉了
非常符合右-左用戶的期望
我想從三個不同的級別來討論從右-左的支持
系統級別會發生什麼當用戶設置了他們的本地化
在系統設置面板中
它會對應用產生什麼影響
你的應用會表現成什麼樣
依賴於你對本地化的支持
然後下降到內容層面
就是在NSView級別
如果需要的話你可以進一步重寫一些東西
直接使用用戶界面佈局
然後我將會圍繞着一節
通過一個非常不錯的開發技巧來幫助你
給你的應用提供右-左的支持
首先 讓我們從系統層面開始講
這裏的關鍵點是一致性
我們需要保持一致性的表現
在用戶設置爲右-左的系統中
所以不管你支持哪種本地化
在你的應用中我們想要讓所有菜單欄
在一個右-左的系統中從Apple這個菜單項開始
在這裏放在其它的菜單項的右邊
這裏同樣適用窗口的標題欄
所以交通指示燈將翻轉到另一邊
所有不在內容區域的東西
都將翻轉到另一邊
不管你的應用中支持的是何種本地化
給用戶提供一致性的體驗
現在降級到應用層面我們將不能自動這麼做了
因爲我們不想打斷任何
你的應用中可能有的設定
所以強烈的建議你添加右-左的支持
在你的應用中添加猶太人和阿拉伯人本地化
一旦在有了這些本地化
在應用層面
所有的滾動區域將自動無視垂直滾動和標尺
NSBrowser將自動翻轉
在這個層面 我們同樣需要一致性
所以不管何種用戶界面佈局方向的任何內容區域
我們都想要滾動條保持一致性都在同一側
下降到內容層面
默認情況下用戶界面佈局方向將會匹配
你的是應用如何設置的
在大部分情況下這正是你所期望的
不過有一些例外
也就是說 如果你有一些類似媒體控件
或者空間控件 或者時間控件
它們始終是一樣的佈局從左往右
對於左-右用戶和右-左用戶來說都是這樣
所以你可以修改用戶界面佈局方向
並且下面這些AppKit中的控件都支持那樣做
所以自動佈局將不會在這個階段中
不過在即將到來第二階段中我們將開始使用父容器
來決定哪邊是頭哪邊是尾
版本中已有的表格視圖
和outline view會適當的調整它們的列
NSPageController可切換動畫且這個列表還在繼續
我們在AppKit中有很多對右-左的支持
讓AppKit做繁瑣的工作
給你的用戶提供一個右-左更好的體驗
我答應過給大家一個開發技巧
我已使用這個技巧一整年了
我發現它難以置信的有用
在Xcode中 你可以修改項目體質
在Options選項中修改你的應用的語言
設置成右-左虛擬語言
這可以讓你的應用
在開發語言中運行對我來說它就是英語
大家看到這裏TextEdit運行在英語當中
但是它在所有控件中使用了右-左翻轉
所以窗口標題欄被翻轉了
滾動區域的滾動條翻轉了
大家看到所有小的子項和
標題欄所有按鈕都翻轉了
所以這是一個非常簡單的方式讓你獲得右-左的支持
並且確保所有的東西在你的原生語言下運行正確
在這裏僅僅涵蓋了我們在AppKit中做的事
還有很多東西可以討論
在“國際化用戶界面新特性”的演講中
在星期五上午9:00於Nob Hill舉行
他們涵蓋了更多東西在桌面方面
比如WebKit 文本佈局資源管理
他們還包含iOS上右-左的支持
強烈推薦大家也關注下這個討論
讓我們來討論下promise拖拽
若你還不熟悉promise拖拽就是
當用戶從你的應用中拖拽一個文件
但是在磁盤上其實並沒有這個文件
你只是許下個promise
你將會寫入到用戶想要釋放的地方
這就是一個文件promise拖拽
從一開始我們就在OS X中支持promise拖拽
在macOS Sierra中我們升級了文件promise拖拽
將會更加現代化使用NSFilePromiseProvider
和NSFilePromiseReceiver對象
現在這些對象允許文件promise拖拽
來支持拖放羣集
若你對拖放羣集還不熟悉
其實就是當你拖放多個元素時
它們會形成中間拖動
這依賴於目標應用
將會對它們做什麼
使用這兩類的文件promise拖拽可支持拖拽羣集
它們基於UTI
它們完全是尊從writer和reader樣板
即你可使用NSPasteboard上基於元素的API
同這些對象一起工作
如果可能的話它們會適配文件
所以你不用擔心文件的適配
我們會自動包裝文件適配的讀
和寫 從你的利益角度出發
並且反過來它們也是兼容的
它們反過來也兼容基於無元素的文件promise API
也就是說你只需要關心一個API
如果你實現了一個NSFilePromiseProvider
你現可提供文件promise
給任何使用新NSFilePromiseReceiver API的人
或者那些在現有應用中
使用基於無元素API的人
他們同樣可以接受你的promise文件
就像NSFilePromiseReceiver一樣
你也可以接受文件promise
從任何使用NSFilePromiseProvider的地方
或者使用基於無元素API的地方
所以如果你想在拖拽中提供一個文件promise
當用戶開始拖動時你需要創建一個promise
通過創建一個NSFilePromiseProvider實例來實現
如果你想要給每個promise的文件
都創建一個實例
你需要提供一個NSFilePromiseProvider代理
這個代理將負擔承重的任務
把文件寫入到磁盤上
同時 目的地將調用這個promise
你將會被詢問提供目的地的文件名稱
現在你知道目的地在哪裏了
你就可以弄清楚文件名了
不過請不要在這個時候寫入文件因爲它還沒被包裝成
文件適配而且我們發現
拖動中還有一些其它項目
當拖動結束之後
我們知道了所有需要知道的信息
再來調用代理 然後詢問你promise要寫入到的URL
並提供一個完成的處理器
在這個時候 它們都包裝成了文件適配寫入
然後只需要寫入文件到提供的URL
然後調用完成的處理器讓文件適配知道
你已經完成了寫入
若你想要接受一個文件promise
你首先需要註冊view
在你想要允許任務發生的地方
這通常由view.registerforDraggedTypes完成
你需要添加的拖動類型就是NSFilePromiseReceiver
readableDrappedTypes
這非常簡單
現在一旦用戶拖動一個文件promise到這個view上
你將會得到拖拽消息
然後你想得到promise對象
可以使用基於元素樣板API
訪問這個對象的forClassesNSFilePromiseReceiver.self來獲得訪問
你將會得到一個NSFilePromiseReceiver對象的數組
你但你有了NSFilePromiseReceiver對象
你可以調用這個promise裏面的
通過調用receivePromisedFilesatDestination options
operationQueue reader
然後它將迅速的從這個函數返回
reader塊還沒有被調用
我們將在後面返回來調用
一但源文件寫入所有的promise
現在我們繼續返回過去調用reader塊
在指定的操作隊列上
現在 這點非常重要你沒有指定NSMainOperationQueue
給這個操作隊列或者你將
打斷你的應用在等待源進程
完成文件寫入的時候
這過程需要一些時間
而且你不想應用被打斷在這整個過程中
這就是關於文件promise拖拽所做的事
它有更簡單的的API可以使用而且可以同拖拽羣集工作
還可以通過樣板支持基於元素API
讓我們繼續來講下我們做的一些改進
針對各種容器視圖
我們從集合視圖開始
對於集合視圖 預想你可以滾動
內容可以在任何背景視圖上滾動
這就是你可能已有的
現在你可以告訴背景視圖跟隨上下文一起滾動
通過設置backgroundViewsScrollsWithContent爲真
它們將會一起滾動
我們同樣已經支持可選浮動header和footer
你可以把這裏的文檔header設爲浮動
然後內容區域滾動將會在它下面
使用NSCollectionView的浮動佈局這將非常的簡單
只需要設置sectionHeadersPinToVisible爲真
或者sectionFootersPinToVisibleBounds爲真
如果你想要footer爲浮動
NSCollectionView將會
適當的處理 基於你的行爲
你也可以可選摺疊任何部分
到一個單獨的水平的可滾動行
正如你這裏看到的一樣而且還有少許旋轉效果
當你水平滾動的時候
通過toggleSectionCollapse IBAction可以非常簡單地做到這點
在NSCollectionView上
現在這個消息的發送者需要是一個視圖
在你的區塊header或者一個繼承自區塊header的視圖
NSCollectionView才能準確的確定
哪個區塊需要切換摺疊
一旦在header或者派生的視圖中有按鈕
你需要將區塊的header實現NSCollectionView
SectionHeaderView協議它僅僅只是
把你的按鈕鏈接到sectionCollapseButton的插口
然後NSCollectionView將可以可以找到你的按鈕
並且自動隱藏和顯示它
依賴於內部有足夠的內容
在這個區塊來摺疊
NSTableView將重繪所有的子視圖
當索引值爲-1
負1是我們的特殊數表示
擴展你表格中的所有行和列
因此 當你調用reloadData
並且索引包含負1時
我們將替你自動重載所有行
這個僅從10.12版本開始支持
因此在10.12或更新版本中
NSOutlineView也將自動加載它的表格
相關聯的也會重新加載
另外 OutlineView現在體驗更好
通過數據源返回
這個功能非常有用 但若你的應用真想
保持我們原有的刷新行爲
你可以設置stronglyReferencesItems爲假
你就可以使用10.12之前版本的行爲
然後 Taylor Kelly向前
來和你談談網格視圖
謝謝Raleigh
首先我想談NSGridView視圖
這是和NSStackView相似的一個新視圖類
我們實現了創建和管理
約束你的佈局
但如同StackView創建線性佈局顯示
NSGridView創建相交的行和列
你在偏向窗格的UI中會經常看到
是的 這些不同的行列
會自動調整
標準的定義
它支持基線 頭部 底部 對齊
它支持GridView設置整體間距
作爲每個行列之間的間距
類似電子表格應用 它支持單元格合併
因此 一個單一的視圖可以跨越多行或多個列
如同分隔符做的一樣
它還支持動態隱藏行和列的顯示
不改變GridView結構的情況下
例如 當我們點擊這個複選框
我們可能想隱藏顯示偏好按鈕
我們可以通過獲取包含按鈕的行
並設置其隱藏屬性爲true
GridView將自動刷新界面
還有幾個可以改進我們自動佈局
一個是清理AppKit佈局週期
視圖不在需要使用佈局
或者不需要層的參與
通過設置needslayout爲true
下一個界面顯示時 它會調用佈局
這樣佈局顯示時不再被調用兩次
對於層的支持我們減少了隱性髒佈局
因此減少佈局
這個實現方式很好
但是 如果你遇到佈局
在你調用時沒有響應
確認你設置了needsLayout
所有這一切都使它更容易成爲你的子視圖手動佈局
所以你可以重寫佈局而不需要調用super
計算子視圖寬架 設置並返回
你要確保沒有
將自己的視圖和其他視圖混淆
若在視圖佈局中發生這樣的情況
它設置自己的框架或父類的框架
這將弄髒視圖的佈局並導致額外的佈局
如果一直存在這就是我們說的佈局環
這個很難去調試
所以在macOS 和 iOS
我們已經介紹了新的佈局環的調試
所以你可以更好的理解哪兒佈局有問題和爲什麼
佈局的改變添加的API到父類
因此 你可以知道父類的含義
即使不使用父類接口你也需要申請
除此之外時間現在是可以爲null
因此 如果你正在使用該屬性一定要處理的是零的情況
另外 接口支持新功能
用於自動佈局的添加
因此在一個單獨文件或
在一個單一的視圖層次結構中你可以使用常量
這是非常好的
NSGridView佈局環調試的詳細內容
在週五“自動佈局有何新特性”中講解
在這裏我想談談顏色
特別是全範圍的顏色
所以sRGB是一個漂亮的流行色彩空間
通常是使用隱含的顏色代替未指定的空間
我們大部分的顯示器有一個sRGB色域
新的5K iMac和iPad Pro 9.7英寸屏
都包含這些更新的顯示器可以顯示更生動的顏色
具體地說 他們正在使用P3色域
比起sRGB色域
它可以顯示很多更充滿活力的綠色和紅色
所以你的應用可以顯示照片
更精確的顏色可以展示這些更具活力的
顏色讓界面看上去更加真實
舉顏色的一個例子綠色
正好是Pantone的2013年度色
它超出了sRGB範圍
所以以前顯示器不能顯示這個顏色
但是使用P3可以完美顯示出來
你的照片也包含這些更鮮豔的顏色
特別是紅色和橙色
諷刺的是 投影機甚至在家裏的電視
其實不去顯示這些顏色
所以你不得不承認它們很特別
如果你想用這些顏色
有新的色彩空間displayP3它讓你可以擁有
這包含sRGB和其它的色彩空間
NSColor中有新構造方法displayP3紅色 綠色 藍色 阿爾法值
它允許你在顏色空間中創建一個顏色
UIColor具有相同的構造函數具有相同的效果
另一種方式具有廣泛的顏色
採用的方式我們調用擴展範圍sRGB
所以用色彩空間時你通常被限制
元件值從0到1
且你可在色域範圍內選擇任何顏色
比如藍色 通過這些值
但你不能代表一個顏色這就是色域之外
所以sRGB不能代表這個綠色的顏色
擴展範圍sRGB使用相同的基色
和相同的白色點爲sRGB但允許部件
採取值小於0或大於1
所以它可以代表這個綠色通過一個負的紅色和藍色的值
和一個大於1的綠色值
這恰好也是P3綠色的原始值 因此
擴展範圍的sRGB你可以代表全範圍
你需要的顏色在顯示器上
這也有一個彩色空間extendedSRGB
和現有的NSColor
以及UIColor已經在使用的函數
先前提供的顏色使用sRGB
現在將接受較少的值小於0或大於1
給你回一個擴展範圍的sRGB色
這是非常方便的
考慮一個重要的事
這些更廣泛的顏色色域顏色深度
所以sRGB理論上可以表示在其色域任何顏色
但每比特8位
你也只能解決數量有限的 是的
這裏的黑色空間只是非尋址顏色
使用8位每組件
當你擴大色域 增加該色域的音量
但保持相同的位深度
你是可尋址的色密度下降
你能夠指定的顏色丟失精度
這就是爲何我們建議
工作時這些更廣泛的色彩空間中 如P3
你用16位比特使用每個組件
它內存和存儲數量翻倍
但給你成倍增長更多可尋址顏色
因此 我們認爲 權衡是值得的
需要使用什麼API考慮到這些更深的顏色
好了 好消息是大多數都是自動的
所以NSWindow將自動使用較深的支持存儲
有了這些更高的位深度寬色域顯示
即使你拖動它在整個屏幕
如果你需要一個方法明確控制
你可以設置深度限制屬性爲你選的值
視圖和層內窗口會自動
繼承該位深度唯一的例外是OpenGL視圖
你應該用相關的像素格式的API
在macOS和iOS的CALayer有一新內容格式的屬性
允許你再次明確控制它使用比特深度
所以這是你可以利用的優勢在你的應用廣泛的顏色
我們也提高了部分系統性能 能夠更好的利用
這些廣泛的色彩
一個例子是彩色面板
所以 在iMac左邊
顏色盤會顯示
開始
它實際上會顯示和允許從全方位的P3的顏色
超出sRGB正常顏色輪也會允許
然而 你也能右鍵單擊顏色輪
並明確選擇工作區色彩空間
因此 即使在這些以前的顯示器不能使P3的顏色
你仍然可以允許選則他們
RGB顏色選擇器始終允許你
選擇顏色替換你工作空間
但它也允許你改變表示
從8位值從0到255到浮點數
所以你又能得到精度更高
工作時有了這些更廣泛的色彩空間
這些顏色面板的變化是所有的應用程序完全免費
沒有任何的接口需要調用
工作具有廣泛的顏色星期四的談話涵蓋更多
如目錄支持WebKit支持
我建議你更新出來如果這些東西使你感興趣
因此 下一個主題是狀況項目改進
所以狀態項的事情
底部的菜單欄
這些是先前的使用要求
私有API來實現但現在大多是免費的
首先是排序
現在你可以命令點擊拖動任何項目排序它
內部和外部的系統項目
你也可以用鍵盤焦點轉到您的項
甚至激活菜單項內
這一切最好的部分 這是完全自動的
沒有API選擇或鏈接檢查
所以所有的項目都是命令點擊拖動重新排序
和任何菜單設置的項目將參與鍵盤導航
如果他們有一個自定義的目標活動他們會被跳過
其次是隱藏和去除
您現在可以命令單擊並將一個項目從狀態欄中拖動
移除通知該更改
甚至編程恢復
不同的排序這就需要選擇
沒有狀態項目將自動移除
你可以通過設置現狀項目的行爲
包含removalAllowed
你可以編程讀/設置
甚至得到KVO通知這個變化的利用可見屬性
如果你的應用是一個狀態欄的應用
它只表示意義是在狀態欄圖標
有無文件圖標或其他的方式要退出它 你可以設置它
自動退出清除
通過設置terminationOnRemoval行爲
所有這一切都會爲你保存位置
和可見的狀態所以你不必擔心
爲了保持使用自動保存名字
我們自動生成這種基於項目指標
你在你的應用程序中創建的
但如果你創造它們一些非確定性的順序
或者只是想擁有更明確的控制
您可以設置自動保存的名稱你選擇一些標識符
這樣的狀況項目改進
很多都是免費的和一點點的調整
你真的可以使他們在應用程序中更好使用
下一個是控件構造函數
所以這些新的構造函數在現有NS控制
這使它很容易得到標準的外觀和感覺
例如 不同類型的按鈕分段控制
圖像視圖 滑塊標籤和文本字段
所以這些類型的已有的
Interface Builder對象庫
這使得它很容易使用盒子的性能
他們跟標準的系統設置合適的字體大小 顏色和文本顏色
他們支持不同的情境
淺綠色充滿動感的標籤看起來很棒
甚至盒子中充滿動感的暗色
沒有額外的安裝
這將對你代碼起何作用我想向你舉例說明
這是創建一個複選框前
需設置相當多的屬性
不幸的是我們真的只關心其中的三個
標題 目標和行動
複選框 以及標題 目標行動 剩下的
這是非常好的
更多的一點 哦
等着
所以這就是創造一個靜態標籤
只是屏幕上的一些文字
而在這裏 我們關心的只是字符串值
有文字的標籤 又是這樣的
所以 這非常棒
它是從盒子裏出來的
它出來的盒子可以用帶或不帶自動佈局
所以 如果你要定位約束
你還需要設置translatesAutoresizingMask
IntoConstaints爲假像你其他的視圖一樣
所以如果你已經有了類做這些事情
我們仍然建議移動到這些新的系統
因爲你會確保你的控制有標準的外觀
感覺現在和未來
我最後想談的是API的改進
我只覆蓋了一些這些適用於我們所有的框架
這些申請AppKit
我還想談談適用於AppKit的另外兩點
首先是弱委託
所以我們已經添加了新的歸零弱委託的支持
對於不同的代表和數據不同類別的源
所以你不再需要明確這些屬性
當引用們被釋放
它仍然支持非弱引用的對象
在這種情況下 它會回到原有的分配
或不安全的 不保留語義
我們也經歷過並確定了
我們所有的類顯式並宣佈其指定的初始化
這些是和他們以前一樣有效的
但現在只是在實際的接口中聲明
有一個例外NSCursor
所以 如果你是子NSCursor請看發行說明
你應該正確處理
與所有的新聲明指定的初始化
你應該確保你是正確的在你的類的處理
所以如果你以前沒有
你可能會有這些錯誤問題
這也許是微妙的錯誤
在Objective-C現在看到的編譯警告
在Swift 你要去獲得建立失敗
所以你要確保你妥善處理這些不同的情況
這是AppKit最新內容
在這一點上我想翻過去
有請Ali講述“Foundation有何新特性”
謝謝你 Taylor
所以這裏有一些東西這是新基礎
現在進入主題
現在你看到了NSURL成爲URL
我想我們昨天也談到了一點
我們把NS前綴在Swift中添加了快捷鍵
現在 你可能知道地基大的子集
實際上用Swift核心庫
作爲Swift 代碼部分
是可用的在其他平臺上 如Linux
我們要匹配的命名樣式這部分的基礎
隨着公約的建立通過Swift標準庫
而不使用前綴
因此 我們的類型很多沒有了NS前綴
在基礎和Swift中正如你所看到的
NSFormatter變成了Formatter等等
最後兩個 NSData和NSURL是一個特殊類別的一部分
我會提到這一點
現在 這正在發生只有在基礎上修改
這不是我們應用的東西
到我們的其他框架甚至在基礎
這只是應用於一些API
我們不把這NS放到API
本質上依賴於Objective-C
例如 NSObjectNSProxy NSAutoreleasePool
我們也不把它的API在特定的平臺
事實上在其他平臺上不可用
比如NSUserNotificationNSXPCConnection
在另一個情況是類這也暴露了值類型
所以在這裏 我們正在暴露數據 網址 等等 但
我們也將NSData NSURL
等等我的意思是
現在先讓我解釋一點關於值類型
你可能已經熟悉值類型
我們有這個概念在基礎很長一段時間
這些類型的值是重要的 而不是身份
比如NSString NSDataURL  Array等等
現在 由於一些基礎的API已經有這些值類型的語義
我們已經提前並將它們最爲Swift值類型添加
我們已經做的全套API
這當然是字符串 數組 字典
和設置已經作爲值類型
在Swift中  他們是可用的在標準庫中
所以現在這裏的這些類型是暴露結構在Swift中
他們有價值的語義類型這意味着他們可以直接變異
如果他們有意義的可變性
你可以使用let或者var突出異變
在你聲明他們的時候
這些也符合Swift協議
正如你所期望的
現在已有的類的API仍然保持在case
在我們創建這些值類型
讓我看看這裏的案例研究
一個例子是數據我已經提到的那個
所以現在我們的結構數據類型
這是數據值類型
這是我們期望的數據類型在編程過程中使用最多
這是前進的類型然而 我們也有NSData
這是NSObject和NSMutableData子類
這是一類NSData本身
現在NS類型仍然存在因爲如NSMutableData
不是很容易遷移所以他們不會遷移它
我們的另一個原因是NS類型有時你真的
要繼承這些類型
你知道 你可以子類化NSData或者NSMutableData
提供一些專業化的實現
當然 你可以這樣做類類型 如您在這裏看到的
所以這些都是一些原因爲什麼NS類型仍然存在
現在 讓我們來看一看這裏有些差異
NSData類有一個長度屬性
這個被命名爲數在結構版本
因爲它與其他Swift標準庫更一致
如寫入方法 範圍和許多其他方法
保持相當完整
他們遇到相同的方法 除非你會注意到
NSRange和NSData已成爲指標範圍
在數據結構的版本 這是更符合Swift庫
最後你會注意到這一變異的功能 如添加
是不可以在這直接值類型數據
在NSData中它在NSMutableData類中
所以這些都是一些的差異 你會看到
在值類型與類類型之間
現在我不準備說更多關於這個內容
今天下午有一個談話“Swift基礎有何新特性”
在任務室裏
我鼓勵你們參加並聽到更多關於這些內容
現在我們有幾個基礎新類型
代表測量的量
這裏的主要類是單元類
這是一個抽象的類型代表單位 如英里
攝氏度 公里每小時 等等
然後我們有一個類維度這是一個單位的子類
這代表單位家庭如長度
溫度和速度 等
因此 在此 我們有單位類
我們有子類維度然後我們的子類
如單位長度 單位溫度單位速度 和一堆更多
有一個輔助類單元轉換器可以
單位之間同一單位家庭轉換
有一種結構測量它是一個類
在Objective-C在Swift中作爲一個值類型
結構測量相結合的值 如10
用一個單位 如英里
所以這基本上現在是一個測量
最後錦上添花
我們有測量格式化程序類
將一個測量
並將其顯示給用戶區域中的用戶
所以它會顯示10英里的用戶在美國這裏
但會顯示16公里 例如在歐洲
使用歐洲系統的用戶
所以它會爲你做的轉換並向用戶展示正確的數據
我們有很多已定義即可用的單位家庭定義
這是全套
所以這些尺度的子類
在其中的每一個單位家庭
我們實際上有多個即可用的單位
讓我們看一看單位的溫度
你會看到溫度有三個標準單位
開爾文 攝氏和華氏
UnitTemperature類中這些都被定義爲類屬性
許多其他尺寸也有一些單位規定
知道彼此之間如何轉換
更好的消息你可以添加你自定義的單位
我們提供它們將使用現有的
而且你也可以添加你自己的單位家庭
你可以聽到更多關於這個的內容星期五下午4點
測量和單位
DateInterval是新類型我們已添加到基礎版本
它表示一個日期間隔
它有三個屬性開始 結束和持續時間
相當直觀 當然 這些都不是
完全獨立 但它們作爲三個獨立的屬性
除了這些屬性
DateInterval能夠做到檢查日期是否在日期間隔內
或是否兩個日期間隔重疊等
當然日期間隔在格式化時很有用
通過DateIntervalFormatter類
這就是我們這是我們去年發佈API
有個從String修改過來的API接口
現在我們從API到String只需要一個日期間隔
如此相當簡單
現在在這裏讓我告訴你們一個關於公共服務通告
處理日期和時間
所以處理日期可能是複雜的
現在 這不是這裏建議的
好嗎 我不是醫生
讓我們說你想要表示10秒時間
你創建個DateInterval類
開始時間和10秒
這可能是正確的無論你試圖做什麼
無論你試圖怎樣處理10秒
但是讓我們說你是試圖代表一天
你也可能這樣寫你的代碼
24乘以60乘以60表示一天的秒數
這是一個數字24小時內的秒數
它往往不是正確的
原因是因爲一天並不總是24小時長
一個月並非總是31天
年不總是365天 等等
我們總是把那些記在心裏但是有時一天
23小時 或者有時24小時 25小時 如你所知
所以取決於你想做什麼通過DateInterval表示日期
你想設置一個鬧鐘嗎正是從現在開始的24個小時
你想在第二天同一時間發出一鬧鐘嗎
你可要小心了
通常情況下正確的解決方案涉及使用日曆類
你會遇到這些問題
而且幸運的是他們的解決方案上面所提到的從2013年開始
常見的數據的解決方案和時間的問題
我建議你回去重新看看
ISO8601 DateFormatter是基礎類中新提供的API
這是一個格式化日期類
謝謝
很顯然你們中的一些人
以前使用86018601是一個標準
這是一個用於指定日期的交換格式
在明確的方法中
所以這是一個單獨的類和DateFormatter相比
因爲不向DateFormatter
它是用戶本地化的日期8601格式是非本地化
你知道這是交換格式所以這是一個單獨的類型
我們決定讓事情變得簡單
使用起來非常簡單
所以創建一個格式化
給自己一個日期又沒有關係的建議
簡單地問格式化程序爲日期轉爲字符串
它會返回你的格式
現在DateFormatter可以兩種方式實現
所以你實際上可以
哦 順便說一下這是調用的輸出 正如你所看到的
就要到午餐時間
這裏是 此格式化程序還有其他的方式
也做解析
所以你可以自己格式化並要求從字符串轉換成日期
它會返回你的日期
所以它是雙向的
這默認是RFC 3339它是一種格式
然而有選項可讓您指定
一些行爲 如果你需要的話
現在讓我快速的告訴你們我們提供的其他功能
URL有一堆新的屬性
如一個文件和一系列其他的典型路徑
像音量是否加密等
你可以閱讀所有這些在發行說明中
有一個新類URLSessionTaskMetrics
這個類可以幫助你收集網絡資源
加載性能信息
所以你可以看看應用程序的網絡性能
PersonNameComponentsFormatter是新版本我們提供的一個API
正如你所知道的 它需要一個名字
它以一個區域設置適當的方式來格式化
在這個版本中其實現在可以解析名稱
所以你給它一個名字它會返回你
名字 姓 等等
這是一個不錯的工作
由於它採用了一種基於真實數據的統計模型
最後
但也有一些棘手的名字
所以不要期望太高
DateComponentsFormatter
是我們最新的版本中添加的
除了長短類型
我們現在有一個簡單的風格你可以格式化日期
下一個發佈也許我們會添加boxer風格
好吧 這就是基礎
核心數據 只是一個簡短的提及核心數據
你已經看到一些API的改進
在覈心數據與泛型
有更多的新的API在覈心代碼裏
比如generational查詢持久性存儲
NSFetchedResultsController類現在在系統OS X中可以使用
對不起 是macOS系統
週五上午10點你將聽到所有這一切“核心數據有何新特性”
還有一個我想大喊出來的
我們每年都在這裏告訴你關於新的API
介紹了新技術
你可能並不總是處於一個方式通過這些API
因爲你在做其他事情
或者你等一個版本
好吧 如果你想得到一個概述關於最近我們已經添加的API
APIs是重要的創建用於Mac的現代應用
這個談話是給你們的
它將涉及很多主題他們將有
其他感興趣的演講不只是在本屆 WWDC
往屆 WWDC 也有
它也適用於每個人各年齡 不同經驗水平
這也是星期五下午5點
所以我希望你在這裏
好的 那麼這是網頁你可以瞭解更多信息
請讀AppKit與基礎版本說明
您可以在我們的開發工具站點中找到
它是一些原始信息很多我已經談到了
這是我們提到的有關演講
還有更多的課程
非常感謝大家