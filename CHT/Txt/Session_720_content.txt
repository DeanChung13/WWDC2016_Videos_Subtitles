Swift 3中使用GCD併發編程
下午好
今天下午 我將要和大家聊一下如何結構化你的程序
使用併發編程以及我們在這一年中做了哪些東西
在Swift 3的GCD的新特性
我叫Matt稍後Pierre會和我一起
我們都在Apple達爾文運行時團隊
當你創建一個新的工程
你會得到一些類似於這個的東西
你們都有應用 那個應用有它的主線程
這個主線程用來
運行所有生成用戶界面的代碼
當你開始往應用中添加代碼的時候
你會發現應用的性能會大幅度地變化
比如 你開始引入很多工作
像數據轉換或圖片處理在你的主線程上
你會發現你的用戶界面變糟糕很多
在macOS上這可能會是出現不停轉動的圓圈
在iOS上這可能是一些更微妙的東西
你的用戶界面會慢下來或者甚至是完全停了
我會帶大家看一些基本的內容
關於如何結構還你的應用以此避免這類問題
稍後 Pierre會上臺給大家談一些更高級的話題
那麼我們應該如何處理這類問題呢？
我們要從介紹程序的多線程概念開始
多線程允許應用中的多個部分
在同一時刻運行
在我們的系統中你通過創建線程來實現多線程
一箇中央處理器核心可以在任意時刻處理一個線程
但是引入多線程的好處
引入多線程的壞處
是它會使得很難維護線程的安全性
你新引入的其它線程
可以觀察破壞代碼不變量的效果
當你在其它線程執行操作的時候
這變成有點問題了
那我們如何處理呢？
GCD是我們平臺上的多線程庫
它幫你寫多線程代碼
工作於所有平臺從Apple Watch
到所有的iOS設備Apple TV以及Mac
所以爲了幫助你 使用多線程
我們在線程上引進了一些抽象
那是調度隊列和運行循環
調度隊列是是一個結構 允許你提交
工作項目給隊列在Swift中 這是閉包
調度會帶來一個線程和一個服務
當調度結束在那個線程上所有工作的運行
它會拆毀工作線程
正如我前面說過的你也可以創建你自己的線程
在那些線程上 你可以運行運行循環
最後 在第一張幻燈片你們有了主線程
它是特殊的
它同時有主運行循環和主隊列
所以調度隊列有兩個主要方法你可以給它們提交工作
第一個是異步執行
你可以給多個工作項目進行排隊
給你的調度隊列 然後調度
會引入一個線程來執行那個工作
調度會一個個從隊列中拿到項目並執行它們
當它完成了隊列中的所有項目
系統會回收那個線程
第二個執行模式是異步執行
這是 比如如果我們的設置和前面的一下
調度隊列有一些異步的工作
但是你有你自己的線程
那個線程想要在隊列上運行代碼等待它的發生
你可以向調度隊列提交那個工作
然後它會在那裏被卡住
它會一直等待直到你要執行的那個項目完成之後
我們可能給那個隊列增加更多異步工作
然後調度會帶來一個線程
爲了服務那個隊列中的項目
同樣 異步項目會被執行
當運行你要運行的同步項目
調度隊列會對取消那個等待線程的控制
執行那個項目
調度隊列的控制會返回給一個工作線程
通過調度來控制
它會繼續排出那個隊列中的其它項目
然後回收使用過的線程
那麼現在我已告訴你如何向調度提交工作
那麼我們如何使用它幫助我們解決我們前面遇到的問題呢？
我們要做的是把工作從你的主線程拿開
那會阻礙用戶界面
我們通過拿開主線程的轉化來實現它
把它放在不同的隊列中運行
所有你可以拿掉轉化把它放回到一個調度隊列
當你想要轉化數據
你可以把那個數據的數值轉移到你在另外隊列的轉化代碼中
轉化它 然後返回給你的主線程
這就允許你執行那個工作
當主線程空閒和服務事件
那麼在真實代碼中這是什麼樣呢？
好吧 這是非常簡單的
首先 你可以創建調度隊列
通過創建一個DispatchQueue對象來提交你的工作
它有一個標籤
那個標籤在調試器中是可見的當你寫應用的時候
調度隊列執行你提交的工作
安裝先進先出的順序
也就是 你提交給隊列的順序
就是調度運行它們的順序
然後你可以在調度隊列中使用異步方法
來給隊列提交工作
所以既然我們已經提交了我們的調整大小操作
給一個不同的隊列那我們如何把它返回給主線程呢
那也是非常簡單的
調度主隊列
服務於所有執行在主線程上的項目
這意味着你可以只調用DispatchQueue main方法
然後在那個主隊列中調用async方法
那樣代碼會執行你可以更新你的用戶界面
正如你所看到的那樣鏈接工作是非常簡單的
從一個隊列到另一個隊列和返回到你的主隊列
那麼我已經看到了如何控制你的代碼
和將它放在不同的線程
這是要有一些代價的
你必須控制你的應用中的一個併發
調度使用的線程池
會限制你能得到的併發數
爲了使用設備上所有的調用
然而 當你阻礙那些線程的時候
如果你等待你的程序中的另外部分或者你等待系統調用
那些被阻礙的工作線程會導致更多的工作線程
調度是嘗試給你你應得的併發數
通過給你一個新的線程來繼續執政代碼
這意味着選擇正確的調度隊列數量是非常重要的
來執行代碼
否則的話 你可能會阻礙一個線程另外一個線程會產生
然後你阻礙了另一個 以此類推
這個模式就是我們稱爲線程爆炸的東西
我們在去年的演講中講了線程爆炸和它的問題
使用GCD建立響應式和高效應用
所以我建議大家回去看看去年的那個演講
現在我們已看到了如何做這個簡單的事情
就是把工作從主線程搬到其它隊列中
但是我們如何真的把這個應用於你的應用呢？
如果我們回到前面的系統
你想要做的就是確定你的應用的面積
使用獨立的數據流
正如我們看到過的那樣這可能是圖像轉化
或者你可能有一個數據庫
你想要計算那些面積把它們分割成獨立的子系統
然後你想要把那些每一個子系統返回給一個調度隊列
這會給每一個子系統一個隊列來獨立地執行工作
這樣就不會有太多隊列和進程的問題
我們在前幾張幻燈片看到了
把工作串聯在一起是很簡單的
你可以異步處理一個一個的模塊
然後到另一個隊列 然後回到主隊列
但是我還想給大家展示第二種模式也是同樣的有用
那就是組合工作和等待工作結束
如果你有單獨的一件事想要產生多個不同的工作項目
而你想往前進 如果那些工作項目
當那些工作項目完成後 你可以做那個
爲了實現它 調度可以幫助你
所以如果我們回到剛纔的示意圖
如果用戶界面產生三個不同的工作條目
你可以創建一個調度組
調度組是幫助你追蹤工作的
它們在Swift中是非常容易創建的
你只要創建一個DispatchGroup對象
現在當你向調度提交工作
你可以向你的異步調用增加這個組作爲一個可選的參數
你可以向那個組添加更多的工作你可以向不同的隊列添加
但是用同一個組聯繫起來
每次你向組提交工作
它都會增加需要完成的項目的數量
最後 當你提交了所有的工作
你可以讓組在所有工作被完成時通知你
你可讓它在一個你選擇的隊列中這麼做
現在一個接着一個這些項目會開始執行
當它們執行的時候 組中的數量
會在每一個工作項目完成的時候減少
最終 當最後一個工作項目完成的時候
組就會繼續 然後提交你的通知阻礙
給你請求的隊列
這樣 我們返回組 阻礙給主進程
它會在主線程上運行
現在還有第三個模式我覺得我們需要展示的
前面說的兩個是異步執行
第三個是關於處理同步執行
你可以使用同步執行
來幫助你序列化子系統間的狀態
串行隊列、調度隊列是本質的序列
你可以使用它 爲了它的相互排斥屬性
那就是當你向那個隊列同步地提交工作
你知道運行在那個隊列中的子系統的工作
不是同時運行的
你可以利用它來建立非常簡單的路徑
從其它地方的子系統中讀取屬性
比如 這裏你可以調用隊列同步
你可以返回一個值到隊列同步的外面
我們會在隊列中捕捉到那個值
然後在工作項目結束時返回給你
但是 當你引入這個模式的時候你必須十分小心
因爲你開始在你的子系統之間引入一個鎖順序圖
那是什麼意思呢？
如果你有我們曾經有過的子系統
而且你從一個地方同步到另一個地方然後又同步到另一個地方
最後 你同步回第一個
好了 現我們有了一個死鎖
這個演講的後面部分Pierre會上來談一下死鎖
所以現在我們看到了如何結構化調度使用
在你的應用中
我們如何將其應用於你的子系統中的使用
你可以使用調度來對你提交的工作進行分類
爲了實現它 我們需要引入很多服務類
這些類用來提供一個明確的分類
你提交給調度的工作
所以它允許你作爲一個開發者
來表示你提交給調度的代碼的意圖
調度可使用它來影響它執行代碼的方式
你給我們的
代碼可以不同中央處理器優先級進行執行
不同的輸入輸出安排優先級
我們在去年同一個演講中詳細地講了QoS
使用GCD創建響應式和高效的應用
那麼我們如何使用QoS類呢？
這和以前一樣簡單
你可以將QoS類作爲一個可選參數傳給異步
我們給隊列提交後臺工作
如果你等會兒出現和在一個更高的QoS上提交隊列
調度會幫你解決創建的優先級顛倒
它會在你的工作之前提升項目
在調度隊列 給更高的QoS
那樣它們更快地執行 讓你的項目
以你期待的速度執行
然而 對這一點需要重點指出的是
它不會幫助你的工作跳行
它所做的一切就是在你之前提升所有的工作
所以你一提交工作 它就會執行
你也可以創建調度隊列
它有特定的QoS類這是非常有幫助的 比如
如果你想要始終在後臺執行的後臺工作
你可以創建一個隊列 在後臺執行所有
當你向那個隊列提交工作的時候那就是我們得到的QoS
所以在更微觀的級別上當你於一個調度隊列進行同步
它獲取執行內容 在你同步的那一刻
執行環境意味着類似於QoS的東西
它也意味着你現在擁有的登入環境
但是如果你想要更多的控制
你可以使用DispatchWorkItem來創建項目
你對它們如何執行有更多的控制
比如
我們使用assignCurrentContext創建一個工作項目
它使用執行內容的QoS
在你創建工作項目的時候
而不是你向調度隊列提交它的時候
這意味着你可以創建那個項目 保存它
當你最後真的執行它
我們會想調度提交它並帶着你創建時的屬性
當我們談論工作項目的時候
DispatchWorkItem有另外非常有用的部分
那就是等待它們的完成
你可以使用DispatchWorkItem wait方法
來向調度表示你需要那個工作項目完成
在你繼續之前
調度會響應通過提升它前面工作的優先級
到那個QoS 就像通過優先級翻轉所做的
它可以這麼做是因爲DispatchWorkItem
知道它在那裏被提交你想要在那個線程運行它
因爲 調度知道它要提升那個隊列
使得完成你的工作條目
需要重點指出的是
因爲等待旗語和小組
不會存儲這個所有者信息
這意味着如果你等待一個旗語
它不會在你的旗語信號前產生東西
來更快地執行
現在我要邀請Pierre來到臺上
他會給大家講一下同步
謝謝Matt
和Matt一起我們看到了如何從應用的角度使用調度
我會和大家講一下它的具體意義
從你們的對象的角度
首先 關於Swift的一點
同步不是Swift 3語言的一部分
你今天只有這個語言的一個重點
那就是你的全局變量是被原子化地初始化的
但你沒有的是你的類屬性不是原子化的
你的類中的惰性屬性也不是原子化的
那意味着如果你調用這些屬性
而它們同時在兩個環境中被初始化
你的惰性初始化器可能實際上運行了兩次
所有你必須同步
這個語言現在不會給我們很多的工具
但是那不意味着競爭不是一個問題
不存在良性競爭這種事情
對你來說 那意味着如果你忘記了同步這一點
你會得到奔潰
或者破壞應用中用戶數據
我建議大家看一下本週稍早時候的演講
關於T San的 那是個消毒劑
是一個工具 幫助你找出
在程序中你缺少了哪些正確的異步處理
那我們拿什麼來做同步處理呢？
傳統上你會使用一個鎖
在Swift裏因爲你有一整個達爾文模塊在部署中
你實際上會看到這個結構是基於傳統的C語言鎖
然而 Swift假設所有被訓練東西都是可以被移動的
那不會和一個互斥體或者一個鎖一起工作
所有我們非常不建議你在Swift中使用這一類的鎖
你若你想要一個傳統的鎖你可以使用的是
Foundation.Lock因爲不同於傳統的基於C語言鎖的結構
它是一個類它不容易產生我前面提到過的問題
然而 那意味着你確定了你的下一個對象
對你來說 它可能會不是所想要的
如果你想要一些小一點的東西
那看起來就像是你在C語言中的鎖
然後你必須引Objective-C引入Objective-C中的基本類
把你的鎖作爲一個不變量
然後你會暴露一個鎖和解鎖方法
一個嘗試鎖 如果你也需要它
你可以從Swift中調用當你將該類分成子類
你會在那張幻燈片中發現我們使用不公平的鎖
這是一個新的API我們在這些更新中引入的
它不易於盜版入侵
它不會旋轉 不像我們複製的旋轉鎖
這是真實生活中最重要的
這是一個GCD的演講所有我們鼓勵大家
使用調度隊列 爲了同步處理
要這麼做的的第一個原因是這些非常容易被誤用
相比於傳統的鎖
你的代碼會在可觀測的方式下運行
這意味着你不能忘記解鎖
另外一件事是隊列事實上更好地集成到
Xcode中調試工具中的運行時
所以我們如何使用隊列來同步呢
我會和大家一起講一下實現原子化屬性的問題
這裏我們有這個對象它有一個內部的狀態
我們想要以一種安全方式來訪問它我們會使用一個隊列來同步
我們如何寫我們的getter和setter呢？
getter是關於返回它的內部狀態
它給我們相互的排斥Matt前面已經講過了
setter也是那麼簡單你只要設置你的新狀態
和同步的其他保護和你的隊列
這個模式是非常簡單的你實際上可以拓展它
對於各種更加複雜的產品
我告訴過你隊列更好地與你的調試工具整合在一起
它們也有更多的功能
在這個更新中的新東西我們讓你表達預設條件
它讓你表達你在代碼中有不變量
非常需要在指定的隊列中運行
你以這種方式擁有
調度預設條件 你在那個隊列上
有時對面是非常有用的
你想保證代碼中特定片段永遠不會在那個隊列中運行
因爲你知道你可能與那個隊列同步
你表以這種方式示這個
一個預設條件你不在那個隊列中
所以那就是關於同步處理同步你的狀態
正如Matt前面所說的 這會更加好如果你僅組織你的應用
以你的傳輸值不需要同步被掛起的方式
然而 在真實的代碼中
你需要一些對象來訪問從簡單明顯的子系統
那意味着所有這些子系統
有一個引用在這些對象中
擺脫它們會是一個挑戰
我現在會帶你們看一下一個四步狀態任務
那會幫你得到這個高度
不會產生奇怪的難以重現的奔潰
你的狀態機開始於第一件事 設置
設置是關於創建你的對象
給它你需要的屬性 爲了它的目的
第二 你會想要激活這個對象
那意味着你實際上讓這個對象對於其它子系統是可知的
你開始使用它以一種更加同步的世界在性能任務方面
然後開始了難的部分你想要擺脫那個對象
所有第三步是作廢
作廢是關於確保所有部分
所有你的子系統知道這個對象會消失
所以 第四 它被取消分配
那麼讓我們讓它保持那樣
設置 激活 作廢 取消分配
這是非常抽象的 所以我們會講一下
一個更加具體的例子我希望你會關聯上
讓我們回到Matt前面介紹的應用
關注於兩個子系統
第一 我們有我們的用戶界面
它會處理事物類似於應用中的標題欄
我會假設你可以觀察一些狀態改變
在你的子系統中
所以那樣 舉個例子對於我們的數據轉換子系統
當它開始執行一些工作
我們給用戶展示了一個視覺上的跡象
當數據轉化子系統停止做任何工作時
視覺跡象消失了
所以我們如何實現BusyController呢？
所以我們記得第一步是設置
設置是關於爲你的代碼挑選屬性
和動畫之類的 這都取決於你
然後我們想要開始使用那個對象
那是激活 我們激活它
那對我們的控制器意味着什麼呢
那意味着我們想要開始接受這些狀態通知
狀態變化的通知所以我們會向子系統註冊
並要求在主隊列上接受通知
我們想在用戶界面進行邏輯的處理
鑑於它非常靈活
那就是你的代碼 那就是你想做的
你的應用有動畫以及非常好的用戶界面
但你的應用有些部分不需要可視指示
或可能不使用數據轉換子系統
而且你想回收控制器的資源
當你不想要它了
我很想說 主線程
是唯一真正擁有BusyController的子系統
我將會像這樣去掉它
在初始化過程中從子系統中註冊控制器
從好的方面想
這種方法不起作用
我將會用兩個例子告訴你爲什麼
讓我們回退一步
我們的BusyController是參考UI
主隊列和用戶界面
然而 當我們用數據轉換子系統註冊時
很可能引用從數據結構轉到這個對象
這意味着當我們去除這些引用
主線程有的參考
仍然會遺留一個這意味着deinit 無法運行
這意味着它會被註冊 被收集
接着因爲被遺棄的內存你放棄了
然而 你們是技術熟練的開發人員知道怎麼來修復那個
弱引用 我會說 你們是對的
但是 這並不是故事的結局
因爲這看起來並不像個真正的應用
圖形對象複雜得多
使用有引用的對象是不常見的
還有一大堆其他對象比如說octopus對象
我將繼續從主線程中去除引用
不像之前 這不是廢棄的內存
因爲octopus對象知道它有引用
但若我們從上下文中去除octopus對象時
數據轉換系統 將會發生什麼
它將去除BusyController的引用
記住 這將在 運行的
因爲那是deinit所做的
然後你有了一個問題因爲非常可能做到的
你需要同步一個調度隊列
它擁有那個數據結構
你猜到了 我們最後會得到一個死鎖
實際上 那個漏洞是非常普遍的
以致於我們爲它寫了一個斷言在這個新版本中
如果你在上一個發佈版本中運行那個代碼
它會斷言 在OS X或者模擬器上
你得到的奔潰報告有一個特定應用信息
指向你有的實際問題
所以你可以很簡單地修好它
好了 現在我們知道我們真的不想從deinit註銷
我們如何修理它呢
我們通過我們的第三步來修理
作廢 一個顯示函數調用
在這個作廢下 我們通過註冊實現它
同樣 因爲我們有預設條件讓我們使用它們
因爲這個對象BusyController
確實應該在主進程中被管理
你想確保API的用戶正確地使用它
所以你會想要一個預設條件
那隻發生在主進程上
或者主隊列上
但是那不是那樣子的
我們還有最後一個問題
記住 這都是發生在主進程上的
你有這個子系統 數據轉化子系統
它會告訴你狀態變化
你可能有一些當你作廢的時候發生
我們如何解決那個呢
我們想要追蹤作廢作爲一個真的狀態
那是什麼意思呢 就是這個意思
你想要追蹤作廢 比如
作爲你的對象中的一個布爾值你記住當你做這個的時候
同時 讓我們說一下更多的預設條件
確保加強 在你的對象被取消分配之前
它已經被正確地作廢它會幫助你找到漏洞
爲什麼這很有趣呢？因爲現在
在你處理狀態轉化通知的代碼中
我們可以觀察對象被作廢
實際把通知扔在地上
不是以令人尷尬的方式更新用戶界面
好了 這大致就是這個複雜的例子
我希望你會回去看一下你的應用和你的代碼
嘗試去發現這個模式能幫助你的地方
減少代碼的複雜性和可能清除漏洞
這也應該不會讓你感到驚訝我們給你這個建議
GCD對象它的真實目的是被同步地使用
遵循完全相同的模式
讓我們以那種方式看待GCD對象
所以我們要記住第一步是設置
給調度對象設置是你可以做的所有事情
當你創建對象 所有你可以傳遞的屬性
Matt前面已展示過標籤和隊列屬性
在這裏 我們也有一個調度資源
我們觀察文件描述器 它獲得一些屬性
資源也有句柄
特別是代碼中的事件句柄
當你在你的觀察中發起的資源時它會運行
那是事件等待
對於我們這裏擁有的資源那是當有可用的數據的時候
一旦你設置好了你的對象它已經準備好了
你想要試用它和激活它
在這個新版本中 我們做了改進
對於API調用 調用激活
它曾經是用於調度資源
初始摘要就是那個意思
我們實際上暫停和激活作爲兩個不同的概念
在重啓激活中可以被多次調用
它只會執行一次
協議是當你已經調用了激活
你再也不會改變你的對象的屬性
我們也發現以你使用資源的方式創建隊列
創建時讓它們在初始化處於非激活狀態是很有用的
我們一家增加了一個新的屬性讓你這麼做
這被命名爲initiallyInactive
一旦這個隊列被創建了你可以傳遞它 結束
以你喜歡的方式配置它 最後激活它
調度對象中的很多都不需要顯式的作廢
比如組或者隊列
因爲你停止使用它們的時候它們就會變成非激活狀態
這是非常不同於資源的資源有顯示的作廢
它叫做Cancel
資源的取消就是做了你期望的事情
那就是你停止從你檢測的東西中獲取事件
但這不是它所做的唯一的事情
它所做的第二件事是
如果你在你的資源中設立了一個取消句柄
比如這裏
它會在取消時運行在一個隊列目標上
這實際上就是你想要擺脫的資源
你在監測它 比如關閉文件腳步
幀內存
最後但不是最不重要的一個
對資源的取消時當你的句柄被銷燬
句柄就是關閉
它們獲取對象甚至是資源自己
它們可以是讀取過程的一部分
調用取消是你們破壞那讀取循環的方式
這是爲什麼始終取消你的資源是那麼的重要
所以你記住前面所說的一點我們增加了很多預設條件
在我們的代碼中 因爲我們想要確保
同步使用的對象永遠是以你可以期待的方式被使用
調度也是一樣的
期待當你的對象被取消分配了
它是在一個不同的狀態
調度期望你做兩個事情
第一 你的對象是激活的第二 它們不是被暫停的
爲什麼它是暫停或者是非激活的原因是
意味着你作爲一個開發者
不要認爲運行與其相關的代碼是安全的
但是我們需要運行代碼來擺脫這個對象
好了
今天我們看到了你可以如何以數據流的方式思考你的應用
和你應該如何使用它來將其劃分爲相當獨立的子系統
使用值類型達到交流的目的
如果你需要同步狀態
我們也向你展示了你可以怎麼使用調度隊列來做這個
最後 當你有對象 它們是被使用過的在一個同步性非常強的世界
如何使用激活和作廢來使得這個模式正確
這是一個鏈接它向你們展示更多與這個演講相關資源
一些相關演講 若你對調度感興趣
你們應該看看 因爲它們非常的有趣
就是這樣這就是使用GCD進行同步編程