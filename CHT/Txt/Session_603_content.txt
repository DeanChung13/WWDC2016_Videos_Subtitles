採用Metal技術 第二部分
大家好 歡迎來到全球開發者大會
希望目前爲止 你們都過得很愉快
你們已看過很多優秀的演講
我們爲你們準備了非常棒的一週
會非常有趣的
我是Matt Collins
這是我的同事Jared Marsau
我們將爲你講解採用Metal技術 第二部分
這裏是603號演講
如果你走錯了 你也能看到一些圖像
所以 讓我們回憶一下
我們共有兩部分“採用Metal技術”演講
希望你們也參加了Warren的第一部分演講
第一部分我們講解了基本概念：
基本繪圖 光照 紋理諸如此類的優秀功能
在本次演講中 我們會更上一個層次
我們會繪製很多對象
我們將會講解如何管理動態數據
大量的動態數據
GPU-CPU同步
我們將會以多線程編碼的話題結束
明天我們還有精彩的演講
我們會講解Metal的新特性
明天的第一個演講將講解細分曲面 資源堆
無記憶幀緩衝
和關於我們改進後的工具
以真正幫助大家做出最好的應用
第二部分 我們將要討論函數專用化
以及函數資源讀寫
豐富的色彩和紋理資產
此外還有Metal性能着色器
如果你還想繼續深入
我們還會有關於高級着色器優化的精彩討論
着色起性能基礎 調整着色器代碼
及更多關於硬件工作原理的細節將會十分精彩
如果你對調整着色器代碼非常感興趣
想讓它們達到最佳效果請關註明天的講座
這裏是採用Metal技術的第二部分
我們將在第一部分的所學基礎上繼續
我們弄清楚如何啓動和運行
讓我們看一下你所需要的概念
能讓Metal在真實世界得到最大的應用
我們有一個演示將會把很多內容繪入一個簡單的場景
在今天的演講中我們都會使用該演示作爲上下文
並從中學到很多內容
我們將會講解數據的理想組織流程
如何管理大批量動態數據
CPU和GPU同步的重要性
以及如我之前所說 一些多線程編碼
希望你已對Metal的基礎有所熟悉
因爲我們不會再次講解
我們預設你已經理解如何新建Metal隊列
新建Metal命令緩衝如何編碼指令
我們在此基礎上進行下一步
我們先來看演示看看我們的目標是什麼
現在我們有10,000個立方體
它們都在四處旋轉 在空中加載
很有趣的畫面
Metal允許我們展開無數繪圖調用
開銷卻很小
所以在此有10,000個立方體和10,000個繪圖調用
你可以看到在底部 有一點陰影
我們正使用一個陰影映射
它被放在底部是一些美觀的反鋸齒線
產生一些深度暗示
當然是所有的立方體
所以怎樣才能渲染這樣的畫面？
我們有很多對象
每一個對象都有自身相關聯的唯一數據
我們需要位置 旋轉和顏色
每一幀都必須要更新因爲我們在動畫顯示它們
所以這是我們不斷在改變的一組數據
不斷重新通知GPU我們正在繪製什麼
我們還可以繪製更多的對象
還可以再多一點
你可以把它們轉動起來
看到它們正漂浮在空中
所以我們有一個立方體的繪圖調用和相關數據
我們得想想該如何更好地思考這些數據
如何管理它們
以及如何讓它和GPU通訊
讓我們深入看一下
謝謝你 Jared
管理動態數據
這是每一幀都在變化的大量數據
可以想像 在一個現代應用裏比如一個遊戲
你也需要每幀都要更新的大量數據
所以我們的繪圖基本看上去是這樣
我們想遍歷所有在繪圖中感興趣的對象
並更新它們
然後我們想爲每一個對象編碼繪圖調用
然後我們必須提交所有這些GPU指令
我們有很多對象
我們從10,000個開始 不斷增加
直到10萬 20萬個
每一個對象都有自己的數據集合
我們要找到更新數據的最好方法
過去 你可能做過類似這樣的事情
你把更新好的數據推送到GPU
可能是統一形式或其他
綁定一個着色器 一些緩衝 一些紋理
然後開始繪製
然後你推送更多的數據
綁定着色器 緩衝 紋理
繪製下一個對象
在我們的場景裏 重複1萬 2萬次
但是我們想跳出這樣的模式
嘗試新的方法
如果我們可以預先加載所有數據
所有發出的指令 以及數據引用都已經存在
GPU是一個非常強大的處理器
它不願意等待
如果所有數據都已經就位只需把GPU指向它即可
它會很高興地開始處理
爲我們處理所有的渲染
我們發出的每一個繪圖調用
都可以引用合適的數據都已經存在了
在我們的示例中 這一切很簡單易懂
我們有一個繪圖調用 引用了一組數據
第一個繪圖調用引用第一組數據
第二個 第二組 依此類推
但並不是隻有這種方法
實際上可以重複使用數據
我們有一些數據如前面的這些 幀數據
可以從所有的繪圖調用中引用
或者 我們可以有一個繪圖調用
在不同的地方引用兩組數據
如果你熟悉實例化的概念其理念是很相近的
開始渲染的時候所有的數據已經準備好
Metal是如何做到的？
在我們的應用裏新建一個單一Metal緩衝
這是我們的常量緩衝
它擁有我們需要用來渲染框架的所有數據
我們想事先就新建好 在渲染循環之外
並且在每一次繪製中重新使用
我們不需要複製任何數據
再次強調任何繪圖調用可以引用任何數據
所以沒有必要複製
每一個繪圖調用都會把一個偏移引用到緩衝
它會作一小部分跟蹤處理從而知道哪個繪圖代表了哪個偏移
你可以運用一切繪圖 一切都已經就位
我們來看看這部分代碼
這是應用裏的代碼
你可以認爲我們有兩個數據集合
如我之前所講 有一個幀數據集合
將在這裏進行更新
這是每個對象都發生改變的數據集合
這是唯一旋轉位置 等等
我們需要把兩組數據都準備好
我所說的每幀數據是什麼意思呢？
這是每次進行繪圖調用時都保持一致的數據
比如 在本例中 有一個視圖投影矩陣
這是個4X4的矩陣 很直觀
如果你熟悉圖像處理
它代表了照相機變換和投影
在框架範圍內將不會發生改變
所以我們只需要一份副本
我們想要儘可能多地重複使用數據
所以我們新建一個副本 放入緩衝內
開始填充
在這裏 是常量緩衝
也就是新建的Metal緩衝
通過Contents函數我們有了一個指向它的指針
我們的應用有一個幫助函數也就是取出幀數據
它將返回我剛演示過的主通路結構
裏面有視圖轉換
視圖投影轉換不好意思
之後只需簡單地把它複製到緩衝的前端
然後一切就緒
我們的緩衝看上去將會是這樣
我們有一個主通路 含有合適的幀數據
並且把它放到巨大的常量緩衝的前端
所以後面會有這一片空白區域
如之前所見我們需要做1萬次 2萬次的繪圖調用
所以需要開始在裏面填充很多信息
然後我們有了一組每個對象數據
這是繪製單一對象所需要的唯一數據
在我們的例子裏有一個“局部空間到世界空間”轉換
它是位置和旋轉的串聯
還有顏色
這就是每一個繪圖調用所需的數據集合
我們會遍歷想要渲染的每一個對象
記錄偏移位置到緩衝
我們有“更新數據”實用工具函數
它將更新旋轉數據
然後更新偏移數據
這樣將數據緊密封裝一邊遍歷一邊填充
看看“更新數據”函數是什麼樣子
它非常簡單
動畫效果似乎不是本次演講的範圍
有一個小幫助函數 “更新動畫”函數帶有“增量時間”參數
在你的應用裏可以按照自己的意願編碼
而且確實應該這樣做
但是也要看你需要什麼樣的動畫
在我的例子裏它返回一個對象數據對象
它有局部空間到世界空間轉換和顏色
和之前一樣 把它複製到常量緩衝
看上去是這個樣子
幀數據已經準備完畢
還有別的數據
其他的數據 還有其他的
所有的數據都到位了 我們準備好渲染
但是不是還缺了點什麼？
確實缺了什麼我想要提醒你們注意的是
我們有一個常量緩衝
我說過新建一個Metal緩衝然後反覆使用
這樣做有一個問題
CPU和GPU實際上是兩個不同的平行處理器
它們可以同時對同一內存進行讀寫
會發生什麼 如果有函數
正在讀一塊內存 而另外有函數在寫？
資源爭用
看上去有點像這樣
CPU準備好一個幀數據寫入一個緩存
GPU開始處理
它從緩存裏讀取數據
而CPU對這一切一無所知
它決定 我要準備下一幀數據
然後它開始覆蓋相同的數據
現在結果變成未定義
我們不知道讀入了什麼
讀出什麼 或者寫入什麼數據狀態會是什麼
所以認識到在Metal裏這不是隱式處理 這點很重要
CPU和GPU可以隨意同時寫同樣的數據
必須自己同步訪問權限
就好像編寫多線程的CPU代碼
必須得確保沒有踩到自己
這把我們帶到了CPU-GPU同步的主題
讓我們從簡單的開始
最簡單的方法就是 等待
把指令提交給GPU之後
CPU繪圖函數做好所有的工作
提交指令 然後就坐在那兒等
直到它確保GPU的工作完成
這樣我們就知道永遠不會覆蓋
因爲我們試圖生產下一幀數據時GPU是空閒的
這種做法不夠快 但很安全
所以需要有某種機制讓GPU通知我們
嘿 我工作完成 你開始做你的吧
Metal提供了這種機制以回調的形式
我們稱爲處理程序 其中兩種很有意思
“添加計劃處理程序”
當命令緩衝被計劃在GPU上運行時將執行該處理程序
對我們來說 更有意思的是“完成處理程序”
它將被調用
當GPU結束執行一個命令緩衝時
命令緩衝完全退休時
此時我們確定修改任何資源都是安全的
正在使用的任何資源
這樣非常完美
我們只需要採用某種方法告訴自己
嘿 我們完成了 繼續下一步
你們當中有多少人熟悉信號量的概念？
有誰知道？
很好
快速介紹一下信號量的背景
它們是同步基元
被用來控制有限資源的訪問權限
應用在此堪稱完美
我們有一個常量緩存它是一個有限資源
我們將會新建一個信號量 初始值爲1
信號量的值代表
有多少想要保護的有限資源
新建一個信號量
它應該建立在渲染循環以外
一旦開始繪圖 第一件要做的事情
就是等待信號量
Apple裏的信號量稱爲“等待”
有人稱它爲“佔據”有人稱之爲“倒數”
無關緊要
理念就是等着它
把超時設置爲遙遠的未來
也就是說我們會永遠等待下去
如果沒有資源可用 線程會進入休眠
等着做點什麼
我們結束後
在完成處理程序裏 我們會通知信號量
那將會告訴我們 修改資源又安全了
工作已全部完成 可以進行下一步
這是一個有點幼稚的同步方法
看上去有點像這個樣子
我們會把幀數據0寫入緩衝
GPU從緩衝讀取
CPU將會等待
當GPU處理完幀數據0
它將發送完成處理程序幀數據1開始工作
並將在CPU上新建一幀數據
GPU上會對其進行處理 依此類推
這種方法可行 但如你所見有這麼多等待時間
CPU和GPU實際上都有一半的時間處於空閒
看上去並沒有好好利用計算資源
我們想要做的是重疊CPU和GPU的工作時間
這樣就可以利用系統固有的並行機制
但還是需要想辦法避免踩到數據
所以我們理想的工作量看上去是這樣
第0幀將會在CPU上做好準備推到GPU
當GPU處理它時
CPU開始新建幀數據1 等等反覆如此
在此謹記一點
CPU實際上要比GPU超前一點
請注意 當幀數據2在CPU上時
GPU上只有幀數據0是完成的
所以CPU有一點超前
也請你一直記住這點
來看看演示裏的解決方案看我們是怎麼做的
我們想要重疊CPU和GPU但我們知道無法做到
用一個常量緩衝 而不等待很長時間
所以解決方案是新建一個緩衝池
所以新建幀數據0
把它寫入一個緩衝
然後CPU開始工作
新建下一個幀數據 寫入另一個緩衝
此時 GPU可以自由從緩衝中讀取
之前的那個緩衝
我們沒有無限的緩衝
因爲沒有無限的內存
所以緩衝池必須得有個限額
在我們的應用中 我們選擇了3個
這部分你得自己決定
我們無法告訴你怎麼做
因爲要考慮延遲的問題
想要用多少內存
所以我們建議你測試自己的應用瞭解多少是最合適的
本例中 我們選擇3個
在這裏 可以看到緩衝池用完了
我們準備好3幀數據
但GPU只處理完成了一幀
所以得等一會兒
現在 幀數據0已經完成
所以可再次使用池裏的緩衝 如此繼續
來看一下代碼
同步常量緩衝的訪問權限
我們已經有了一個信號量
它可以很好地控制有限資源的訪問權限
在本例中 我們的限制是3
但這個數字可隨意設定
在這裏按照限制數字新建了一個信號量
我們不再只新建一個常量緩衝
而是新建一個緩衝數組
最後
需要一個索引
我們用這個索引表示
當前可用的常量緩衝數
我們可以遍歷數組並回返
信號量會控制我們的訪問權限和保護我們
所以在繪圖函數裏我們會立即等待信號量
如果沒有可用緩衝 就進入休眠
一旦取得信號量 就開始工作
我們知道獲取當前的常量緩衝是安全的
在索引中 “當前常量緩衝”記錄哪個資源可用
然後正常填寫幀數據 編碼所有命令
進行更新 添加完成處理程序
然後我們通知信號量說嘿 該幀數據處理完了
你可以進行下一步了
最後要做的是更新索引
我們加上1 我們取模進行環繞
我們不用擔心覆蓋自身
因爲信號量會保護我們
這就是演示中的常量緩衝
演示裏有一個3個緩衝的數列
但我也看過有些應用會跟蹤緩衝
把它們標記爲該緩衝正在被幀數據7讀取
該緩衝正在被幀數據5寫入
在本模式下 我們不需要這麼做
信號量爲你做所有同步的工作
而且如果你取得了信號量
你可以確認最後正在使用該資源的幀數據已經結束
否則你還會處於休眠
所以現在數據都已經準備好並且受到保護
我們想要發出一些繪圖調用
在屏幕上顯示一些圖像
這就是本演示的基本渲染循環
我們有兩個通路：一個通路繪製陰影映射
一個通路讀取該陰影映射
我們決定把它們分成兩個獨立的命令緩衝
這樣做有一個很好的理由
它讓我們有兩個編碼函數
是獨立和唯一的
它們不依賴於彼此
你編碼陰影通路 你把它傳到命令緩衝
以及你已經填寫的常量緩衝
它會編碼所有的命令 渲染陰影映射
然後你有了一個獨立的編碼函數可以編碼主通路
把它傳到主命令緩衝以及其他所需數據
編碼所有其他的命令
編碼結束時
調用提交兩個命令緩衝
輸出 幀數據處理完畢
那麼 如何真正編碼繪製其中一個立方體？
我們需要一組數據而不僅僅是旋轉數據
我們需要立方體的一些幾何數據
這非常簡單 你知道
把立方體想成是8個頂點也許還有一個索引緩衝
在本例中 我們不需要任何複雜的材料
只需用到很簡單的漫反射着色
因此我們可以重複使用管道狀態對象
在所有立方體範圍內
我們之前提到過每幀數據
我們需要它的一份副本
我們更新它 準備好
當然我們還需要 每光學數據
以及我們動畫裏展示的 LocalToWorld和顏色信息
所以當發出繪圖調用時
我們想確保引用了正確的數據
所以編碼器會產生命令
把它們放入命令緩衝
繪圖調用0
將會引用幀數據和我們感興趣的對象
繪圖調用1 同樣 將會引用幀數據
和對象1數據 依此類推
這樣一切都會準備好
發出調用 GPU開始處理
現在我們有很多調用要發出
你知道 在演示中 至少有1萬個
我們想盡可能高效地發出調用
我們想避免重複的工作
不想每一次繪製就進行重設
所有共享資源 幾何 管道狀態
我們只想設一次 然後保持
這樣就可以避免重複的狀態更新
並且避免重複的變量表格更新
還有一點值得注意
頂點和片段變量表是完全分開的
你可以將緩衝綁定在頂點階段
而不是片段階段 反之同理
但若必須要把所有綁定到兩個階段
調用“設置頂點緩衝”函數時可能會調用兩次
“設置片段緩衝”函數也是如此
這就是爲什麼在本例沒有使用“設置頂點字節”函數
你可以想像我們有50,000個對象
必須把所有那些數據複製兩遍
一遍在頂點階段 一遍在片段階段
很快工作量會變得很大
而如果把所有數據放入一個緩衝只需引用它
我們就不用擔心該問題了
最後我想指出的是
使用新函數
“設置頂點緩衝偏移”和“設置片段緩衝偏移”
這只是把指針指向其中一個緩衝
可以看到 在調用這些函數時
它們並沒有把引用放入Metal緩衝
它們只取出了一個偏移和一個索引
因爲你肯定已經設置該指針指向緩衝
這樣緩衝內部的指針也隨之改變
這就是我們想要實現的
我們有一個常量緩衝 正在遍歷
所以可以在一開始只設置一次
然後每一次繪製時就調用“設置頂點緩衝偏移”函數
並且把下一個繪圖調用指向緩衝中正確的位置
看上去有點像這樣
綁定該常量緩衝
然後調用“設置頂點緩衝偏移”函數
用該偏移量作爲參數
然後再次調用 繼續往前
再一次往前
我們並沒有修改該索引指定的緩衝
我們只是修改了緩衝裏的偏移值
記住這些原則
編碼其實非常簡單
可以事先設置好一組數據
每幀常量是很顯然的
因爲我們知道會修改它
所以一起來設置
我們將一次設定常量緩衝因爲它必須要準備好
我們才能使用設置頂點緩衝偏移函數
還會設置幾何緩衝 和管道狀態
我們知道整個立方體範圍內它們是共享的
然後終於可以開始循環通過想要繪製的對象
設置當前繪圖調用
常量緩衝的偏移值
然後我們真正開始繪圖
這裏是 "編碼主要通路"函數的代碼
在例子裏的
首先設置頂點緩衝
那是幾何和渲染管道狀態
也就是光照陰影管道
我們將會設置常量緩衝
在之後調用“設置頂點緩衝偏移”函數
在本例中把它傳給頂點和片段階段
然後設置每幀數據
你現在看到我已設置了一個常量緩衝
有兩個分開的索引 和不同的偏移
Metal允許你隨意這樣做
可以把同樣的常量緩衝設給每一個索引
帶有不同的偏移 如果你願意的話完全取決於你
接下來馬上看看緩衝池
我們需要追蹤偏移 因爲我們不是
在常量緩衝的開始部分開始的
還有一些幀數據在那裏
所以偏移將會被推回 經過幀數據
然後將調用“設置頂點緩衝偏移”及“設置片段緩衝偏移”函數
來把該繪圖調用指向要繪製的正確數據
發出繪圖調用
然後再次設置偏移 一次完成一個對象
繪圖都準備好了
這仍然是非常線性
我答應做一些多線程編程
並且Warren提過
可以在Metal裏進行平行編碼
該怎麼做？
一個理想框架看上應該是這樣
渲染線程正在埋頭苦幹然後它意識到 嘿
我得渲染一個陰影映射還得渲染一個主通路
要是我能並行編碼就好了
我有很多CPU
如果能調度一些工作出去進行一些編碼
然後回來繼續參與渲染線程
然後渲染線程把它推給GPU
讓GPU做接下來的工作
這種方法一定非常好
你們中有多少人用過GCD（大中央調度）？
此時非常適合使用大中央調度
大中央調度是Apple的多處理API
該API讓你新建隊列
這些隊列管理計算資源
在你的機器上
可以新建兩種類型的隊列
一種是串行隊列
當你通過串行隊列調度工作時
可以保證所有工作都按照順序處理
但對我們來說更有意思的是併發隊列
當你把工作調度給併發隊列
大中央調度會查看系統
爲你做出最好的安排
這非常完美
我們有兩個需要並行的作業
所以我們新建這一個隊列把工作推送給它
它會幫我完成
有另一個對象你想新建一次並可以重複使用
這裏是一些新建併發調度隊列的代碼
你應該始終爲隊列加上標籤
在此我使用了非常具有創造性的標籤隊列
但你也許想稱呼它別的名稱
所以我們修改了部分代碼
一開始還是新建命令緩衝
但是既然我們如此聰明會使用兩個命令緩衝
並把編碼函數分成兩個不同的函數
我們除了調度工作外沒什麼別的事情可做
所以dispatchQueue.async
是大中央調度中用來調度工作的主調用
這是一個異步調用
它將推送工作 線程將會繼續
在這裏我們調度了陰影通路
然後我們調度了主通路
我們得想辦法提交該工作
所以我們調用“調度障礙同步”
這將確保此時所有的工作都已經完成
最終我們重新加入 提交工作
在這裏 順序是很重要的
陰影映射必須在我們要引用的時候完成
所以必須首先提交陰影命令緩衝
之後是主命令緩衝
在這裏我還想提出一點
你們之中有多少人熟悉“閉包”的概念
很好
有多少人曾經在閉包捕獲自身時遇到過問題
你以爲自己在引用別的？
你們可誠實作答我們都會發生
我只是想提出這一點
閉包捕獲自身
如果你正在引用一個成員變量或其中的成員變量
而你並沒明確指定self.iVar
它還是會引用那個變量
如果你想確保引用正確的數據
在外部捕獲它是一個好方法我將會馬上對此進行演示
這兩樣東西做的事情不一樣
第一個調用中 編碼陰影通路的地方
可以看到正在獲取的常量緩衝
獨立於self.constantBufferSlot之外
我實際上並不知道它執行時會怎麼樣
這是真正的異步編程
所以當調度正在運行時
它已經揹着我發生了改變
也許是對的 也許不對 我無法保證
所以請謹記這點 不要那樣做
相反 我們想捕捉一個引用
到我們感興趣的常量緩衝中
所以在這裏 取出常量緩衝
把它從數列裏拿出去
然後再發出調度
引用已經獲取的緩衝
這樣就能保證確切知道讀取的是哪個數據
這就是多線程編程的趣味
示例中的實際代碼看上去是這樣
捕捉常量緩衝
當使用它時 保證用的是正確的那個
是已經捕捉的那個
知道正在使用該幀數據的常量緩衝
我之前提過“排序”以及它非常重要
當新建一個命令緩衝 提交
GPU上執行的順序
通過你提交到GPU上的順序來表示
所以如果先提交陰影命令緩衝
再提交主命令緩衝
可以確保在GPU先執行陰影
接着再執行主命令緩衝
有時我們把這稱爲 隱式命令緩衝排序
但是可以變得顯式一點
Metal提供了“排隊”函數
強制執行命令緩衝排序
如果有一組命令緩衝 可以把它們排隊
這樣可以確保它們按照那個順序被執行
不論提交方法和提交時間
這是非常酷的方法 因爲它允許你
從多重線程上提交命令緩衝按任何順序
而你完全不用爲此操心
運行時將會確保運行順序是正確的
我們來看看如何在代碼裏實現
新加了一些內容
當新建命令緩衝時
馬上按照順序把它們排隊
順序很重要
所以我們還是會讓陰影命令緩衝先排隊
然後是主命令緩衝
但是現在 當我們調度時
我們可以從別的線程上提交
再次強調 運行時候將會確保
順序正確
所以我們不用爲此擔心
這實際上移除了之前的障礙
因爲不必重新加入 再提交命令緩衝了
它們已經自己提交了
我似乎跳過了所有的同步內容
不久前我剛說起過
我們還是需要了解 因爲我們還是
會自我覆蓋 如果我們不同步的話
所以能否把同樣的同步原理
應用到這個多線程世界？
答案是可以 並且實際上它非常直觀
回到友善的信號量 還有常量緩衝數列
記住取出你想要的正確緩衝
一開始 等待信號量如果沒有可用緩衝就進入休眠
我們已用排隊強制執行了順序 推出去
我們知道 主命令緩衝是框架裏最後的命令緩衝
且我們知道要通知幀數據已經處理完畢
所以應把完成處理程序加到主命令緩衝
可以在調度內部完成
主命令緩衝是最終命令緩衝
我們爲它添加上完成處理程序用來通知信號量
在調度內部提交它 如之前所做的那樣
現在你可能注意到我引用self.semaphore
不久前我剛告訴你要注意這點
所以發生了什麼？
結果是信號量是一個同步圖元
我們確實想要用同一個
和所有其他線程一樣
所以需要知道信號量的值
在線程正在執行的時候
所以在本例中確實需要self.semaphore
需要時刻注意
這是渲染的方法
在渲染函數的開始 等待信號量
選擇併發常量緩衝
把數據寫入常量緩衝
也代表了所有的對象
把命令編碼到命令緩衝
可以單線程編碼也可以多線程 隨你所願
在最終命令緩衝裏加上一個完成處理程序
用它來通知信號量 完成時通知我們
然後提交命令緩衝
GPU接過所有
開始處理幀數據
我們再看看演示 看看最後呈現結果
可以看到在左上角這是單線程編碼模式
可以看出正在進行多少繪圖調用 10,000個
右上角 可以看到編碼一個幀數據的時間
我們看到是5毫秒
我們可以增加繪圖的數量
繪製的東西越多 時間越長
這就是單線程模式
你們想想看 我們在繪製一個陰影映射
也就是說必須在陰影映射內發出40,000個繪圖
當繪製主通路時意味着我們必須再發出
另外的40,000個繪圖來引用
但是再次強調 我們可以併發操作
所以在演示裏 加了一個並行模式
可以看到速度有多麼快
看一看正在發生的一切
你可再讓它們飛起來一點
在這裏 我們有4萬個立方體獨一無二 各自分離
它們隨時都在更新
我們使用大中央調度並行編碼了許多內容
我們有兩個命令緩衝
一個產生地上的陰影地圖
一個爲所有的立方體渲染上色
光照很簡單 即漫反射着色 基本上是
沃倫之前說過的N.L光照
這就是我們的演示內容
這些都會作爲示例代碼 供大家參考
希望你們可以把它拆開取得其中的一些想法
和思路並且能夠應用到自己的代碼當中
所以我們今天講了什麼？
你們走進來的時候
希望你們也聽過沃倫的演講
可能稍微瞭解一點圖形的知識
或者以前有相關編程經驗
但帶你們一起了解了Metal裏的一切
Metal的概念性的概覽它的相關原理
是運用API 和硬件相近的API
及和驅動相近的API
我們學習了Metal設備
即Metal的根對象也是一切的來源
稍微討論了加載數據到Metal
以及不同的資源類型 和如何使用它們
Metal着色語言 即C++的變體
可以在GPU上編程
我們討論了建立管道狀態
事先驗證過的對象 包含兩種函數
頂點或片段 或某個計算函數
和其他在預先驗證狀態的對象
能在運行時節省時間
然後我們討論了發出GPU命令
創建Metal隊列創建該隊列的命令緩衝
還有創建編碼器填入命令緩衝
然後該工作發送給GPU
我們帶你瞭解了動畫和紋理
以及使用設置頂點字節 發送小位數據
以支持動畫效果
之後當小位數據不夠時
我們講解了管理大批量動態數據
使用一個大常量緩衝以及在不同的地方對其進行引用
在系統外反覆使用數據
我們討論了CPU-GPU同步以及確保
CPU和GPU不彼此覆蓋
及互相協作的重要性
最後
我們討論了一點關於多線程編碼的內容
你如何利用Metal的大中央調度編碼多命令緩衝
同時編碼隊列中的所有緩衝
這就是採用Metal技術
希望你喜歡本次講座
也希望你把其中一部分應用到自己的應用裏
讓應用變得比現在更好
如果想了解更多信息 可以訪問網站
developer.apple.com/wwdc/603
明天我們還有更多的演講我大力鼓勵你們能夠參與
上午11點有“Metal的新特性 第一部分”
晚些 下午1點40分有“Metal的新特性 第二部分”
這兩個講座將告訴我們Metal世界裏所有新特性
你可在應用里加入很棒的內容讓應用更優秀
之後 爲了你們當中的着色狂人
下午3點有“高級Metal着色器優化”演講
如果你想知道如何更好地利用着色器
我建議你們參與該話題非常棒的演講
感謝你們前來聽我們的講座
歡迎來到全球開發者大會希望你們剩下幾天過得愉快
再次感謝