深入系統追溯
早安 這是演講411“深入系統追溯”
我的名字是Chad Woolf
我是Joe Grzywacz
我們是Apple的性能工具工程師
去年的“深入”演講中我們談了時間分析器
我們向你展示瞭如何分析你的應用直到反彙編水平
我們的目標是向你展示如何使你的代碼變得儘量迅速
有時你也許想讓你的優化代碼運行在多個CPU上
以完成更多工作
但這麼做的同時會增加系統負荷
隨着系統負荷增加
一些次級反應開始顯現例如搶佔的增加
鎖競爭和虛擬內存活動
這三者任何一個都足以抵消
你通過時間分析獲得的優化
在今天的演講我們展示如何通過系統追溯
分析次級反應
我們也會展示如何有效地加載系統
同時維持最佳性能
我們今天的演講是這樣的我們會談到一些關於系統追溯的內容
以及爲什麼它適用於應用開發者
之後我和Joe會帶你瞭解系統追溯
我們會談到線程 指示
一點關於虛擬內存的內容
以及展示一些最佳實例告訴你如何儘可能利用工具
爲何應用開發者需要系統追溯？
當你的應用成爲設備的焦點
從用戶的角度 它就是系統
他們不把你的應用與全部這些系統服務和守護進程相等同
共同爭奪共享資源如CPU時間和內存
他們只會看到你的應用
如果你的應用出現卡頓因爲緊張的虛擬內存活動
或是因爲錯誤優先的線程
他們會找你以尋找解決方案
這就是壞消息
好消息是
當你的應用成爲設備的焦點
它是整個設備最重要的
操作系統知道這一點
它會毫無保留儘可能多地分配給你CPU時間和內存
當我們談到通過系統追溯優化
我們不是指優化系統而是優化你的應用
使用分配所得的資源
系統追溯是Instruments的模板之一
它可以在我們全部四個平臺完美運行
當你使用它記錄
它把內核設置成特別的追蹤模式
記錄全部調度活動 系統調用
以及發生的虛擬內存操作
它會隨時間累積產生大量數據
所以我們對Instruments 8的改進之一
是我們把模板默認地設置成Windowed Mode
這代表我們只保留前五秒左右的數據
優勢是
你可以開始記錄 設置你的應用
隨便花多久時間來複現性能問題
當它復現 按停止鍵
然後你得到了前五秒的可行動數據
這是這五秒數據可能的樣子
追溯記錄會很密集
我們發現它會很有用如果你可以把這數據
和你的應用裏的高級活動相關聯
比如我是否在更新表視圖
後臺是否在進行下載
我是否在更新圖表這類高級活動
今年在Instruments 8我們新增了
興趣點工具
興趣點工具其實是一個空白的畫布
你可以告訴Instruments你感興趣的地方
然後我們會爲你把它放進圖表中
通過你的代碼中使用Signpost來實現這一功能
Signposts已經發布一段時間了
不過以往的使用方法是調用這個直接系統調用
從頭文件提取這些宏
然後把它們放在一起 這有點臃腫
不僅臃腫
在今天的Swift世界裏它甚至無法運行
我們會拋棄這個方法
不過在新的操作系統裏我們增加了這些新的函數
它們的功能完全一樣kdebug_signpost
它們可以在CObjective-C C++運行
現在還可以在Swift裏運行
首先 最簡單的方法是把一個點事件放入時間軸
就是這裏的紅色標誌
你要做的僅僅是調用kdebug_signpost
在我們的Mouse Down事件中每當我們點擊Mouse Down
你會看到時間軸上出現一個標誌
它接受一些參數第一個是代碼
它只是一個0到16383之間的整數
用來幫你確定Signpost
另外四個參數也是整數可以是你想要的任何數值
默認情況下 Instruments會把它帶到UI
現你可命名這些東西
切換到Instruments的配置部分
然後加入到表視圖
現在代碼5代表Mouse Down
下次當我記錄時
我可以看到那些興趣點變成了Mouse Downs
如果你喜歡興趣點工具你也會喜歡興趣區域工具
它們基本上是一樣的只不過它們用來記錄狀態和動作
或是發生在一段時間裏的事件
它稍微複雜些因爲你需要兩次調用而非一次
你有一個開始和一個結束
在Instruments裏還有一個配對規則
默認情況下規則很簡單只是使用代碼
你只需要
在開始和結束提供相同的代碼
我們知道這不適用於所有應用
因爲有些應用會產生一堆開始事件
緊接着一堆結束事件
這會導致...在Instruments內
如何把它們配對會模糊不清
所以我們允許你改變配對規則
來到設置頁
你可以選擇代碼和第一參數或是代碼和線程
代碼和第一參數代表你的開始和結束
需要有一樣的代碼和第一個參數
在這個例子中我們並行開始了一堆URL下載
我們用了URL下載任務指針
作爲第一個參數你可以看到
Instruments時間軸上的這些並行下載
如果你使用代碼和線程
你必須讓
相同代碼的開始和結束在同一個線程上產生
這是一個例子
不過你可看到它發生在dispatch_apply塊內
現在我們的圖表裏有四個興趣區域
每個線程或工作線程一個
目前你看到的興趣區域都是紅色的
非常單調
如果你願意犧牲最後一個參數
你可以來到這裏
勾選這個方格用最後的參數代表顏色
在你的第四個參數你只需提供
0到4之間的數字
代表Instruments裏的五個基本顏色
在這例子中
當我的下載任務成功
我把它設置爲綠色
如果完成時產生了錯誤我把它設置爲紅色
這樣可以清楚地區分成功和失敗
我們把這全部放在一起
你可以看到這是多麼簡單
把我之前展示的巨大複雜的追溯數據和你應用中的高級活動關聯起來
比如 你可以看到這一堆活動其實是
我們的下載任務創建的
我們來說說今天的演示應用
今天研究的是我們給你們寫好的一款叫做Graphasaurus 2的應用
它是去年演講中Graphasaurus的靈魂繼承者
和去年的演講一樣我們會研究現實的問題
這是我們優化Instruments 8時遇到的問題
我們決定把它們放進一個iOS應用進行演示
這是一個新的圖形風格
更像你在Instruments所看到的狀態界面的風格
因爲這是我們今年優化的東西
另一個和去年不一樣的是
我們會假設我們的代碼已被時間分析了
它已經是在目前條件約束下最優的了
和去年一樣 圖表的生成
通過Core Graphics在CPU上進行
我們首先要做的是初始計時
我們發現生成全部四個圖表
總共會花費20毫秒
這是在全部放大的最壞情況下的
它超過了16毫秒的限制
如果我們想達到每秒60幀
我們決定需要引入些並行運行
因爲我們知道
四個圖表可以各自獨立生成
最壞情況下需要5毫秒
如果我們把所有任務放到dispatch裏
我們有完美的擴展性
那麼在我們的雙核iPad上
應該可以把任務時間縮短一半
爲了看看效果如何
向你展示如何使用系統追溯我會交給Joe
好的 謝謝你Chad
你現在看到的是
Quick Time上的鏡像顯示的是我使用的iPad Pro
你看到就像在Instruments裏你可以順暢地滑動
不過當我放大的時候
動畫變得有些延遲
不算糟糕 不過可以更好
我要做的是找出爲何如此
現在打開Xcode
按下並長按Run按鈕並選擇Profile
那會編譯發佈版本的應用
在設備上安裝
然後Instruments會出現
同時還有模板選擇器你可以選擇想要使用的工具
我們繼續 雙擊選擇System Trace模板
在這裏我開始記錄前
我增加了一些kdebug_signpost的起止點
到我的代碼裏
我要設置它們在Instruments裏出現的方式
你需要到右下角
在Record設置裏
開始時 我要用第一個參數設置顏色
我在kdebug_signpost添加了一些不同的數字
並添加了三個不同的代碼
代碼0是CADisplayLink
它是用於驅動動畫的60Hz計時器
基本上這個區域符合我的幀時間
因爲這是我做所有渲染的地方
下一個是代碼1 它是...我稱之爲CreatePath
這是我實際創建CGPath的地方
屏幕上出現的長方形和標籤
最後代碼2叫做RenderGraph
指的是我把那些CGPath
實際渲染成CGBitmapContext
然後在屏幕上顯示
最後因爲我的代碼會並行運行
它們會產生同樣的代碼
我必須告訴Instruments如何分辨它們
這個情況 線程足夠了因爲它們會運行在不同的線程
好的 我完成了全部的配置
我不想每次打開Instruments重複做這個
所以點擊文件目錄然後選擇保存爲模板
設置一個具有描述性的名字
Graphasaurus System Trace按下Save
比如你關閉了這個文件關閉了Instruments
一星期後 你來到模板選擇器
選擇Custom標籤
你的模板就在那裏可供使用
你不用重新設置直接點擊Record即可
Instruments會等我復現問題
所以我會雙指張開 就像你之前看的
張開到產生問題爲止
我只需復現問題幾秒鐘
這樣它可以在視窗緩衝區填充我感興趣的數據
做完後我停止記錄
現在Instruments會從設備下載全部數據
然後開始分析它
因爲這是窗口模式錄製你只會得到最後幾秒的數據
確保在你復現問題後
立即停止記錄
不然 新的事件會出現
擠掉你感興趣的事件
我們等待Instruments完成分析
好了
我們看到有很多東西
我們放大一些這樣就能看到發生了什麼
好的 第一個選擇的工具是新的興趣點工具
隨便放大這裏的一個區域
我們可以看到那些都是我創建的代碼
我看到DisplayLinkCreatePath RenderGraph
如我想的一樣
這有一個大的藍色的CADisplayLink時間
以及四對綠色和紫色的CreatePath和RenderGraph
看起來很好
不過當我移動鼠標到這個部分
你看到一個小工具提示顯示你
你提供的參數和時段
這裏我實際運行了接近30毫秒
是我希望的速度的一半
這可不太好
這還只是一幀我渲染了很多很多
累積起來會是什麼樣子的？
我們看這個詳表
現在顯示的是按時間排序的所有區域的列表
你可以瀏覽這個巨大的列表看看參數等等
我們做了一個表爲你彙總
叫做KDebug IntervalSignposts by Code列表
當我選擇它
這是所有Graphasaurus 2產生的代碼
可以看到這是我的CADisplayLink
我渲染了152幀
它們平均花費28毫秒
所以平均運行並不好
你可以看到最小值最大值標準差之類的
你可以通過代碼旁邊的聚焦按鈕查看詳情
它會給你全部數據的表
這些事件都是我的CADisplayLink事件
在這裏你可以隨意排序
不同參數 任何對你的應用重要的
這裏我根據持續時間排序
我要做的是
選擇中間某個地方的一條數據
我想指出的是當我點擊其中一行
上面的圖表會移動
它會顯示我感興趣的區域
就是這裏
我把藍色視察頭標放在那區域的開端
你把下面點擊的項目
和上面追蹤視圖中它出現的位置關聯了起來
我正在看這一幀
你也可以按住Ctrl點擊那一行並選擇設置時間過濾器
它會把所有詳細視圖中在時間範圍之外的事件變成灰色
上面的跟蹤視圖同樣如此
你可以用它過濾出你要的數據
或者作爲視覺上的提示
現在完成了
我正在看這一幀
我可以看到我的CADisplayLink在此開始
在這裏結束我不知道爲什麼會這樣
它只會告訴你何時開始 何時結束
你不知道你的應用是在運行還是進入了睡眠狀態
從圖表你無法得知
我們必須更深入
在Instruments工具欄的右上角
我們目前在Instruments策略
也就是這個模板裏全部的工具列表
你可以點擊這個線程數據查看你應用中的全部線程
另外
假設我們已經在詳細視圖裏深入查看線程
如果你按着選項並點擊
你會看到這些可以按下的超鏈接
選擇線程策略顯示
它會把你帶到線程策略併爲你預先選擇那個線程
我們可以看到這裏放大它一點
它爲我們選擇了主線程
如果我看這裏還有許多其它的dispatch工作線程
它們正在運行 特別是這兩個
這個和它下面的這個 正在運行很多工作
這些都是那些出現的紅點
如果我按住選項並拖拽以放大其中一個區域
我們其實可以開始看到它們是什麼
通過把鼠標停留在它們上面
這是一個ulock_wake系統調用它從某種鎖被喚醒
這是ulock_wait系統調用它正在某個鎖上等待
如果你一直把鼠標放在它們上面你會看到這個模式一直重複
有很多ulock_wait和waking正發生
如果你點擊鼠標你可以把視察頭標定在那點
如果你來到我們稱爲線程和描述視圖的地方
在這張表的下面 它會給你展示
在我點擊的上面那張圖裏
在這個時刻線程在做些什麼
這是一個顯示了線程做的所有事的列表
線程生命週期的故事
這裏我們可以看到wait調用之一好的 那它是在哪裏產生的？
如果可能 Instruments會生成一個回溯表
串聯這些系統事件
你可以在這裏找到它們
這邊右側的擴展詳情視圖
我們可以看到一些Swift代碼用於創建路徑
這裏其實它是在創建NSAttributedString
好的 在它下面的幾幀裏它在獲取鎖
我沒想到在NSAttributedString裏面會出現鎖
不過確實有
那麼後果是什麼？
回到線程描述視圖
看看發生了什麼
僅僅獲取鎖就花了109微秒
然後我們又被阻塞了6微秒
今年很酷的是 它會給你展示
哪個線程使你的線程可執行
基本上就是釋放鎖的線程以便你可以獲取它
可以看到 一個Graphasarus線程0x8468b讓它進入可執行狀態
好的 我們可以看見就算鎖被釋放了
在我們實際切換回CPU之前還等待了98微秒
我們看看其它線程在做什麼
爲什麼它釋放了鎖？
按下選項點擊它選擇在線程策略中顯示
這會選中上面的那個線程
然後在描述視圖的下面
我們會看到線程那時在做什麼
我們看見它正調用ulock_wake
它正在釋放鎖
合情合理
我們可以看見這兩個線程在並行執行
除了它們正在這個鎖上競爭
它們實際做了很多事情 而不是隻在運行
另一個查看方式是在上面的跟蹤視圖裏
這裏可以看到線程的狀態
我把它放大一點如果你懸停在這個線程狀態
你看見它運行了這段時間 64微秒
然後它被阻塞了一會兒
然後很長時間它處於可運行狀態這代表它其實沒有在運作
最終它得以運行
如果我們繼續查看
我們會看到這個模式不停重複
很清楚的是
這兩個線程正在這個鎖上競爭
在這期間 我創建了很多字符串
如果這佔用了這麼多時間並且這麼重要
爲何我不能在時間分析器裏看到它們
說實話若你回去查看時間分析器它確實出現了
不過僅僅是百分之四或五左右沒有以紅色大旗標的形式突出
一個主要原因是這些線程
很長時間處於被阻塞和可執行的狀態
時間分析器只是採樣真正在CPU上運行的東西
所以它不會在那裏出現
爲了解決問題 我需要意識到
我只是在狀態圖上放了一些屬性字符串
其實沒有那麼多需要顯示的狀態
我應該提前緩存它們
然後在字典上查找它不需要用到鎖
一切都會運行的更加順暢
爲了展示它看起來是什麼樣的
我交回給Chad
好的Joe看到是一個標準的鎖競爭
我們有兩個線程正在執行
它們正在爭奪共享資源
在屬性字符串創建鎖的代碼附近
就算我們只持有那個鎖幾毫秒
性能的折損也遠比那大得多
Joe向你展示了一些不過我還要多說幾句
當你的線程處於執行狀態代表線程在CPU上
它正在全速執運行
你使用時間分析器所做的所有性能優化
現在有回報了
在某些時刻你調用ulock_wake
在一小時段後它把線程變成了阻塞狀態
這裏發生的是ulock_wait系統調用
發覺那個鎖正被另一個線程持有
所以它請求內核把它移出CPU
當它實際獲得到了鎖時再放回CPU
3.42微秒之後這確實發生了我們進入了可運行狀態
但現在在可運行狀態中
這是回到CPU所消耗的時間
你看我們在可運行狀態持續了約7微秒
這是競爭鎖的時間的兩倍左右
這裏的額外開銷太大
另一種定量查看的方式是你可以進入線程策略視圖
選擇線程
像Joe展示的一樣創建一個時間過濾器
接着把詳細視圖部分從描述切換成線程概述
它會展示給你每個線程狀態所花費的時間總和
在這個例子裏我們可以看到我們的線程
只有82%的時間在運行
這意味我們從多核還是有所收益
我們做到了一些改進
但這個擴展仍然不是
我們所期待的完美的線性擴展
還是浪費了一些時間
當Joe採取他說的解決措施時
會發生兩件事情
第一是UpdateGraph區域
會變短一些因爲我們需要做的工作變少了
我們對這些字符串進行了緩存
但更重要的是
線程沒有佔用100%的時間運行
所以你可以獲得完美的擴展性
所以 當你把CPU的數量增加一倍
那段代碼的運行時間會變成一半
這非常棒
所以 如果你有這樣的一個解決方案一定要設法用上它
我們再來講講搶佔
在我們的例子中沒有看到任何搶佔
但它在系統追蹤裏也十分常見
搶佔指的是非自願地把你的線程挪出CPU
也就是說 有些其他的更高優先級的工作需要CPU
但現在沒有可用的於是你的線程不得不讓步
有一個例外情況
你可能會看到自願性的搶佔
它出現在自旋鎖的內部
當一個自旋鎖發現它的工作沒有任何推進
它可以產生線程切換系統調用
最終放棄它佔用的鎖持有者的時間片
在系統追蹤的線程描述裏
你會看到它調用了thread_switch
搶佔的描述會說它主動放棄了CPU
而不是被移出CPU
另一種更輕量級的搶佔叫做中斷狀態
中斷狀態指的是當你的線程在CPU上執行時
CPU必須處理一個硬件中斷
所以你的線程被掛起
中斷處理程序運行然後你的線程重新開始
此時 你線程的優先級起不到任何作用
你可以具有最高優先級但這也沒有用
中斷始終更加優先
好消息是
這些通常是短暫的 幾微秒而已
通常它們不會給你的應用
帶來任何內部的性能問題
但它們的確會出現這就是爲什麼我想提一下
Instruments 8的另一功能是全新的系統負載工具
這個工具可以幫助你找到系統追蹤中的一些高負載事件
比如會導致丟幀的事件
它通過兩種方式顯示第一種是下面的表視圖
它會給你展示一張圖表顯示了調度狀態的樣子
在藍色審視線的下方列出了所有可執行的線程
你可以知道在這個時間點有三個線程
一個是內核線程 另兩個是Graphasaurus線程
它們是未被阻塞的線程正在嘗試運行
你可以看到它們的核心任務
這個工具的另一個功能
稱爲可交互負載平均圖
這裏每一個豎條代表一個時間10毫秒的窗口
豎條的高度
是在10毫秒期間的活動線程的平均數
這些線程處於執行 可執行被搶佔或者被中斷狀態
就是所有沒有被阻塞的線程
由於它是可交互負載平均
我們只包括優先級大於或等於33的線程
因爲這些線程的優先級
足以對服務類的用戶交互的質量產生影響
更明白的說
當線程變成橘色這說明你的平均負載
已經超過了該設備上的核心數
所以當你看到一片橘色
你可以預測會有個丟幀發生
你可能想放大
這些橘色的區域
確保正在執行的線程
在服務質量水平上相互平衡
當Joe修改時
最終給負載留有了一些空間我們可以添加一項新的功能
這個新功能是懸浮標籤
類似你在Instrument看到的懸浮標籤
除了Graphasaurus你進行長按
懸浮標籤會跟隨你的手指
爲了展示這個特性我把演講交換給Joe
謝謝 Chad
所以我添加了NSAttributedString的解決方案
回到了每秒60幀 看起來不錯
增加了新一代的Tool Tips事件
再次慢了下來
你可以看到這裏和那裏掉了幾幀
查看時間分析器
沒有什麼是明顯我能刪除的我也沒有做什麼額外的工作
於是我回去 檢查系統追溯也就是你們現在正看到的
在我查看追溯之前
我新添加了一個Signpost代碼代碼爲3
它代表GenToolTips事件
你可以看到上面以紅色顯示
我們來放大其中的一個區域
好的 現在我們可以看到這是我們新的紅色柱狀圖
這些GenToolTips
我必須介紹一下我的算法的原理這非常重要
基本上每當這個CADisplayLink區域開始
對於界面上每一個圖
我對它調用異步渲染
同時我異步生成Tool Tip字典用於查詢
對於界面裏的每一張圖我都做同樣的事情
但後來我做了一個巧妙的實現
爲了調用我的渲染
我實際上並不需要等待Tool Tip完成
所以我創建了調度組讓它們只等待渲染工作
我們可以看到它實際在這裏運行地非常好
這是我的幀的起點CADisplayLink時間
我們可以看到一些Tool Tip在這工作
我向右滑動一些
你可以看到實際上它們中有一個
直到我的渲染幀完成纔剛剛開始啓動
看起來我的工作做得很好我拍拍我的背
這看起來不錯
然而當我看這裏的CADisplayLink時間
它花費了17.4毫秒
非常接近了但還不是我想要的16.6毫秒
同樣 這只是一個區域
我們來看看彙總起來怎麼樣
我們回到KDebug Interval Signpost by Code表
這裏可以看到我們的CADisplayLinks執行了大概260次
比我們之前要多聽起來不錯
16毫秒的平均水平比我的16.6還要少
這聽起來相當不錯
但是 這個最大值仍然是19.27左右
如果我們看所有的單個事件
按花費時間從長到短排列
我們可以看到這個19毫秒的
一堆18毫秒的
這裏是一些17毫秒的
很多17毫秒的
更多的是16毫秒（近17毫秒）的
所以我們還有一些幀實際渲染得太慢
慢的不多 但還是慢了
這意味着我們會丟幀
這次我們該何去何從？
我們重新深入線程策略
觀察我們所有的線程 系統調用VM事件
線程事件之類的
但只要有可能
這個系統跟蹤模板
有一堆工具它們可以給你提供
更高級別的彙總信息一開始看看它們會很有幫助
所以在你深入到那100,000多個事件之前
看看這些更高層次的聚合信息
我要做的是看看這個用戶交互負載圖
這是該系統負載工具之一
我們繼續縮小一點至合適大小
現在我們又可以在屏幕上看到所有數據
做好這些後我放大這裏
你可以看到這個圖裏有非常多的橘色
再放大一點
你可以看到這裏有非常多的橘色
這表示正在運行的用戶交互線程要比核心數多
這些線程說我有很多活 現在就要做
給我一個CPU
可是我們沒有CPU了所以這裏纔會是橘色
我們放大這裏
一大片橘色的地方
你可以看到數值只需懸停在一個區域上
放大一點點
在這個10毫秒塊裏
平均有2.84個用戶交互線程在嘗試運行
再次 在雙核的機器上
有0.8個線程缺乏CPU時間
這就是爲什麼這是橙色的
平均來看有很多區域太大
這裏實際上是四
我們在嘗試運行兩倍於核心數量的線程
我們來看看該區域的更多細節
我把它挪過來一點這樣你就能看到了
正如Chad所說
你可以看到這段時間裏哪些線程在嘗試運行
點擊並按住上面這裏的尺標視圖
你可以來回移動這個藍色標誌頭
Instruments會告訴你
那個時間點我們在嘗試運行哪些線程
如果我們看看下面這張表
我按照優先級排序
我們可以看到 在這裏
有兩個Graphasaurus線程正在運行 不錯
有兩個location D線程在嘗試運行 它們優先級稍低
這是真實系統的一部分
你會看到系統守護進程進來並試圖做好自己的工作
但沒關係它們的優先級比我們的稍低
所以我仍然持有CPU看起來不錯
我還有第三個線程在同時運行
嘗試在同一時間運行
但它沒有得到任何CPU資源
我知道這些線程是什麼了其中兩個是我的渲染工作
然後我讓這第三個線程嘗試完成我的Tool Tip生成工作
所以發生的是它們其中之一沒能獲得CPU
我們又能看到這個了如果我們查看 比如 我們的一幀
讓我們回到那個興趣點區域
我們可以看到我們在幀內進行渲染
ToolTips的產生也是在這裏所以它得到了一點CPU時間
但當它獲得的CPU時間時是從我的渲染這裏分走的
所以基本上我錯誤調度了我的工作因爲當我停下來想想
我需要渲染現在就進行
站在用戶交互的級別非常有意義
因爲我希望它完美而流暢60幀每秒
但這些Tool Tip它們的優先級不夠高
我確實很希望它們能儘快完成
因爲我希望當用戶長按屏幕的時候
它們能立即出現
但它們其實並沒有渲染工作重要
你可以清楚的看到它們拿走了一部分時間
從CPU的給渲染分配的資源現在渲染被延遲了
就是拖慢CADisplayLink時間的原因
對於此的解決方案其實非常簡單
我們回到Xcode
這裏我有個ViewController類
它做的事情之一是創建一個Tool Tip隊列
我們可以看到它就創建在下面這裏
這是我處理所有Tool Tip工作的地方創建它的同時還包含了些屬性
其中之一是它是並行的 很不錯
所以它們能在多個CPU上執行如果存在的話
它被設置爲用戶交互的QOS類
這個QOS類
和我正在進行的渲染工作相同所以它們互相競爭資源
如我所說的它實際上不是那麼重要
所以我要改變這個類
你可以在頭文件中讀到不同的類
我把它降低幾個級別使用Utility級別的類
這會讓CPU優先做我的渲染工作
然後當CPU有一點空閒時間比如每一幀的結尾或者其它時間
Tool Tip就會開始工作
它們仍然處於足夠高的優先級當用戶點擊屏幕
它們應該準備好隨時運行
爲了給你們展示這是什麼樣子的我們交還給Chad
好的 當Joe做了這個修改圖表會是這個樣子
我們會發現我們的CADisplayLink時間
降低到了平均12.7毫秒
是比以前好多了
但更好的是我們的最大持續時間僅爲14.6毫秒
所以我們不會丟失任何幀同時我們達到了16毫秒的限制
即使系統仍然處於過載狀態我們仍然能夠達成
如果你想想看我們仍然在運行三個不同的線程
但是因爲我們已經正確地安排了工作的優先級
我們的GenToolTips代碼在下面這裏 以優先級四運行
它不會阻擋用戶交互代碼
我們仍然在CPU上做了很多事情
我們仍然有一個非常高的系統負載
但與此同時我們仍然得到了完美流暢的用戶體驗
什麼是服務質量真正的意義
服務質量如果你還沒有看到它
是你附加到塊 隊列以及線程上的屬性
基本上它用於告訴內核
你願意獻出多少系統資源
以便讓某一工作快速完成
不同的QOS類會限制優先級的範圍
所以你可看到我們的Utility類把它的優先級降到了四
所以我們的用戶交互代碼在三十多四十多的高優先級運行
但QOS類還是可以限制類似IO這類工作
以及代碼運行的CPU頻率
所以當你爲你的代碼選擇QOS時
請非常詳細地閱讀文檔
並確保它與你正在做的工作種類相匹配
另一件能影響你應用性能的是
虛擬內存錯誤
隨着內存壓力的增加它們的負載表現會變差
但好消息是 它們是可控的
系統跟蹤擁有所有爲了分析虛擬內存故障所需的工具
在線程策略裏
虛擬內存錯誤以這種藍色小膠囊的形式出現
在線程描述裏面它會報告虛擬內存錯誤
甚至附上一個回溯表表明產生錯誤的位置
在代碼內的什麼地方
我們也有一個工具專門用來分析虛擬內存錯誤
舉個例子 你可以看到
你的代碼的哪些部分容易產生特定的錯誤而不是其它錯誤
比如你有一段代碼
需要進行更多的零填充或者寫時複製
下一個你需要知道的關於虛擬內存錯誤的事情是
錯誤是在訪問時發生的而不是分配時
所以你可以向內核請求一大片內存
比方說500M
但實際上你並不需要把它轉化成物理內存
直到你開始修改或訪問
進程中分配的相關頁面
這是你分配內存時需要想到的
另一需要知道的重要的事情是虛擬內存錯誤
可以通過代碼內聯解決
所以你不需要進行顯式調用
來解決一個虛擬內存錯誤
你需要做的是修改頁面內
任何被標需要錯誤處理的字節
內核會獲得你的線程控制權
解決​​故障然後把控制權交還給你
當你看到這些藍色膠囊
在你線程策略的系統追蹤裏
這就是會發生的事情
如何處理你的應用內的虛擬內存錯誤？
最簡單的是不好意思
最簡單的是消化掉它們
我的意思是在性能預算上留足夠的空間
便於你處理一定數量的虛擬內存錯誤
在你達到限制之前
這會使你的負荷更有彈性
隨着內存壓力的增大
如果你的預算足夠大你有足夠的空間
你不會發現性能上的差別
現在我們發現
有些人不設置這種鬆散的限制
在其UI生成方面
所以另一種選擇是嘗試在後臺線程解決錯誤
比如說你有個遊戲
你的玩家玩到了第一關的結尾
他們馬上就要進入第二關
你可以做的是異步分配到後臺隊列
然後在後臺隊列裏創建與第二關內容相關的頁面
這樣當你的渲染線程開始獲取這些新內容時
不會有延遲
關於使用這種方法我們在這裏要給你一個警告
確保只創建一定會用到的頁
因爲如果你開始創建比所需更多的頁面
實際上會使問題變得更糟
這就是今天的會談內容了
我們相信系統跟蹤器是時間分析器的絕佳搭檔
時間分析器可以讓你的代碼更快
但系統跟蹤可以讓你的應用更易擴展到更高的負載
我們鼓勵你在自己的應用中嘗試使用系統跟蹤
我們知道當使用Instrument檢測我們的應用時
總能找到值得修補的地方
如果過去你用過系統跟蹤
請你到Instruments 8重新看看它
因爲我們做了一些重要的改進
包括易用性和功能性
我們相信它會是你的工具箱中又一新的利器
欲瞭解更多信息這是我們411號演講的鏈接
我們今天有一些相關演講
在這一週以及週五也同樣有
剩下的上午時光過得愉快