線程檢查工具和靜態分析
幫助你在代碼中查找錯誤
大家好 我是Anna
歡迎來到線程檢查工具和靜態分析演講
由於我們的團隊從事於錯誤尋找工具
我們將告訴你找出錯誤的新方法
我開始會簡要概述一下地址檢查工具
然後更加深入到線程檢查工具
這是我們今年推出的新功能
之後 Devin會上臺給大家講講新的檢查
我們添加到Clang靜態分析器上
開始吧
檢查工具是LEM工具的一個家族組合編譯時間檢測工具
和運行時監控在運行時尋找錯誤
它們與Valgrind相似
然而 它們的主要優點是有低的運行時開銷
兼容Swift和Objective-C
而且緊密集成於Xcode UI
去年我們在macOS和iOS上推出了地址檢查工具
這個工具能找出內存崩潰例如棧堆緩衝區溢出
用後死機 雙重死機
在尋找內存問題上極爲有效
所以如果你還沒使用我極力推薦它
今年我們擴展這個工具給Swift提供全面支持
這會是令人激動的消息對於那些
喜歡在Swift中不走尋常路的人
所以這意味着什麼如果你使用不安全指針類型？
在地址檢查工具開啓時進行測試 它會爲你找出錯誤
地址檢查工具雖然主要注重於內存崩潰問題
這裏還有一個大的錯誤來源那就是線程問題
這些更加難以重現並調試
對時機很敏感
它們可能只會在某些情況下出現
這意味着包含它們的應用程序
會有難以預測的行爲
所以今年我們推出另一個工具的支持線程檢查工具
這會有助於你找到
並更好理解你的線程錯誤
TSan報告很多不同類型的錯誤
我們來看一些錯誤
我會告訴你關於未初始化互斥體的使用
這可能看起來沒什麼大不了
然而 如果你使用未經恰當初始化的互斥體
這會在你的應用程序中導致非常細微的錯誤
因爲實際上你沒有實現任何互相排斥
當你使用那樣互斥體
另一個例子是線程泄露
如果你的應用程序擁有很多線程
如果那些線程泄露了
這就會導致內存泄漏
另一個是信號處理器中的不安全調用
以及從錯誤線程中解鎖
然而 數據競爭是目前最常見的問題
因爲它們非常易於引發
當多個線程訪問相同內存位置時就會發生
沒有使用恰當的同步
我們看看該工具是如何工作的
通過進入Xcode演示
這裏我將演示線程檢查工具
在去年Alpha版的WWDC應用上
所以如你所料這裏顯示出了一週的安排
不過 注意這個有趣的視覺錯誤
即使所有會話的數據已下載完成
網絡活動指示器還是在轉動
我知道我使用全局變量來決定
何時顯示或隱藏這個指示器所以這裏可能有線程問題
我們看看線程檢查工具能否幫我們找到
爲啓用線程檢查工具我們選擇編輯方案
現在Diagnostics選項卡
點擊這裏啓用線程檢查工具
現在你可以選擇每當遇到一個問題時
就暫停調試器並就地調試那個問題
或者你可以選擇保持運行
收集線程檢查工具報告的所有線程問題
之後再探究它們
Xcode 8第二個工作流程是新的只有線程檢查工具支持
我們看看其工作原理
當你在線程檢查工具下啓動應用程序
Xcode會通過額外的編譯器工具重建你的項目
然後會在特殊模式中啓動它
嘗試找到線程問題
這裏我們的應用程序啓動了
Xcode告訴我們線程檢查工具檢測到兩個問題
並在活動查看器中顯示了這個紫色的指示器
點擊這個紫色指示器
會將我們帶到問題導航器
之前我們只是用它
顯示構建時間問題例如編譯器警告
編譯器錯誤靜態分析器問題
今年擴展支持了運行時問題
這樣線程檢查工具的問題就能找到根源
線程檢查工具報告了兩個問題我們一個個看
第一個是使用了未初始化互斥體
這個問題在之前運行應用程序的某個時候出現的
線程檢查工具會告訴我們確切的時間
通過提供歷史堆棧跟蹤
即使這不是即時堆棧跟蹤
你可以把它當做即時堆棧跟蹤 一幀一幀查看
我們來看看
某時刻我們調用了acquireLock
這調用了pthread_mutex_lock然後傳遞了無效的互斥體引用
這是調用自resetFeedStatus而它又是調用自初始化器
這裏如你所見我們確實初始化了互斥體
不過是在使用之後才初始化的
這是簡單的排序錯誤
所以重新給這兩個陳述排序就應該解決好了
好了 我們來看看第二個問題那就是數據競爭
線程檢查工具告訴我們出現數據競爭
在叫做活動計數的變量上
這是相同的全局變量用來決定
何時顯示或隱藏指示器的
因爲這是數據競爭線程檢查工具會告訴我們兩個事件
兩個競爭訪問
一個讀取和一個寫入
所以線程11上出現讀取
而線程13上出現寫入
注意這兩個都不是主線程
而且堆棧跟蹤是一樣的
這意味着它們可能通過多個線程
在相同的線上執行並且沒有使用同步
我們來看看
好了 我們在更新活動計數變量
現在我可以通過添加鎖來修復這個競爭
不過注意這只是症狀
這裏的下一行更新UI
我們知道UI更新應該發生在主線程上
所以合適的修復是將
counter-increment和UI更新分派到
Grand Central Dispatch的主隊列上
這既會解決我們應用程序的邏輯問題
也會解決競爭因爲所有的線程會從
相同的線程上訪問計數變量
我確定我說得十分有說服力
而且你們都相信我將錯誤修復好了
然而 最好的自行檢查方式
就是在你的項目上再次運行這個工具
所以我們應該在線程檢查工具啓用的情況下重新運行應用程序
這會再次重建你的項目
帶有這個額外檢查而且在特殊模式中啓動
現在應用程序啓動了
我們看到奇怪的視覺UI錯誤消失了
而且線程檢查工具沒有報告任何問題
一切正常
我們回到幻燈片
我們回顧一下演示
在方案編輯器中啓用線程檢查工具
當你進入診斷選項卡跟地址檢查工具的做法一樣
除了擁有在出現第一個問題時暫停調試器的ASan工作流程之外
線程檢查工具支持另一種模式
你可以在檢測問題的過程中保持運行
之後你可以在問題導航器中探究它們
在你重啓應用程序之前它們會留在那裏
我們來談談Xcode在後臺發揮了什麼作用
來讓這一切奏效
爲了使用線程檢查工具Xcode將特殊標記傳遞給
Clang和Swift編譯器
命令它們生成被檢測二進制文件
這個二進制文件鏈接到TSan運行時間庫
由檢測工具使用來
監控程序的執行並檢測那些線程問題
所以如果你從命令行進行構建和運行
你可以將選項傳遞給任何一個編譯器
而且xcodebuild還會支持線程檢查工具
通過提供enableThreadSanitizer選項
默認情況下 TSan會在檢測錯誤的過程中持續運行
不過你可以命令它在遇到第一個問題時就中止
通過將TSan選項環境變量設置成
在啓動過程的時候當halt_on_error=1時中止
這會允許你有相同的工作流與地址檢查工具是一樣
在哪裏可以使用這個工具？
線程檢查工具在macOS上有支持
以及64位的模擬器
並不在設備上支持
現在你知道如何使用該工具如何啓動 如果尋找問題
我們來談談如何修復報告中的錯誤
我們主要注重於數據競爭
因爲這是所報告的錯誤中最多的類型
什麼是數據競爭？
數據競爭發生於當多個線程
訪問相同的內存位置
沒有使用恰當的同步
而且至少一個訪問是寫入
這裏的問題是你最後可能不止得到過期數據
而且行爲是無法預測的
你最後甚至可能遇到內存崩潰
所以數據競爭的原因是什麼？
這通常表明你遇到了邏輯問題
在你程序的結構中
而且只有你知道如何修復
另一方面 這還意味着缺失一些同步
我們來談談第二種情景
這是一個Swift中數據競爭的例子
我們有全局變量數據
我們有一個生產者設置成42
以及一個打印它的消費者
如果執行這兩段代碼
通過兩個不同的線程這就會出現數據競爭
那這個代碼怎麼樣？
我們引入了另一個變量叫做isDataAvailable
數據在生產者中更新後我們設置那個標記
而在消費者中我們要等待直到標記設置完成
如果一旦設置好我們打印數據
這看起來很有邏輯
看起來應該會奏效
問題是你看到的東西不會得到執行
這裏的指令可以被任一個編譯器重新排序
或者CPU 所以你不能假設標記是在
數據更新之後設置
指令的順序無法保證
在生產者和消費者中都一樣
所以這張幻燈片的意義何在？
我只是想演示
試着推出自己的同步方法
通常是不好的想法
那應該怎麼做？
我們應該使用已經可用的東西
例如Grand Central Dispatch
是一個非常好的選項你可以將最近訪問
分配到相同的串行隊列
這會確保它們在相同的線程上執行
而且沒有數據競爭
現你可能想起線程檢查工具適用於Objective-C和Swift
我們使用Objective-C作爲下一個例子
這是惰性初始化代碼
我們的實現方法叫做getSingleton
確保我們將相同的共享實例返回到其所有的調用者
如果這個代碼由多個線程執行
沒有適當的同步這就會出現數據競爭
當兩個線程都嘗試更新共享實例變量
好了 那這個代碼呢？
我們嘗試修復這個問題通過分配
並初始化本地變量
之後我們使用atomic_compare_and_set操作
來確保線程會原子級地更新那個全局變量
所以在右邊不會有數據競爭
這看起來像是踏入正軌
不過這個代碼還有問題
我們來看看它們
首先 這會非常難以推斷出內存管理
當你使用原子
例如 如果你使用ARC這裏你會遇到use-after-free
如果你使用MRR
這個對象只有在競爭出現時泄露
這不是好事
問題不只這一個
另一個問題是因爲讀取是非同步的
這裏還是會出現競爭如果一個線程嘗試
讀取那個共享變量
而另一個嘗試原子級地設置它
所以這是未定義行爲這不好
那你應該怎麼做？
如果你已經知道解決方案了使用Grand Central Dispatch
這會替你進行惰性初始化設置
這在Swift中更加容易
全局變量和類型常量都分派了一個語義
你能選擇兩者任意一個解決方案
對你的代碼有最有效的那個
好了 總結一下
你應該使用適合你需求的最高級別API
大多數人應該使用GrandCentral Dispatch
如果這不適合你可以使用pthread API
或者比如NSLock
我們新os_unfair_lock是今年在我們平臺上新出的
它代替了OSSpinLock
我們還有C++和C11 Atomics
線程檢查工具支持它們
你在之前的例子中看過了它們非常難以正確地使用
除了性能之外
這要麼是不可測量的或者是可以忽略的
所以不要選擇使用那些API如果你不去測量
它們確實在你的應用程序上有一些東西
所以關於更多這些API的信息
請參加週五的併發程序設計演講
現在我們來談談良性競爭
這是什麼？
一些開發者主張在一些架構上
例如x86
你不需要在讀取和寫入之間插入同步
因爲架構本身就保證了自動
指針大小數據的操作
要記住的重要一點是任何競爭 即使是良性競爭
在C或C++標準中被視爲未定義的行爲
所以你不僅會驚奇地發現帶有良性競爭的代碼運行在
你之前沒有完全測試好的架構上
而且編譯器可以自由給那些指令重新排序
跟沒有其他線程看到一樣
所以最後你可能會遇到非常細微的錯誤
正如我們的線程檢查工具工程主管所說：“修復所有錯誤”
現在到我們演講最精彩的部分了
我們都知道數據競爭很難重現 因爲它們
對時機非常敏感
線程檢查工具最有趣的一點是它可以檢測
那些在特定程序運行過程中未顯現的競爭
來看看它是怎麼做到的
當你用線程檢查工具編譯你的程序
它會檢測每個內存訪問
然後在上面加上標記前綴使用引號
不過首先記錄關於訪問的信息
第二 檢查那個訪問是否參與競爭
我們來深入看看
對於每個對齊的8字節應用程序內存
線程檢查工具的影子狀態會最多記錄4個訪問
假設你有4個線程
線程1寫入到那個內存位置
線程檢查工具更新它將信息存儲在
影子線程來重置內存位置
我們還是會記錄我們持續不斷做下去
現在如果你有4個以上的訪問怎麼辦？
線程檢查工具使用有根據的推測
決定接下來將哪個單元格驅逐掉
這裏它驅逐了相同線程的訪問
這不會使其失去精度
然而 如果我們有第五個訪問
這會驅逐一個隨機單元格
所以像這樣限制訪問的數量意味着
我們可能不會在所有案例中遇到所有競爭
好了 現在我們談談它是如何檢測數據競爭的
線程檢查工具使用衆所周知的方法
用向量時鐘檢查競爭
這如何起作用的？
每個線程有線程本地存儲
記錄線程自身的計數器
以及其他所有線程的計數器
這個計數器初始化爲0
每次有線程訪問內存
計數器就會增加
例如 線程1訪問了2個內存位置
線程2訪問了22個內存位置
線程3訪問了55個內存位置
這個時間戳是沒有可比性的
每個線程使用這些時間戳或者計數器
來給其進行的內存訪問排序
好了 我們回來
將內存位置帶回來
及其影子看看線程是如何交互的
以及它們如何更新這裏的計數器
我們還會加入鎖線程使用它
來同步內存位置的訪問
好了 線程1寫入
這是行爲良好的線程它會獲取那個鎖
它會更新其計數器
它會寫入到那個內存位置中
線程檢查工具現在看到它了
它會更新影子
在更新影子之前它看到影子中什麼都沒有
沒保存到影子中意味着
內存位置之前未被訪問
所以可以安全地寫入進去
在釋放鎖之前線程1會在上面
更新有自己的時間戳
然後釋放那個鎖
現在該線程2去寫入了
線程2也是行爲非常良好的線程 它會獲取那個鎖
像這樣獲取鎖會讓線程2看到
線程1的計數器已經增加了
線程2增加其自身的計數器
寫入到那個內存位置中
線程檢查工具看到它想要更新影子
它在這裏看到之前有東西進入影子裏了
這意味着那個內存位置已經被訪問了
所以就會檢查是否有競爭
通過對比時間戳
線程檢查工具看到線程2的同步時間
是在線程1訪問內存之後
所以沒有數據競爭
我們就可以繼續更新
在釋放鎖之前線程2會更新
其自身的時間戳
然後釋放鎖
好了 現在該線程3去寫入了
線程3已經等了很長時間
很激動地要寫入那個內存位置中
結果呢 它把鎖忘了
它增加計數器寫入到內存位置
線程檢查工具在那裏監督着
它想更新影子並檢查有沒有競爭
線程檢查工具看到線程3的
舊視圖實在舊了
在影子中存儲的讀取和寫入是發生在
線程3上次同步之後
這就允許線程檢查工具揪出那個錯誤
關於這個算法重要是要知道
我們將與數據競爭相關聯的
時間敏感性在這裏不適用
即使競爭在特定運行中沒有顯現出來 TSan還是能檢測到
但可能再次運行應用程序就會出現
或者用戶運行你的應用程序
這讓使用線程檢查工具更加高效
相比於調試並重現那些數據競爭
在不使用該工具的普通環境下
另一個需要記住的是
線程檢查工具是運行時錯誤查找工具
所以它只會找出競爭
當你提供了足夠的覆蓋面
所以請在線程檢查工具啓用時運行你的所有測試
這就是Xcode 8上新出的線程檢查工具　用它
它會找出錯誤它會讓你的應用程序更好
現在交給Devin他會講講我們在
Clang靜態分析器上添加的檢查
謝謝 Anna
與檢查工具不同靜態分析器可無需
運行你的代碼就能找出錯誤
其做法是系統性地探測整個程序的所有路徑
這讓使其十分適合找出重現條件很難很極端的錯誤
它支持Clang可編譯的所有語言
所以CObjective-C和C++
今年靜態分析器我們添加了三個新檢查
本地化能力缺失的檢查
不正當的實例清理檢查
在手動保持的釋放代碼中
還有爲空性違規的檢查
我來跟大家講講
在本地化應用中的常見錯誤
就是忘記本地化UI元素
這對用戶來說會是很驚人的事
他們會以自己的母語使用你的應用
不過突然出乎意料地
你語言中的字符串出現在他們的UI中
這不是好的用戶體驗
我來給演示一下
靜態分析器是如何找出這種錯誤的
好了 我將演示靜態分析器
Anna使用的相同應用上
要運行分析器你可以去Xcode的產品菜單
選擇分析
這會探測大量經過你程序的路徑
並試圖在每個路徑裏發現錯誤
就像線程檢查工具
如果靜態分析器發現一個問題
它會將這藍色靜態分析器圖標
顯示在Xcode的活動條中
如果你點擊它它會給你顯示問題導航器
看來我們有一個本地化問題
一個非本地化字符串流向了面向用戶屬性
所以我們應將其本地化
不過看看這個方法
我沒有看出任何很明顯的錯誤
我會去點擊診斷功能
這給我展示了更多的信息
關於這個非本地化字符串是如何流向
面向用戶屬性的
我可以通過路徑探測器欄探測這個路徑
在Xcode編輯器頂部
通過反向推斷我能看到這個方法是調用自
表視圖數據源方法
之後反過來它將其傳遞到
這個非本地化的常量字符串
所以我們將其本地化
爲此我將使用NS本地化字符串宏
這會在運行時加載一個翻譯版的字符串
在使用這個宏時非常重要的是
同時包括你給譯員的註釋
來幫助他們正確翻譯字符串
所以我會說：
“這是按鈕...
會重置會話篩選器”
好了
我們再次運行分析器確保我們解決了這個問題
看起來很好我切換回幻燈片
回顧一下 你可以從產品菜單中運行分析器
它會將其找到的任何問題在問題導航器中顯示
正如我們所見 點擊診斷功能非常有助於顯示路徑
這會使問題更易於理解並且最終修復它
我們看到分析器可以找到缺失本地化功能的地方
但這也警告我們當我們忘記給
譯員提供註釋
這裏我提供了零的註釋沒有一點幫助
所以分析器會警告
你可以把這些檢查打開
其他靜態分析器檢查在項目構建設置中
靜態分析器的部分
本地化功能缺失的檢查會由Xcode自動打開
如果你的項目擁有不止一種語言的本地化版本
註釋缺失的檢查是默認關閉的
但你一定要打開它
如果你不用其他方式將這些註釋傳達給你的譯員
例如 你可能已經直接在字符串文件中這麼做了
今年我們還改進了dealloc檢查
在你的手動保留釋放代碼中
在手動保持釋放下非常重要的是
不要釋放實例變量合成用於
dealloc內的分配屬性
如果你那麼做這會導致過度釋放
當那個值的所有者也釋放它這會使你的程序崩潰
所以現在分析器放出了警告
另一方面你必須釋放實例變量
合成用於保持或複製屬性
因爲如果你不這樣做它們會泄露
分析器同樣也會警告
耶！
這真是非常棒的檢查
我們運行的每個手動保持釋放項目中 它都會
找出一個錯誤
所以試一下
當然去除保持釋放問題最好的方法
是將你的項目升級到自動引用計數
幸運的是 Xcode可以幫你自動完成這些
如果你去編輯菜單
選擇轉換到Objective-C ARC
這會讓編譯器爲你處理所有的麻煩
關於保持釋放
終於在今年
我們給爲空性違規添加了一個檢查
這是基於去年的成果我們給SDK加註釋
來表示方法或屬性是接收還是返回零
例如 Core Location的時間戳屬性是非空的
這是因爲每次的位置測量
也有對應的日期和時間
相比之下其底層屬性可爲空
這是因爲這個屬性會返回零
當這個位置不是室內定位激活的場地
你應該給自己標頭註釋爲空性
因爲它會啓用新的程序和模型
可以將你的爲空性預期直接
傳達到客戶那裏
這很重要 因爲違反
這些預期 可能會引起崩潰或意想不到的行爲
事實上 我們認爲它如此重要
以至於將它內置到Swift中那裏的可選類型要求你
先檢查零 之後再使用值
這在Objective-C中也很重要
所以我們將爲空性違規的檢查添加到靜態分析器
而且這個檢查特別適用於
混合Swift和Objective-C代碼項目
它會發現兩種問題
在代碼中可能有邏輯問題
可能你在錯誤時間返回零
或者你可能會有錯誤的註釋
所以我們看看如何修復
這兩種問題
一個常見錯誤是從零初始化局部變量
之後填充進一連串
非窮舉的分支
例如 這個方法
返回一個位置的簡短說明
要麼是城市的名字
或國家含有着這個位置
但我們沒能考慮到一個很重要的情況
如果這個位置是位於國際海域呢？
那這既不是城市也不是國家
所以這個方法會不出意外地返回零
然後分析器會告訴我們
幸運的是
這也很棒
幸運的是這很容易修復的
你要做的是初始化你的局部變量
通過非零默認值
在此例中我們使用常量字符串Earth
當然 要確保將其本地化
另一方面可能是你的代碼
在實施方面完全沒問題
而是註釋出現錯誤
我們發現其經常發生的一個原因
是當你使用方便的NS_ASSUME_NONNULL_BEGIN和END的宏
這些宏會將標頭的一部分包起來
而且它們包起來的內部範圍
那些類型會隱含地成爲非空
這可以節省你很多的鍵入
但這也讓你很容易忘記
將屬性標記爲可空
在這個例子中壓力特性會返回零
如果設備沒有氣壓計
但是屬性是隱含成爲非空的
幸運的是這裏也很容易修復
我們可以明確地將屬性標記爲
可空在那個區域內部
這會告訴客戶不要期待壓力數據
是一直可用的
你的確需要注意這個
這是因爲你API的爲空性是一種契約
所以你不應該爲滿足分析器而更改它
相反 你應該仔細考慮你想
公開的API並使用它
如果你決定改變你的API
那你還要仔細考慮向後兼容
這在Swift尤爲重要
因爲 爲空性會改變類型的導入方式
你也可能處在這樣的情況下
你無法改變方法的實現
及其註釋
在這些情況下 你可以通過轉換來壓制分析器診斷功能
它經常出現的一個原因要歸咎於
當違反前提條件時會防守性返回零的方法
在這個例子中該方法返回零
當索引越界的時候
如果有依靠這種行爲的現有代碼
那你不能移除那個檢查
而且你不能用一個證書替代它
相反 正確做法是告訴分析器這是你特意做的
通過將返回值轉化爲非空
所以這是靜態分析器和Xcode 8的新功能
我們做個總結
今天我們講了三個很棒的工具
這些工具找到真正的錯誤
地址檢查工具和線程檢查工具在運行時
查找內存崩潰和線程問題
靜態分析器甚至不用運行你的代碼就能發現錯誤
所以請在自己的項目中使用這些工具
它們會在用戶發現錯誤之前幫你找到錯誤
如果你有興趣瞭解更多信息你可以去演講網站
這裏還有幾個相關演講
我們認爲可能會幫助到你
謝謝大家