應用啓動時間優化
早上好 歡迎來到406演講“應用啓動時間優化”
我叫Nick Kledzik我將和同事Louis
帶大家一起討論 如何啓動進程
你們可能會想 這個主題適合我嗎？
所以我們請了專業的開發營銷團隊做了一些調查
得出的結果是有三組人羣將會從本演講中收益
第一組 是應用開發者他們的應用啓動很慢
第二組 是不想在第一組的應用開發者
最後一組是任何對操作系統的運作感到好奇的人
所以本次演講分成兩個部分
第一部分更注重理論第二部分更注重實際
我負責第一部分
我將會帶你一起看看發生的步驟
一直到主函數
但是爲了理解所有的步驟
首先需要上一個速成課關於Mach-O和虛擬內存
首先快速講一下Mach-O的部分術語
Mach-0是運行時可執行文件的文件類型
第一個類型是可執行文件應用裏最重要的二進制文件
也是應用擴展文件的主二進制文件
Dylib是一個動態庫在其他平臺上
用的是你可能會熟悉的名字：DSO和DLL
我們的平臺上還有另一種類型叫捆綁包
捆綁包是一種特殊的Dylib是不能進行鏈接的
只能在運行時用dlopen()函數打開它
Mac OS的插件會用到
最後是圖像圖像指的是任意這三種類型
我會常常提到圖像
最後 是框架該名詞在我們的領域如雷貫耳
但就本主題而言
框架是一個Dylib周圍有特別的目錄結構
存儲該Dylib需要的文件
我們來看看Mach-O圖像格式
Mach-O圖像分成數段
按照慣例所有的段名都是由大寫字母組成
每一段都是頁面大小的倍數
該例中 TEXT段大小是3頁DATA和LINKEDIT段大小是1頁
頁面大小由硬件決定
arm64處理器的頁面大小是16K其他都是4K
另一種查看方式是分區
編譯器常常會忽略分區
分區是段的子範圍
分區不用遵循頁面的大小
但是它們是不重疊的
最常見的段名是TEXT DATA LINKEDIT
實際上幾乎每一個二進制文件都包含這三段
你可以添加自定義段但一般不會給它賦值
這些是用來做什麼的？
TEXT是文件的開頭
它包含了Mach的頭文件任何機器指令
以及任何只讀常量 比如C字符串
DATA段是重寫段
它包含了所有的全局變量
最後是LINKEDIT段
它不包含全局變量的函數
它包含變量函數信息
比如名稱和地址
你可能還聽說過通用文件什麼是通用文件？
假設你生成一個64位的iOS應用
現在你有一個Mach-O文件
當你也想讓它在32位的設備上運行
Xcode裏會發生什麼變化？
重新生成時 Xcode會生成另一個單獨的Mach-O文件
這個是爲32位生成的armv7
之後這兩個文件合併成第三個文件
叫作 Mach-O通用文件它前端有一個頭文件
所有的頭文件都有一個所有體系結構的列表
它們的偏移值也在文件裏
該頭文件也是一個頁面的大小
你也許想問爲什麼段都要是頁面大小的倍數？
爲什麼頭文件要一個頁面的大小爲什麼要浪費那麼多空間？
這就涉及到我們下個主題 虛擬內存
什麼是虛擬內存？
你們當中可能有人知道軟件工程裏的格言
任何問題都可以通過添加一個間接層加以解決
所以虛擬內存解決的問題是
所有這些進程存在時該如何管理所有物理內存？
所以他們添加了一個小的間接層
每一個進程都是一個邏輯地址空間
映射到RAM的某個物理頁面
這種映射不一定是一對一的
邏輯地址可以不對應任何物理RAM
也可以多個邏輯地址對應同一物理RAM
這樣帶來很多種可能
能利用虛擬內存做什麼呢？
首先 如果有一個邏輯地址不映射任何物理RAM
當進程要訪問該地址時就會產生頁面錯誤
內核將停止該線程
並試圖找出解決方案
下一點是 如果有兩個進程
有兩個物理地址 映射同一個物理頁面
這兩個進程共享一樣比特的RAM
進程之間開始共享
另一個有意思的功能是基於文件的映射
不用把整個文件讀入RAM
而是可以調用mmap()函數告訴虛擬內存系統
我想把這部分文件映射到進程裏的這段地址
爲什麼要這麼做？
不用讀取整個文件 通過設置該映射
第一次訪問這些不同的地址時
如同已經在內存裏讀過
每次訪問未訪問過的地址時
都會導致頁面錯誤內核會讀該錯誤頁面
將會造成讀取文件遲緩
現在可以把所有功能集中
關於我告訴你的Mach-O可以發現
Dylib或圖像的TEXT段可以映射到多個進程
將會造成讀取遲緩
而所有這些頁面可以在進程間共享
DATA段呢？DATA段用來讀寫
有一個策略叫寫入時複製
這和Apple文件系統的克隆很相似
寫入時複製所做的是它積極地
在所有進程裏共享DATA頁面
只要進程只讀有共享內容的全局變量
但是一旦有進程想要寫入其DATA頁面
寫入時複製開始
內核會把該頁面複製
放入另一個物理RAM並重定向映射
所以該進程有了該頁面的副本
這把我們帶到了 髒vs乾淨頁面
該副本被認爲是髒頁面
髒頁面是指含有進程特定信息
乾淨頁面是指內核可以按照需要重新建立的頁面
比如重新讀取磁盤
所以髒頁面比干淨頁面要昂貴許多
最後一點是 頁面也有權限界限
這指的是 可以標記一個頁面
可讀 可寫 或可執行或它們的任何組合
所以我講到了Mach-O格式關於虛擬內存的一些內容
看看它們是如何一起工作的
我先往前跳一步先簡單講講Dylib是如何操作的
一會兒我會和你們一起來看 但現在
我想講一下它在Mach-O和虛擬內存之間是如何映射的
這裏有一個Dylib文件我們沒有把它讀到內存
而是把它映射到內存
所以 在內存裏該Dylib文件本應該佔用8個頁面
看一下 不同是有這些“全零填充”
大部分全局變量的初始值都是零
所以靜態鏈接器進行了優化
把所有值爲0的全局變量都移到了尾端
然後不佔用任何磁盤空間
取而代之我們利用虛擬內存的特性
該頁面第一次被訪問時告訴虛擬內存 把它填滿0
所以它不需要讀取
Dylib必須要做的第一件事是查看Mach頭文件
在內存裏 在該進程裏
它將查看內存的頂盒
此時 那裏是空的沒有內容映射到物理頁面上
所以產生頁面錯誤
到那時內核意識到它被映射到了一個文件
所以它將讀取文件的第一頁
放入物理RAM設置其映射
現在Dylib可以真正通過Mach頭文件開始讀取
它這麼做了 Mach頭文件說
“看看LINKEDIT段上的這條信息”
再一次 Dylib跳下去查看進程1的底盒
這又會產生頁面錯誤
內核又讀入RAM的另一個
LINKEDIT的物理頁面Dylib現可期望一個LINKEDIT
進程 LINKEDIT將會告訴Dylib
對DATA頁面做一些修正讓dylib可運行
所以 同樣的事又發生了
Dylib現從DATA頁面讀取數據
但是有一點不同
Dylib 想要寫回一些內容修改DATA頁面
此時 寫入時複製出現了
這個頁面變髒了
所以髒RAM的8個頁面將會是什麼？
若我只用malloc()函數分配8頁內存 然後讀了一些內容進去
我將會有8個頁面
但是我只有1頁的髒RAM和2頁乾淨的
如果第二個進程加載同一個Dylib 會發生什麼？
在第二個進程裏Dylib經歷相同的步驟
首先它查看Mach頭文件
但這次內核說
“在RAM某處我已經有這頁了”
所以內核只簡單地把映射重定向重新使用該頁面 沒有任何IO操作
LINKEDIT也是如此 更加快速
我們來看DATA頁面
此時 內核必須要看看在DATA頁面
乾淨的副本是否還存在RAM某處
如果還在 就可以重複使用如果不再 就必須要重新讀取
在該進程種Dylib會讓RAM變髒
最後一步是LINKEDIT
只在Dylib進行操作時被需要
所以它可以提醒內核 當它完成時
它不再需要這些LINKEDIT頁面
當有別人需要RAM時 可以回收它們
現在有兩個進程在共享這些Dylib
每個進程都本應該有8個頁面也就是一共有16個髒頁面
但現在我們只有2個髒頁面和1個乾淨的 共享頁面
我還想補充說明兩點安全如何影響Dyld
兩點安全問題會影響Dyld
首先是ASLR 地址空間佈局隨機化
這是10年或20年前的舊技術
基本概念是把加載地址隨機化
第二點是 代碼簽名
你們當中的很多人都有代碼簽名的經驗在Xcode裏 代碼簽名是指
對整個文件運行一個加密哈希算法
然後在文件上簽名
爲了在運行時進行驗證整個文件都必須要重新讀取
所以在編譯階段我們讓Mach-O文件的每一個頁面
都進行自己的加密哈希算法
所有哈希都儲存在LINKEDIT裏
這使得你的每個未被修改的頁面
在被讀取的過程中都能得到及時驗證
好的 速成課結束
現在我將帶你們一起從exec()講到main()
什麼是exec()？exec()是一個系統調用
當你進入內核 說
我想把這個進程換成這個新程序
內核會抹去整個地址映射指定的可執行程序
ASLR把它映射到一個隨機地址
下一步是從該隨機地址 回溯到0地址
把整個區域標記爲不可訪問
意思是 不可讀 不可寫 不可執行
該區域在32位處理器下至少4KB大小
64位處理器下至少4GB大小
這樣可以捕捉任何空指針引用
捕捉任何指針截斷
Unix誕生的前幾十年一切都很簡單
我只需映射一個程序把指針引用指向它 開始運行它即可
然後共享庫被髮明出來
那麼誰來加載Dylibs？
人們很快意識到情況太過複雜
不想讓內核來做這件事
所以人們新建了幫助程序在我們的平臺上 叫作Dyld
在別的Unix平臺可能聽說過它名字LD.SO
當內核完成進程的映射它現在映射另一個Mach-O文件
調用Dyld進入該進程到另一個隨機地址
把指針引用指向Dyld 讓Dyld完成進程啓動
現在Dyld在運行進程
它的工作是加載所有依賴的Dylib
讓它們全部準備好開始運行
我們一起來瀏覽這些步驟
底部有很多步驟和一個時間線
我們瀏覽這些的時候 也會瀏覽時間線
首先 Dyld是否需要映射所有的依賴Dylib？
什麼是依賴Dylib？
要找到它們 首先要讀取主可執行文件
的頭文件 內核已經映射好的
在該頭文件裏有一個所有依賴庫的列表
都必須要進行分析
所以必須要找到每一個Dylib
如果每一個Dylib都找到了它就須打開和開始運行每一個文件
它需要確保是一個Mach-O文件
對它進行驗證 找到它的編碼簽名在內核裏對它進行註冊
然後它可以在該Dylib裏的每一段調用mmap()
好吧 這非常簡單
你的應用知道內核Dyld
Dyld說 噢這個應用依賴A和B Dylib
加載它們兩個 完成了
當然 實際情況要更爲複雜因爲A.dylib和B.dylib
自身也可能依賴dylib
所以dyld必須再做一次同樣的事
爲每一個dylib
而每個dylib可能依賴於某個已加載或新的東西
它決定是否已經加載如果否 則需要加載
所以 如此繼續
最終所有的都加載了
如果你看一個進程系統裏的一個普通進程
都會加載1到400個dylibs這個加載數量很大
還好大部分都是OS dylibs我們做了很多工作
在建立OS預計算時
和與緩存那些dyld要做的工作來加載這些內容
所以OS dylibs加載速度非常非常快
現在所有dyibs都已經加載完成
但它們都彼此獨立我們必須要把它們綁在一起
這就是修復
關於修復有一點 我們已經知道
因爲編碼簽名的存在我們無法修改指令
那麼dylib該如何調用另一dylib？
如果無法修改指令 怎麼調用？
我們把老朋友找回來加上許多舊的間接引用
所以我們的code-gen即動態PIC 即地址無關代碼
代碼可以加載到該地址 並且是動態的
也就是說 地址間接地被分配
也就是說爲了讓一個調用另一個
code-gen實際上在DATA段裏新建了一個指針
該指針指向我們想要調用的位置
代碼加載該指針 跳向指針
所以所有的dyld都在修復指針和數據
修復有兩種 重設基址和綁定
它們的區別是什麼？
重設基址是指如果有一個指針指向圖像範圍內
需要做出的所有修改
第二種是綁定
綁定是指 如果指針指向圖像範圍外
它們必須進行不同的修復
我來帶大家一起看看其步驟
但是首先 如果你覺得好奇有這麼一個指令
dyldinfo還有很多選項參數
你可以在任何二進制文件上運行就可以看到所有的修復
該dyld將必須該二進制文件才能讓他準備好
這就是重獲基址
過去你可以爲每一個dylib指定首選加載地址
該首選加載地址是一個靜態指針
和dyld一起合作比如 若把它加載
到該首選加載地址 所有指針和數據
本應該內部編碼的 都是正確的
那麼dyld就不用做任何修復
但是現在 因爲有了ASLR
dylib加載到隨機地址上
它滑到了其他地址也就是說所有那些指針和數據
都還依然指向舊地址
所以爲了修復它們我們需要計算滑動值
也就是移動距離並且對每一個內部指針
都添加該滑動值
所以重設基址是指遍歷所有
內部數據指針然後爲它們添加一個滑動值
概念非常簡單 讀 添加 寫讀 添加 寫
但是這些數據指針在哪裏？
這些指針在段裏的位置都編碼在LINKEDIT段裏
此時 所有映射都已經結束
當我們開始重設基址時
實際上在所有DATA頁面上都產生了錯誤
然後對頁面進行修改 產生寫入時複製
所有重設基址有時會非常昂貴由於所有這些I/O
但是有一個技巧  就是按順序操作
從內核的角度來看它認爲數據錯誤按順序產生
當它如此認爲時 內核會進行預讀
這樣I/O成本將降低很多
下面來講綁定
綁定針對那些指向dylib範圍外的指針而言
這些指針通過名稱進行綁定實際都是字符串
本例中LINKEDIT段裏的malloc
也就是說該數據指針需要指向malloc
所以運行時dyld需要找到實現該符號的位置
這需要很多的計算 遍歷查找符號表
一旦找到 就把值存到該數據指針裏
計算複雜度比重設基址高得多
但是I/O很少
因爲重設基址已經完成大部分I/O
下一步 ObjC有很多DATA結構
DATA結構類也就是指向方法的指針
以及高光指針等等
幾乎所有都已經被修復通過重設基址或者綁定
但在ObjC運行時還需要一些額外的操作
首先ObjC是一門動態語言
可以把一個類用名稱實例化
即ObjC運行時 必須要維護
一張表格 包含所有名稱及其映射的類
每次加載的名稱 都將定義一個類
名稱需要登記在一個全局表格裏
接下來 在C++裏你們可能聽說過脆弱的ivar問題 抱歉
脆弱的基類問題
在ObjC裏不存在該問題因爲我們做的其中一種修復就是
動態改變所有ivar的偏移值在加載時
接下來 在ObjC裏 可以定義類別
就是改變另一個類中的方法
有時候 它們在那些位於另一dylib且在圖像範圍外的類裏
此時 那些方法修復必須已經完成
最後 ObjC基於選擇器是唯一的
所以我們需要唯一選擇器
現在我們完成了所有的DATA修復
現在我們可以進行所有
可以靜態描述的DATA修復
現在是進行動態DATA修復的時機
在C++裏 有一個初始化器
可以指定 等於你想要的任何表達式
該抽象表達式 此時需要運行
此時開始運行
所以C++編譯器生成
初始化器來完成那些抽象DATA的初始化
在ObjC 有一種方法叫+load方法
現在+load方法已經被否決不建議使用
建議使用+initialize
若有+load方法 此時它開始運行
現在我有了這張大圖
頂端是主可執行文件所有的dylibs依照這張大圖
必須要運行初始化器
按什麼順序運行呢？我們選擇從下往上
原因在於
當初始化器運行時可能會調用一些dylib
你需要確保那些dylib已經準備好被調用
所以從下開始運行初始化器
一直往上到應用類
可以很安全地調用依賴的內容
但所有初始化器完成時
我們實際已經最終調用的主Dylib程序
理論部分熬過來了
你們現在都是瞭解進程如何啓動的專家了
知道dyld是一個幫助程序
它加載所有的依賴庫
修復所有DATA頁面
運行初始化器 跳轉到主函數
那麼該如何把這些理論應用到實際中？
我把該主題交給Louis
他將會爲你們講解非常實用的技巧
謝謝你 Nick
我們都曾有過這樣的經驗把手機從口袋裏拿出來
按下主屏幕按鈕
輕輕點擊想要運行的應用
點擊 點擊 再點擊
不斷點擊 因爲它停止響應了
當這種情況發生時 非常令人沮喪
我想把這個應用刪了
我叫Louis Gerbarg研究Dyld
今天 我們講討論如何讓應用立即啓動
可以讓用戶滿意
首先 我們來討論
在這部分演講中 要涉及的內容
我們將會討論啓動速度要多快
用戶體驗才足夠良好
如何測量啓動時間 因爲會很難測量
標準的測量應用的方法
在代碼運行前無法使用
我們將一起看一張列表代碼的常見原因...
抱歉 我們將一起看一張列表
表上列有應用啓動慢的常見原因
最後 我們將討論一種解決所有緩慢問題的方法
我將先劇透一部分演講後面的內容
少做點事
我不是說應用應該減少功能
我是指你的應用在運行前應該減少操作
我們想讓你搞清楚如何推遲一些啓動行爲
從而只在啓動前一點點時間進行初始化
讓我們討論目標 想要多快啓動
不同平臺上的啓動時間也有所不同
但是 一個好的經驗法則是
400毫秒是一個不錯的啓動時間
原因在於
在手機上有啓動動畫顯示給用戶一種持續感
在主屏幕和應用之間
當你看着它在運行時
這些動畫佔用時間 並且動畫
會給你一個機會隱藏啓動時間
顯然 根據情況會有所不同
應用擴展程序也是應用啓動的一部分
它們啓動的時間不同
手機 電視和手錶是不同的設備
但是400毫秒是一個好目標
啓動時間永遠不要超過20秒
如果超過20秒 OS會終止應用
以爲它進入了死循環
我們都曾有過這樣的經驗
點擊一個應用 回到了主屏幕
它不響應 就這麼消失了
這就是它被終止了
最後 在最慢的支持設備上進行測試這很重要
這些計時器都是常量值
在我們平臺支持的所有設備上
如果在iPhone 6S上你達到400毫秒
現在測試的結果 也許剛好達到
很有可能在iPhone 5上達不到
我們回憶一下Nick的演講中提到的
啓動時需做什麼要解析圖像映射圖像
重設基址圖像綁定圖像
啓動圖像初始化器 調用主函數
如果聽上去很多操作 沒錯我說說就覺得很累
而再之後
還必須調用UIApplicationMain()在ObjC應用裏可找到這個函數
或在Swift語言寫的應用裏進行隱式處理
還有一些操作
包括運行框架初始化器
以及加載nibs
最終 在應用委託裏收到回調
我之所以提最後這兩個操作是因爲它們都計算在
我之前說的那400毫秒的時間裏
但本次演講中我們不討論它們
如果你想更好地瞭解它們
在2012年有一個演講iOS應用性能響應
我強力推薦你們找出來看看
但是現在我們就不再提了
我們繼續
還有一點 熱啓動和冷啓動
啓動應用時 分熱啓動和冷啓動
熱啓動是指
啓動時應用已經在內存裏
或者因爲已經啓動過 之前退出了
但還在內核的磁盤緩存裏
或者因爲你剛把它複製過去
冷啓動是指啓動時應用不在磁盤緩存裏
測量冷啓動時間通常更爲重要
冷啓動時間更爲重要的原因是
當用戶重啓手機後啓動應用
或很長時間後啓動應用
這時非常需要一個快速啓動
爲了測量冷啓動時間必須在每次測量之間重啓設備
說了這麼多如果你正致力於加快熱啓動時間
冷啓動時間應該也會隨之加快
你可以通過快速開發週期加快熱啓動
但是請時不時地測試一下冷啓動
在主函數啓動之前該如何測量時間？
dyld裏有內置的測量系統
可以通過設置環境變量訪問
DYLD_PRINT_STATISTICS
安裝OSes時候就可用了
它打印了很多內部調試信息
並沒有什麼用
它缺少了某些你可能想知道的信息
今天我們就來改進
在新的OS裏進步顯著
它會爲你提供更爲相關的信息
應該會提供可操作的方法加快啓動時間
將會在seed 2可用
對此我還想講一點
加載每一個dylib調試程序都必須暫停啓動
才能解析應用的符號
加載斷點
通過USB線 將非常費時
但是dyld清楚這一點它把調試時間
從註冊時間裏減出去
所以不用爲此擔心
但是你會注意到它因爲dyld會顯示
比你從牆上鐘錶中所觀察到的數字精細得多
這是預期的和能夠接受的
如果你看到了那個數字 一切都是對的
我只想讓你們記下這一點
我們繼續
在Xcode裏設置環境變量
只需打開方案編輯器 如此填寫
完成後會有一個新的控制檯日誌輸出
控制檯輸出被記錄
看上去是什麼樣？
這就是輸出看上去的樣子
底部的時間條代表它不同的部分
再添加一個內容
爲那400毫秒的目標添加一個指示器
在這個應用上並沒有達到
如果看順序 這就是基本步驟的順序
如Nick講的啓動應用的順序
我們按照順序來看
加載dylib
關於加載dylib
還有看到的速度緩慢 需特別瞭解的是嵌入式dylib 會非常昂貴
所以Nick說 平均每個應用包含100到400個dylib
但是OS dylibs很快因爲構建OS時
我們預計算了大量dylib數據
但是我們開發OS時做不到每個應用裏的每個dylib
我們無法預計算你要嵌入應用的dylib
所以加載時必須要經過一個慢得多的過程
其解決方案是 少用dylib
而這將非常困難
不是說完全不能用
但是 有很多方法可以合併已有dylib
可以使用靜態存檔把dylib用這種方法鏈接到應用
還可以使用延遲加載也就是使用dlopen()函數
dlopen()會帶來細微的性能和正確性的問題
實際之後會帶來更多的工作量但現在被延遲了
所以 這是個可行的選項
但是必須要仔細思考清楚
如果可能的話 我會反對這麼做
這裏有一個應用 有26個dylib
加載它們需要240毫秒
如果我把這些dylib合併成兩個dylib
那隻需要20毫秒就可以加載
所以這些dylib都在還可以使用它們
在應用和擴展程序間共享功能
但是 限制dylib數量將非常有用
我理解這是一個權衡
在開發舒適度
和麪向用戶的啓動時間這兩者中做選擇
因爲dylib越多你就可以越早開始生成
和重鏈接應用 開發週期就會越短
所以理所當然應該用它們
但是試試用有限的數量這個目標不錯
我會大概建議 用半打應該不錯
現在我們修復好了dylib數目
繼續看看下一個速度緩慢的地方
綁定和重設基址要350毫秒的時間
如Nick所說的
重設基址由於I/O會更慢一些
而綁定會計算上昂貴
但它已經完成I/O
所以I/O是爲了它們它們交加在一起
時間也交加在一起
如果我們深入看一下
時間都耗在修復DATA段裏的指針
所以我們必須修復少一些指針
Nick介紹了一個可以運行的工具
可以看到在DATA分區修復指針的信息 dyldinfo
還能顯示正在哪些段和分區操作
你會很清楚地瞭解到在修復什麼
比如 如果看到一個符號在ObjC分區ObjC類
很可能你有很多ObjC類
你可以做的一件事是 減少
ObjC類對象和ivars的數量
有很多編碼樣式都鼓勵很小的類
只有一個或兩個函數的
這些特殊的模式可能會導致速度逐漸變慢
當你越加越多時 更要格外小心
有100個或者1000個類不成問題
但我們見過有的應用有5000 1萬 1萬5 2萬個類
這樣將會增加700或800毫秒
的啓動時間因爲內核要把它們讀入頁面
還可以做一件事
可以試試減少使用C++虛擬函數
虛擬函數新建 我們稱作 V表格
和ObjC元數據相同
因爲它們都新建結構
在必須要被修復的DATA分區
它們比ObjC元數據小
但它們對於某些應用來說 作用顯著
還可使用Swift structsSwift通常用的數據要少一些
帶有指針做相關修復
並且 Swift更爲內聯
可以更好的使用codegen減少消耗
所以 轉爲Swift語言也是一個好方法
還有一點
要小心機器生成的代碼
曾經有過這樣的例子你可能描述某個結構
用DSL或一些自定義語言
然後有一個程序從中生成其他代碼
而如果這些程序中有很多指針
它們將變得非常昂貴 因爲生成代碼時
會生成非常非常大的結構
我們看過這樣的情況生成了兆量級的數據
但好處是 比較容易進行控制
因爲你只需改變代碼生成器
不使用指針而用別的比如偏移基址 結構
將收益良多 來看看本例中
加載時間怎麼樣了
我至少有1萬個類 實際上有2萬個
太多了都無法一次顯示完整
如果減少到1萬個類
啓動時間也減少了
這部分的啓動時間從350毫秒減少到20毫秒
現在 除了初始化器
其他都在400毫秒以內 做得很好
關於設置ObjC
Nick說過所有它做的工作
它要註冊類 要處理非脆弱ivar
還要註冊目錄 還要讓選擇器變成唯一
我不想在此處多花時間
原因在於
這些問題我們都已經解決
通過之前對重設基址數據和綁定的修復
那裏所做的所有減少和你想在這裏做的完全相同
我們這裏就坐享其成
很短的時間 8毫秒
但我們並沒有特別對它進行操作
最後 來看一下初始化器
消耗時間長達10秒鐘
這裏我將講得比Nick更深入一些
有兩種類型的初始化器
顯式初始化器 比如+load
Nick說我們建議用+initialize取代它
將導致ObjC在運行時初始化代碼
當類被實例化時 而不是文件加載之後
或者在C/C++裏函數可以帶有一個屬性
可以導致函數像初始化器一樣生成代碼
這是顯式初始化器
我們寧願用調用點初始化器取代
要調用它可以用dispatch_once()函數
或者跨平臺代碼裏pthread_once()
若是C++ std::once()
所有這些函數基本上都有相同的功能
這些函數的代碼
只會在第一次點擊時運行 僅此一次
dispatch_once在系統裏很優秀
第一次執行之後
幾乎等同於無操作 直接跳過
所以我強烈建議不要使用顯式初始化器
接下來是隱式初始化器
如Nick所描述的那樣隱式初始化器
大部分來自C++的全局變量帶有非默認初始化器…
非默認構造函數
你可以選擇用之前提到的
調用點初始化器取代它
當然有很多地方可以把全局
換成非全局結構或指針指向想要初始化的對象
還有一個選項 你沒有非默認初始化器
在C++裏初始化器調用POD普通純式數據
如果對象只是普通純式數據
靜態鏈接器
將會爲DATA分區預計算所有數據
只把數據放在那裏
不一定要運行 不一定要修復
最後一點
很難找到它們 因爲它們是隱性的
但是編譯器會收到警告——Wglobal-constructors
如果這麼做 會有警告
只要產生其中一個
所以把它添加到編譯器用的標誌裏是個好方法
還有一個選項即用Swift重新編寫
理由是
Swift有全局變量並且會被初始化
它們確保在使用前被初始化
但是其方法不是用初始化器
在後臺使用一次dispatch_once()
使用了一種調用點初始化器
所以轉爲Swift語言將會做到這一點
所以這個選項我強烈建議
最後
在初始化器裏請不要調用dlopen()
它將帶來巨大的性能問題 原因很多
dyld在運行時 是在應用啓動之前
我們可以做一下諸如關閉鎖定的操作
因爲是單線程
當dlopen()出現在那種情況下
初始化器的運行發生了改變
可能會有多線程 必須要打開鎖定
將會帶來巨大的性能下降
還會帶來細微的死鎖和未定義行爲
還有 不要在初始化器上開始線程
也是出於同樣的理由
若必要可以設立一個mutex
優先mutex甚至會有
預定義的靜態值你可以用run no code設定
但是實際上在初始化器裏開始線程
會帶來潛在巨大的性能和正確性問題
這裏有一些代碼
有一個C++類有一個非默認初始化器
網絡連接出現問題
請稍後再試
謝謝你 Siri
我有一個非默認初始化器
調試時還有 可能我註釋掉了
好 已經縮短到50毫秒
總共
有足夠的時間可以初始化nibs
還有其他的操作 狀態不錯
我們已經瀏覽完畢
我們一起來討論 我們應該瞭解什麼
如果啓動時間冗長
首先用DYLD_PRINT_STATISTICS測量時間
添加到檢測性能的測試工具裏
所以你可以追蹤應用是如何超時的
這樣可投入編寫而不會在幾個月後發現
調試出現問題
爲了縮短啓動時間 可以採用的方法有
減少已有dylib的數量
減少已有ObjC類的數量
以及刪除靜態初始化器
還有可用更多Swift語言加快速度
因爲Swift真的很強大
最後 不鼓勵使用dlopen()
它會帶來細微的性能問題 很難診斷
可以通過屏幕上的URL獲取更多信息
本週還將有很多相關演講
再說一次 2012年有一個關於應用性能的會話
涉及到應用啓動的另一部分
如果感興趣 強力推薦觀看該演講
感謝各位的到來希望你們這周過得愉快