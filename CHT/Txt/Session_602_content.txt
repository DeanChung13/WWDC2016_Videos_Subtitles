採用METAL 第一部分
下午好 歡迎來到“採用Metal 第一部分”
我是GPU軟件團隊的Warren Moore
我和同事Matt Collins一起 他主要負責做展示
我想問一個
看似簡單的問題 什麼是Metal
你可能已聽說過Metal是Apple的偏底層的API
面向GPU的它是一個統一的圖形計算語言
並且面向多線程做了優化
專門爲我們的平臺所設計
這些都是正確的
但是Metal不僅有Metal.framework
Metal同時也被其他的框架和工具支持
它們提供了比metal框架API多很多的東西
尤其是去年我們引入MetalKit
它包括了用來一些處理常見任務的工具
像與UIKit和AppKit交互加載紋理
還有Metal性能着色器
能幫你做圖片處理
可以手動調優 高度優化的着色器
可以直接放到你的應用裏來處理這些任務
Metal同時還緊密與我們的開發工具結合
像Xcode與Instruments
當你的應用裏面有着色器
它們會同你的應用一起編譯
通過Xcode集成到你的應用包裏
還有GPU框架調試器可以做一個快照
在程序運行的任何一個點來看看程序現在是什麼情況
Instruments中Metal系統跟蹤
可以讓你在運行是查看應用的性能
和行爲
兩年前我們把Metal引入了iOS
然後我們又把它帶到了Mac OS和tvOS
所以現在在我們平臺上受到了廣泛的支持
同時我們的大部分硬件也支持它
包括桌面架構和移動架構
像Apple AMD Intel和NVIDIA
所有的2012年後的Mac
2013年以後的所有iOS設備還有新的Apple TV
Metal可以讓應用程序充分利用GPU的性能
在我們的海量的產品上
在這些平臺上Metal屬於基礎技術
它支持核心圖像 核心動畫
遊戲和圖形庫比如SpriteKitSceneKit和Model I/O
也是我們關鍵系統軟件的重要部分
像Preview和Safari
各種各樣開發者們已廣泛使用了Metal
從AAA工作室 遊戲引擎提供商
到獨立開發者和專業工具開發者
他們開發了非常好的應用和遊戲
這只是一部分我想着重說幾個
比如 Fancy Guo用Metal顯著的提升了性能
帶來了驚人的視覺效果
在他們廣受歡迎的MORPG遊戲Furious Wings
Metal也被用在專業的內容創造工具
像iPad上即將發佈的Affinity Photos
我帶大家快速預覽下都有什麼
這個是Serif Labs的Affinity Photos
這是個全功能的圖片編輯應用
在iPad pro上Metal可讓其獲得令人驚歎的效果
今年的 WWDC我們會給你一些工具
讓你們開始使用Metal
來製作體驗非常棒的應用
今年的 WWDC 有很多很棒的內容
有五場講座專門介紹Metal
當然這是第一場會話採用Metal 第一部分
在這節中我們會討論
Metal裏的一些基本概念
接着會介紹2D繪圖添加光照
紋理和動畫 我們還會介紹3D
這節課的第二部分也是在這個教室 緊接着這節課
我們會介紹動態數據管理
接着會介紹一些高級的
關於GPU和CPU的同步
會讓你性能達到新高度
通過使用多線程編碼
我們會介紹下Metal裏有什麼新東西
確實有很多新特性
在昨天的統一介紹中相信你們也看到了一些
我不會詳細介紹全部的東西
如果你想在你的應用中使用
你應該看一下那個最新課程
最後 我們會有個很棒的高級着色器優化的課程
對於那些想要
更好的使用着色器的人來說這些絕對是乾貨
我們會詳細的討論硬件如何工作
你該怎樣使用Metal來更好的發揮它的性能
還有調優你的着色器代碼
在這些課程中 我們會創建樣例工程
由簡單的Hello Triangle開始
圖形編程領域的Hello world
然後 我們會研究動畫和紋理貼圖
第二部分 我們會進入到下一層級
討論下實時更新對象數據
同時還有 通過多線程來優化繪製調用
現在我們假設
你們已經熟悉
基本的圖形編程 最好是
知道可編程管線熟悉着色器等
同時你想知道怎麼能用Metal來
讓你的程序和遊戲變得更棒
我假設大家都是這樣
這也是你們爲啥在此 對吧
我先過一遍議題
我們會先大體介紹下
Metal的理念
和爲何Metal會是現在的樣子
接着我們會詳細的
介紹創建一個Metal實例
接下來會介紹加載數據
到內存來供GPU使用
我們會簡要介紹下Metal着色語言
我們會介紹創建預驗證管線狀態
和GPU調用 包括繪製調用
我們會用一個討論結束
如何在Metal中處理動畫和紋理貼圖
第二部分我們會介紹的更深一些
剛纔我已經提到了
現在我們開始
從理念概覽開始
只有幾點需要強調
使用和硬件驅動相匹配的API
儘量明確一些
儘量不做耗時操作
先說說使用和硬件驅動相匹配的API
Metal是一個完全現代化的API
也可以說它使用了最新的硬件特性
和硬件的工作流程息息相關
作爲一個全新的API它非常輕量級
並且沒有歷史包袱
對的開銷的操作沒有花哨的技巧
它和Metal契合
並且都是在最基礎的層級操作
幸運的是 它是統一的
在我們的所有平臺上
當我們說我們更傾嚮明確的操作
意思是我們想讓你
負責操作GPU
而不是讓其默認的操作
同時還包括數據的管理和同步
這讓你有更多的責任
同時能有更好的性能
再來解釋下
不要經常做耗費大的工作
有三個地方
程序創建時
程序加載時
加載資源的時候
然後就是繪製時 每秒會調用60次
如果是歷史API 如OpenGL
你大部分時間會花在
狀態檢查上每次調用繪製的時候
最壞的時候你需要在運行時重新編譯
這些都會給GPU的必要工作上
添加負擔 在調用繪製函數的時候
在Metal中我們把這些工作提前
像我開始說的
着色器的編譯可以在
程序編譯的時候同時進行
同時 我們也允許你驗證狀態
在調用繪製的時候提前驗證
這樣就不用在每次調用繪製的時候驗證了
這樣你需要做的唯一工作
就是隻有繪製調用了
通過這些理念介紹
我們看看實際情況中的
Metal設備
這裏有個類MTL設備
它表示抽象的GPU
它是你Metal應用中的最基本對象
你將會用它來創建
像指令隊列 資源和管線狀態對象
和其他你需要用的對象
創建Metal設備很簡單
只需調用MTLCreateSystemDefaultDevice
現在設備代表對象
你需要在程序開始時創建一個
並保持引用因爲會在整個程序的生命週期使用
就這麼簡單
現在說說怎麼把數據
放到GPU可以讀取的位置
然後你可以觸發繪製調用
在Metal中我們把數據存到緩衝中
緩衝就是一塊內存用來存數據
你可以用任何格式
可能是頂點數據 索引數據 常量
你把數據寫到緩存中
隨後在
頂點和片段函數中訪問
我們看看大體是個什麼樣子
這裏有個包含幾個緩存的例子
你加載數據的時候可能會創建
我們有個vertexBuffer包含一些頂點數據
一個indexBuffer包含一些連續的索引
更具體寫來說
每個頂點類型的實例可能是一個Swift結構
用向量表示頂點的位置
同樣還有點的顏色
你可以讓它們在內存你連續保存
說下如何創建緩存
這個API在你已經創建的設備裏
簡單調用newBufferWithLength
來獲得一個指定大小的緩存
裏面默認沒有數據
或調用newBufferWithBytes
傳一個已經在內存中有數據的指針
Metal會把數據拷貝
到新創建的緩存
你可以馬上使用
你也可以用memcpy把內容指針拷貝到緩存裏
既然我們要展示一個2D的三角
作爲我們第一部分的展示
我們先說下三角的幾何座標
既然我們想讓頂點着色器
和片段着色器儘可能的簡單
我們在裁減的空間裏提供座標
Metal的裁剪空間很有趣
它和其他類似的API有些不同
有點像DirectX裁剪空間
X從負1到1 Y軸從負1到1
Z軸從0到1
這個是我們要用的座標空間
代碼中是這樣的
我們創建了個Swift的頂點數組
我們依次添加頂點
同時包括位置和顏色值
現在 我們不用嚴格的使用索引繪製
在這個簡單的用例中
接着創建一個indexBuffer並向其中添加0 1 2
代表三角形的第一個 第二個
和第三個點
然後用我們的設備創建接個緩存
我們會用newBuffer(withBytes創建vertexBuffer
把頂點數據加載到Metal緩存中
我們再調用一次newBuffer(withBytes
把索引數據穿進去得到indexBuffer
現在我們有了數據和內存
下面說說統一着色語言
Metal的着色語言是C++ 14的擴展子集
他是圖形和計算的統一語言
代表你還可以做很多事
不僅是3D圖形
它可以讓你寫程序給GPU
這裏有個管線各個階段的圖表
現在我們是在頂點
和片段處理階段
每個階段都有相應的函數要寫
要麼是處理頂點要麼是片段
將會刷到屏幕上
語法上 它看起來像這樣
我們不會詳細介紹
希望你們注意這些函數修飾符：頂點和片段
你會注意到右面函數的前面
不像普通的C++程序
我們相用這些修飾符來表示
這些函數和哪個階段相關
我們有一個頂點函數在上面
和一個片段函數在下面
我將簡單展示怎麼實際把這些
和你的管線結合在繪製的時候
我們還會看看這些函數的內部實現
在以後的2D和3D展示中
我提過好幾次Metal可以
直接把着色器編譯到程序包裏
方法是即使你有一個.Metal文件
在你的工程中的編譯源碼層
Metal會自動生成
一個Metal庫文件default.Metallib
同時會拷貝到你的包中
在你的程序編譯的時候
除此之外不會再編譯
所以它會在你程序包中
這是default.Metallib
簡單說
你可在運行時編譯Metal着色器
如果你程序裏有一個.Metal文件
它會被Xcode用Metal工具鏈編譯
生成一個default.Metallib打到你的應用包中
這裏很自然會有個問題
運行時怎麼使用這些函數
答案是你會用一個叫做
Metal Library的類
Metal Library是一個集合
編譯器編譯的函數對象
有幾種方法創建
你可以通過我們討論的流程
創建一個default.Metallib
到你的應用包然後在運行時加載
你還可以用我們的命令行工具鏈編譯一個.metallibs
運行時你還可以用代碼串創建一個目錄
例如 通過字符串來編譯一個渲染器
在代碼裏看起來像這樣
爲了加載default.Metallib
調用newDefaultLibrary
用你已經創建的Metal設備
還有其他的API加載 例如
從編譯好的.Metallib或者從源代碼
你可以詳細查看文檔來瞭解這些API
現你已有Metal Library
能從中得到什麼可以得到Metal函數
現在Metal函數是一個簡單對象代表一個函數
它和一個特定的管線階段關聯
記得我們剛纔看過的圖麼
頂點或片段階段
我們還有一個額外的描述符叫“kernel”
表示並行處理數據的函數
這裏有段代碼 你可以看到
函數名是vertex transform
fragmentFunction名是fragment lighting
我重改下以便我能給你展示API
如何在你的庫中加載函數
像這樣
我們先調用NewFunctionWithName
傳一個代表函數名的字符串
獲得一個Metal函數 引用它
稍後將展示實際中如何使用這些對象
但也只是簡要介紹Metal着色語言
讓我們介紹下創建預驗證的管線狀態
但首先 我們先預熱下
像OpenGL中的API
你經常需要設置許多狀態
然後觸發繪製調用
在這之間驅動負責驗證
你設置的狀態是有效的
然後 最壞的情況
你還得付出運行時重新編譯着色器的代價
我們想要避免這些
在Metal中 它看起來像這樣
你設置一個預驗證的管線狀態對象
可能還有其他少數輔助狀態
然後觸發繪製調用
我們這裏想要減少繪製調用的負擔
把更多工作提前進行
這裏有幾個你可以在管線狀態對象中設置的樣例狀態
這些狀態繪製時你可以在任何時間設置
你看到左面這欄
你可能設置的管線狀態
有頂點和片段函數用來繪製的
還有透明渲染狀態
右面 我們看到的狀態是
你可以在觸發繪製函數前設置
包括front face winding和cull mode
來講一下如何創建對象
包括這些預驗證的狀態
主要對象是Metal RenderPipelineState
它代表一類GPU的管線配置
它包括你會在加載時創建的一個預驗證集合
像設備
RenderPipelineStates是持久對象
你想讓它在你的整個程序生命週期都存在
如果你有很多不同的函數
你可以異步創建管線狀態對象
在程序運行的時候
實際上在創建RenderPipelineState時
我們不會直接創建
反而 我們會用一個叫做Descriptor的對象
它打包了所有參數用來創建RenderPipelineState
通常在Metal中我們創建Descriptor對象
它會把所有不同的參數弄在一起
我們在創建其他對象時也會使用
對於RenderPipelineState對象
它被叫做渲染管線描述符
你會發現它包含指向頂點函數
和片段函數的指針我早先曾介紹過
它還包含一個附件集合
附件是一些紋理我們會在
實際渲染中用到
現在在Metal中所有的渲染都會被渲染到紋理中
但我們不需要提前指向那些紋理的指針
我們只需要提供你要渲染的像素格式
這樣我們對它們的管線狀態優化
若你使用了深度或者Stencil Buffer
你也可以指定它們的像素格式
你一旦創建了一個管線描述符
你可以傳遞給你的Metal設備
然後得到一個MTLRenderPipelineState對象
讓我們在代碼中看一下
這是一個RenderPipelineState的最小化配置
你會發現我們設置了頂點函數
和片段函數屬性給
我們先前從我們庫中創建的頂點和片段對象
同時我們也創建了
主要顏色附件的像素格式爲.bgra8Unorm
它是一個可顯示和渲染的像素格式
這代表我們最終要
在繪製的時候繪製的紋理
最後 一旦我們創建了管線描述符
我們可以用設備新的RenderPipelineState函數
來獲得實際的預驗證對象
我還行強調下PipelineStates是持久的對象
你應該在加載時創建
在使用設備和資源的時候需要保持
你可以在繪製時在它們之間切換
來達到不同的效果
通常會有一對頂點和片段函數
現在我們已經討論了如何創建預驗證的狀態
和如何加載資源到內存中
接下來我們說下觸發GPU指令包括繪製調用
我們通過幾個階段介紹
我們還會討論和UIKit AppKit交互
稍微討論下Metal指令提交模型
然後到渲染和繪製調用 最終
如何展現你的內容到屏幕上
就與UIKit和AppKit交互而言
我們用MetalKit裏的一個工具MTKView
MTKView是一個跨平臺的視圖類
繼承自Mac OS的NSView
iOS和tvOS中的UIView
它可以減少你要寫的代碼
爲了讓它在Metal中運行起來
例如 它會創建和管理一個CA Metal Layer
是CALayer的一個特殊子類
可以和窗口服務或者顯示循環交互
來讓你的內容顯示到屏幕上
通過CV或CA顯示鏈
可管理繪製回調循環
通過循環觸發回調
來完成你的繪製
同時它還可以管理要渲染的紋理
具體的方面我想強調
它可以做什麼和那些繪圖資源
在CA Metal Layer中由MTKView管理
有一個可繪製資源集合
可繪製資源包含一個紋理
將要顯示到屏幕上
這些在一個內部的隊列中保存會在幀間複用
因爲它們相對來說要耗費資源
它們需要由系統管理
因爲它們和東西
如何在屏幕上顯示息息相關
我們替你管理並給你
包含紋理的可繪製對象讓你來繪製
這裏有幾個屬性
你可以給MTKView設置
來定義如何管理紋理並往裏面繪製
特別是 你還可以設置一個純色
讓主色更清楚
可以指定顏色像素格式
需要匹配你指定的
固定管線的狀態對象的顏色格式
同時制定深度或模板顏色格式
最後一個屬性可能是最重要的一個了
我們在這裏設置代理
MTKView實際上不會做任何繪製
你可以將它歸爲一個子類別
或者你實現一個代理負責繪製
我們通過接下來的例子來介紹
我們看看你需要怎麼做
才能實現一個MTKView代理
可歸結需要實現兩個方法
繪製大小變化和繪製
在繪製大小變化裏你負責
響應如窗口大小發生變化或者設備旋轉
比如 如果你的投影矩陣依賴
窗口大小 那麼它可以讓你
響應來替代重建所有幀
繪製方法會固定的被調用
可以讓你編碼你想的執行指令
包括繪製調用
我們沒有展示這個方法的完整的內部內容
但是這是對指令提交的簡單介紹
你要創建commandBuffer做些事情 然後提交
稍後我們會做更多介紹
但是這是一種使用MTKView的繪製功能的hook函數
我們推薦使用MTKView尤其是在開始時
因爲它已經爲你做了不少其他的東西
我們說下Metal的指令提交模型
這裏有張我們要做的圖
在接下來幾張幻燈片中
你不需要記住所有的東西
我們將要把這個圖繪出來
這僅是個大體介紹
我們會創建這個對象
Metal的指令提交模型非常明確
表示你需要自己構造
和提交commandBuffers
可把commandBuffer當作
一個打包的工作交給GPU執行
不同於我們存數據的Metal緩存
指令緩衝存了GPU需要完成的工作
同時commandBuffer的提交完全由你控制
就是當你構造了一個commandBuffer
你負責告訴GPU何時執行
稍後會詳細介紹
我們先說說指令編碼器
把對象的API調用翻譯成
GPU需要做的工作
你要明白這很重要
這些指令編碼器不會有狀態驗證延時
所以所有預驗證狀態捆綁到
管線的狀態對象裏了
我們假設它是合法的因爲我們已經提前驗證了
所以這裏沒有額外的工作要做
在你的編碼器或驅動調用渲染指令的時候
還有 Metal的指令提交模型是多線程的
你可以並行的創建多個指令緩存
讓應用決定執行順序
這可以讓你的每一幀的繪製執行上萬次調用
使用Metal 第二部分會深入探討
但這裏因爲提到了所以說一下
讓我們深入瞭解下這些對象
首先是指令隊列
指令隊列這裏是說
一個叫做MTLCommandQueue的類
它把設備需要執行的指令都放在隊列裏執行
像設備和資源和管線狀態
隊列是一直存在的對象
在程序的整個生命週期會保持引用
通常你只需要創建一個
這樣可以保證Metal API是線程安全的
你可以創建指令緩衝渲染
並在多線程中使用它
隊列可以讓你創建和提交它們
並在自己不加鎖的情況下保證是線程安全的
創建一個指令隊列很簡單
用設備調用newCommandQueue()
你將會得到一個Metal指令隊列
當然只有你往裏放入指令的時候它纔會工作
我們說一下
我已經提過指令緩衝了
指令緩衝是GPU要執行的打包的工作
在Metal中 它們用
一個叫做MTLCommandBuffer的類表示
MTLCommandBuffer包含一系列指令
由GPU來執行 它們被放進
一個指令隊列等待驅動來調度
根據我們目前講的這些
它是臨時對象
就是說每一幀你都要創建一個或多個
然後往裏給它編碼指令
然後讓讓它們脫離GPU
你不會重用它們 不用引用它們
它們會自己消失
創建一個commandBuffer
調用commandQueue.commandBuffer()
我們已經說了緩衝和隊列
我們討論下如何把數據和指令
放到指令緩衝中
通過一個叫做指令編碼器的類
這裏有幾種類型的指令編碼器
包括渲染 位傳輸和計算
這些分別實現不同的功能
它們都差不多 都可以把你的
工作編碼到指令緩存中
比如 一個渲染指令編碼器
可以設置狀態和執行繪製調用
一個計算指令編碼器可以
把工作添加到隊列中並像數據一樣並行計算 不像渲染工作
它像GP GPU或者類似的東西
位傳輸指令編碼器用來
在緩存和紋理之間相互拷貝數據
這節課中我們會詳細看看渲染指令編碼器
我剛纔提到 它負責編碼指令
每一個渲染指令編碼器
單獨編碼每個工作
如果你觸發狀態變化
然後觸發繪製
然後管理一個渲染附件集合 代表
將要繪製的紋理
概要來說 我們說的是最後這個階段
你能看到我們有這些附件
被掛到管線的幀緩存合適的階段
如果我們做多通道渲染
那麼一個或多個渲染目標可能會變爲接下來的輸入
這裏只有一個通道 比較簡單
附件表示紋理貼圖
我們將要這個階段的最後繪製
就是說 實際上創建一個渲染指令編碼器
使用另一種類型描述對象一個RenderPassDescriptor
一個RenderPassDescriptor包含一系列的附件
每一個都有加載存儲操作 純色和值
和將要被渲染的Metal紋理
我們用幾頁講一下加載和存儲操作
這裏有很重要的一點需要明白
你需要構造一個RenderPassDescriptor
在幀開始的時候並且把需要它
和將要繪製的紋理相關聯
相比只需要知道像素格式的renderPipelineState
這是最重要的部分
而你必須有我們將在其中進行繪製的紋理
RenderPassDescriptor包含
渲染通道附件每一個可能是一個顏色
深度或者模型目標
或者指向需要渲染的紋理
指定這些東西叫做加載和存儲操作
我們更深入的說下是什麼意思
開始的通道中你有顏色緩存
有深度緩存它們包含未知的內容
爲了做些真正的工作我們先清空它
我們通過設置和其相關的加載動作
在RenderPassDescriptor中
我們顏色和深度目標設置一個清空加載動作
那它會把相應的顏色設置爲清空色
或者值 根據實際情況
然後我們開始繪製
會把我們作用的結果
繪製到紋理上
然後存儲操作會觸發
存儲操作包含兩部分
存儲操作的存儲
渲染的結果應該被寫會
內存並且存儲
對於顏色緩存
我們儘可能的在屏幕上展現
對於深度緩存 我們只在
實際繪製和渲染時用到
所以我們在最後的通道中不關心它的結果
我們可以設置一個存儲動作爲不關心爲了節省些帶寬
這也是你可以做的優化
如果你並不需要
渲染的結果寫會渲染對象
再深入說下加載和存儲操作
它決定了紋理內容如何被處理
在開始和結束的時候
另外對清空操作
也有加載操作讓你
加載紋理的像素內容
用之前的處理結果
它也不用關心
比如 你想從頭到尾渲染一個目標
所有的像素 那麼你不用關心
之前的紋理 你也不用清空它
因爲你知道你將會設置
每一個像素爲一些值
還一種你可以做的優化
如果你知道你會
在這個階段處理每個像素
我會告訴你 如何創建RenderPassDescriptor
然後創建一個渲染器指令編碼器幸運的是
MTKView使這些變得很簡單
之前我們配置MTKView
用幾個屬性
我希望你們熟悉它像清空色
還有渲染目標的紋理格式
實際上你可以通過請求視圖得到
當前的RenderPassDescriptor
你會獲得一個設置的RenderPassDescriptor
接下來你就可以使用它
創建渲染指令編碼器了
你該這麼做 調用渲染指令編碼器
在你的指令緩存上
你需要重點關注當前的RenderPassDescriptor是
一個潛在的塊調用
這樣的原因是 實際上它會調用
CA Metal Layers的下一個可繪製函數
我們不會詳細介紹但它是用來
獲取包含紋理的可繪製對象
來展示到屏幕上
因爲那是個有限的資源
如果當前沒有可繪製的對象
如果他們所有的在運行然後這個調用會阻塞
所以這裏需要注意
我們已經說了加載資源到內存
我們說了創建預驗證狀態
和創建渲染通道
和渲染指令編碼器
如何把數據弄到着色器中
第一我們需要說下參數表
參數表是Metal資源到
着色器參數的映射
你用的每一種資源
如緩存或者紋理
都有他們自己的緩存參數表
在右面你能看到
我們有緩存參數表
和紋理參數表它們中每個都包含幾個
緩存對應着參數表中的索引
給定參數表的插槽的可用數量
根據設備決定
你需要先查詢
我們具體說下
在渲染指令編碼器有個函數
叫setVerTextBuffer
它有三個參數
一個buffer 一個offset一個index
最後一個是我們最關心的
因爲它是我們的參數表索引
這是主機端設置資源
在使用着色器的時候
也有個對應的着色器端
像這樣
在着色器語言中間
在你的着色文件中 你指定
每一個給定的參數對應一個你要訪問的資源
有個屬性像這樣
這是第一個緩存索引
索引0在參數表中
代表我們剛纔在渲染指令編碼器的緩存
我們詳細看下
當在2D繪製中
我們創建了renderPipelineState
我們需要告訴渲染指令編碼器
在繪製前需要用哪個管線狀態
這個API就是幹這個的
我們調用setRenderPipelineState
用剛纔創建的PipelineState對象
用我們創建的着色器配置
我們用先前創建的來繪製
現在RenderPipelineState
有相關的頂點和片段函數了
我們看看頂點和片段函數
我們在2D繪圖中主要用這個
回到Metal着色語言看起來像這樣
大體上是一個直接的頂點函數
沒有複雜的數學操作
它會複製所有的屬性 直接連接
函數的第一個參數是一個頂點列表
我們剛纔創建的緩存
第二個參數是屬於
頂點ID的屬性
表示正Metal在處理的定點的
索引
它比較重要的原因
vertexBuffer包含所有的點
我們可以隨機獲得
實際上我們想在我們頂點函數
一次對一個點操作
這告訴我們正在操作哪一個
我們創建一個VertexOut結構的實例
代表定頂點的各種屬性
然後我們傳給給光柵
我們創建一個實例 並設置位置
爲向量位置vertexId的頂點
顏色也是類似
這裏進傳遞了vertexBuffer數據
給結構體供光柵來做插值
然後我們返回這個結構
讓我們看看fragmentFunction
它更簡單
所以我們得到了插值結構
它表示
光柵化得來的數據
我們剛抽取了顏色
顏色來自結構
然後再傳回去
這個過程中頂點發生了什麼
在這個例子裏截取空間指定的
被插值然後光柵化然後
被每個片段處理
我們返回由光柵創建的插值顏色
一旦我們指定RenderPipelineState
包含我們的頂點和片段函數
我們可以設置額外狀態就像我之前介紹的
包括front facing狀態
如果你想指定不同的front facing順序
而不用Metal默認的
你可以在這裏實現
這裏有許多配置項但我們只看
一些繪製調用
現在
Metal有很多函數
繪製幾何圖形包括indexedinstance和indirect
我們只看基本的索引繪製
這裏我們想畫一個三角形
我們調用drawIndexedPrimitives
我們指定原型爲三角形
因爲我們想畫三角形
我們傳遞三個索引
來畫一個三角形
我們同時需要制定索引的類型
我們之前聲明瞭一個Swift的數組集合
我們這裏複製一下
我們還要把indexBuffer傳遞下去
來表示哪些點應該繪製
我們把位移設置爲0
這會畫一個
三角形在屏幕上
我們可以添加些其他狀態
觸發一些其他繪製調用
但第一個演示我們就做這些
爲了完成一個渲染過程
我們調用Render CommandEncoder的endEncoding
回顧一下你需要創建一個請求
在開始時獲得RenderPassDescriptor
用這個描述符創建一個Render Command Encoder
設置RenderPipelineState
設置其他必要的狀態
觸發調用最後結束編碼
這是我們看到的代碼的一個概括
沒有啥新東西
和剛纔我說的一樣
創建一個Render Command Encoder設置狀態 設置狀態
綁定緩存 然後繪製
你已經渲染了這些內容
怎麼樣讓它顯示在屏幕上
非常簡單
首先 渲染路徑的顏色附件
通常是可繪製的紋理
你可從CA Metal Layer或者MKTView獲得
爲了獲得在實際上顯示的紋理
你可調用commandBuffer的present
並給它傳遞那個drawable
它將會顯示到屏幕
一旦所有的處理路徑完成
要向實際完成這一幀
由於我們把指令編碼進commandBuffer
我們要表明下我們完成了
通過調用commandBuffer.commit()
提交告訴驅動commandBuffer
已經準備好給GPU運行了
總結一下
我們創建了一個指令隊列開始
它是一個持久對象我們需要引用它
每一幀我們創建一個commandBuffer
使用渲染指令編碼器編碼一個或多個渲染路徑
通過提交commandBuffer來在屏幕上顯示
現在交給我同事Matt
帶我們完成這個2D demo繪製
謝謝 Warren
這裏是驗證部分
一個2D的三角形這是Metal三角形演示
從題目可以看出
非常簡單 就是一個三角形三種顏色
在邊上被插值
我們看下代碼
首先是MTKView的代理
Warren說我們需要實現個函數
這裏是MTKView的drawable和sizeable change
它將會在window變化時
響應
例子很簡單我們不會實現它
你們在應用中自己實現
另一個是繪製
我們選擇把它放到渲染函數
當我們的繪製被調用
我們進入渲染
渲染也很簡單
當我們拿到MTKView的當前RenderPassDescriptor
你把它弄出來 如Warren所說
然後你創建RenderPassDescriptor
然後用它編碼
大家注意這裏
“pushDebugGroup.”
這裏你可以和Metal工具交互
當你做幀捕獲
這裏會列出調試組信息
這裏 我們有一個繪製和一個繪製三角形
繪製完我們會彈出調試組
所以繪製顯示標籤爲Draw Triangle
我們看下着色器
正如Warren說的
我們已經有了結構有頂點結構
這是我們放入着色器的數據格式
只有位置和顏色
有vertex out結構
我們會傳給光柵
你看到位置被
位置屬性標記
這裏代表截取空間位置
每個點着色器或點函數 抱歉
都需要有一個
看起來都很熟悉 都很簡單
頂點進來 我們有個路徑
同時你把它們寫出去
在片段函數裏我們拿到頂點
被光柵化後 我們讀取顏色並且傳下去
這個三角形演示很簡單
下面由Warren繼續
謝謝 Matt
我們已經展示瞭如何繪製2D內容
2D非常酷什麼更酷呢
3D 我麼說說Metal中的動畫和紋理繪圖
進入3D前
我們會經過幾個階段
我們討論如何真正實現3D
我們用constant緩衝實現動畫
我們還會介紹紋理繪圖樣例
爲了進入3D
我們已經指定了我們的頂點在截圖空間
我們現在需要在一個模型本地空間指定
然後用一個合適的模型視圖做投影矩陣
爲了回到截取空間
同時我們將給普通頂點添加屬性
和紋理座標 這樣我們可以
在我們的fragmentFunction中設置光照
和設置紋理映射
這裏是我們擴展過的頂點
我們移去了顏色屬性 添加進一個向量
和一組紋理座標
和2D中的相似
我們會添加一個新的緩衝存儲所有需要的常量
引用我們的頂點和片段函數
用來合適的轉換那些頂點
你會發現這個緩存的輪廓
是虛線 這是有原因的
因爲我們不想創建另一個Metal緩存
僅僅是出於要管理這一小部分數據
只有幾個矩陣
實際上Metal也有很棒的API
用來綁定和管理非常小緩存
所以 對於小數據
小於4K的
你可以用這些API設置頂點字節
直接把數據的指針傳給他
當然需要告訴我們大小
Metal會創建和重用緩存
包含那些數據
你可以指定表的索引
這裏設置爲1
因爲我們的頂點已經被綁定在索引0
所以我們綁定在1這樣我能從其中讀取
在我們的函數中
我們看看函數如何響應
開始之前 我們看一個例子
如何在應用中調用setForTextBytes
我們創建了Constant結構
同時創建
包含兩個矩陣相乘
通過模型視圖投影和普通矩陣
這個矩陣會變換
本地空間爲iSpace
我們用自己的矩陣工具構造
然後把它們相乘
最後用setVertexBytes傳遞結構引用
然後Metal會拷貝
這個緩存用於繪製
在接下的繪製調用
現在
在去年的 WWDC我們介紹了Model I/O框架
Model I/O包含許多工具
最棒的是Model I/O包含
可以讓你生成常用圖形的方法
由於MetalKit
和Metal集成非常緊密
你可以創建頂點數據Metal可以直接渲染
我們可以不必手動指定所有頂點
我們可以這樣在一些內容創建包
裏面繪製模型 導出
然後用Model I/O加載
或在這個例子中 用程序生成
我們看看代碼
想生成些vertexBuffers表示立方體
爲了在Metal中使用Model I/O
我會創建一個MeshBufferAllocator
MeshBufferAllocator作爲Model I/O和Metal間的膠水程序
傳遞一個設備給MeshBufferAllocator
然後我們可以讓Model I/O直接創建Metal緩存
然後傳回給我們
所以我們用工具方法創建了MDLMesh
boxWithExtent等等傳進我們的分配器
這將會創建一個MDLMesh一個Model I/O網
包含相關數據
我們然後用MetalKit的工具類提取出來
就是爲我們提供的
這看起來像這樣
首先 我們生成了MTKMesh
包含我們剛纔創建的MDLMesh同時包含設備
爲了得到vertexBuffer
把它放進mesh然後抽出來
對於indexBuffer需要進行類似操作
這裏還有幾個參數
我們見過
繪製調用的時候用的
這裏強調一下
用Model I/O生成進程幾何圖形很容易
然後可以將緩衝提取出來直接在Metal中應用
下面說說紋理
我們有了頂點數據
我們想用紋理映射上去 並添加些細節
像你知道的那樣紋理是一塊內存
用特定的像素格式預先指定
主要用來存儲圖像數據
在Metal中 創建一個紋理
用描述符對象 很常見
特別是Metal紋理描述符
紋理描述符是參數對象
它把紋理屬性弄在一起 比如高和寬
還有像素格式 設備會用
它們生成紋理對象：Metal紋理
我們看看
我們有這些方便的函數
在Metal TextureDescriptor中
可以讓你得到一個2D的描述符
僅提供必要的參數：高 寬
像素格式或者你是否想mipmapped
你可調用設備的newTexture創建一個新紋理
這是一個不包含實際圖像的紋理
你需要使用替換區域或者相似的方法
你可以查查文檔怎麼做這裏我們用
另一個簡單點的工具
叫做TKTextureLoader
這是MetalKit提供的工具用來加載圖像
從資源包中 包括資源目錄
或者從一個文件URL 還有CG圖像
內存中已經有了
以NSImage或UIImage的形式
它們生成填充Metal紋理
用合適的大小和格式
與你已經有的的圖像數據有關
我們看看代碼
你可以創建一個MTKTextureLoader
通過傳入Metal設備
你會得到一個TextureLoader
同時你可以接着或許一個數據集合
或你的集合目錄中的其他東西
一旦你拿到了數據
你可調用textureLoader.newTexture
然後傳遞數據那麼將會返回一個Metal紋理
你可能熟悉取樣的概念
Samplers和Metal從紋理來說不同
他們沒有綁定在一起
Samplers只包含紋理相關的取樣狀態
一些如過濾模式 地址模式
還有層級詳細的參數
這裏展示的我們都支持
爲了獲得我們竟來要綁定的Sampler狀態
在Render Commandencoder中做紋理繪製
我們會創建一個Metal Sampler Descriptor
像這樣
我們創建了個空的Metal Sampler Descriptor
擁有默認的屬性
我們可以設置想要的屬性
這裏我們讓紋理在各個軸
上重複
當縮小的時候使用nearest filtering
當放大時用linear filtering
一旦我們創建了描述符對象
我們調用newSamplerState
得到Metal Sampler State對象
我們可以用來在紋理中綁定採樣
在Render Command Encoder中API看起來像這樣
我們創建一個紋理 把它放在插槽0
在片段紋理參數表中
然後我們綁定SamplerState在索引0
在Sampler State參數表中
我們看看這些函數
頂點函數這次會和
MVP矩陣相乘矩陣從constant buffer中獲得
它會變換頂點的位置
從本地空間到截取空間
我們會從頂點函數返回
同時它還會變換那些頂點
從Models LocalSpace到Eye Space
然後我們做光照渲染
代碼裏看起來是這樣
我們添加了一個參數屬性通過緩存1
像我之前說的通過constants緩存獲得
我們已創建了一個結構類型
在我們的Metal着色代碼中
和SWF代碼中創建constant結構關聯起來
這樣我們可得到MVP通過普通的矩陣
再一次 這個綁定在索引1的參數表
和你看到的屬性關聯起來
爲了進入截取空間
獲取vertexBuffer位於VertexID的索引
得到一個位置向量
和MVP矩陣相乘然後賦值給結構
對普通的 進行相同的操作
我們還拷貝紋理座標
給傳出結構
這些都會被光柵插值
我們接着進行返回結構
fragmentFunction比之前更參與
我們想要計算些光照
我們引用兩種環境光和漫反射
同時從紋理中採樣
應用到表面紋理中
像這樣
我們不會詳細介紹
需要注意的是
我們添加了一個參數
我們創建和綁定的
我們給它一個訪問標識符
我們用來採樣
在Argument Table Index的0位置
我們創建的Sampler State在
samplers的ArgumentSlot Zero
想獲得實際的文本
調用紋理的Sample
Text2D.Sample有個採樣狀態
和紋理座標給到顏色向量
我們接着做光照
我不會詳細介紹
它根據正常和光照方向的積來得到
我們設置了一些常量
在我們之前的着色文件演示中可以看到
這相當多
我們構造特定片段的顏色
通過乘以從紋理中採樣的值
通過光照反映到動畫紋理的立方體上
現在讓Matt給大家展示下
好的 我們看看演示
這裏有個Metal紋理網
你可以看到它是個很複雜的立方體
一些簡單的光照和紋理貼圖
在一個設置好顏色的背景上
欣賞下它
我們看看着色器
比起上一次 你能看到一些新的東西
首先是Constants結構體
是Swift寫的
有4 X 4的模型投影矩陣
和3 X 3的普通矩陣它們是用來做變換的
如Warren所說我們有些光照數據
環境光強度 這裏很弱
但漫射光 卻很高
光的方向
我們用來計算點積
輸入和輸出結構有點不同
我們現在有更多的信息需要向下傳遞
我們有position
有normal 用來光照
和紋理座標 用來紋理貼圖
相似的 當從頂點函數輸出時
我們需要相似的數據
我們看下頂點函數
如Warren所說
就是些簡單的矩陣 乘法運算
然後傳給紋理座標
快速的看下片段函數
就是剛纔給你展示的
我們看看渲染器
接着往前
我們有個小動畫
所以我們需要每段時間更新我們需要知道立方體需要旋轉多少
這裏有個幫助函數
來更是時間間隔
這將修改Constants
像Warren說的我們不想讓很多數據通過GPU傳遞
所以當你設置頂點字節
傳一個小的結構 之前的兩個矩陣
我們用來計算變動的位置
放入紋理和採樣 觸發繪製
我建議你們記住
用你的調試組 這樣你可以知道
現在在什麼位置如果你想稍後捕獲幀的話
展示繪製內容 提交 然後就可以了
很棒 謝謝 Matt
通過這些使用Metal的課程
我們想充分利用我們這幾年的
成果 教授Metal
同時介紹非常棒的新工具
讓Metal更容易使用
我們希望
這兩部分課程對此有幫助
你看到Metal是強大的低負載的
GPU編程技術 幸運的
你現在已經熟悉它
其中的一些API
Metal非常接近
和符合GPU的實際運轉情況
概念上也是這樣 我們想把
耗費資源的操作儘可能提前
你已經看到了幾種方式
怎麼安排這些API
這個課程不是強調一些限制和細節
主要是
想給你灌輸些能力
你已經看到如何明確的進行內存管理
和指令提交 可以讓你的工作更智能些
如果你知道你的應用是怎麼回事
你知道它在做什麼 然後你可以
直接控制GPU
當然接下來的幾節關於Metal課程
在今年的 WWDC我們會給你展示更多
的Metal的內容
當然 它會讓你創建有更好體驗的應用
想要了解更多的關於602會話的信息
你可以訪問這個URL同時可以參考其他相關課程
第二部分還會在這個教室
明天我們會有Metal的新東西Parts I和II
和高級Metal着色優化課程
謝謝祝你們在 WWDC 中大有收穫