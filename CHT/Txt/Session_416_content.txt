瞭解Swift功能
大家好歡迎參加“瞭解Swift功能”演講
我是Kyle
今天能跟大家一起探討Swift我和Arnold都很激動
作爲開發人員 Swift提供了廣闊而強大的設計空間等待我們去探索
Swift有各種各樣的頭等類型
以及各種代碼複用和動態機制
語言中的所有特性都能
以一種有趣、迅捷的方式結合在一起
那麼我們該如何縮小這個設計空間
併爲我們的項目選擇合適的工具呢？
嗯 首先 你要考慮到
Swift的多種抽象機制的建模意義
值或引用語義是否恰當？
這個抽象需要有多動態？
嗯 今天我和Arnold也想使你們
用性能來縮小設計空間
以我的經驗來說 考慮性能影響
總會有一個更順暢的方案
那麼 我們主要關注的是性能
我們會接觸點兒建模
但我們去年做了一些很不錯的演講 今年我們也會繼續努力
主要內容是在Swift中爲項目建模的強大技巧
如果你想充分利用本場演講
我強烈建議你們至少參加一場這類演講
好了 那麼我們想用性能來縮小設計空間
嗯 理解性能影響的最好方式是
Swift抽象機制的
理解它們的優先執行
這就是我們今天要講的主題
我們從識別 開始
不同的維度
當評估不同的抽象機制選項時
其中的每一項 我們都會演示一些代碼
用結構和類
深化我們的心智模型所涉及到的總開銷
然後 看看如何應用我們所學的技術
來清理和加速一些Swift代碼
在演講的後半場
我們要評估面向協議程序設計的性能
我們要看一下高級Swift功能的實現
如協議和泛型
來更好地理解
它們的建模和性能影響
免責聲明：我們要看一下內存表現
和所生成代碼的表現
當Swift編譯和執行你的代碼時
這些必然要被簡化
但我和Arnold認爲已達到了很好的平衡
在簡易和準確之間
這是一個很好的推理出代碼的心智模型
好了 讓我們從識別
性能的不同維度開始吧
那麼 當你在創建一個抽象並選擇一個抽象機制時
你應該問問自己
我的實例要分配給堆棧還是堆？
當我傳遞這個實例時
我要產生多少計算開銷？
當我在這個實例中調用方法時
要靜態還是動態發送？
當我們想快速地寫Swift代碼時我們就要避免
爲我們不能利用的動態和運行時間付出代價
我們需要學習何時以及如何在
這些不同維度之間切換來獲得更好的性能
好了 我們要講一下每種維度
一個一個地講 從分配開始
Swift會替你自動分配內存並取消內存配額
有些內存會分配給堆棧
堆棧是一種非常簡單的數據結構
你可以推到棧底 並彈出棧底
因爲你能只添加或移除棧底
所以我們可以實現堆棧或實現入棧和出棧
僅僅通過在棧底放一個指針
意思是 當我們調用函數時或不如說
我們把棧底的指針叫做堆棧指針
當我們調用函數時 我們分配我們需要的內存
僅僅通過遞減堆棧指針數值獲得空間
當函數執行完畢之後
我們可以釋放內存
只需要把堆棧指針增加至原來的數值即可
調用這個函數之前
現在 如果你並不那麼熟悉堆棧或堆棧指針
我想讓你從這個幻燈片中看到
堆棧分配是多麼快
字面意思其實是分配一個整數的消耗
那麼 這就與堆形成了對比
堆更動態化 但比堆棧效率低
堆可以讓你實現堆棧所不能實現的功能
比如以動態週期分配內存
但那需要更高級的數據結構
那麼 如果你要在堆上分配內存
你實際上要搜索堆數據結構
尋找閒置的適當大小的內存塊
用完之後要釋放內存
你要重新把那個內存插入適當的位置
很明顯 這涉及的東西更多
相對於我們在堆棧中實現的僅僅分配一個整數來說
但這些不見得是涉及堆分配的必要的主消耗
因爲同時可以給多線程分配內存
堆需要使用鎖來保護它的完整性
或其他同步機制
這是一個很大的消耗
如果你今天不注意
你的程序何時及在何處在堆上分配內存
僅僅需要多考慮那麼一點兒
你就能顯著地改善性能
好了
讓我們來看一些代碼看Swift都替我們做了什麼
在這裏 我們有一個點結構有x和y存儲屬性
還有draw方法
我們用(0, 0)構造點
把point1賦值給point2複製一下
並給point2.x賦一個爲5的值
然後 我們要開始使用point1和point2了
讓我們來看一下
我們進入這個函數在我們執行任何代碼之前
我們已爲point1和point2實例在堆棧上分配了一個空間
因爲點是一個結構
而x和y屬性被存儲在堆棧線中
那麼 當我們用x爲0和y爲0來構造點時
我們所要做的就是初始化那塊 內存
我們已經分配到堆棧上的
當把point1賦值給point2時
我們僅僅是複製了那個點並初始化了point2的內存 也是
我們已經分配到堆棧上的內存
請注意 point1和point2是獨立的實例
意思就是 當我們給point2.x賦一個爲5的值時
point2.x是5但point1.x仍然是0
這就是值語義
然後我們繼續使用point1 使用point2
並完成函數的執行
那麼 我們就可以來釋放point1和point2的內存
僅僅通過把堆棧指針的值增至
我們進入函數之前的值
跟同樣的代碼比較
這段代碼僅使用了一個點該點是一個類 而不是一個結構
好了 那麼我們進入這個函數
就跟剛纔一樣我們給堆棧分配內存
但並不實際存儲點的屬性
我們要給point1和point2分配內存引用
引用我們要分配到堆上的內存
那麼 我們用(0, 0)構造點
Swift會鎖住堆並搜索數據結構
尋找適當大小的閒置內存塊
然後 得到內存塊後我們要以x爲0 進行初始化
y爲0 並且我們要把point1引用初始化
用內存地址到那個堆上的內存
請注意 當我們在堆上分配時
Swift其實是爲我們的點類分配了四個字的存儲
這跟當我們的點是結構時所分配的兩個字形成了對比
這是因爲 現在的點是個類除了爲x和y存儲的之外
我們又分配了兩個字Swift將替我們進行管理
那些字通過堆圖中的這些藍色框來指示
當我們把point1賦值給point2時
我們並不是要複製點的內容
不像當point1是一個結構時所做的那樣
相反 我們要複製引用
point1和point2其實指的
正是堆上的同一個實例
意思是 當我們給point2.x賦一個爲5的值時
point1.x和point2.x的值都爲5
這就是引用的語義可導致非計劃的狀態共享
然後 我們要使用point1使用point2
然後Swift會替我們釋放這個內存
鎖住堆 再分配閒置內存塊到適當的位置
然後我們就可以出棧了
好了 我們剛看到了什麼？
我們看到類的構造比結構的構造消耗更多
因爲類需要堆式分配
由於類是在堆上分配的並且有引用語義
所以類有一些強大的特性如一致性和間接存儲
但是 如果我們的抽象不需要這些特性
我們最好還是用結構
而且結構不會導致像類那樣的非計劃的狀態共享
那麼 我們該如何應用
以便改善某些Swift代碼的性能呢
這兒有個例子是我正在做的一個消息應用
那麼 從根本上說這來自視圖層
我的用戶們發送一條短信
在那條短信末端我想畫一個漂亮的氣球
我的makeBalloon函數是生成這個圖片的函數
並支持不同的配置
或不同氣球的整體配置空間
比如說 這個氣球我們看到是藍色的
方位向右 有個尾部
我們還支持 比如說 灰色氣球
方位向左 帶氣泡
makeBalloon函數執行要快因爲我會 頻繁地調用它
在啓動分配和用戶滾動過程中
所以 我添加了這個緩存層那麼 對於任何給定的配置
我從不兩次生成氣球圖片
如果我已生成了一次我只需要從緩存中取出即可
我的實現方式是通過把顏色、方位和尾部序列化
到一個鍵中 這個鍵是個字符串
這裏有一些不妥當的地方
字符串不見得是這個鍵的健壯類型
我用它來呈現這個配置空間
但我只是把我的狗的名字放在了那個鍵中
所以 那兒不是很安全
而且字符串可以代表很多東西
因爲它實際上把它的字符內容間接地存儲在堆上了
意思是我們每次調用makeBalloon函數時
即使我們有緩存命中我們也會引發堆的分配
看看是否可以做得更好
嗯 在Swift中我們可以只用一個結構
來表示這個配置空間的顏色、方位和尾部
這是一個比字符串更安全地呈現配置空間的方式
因爲結構在Swift中是頭等類型
可以用作我們字典中的鍵
當調用makeBalloon函數時
如果我們有緩存命中就不會有內存消耗
因爲構造一個像屬性一這樣的結構
不需要任何堆式分配可以在堆棧上進行分配
更安全 也更快
讓我們繼續講下一個性能維度：引用計數
當我們談堆式分配時我隱瞞了一個詳細信息
Swift如何瞭解何時釋放
在堆上分配的內存是安全的呢？
嗯 答案是Swift會保持一個引用個數的總計數
到堆上任何的實例中並把它存儲在實例本身
當你添加引用或移除引用時
就會增加或減少引用計數
當計數爲零時Swift就知道沒有指向
堆上的這個實例的引用而且釋放那個內存很安全
引用計數的關鍵點是
這是個非常頻繁的運算實際上
比只增加和減少一個整數更復雜
首先涉及到成對出現的間接層級
來執行增加和減少
但更重要的是跟堆式分配一樣
需要考慮線程的安全性
因爲引用能被添加或移除到任何堆實例
多線程上的 同時
我們實際上要自動增加和減少引用計數
由於引用計數運算的頻率高會增加消耗
讓我們返回去看點類和程序
看看Swift替我們做了什麼
那麼 在這裏我們有用來對比的一些僞代碼
我們看到 我們的點獲得了一個附加屬性refCount
並且Swift添加了一對調用來保留–
或一個調用保留和一個調用釋放
保留會自動增加我們的引用計數
釋放會自動減少我們的引用計數
這樣 Swift就可以追蹤
堆上的點上有多少激活的引用
好了 如果我們進行快速追蹤
我們可以看到在堆上構造點之後
那個點就被初始化爲引用計數爲1
因爲我們有一個那個點的實時引用
我們查看整個程序並把point1賦值給point2
我們現在就有兩個引用了那麼Swift已經添加了一個調用
來自動增加點實例的引用計數
繼續執行一旦我們不再使用point1
Swift會添加一個調用來自動減少引用計數
因爲point1不再是一個激活的引用了
它所關注的
同樣地一旦我們不再使用point2
Swift會添加另一個自動減少引用計數
在這個點上 沒有引用被 使用
我們的點實例所以Swift就知道很安全
會鎖住堆並把那個內存塊返回給它
如果是結構會怎麼樣呢？
結構是否涉及引用計數呢？
嗯 當我們構造點結構時
不會涉及任何堆式分配
當我們複製時也不會涉及任何堆式分配
每個步驟都不會涉及引用
所以 點結構沒有引用計數
那更復雜的結構呢？
在這裏 我們有一個包含文本的標籤結構
類型爲字符串類型字體爲UIFont
我們剛纔提到過字符串實際上是把它的
字符內容存儲在堆上
所以需要引用計數
字體是一個類
也需要引用計數
我們看一下內存表現標籤有兩個引用
當我們複製它時我們實際上增加了兩個引用
另一個文本存儲另一個字體
Swift的追蹤方式是
這些堆式分配是通過添加保留和釋放的調用來實現的
那麼在這裏 我們看到標籤實際上會引發
兩倍於那個類應有的引用計數
好了 總之由於類是在堆上分配的
Swift得管理那個堆式分配的使用期限
這是通過引用計數實現的
這並不容易因爲引用計數運算
相對頻繁另外引用計數具備原子性
這也是不願使用結構的另一個原因
但是 如果結構包含引用
也會進行引用計數
事實上 結構會進行引用計數
相應地與它們所包含的引用數量成比例地
所以 如果它們有一個以上的引用
它們會保留一個類以上的引用計數
讓我們看看如何把鏈應用到另一個示例
從我那個假設的消息應用中
那麼 我的用戶們不願意只發送文本消息
他們還想發送附件 如圖片
那麼 這個結構附件在應用中是一個模型對象
有fileURL屬性
即在磁盤上存儲這個附件的數據路徑
有一個通用的唯一標識符是一個唯一的、隨機生成的標識符
這樣 我們就可以識別這個附件了
在客戶端和服務器端以及不同的客戶設備上
還有一個mimeType 用於存儲
這個附件所使用的數據類型如JPG、PNG或GIF
很可能的情況是 唯一重要的代碼
這個示例中可能導致初始化失敗 會檢測
mimeType是否爲應用所支持的文件類型中的一個
因爲我並不支持所有mimeType
如果不支持 我們就會失敗
反之 我們會初始化fileURL、唯一標識和mimeType
那麼 我們注意到有很多引用計數
並且 如果我們看一下這個結構的內存表現
屬性引發了引用計數
當傳遞屬性時
由於在每個結構的底層有進行堆式分配的引用
我們可以做得更好
首先 就像我們剛看到的
唯一標識是一個意義明確的概念
它是一個隨機生成的標識符有128個位元
而且我們絕對不想讓你隨意在唯一標識字段放入任何東西
且作爲一個字符串其實你是可放入任何東西的
嗯 今年 Foundation增加了一個新的數值類型
爲唯一標識 這很棒 因爲它會存儲那128個位元
直接在結構線中
讓我們用一下那個新數值類型
它要實現的是
移除所有引用計數所帶來的消耗
爲唯一標識字段就是那個字符串
我們將獲得更好的安全性
因爲我們不能在這兒隨意放東西了 我們只能放唯一標識
棒極了
讓我們看一下文件類型
以及如何實現文件類型檢測
今天 我實際上只支持了文件類型的一個閉集
JPG、PNG、GIF
我們都知道Swift有強大的抽象體系
來表現固定集合 這是個枚舉
我要把那個switch語句
放到可能導致初始化失敗的程序中
並把那些mimeType映射到枚舉中合適的案例中
那麼 現在 我得到了更多的mimeType枚舉值
而且我還獲得了更優化的性能因爲我不需要 存儲
在堆上間接地這些不同的案例
Swift實際上有一個非常簡潔、有效的方式
來寫這段代碼
就是使用由原始字符串值支持的枚舉
所以 這就是有效的代碼完全一樣
除了更強大之外
有同樣的性能特徵但寫起來更便利
我們現在看一下附件結構
該方式使類型更安全
我們得到了類型非常強大的唯一標識和mimeType字段
我們也不用做那麼多引用計數
因爲唯一標識和mimeType不需要進行引用計數或堆式分配
好了 讓我們繼續看最後一個性能維度
方法調度
在運行過程中當調用一個方法時
Swift需要執行正確的實現
是否能在編譯時確定要執行的實現
這就是著名的靜態調度
在運行過程中 我們只能直接跳到
正確的實現
這很酷
因爲編譯器實際上可以看到
要執行哪些實現
並且也可以
強行優化這個代碼包括一些像內聯的東西
這跟動態調度形成了對比
動態調度
在編譯時我們不能直接決定
要執行哪個實現
在運行過程中我們實際上需要查找實現
然後跳到那兒
那麼 對於實現本身 動態調度
比靜態調度的消耗並不多
只有一個間接層級
沒有一個線程同步像我們之前
引用計數和堆式分配中的那樣
但是這個動態調度阻塞了編譯器的可見性
所以 編譯器可以實現所有很酷的優化
爲靜態調度
動態調度編譯器不能推理通過
那麼 我提到了內聯什麼是內聯？
嗯 讓我們返回去看我們熟悉的點結構
有一個x和y還有一個draw方法
我還添加了這個drawAPoint方法
drawAPoint方法在點中應用只調用draw
很有意思
我的程序用(0,0)構造了一個點
並把那個點傳給drawAPoint
嗯 drawAPoint函數和point.draw方法
都是靜態調度
意思就是編譯器完全瞭解
要執行哪些實現
所以它實際上只要把drawAPoint調度
替換爲drawAPoint的實現
然後再把point.draw方法
因爲它是個靜態調度
替換爲實際的 實現即可
point.draw的
那麼 當我們在運行過程中執行代碼時
我們可以只構造點
然後運行實現 就完成了
我們不需要那兩個靜態調度
以及設置和銷燬相關聯的堆棧調用
這很酷
這就回答了爲什麼是靜態調度以及靜態調度
比動態調度要快多少的問題
然而 就像單一靜態調度與單一動態調度形成對比一樣
並沒有太多不同但是一個完整的靜態調度
編譯器可以看到整個調度
因此 動態調度鏈
要在推理的每一步中被阻塞
在沒有它的較高層級上
所以編譯器要能
分解靜態方法調度鏈
就像沒有調用棧的
單一實現
這很酷
我們究竟爲什麼要這個動態調度呢？
嗯 原因之一是它可以啓動很強大的東西
比如多態
我們看一個傳統的面向對象的程序
有一個可繪製的抽象超類
我可以定義一個點子類和線子類
用自定義實現來覆蓋draw
然後我有個程序可以多態地
創建繪製的數組
可能包含線 可能包含點可以分別調用draw
那麼是如何實現的呢？
嗯 因爲可繪製的點和線都是類
我們可以創建一個數組大小都一樣
因爲我們在數組中通過引用來存儲
然後當我們查看每一個數組的時候
在數組上調用draw
我們明白或者希望我們有一些直覺
爲什麼編譯器不能在編譯時做出決定
哪個是要執行的正確的實現
因爲這個d.draw可以是個點可以是條線
這是不同的代碼路徑
那麼 如何決定調用哪個呢？
嗯 編譯器向類中添加了另一個字段
是那個類的信息類型的指針
存儲在靜態內存中
因此 當我們調用draw時
編譯器實際上替我們生成的是一個對類型的查詢
查找一個虛擬方法表
在類型和包含指針的靜態內存上
找到要執行的正確的實現
所以如果我們修改了這個d.draw
編譯器替我們做的是
我們看到實際是查詢虛擬方法表
找到要執行的正確的draw實現
然後把那個實際的實例作爲隱藏的自-參數傳過來
好了 那麼 我們看到了什麼？
嗯 類默認動態地調度它們的方法
這對於它本身並沒有什麼不同
但是如果形成方法鏈或其他形式可以防止
內聯優化 並且可以累計
但是 並不是所有類都需要動態調度
如果你從未打算給一個類創建子類
你可以把它標記爲最終類傳給隨後的同事
和未來的你 那是你的打算
編譯器會注意到這一點
並動態地調度這些方法
此外 如果編譯器可以推理和證明
你從不打算在應用中給類建立子類
它將適時地替你把那些動態調度返回
到靜態調度
如果你想了解更多實現方式
請參考去年關於優化Swift性能的演講
好了 我們講到哪兒了？
在演講的上半場我想讓你瞭解的是
問你自己的這些問題
無論何時 當你讀和寫Swift代碼時
你都應該看和思考
“這個實例要在堆棧中還是在堆中分配？”
當我傳遞這個實例時
我要引發多少引用計算？
當我在這個實例中調用方法時
是動態調度還是靜態調度？
如果我們不需要執行動態調度
會影響我們的性能
如果你是Swift新手或是使用代碼庫
從objective C移植到Swift
你很可能會更好地利用結構
就像我們今天在例子中所看到的爲什麼我使用結構而不是字符串
有一個問題是
“如何用結構寫多態代碼？”
我們還沒有講
嗯 答案是面向協議程序設計
現在讓我們歡迎Arnold來到臺上給大家講解
去吧
謝謝Kyle
大家好 我叫Arnold
讓我們一起來看一下
協議類型和通用代碼的實現
先講協議類型我們要看如何
存儲和複製協議類型的變量以及方法調度的運作
讓我們再回到我們的應用中
這次 我們要用協議類型來實現
這次我們不再用可繪製的抽象基類
我們要用聲明瞭draw方法的可繪製協議
並且我們有數值類型的點結構
和遵循協議的線結構
請注意 我們還有一個遵循協議的SharedLine類
然而 我們決定不再讓由於非計劃共享
而使類所具有的引用語義
出現 讓我們停止它
我們程序仍然是多態的
我們可以存儲點類型和線類型的值
在可繪製的協議類型數組中
然而 跟以前相比有一個不同點
請注意我們的線數值類型結構
和點結構並不共享一個共同的繼承關係
做V-表調度所必須的就是Kyle剛展示給我們的機制
那麼 Swift是如何調度正確的方法的呢？
在這個例子中是通過徹底審查數組實現的
這個問題的答案是一個基於表的機制
叫協議證明表
每種類型都有一張表
會在你的應用中實現協議
並且表中的條目
會鏈接到類型中的一個實現
好了 那麼 現在我們瞭解如何找到那個方法了
但是仍然有個問題
“如何把元素從數組中拿到表中？”
還有另一個問題
請注意 我們現在有數值類型的線和點
線需要四個字
點需要兩個字
它們的大小不一樣
但數組需要一致地存儲元素
在數組中以固定的偏移量那是如何實現的呢？
這個問題的答案是Swift使用一個特殊存儲佈局
叫存在容器
裏邊有什麼呢？
存在容器內的前三個字
是留給valueBuffer的
小類型 比如我們的點類型只需要兩個字
剛好能放進valueBuffer中
現在 你可能會說“等一下 那線呢？
它需要四個字我們該把它放哪兒去？”
嗯 在這種情況下Swift會在堆上分配內存
並把值存入內存 而且會給那個內存存一個指針
在存在容器中
現在 你看到了點和線之間的不同點
因此 存在容器無論如何得管理這個不同點
那麼該如何實現呢？
嗯 答案是 還是基於表的機制
在這個示例中我們叫它值證明表
值證明表會管理值的有效期
在程序中每種類型都有一張表
現在 讓我們來看一下局部變量的有效期
看這個表是如何運作的
那麼 在協議類型的局部變量的有效期的開始
Swift在那個表內部調用了分配函數
在這個函數中 因爲這個例子有一個線值證明表
我們將在堆上分配內存並給該內存存一個指針
存在容器的valueBuffer內
下一步 Swift要把複製
值從賦值源代碼中
初始化局部變量的
到存在容器中
我們在這裏有一個線
所以值證明表的複製條目
會做出正確的判斷並把它複製到valueBuffer中
在堆中分配的
好了 程序繼續
我們現在是在局部變量有效期的最後階段
Swift會調用值證明表的破壞條目
這將遞減可能包含在類型中的
值的引用計數
線並沒有任何引用計數所以這裏沒什麼需要注意的
然後 在最後
Swift會調用表中的解除分配函數
再說一次我們有一個線的值證明表
這將釋放在堆上爲值分配的內存
好了 那麼 我們已經看到了
Swift處理不同種類的值的一般性機制
但無論如何它仍需要進入這些表 對吧？
嗯 答案很明顯
值證明表的下一條是一個引用
在存在容器中對值證明表的
一個引用
最後如何進入協議證明表呢？
嗯 它是 再說一次在存在容器中進行引用的
我們已經看到那個機制
關於Swift是如何管理協議類型的值
讓我們來看個例子
看看運行中的存在容器
在這個例子中 我們有一個函數
把協議類型參數當做局部參數
並在局部參數上執行draw方法
然後 我們的程序會創建一個局部變量
可繪製的協議類型的並用點對其進行初始化
然後把這個局部變量傳給
一個drawACopy函數調用作爲它的參數
爲了顯示Swift編譯器爲我們生成的代碼
在這個例子中我將使用Swift作爲僞代碼註釋
那麼 對於存在容器而言我有一個結構
存儲valueBuffer的三個字
還有一個值證明表和協議證明表的引用
當drawACopy函數調用執行時
它會接收實參並把它傳給函數
在生成的代碼中我們看到
Swift把存在容器傳給了
實參的函數
當函數開始執行時
函數爲那個形參創建了一個局部變量
並給它賦了一個實參
在所生成的代碼中
Swift將在堆上分配一個存在容器
下一步 它將讀取值證明表和協議證明表
從實參存在容器中
並在局部實參容器中對字段進行初始化
下一步 它將調用值證明函數
分配緩衝區 如果必要的話還會複製值
在這個例子中 我們傳了一個點
所以就不需要任何動態堆式分配了
這個函數只是從實參中把值複製
到局部存在容器的valueBuffer中
然而 如果我們傳一個線
這個函數將會分配緩衝區並在緩衝區中複製值
下一步執行draw方法
Swift會從存在容器字段中
查詢協議證明表
在那個表的固定偏移中查詢draw方法
並跳到那個實現
但是稍等一下
還有另一個值證明調用就是projectBuffer
它爲什麼會在那兒？
嗯 draw方法把值的地址當成了它的輸入
請注意 這取決於值是否爲
正好能放進內聯緩衝區的小值決定了這個地址是否爲
存在容器的開始
或若我們有一個大值不適合放進內聯valueBuffer
那個地址就是在堆上分配的內存
的開始
那麼 這個值證明函數把這個不同點抽象化了
根據類型
然後執行draw方法 執行完畢
現在 我們是在函數的末端
意思就是 爲形參創建的局部變量超出了適用範圍
所以Swift調用
一個值證明函數來破壞值
這將遞減引用計數
如果值中有引用的話
並且如果分配了緩衝區會釋放緩衝區
函數執行完畢 移除了堆棧
也移除了在堆棧上創建的
局部存在容器
好了 這個工作量很大
是吧？
我想告訴你們的是
這項工作是使結合的值類型
如結構線和結構點還有協議
獲得動態行爲、動態多態性
我們可以 存儲一條線和一個點
在可繪製的協議類型的數組中
如果你需要這個多態性一切都值得你付出
跟使用類相比
就像Kyle在示例中給我們演示的一樣
因爲類也要查詢V-表
並且類還有附加的引用計數
好了 我們已經瞭解如何複製局部變量
以及方法調度如何處理協議類型值
讓我們看一下存儲屬性
那麼在這個例子中我們有個對兒
包含兩個存儲屬性第一個和第二個屬性
即可繪製的協議類型的
Swift是如何存儲這兩個存儲屬性的呢？
嗯 是封閉結構的內聯
那麼 我們看一下-當我們分配一個對兒時
Swift將存儲這兩個非常必要的存在容器
對於在封閉結構內聯中存儲那個對兒來說
然後 我們的程序就開始執行並初始化 這個對兒
線和點正如我們之前所看到的
對於線我們將在堆上分配一個緩衝區
把點放到內聯valueBuffer並把它內聯存儲
到存在容器中
現在 這種呈現允許在後面的程序中
存儲一個不同類型的值
那麼 程序繼續執行把線存入第二個元素
沒什麼問題但我們現在有兩個堆式分配了
好的 兩個堆式分配
嗯 讓我們用另外一個程序
來說明堆式分配的消耗
那麼 再一次 我們創建一個線
然後創建一個對兒並用線對這個對兒進行初始化
那麼 我們有一個、兩個堆式分配
然後我們再一次複製那個對兒
堆棧中有兩個存在容器然後有兩個堆式分配
現在 你可能會說
“Kyle剛告訴我們說堆式分配的消耗很大”
四個堆式分配？
嗯 我們能做點什麼嗎？
嗯
請記住存在容器能容納三個字
可以把引用放進
那三個字中因爲引用基本上是一個字
那麼如果我們用類代替線來實現
並且類是個引用語義因此它們
通過引用存儲 該引用可放入valueBuffer中
當我們把第一個引用複製
到對兒的第二個字段時只複製了引用
我們消耗的只是附加的引用計數增量
現在 你可能會說 “等一下
我們剛纔不是聽說引用語義會引發
非計劃的狀態共享嗎？”
那麼 如果我們存儲到x1字段
通過對兒的第二個字段
第一個字段可以觀察到變更
這並不是我們想要的結果
我們想要的是值語義 對吧？
嗯 我們能做點什麼呢？
嗯 有一種技術叫複製並寫入
可以幫助我們處理這個問題
那麼 在我們寫入類之前
我們要先查看它的引用計數
我們已經瞭解到
當同一實例有一個以上的明顯引用時
引用計數將大於一
二、三、四或五
如果是這種情況在我們寫入實例之前
我們先複製實例然後寫入那個副本
這將削弱狀態
好了 讓我們以線爲例看看是如何實現的
我們不直接在線的內部實現存儲
創建一個叫LineStorage的類
這個類有線結構的所有字段
然後線結構引用這個存儲
無論何時當我們要讀取值時
我們只需要從那個存儲內讀取值
然而 當我們想要修改、改變值時
我們首先要查看引用計數
是否大於一？
這是UniquelyReferenced調用要實現的
它只有一個功能就是查看引用計數
是否大於或等於一？
如果引用計數比一大
大於一
就創建一個線存儲的副本並修改這個副本
好了 那麼 我們已經瞭解如何結合一個結構和一個類
使用複製和寫入獲得間接存儲
讓我們再回過來看例子看看發生了什麼
這次 我們使用間接存儲
我們再創建一個線
這將在堆上創建一個線存儲對象
然後 我們用那個線對對兒進行初始化
這次 只複製線存儲的引用
當我們複製線時
只會複製引用引用計數會遞增
這比堆式分配的消耗小多了
這是個不錯的交易
好了 我們已經瞭解如何複製和存儲協議類型的變量
以及方法調度的運作方式
讓我們看一下這些對於性能的意義
如果協議類型包含能放進存在容器的內聯valueBuffer中
的小值
那麼就不存在堆式分配
如果結構不包含引用
也就無所謂引用計數了所以 這真的是一種快速編碼
然而 由於間接
查詢值證明表和協議證明表
我們得到了完整的動態調度
這就允許動態的多態行爲
跟大值比較大值會引發堆式分配
無論什麼時候初始化或賦予協議類型的變量
可能也將引發引用計數
如果大值結構包含引用的話
然而 我演示了一種技術
就是使用可複製和寫入的間接存儲
承擔堆式分配的部分消耗
這適用於消耗較少的引用計數
請注意 與使用類相比很有優勢
類還會引發引用計數
並在初始化時進行分配
這是筆好交易
好了 那麼 我們回顧一下簡而言之
協議類型提供多態的動態形式
值類型可以跟協議一起使用
並可以在協議類型的數組內存儲線和點
這是通過協議 實現的
和值證明表以及存在容器
複製大值會引發堆式分配
然而 我講了一種如何解決這個問題的技巧
即通過用間接存儲及複製和寫入實現結構
好了 讓我們再回到應用中
那麼 在我們的應用中我們需要draw一個函數
以協議類型爲形參
然而 我們的使用方式是
我們要一直在具體類型上使用
在這裏 我們要在線上使用
稍後 我們會在點上使用
然後我們會想“嗯
我們能在此使用通用代碼嗎？”
嗯 是的 我們能
讓我們看一下
在演講的最後我要談一下
通用類型的變量如何存儲和複製以及變量與方法調度的運作方式
那麼 再返回我們的應用這次 我們要使用通用代碼來實現
DrawACopy方法把一個泛型參數限制變得可繪製
程序的其它部分保持不變
那麼 跟協議類型有什麼不同呢？
通用代碼支持多態的更靜態的形式
也叫做參數多態性
每種調用情境都有一種類型
這是什麼意思呢？嗯 讓我們看這個例子
我們有foo函數
這個函數把泛型參數T限制變得可繪製
並把這個參數傳給bar函數
這個函數再一次取走泛型參數T
然後 我們的程序創建一個點
並把這個點傳給foo函數
當函數執行時
Swift會把泛型類型T綁定到
本次調用中所使用的類型在這個例子中是點
當foo函數帶着這個綁定執行時
它會進入bar的函數調用
局部變量的類型是剛發現的也就是點
那麼 泛型參數T再次
在這個調用情境中通過點類型進行綁定
我們可以看到 在調用鏈中類型隨着參數被取而代之
這正是我們的用意...
通過更靜態的多態形式或參數化的多態性
那麼 讓我們看看Swift是如何在後臺實現的
讓我們再次回到drawACopy函數
在這個例子中我們傳遞了一個點
就像我們使用協議類型時一樣有一個共享的實現
這個共享的實現如果我可以給你展示它的代碼
就像之前展示的協議類型的代碼一樣 兩者的代碼看起來很相似
可以使用協議和值證明表
在函數內部執行運算
然而 因爲每種調用情境都有一個類型
所以Swift不會在這裏使用存在容器
相反 它可以傳遞值證明表
和協議證明表– 點的
在這次調用中使用的類型的
作爲函數的附加參數
因此 在這個例子中我們看到點和線的
值證明表被傳過去了
在那個函數的執行過程中
當我們爲參數創建局部變量時
Swift將使用值證明表
在堆上分配可能必要的緩衝區
並根據目的地執行賦值源代碼的副本
當在局部參數上執行draw方法時 很相似
它將使用所傳遞的協議證明表
在表中查詢固定偏移的draw方法
並跳到那個實現
我剛剛說過了這裏沒有存在容器
那麼 Swift是如何給局部參數
給爲這個參數創建的局部變量
分配所需要的內存呢？
嗯 它在堆棧上分配一個valueBuffer
該valueBuffer仍是三個字
像點這樣的小值會放進valueBuffer
像線那樣的大值仍然會存在堆上
並且我們在局部存在內存裏存了一個指示器
所有這些都是爲了使用值證明表
現在 你可能會問“這樣會更快嗎？這樣會更好嗎？”
“我可不可以不只使用協議類型？”
嗯 多態的靜態形式可以使編譯器優化
叫做泛型特化
讓我們具體看一下
這是我們的drawACopy函數
取走泛型參數我們把一個點傳給
那個函數調用方法
我們有靜態多態調用時有一種類型
Swift使用那個類型在函數中替換泛型參數
並創建那個類型專用的
函數的一個版本
那麼 在這裏 我們現在有點函數的drawACopy了
取走點類型的參數
函數內部的代碼仍然是那個類型專用的
就像Kyle給我們的展示的一樣這是非常迅捷的編碼
Swift將給程序中的調用所使用的每個類型都創建一個版本
那麼 如果我們在點中調用線上的drawACopy函數
它將特化並創建那個函數的兩個版本
現在 你可能會問“等一下
這可能會大量增加代碼量 對嗎？”
但是 由於靜態類型信息
不能使編譯器優化
Swift實際上可能會減少代碼量
那麼 比如說它將內聯點函數的drawACopy
然後進一步優化代碼因爲現在有更多的情境了
因此 那個函數調用基本上可以爲這一條線
而正如Kyle所說的這可以進一步減少爲
draw的實現
現在 不再引用點方法的drawACopy了
編譯器也將把它移除
並在線示例中執行類似的優化
因此 幾乎不太可能發生
編譯器優化會增加代碼量
有可能發生但不一定是在這種情況下發生
好的 那麼 我們已經瞭解特化
但還有一個問題“何時進行？”
嗯 讓我們看一個小例子
那麼 我們定義了一個點然後創建了那個點類型的局部變量-
把它初始化到一個點然後把那個點傳給
drawACopy函數
爲了特化這個代碼 Swift需要
在這次調用中推斷出類型
它是可以實現的因爲它可以看到那個局部變量
再返回去看它的初始化
然後就會看到它被初始化成了一個點
Swift還需要有在特化過程中所使用的類型
的定義
和通用函數自身
這裏的情況是這樣的在一個文件中進行了所有定義
這個文件能在很大程度上提高整個模塊優化
的優化機率
讓我們看看這是爲什麼
比如說我把點的定義挪到另一個文件中
如果我們分別編譯那兩個文件
當我編譯UsePoint文件時
點的定義就不再可用了
因爲編譯器已經分別編譯了那兩個文件
然而 對於整個模塊優化
編譯器將把兩個文件作爲一個單元一起進行編譯
洞悉點文件的定義
並進行優化
因爲這能很大程度地提高優化機率
現在 我們在Xcode 8中啓動了默認整體模塊優化
好的 讓我們再返回來看我們的程序
那麼 在我們的程序中我們有可繪製的協議類型的對兒
並且 我們再次意識到要如何使用它
無論什麼時候我們要創建一個對兒時 我們實際上是想
創建同一個類型的對兒
比如一對兒線或一對兒點
請記住 一對兒線的存儲表示
會消耗兩個堆式分配
當我們看這個程序時
我們注意到我們可以在這裏使用泛型類型
如果我們把對兒定義爲泛型
然後那個泛型類型的第一個和第二個屬性有這種泛型類型
那麼 編譯器實際上可以強制
我們只能創建同一個類型的對兒
此外 我們也不能在後面的程序中把點存儲到一對兒線中
這的確是我們想要的結果
但是這樣的表示對於性能來說是好是壞呢？
讓我們看一眼
那麼 在此我們有對兒
這次 存儲屬性是泛型類型的
請記住我剛纔說過的不能在運行過程中改變類型
對於生成的代碼來說 這意味着
Swift可以分配閉合類型的存儲內聯
那麼 當我們創建一對兒線時
給線分配的內存實際上將被分配給內聯的閉合對兒
不需要任何額外的堆式分配
這很酷
然而 就像我所說的你不能再向不同類型的值中存儲
那個存儲屬性了
但這正是我們想要實現的
好的 我們已經瞭解了非專用代碼如何使用
值證明表和協議證明表
以及編譯器如何通用函數的指定類型的版本
特化代碼創建
讓我們看一下它的性能
首先看包含結構的特化通用代碼
在這種情況下我們有性能特性
與使用結構類型相同因爲正如我們所看到的
從本質上說 通用代碼
看起來就好像是你按照結構來寫的這個函數
當我們複製結構類型的值時
不需要任何堆式分配
也不需要引用計數
如果結構不包含任何引用的話
而且我們有靜態方法調度
進一步地優化編譯器
並減少運行—執行時間
如果我們使用類類型那麼跟類類型相比
我們有跟類相似的特性
堆式分配、創建實例和引用計數
是爲了傳遞值
並對V-表進行動態調度
現在讓我們看看包含小值的非特化通用代碼
不必給局部變量進行堆式分配正如我們所看到的
因爲小值可以放入分配到堆棧中的valueBuffer
如果值不包含任何引用也不會有引用計數
然而 我們在所有潛在的調用情境中
通過使用證明表
共享一個實現
好了 今天我們這場研討會講了
結構和類的性能特性
以及通用代碼和協議類型的運作方式
我們學到了什麼？
哦 嗯 就這樣吧
我忘了該講哪個笑話了
如果我們使用大值和通用代碼
就會引發堆式分配
但我之前展示過那個技巧 也就是
使用間接存儲方案
如果大值包含引用的話
然後還有引用計數
然後我們再一次實現了動態調度
意思是 我們可以共享一個通用實現
在代碼中
好了
最後讓我們看一下簡述
總結
爲應用中的實體選擇合適的抽象
動態運行時間要儘可能少
這將啓動靜態類型的檢測編譯器可以確保
編譯過程中程序的正確性 此外
編譯器有更多的信息來優化代碼
從而得到更迅捷的代碼
那麼 如果你可以在程序中使用值類型 如結構和枚舉
表達實體
你將得到值語義 這很棒
不會出現非計劃的狀態共享
並且你將獲得高度優化的代碼
如果你因爲需要 使用類 比如
一個實體或你正在使用一個面向對象的框架
Kyle給我們展示瞭如何減少引用計數的消耗的一些技巧
如果你的部分程序可以使用一個更靜態的多態形式來表達
你可以把通用代碼和值類型結合起來
並獲得非常迅捷的代碼
但共享那個代碼的實現
如果你需要動態多態 比如
在我們的可繪製協議類型示例的數組中
你可以把協議類型和值類型相結合
得到跟使用類得到的代碼同樣迅捷的代碼
但你仍然可以停留在值語義內
如果你遇到了堆式分配問題
因爲你在協議類型或泛型類型內複製值
我也給你們展示了一種技巧 也就是
使用可複製和寫入的簡潔存儲來處理
好的 那麼 這裏有一些與建模和性能
相關的演講
我強烈推薦你們參加今天下午的一場演講
“UIKit應用中以協議和值爲導向的編程”
謝謝大家