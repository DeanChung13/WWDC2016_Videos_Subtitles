高級Metal着色器優化
大家好
我叫Fiona這是我的同事Alex
我任職於iOS GPU處理器團隊
我們的工作就是讓大家的着色器運行於最新的iOS設備上
而且讓它們儘可能高效地運行
這裏我要談一下我們的演講
高級Metal着色器優化
鍛造和打磨你的Metal着色器
我們的編譯器是基於LVM的
而且我們和開源社區合作
讓LVM更加適用於GPU
這是其它幾個Metal相關的演講萬一你錯過了的話
不用擔心 你可以上網看錄像
昨天講了Metal應用的第一部分和第二部分
今天早些時候講了Metal新特性的第一和第二部分
因爲Metal有太多新的東西了
當然 現在這個是最後一部分
就是你們現在看的東西
所以在這個演講中我們將討論一些東西
你們可以利用這些編輯器相關的東西來讓你們的代碼運行地更快
這些中的一部分是針對A8處理器和更新的圖像處理器
包括一些從未被公佈過的信息
其中一些也將比較通俗
我們會談到大家看到A8的圖標
在演示文稿中 是針對A8處理器的
另外 我們會談一些潛在的陷阱
這些東西一般不會出現 就像微優化
你們經常發現的那樣
但是一旦你們碰到了很有可能會降低很多性能
相比之下 其他東西都不重要了
所以始終要確保你們不會掉入這些陷阱
這些會被標記上三角符號正如你們看到的那樣
在我們繼續之前 這不是第一步
這是最後一步
進行低級別的着色器優化是沒有意義的
除非之前你已經做了高級別的優化
比如觀看其他的Metal演講
優化你的繪製調用 你的引擎結構等等
優化你的着色器差不多是你要做的最後一件事情
而且 這個演講主要是給經驗豐富的着色器程序員
也許你在Metal方面經驗豐富
而且你想要更深入的學習優化着色器
又或許你剛開始接觸Metal但你已在着色器優化方面做了很多工作
在其他平臺而且你想知道如何更好地優化
A8處理器和更新的圖像處理器這個演講就是爲你們準備的
你可能已經看過這個管線圖了若你看過任意一個之前Metal演講
當然 我們也將聚焦在這個管線圖的編碼階段
正如你們所見的 着色器課程
首先 Alex將會講一下一些着色器性能的基本知識
和一些高級一點的問題
然後 我會回來講一些低級別的底層的 繁瑣的着色器優化
着色器性能基礎
謝謝Fiona 首先讓我解釋一下
着色器性能基礎
這些是你想要確保
你們是對的在你們深入瞭解源代碼級別的優化
通常你們在此所做改變的影響可能弱化
或者潛在地掩蓋你在其它地方做的更加有針對性的改變
所有今天我打算談四個方面
緩衝參數的地址空間選擇
緩衝預加載
碎片函數資源的處理
和如何優化電腦內核
好 讓我們從地址空間開始
因爲這個功能不存在於
所有着色語言我給大家簡單的入門
所以 圖像處理器有很多的途徑從內存中拿到數據
而對於不同的應用場景這些途徑都是被優化過的
所以它們有着不同的性能特徵
在Metal中 我們給了開發者使用路徑的控制權
通過要求它們符合所有的緩存器參數和指針
在着色語言中 用它們要用的地址空間
所以一部分地址空間專門用於
從內存中提取信息
其中的第一個就是設備地址空間
這是一個限制相對較少的地址空間
你可以通過地址空間來讀寫數據
你可以傳任意多的數據
你在API級別指定的寄存器
有着相對靈活的參數要求
另一方面 你有固定的地址空間
如名字中所寫這是一個只讀的地址空間
但是有另外一些約束
你能傳輸的數據量是有限制的
通過地址空間 另外 緩存區偏移量
你在API級別指定的有更加嚴格的對齊要求
但是 這就是地址空間
被優化 爲了大量數據重用的情況
所以 每當它有理的時候你就會利用這個地址空間
找出是否這個連續地址空間
對你的緩衝器參數有意義
通常在於兩個問題
第一個問題是我是否知道我有多少數據
如果你的數據量是變化的
這通常就是你需要使用設備地址空間的一個信號
另外 你要看一下緩衝器中的每一個有多少被讀取
如果這些可能被讀取多次
這通常表示你需要把他們放下連續地址空間
讓我們用幾個例子把這付諸實踐
例子源於一些頂點着色器
首先 你有規則的原始頂點數據
可以看出 每個頂點有自己的數據塊
而且每個數據塊只被自己的頂點讀
因此基本上沒有重用
這是在設備地址空間真正需要滿足的條件
接着 你有投影矩陣以及其它的矩陣
現在 屬於你的
是你有一個對象這些對象被單一的頂點讀
在完全的數據重用情況下
你想這個對象在常量地址空間裏
把東西混合一點後 分析常量矩陣
在這種情況下 很大可能你能得到最大
bone數這些對象是你正在處理的
但是你單個看每個bone時
矩陣可以被每一個和那個bone相關的頂點讀取
這也是潛在的大量重用
所以這也該在常量地址空間裏
最後，讓我們來看看每一個實例數據
如你所見，例子中的所有頂點
將會讀取這個特定的數據
但是另一方面你有一些潛在的可變實例
所以這也應該在設備地址空間裏
爲何地址空間的選擇對於性能那麼重要
我們進入到下一個話題 緩衝器預加載
Fiona將會花些時間講一下
如何真正地在着色器中優化加載和存儲
但在很多情況下你能做的最好的事就是
把這個工作交給專門的硬件去做
以下兩種情況我們能做優化
背景緩存和頂點緩存
但是這基於 你知道着色器中訪問模式
和你把它們放在了什麼地址空間
讓我們以常量緩存預加載
所以這裏想說的是
不同於通過常量地址空間來加載
我們其實要做的是拿到你的數據
然後將它們置於特殊的常量寄存器這些寄存器是更快的
對於ALU的讀寫
所以只要我們知道什麼數據會被讀取我們就可這麼做
如果你的偏移量是已知的編譯時間這就很直接明瞭了
但是如果你的偏移量在運行前是未知的
那麼我們就需要一些額外的信息
關於你正在讀取多少數據量
所以給編譯器表明這個通常需要兩個步驟
第一 你需要確保這個數據是在常量地址空間
另外你需要表明你的訪問時是靜態綁定的
做這個最好的方式是通過傳參數時
儘量使用引用而不是指針
若你只是傳遞一個參數或者一個結構體
這是很直接的你可以只改變指向引用的指針
和對應地改變你的訪問
如果你傳遞一個綁定的數組這就會有所不同
所以你在這個例子中要做的是你可以嵌入那個大小的數組
並將那個結構體通過引用來傳遞而不是傳遞原來的指針
我們通過一個例子來實踐一下
在前燈碎片着色器
如你在原始版本中看到的那樣
我們有的是一些參數
作爲普通設備指針進行傳遞
而且這並沒有給出我們想要的信息
所以我們能比這個做得更好
相反 若我們注意到燈的數量相互關聯
我們能做的就是將燈的數據
和數量一起放在這麼一個結構體中
然後將這個結構體傳給常量地址空間
作爲像這樣一個引用
這樣 我們就實現了常量緩存預加載
讓我們在看一個例子看看它實際中是如何影響你的
實現延遲渲染有很多種方式
但是我們發現實際上你選擇的實現方式
會對實踐中你實現的性能
有很大的影響
現在一種常用的模式是使用單一着色器
來積累出所有燈光的結果
正如你在函數的聲明中看到的那樣
它可能在這個場景中讀取任意或者所有的光
這意味着你的輸入大小是無關聯的
另一方面 如果你能結構化你的渲染
使得每一個光在它自己的繪製調用中被處理
那麼每一個光就只需要讀那個光的數據
它是着色器 那意味着你可以傳遞
在常量地址空間和充分利用緩存預加載
其實我們發現在A8後的圖像處理器上這有一個很大的性能提升
現在讓我們談一下頂點緩存預加載
頂點緩存預加載的目的是重用相同的專用硬件
我們會在固定的函數頂點獲取中使用
我們可在常規緩存加載中做這個 就像
你在讀取緩存看上去就像固定函數頂點獲取
它意味着你需要
使用頂點或者實例的ID來進行索引
現在我們可以處理一些額外的改變
爲頂點或者實例ID比如應用一個發生器
使用或者不使用基本頂點
或實例偏移量你可能在API級別的應用
當然最簡單的方式是充分利用
儘量使用Metal頂點描述功能
但是如果你寫你自己的索引代碼
我們強烈建議設計你的數據
使得頂點線性到達而簡化緩衝區索引
意識到這並不妨礙你做自己喜歡的事情
比如你在畫矩形 你想賦值
給矩形的所有頂點你仍然可以做其它事情
像用頂點ID除以4建立索引因爲這看起來就像個分配器
讓我們繼續着色器階段的一些具體問題
在iOS 10裏我們介紹了記錄資源的功能
在片段功能裏
對於隱藏的表面去除有着有趣的含義
在這之前你也許已經習慣這種行爲
片段不需要被着色
只要一個不透明的片段過來遮擋它
所以這不再是正確的尤其
當你的片段功能正在寫資源
因爲這些資源記錄仍需要發生
相反你的行爲僅僅取決於前面所發生的事情
確切地說 發生什麼取決於
在你的片段功能裏你是否能進行早期的片段測試
如果你通過 了早期的片段測試一旦被柵格化
只要它通過早期的深度和模塊測試
如果你沒有指定早期的片段測試
那麼只要它被柵格化了你的片段就會被着色
所以從最小化你的着色器的角度看
你要做的是儘量早地使用早期片段測試
但是有一些其它事情
你可以做的 來提高你得到的拒絕
且這其中大部分歸結於繪製順序
你想要繪製這些圖案
片段函數進行資源寫的圖案
在不透明的圖案的後面
而且如果你使用這些圖案來更新的你的深度和畫筆緩存
我們強烈建議你把這些緩存按照從前到後進行排序
注意這個指導應該聽上去相當的熟悉
如果你曾經處理過片段函數
丟棄或者修改你每一像素點的深度
現在讓我談一談計算機內核
因爲計算機內核的決定性特徵
決定了計算能力
我們來說說什麼因素影響了你在iOS中是怎麼做的
首先 我們有計算機線程啓動的限制
所以在A8及以後的圖像處理器上有一定量的時間
被花在了啓動一些計算機線程
所以如果你的在一個計算機線程中沒有做足夠多的工作
這就會使硬件沒有被充分利用
這就降低了性能
一個處理這個問題比較好的方式和一個好的模式
對於在iOS上寫計算機內核
是在一個計算線程上處理多個概念的工作條目
尤其我們找到一種工作得很好的模式是
重用數值 不是通過線程組內存傳遞
而是通過重用加載的數據爲下一個工作條目
當你在同一個計算線程中處理下一個工作條目
最好通過一個例子來闡述這點
這是一個音節過濾內核
這是一種最直接的版本了
它讀取三個不發音的區域
併產生一個輸出像素點
所以如果應用處理多工作條目的模式
在單一計算線程中我們就得到類似於這樣的東西
注意現在我們是在以一次兩個像素點向前邁進
所以處理第一個像素點和它以前做的沒區別
我們讀取這個3乘3的區域
我們應用了這個過濾器且寫上去了這個數值
但讓我們看看第二個像素點是如何被處理
支架是以一次兩個像素點邁進的
我們需要確保有第二個像素點被處理
現在我們讀取了它的數據
注意到這個像素點所需要的三分之二的區域
已經被之前的像素點加載
所以我們不需要重新加載我們可重用這些原有值
現在我們所需要加載是這個像素點的新的三分之一
之後 我們就能應用過濾器完成任務
注意 最後我們不是做12個紋理讀取
不是原有的9個而是我們在創建2個像素點
在大量的單個像素點的紋理獲取中這是個有意義的縮減
當然這個模式並不適用於所有的計算使用案例
有時你仍然要通過線程組內存傳遞數據
這種情況下 當你同步
一個線程組中的線程的時候
需要記住一個重要的事情是
你想要使用柵欄在儘量小的範圍內
爲你需要同步的線程
尤其若你的線程組在一個SIMD裏面
在Metal中通常的線程組閘函數是不需要的
你可以使用的
是新的SIMD組閘函數這是在iOS 10中引入的
我們發現的實際上是線程組
符合單一SIMD和使用SIMD組閘通常要快於
使用一個更大的線程組爲了擠壓另外的重用
但是不得不使用線程組閘作爲結果
總的來說
確保你使用正確的地址空間
爲每一個緩存參數
根據我們說的規則
機構化你的數據和渲染最大程度地利用常量
和頂點緩存預加載
確保使用早期片段測試來過濾
儘量多的片段當你在做資源寫操作的時候
給每一個計算給予線程足夠的工作量這樣你就不會被限制
在計算線程啓動
給任務使用最小的欄柵當你需要
同步線程池中的線程的時候
那麼 我想讓Fiona詳細地講一下調製着色器代碼
謝謝Alex
在進入這些細節之前
我想要講一下一些圖像處理器的普通特性
和一些你們可能會遇到的瓶頸
可能你們中所有的人都熟悉它
但是我覺得還是有必要快速的過一下
對於圖像處理器通常來講你有一組資源
經常會發生的事情是着色器被其中的一個資源給卡住了
舉個例子 你卡在了
內存帶寬提高你的着色器中的其它東西
通常不會帶來明顯的性能提升
識別出這些瓶頸
和聚焦在這些瓶頸上以提高性能是很重要的
這實際上對於非瓶頸的東西也是有益的
比如 在那個例子當中如果內存使用成爲了瓶頸
你通過提高算法變得更加高效
你仍然節約了電量即使你沒有提高幀速率
當然在移動設備上節約電量始終是是重要的
所以這不是一個能忽略的東西
只是因爲幀速率在那個例子中沒有上升
所以在着色器這裏你需要記住四個典型的瓶頸
第一個是非常直接的ALU帶寬
圖像處理器能處理的數學計算量
第二是內存帶寬 同樣也是非常直接的
圖像處理器能從系統內存中加載的數據量
另外兩個相對就沒那麼明顯
第一是內存問題率
它表示能執行的內存處理量
這會出現在以下的場景中當你的內存處理比較小的時候
或者你使用很多線程組內存等等
最後一個也是我等會兒會深入講的一個
是延遲佔用寄存器使用
也許你已經同說過它來但是我會把它留在最後
所以爲了緩解其中的一些瓶頸
和提高着色器的性能和效率
我們將一起看一下四類優化機會
第一類是數據類型
首先要想到
當你優化着色器時 是選擇數據類型
當你選擇數據類型時最重要的一件事是A8
及更新的圖像器有16位的寄存器單元
這意味着當你使用32位數據類型時
那就是兩倍的寄存器空間 兩倍的帶寬
可能是兩倍的電量等等總之所有東西都是翻倍的
所以 對應的 需要節約寄存器
這樣會得到更快的性能 更低的能耗
通過使用更小的數據類型
在運算中儘可能地使用半字節和短字節的變量
從能耗看半字節比浮點型變量節能多了
浮點型比整型又要節能
甚至在整型當中短整型又要比長整型節能
你節省寄存器最有效的方式
是給紋理和插值使用半字節型
因爲通常情況下你並不需要浮點型
注意我不是指紋理格式
我指的是數據類型這數據類型是你用來存儲
紋理樣本或者插值的結果
A8及更新的圖像處理器中是相當方便的
使得比在其它圖像處理器上使用更小的數據類更加的簡單
是因爲數據類型轉換一般是免費的
甚至在浮點型和半字節型之間
這意味着你不需要擔心
我會不會在使用半字節類型的過程中引入了太多的類型轉化
這會導致消耗太多嗎這是否值得
不 因爲類型轉換是自由的所以很可能是更快了
無論何時你都可以使用半字節類型不需要擔心這個部分
需要記住的一點是半字節精度的數值
和限制與浮點型數據是不同的
經常出現的一個錯誤
如寫65,535這樣一個半字節類型
但它實際上是無窮大
因爲這比最大的半字節類型還要大
所以要注意有哪些限制條件
最好能知道哪裏應該用半字節類型 哪裏不應該用
降低在着色器中發生意外錯誤的可能性
一個例子應用
對於使用短整型數據類型 是線程ID
你們中與計算機內核打過交道的應該知道
線程ID在程序中是廣泛被使用的
所以把它們弄得小一點能很大程度地提高
運算的性能 可以節省寄存器等等
對於本地線程ID 在這個例子中沒有理由去使用無符號整型
因爲本地線程ID不能用那麼多的線程ID
對於全局線程ID通常你可以使用無符號短整型
因爲大多數情況下你不會有那麼多的線程ID
當然這要取決於你的程序
但是在絕大多數的情況下你不會超過2的16次方減1
所以你可使用無符號短整型
這會降低功耗 也會更快
因爲所有線性ID相關的運算都變快了
所以我強烈建議你儘可能的這麼做
另外 記住在類C的語言中
當然這也包括Metal
運算的精度是通過輸入類型的大小來定義的
比如 一個浮點型乘以一個半字節型
這是一個浮點型運算而非半字節型運算它會向上提升
所以對應的 確保儘量不要使用浮點型
因爲這會把一個半字節運算
輸入半字節型 返回半字節型變成一個浮點型運算
因爲根據語法
這實際上是一個浮點型運算因爲輸入值中至少有一個是浮點型
所有你可能想要做麼做
事實上 這就會是一個半字節型運算
而且會變得更快
這可能就是你所說的
所以要注意 不要在不經意間引入浮點型精度的運算
在你的代碼中當你其實並不想要它時
雖然我剛纔說了數據類型越小越好
有一個例外是字符型
在A8及更新的處理器上原生的數據類型大小
是16位的 而不是8位的
所以字符型並不會節省空間或者能耗或者其它一些東西
進一步說 沒有原生的8位運算
所以它似乎要被仿真
如果你需要的話它不會過度的耗資源 隨便用
但是它可能會導致額外的指令
所以不要把變量壓縮爲字符型
在沒有必要的時候
所以接下來我們會有計算優化
在這個類別中幾乎所有的都會影響ALU帶寬
你能做的第一件事情始終是儘量使用Metal內置
它們是給各種不同的函數優化實現的
它們已經爲硬件進行了優化
通常來講 會比你自己實現的要好
特別的
實際上 他們中的一些通常是免費的
這是因爲圖形處理器通常都有修改工具
運算可以通過輸入輸出指令免費地執行
對於A8及以後的圖形處理器通常包括非門
絕對值和飽和值 像你們看到的一樣這三種綠色的運算符
所以 沒有必要嘗試着讓你的代碼更加聰明或者加速它
通過避免這些
同樣是因爲他們幾乎總是免費的
因爲他們是免費的你不可能比免費更加好
無法在免費的基礎上再進行優化了
A8及更新的圖形處理器和很多其它處理器一樣 是標量機器
而着色器通常是用向量表示的
編譯器會把它們在內部分離開來
當然 寫向量代碼並沒有什麼壞處
它經常更加清晰 也更容易維護
而且它符合你想要的東西
但是它也不會比寫標量代碼更加好從編譯器的角度
和你要得到的代碼
所以沒有必要去向量化代碼
那並不符合向量格式
因爲最後它只會導致一樣的東西
而你浪費了你的時間
但是 從一個側面說明我等會兒會深入說一下
在A8及更新圖像處理器上
確實有向量加載在存儲裏儘管他們沒有向量運算
所以這只是應用於算術
指令級別並行
你們中有些人可能已經優化過了
特別是若你做過中央處理器相關的工作
但是在A8及更新的圖形處理器上這通常不是一個好事情
去嘗試優化它因爲通常它要與寄存器使用競爭
而寄存器使用通常更重要
所以你可能見過的一種普通模式是一種
你有多個有序的加法器
在圖形處理器上更好地處理延遲
但是在A8及更新的圖形處理器上這可能是降低效率的
你最好只使用一個累加器
當然 這會導致更多的複雜例子
比人工的簡單例子
簡而言之
不要嘗試去重新結構化你的代碼從中得到更多的ILP
這可能並不會對你有所幫助
最糟糕的是 你的代碼可能變得更差
所以在A8及更新的圖形處理器上有個相當好的功能
就是它們有着非常快速的選擇指令集它們是三元運算符
過去 使用一些小聰明是非常普遍的就像這個
在三元運算符中執行選擇操作爲了避免那些分支等等
但是在現代圖形處理器上這些通常會是起相反的效果
特別是對於A8及更新的圖形處理器
因爲編譯器不會考慮這些小聰明
它不會明白你的真實意圖
真的 這是非常糟糕的
你可能剛剛寫了這個
而且它會更快 更短
它會展示你的意圖
像以前一樣 太過聰明反而會變得複雜
你所做的會使編譯器困惑
現在 它就是一個潛在的陷阱希望這不會經常發生
對於相對的圖形處理器它們中的大部分都沒有整數除法運算
或者取餘數指令集整數型而不是浮點型
所以避免除法運算
不是字面的或者函數常量
這個新特性在前面當然演講中提到過
所以在這個例子中 我們想說的是
分母是一個變量
那就會非常非常得慢
想象一下成百上千的時鐘秒針
但是這另外兩個例子 它們會非常得快
它們是好的
不要覺得你必須要避免它
最後 快速數學運算的主題
在Metal中 快速運算是默認的
這是因爲編譯器是經過快速運算優化過的
這對Metal着色器的性能來說至關重要
這能提供50%或者更多的性能提升相較於沒有快速運算
這也是爲什麼它是默認開啓的
那麼在快速運算模式下我們到底做了什麼事情呢
第一 一部分Metal中內置的函數
對於有沒有快速運算有着不用的精度保證
所以在某些函數中它們會有稍微低一點的精度
在快速運算模式中會有更好的性能
編譯器會提高中間件的精度
對於你的運算比如通過組成一個多個加法指令集
這不會降低中間件的精度
所以舉個例子如果你寫了一個浮點型的運算
你的這個運算至少是浮點型的運算
不是一個數學運算
若你想要寫一個半字節型的運算
你最好就自己寫編譯器是不會幫你做的
因爲這是不被允許的
它不會讓你的精度達到那樣
我們確實會忽略如果不是一個數字 無窮量
和符號零 這是很重要的
如果不那樣的話 你不能真正證明
x乘以0等於0
但是我們不會引進一個新的NaN不是一個數字
因爲現實中 那是一個非常好的方式
來激怒開發者 毀壞他們的代碼
我們不想要這麼做
編譯器會執行算術重整合
但是不會做算術分配
而且實際上 這不會毀壞代碼
而且會使得它更快
我們不想毀壞代碼
所以無論什麼原因如果絕對不能使用快速運算
還是有方法恢復一部分性能
Metal有一個內置的融合的乘法加法
它允許你直接請求融合的乘法加法指令集
當然如果快速運算被停用
編譯器就不會被允許編譯它們
它不會改變你的四捨五入的一位這是被禁止的
所以如果你想要使用融合的乘法加法而且快速運算是停用的
你需要使用內置的
而且那會重新增加一部分的性能
不是所有的性能 但至少有一部分
所以 我們的第三個話題 控制流程
預測的GP控制流程不是一個新的話題
你們中的一些人可能對此已經非常熟悉了
但我快速回顧一下這對你來說有什麼意義
控制流程在SIMD中是一致的
每一個線程都在做同一件事情相當的快速
就算編譯器看不到它 這也是真的
所以如果你的程序看上去不一致
但是隻有當運行的時候它才一致
那仍然是很快的
類似的 這個分歧的另一面
不同的道路做不同的事情
在那個例子中 它可能不得不運行
於所有的路徑 同時地
不同於中央處理器在一個時間點只會選擇一個路徑
因爲它會做更多的工作
當然也就意味着不高效的控制流程
會影響任意一個瓶頸
因爲它只是直接地表明圖像處理器做了更多事情
無論是什麼事情
所以 在控制流程這個話題上我給大家的一個建議
是避免切換fall-through
這在中央處理器的代碼中非常的普遍
但是對於圖像處理器它們可能會成爲低效
因爲編譯器不得不做相當嚴重的轉型
爲了讓它們符合圖像處理器的控制流程模型
而且經常的 這會導致冗餘的代碼和各種各樣的麻煩的東西
你可能不希望發生這樣的事情
若你能找到好方法來避免代碼中fall-through切換
你可能會變的更好
現在到了我們最後一個話題
內存訪問
我們現在先從大家最可能碰到的陷阱開始說
那是動態地索引非常量堆數組
這是非常有爭議的
但你們中很多人可能已熟悉這些代碼了大致上看上去着這樣的
你有一個包含數值的數組在運行時被定義
在每一個線程或者每一個函數調用中變化
而且你索引這個數字通過另外一個也是變量的值
這就是動態索引非常量堆
在我們繼續之前
我不會想當然的認爲
對於圖形處理器 堆棧是慢的
我會解釋爲什麼
所以 對於中央處理器通常你有多個線程 或者幾十個線程
且你有幾MB的緩存分配在這些線程中
所以每一個線程可能有成千上百KB的堆棧空間
在它們變慢和不得不去處理主內存之前
對於圖形處理器通常會有成千上萬的線程在同時跑
而且它們都在分享一個小得多的緩存
所以平均下來
每一個線程只有非常小的空間給數據和堆棧
這不單單意味着那個這不是很高效
作爲一個慣例對於絕大多數的圖形處理器程序
如果你使用堆棧 你已經輸了
這會非常慢使得幾乎其他任何東西都本有可能更好
一個真實世界的應用
程序開始時 它需給向量從兩個浮點型數據中選擇一個
它用了32字節的數組一組兩個浮點型數據
在他它們中選擇 使用這個堆棧數組
這會導致30%的性能損失
在這個程序中 儘管只在開始時做一次
這也會是相當的重要
當然每次我們提高編譯器的時候
我們要儘量避免
儘量
避免產生這些堆棧訪問因爲這是不好的
現在我要給大家展示兩個好的例子
另外一個 哪些是常量 不是變量
那不是一個非常量堆棧數組 沒關係
因爲每一個線程的值不會變化
它們不需要在每個線程中被複制
所以這是可以的
這個也是可以的
等等 爲什麼？這仍然是一個動態索引非常量堆棧數組
但是它只是做動態索引 因爲這個迴路
而且編譯器會展開這個迴路
實際上 你的編譯器展開任意的迴路
那會訪問這個堆棧爲了讓它停止這麼做
所以在這個例子中它被展開後 就不再被動態索引了
它會變得很快 值得提出來的是
因爲在大量的圖形學代碼中這是非常普通的模式
而且我不想嚇唬你不要這麼做當它可能還行的時候
既然我們已經講了這個主題
關於如何不要做加載和存儲這些類型
讓我們繼續講加載和存儲我們會講得快一些
當A8及更新的圖像處理器都是用標量算法
正如我前面說過的那樣它們確實有向量內存單元
一個大的向量加載資源自然比
多個小向量要快當小向量相加大小和這一個大向量一樣
這通常會影響內存處理速率瓶頸
因爲你通過負載來運行 那沒多少負載
對於iOS 10我們新的編譯器優化中的一點
是我們會去向量化一些負載和存儲
會去儘可能地鄰接內存位置
同樣是因爲它可以給出好的性能提升
雖然如此這是一個處理編譯器時的例子
可能會很有幫助 我給大家舉個例子
正如你們看到的這樣這是一個簡單的迴路
它做了一些計算和讀取了一個結構體數組
但是在每一步循環 它只讀取兩個加載
現在如果可以 我們想要它變成一個
因爲一個比兩個要好
而且編譯器也想這樣
它想要向量化這個 但是它做不到
因爲A和C在內存中不是緊挨着的
所以它什麼都做不了
編譯器是不被允許重新安排結構體的
所以我們有兩個負載
對此有兩個解決辦法
第一 當然是把它變成一個浮點型
它就是向量負載了 結束了
一個負載 兩個一組 什麼都好了
而且 對於iOS 10這也一個相同的快速
因爲在這裏 我們重拍了我們的結構體讓值一個接一個
那樣編譯器可以向量化負載當它做這個的時候
這同樣是一個處理編譯器的例子
編譯器被允許做一些它以前做不了的事情
因爲你知道到底發生了什麼
你知道如何選擇模式 使得編譯器開心
讓它可以做
所以 另外一個要記住的關於負載和存儲的事情
是A8和更新的圖像處理器有專門的硬件
給設備內存地址分配
但是這個硬件是有限制的
訪問設備內存的偏移量必須在有符號整型的範圍內
小一點的數據類型比如短整型和無符號短整型也是可以的
實際上 它們是被強烈推薦的
因爲那些也是在有符號整型的範圍的
但是 無符號整型當然不是的
因爲他可能有值超出了有符號整型的範圍
所以如果編譯器發生一種情況
當偏移量是一個無符號整型就不能保證
它會很好的待在有符號整型的範圍內
必須手動地計算地址
而不是讓專用硬件來做這個
那樣會浪費電量
它會浪費ALU性能等等
這是不好的
所以 把你的偏移量轉爲整型這樣問題就解決了
當然利用這個通常會節省ALU帶寬
所以在我們的最後一個話題上我前面有所掩蓋
延遲和佔用
現代圖像處理器的核心設計之一是隱藏延遲
通過使用大規模的多線程
所以當它們等待一些慢的東西結束
比如紋理讀取它們只是運行另一個線程
而不是坐着什麼都不幹只是等待
這是相當重要的
因爲紋理讀取通常要花好幾百個循環
才能結束 平均下來
所以你在着色器中延遲越多
你就需要更多的線程來隱藏延遲
你有多少線程呢？
這限制於你有一定數量的資源
它們被一個線程組中的線程共享
所以顯然基於每一個線程的使用量
你需要限制線程的數量
相沖突的兩件事情是
寄存器和線程組存儲器的數量
所以在每個線程中你使用寄存器越多
你就不能使用這麼多線程
太簡單了
如果你在每個線程中使用的線程組越多
你又會遭遇同樣的問題
每一個線程對於你的線程
你可以檢查着色器的實際佔用率
用MTLComputePipeLineState導致maxTotalThreadsPerThreadgroup
這將告訴你着色器的實際佔有率是多少
基於寄存器的使用率和線程組存儲器的使用率
所以當我們說着色器延遲限制
這意味着用來隱藏着色器延遲的線程太少
這時 你可以做兩件事情
你可以減少着色器的延遲
保存寄存器 另外一件事是
避免使用更多的線程
所以 對於一個非常大而複雜的着色器克服延遲是有點困難的
我將會重溫一些僞代碼實例
可能會給你強烈的直覺
在你的着色器中如何考慮延遲和怎樣略微理智地建模
所以 這兒有一個REAL的依賴案例
有一個紋理樣本然後我們使該紋理樣本
執行if語句
然後我們在x語句裏創建另一個紋理樣本
我們必須等兩次
因爲我們在執行if語句前必須等一次
在使用值之前又必須等一次
第二個紋理樣本的
兩次連續的紋理訪問造成總共兩次延遲
這兒有一個錯誤的依賴案例
該依賴看來很像另個
除非我們在if語句中不使用它
但是通常我們不能等待跨控制流程
這種情況下if語句成爲了一個嚴重的障礙
所以我們不得不等
即使沒有數據依賴
所以我們仍然有兩次延遲
當你意識到GPU並不在乎數據依賴
它只在乎出現什麼依賴
這樣第二個依賴的延遲時間和第一個是一樣的
即使那兒沒有數據依賴
最後有個簡單的依賴
在頂端你僅僅獲取兩個紋理
它們都被並行獲取這樣我們就只等一次
所以就是1 x延遲而不是2 x延遲
所以 運用這個知識你將會幹什麼呢？
在很多實際着色器中 你有機會
在延遲和吞吐量之間權衡
一個常見的案例是
你能決定代碼以一個紋理獲取爲依據
在這個着色器中我們不必做任何事還是早點放棄
而且這是非常有意義的
因爲在這種情況下你要做的事情
將不必做 你正在保存所有的工作
太棒了
但是當你增加吞吐量
通過減少你需要乾的工作
但是你也增加了延遲
因爲現在必須獲取第一個紋理然後等待紋理獲取
接着做早期的終止檢查
接着做其它的紋理獲取
呃 會更快嗎？難道不是嗎？
時常你只需要測試一下
因爲哪個更快真正依賴的是着色器
但是值得考慮的事時常是真正的權衡
你時常要測試來明確什麼是正確的
雖然沒有通用規則
我可以針對A8和後期的GPUs給你一個獨特的的指南
那就是同一時刻硬件至少需要兩個紋理獲取
來獲得足夠的性能來避免延遲
一個是不夠的
如果你只能做一次 沒有問題
但是如果你有一些選擇
來分配着色器中的紋理獲取
如果你同一時刻允許它做兩次
你會獲得更好的性能
所以 總結就是
確保你選擇了
正確的地址空間 數據結構 佈局等等
因爲把這個弄錯會導致
這個演講中的其它東西都不重要了
用編譯器工作
寫下你想的
不要嘗試着太聰明
否則編譯器不知道你想什麼而迷失
且不能做好它自己的任務
另外 寫下你想的是很簡單的
注意大陷阱而不僅僅是極小的優化
它們時常不明顯而且它們也不時常發生
但當它們發生時 會導致嚴重的問題
它們導致的問題如此嚴重以至於再多的小優化都無法彌補
隨意試驗
會發生很多定律權衡
根本就沒有單一的定律
全部都試一下 看哪種更快
如果你想要更多的信息 上網查詢
演講視頻就在網上
還有其它的演講
如果你又錯過了 視頻在網上都會有的
謝謝