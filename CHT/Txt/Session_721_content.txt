統一日誌和活動追蹤記錄未來
歡迎大家來到“統一日誌和活動追蹤——記錄未來”
感謝大家能在週五晚上來到這裏
我是Steven Szymanski
真沒想到這個時間還有這麼多人來聽
我是Steven Szymanski將會主持大部分演講
稍後我會邀請Matthieu Lucas上臺
那麼我們開始吧要講的內容很多
我開始先做個簡單的介紹
然後講講新的日誌系統背後的基本概念
這是這周才引入的新系統
一會兒做個簡短的演示
然後再回過頭來講解如何真正使用它
如何使用API怎麼使用這些工具
再討論一下我們心目中的最佳操作
然後講一下如何收集你創建的記錄
最後講一些棄用的界面
那麼開始吧
先講一點背景
如果你已經聽過幾場演講你就知道在2014年
Apple引入了“活動追蹤”的概念
它能跟蹤所有的工作
代表某些操作在整個系統裏運行
這個工作可以在一個應用裏完成
可以在應用調出的一個框架庫裏完成
甚至可以代表應用在另外的進程裏完成
我們同時引入的另一個概念
就是故障和錯誤
這種特殊類型的日誌事件會引發額外的工作
讓系統收集額外數據
作爲開場白的最後一點
就是我們意識到Apple已有一些記錄API
而且希望演講結束後你能明白我們爲什麼要介紹
這個新的API以及它如何與其他人相互關聯
那麼這個項目的目標是什麼？
首先我們想要做的是創建
一個公開公共且有效的記錄機制覆蓋整個系統
既能用在用戶模式下也能用在內核模式下
目標
其中一個目的是爲了儘可能多的收集信息
同時 最小化觀察者效應
這裏的觀察者效應指的是我們開發者都有的體驗
當你遇到問題將一些日誌粘貼到你的代碼
問題一下子就沒有了因爲你改變了時間
我們想要一個無痕的記錄界面
在你調出代碼的時候對代碼的影響最小
如何實現這一目標就是這場演講我要具體講的內容
首先 我們壓縮數據
這樣就能在磁盤上存更多的信息
卻不佔用更多空間
另外一件重要的事就是我們延遲了許多工作
我們能做的所有事情都是在顯示信息的時候
而不是在收集信息的時候所以我們想要延遲到那個時候
這是我們採用的主要方法來避免觀察者效應
另外我們做的就是用新方法來管理消息的生命週期
我們的想法是不同種類的信息
可能在系統裏停留的時間不同
要儘可能讓你想要的信息真正出現在
你實際去研究和使用它們的時候
背景情況是我們想要能
打開系統裏儘可能多的日誌無論在任何時候
而不需要回去再說
“能否打開這個再給我一個新的日誌”
我們要看到所有越多越好
另外一個動機是
我們想把隱私完全融入系統裏
這個我一會兒也會細講
那麼這個新系統的主要功能是什麼？
就是用新改進的方法分類和篩選日誌消息
因此我們將爲你提供新的工具
讓你能給日誌信息分類
這樣在需要查看日誌的時候
能更簡單的找到你要的信息
特性
另外很重要的一點是日誌系統會爲你收集調令源的信息
所以你不再需要傳遞文件和代碼行
去確定這個調令來自哪裏
我們自動爲你收集好
這裏還有很多新的內置分類符
讓我們可以爲你處理二進制數據的格式
這樣你就不用花時間做這個了
我們有個新的Console應用和一個新的命令行工具
我們用它們來訪問所有的功能
我們所有的平臺都支持它
macOS iOS watchOStvOS和所有的模擬器
它同時也可用於...
用於這周發佈的CC++和Objctive-C版本
不久之後也會支持Swift
那麼現在給你一些小預告
這是現在使用的Console應用就是你看到的這樣
而這是新Console的樣子
這裏我要指出
仔細看看高亮的這一部分
這個樹狀圖向你展示的是一個特定活動
不斷從一個進程到另一個進程的過程
這樣你就可以直觀的看到所有的工作情況
它們代表你所請求的操作
那麼我們先來打個基礎 講講理論
以及背後的抽象概念
首先 採用
如果你想使用新的統一日誌系統你一開始要做的
就是使用這周新發布的SDK來進行創建
如果這樣做
所有遺留的API NSLogasl log和message syslog
所有這些都會被重新引入新系統
你一行代碼都不用改就可以開始使用這個系統
當然如果要使用這些新功能就要開始使用新的API
但是如果你什麼都不做直接使用新系統創建
它們就都被引入新的日誌架構
另一方面如果你不想開始使用
新的日誌系統並且繼續用舊的SDK創建
那麼你的系統不會有任何變化
採用
下面來講新的文件格式
在新的系統裏日誌數據是以二進制形式壓縮在磁盤裏
叫做.tracev3文件
這些文件現在的保存路徑爲/var/db/diagnostics
其輔助文件的路徑爲/var/db/uuidtext
現在可以用新的工具訪問這個數據
我們有新的Console新的命令行工具
你還要記住一點
就是由於數據以二進制格式保存
你必須使用新工具來訪問
所以你不能再用grep命令查找日誌而必須用我們的工具
來瀏覽日誌
還有另一種新的文件類型.logarchive
這是爲了實現數據可移植性
其實.logarchive文件是信息的集合
來自/var/db/diagnostics和uuidtext
它們集合到一個文件裏
這樣就能更方便郵件傳輸添加到故障報告等
這個系統背後的另一個新概念是
子系統和分類
日誌消息現在可以與一個子系統和一個分類聯繫在一起
它可以用來控制日誌消息的篩選和顯示
一個子系統實際上可以包含很多個不同的類別
而且你可以使用很多子系統和分類只要你需要
舉個例子你可能有一些應用
並定義一個子系統爲com.your-company.your-application
它有三個分類setupinprogress和teardown
在同一個應用裏
你還可以定義另一個子系統com.your-company.test.your-application
只包含一個分類測試
你可以用它們來控制日誌消息的顯示
日誌行爲這是這個系統的核心所在
每個日誌消息都有一個級別由你創建使用的API決定
有三個基本級別：DefaultInfo和Debug
還有兩個特殊級別：故障和錯誤
每個基本級別有兩個特徵
既可以在系統範圍內定義給某個子系統
也可以給子系統裏定義一個特定類別
第一個是指是否可用
如果你發出指令它是否真的能生成一個log line
要注意默認消息總是可用的
你無法關閉默認消息
另一個特徵就是你可以定義所有級別
是要保存到磁盤還是內存
看上去應該是存到磁盤裏
但是我說的是存到內存裏
新的統一日誌系統
保存了大量的內存中環形緩衝區
一些日誌消息可以被轉到這裏
然後這些消息只會在故障和錯誤時存到磁盤裏
這很有用尤其是對很快就過期的消息來說
假設你有一個消息
這個信息基本上已經沒用了
你所能看到的就是這個消息最後的版本
無論何時你收到一個日誌都沒有必要把幾百個
不同的備份存到磁盤上
如果存到緩衝區它就可以在故障與錯誤中找到
而且就是你需要的最後一版
而不用存一堆額外的東西
這些級別是有順序的
也就是說 若你定義Debug給磁盤
那麼信息也會引入磁盤
所有這些行爲都可以自定義
通過安裝文件或者在macOS上使用log命令
會立刻出現什麼樣的標準行爲呢？
如果你沒有安裝一個特定文件的話
Default級別的消息總是可用
標準配置下他們會進入磁盤
Info級別的信息可用但是他們進入內存
Debug級別的信息是關閉的他們不可用
當然因爲處於關閉他們哪裏也去不了
那麼另外兩種類型的消息就是故障和錯誤
故障和錯誤通常都是開啓的並總是存入磁盤
現在花點時間來講講隱私
你知道Apple十分重視客戶隱私
作爲指導原則我們設計的所有產品
在我們的應用 服務以及OS的新版本
都要尊重用戶的隱私
所有的開發者 包括你們在座的各位都跟我們有一樣的責任
如何在日誌裏體現呢？
我們想避免的是不小心記錄了
能夠識別個人信息的日誌
這樣其他人就可以從日誌數據中提取信息
因此 動態字符串集合 陣列和對象等
都被認爲是包含隱私的數據
靜態字符串和標量被認爲是可公開的
稍後我們會進一步講講怎樣控制它
現在來看故障和錯誤
我之前講過作爲活動追蹤的一部分
我們引入了故障和錯誤的概念
它的一個基本理念就是
我們在故障和錯誤上下更多功夫
就能保存更多的信息
錯誤指的是一個問題
出現在不同應用或者庫裏
對於錯誤我們查找內存緩衝區
收集來自相關進程的所有日誌消息
並保存到磁盤上作爲錯誤的一部分
相對而言 故障代表的是系統中更廣泛的問題
是更大型的故障
針對故障我們查找存儲緩衝區
收集相關進程的所有日誌消息
以及這個活動涉及到的所有進程
實際上我們還收集了一些其他系統信息
它們可能對我們有用
故障與錯誤以及所有作爲它們的部分而收集的日誌數據
都實際上存到了單獨的一套日誌文件中
這樣做是爲了不讓正常的日誌把他們擠掉
因爲這會導致它們超出份額佔用更多的空間
也就是說故障和錯誤的數據會一直存在
甚至比正常的日誌數據還長
好的 現在我來做一個很直觀的介紹
看看系統如何在細節大量丟失的情況下工作
這是個比較寬泛粗略的討論
好了 每一個進程裏
有一個小緩衝區的集合我們會把日誌消息存在這裏
這些緩衝區實際存在於與日誌守候進程共享的內存裏
緩衝區滿了的時候日誌守候進程就會開啓
把數據壓縮進它的一個更大的緩衝區
當這些大的緩衝區也滿了的時候我們可以把它們存到磁盤上
也可以再利用將它們作爲內存緩衝器的一部分
架構
那麼最後會做的就是
請求在線流式日誌數據
比如你在Console上想看到的日誌
是在一出現就實時記錄的
我們執行的方法是
立刻做一個IPC連接到診斷守候進程
它會分發日誌消息給所有的客戶
副作用是
它會極大的影響在線流式日誌數據的性能
基本上我們做了很多努力來節省力氣 提高日誌的速度
這樣你的代碼就不會有觀察者效應
因爲我們給每個調令都做了IPC
另外要注意的是每一類消息是如何
不管從應用還是某個子系統還是繞過這些路徑
如果通過配置等等來改變
我講的差不多了請Matthieu Lucas上臺
來爲大家實際演示一下如何使用Console應用
謝謝 Steven
就像Steven在一開始說的那樣
今年我們引入了全新的Console應用
我們重新用Swift編寫
我們想創建一個新的日誌系統
讓你們的開發能夠更簡單
讓我們來看看這個應用
這是新的界面
你能看到佈局其實沒怎麼變
中間還是主要流式
頂部是不同的操作邊欄是不同的來源
先來看看邊欄
你還是能看到不同的報告
系統報告或者用戶報告還有不同的遺留日誌
它們可能都有系統路徑
但是這裏你看到有一個新部分
我們現在可以顯示所有連接到你的機器的設備
也會顯示當前的機器
我們可以支持iOStvOS和watchOS設備
所以你可以連接所有你有的設備
現在再來看看主要流式
現在 日誌流由兩個視圖組成
一個是消息視圖一個是活動視圖
就跟Steven之前說的一樣
在活動視圖裏你可以看到活動的分層
以及相關的消息如果有的話
細節會顯示在底部這裏
現在轉過來看看消息
這裏你看到有一大堆消息
那麼爲了能包含Debug和Info消息
你需要在Action菜單裏手動操作
這樣他們就能和默認的流一起顯示
現在我們來多看一些...
我開幾個應用來創建一些日誌
這裏現在能看到出現了更多的信息
能看到不同的消息類型
通過這些彩色的點在類型這一欄
灰色的是Info消息
黃色的是錯誤紅色的是故障
深灰色的是Debug
如果沒有點就是默認類型
你也可以展開或者摺疊你的消息
直接在行內使用左右箭頭
或者使用這裏的視圖菜單選項
展開或摺疊
只要你點一個消息
你就能看到有關這個消息的所有細節
就在下面這個細節視圖裏
所以說我們可以展示給你所有信息
只要是有關這個日誌的這就是新的日誌系統的一部分
那麼現在我們來展示一下進程還有它來自哪個庫
你們看到這一個
它就accountsd下的Accounts.framework
你還能看到更多的信息在我們收集所有新日誌的時候
你現在看到我們有子系統 分類
活動ID線程ID或PID
現在再看看這個iPad
我連接的iPad只有一個最基本應用上面有些數字
我們要找到它們通過瀏覽不同的功能
首先我們最小化欄的佈局
我可以右擊上方這裏
然後添加一些新的欄
我就添加子系統和分類
然後把它挪到這裏
現在這個佈局是永久的你不用再設第二遍
現在我們可以看到這個設備上有很多信息
爲了精確你的搜索
我們有兩個方法
你可以首先右擊一個消息
然後你能選擇不要子系統
不要進程或者只顯示一個特定的進程
這樣我們開始就可以減掉特定的分類
假設我們要widgets不出聲
第二個方法就是
在這裏直接打字輸入
所以你看到 我們只添加了一個自定義的token給widget
假設我只想看Bookmarks應用
就是這個應用在我的設備上出錯了
這樣一來 這裏就只有來自Bookmarks的消息了
而沒有分類widget
那麼再來添加一個token只顯示錯誤類型
現在看到的消息就只來自於Bookmarks
沒有分類widget並帶有一個錯誤類型
我們可以看到網頁視圖的不同的錯誤
這就是我們如何直接關聯到要查找的內容
爲了之後能修正錯誤你只要保存它
通過點擊右上方的保存鍵
名字就叫Bookmark Errors
你可以看到所有你保存的搜索都會顯示在這個部分裏
你可以重新排列它們願意的話也可以刪除
你會有兩個默認保存的搜索
就是全部信息和故障及錯誤
現在來轉到活動視圖
看看能否找到更多有關這些日誌的情況
能否簡單的重製這些錯誤
這裏我們看到不同的活動
這些活動的視圖基於同樣的搜索機制
所以我們可以使用同樣的功能並且保存
這裏我們看到
不同孩子的Bookmarks活動
我們可以看到當時是在準備轉換
然後我們檢索一個對象打開細節視圖
然後設定細節視圖下載網頁視圖
現在你就可以看到信息直接顯示在底部的視圖
這些都是有關這個活動的信息
這個消息是記錄在這個活動裏的所以纔會顯示在這裏
我們現在看到這些消息
這兩個錯誤是加載網頁視圖活動的一部分
那麼我們就知道了是什麼情況
導致了這個錯誤
那麼現在我們添加一個分享選項給Console
你只要選擇一些活動或消息
直接分享給某個人或者給備註
我這裏就只添加爲備註以便以後的調試
下一個問題
另外一個可用的輸入是日誌檔案
在桌面上有一個日誌檔案
是另外一個設備之前生成的
如果你也有一個雙擊它
Console會打開它
你可以看到無論何時你點開它
它就會下載所有的東西
你還可以看到
這裏保存的篩選跟我們之前說的一樣
那麼爲了能看到這個特定的日誌文檔
是否包含了同樣的錯誤消息作爲流的當前設備
我們只要點擊它它就會自動重新應用同樣的篩選
這裏就看到錯誤是一樣的
同樣我們也可以在活動視圖查看同樣的活動
這就是Console的全部內容我要請Steven回到舞臺
謝謝
十分感謝 Matthieu
我十分喜歡新的Console很好用
那麼我們來講講新的統一日誌系統
以及如何實際使用
首先我們來總結一下所有新的API
Os_log是基本的日誌API用默認模式記錄
Os_log_info是一個調令默認發送日誌消息給內存
也用於你想收集的額外即時信息
Os_log_debug用於十分頻繁的調試
另外還有os_log_error和os_log_fault
用來生成故障和錯誤信息
最後一個調令是os_log_create
它能創建一個日誌對象讓你自定義你的行爲
就這一點我們再深入講一下
因爲它對你們來說應該是最不熟悉的
相較於其他內容而言
調出os_log_create由兩個參數組成
子系統的名字和分類的名字
它要做的是創建一個線程安全的單例對象
來控制你傳遞的日誌調令行爲
在默認情況下這是個系統範圍內的行爲
但是你可以自定義爲某種特定的行爲
通過使用配置或者日誌命令行工具
使用方法就是簡單地將它作爲第一個參數傳遞
給所有其他調令
這裏我調出os_log第一個參數爲log
它是從os_log_create返回的值
它所做的就是製造一個引用給分類
和用這個日誌對象定義的子系統
跟每個用到的日誌消息存在一起
以便以後可用在後端上篩選和顯示消息
如果你無所謂有沒有自己的子系統和分類
那麼另一個辦法就是傳遞一個os_log_default
只是我們一直提供的默認日誌對象
它沒有子系統或分類
但是它很有用如果你不需要那種控制的話
內置類別格式化
我們都花費了大量的代碼去把二進制信息轉換成字符串
以便我們記錄
統一日誌系統可以幫你完成大部分這樣的工作
通過爲常見的類別提供內置格式化
更重要的是
我們省去了轉換工作直到我們要顯示日誌消息的時候
所以你不需要爲轉換而苦惱
在生成日誌消息的時候
避免所有不同類型的觀察者效應
這點我們多講一些
對於一些常用的值這裏有內置的解碼
語法不是％d
而是％（time t ）d
這就是說這個十進制的值
你傳遞的實際上是一個time_t
那麼在打印的時候印出的就是一個time字符串
同樣的對於錯誤你要寫 ％（errno ）d
這樣這個錯誤就會被轉換成肉眼可以辨識的格式
我們還有一個新的基本時間格式％P 不是小寫p
這已經不是新聞了
你可以用它來顯示任意二進制數據
所有常用類型都有解碼器比如％（uuid t ）
這裏列出了我們現在使用的所有代碼
包括所有不同類型的時間值
errno和uuids還有所有不同類型的網絡ID
而且我們很期待未來還有更多的代碼出現
那現在講講以參數爲單位的隱私
隱私現在基於參數處理並以一個參數爲單位
標量和靜態字符串被認爲是公開的
另一方面動態字符串 集合和對象被認爲
含有隱私信息除非你特別說明
那麼這個行爲就可以重寫以一個參數爲基準
以前會寫％@來表示
“我想把這個對象包含進我的日誌”
而現在你要寫％（public ）@來告訴我們這個對象
以及這個對象裏的所有內容都是公開的不用擔心
另外如果你有一個事件裏面的一些數值
出於某些原因是隱私的你就可以寫％（private ）d
讓這個數據記錄爲隱私信息
這樣你就可以把隱私和格式結合起來
那麼我可以寫％（public, uuid t ）.16P
來表示這裏有一個uuid
它是公開信息並且已格式化
那麼我們再講講實例
看看寫代碼的時候會產生什麼不同
日誌消息簡化
這是我們以前用的方法
好的首先你要檢查並聲明
當前的日誌層級是否在發出任何調令前可用
然後你要聲明你要顯示一個uuid
你要做的第一件事就是調出unparse 轉換成字符串
碰巧你還有一個套接字地址
這個之後也要轉換成字符串
然後調出NSLog包括所有已經轉換的元素
當然你還要傳遞這個函數的名字
以及file和line的數字
完成後不要忘了
釋放爲套接字地址所創建的字符串
這就好了
下面來看看新方法
簡單地調出os_log_info它可以幫你檢查日誌級別
這種情況下我傳遞默認的日誌對象
我在格式字符串裏定義所給的參數是一個uuid和一個套接字地址
就不用再做轉換
現在我什麼也不做直到我們要顯示它的時候
然後我只要傳遞參數就這麼簡單
在我做示例的時候讓我多說一下
使用其他API的例子
這裏我做了一個log_create定義了一個子系統和分類
子系統是com.apple.logging.example
分類就是普通分類那麼這就是我一般的日誌對象
我要做一樣的事情 但這次我創建了一個分類timestamp
然後寫個簡單的調令
調出os _log 使用general_log對象傳遞字符串 日誌完成
這裏有個更有趣的案例
我調出os_log_info
這之後會進入內存緩衝區
並只保存在有故障和錯誤的時候
在我的格式行裏我定義％（public ）s給filename
因爲filename是個動態字符串
所以我們假設它是隱私信息
除非你特別聲明它是公開的
下面這是個比較複雜的例子
我打開一個文件檢查到一個錯誤
如果它返回一個錯誤我就調出os_log_error
在我的格式行裏就會聲明這個filename是公開信息
我聲明給格式定義errno爲errno
這是另一個相似的例子這一次我調出fstat
但糟糕的是我調出的fstat是在打開文件之後
所以如果我收到報錯就可能有奇怪的問題出現
因此我調出os_log_fault同樣類型的參數
最後一步就是調出os_log_info
但是這一次我傳遞timestamp日誌對象
然後基本上我會丟掉這個文件的所有timestamp
這就意味着當我打開瀏覽Console的時候
我可以簡單地篩選並說
我只要看timestamp數據或者我不想看timestamp數據
因爲我要看其他數據
新的統一日誌系統不是此次發佈的唯一改變
我們還改進了活動跟蹤系統
活動 是最優先被保存和再利用的對象
創建操作讓你能控制
不同活動對象之間的關係就在你創建它們的時候
還有一些新的API是觀察你的代碼活動
改進的活動API
這裏就是所有的新API
這個新的os_activity_create跟os_log_create一樣
都是創建一個日誌對象只是在識別一個活動的時候
你可以使用兩個調令在你的代碼上
os_activity_scope和os_activity_apply
我一會兒讓你們看幾個例子看看他們的運行有何不同
最後就是os_activity_label_useraction它將活動標記爲
基於UI的用戶活動
那我們用個例子來說明
首先調出os_activity_create創建init活動
注意這個函數的第二個參數
是常量os_activity_current
這就是說這個init活動是附屬於
當前活動的不論這個活動是什麼
現在我開始做os_activity_create爲驗證活動
但是第二個參數是我剛建的init活動
這樣我就給這些活動手動創建了一個層級結構
現在我有了一個代碼塊
準備好了我大括號裏還有一些代碼
第一件事就是調出os_activity_scope
然後傳遞這個驗證活動
意思就是這個代碼塊裏的其他代碼
被認爲是這個活動範圍之內的直到我點擊結束括號
不用再記得要在結束時調出os_activity_end
它會自動完成
當你離開這個scope的時候你就不再是這個活動的一部分了
我們提供的另一調令是os_activity_apply
先傳遞活動對象再傳遞這個代碼塊
然後它就會運行這個代碼塊並以這個活動爲執行範圍
工具
Matthieu已經爲你們展示了新的Console
那麼我就快速過一下它的功能
你可以瀏覽系統中的活動內容
可以打開日誌檔案
可以使用新的日誌檢測的活動中心視圖
你可以使用高級的篩選和搜索
還可以看到設備的日誌
現在我仔細講講新的命令行工具
它提供了跟Console完全一樣的功能
但是是用命令行
要想獲取在線流式日誌消息只要寫log stream
如果要漂亮一點
你可以寫log stream--predicate eventMessage contains my message
它能做的就是獲取所有流式日誌消息
包括了my message字符串
就跟Console一樣讓你打開日誌檔案
一個日誌檔案可以通過日誌命令顯示
你可以寫log_show然後給它文件名
然後它就可以顯示這個日誌文件的內容
你可以在macOS做的另一件事使用日誌命令去更改
你的子系統和分類的配置
這裏是個案例
我寫了log_config --mode level:debug
然後寫-system com.mycorp.myapp
這麼做是爲了能夠記錄
這個子系統的日誌在你的macOS上
即將推出
我們很感謝你們將使用iOS 10來開發你的應用
但是請繼續使用Mac上的macOS 10.11即El Capitan
讓你能夠通過El Capitan訪問新日誌的工具馬上就會推出
但與此同時
我們煞費苦心的提供了一個變通方案
能讓你的新工具在模擬器內部運行
xcrun simctl spawn booted
然後寫log show system logs.logarchive
然後你就可以執行所有命令跟往常一樣
另一種方法也再研究中
那麼我現在開始講最佳操作記錄規則
一定要保證你的消息裏只包含真正有用的信息
不要有額外的空白字或者填充數據
要保持緊湊
讓我們利用內置格式化組件去做格式轉換
你提前做的字符串轉換越多
你的應用就顯示得越慢
相比之下輸出的時候再轉換就好很多
避免將日誌API包含於其他函數
如果你把它包在其他函數裏
你就無法收集文件和行數
如果你必須要包裝我們的API
那麼把它們包在宏命令裏不要包在函數裏
只從字典和檔案裏記錄所需要的內容
這裏說的字典是指字典和數組
它們佔用了磁盤上很多的空間
也就是說他們會擠掉其他人們需要的日誌消息
儘可能的只記錄你日誌所真正需要的部分
還要避免記錄到緊湊代碼循環裏
簡單說一下我們心目中這些新API的最佳用途
Os_log是記錄日誌信息的基本細節
這個信息類型可能正是你需要的
能在幾個小時前幫你調試問題
使用os_log_info去獲取額外的即時信息
這個首先要用於很快就會過期的信息
使用os_log_debug來處理開發過程中大量的調試工作
錯誤出現在你需要收集額外信息
併爲你的應用保留的情況下
故障是指你想要收集額外的
有關係統的信息
簡單來講講日誌收集
我們推薦Sysdiagnose來捕捉有關故障報告的數據
使用sysdiagnose
如果你使用sysdiagnose我剛剛描述的系統裏的日誌數據
就會出現在檔案裏文件名是system logs.archive
可使用key-chords來激活sysdiagnose
如果在Apple watch上
它不僅會在手錶上激活也會在與之匹配的手機上激活
然後你可以用iTunes轉移這個檔案
給你的Mac來進行操作
這個文件就是Apple想要爲你提供的
解決你給我們提出的問題
所以你可以把它附在雷達上
也可以發送給開發者技術支持
這就是各種key-chords
Shift + Control + Option+ Command + Period （. ） 對Mac OS
Volume up + Volume Down+ Power 對iOS
手機上會產生輕微震動iPad不會
在watchOS上長按電子錶冠和邊鍵一整秒
如果按的時間不夠長你就只獲得一個截屏
啓動的時候會有輕微的觸摸震動
Play/Pause + Volume Down在tvOS上
注意以前的Apple TV遙控器
得按五秒鐘才能激活
棄用
這一部分我們要對一些API說再見了
首先就是所有的ASL日誌API現在已經被這些新的API所替代了
所以這些舊的API就被棄用了
但這裏還有一個有趣的極端情況
搜索日誌數據的新API在這一版本不會被公佈
意思就是現在沒有能替代asl搜索功能的工具
如果你的系統完全依賴asl搜索
那就得等着使用新的日誌系統了
還有一些活動API也會被棄用
現在不用再寫os_activity_start和os_activity_end
而是像我展示的那樣寫os_activity_create就可以
然後調出scope或者apply來應用到代碼塊
Os_activity_breadcrumb已經被os_activity_user_label代替
Os_trace_with_payload也換成了任意os_log調令
注意這些函數在這一版本里以沒有ops
所以如果你繼續調用它們它們也不會進行任何操作
總的來說
新的日誌系統更快也更簡單也給你更多的控制力
但它的確要使用新的API和新工具
相關演講
我提到了幾次在2014年發佈的“活動追蹤”
這個演講講的就是這個內容
所以如果你想回顧一下
或者想了解更多有關這個演講的信息請登陸這個URL
謝謝大家