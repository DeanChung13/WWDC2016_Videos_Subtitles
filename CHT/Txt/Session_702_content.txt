在StoreKit中利用Swift 3進行In-App Purchase
大家好
我是Dana DuBois
在基礎框架團隊擔任技術經理
在iOS和tvOS上框架可以幫助App Store更好發揮作用
今天我們要談論的是衆多框架中的一個
它是StoreKit
你們當中許多人知道StoreKit已經存在了很長時間
它是在iPhone的iOS 3系統中被引入的
從那時起到現在它已經被成千上萬的應用使用
來實現各式各樣的商業模型
報紙 雜誌 遊戲
甚至約會應用都使用StoreKit
它實實在在的被廣泛使用着
關於StoreKit我們在WWDC 上已經談論了很多
今年我們將要做一些新的東西
我們談論它在Swift上的使用
聽上去令人興奮我們有些新應用接口可使用
多了一些新的東西那就是Swift API
那真是太棒了
在上週 你們中的許多人或許已經聽說了
圍繞着程序訂閱我們發佈了一些重要的通知
這同樣也令我們興奮
我想很多開發者最終會去
使用程序訂閱的增強特性
我將給你們大體介紹下它的新特性
首先 分類
我們十分興奮的宣佈
分類將不再影響你選擇
去使用自動更新訂閱在你的應用中
但標準仍將存在
指導你如何使用自動更新訂閱
但分類將不會再是一個重要的影響因素
其次 每個人都會感到興奮
就是我們會把更多的收益給開發者
假如你保持你的訂閱用戶使用一年以上 那是極好的
我想那將是一大單生意
定價
我們將更多的控制權給開發者
開發者通過iTunesConnect來設置定價
基於領土之間 國家之間爲他們的程序訂閱
如果由於商業原因你需要調整在歐洲的定價
相比於美國來說相對於過去現在你有了更多的權限
隨着定價的改變 我們將給你能力
來保存價格 爲部分用戶保留價格
那些已經使用了你程序訂閱的用戶
僅爲新的用戶調整價格
假如你想獎勵早期的使用者
你想讓他們繼續使用你的程序訂閱
但是你想爲新的用戶調整定價
現在你有這樣的權利了
隨之而來的是程序的升級和降級
這也是我們給與用戶更多的權利...
準確的說用戶可以在你的服務中選擇想要的級別
假如用戶想升級到白金級
或者是回到普通級別
他們可以通過管理訂閱界面來進行升級或者降級
在他們的設備上
以上就是程序訂閱新特性的大體介紹
更多關於程序訂閱的內容
如果你想將程序訂閱集成到你的應用中
你真的應當去 擴展訂閱的介紹
在iTunes Connect
今天下午四點在Pacific Heights
他們將深入介紹如何將程序訂閱集成到你的應用中
如何在你的應用中去管理你的程序訂閱
我極力推薦你們去參加那個活動
這就是程序訂閱
我要興奮地通知大家除此外 還有新東西
那就是iMessage應用
我們在昨天的主題會中已經展示了
我們將帶給大家一個全新類別的應用
在iMessage應用和iMessage中
你將可以構建自定義的擴展
我們將在這些擴展中允許In-App Purchase
在iMessage應用可以使用同StoreKit幾乎一樣的API
你今天或許使用着你在應用商店下載的普通應用
假如你有額外的內容發佈到市場
或者在iMessage中讓用戶體驗
現在我們支持它們了
這些特性將在iOS 10可以使用
我們爲這些特性感到興奮
我想開發者們將會很好利用這些新特性
就像我之前說過的StoreKit已經存在一段時間
人們已長時間使用In-App Purchase
但對在座的一些人它是新的東西
我將簡單的介紹何謂In-App Purchase
In-App Purchase是數字內容或者服務
可以在你的應用中進行購買
然而 要清楚 它不是實體的商品
還有其他方法進行購買
這僅僅只是關於數字內容和服務
當我們談論數字內容和服務時
還有一大堆其他不同的類型
當使用iTunes Connect對它進行配置的時候
有許多的選項需要你去確認
你需要選擇適合你內容的類型
讓我們來看下我們談論的東西是什麼
可以消費的商品
人們在玩某個遊戲時都有一定數量的金幣
流通的貨幣 或者在疾馳汽車裏的汽油
或者是用戶想要購買的一些東西
買一次 又買一次 用光剩餘的時間
這就是可以被購買的商品
不可以被消耗的產品是一成不變的
它始終一成不變 只要用戶想使用它
用戶們能恢復它
它可以在設備之間傳輸
這是可消費和不可消費產品間的細小區別
同樣在一個遊戲中你有一把劍
或者你有一些類型的武器再或者你駕駛一輛疾馳的汽車
或者等級又或者你有一個實用的應用
你的應用或許有一個基礎版本
你或許想推出一個高級版本的應用
那就是一類不可消費的產品
當我們談論程序訂閱時我們也有兩種類型的訂閱
有一種不能自動更新的訂閱
像它的名字那樣
它不會自動更新它的更新取決於你和你的應用
你的後端來管理如何去更新訂閱
我們也有自動更新訂閱
這些程序訂閱的使用者會週期性的付款給Apple
這些都基於你在後臺的配置
假如它是每月的程序訂閱
每個月我們會給用戶出賬單
只要他們一直選擇使用程序訂閱
以上就是訂閱的類型
讓我們將In-App Purchase加入到你的應用的核心部分
我們將要快速瀏覽
這些種類中的所有步驟再深入瞭解其中的每一步
接下來我們將談論的是如何在Swift中使用它
你清楚的知道你需要去擔心什麼
或者你曾經碰到的問題
太多的事情有時會讓我們感到厭煩
當你在開發中解決StoreKit的問題時
一些事情需牢記
首先...
你需要準確瞭解你出售給用戶的是什麼
對於消費者就是使用你應用的用戶
需要做的僅僅是辨識出這個標識
這些你將發佈到應用內的標識
將立即展示給用戶
一旦你擁有了這些標識你可以前往App Store
獲取到這些信息
本地化和標識相關的產品信息
確定本地化的信息很重要
App Store是全球化的應用市場 你需要確保
你展示給用戶的是本地化處理後的信息
一旦你有了這些信息你就可以展示你的產品
你可以去App Store發佈他們出售你的產品
你的應用你做主
你可以構建優質的UI展示它們
用戶會被它們吸引 然後去購買
它們將會被出售 用戶會去挑選產品
立即看到產品
但是你需要爲你的產品創建支付
並且把它加入到了支付隊列
接下來我們談論的內容會有許多關於支付隊列
當支付的訂單通過支付隊列時
關於交易的通知會被推送到你的應用
推送到達時你必須做出必要的響應
就是你將如何處理這些交易
最後 當支付完成後
你需要確保應用是可以正常使用
告知用戶它們支付了什麼
最後通知支付隊列你已經處理了這筆交易
處理完所有的事情 產品是可用的
這樣這筆交易就完成了
這就是你需要採取的不同步驟如此迅速
我們將深入瞭解我們提到的每一步
需要特別注意的是支付隊列
支付隊列是應用內購買的核心
In-App Purchase購買中
對於支付和購買的狀態來說支付隊列是它們的來源
由於它們貫穿支付過程的始終
從用戶選擇商品到完成支付
需要注意
你應當依靠隊列並且只能依靠隊列
並且需要了解交易的過程 支付的狀態
假如你使用主機去下載
支付隊列將會告訴你所有的這些下載
另一個需要注意的是
如果支付隊列告訴你有一筆支付
它就是有效和真實的支付
在實際過程中 我們看到過一些案例
開發者有可能自己做了緩存
開發者會知道用戶點擊了產品
開發者管理着支付的各種狀態
然而這些應用有可能會崩潰或者會發生其它事情
用戶將會在完成支付前關閉應用
用戶們將會回到遊戲或者其他地方
他們進行支付的頁面
開發者沒有必要關注這些響應
來自於支付隊列
因爲它們沒有監聽這些交易的支付
他們自己的隊列沒有支付隊列的狀態
因此你真的需要依賴支付隊列
來告知你在這些支付的過程中發生了什麼
在實際應用中支付隊列十分重要
在這裏我們需要加入一些代碼
當你啓動應用時用來監聽和觀察支付隊列
我們可以在這兒的例子中添加代碼
我們的didFinishLaunchingWithOptions函數
在我們啓動應用的時候會最先被執行
我們用它創建監聽支付交易的觀察者
在這個例子中它是應用代理本身
我們把它設置到了支付隊列上並且把它加入到支付隊列
如果支付隊列有事情發生
在我們啓動應用前已經發生
我們將立即收到交易的通知
另一種被提及的是
在In-App Purchase時使用兌換碼
用戶進入到App Store
並且在你應用的外部使用兌換碼完成了In-App Purchase
用戶樂於使用In-AppPurchase進行消費
然後進入到你的應用中
如果你沒有監聽支付隊列
產品將不可用
在應用啓動的時候你需要監聽支付隊列
以上是關於支付隊列的簡記
讓我們回到實現流程上來
準確理解如何添加支付隊列到你的應用中
首先要做的是加載標識符
爲In-App Purchase
進行iTunes Connect時會有相同的標識符
你需要定義這些標識符對他們進行命名
開發應用時要獲取標識符的列表
有不同的方法來獲取它們
如果你的應用十分簡單
你或許僅僅需要將這些標識符複製到你的應用中
如果你的應用有基礎版本和高級版本
你有可能僅僅有一個可消費的版本
你僅僅需要複製標識符到你的應用中
然而 我們看到許多應用並沒那樣做
它們傾向於在外部
並且從他們提供的主機上獲取應用內標識符
以便應用過期後它們可以改變應用的可用性
或者準確地說可以改變呈現給用戶的內容
它們這樣做是沒問題的完全是符合規定的
我們想要說明的是如果你這樣做
請確保你的主機具有穩定性和較高的可伸縮性
是In-App Purchase流程的開始
最壞的事情是展示給用戶的價格需要進行微調
當用戶正在等待購買的時候
這應該是可能發生的假如你能提前抓取信息 那是極好的
如果你能在設備上緩存這些信息那就更好了
你要清楚的知道如何進行抓取和保存這些標識信息
即然你已經有了這些標識信息
你需要去App Store來抓取產品本地化的信息
同產品密切相關的信息
你可使用SK產品請求來完成這些操作
這樣你就可以拿到你感興趣的標識符
爲了獲得更流暢的用戶體驗
你需要提前抓取這些標識符
你想要知道當用戶有可能感興趣
在看到你的In-App Purchase時
你能在第一時間獲得這些信息
你首先要做的是創建你的SK產品請求
你傳遞你感興趣的標識符
你需要設置你的代理
它將給你的應用返回信息
當這些產品被加載的時候
你僅僅是需要調用開始那是如此的簡單
代理看起來像上面那個樣子
我們有產品請求didReceive函數會響應
它將傳遞給你從App Store上下載的所有產品
每一個產品將會保留這些信息
像本地化的標題和描述
像我之前所說的App Store是面向全球的應用市場
你是向全世界發佈In-App Purchase
最好確保
你正在使用本地化的信息
來進行你的交易
比如本地化的標題和描述
甚至更重要的是價格和的價格本地化
你想提供給用戶In-App Purchase價格
你需要確保呈現給用戶的格式是他們能理解的
在全世界流通的貨幣呈現的方式是不同的
你要知道正確展示價格的重要
我們將會講到這些
最後你拿到你的In-App Purchase內容
啓動iTunes Connect時這些事會發生
我們會給出下載時長的信息
和購買相關的版本信息
就像我提到的定價該信息也很重要
當你呈現這些價格的字符時要做出正確的選擇
當你呈現這些價格的時候你想要使用換算到本地的價格
將它轉換到NS的數字格式
你將獲得關於定價的相關信息
那個NS的數字格式將會帶有價格的信息
對它進行本地化操作
假如你對它設置了貨幣格式你可以確信
你獲取的價格信息是正確的
你要做的另外一件事情是
不要在進行貨幣轉換的時候進行無關的排序
App Store知道如何進行本地化對貨幣進行轉換
所以不要做任何其他無關的操作
只要把定價原本的樣子用NS數字格式呈現出來
下一步就是呈現你的UI
接着將不會過多談論產品的本地化了
你的產品你做主
你知道如何呈現你的UI使你的應用盡可能獲得更高的銷量
然而 一旦購買完畢
或者一旦UI被顯示 我們將立即跳轉
自動完成購買
添加並且創建SK支付對象完成上面的操作
並且把它加入到支付隊列當中
一旦你創建了SK支付對象並且添加到支付隊列當中
隨着支付的進行你將會獲得一個回調
通過它更新交易
這就是你剛剛添加的支付隊列的觀察者回調
當應用開始調用的時候
你創建了支付隊列的觀察者
觀察者會調用支付隊列的函數來更新交易
在支付進行的過程中你將獲得關於支付的消息
你需要做的就是創建你的SK支付對象
將創建的對象添加到支付隊列當中
消息開始陸續到來
你將會獲得關於整個交易過程的信息
你可能有一條消息也許有許多條消息
你需要遍歷這些交易
並且監聽每筆交易的狀態變化
有許多不同的狀態
它們之中你最感興趣的是購買的狀態
從那兒你可以知道購買完成了
繼續去激活購買
我們將獲得一小部分數據使得應用的內容是可用的
然而 我想說還有另外一種狀態
那就是延遲交易的狀態
延遲是在iOS 8中爲了購買前詢問特性添加進來的
這是爲了讓家人共享iCloud
家裏的孩子可以去進行購買例如In-App Purchase
孩子們的父母 監護人 擔保人
可以決定兒童可不可進行購買
延遲的狀態是你在登錄狀態進行In-App Purchase時
延遲狀態需要獲得來自父母的許可
我們看到許多這種情況並且想要將它解釋清楚
如果是在延遲狀態你不能阻塞你的UI
你應當以某種方式對它進行處理...
也許購買最後沒有發生
允許孩子們嘗試用你的應用進行購買
讓孩子們返回並且繼續可以使用遊戲
或者是他們感興趣的任何內容
因爲延遲購買會持續一小時或幾天
在他們父母審閱和同意這次購買前
不要微調 不要彈窗
僅僅是像購買從來沒有發生過一樣
就像你知道還沒開始一樣
一件我也想做的非常重要事情是
當你進行In-App Purchase時測試你的應用
就像測試你應用的其他功能一樣
通過iTunes store可以實現上面的操作
沙盒環境
沙盒環境是一個特殊的環境
假如你運行的是有開發者簽名的應用
你進行的所有購買都會進入沙盒環境
然而 假如你對延遲交易的測試感興趣
沒有比創建一個家庭賬戶更好的方法
這樣你就能在沙盒環境下測試延遲交易了
假如你想在沙盒環境中測試你的延遲交易
你可以使用SimulatesAskToBuyInSandbox
你可以在你的SKMutable支付對象中創建它
你傳遞給你的產品
然後你設置SimulatesAskToBuySandBox標記
這個標記會告訴App Store 嘿
對待這次購買就像家裏有小朋友在進行購買
一旦你將它加入到支付隊列就會被髮送到App Store
然後App Store將會在你的應用中返回給你延遲的狀態
這種方法可以讓你知道你的應用可以在兒童購買時正常工作
我們同樣需要談論一下關於錯誤的處理
不是每件事情都正常執行
在你的應用中也會出現錯誤的狀態
尤其是在In-App Purchase時
你需要牢記的是不同的錯誤需要不同對待
我強烈建議你翻閱In-AppPurchase編程指南
或者StoreKit框架參考指南
來更好的理解使用中出現的錯誤
隨着程序的運行會有相應的返回
需要記住的是
大多數錯誤是不需要你去通知用戶的
許多錯誤是我們通知開發者的
讓開發者在應用中進行處理
我有過類似的經歷
我在使用開發者開發的應用我隨意瀏覽着
我在進行網上購物
我點擊了購買
確認了價格緊接着StoreKit的窗口就出現了
然後我又改變主意了我想返回看看其他東西
我選擇了取消
可是取消發生錯誤
取消錯誤確實在你的應用中發生了
沒有必要將取消錯誤的警告展示給用戶
我們有時會在應用中看到這些錯誤
用戶知道他們進行了取消操作
沒有必要重複展示給他們
儘可能讓StoreKit處理交易流程
再次強調我們將要談論支付隊列
支付將會在支付隊列中進行處理
App Store和StoreKit會要求用戶進行購買確認
他們將會給出一個價格
這個價格需要同你應用內價格進行匹配
這就是爲什麼確認本地的價格信息正確
是如此重要
我們會對用戶進行認證
如果賬單信息有任何問題
我們需處理賬單問題
彈出確認框或者做其他的特殊操作都是不必要的
讓StoreKit爲你處理這些問題
我們談論了進入交易隊列前的一小部分
我們談論了支付返回的一些狀態
一旦你的支付變成了購買的的狀態
你需要在你的應用中做出多種選擇
特別的 你需要驗證購買的時候
可以使用現金進行交易
我們有好幾種方法來完成這些購買操作
但是再次強調 你的應用你的產品 你做主
你要特別注意你使用什麼技術
你用何種安全級別驗證購買的合法性
回執的驗證 回執會返回給應用
在購買的最後環節
回執就像消費者拿到的賬單
當你在商場進行購物或者類似的事情
回執包含購買的所有信息
還有購買的In-App Purchase
有兩種主要的方法
你可以進行回執的校驗
首先是在設備自身上驗證
接下來是回執
你可以編寫代碼將它在設備上分爲幾部分
授權來自Apple的回執
確認回執的現金來源是有效的
做這些是爲了解鎖應用中的一些特性
和內容
這是你必須選擇的
這些購買完全只能在客戶端進行嗎？
或者說如果你有服務端
你想在服務端做回執的驗證
因爲你想讓服務器爲你的內容和服務提供網關服務
爲了完成上面的事情你需要將發送到設備的回執
上傳到你的服務器
然後讓服務器發送回執到App Store
有後臺的API可以對回執進行驗證
這可以做到從服務器到服務器
需要注意的一點是App Store有後臺API
可以接受和驗證回執
但是你不能通過你的設備直接發送回執
那樣做是不安全的
如何保證來自你應用的回執是可信的
如果你想驗證回執的有效性
回執應當通過你的服務器
傳遞到App Store的後臺
讓我們來深入瞭解下回執是什麼
回執是你在進行In-AppPurchase時得到的可信記錄
它包含的信息允許你知道
在這個設備上用戶已經購買了應用
對開發者而言是用戶在他們的設備上進行了購買
回執存儲在設備上
你應用本身的容器中
回執由App Store簽發並且包含一些信息
允許你驗證來自App Store的回執信息
這只是針對你的應用和設備來說
如果你的應用在不同的設備上運行
對於不同的用戶得到的回執也是不同的
這樣做是爲讓你知道回執大體的樣子
存儲在App Bundle中
我們提供應用程序接口允許你能獲得這些信息
過一會兒我們將看到它大體的樣子
它是單個文件
很早很早以前回執的版本
以前每一個In-AppPurchase通常會有多個文件
但是自從iOS 7開始我們有了統一的回執
在一個文件中包含了所有的信息
它裏邊也包含了證書和簽名信息
允許你通過這些信息驗證回執
我們通過使用公鑰密碼標準
7容器來完成上面的操作
容器裏邊包含了所有信息
容器使用的是開放的標準
你有許多可以參考的信息
關於如何使用PKCS7標準容器
容器進行加載
裏麪包含有用的信息
是需要你去解析的
裏面的編碼是ASN1格式的也是公開的標準
有很多不錯的標準可以選擇用來做回執的驗證
OpenSSL就是其中的一個
有時開發者會創建他們自己的標準
在這兒我要強調的是
這是你的應用 這是你的錢
這是你的生意
如何更好的驗證回執依賴你做出的選擇
你要使用什麼技術
然而 不論你選擇什麼都會有相似的處理過程
你在支付過程中會經歷的
首先 你需要在你的應用中定位回執
使用NS bundle API
上面就是它在Swift中的樣子
你可通過NS Bundle進行調用
App Store回執的URL會通過上面的函數回傳
它是本地的URL 在本地的文件系統
一旦你有了URL你需要把它放入NS數據中
你可以獲得二進制形式的回執
需要注意你現在已經加載了二進制文件
證書會有過期時間
你必須十分小心
在覈對過期日期的時候
只是因爲它是發行在一定時間內
並不意味着那個有效期是有效的
在未來所有時間裏
所以如果你正檢查有效期
比較App Store發行receipt時間
而不是當前日期
它不像SSL握手 你每次都想檢查它
只有被髮行時 它纔是唯一有效的
或者只有被髮行時這纔是唯一有效的檢查日期
或者它是完全有效的根本不用檢查日期
但是你要做的是檢查
receipt上的根證書頒佈機構
這將驗證它來自Apple
你可以相信它 因爲它是Apple的receipt
所以檢查到根
所以再次，這只是一種給你一個想法
關於receipt內部的情況
它的有效負荷 我所說的ASN1格式
是一系列的屬性
你可以把它當做一本NS字典
它包含類型和值
還有我們將要標記一些這些類型和值
那裏還有比我們今天討論的更多
你可以在線得到很多
通過我們的receipt驗證編程指南
但是一些你主要想使用的是
類型2和類型3 包括捆綁標識符
和receipt的捆綁版本
希望這和你的應用程序中的匹配並且你應該檢查它
所以你應該檢查捆綁標識符和捆綁版本
然後要記住的一件事是
你應該在你的APP的二進制文件中使用硬編碼值
這是一個更容易讓我進去並改變信息列表P
如果那個是你正在使用去匹配的假receipt
相對於我同改變你程序有效負荷去匹配receipt
所以如果你真的想去確認那個receipt是
爲你的程序的 使用硬編碼值
你現知道這receipt是爲你的應用程序的
你想去確認它是爲
那些正在運行receipt的設備
這是一個小的技巧
你要去做的是看一下SHA-1哈希
它是在類型5中返回的
類型5包括這個哈希
哈希是有信息片段組成
是App Store在購買時獲取的
是你在驗證時獲取的信息片段
特別是捆綁的標識
所以你想在你的應用中保留硬編碼值
你的APP綁定標識
設備標識
這是一個或多個API用於那個
它是在iOS和macOS有些不同
但是你要加載這個設備的標識符
然後這個不透明的值
這個不透明的值是基本上一點加密熵
它是一個包含在回執裏的加密鹽值
它允許哈希隨着時間推移而改變即使如果綁定標識
和設備標識不改變
你應該基本上獲取這個在receipt裏的不透明值
把它包括在你的哈希裏
一旦你擁有了它 SHA-1哈希對比它同屬性5
如果匹配 你知道它是你的設備
對於你的在設備上的APP是唯一的
receipt還包括你的所有in-app purchases信息
所以我們這裏所看到的是全部遠不止類型17
類型17是爲了用戶用你的應用程序所做的每次購買
它包括一條關於in-app purchase的記錄
類型17的有效載荷
不是一個字符串 它實際上是另外一個ASN1文檔
它擁有自己的值
所以這些看起來像什麼
好吧 1701 這是購買的數量
所以我們以前討論過消費品
用戶能有購買10包硬幣在你的遊戲裏
或者100包硬幣
這將是數量 購買的數量
這是針對特定的標識符
這個產品標識符，我們以前討論過
這個是那個標識符你用來
從App Store加載你的in-app purchase數據
如你在iTunes Connect設置的樣子
標識符 這是一個交易標識符
這是一個對於交易的唯一標識符
它被用來購買
購買的日期
然後最後的一個新事物 不是新的
但是一件事我想去強調是我們也包括
自動更新訂閱
訂閱有效期
所以如果你正切換你的應用去訂閱
那是對你非常重要的
你將會使用這種類型 你將會使用它去知道
訂閱是否有效
我們是否需要去讓用戶去或者你需要去仔細檢查
用戶是否在一個有效的訂閱狀態
因此領域非常重要
然後另外一個注意
如果你在Store裏有個應用
它是付費的並且你有興趣
切換它到一個訂閱模式
有一件事你想去確保你檢查是主要的receipt裏面
應用receipt本身是類型19
這包括原始應用程序版本
是應用買來的版本
所以如果我買的它是1.0版本的付費應用
並且在2.0版本你轉至訂閱模式
我想看一下程序的原始版本
因爲我想確認我把那個用戶當成付費用戶
他們是或者不是一個訂閱用戶
我認爲這是一個很差的體驗如果模式轉換爲訂閱
並且你並不尊重他們買原始APP版本
所以如果你切換成訂閱模式記住這些非常重要
另外兩個注意關於receipt
receipt是在購買時發行的
但是它實際上是同樣可以續訂的
但只針對in-apppurchase的特定的類型
所以當我們討論可消費的和不可更新的訂閱的時候
他們將會在receipt裏被刷新
所以可消費和不可續訂的訂閱只會出現一次
他們出現剛好在交易生成之後
他們不會出現在那裏
當用戶刷新receipt同樣在該設備上
或者當他們切換至另外一個設備
但是 不可消費和自動更新的訂閱
會一直出現在用戶的receipt裏
你可以拿回那些東西
應該拿回那些東西通過StoreKit API
我們可以看一下那個看起來像什麼
他在IOS和macOS有些不同
在iOS receipt不存在或者是無效的
你應該使用StoreKit API去刷新它
但是記住你必須擁有網絡
我們需要去連接App Store
我們需要去驗證用戶
我們必須要知道他們真的是那些已經購買過這個東西的人
所以他們將要輸入他們的密碼
或者使用他們的指紋
如果你正在做一些事情如
應用每次啓動刷新receipt
這絕不是一個好的模式去遵循
或者如果你正在做一些事情如在檢查receipt是無效的
然後獲取它，因爲你知道或許有些東西
有些東西看起來不對
你想小心點你不會陷入一遍又一遍的循環中
如果你的應用崩潰而你正檢查你的receipt啓動
或者如果你保持檢查並且它是無效的
關於的驗證碼就是不對的
你不想去驗證和取回那個receipt
一遍又一遍
所以這些都必須要小心
這些能夠在iOS完成通過
這些能夠通過一個SKRecipt刷新請求完成
你設置的代理並且調用了start
這個會在代理中通知你的應用程序
當receipt被更新而且你能繼續
並且處理這些交易在receipt中
就好像他們由用戶購買一樣
在macOS一點不同
如果receipt是無效的
你將會退出伴隨着編碼173
這個會告訴Finder他們替我把receipt取得
再次 這裏需要網絡
用戶可以登錄Store
這個可以完成通過調用exit 173
然後我只想去再次強調server-to-server驗證
若你正在做一個自動更新的receipt並且你有
一個自動更新的訂閱
如果你有在服務器上可用的內容
你可能有一個hosted implementation備份你的in-app purchases
所以如果你正在做server-to-server驗證
這個會允許你去在服務器端驗證receipt
那是用戶獲取用於他們的in-apppurchases是有效的
因此你拿到在那個設備上的receipt
你上傳它去服務器
但是 我要再次強調它
不要直接發送receipt去驗證receipt的端點
這是不安全的還有你不應該那樣做
有件事需要注意是驗證receipt的端點返回的是一個JSON
有效載荷和實際包括信息
像如果你的receipt過期了
你會從App Store那裏得到最新的版本
它會包括一些關於它有效的信息
或者如果receipt的狀態不對
所以再次 有在線文檔
關於到底驗證receipt的端點如何工作的
好吧 我們已經通過了我們已經購買了
我們已經完成了交易處理
這取決於你決定到底你怎麼去驗證
receipt和哪個安全層級
你將要把它放到後面還有什麼技術你將會使用
你驗證了那個購買是真的
那個背後有一個貨幣交易
使用戶可以買到什麼取決於你
再交易結束的時候做得很好
這裏有兩個方法去實現而且我們以前討論過
你可能只有隱藏在你的應用的功能
你將要解鎖的
你的一個基本版本的應用程序
一個免費的基本版本現在已經是一個專業版本
你只需要設置那個狀態並且確保對用戶是可用的
或者如果你有來自服務器上的內容
你需要去下載它
一堆不同的技術
一堆實現的不同方式
現在我要強調它們中的一部分
一個是Apple提供的一個更新的
是按需資源
這個方法能使你的應用程序
在初始下載的時候儘可能的小和壓縮
如二進制文件
如果你要去讓別的資源
關聯應用程序
如果你的遊戲有一堆不同的等級
而它們讓你知道圖片和視頻關聯它們
你可以在你的應用清單裏把他們分解成不同的組件
按需資源是託管在App Store中
所以你不同擔心託管的問題
它是可擴展和穩定的
我們已經用這個爲全世界緩存
你的用戶可以更快的獲取他們的內容
一件事需要記住的是
它可以包含任何類型代碼執行異常
所以所有的代碼都在你原始的二進制文件裏
但是它可以包含其他類型的你想要的內容
它只在IOS和tvOS中可用
macOS現在不支持按需資源
所以那個技術是你可能選擇去使用
它去獲取額外的內容在購買完成之後
如果你有興趣想了解多一些關於它
我強烈建議你看一下“按需資源的優化”這個講座
它在Mission裏 在這個房間週四早上10點
另外一個Apple提供的技術是in-app purchase託管內容
你可以這個內容關聯你的in-app purchase
在iTunes連接和再次連接
它託管在Apple服務器上
所以你不用擔心主機本身
可擴展和可靠地
緩存全世界
一件事需要記住的關於這個和ODR
是這個會在後臺下載你的內容
你的應用不需要運行
所以用戶完成購買並且會離開你的應用
運行其他的應用而你需要去下載這些內容
那些會繼續運行
每個in-app purchasable產品你有最高2G容量
所以不是所有的應用程序共有2G容量
是每個產品2G
這個iOS tvOSmacOS是支持的
所有 再次另外一個擁有Apple託管內容的方法
爲你in-app purchase
讓我們看一下那個可能看起來有點
一個付款通過了
用戶 你驗證它並且你準備去下載內容
你將在更新的交易中回調
你的付款觀察者
那麼我們再往下一點
你將看到你的交易
你將獲知一筆其中的交易
包含一個或多個下載
你所需要做的只是回傳那個下載
去“支付隊列” 它會開始下載
如果你的應用程序有興趣使用託管in-app purchase
你將擁有一個支付隊列更新下載的方法
在你的支付隊列觀察者裏
這個會給你全部的信息
關於下載當他們進來
包括像進度這樣的東西會調用並讓你知道進度
你會用這個去更新UI
或者時間剩餘
或者如果錯誤發生你需要對它做出反應
這些信息會在這裏
然後一旦下載完成一個URL會被提供
那是一個本地URL 就在文件系統上
所以你可以抓取它然後在那裏你可以與你的內容進行交互
這是in-apppurchases託管怎麼工作
但是你可能也想自託管這些內容
完全有效的事情
如果你有一個隨時間變化的目錄
如果你有一些不同的東西你不需要
去放到Apple託管自託管內容完全有效的選擇
一件事需要記住那裏有後臺下載的API
你必須用NSURL會話調用
這個是託管這個內容的方法
內容可以被下載即使你的應用不是激活狀態
若你扔使用NSURLConnection
那是過時的
那不是一個好的體驗
對應用戶來使用NSURL會話
所以這個是非常重要的對於你使用這些API
這個是它在Swift中的樣子
你將要創建一個會話配置
這是一個配置你想命名爲一個唯一的
對於你的應用程序用於描述那個會話是關於什麼的
你將要創建會話
你要傳入配置的值
你要傳入代理 這將是任何對象你想要
獲取這些下載的信息
你會給出隊列
這個操作隊列實際上是在你的代理中被調用的
什麼線程和什麼操作隊列將會在代理裏調用
所以你想要確保你創建了一個專用的
操作隊列
然後開始下載 你創建了一個任務
你遞交請求和與in-apppurchase關聯URL
你調用繼續
這個會在你的後臺開始自託管in-app purchase下載
伴隨着下載開始你的代理會接收到信息
它將在URL會話didWriteData方法裏被調用
這會給你這個能力
你可以帶入這些信息
並且它能讓你去更新UI
你可能有一個進度條
或其他東西你想告訴用戶
關於下載的進度
但是重要的你要記住你的應用程序有可能退出
在下載的過程中
所以當你的應用程序重啓
你想把這些後臺下載會話重新連接
所以在你的應用程序代理裏
你會執行處理事件爲後臺URL會話
這會讓操作系統喚醒你的應用程序
並且告訴它這個後臺下載剛剛完成
或者正在進行 或者出了什麼問題
所以處理事件爲後臺URL會話
這裏會把之前使用的配置的標識符傳入
你會重新創建帶有標識符的配置
重新創建一個重新連接後臺會話的會話
然後你要做的是那裏有個完成句柄
它會被傳入應用代理方法
你需要去調用完成處理程序
一旦你完成了你就完成了所有關於下載的動作
所以如果下載完成你需要去把它放入你的容器
解壓它 讓它工作
你需要去調用完成處理程序一旦你完成了所有工作
讓OS知道你已經完成了所有工作
所以這能使資產可用
但是你還沒有完全完成
即使你已經做了所有可以做的
用戶已經擁有他們買到的
你還是要做另外一件事你需要告訴StoreKit
你已經完成了交易
這個很重要因爲我們保留這個交易
在我們的購買隊列中
我們保留它在我們的state machine
如果你的應用程序死機並且重啓
或者用戶離開並返回
支付隊列會持續告訴你這些
它實際會持續做這些在你行爲後臺API調用的時候
所以這樣會用光用戶的數據空間
所以及時清理是非常重要的
在你完成交易之後
但是你應該確保是你做的
當內容下載完成
如果你完成了交易 然後開始下載
我們會再告訴你關於那個交易一次
所以如果下載失敗或者下載出錯
你不會得到更新信息
所以你要確保下載完成
然後調用完成交易
所以 再次 支付會繼續在隊列裏直到你完成它
如果你正在下載託管內容另外一件你需要記住的
是你需要完成下載
如果你在下載完成之前完成交易
我們會停止下載
這個可以很容易被實現通過調用SK支付隊列
完成交易和傳遞交易到支付隊列
所以 用戶已經使用你的應用他們已經購買了in-app purchase
他們喜歡你的內容 他們決定
你知道我的空間已經用完
我會刪除應用可能我稍後會重新下載它
或者他們切換到另外一個設備
這總是很重要的他們可以要回那些
非消費型和自動更新in-apppurchase到應用裏
他們需要能恢復以前的內容
所以恢復交易允許用戶
恢復非消費和自動更新的訂閱
消費的和非自動更新的訂閱
這取決於你去管理這個狀態
所以可能有一些你剛好保存在本地
可能有一些你存儲在Cloud中
或者你存在自己的託管後臺
這取決於你去管理你究竟想如何恢復內容
但是對於非消費和自動更新
你可以恢復它們使用恢復API
再次 我們提供API用於SK支付隊列恢復
完成交易
那能夠降低一個品牌的應用的更新版本
和in-app purchasereceipt
再次 你會想去觀察隊列
你把它加到你的應用代理 所以當然你正在觀察隊列
你正在獲取信息
關於這些交易當它們進入
因爲我們將調用
支付隊列恢復完成 交易結束
這個會告訴你所有的發生的恢復
你會只想去處理它們
好像它們剛被用戶購買
或者我們會告訴你錯誤發生了
可能你需要讓用戶再嘗試一次
或者對應的更新你的UI
所以 觀察隊列非常重要
再次 一旦恢復完成你可以看看receipt
並且解鎖對應的內容和功能
現在我們會感覺好點的是
你創造了自己的應用
你準備去提交它到App Store你想確保
你能通過審查
有些事情需要記住
我們剛剛討論的恢復
你真的需要一個恢復機制
它不必要是個UI按鈕
你需要一些應用內在機制去允許用戶
要回他們的內容否則這不會通過審查
再次 對應非消費和自動更新的訂閱
你不會在恢復中得到其他的in-app purchase類型
一件事需要記住的是
我們想讓這些同購買隔離開
恢復是免費的
用戶不會感到疑惑如果他們做了恢復
他們需要輸入來自App Store的密碼
這會消耗他們任何東西
這個在你的應用程序是非常明顯的
他們做的這次恢復操作不是一次購買
這是完全隔離開的
所以你要確保的是你的UI反映
其他你想要記住的消息
對於自動更新訂閱的是關於政策的
保留信息在市場文本里
確保一旦他們訂閱了
他們就可以立刻得到內容
他們不需要等待直到下個階段開始
任何東西出現
如果你訂閱了你應該會馬上獲取一些信息
你應該獲取信息
關於你應該只能通過訂閱獲得
而不是一堆產品或者內容
他們本可以在別處獲取免費
所以 這就是一些政策
我強烈建議你看一下“APPS審查政策指南”這個講座
我已經聽說現在已經有一本漫畫書關於它
所以我強烈建議你把這些全部學習一遍
因爲它們一直在變化
你應該時刻關注它的變化
關於非更新的訂閱這裏有些其他政策
你要記住
關於隱私和確保用戶有能力去參與
或退出
然後最終這最重要的事情是通過應用反饋
是如果你已經在你的應用裏擁有購買它應該可以工作
你完成購買 內容就應該出現
它們應該得到信息
他們應該在那裏得到內容
如果它是缺陷或者如果他是容易錯誤
或者如果有什麼事情發生當評論人正在評論它
在應用評論環境內部
你就會在那裏立刻得到評論中的問題
所以測試它
測試它在Sandbox確保一切如你期望的工作着
所以剛纔總結下我們今天討論的
始終遵守支付隊列
如果你在你的應用裏與in-app purchase交互
首先你的應用應該設置一個支付隊列觀察者
去獲取信息關於支付的進展情況
你應該從App Store中獲取本地化產品信息
這是通過一個SK產品請求
它會返回本地化信息
所以用戶在他們國家的信息
關聯到App Store賬戶賬單信息
再次強調使用產品所在地的貨幣單位
這裏有個SK產品返回它有一個關聯的場所
你應該去使用它爲了展示價格和貨幣信息
使用receipt去驗證你的購買
再次 它們是你的購買 這是你的生意
你應該去做決定關於怎麼最好的去驗證receipt
是否在本地驗證或者在服務器
後面是什麼技術
要知道到底每個優點和缺點是什麼
用那個做下你的決定
最終使內容是可用的
你可以在那個設備的你的應用裏解鎖它
或者你可以發出一個App Store自己的託管請求
或者你可以發出一個請求到後端主機API
使內容可用
但是用一個可靠的而且快速的方法做它
如果你自託管確保你的服務器是可擴展的
你知道緩存適度
是真的準備爲了用戶很好地使用你的應用
然後最終完成交易
最後一件你需要確保的事情是
交易不再存在在支付隊列中
否則你的觀察者將會不斷的被通知
關於它當你的應用啓動
這將感覺很奇怪用戶可能不得不
在特定的時間進行身份驗證
或者那裏可能存在後臺代替你應用的API正在發生
爲用戶使用完數據空間如果你不能完成交易
所以始終那樣做
然後 允許用戶恢復完成交易
你需要一個恢復機制在你的應用裏
如果你有非消費或者自動更新的訂閱
這會允許用戶去獲取之前已經購買的
更多信息請在開發者網站上
我強烈建議你返回並稍後看看它
然後兩個相關的話題我們今天提到的
如果你正使用訂閱在你的應用裏
你應該明確的檢查“介紹擴展訂閱”
在iTunes Connect今天稍後的時間裏
或者如果你對按需資源有興趣
週四早晨來看一下
這是全部
謝謝