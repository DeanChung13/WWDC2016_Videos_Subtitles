Swift Foundation的新特性
謝謝
大家好 歡迎我是Tony Parker
我在Apple帶領Foundation團隊
今天我在這裏和Michael LeHew一起討論
Swift Foundation的新特性
這一年來Foundation團隊付出了很大的努力
改善你使用Cocoa的方式
以及Swift中Cocoa Touch的API
從Swift API設計指引開始
隨後 我們研究了所有Objective-C的代碼
包括Cocoa SDK使用及你自己編寫的代碼如何引入Swift
但是我們知道我們可以做到更好
所以 我們引入了一套新的值類型到Foundation裏
同時也引入了大量很棒的針對Swift的新API
我們繼續從設計指引開始
我們今年的工作圍繞着Swift 3 但是
我們最初設計Swfit的目標一直沒有變
我們希望你編寫的代碼快速 安全 表達性強
我們創建了標準庫
以及圍繞這些核心思想的編程語言
你們很多人也都理解了這些原則
並且根據它們建立了自己的應用程序
但是 我們都知道還有另一部分內容沒有提到
那就是Cocoa SDK
你的程序也非常依賴它
甚至對它的依賴要大於Swift標準庫
它需要看起來屬於同一個生態系統
因爲SDK在這裏至關重要
有關我們如何在自己的平臺上開發應用
讓語言和庫相互合作至關重要
所以今年我們專注於表達性
我提到表達性這個詞時有兩層含義
第一層意思指的是你作爲應用作者的能力
你編寫的Swift代碼能把你的意圖
傳達給編譯器和庫
但它還有另一種意思
庫需要能表達它們自己的目的
它們的設計模式
以及它們對於如何讓作爲應用作者的你能最方便地使用API的想法
所以在研究指引的時候
我們注重一致的體驗這一概念
有關指引的決策都基於這一概念
語言和庫密不可分
它們必須協同工作
舉個例子庫帶來了一堆新的特性
很多你看到的今年我們新版平臺上的特性
都源於庫中的新特性你也可以把它們用到自己的應用裏
提升你的開發體驗
這些庫在我們所有的平臺中都有廣泛應用
包括今年新的Swift Auto ARC和Swift Open Source
我們有Swift CoreLibs Foundation
把大部分FoundationAPI移植到其他平臺 如Linux
這些庫的實現經受得住考驗
其中很多自OS X時代就已經存在了
有些甚可追溯到更久遠
得益於Cocoa命名指引它們還帶來了
一套悠久傳統
這意味着當你看到一套新的API時
你馬上就能明白它的工作原理以及功能
最後重要的一點是
這些庫在不斷更新中
除了添加新的特性
我們還在改進 修復漏洞 等等
每年發佈新系統我們都會繼續這樣做
另一方面 Swift語言
帶來了一些Objective-C所沒有的特性
比如 對泛型的第一類支持
以及內置的對可變類型的支持
這些都是Swift語言安全性的重要部分
其中包括協議擴展
函數重載 以及默認參數值
這些都對如何設計Swift的API有着重要的影響
這個清單兩邊都沒有列全我沒有足夠空間
可以提到的還有很多
所以我們提煉了三份關鍵文檔
第一份是SE-0023API設計指引
所有文檔都發送到了SwiftEvolution郵件列表
給你和Swift社區
一個機會參與到語言的設計和進化中
我們把這些指引視作統一的文檔
無論是現在還是將來的Swift庫
此外我們還有SE-0006
將這些設計指引用於標準庫
提供了一套一致且可預測的原語集
我們可以把它們作爲基礎還有SE-0005
它大幅提升了Cocoa SDK的表達性
通過引入默認參數值
改進可選集以及編譯屬性
甚至在一些情況下自動採用協議
有一期關於此的演講
你如果沒看過的話建議你去看看
Swift API設計指引
這些已經算得上巨大的進步但我們知道 還可以更進一步
因爲Swift的目標不止於其名
可變性是這門語言至關重要的一部分
所以我們把目光聚焦於Foundation
若你在想爲何選擇Foundation？
答案是它比較特別
我這麼說不是因爲我的工作是關於它的
Foundation在SDK中處於一個特別的位置
它的層級足夠低
適用於任何我提到過的平臺
但與此同時它的層級又足夠高
足以建立一整套通用類型和設計模式
同樣你會發現它會反映到整個SDK
我們回顧一下剛纔的圖片放大這裏的Cocoa SDK
你會發現很多應用的日常開發中用到的框架
從UIKit到SpriteKit從WatchKit到CoreData
還有很多其它不適合放於此的Cores和Kits
有趣之處在於
所有這些都建立在Foundation的基礎上
因此將Foundation<c.magnenta>視作一槓桿點
在Foundation裏的一小點改動
會對整個SDK產生巨大的影響
一定程度上由於很多數值類型出自Foundation
所以我們注重進化勝過徹底改變這一觀點
我們看到了標準庫爲你的應用開發帶來的所有東西
我們不會因爲新語言而摒棄已有的一切
我們做的是讓語言和庫更加緊密
通過同時改進雙方
我們今天談論的正是這一過程的延續
把這一點放在心上Foundation團隊
在Swift Evolution郵件列表提出了兩個新的提議
第一個是Foundation中數值類型的可變性
把Swift的可變性模型
應用到Foundation框架上
另一個是拋棄SwiftFoundation裏的NS前綴
爲Swift建立通用類型和設計模式
以適用於任何平臺
這是我們今年對API做的一些改進的概述
第一點最重要的是數值語義
一套全新的數值類型在整個SDK隨處可見
此外我們對命名進行了些改進
超越了Objective-C翻譯成Swift能做到的
我們讓這些類型採用了很多標準庫協議
這意味着你的通用算法現在同樣適用於Foundation類型
我們額外添加了類型安全性以及很多針對Swift的新特性
我們來快速瀏覽一下數值類型
數值類型和引用類型不同
主要區別於複製時的行爲
數值類型在賦值或作爲參數傳遞時會複製它們的內容
舉個簡單例子我有一個點
我用等號把這個點賦值給另一個點
當我修改第二個點的時候你可以看到 只有副本改變了
我沒有影響兩個點的內容因爲CGPoint是數值類型
另一方面引用類型默認共享內容
這裏我用引用類型創建些數據它們是可變數據
同樣用等號把data賦值給otherData
然而這一次當我修改第二個數據的時候
你會發現它影響到了兩個數據的內容
重要的是要理解這兩者沒有好壞之分
只是使用方式不同
我喜歡把它們看做工具箱中的不同工具
當你需要解決某個問題時可以使用它們
所以當你試着決定
你的類型是數值類型還是引用類型
你應該從對象身份和存儲內容考慮
我舉幾個例子來解釋
Foundation中有個叫OperationQueue的類
OperationQueue中有一個單例叫main OperationQueue
這個mainOperationQueue
用於放置你希望在主線程上完成的工作
所以它只有一個這一定程度上代表了身份
若我能複製main OperationQueue它就不再是主隊列了
所以我們相信OperationQueue是一個引用類型
另一個例子 Cocoa SDK裏隨處可見的一種模式就是代理
這是一個代理或者說是URLSession的代理之一
你會發現這個代理協議有一個參數 就在這兒
名叫Session它告訴被委託的對象
它將以哪個URLSession的名義工作
這裏的哪個URLSession同樣暗示了身份
所以我們相信代理使用的類型通常是引用類型
從另一方面 很多類型的重點在於它們存儲的內容
比如Date
這是我們新Foundation數值類型之一
Date是一個絕對的時間點
我們可以有兩個具有相同值的Date
同樣的絕對時間點它們是同一個Date
我們不需要討論那個時間點的引用
如果我們查看Date的實現
正如你所見其實它只是個Double
Double我們可以本能地認爲是一個數值類型
另一個例子就是Data
Data是另一個新的Foundation數值類型
Data 通常情況下你關心的是Data的內容
它所包含的字節而不是NSData對象
所以Foundation把Date設爲數值類型
每次我們把它作爲參數傳遞時都需要複製數據
很快開銷會變得很大
所以我們進行了一種優化叫做寫時複製
這裏我建立了一些數據
看到我建立了一個Struct
但是在它內部還有一個引用
又一個合作提高效率的例子
我同時使用了引用和數值
來得到我想要的性能特徵
以及重要的數值語義
如果我用等號把這個數據賦值給另一個數據
你會發現我得到了另一個Struct
但其實在內部它們還是指向同一個類
但是如果我修改這個數據那我們就需要複製數據了
修改副本我們就有了兩個獨立的Data
如果我繼續修改第二個數據
我們可以斷定Data各有獨自的引用
而我們也不需要每次都去複製它
這是一種擴展 或者說其實就是同樣技術的另一種使用方式
這個技術我們以前談論過包括去年談到的
在Swift裏構建更好的應用和值類型
如果你想了解更多它的工作原理可以去看看
所以我們調查了Foundation裏每一個API
總結出了這份列表我們認爲它們作爲數值類型很棒
你會很高興看到很多你平時使用的類型都在列表上
包括我剛剛提到的Data和Date
還有很多別的常用類型比如URL
IndexPathCharacterSet 等等
它們當中很多不只是變成了數據類型
還增加了很多很棒的新API
爲了讓你們瞭解它們是什麼樣的我想有請Michael上臺
謝謝你 Tony
咱們先看看Foundation枚舉類型的新家
Objective-C裏的枚舉
以及選項集合生存在全局命名空間裏
和使用它們的類型在一起
比如NSNumberFormatter定義了四個枚舉
包括樣式、行爲、填充位置以及舍入模式
它們和NumberFormatter有一定暗中的聯繫
通過嚴格一致的命名傳統
在Swift 2中 你也知道它們同樣在全局命名空間裏
但這就感覺不像是純粹的Swift
Swift支持嵌套類型
所以在Swift 3裏我們決定改變這些類型的位置
在它們註定應該在的地方進行聲明
現在NumberFormatter擁有內置的樣式
行爲、填充位置以及舍入模式類型
它們的名字不再繁冗
這極大程度減少了
Foundation在頂級命名空間聲明的類型數量
關係也更加明確
我們的API表達性變得更強更易被發現
還是關於枚舉這個主題
很多Foundation API也使用字符串常量家族
比如Notification Name和URL Resource Key
Swift支持建立在其它原始類型上的枚舉類型
可以是整型以外的類型包括字符串類型
若我們在Objective-C裏也能做到這些豈不更妙？
今年 我們可以了常量現在被定義成了
類型非常具體的字符串常量
如Notification Name及URL Resource Key
以及很多很多別的
這些常量保留了可擴展性無論在Objective-C裏
還是在Swift裏
我們都可以對它們進行嵌套就像對待它們的兄弟整數類型一樣
這樣在Swift 3中使用它們非常自然 表達性也很強
另一個常見的Foundation設計模式是把狀態和類型聯繫起來
比如standardUserDefaults
Swift對於類屬性的支持可以很好地適用於這裏
今年我們把類屬性引入了Objective-C
它們的定義和對象屬性一樣
除了現在我們支持這個酷酷的類別關鍵詞
由於我們知道它是類屬性
我們不需再像Swift 2.2那樣把它作爲函數引入
它現在可以作爲類屬性出現
如同你會在Swift裏定義一樣
但我們沒有止步於此
有些累贅的詞在Swift 3中
我們徹底修改了Swift代碼的顯示方式
以及Swift裏Objective-C代碼的顯示方式
所以我們的最終API更像這個
我們知道它是userDefault通過幫助把Foundation
變得更像Swift我們獲取了很多好處
無論是對於Objective-C還是Swift
Tony剛纔說很多Foundation類型值得變成數值類型
我談談其中的一些我們從Date說起
假設我們要安排一條備忘錄
提醒我們什麼時候該回家
我們從Swift 2.2開始引出我們的例子
假設我們有一個函數它會告訴我們什麼時候應該回家
我們調用它五分鐘看起來正適合我們的提醒
我們繼續 你知道的把它偏移一點
有一點值得說明 NSDate是且一直會是一個引用類型
所以在這裏實際隱藏着兩個動態分配
一個在這裏另一個在這裏
在Swift 3裏我們可以使用Date數值類型
所以現在我們就來使用它用法和原來類似
但是這個變量的行爲和以前大不相同
特別地 我們允許內聯修改
我們沒做額外的事情
這兩個例子做的是一樣的事
除了對於數值類型我們不需要額外進行動態分配
繼續我們的例子
當然了我們也可以這樣內聯
關於提醒事項只有把它安排在事情發生前
纔是有意義的
Swift帶來的最棒的是
滿足某些條件時協議會自動被採用
在這個例子裏Date自動遵從了Comparable協議
它賦予了我們使用小於號的能力我們現在就在使用
我們可以設定定時器但首先我們要創建它
我們要使用另一個今年的新API
就是這個看起來很棒的基於閉包的定時器API
我們用一個閉包初始化定時器
不再需要selector和target了
我們把它安排在主RunLoop上
我相信線程和RunLoop也有這樣的方法
把它安排在主RunLoop上然後就完成了
這是個絕佳的例子 它展示了所有熟悉的Foundation API是如何
如此優雅地移植到Swift 3裏的
這是我能在演示裏展示的最具Foundation特色的代碼
我有個RunLoop一個定時器及幾個日期
基本上全是Foundation的內容極少的其他內容
看不到任何方括號
另一個新例子或說Fondation裏另一新類型
Measurement數值類型
假設一個新例子我們關心上下班線路有多長
而且我們很幸運我們住的地方距離上班的地方
只有兩條短街之隔
Measurement是數值類型並且Swift支持運算符重載
它們不僅僅是數值類型
它們還是Mathematical類型所以給它們設置運算符有實際意義
沒人會輕視它或不待見它
如果我們考慮把它們加起來
我們就可以計算出它們的總和甚至對它們進行轉換
轉換成另一個單位
假設我們很好奇想知道去工作路上要花費多久
這個我們也能做到
只是在Swift 3裏如果我們試着編譯這段代碼
它會失敗的而且是在編譯的時候失敗
得益於Swfit 3中泛型和類型限制的能力
我們設計成讓單位的區別
在編譯的時候就可以看出來
Swift編譯器可檢測出然後提醒我們
我們正在進行無效轉換
想了解更多Measurement類單位以及今年新引入類型的
整個新的生態系統的話記得去收聽這場演講
在週五下午 瞭解更多Measurements和單位
換一個例子
我說過這將是一場探索
假設我們想買幾臺MacBook
會使用新URLComponent數值類型
可以表達性很強地做到
從描述可變部分開始
把它作爲下面的模板
遍歷我們想要購買的產品
複製我們的模板然後修改這個副本
指定我們想要買的產品
在這裏我們可以放心地展開這個可選類型
因爲在我們的模板裏把它設爲了非空
繼續把我們的URL打印出來我們發現可以
不進行任何內存管理創建我們想要購買的產品的鏈接
只需聲明我們的意圖指明是否可變
然後語言就會爲我們處理好剩下的事
Swift 3 或者廣泛地說Swift帶來的另一個特性
是ProtocolComponents在很多Foundation類型中 比如Date
得到了有用的新能力這得益於新的遵循協議的方式
比如CharacterSet和IndexSet現在遵循SetAlgebra協議
你可以對它們進行並集交集 對稱差集操作
根據你的需要
Data現在遵循8位無符號整數的
MutableCollection協議和MutableRandomAccessCollection協議
就像你一直認爲的那樣
我們來看看遵從新的協議後Data現在能做些什麼
首先需要一些數據我手頭上有一些Base64數據
通過普通的初始化函數進行解析
這裏有個顯式展開我知道這麼做是安全的
因爲這裏只是個演示我知道它是有效的Base64值
你自己使用過程中可能需要用到try語句
我喜歡統計以及看起來很棒的圖表
當你的統計用直方圖的形式表現時我們要來建立一個直方圖
我們需要用到後臺存儲使用原始的Swift數組
把它全都初始化爲0
我們把data裏每一字節的值作爲索引
然後維護一個頻率計數
由於Data是一個Collection 遍歷它的字節
很自然且表達性高我們可通過一個for-in循環做到
接着我們創建直方圖來看一看
這看着絕對像直方圖
就像所有直方圖一樣裏面有信號和噪聲
我在這看到了不少高頻率數據
我想要把它過濾出去
幸運的是Data現在是Collection了
所以我們可使用到類似Map、Reduce、Filter的功能
以及其他你喜歡的Collection函數
假設我們想要剔除所有大於三的數據
就如同聲明謂詞一樣簡單
然後我們可以就生成過濾後的數據了
作爲一個CollectionData是可切分的
這些切片功能上和MutableCollection一樣
或是你在Swift裏見到過的數值類型Collection
修改它們會觸發同樣的寫時複製機制
正如Tony剛纔描述的它們的運行方式完全相同
Data還保留了可擴展性
通過繼承隱含的引用類型
這是很重要的一句話我會詳細講個例子
來解釋我的意思
舉個例子 我們先創建一個自定義的NSData子類
不給它分配任何存儲空間
代表一個虛擬的全是1的Collection
我們將它名爲AllOnesData 描述性很強
這裏我只展示一個方法的實現
獲取指定的字節getBytes多少可以實現這個類期望的功能
我們把所有字節設置爲1
不需要儲存任何東西
接着我們創建一個它的只讀對象
我們不會單純地使用引用而是會建立一個數值類型
並把引用包含其中
我們使用了剛剛創建的新的初始化方法
它和你預期的效果一樣
現在我們的ones數值類型指向全是1的數據的引用
它們是虛擬的
現在不會在內存裏佔用字節
現在我們來創建一個可變副本同樣 我們不做任何修改
所以我們現在不需要分配或管理任何這些內存中的字節
我們準備好對bytes進行需改爲了做到這一點
要用到一個今年新添的Foundation API
它是一個ScopedPointer Accessor
叫做withUnsafeMutableBytes
這比直接對data本身調用mutableBytes好得多
因爲我們把對這些字節的訪問限制在了
我們定義的閉包內
這很好理解
沒有漫天亂飛的指針
指針只在這個小的訪問器內部有效
我們實際進行修改引起寫時複製機制
現在這些字節
這些複製的字節真正是可見的內存了
接着下一個例子我厭倦談論Data了
我們來說說URL以及URL屬性
爲了說明這個例子
我想先說一說在Swift 2.2中我們是怎麼做的
在Swift 2.2我們會請求NSURL.fileURL
以my-special-file爲例
這個文件太特殊了我把它放在我的文件系統的根目錄
我對三個屬性很好奇
我想知道創建日期它是否是常規文件
以及出於某些原因這個文件所處卷的最大文件大小
這些在Swift 2.2只是字符串所以這只是個字符串數組
而且當我向我的URL請求資源值的時候
只會得到個普通的字典類型不包含任何類型信息
它只是字符串指向對象這意味着使用它時
需要用到很多as某個類所以我必須
暗示說它是布爾型暗示它是整數型
我一直在不停檢查引用值來確保我做的是對的
除此之外修改只是針對字典類型的
所以你可以做類似這樣的荒唐事情
並且每一個錯誤都是運行時錯誤
我們來看看Swift 3的改進
在Swift 3中建立URL的過程也很類似
但是我們不再使用類工廠方法
它變成了普通的初始化語法
我們現在談的依然是my-special-file
我們不再請求字符串數組
而是使用強類型的字符串枚舉
正如我之前說的一樣我們要創建它們的集合
當我們向URL請求資源值時
我們得到的不再是個字典
我們會得到一個值一個新的Foundation數值類型
我們看看這個Foundation值的類型是什麼
針對我們請求的三個屬性
你可以看到creationDate是一個Date
isRegularFile是一個Bool
volumeMaximumFileSize是一個Integer
而且還有一點需要指出的是
URLResourceValue結構本身是惰性的
它仍然是用字典實現的
正如Swift 2 API一樣沒有必要
這個巨大的Struct會消耗內存
我請求了三個東西就會得到三個東西
如果你有自定義keys字典還是在那裏
你請求的不是字符串而是你所感興趣的
URLResourceKey
你可能注意到有很多問號
原因就是 恩其實有兩個原因
第一個原因是你並沒有請求它
所以這個創建日期就不存在
這涉及到數據的稀疏性
第二個它不存在的原因是
就是屬性本身可能是無效的
volumMaximumFileSize就是個例子
我們來看看兩個關於工作原理的例子
因爲我們請求的是普通文件
我們完全可以顯式展開這個Optional值
它會出現在此因爲我們請求了它
然而 VolumeMaximumFileSize的文檔裏面說到
不是所有的卷或所有的文件系統
都支持最大文件尺寸這個屬性所以它可能並不在那兒
這是Swift裏使用if let結構的絕佳例子
有條件的設置局部變量
現在咱們說說修改
當然URLResourceValues中URL的修改API
與它新的值類型相關所以當你嘗試這麼做的時候
儘管這是我的特殊文件
我非常努力地說它不是常規的
編譯器會在我編譯的時候就會報錯
而不是讓我自己在運行時發現這個問題
更進一步 文件創建日期也是強類型的類型爲Date
如此荒唐的事 在Siri那可能行得通但寫代碼的時候是不可能的
關於Foundation的探索我最後想說的一點
就是Swift的原始枚舉類型
然後我們又要再一次談談數據了
因爲有個例子真的很不錯
當data擁有一個UnsafeMutablePointer時
你可以選擇設置一個deallocator
Data默認支持多種類型
包括自定義deallocator
現在 Swift支持把值和枚舉相關聯
你經常會看到這些和整數關聯
你可以在case表達式裏使用它們這樣你就可以
用它們做一些很酷的模式匹配但這裏我們接受的是一個閉包
因爲我們想把你提供的行爲包含其中
我們來實際做一下
我們從一個簡單的malloc例子說起
在Swift你依然可使用malloc
儘管你在演示中不常看到它
使用malloc分配內存當你把這個指針指向Data時
你可以把deallocator設置爲free
語法和使用集成值一樣簡單
我們再看一個自定義的例子
假設我們有一個函數create_glorious_pointer
我們想光榮地釋放它
以免它們受到冒犯
設置自定義deallocator非常簡單只需提供一個閉包
並且確保你進行了想要進行的操作
這非常強大
對於框架開發者來說也是一個很強大的概念
因爲在別的語言裏 我們不得不
提供另一個基於函數指針的API
但在Swift 3裏我們可以直接提供基於枚舉的API
它可以簡潔地表達所有內容非常有表現力
至此我們的API探索之旅結束了
但願我們見到了不少奇妙之處
現在讓Tony給大家詳細講講Adoption
謝謝 Michael
現在你對於可能做到的事情有了一點大致瞭解
我們來談談如何在你的應用中使用
咱們先來講講橋接
在這個主題上我們不斷迭代更新
我們把Swift 2裏面的一些你已經熟悉的概念進行了擴充
用於橋接Objective-C和Swift
如果你理解String和NSString是如何橋接的
我們把同樣的概念應用到了Data和NSData上
以及你看到的這裏所有的數據類型
這就表示所有從Cocoa SDK引入的API
都會使用這些新的數據類型
這就是我們形成槓桿的核心思想
例如 在Swift 2.2的AppKit中
你能看到這個類名叫NSDatePicker
它允許我們展示一個UI並讓你的用戶選擇日期
除去其他屬性它有兩個能夠控制日期的屬性
你能在這裏看到它們被標成了@NSCopying
它們是NSDate引用類型的
在Swift 3不改變AppKit前提下
我們只改變了Foundation這個類現在看起來是這樣的
你看 我們現在有Date結構類型了
而且我們不需把它標作@NSCopying了因爲他們是數值類型
我們會幫你進行復制
進行橋接可能會有一定的性能折損
爲了介紹原因我需要深入講解一下具體細節
橋接的原理究竟是什麼
橋接有兩個主要策略一個針對大型類型
它會存儲引用另一個針對小型類型
它會創建引用
舉個例子我們再討論一下數據
我又創建了一次data
它是一個結構體包含了一個引用類型數據
若調用Objective-C的API
將會發生的是 我們把引用交到Objective-C端處理
因爲Objective-C不會處理結構體數據
它只能看懂NSData
在這個例子裏也許對於同步方法調用
Objective-C的代碼在任何時間都不會持有這個數據
它可以訪問它隨後就忘記它
僅僅保存一小段時間引用即可
你會看到許多API會長時間持有數據
通常會被標註上Copying屬性
那樣 在Objective-C中
Objective-C代碼會調用數據的複製方法
因爲它需要保護自己
以免潛在的對於原始數據的修改
從一個完全未知的來源
這意味着 當發生橋接時可能發生數據的複製
我們把它翻過來看
這裏是一段Swift代碼它調用了Objective-C方法
並獲取返回的數據
這裏 Objective-C代碼創建了NSData類
當它回到Swift的時候
我們建立結構體數據並把引用包含其中
然後調用複製方法原因和上一頁演示文檔說的一樣
這個結構體需要保持它對這份副本的控制
這樣它纔可以向你提供正確的語義
幸運的是 基本上所有通過這個方式接收到的來自SDK的數據
都是不可變的
這意味着 這份副本在本質上只用於保持計數
但是有一點很重要需要明白
當橋接的時候可能會出現複製操作
對於小的類型 比如Date你會發現並不存在引用
我們剛纔看到了它的實現只有一個Double
所以在Swift裏 若我調用了一個Objective-C的函數或方法
它接受一個Date 我們需通過橋接分配一個NSDate
那是因爲Objective-C代碼只知道如何處理引用類型
在Objective-C方面我們採用了很多技巧
使NSDate分配的開銷很小
這點很重要 我們要明白橋接的時候會產生內存分配
所以我們優化了這些數據類型以適配Swift
在你的編碼中你應該避免來回橋接
這是因爲我們想讓我們的編碼默認是安全的
但是它確實說明在這裏可能有潛在的複製操作
這是使用新的數值類型時需要注意的幾點
現在咱們來談一談遷移
先來說說好消息
我們今天說的新類型適用於所有Swift部署目標
這些都是Swift標準庫的一部分
所以你不需要等待客戶
升級到我們最新版本的平臺
一旦Swift 3和Xcode 8發佈
你馬上就可以使用它們
現在 爲了幫助你我們升級了Migrator
這就代表當你打開Xcode 8裏你的項目
你會看到一個類似這個的對話框我建議你點擊Convert
我來展示一下Migrator可以幫你做的一些事
現在我們在Swift 2.2中有一些NSDate
我們調用它的dateByAddingTimeInterval方法
Migrator會把NSDate這個引用類型
修改爲結構類型的Date
然後它會改變方法
因爲它們已依據最新的Swift 3API設計指引進行了修改
無論是針對引用類型還是數值類型
我們再來舉一個例子
我在Swift 2裏創建了一個NSDateComponents
然後對它的屬性進行了設定
我能做到這些是因爲NSDateComponents永遠是可變的引用類型
Swift 3裏引入了新的結構體DateComponents
所以Migrator會把引用變成結構
但是它注意到你對它進行了修改所以它還會幫你把let改成var
Migrator可以幫你做很多
但有些地方如果你檢查一下它做了什麼
你自己可以做到更好利用我們提供的新功能
該例中DateComponents有一個新的initializer
這我們只能在Swift裏做到
這個initializer爲 DateComponents裏的每一個屬性提供了參數
這些都不是必需項而且都有默認值
你可只利用自己在乎的值創建DateComponents
比如這個例子裏只提供月和日
然後把var變回let
因爲初始化後你不需要改變它
最後又要說到我們的朋友Data類型了
Swift 2裏我建立了一個NSMutableData
它是一個引用類型然後我給它添加了一些數據
在Swift 3裏Migrator會處理好方法名稱
比如contentsOfURL以及appendData
而且它會把NSData變成Data結構
但是 它沒有處理NSMutableData引用類型
有些情況下 信息量不夠
Migrator沒辦法做到我們認爲最佳的選擇
我們不去管它它依然能正常運行
但是如果你回去自己做一些修補
你可以做到些很酷的事情
我們可以把MutableData變成Data結構
即我們把它從let改爲var
還可以刪除掉options參數因爲它現在已經有默認值了
我們今天談了不少東西現在讓我們來稍微回顧一下
相信這些對Foundation的改進
會讓整個SDK受益
並提升你的整個Swift開發體驗
一方面是由於API重命名
另外我們把握住了機會更進一步
添加了一套全新的數據類型以及很多針對Swift的新API
我們將此視爲一段旅程的開始
並且在未來我們也願意繼續成爲支點
我們要做很多改進
讓你的Swift應用更安全 更迅速 表達性更好
有興趣多瞭解的話去查看下這個URL結構
以及這些相關演講 包括
使用Swift Open Source深入服務器端Measurement類型和Unit類型
謝謝大家