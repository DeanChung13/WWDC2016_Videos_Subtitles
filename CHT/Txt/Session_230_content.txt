用CallKit提升VoIP應用
大家好
歡迎來到演講230
我是Sirisha一名CallKit的工程師
今天和我一起的還有我的同事Stewart和Nick
今天我們很興奮地向大家介紹一個全新的框架
CallKit
你們有很多人已經編寫過VoIP應用
你們改變了電話通訊的面貌
讓世界變得更小
你想讓你的應用成爲用戶的首要選擇
他們用你的應用在iOS上接聽電話我們想爲你們提供這方面的支持
CallKit是一個框架 能夠大大提升第三方VoIP應用
使它和原裝應用的體驗一樣好
謝謝
因爲你們很多人已經編寫過VoIP應用
接下來的40分鐘中假設我們創建了
一個全新的應用叫做Speakerbox
Speakerbox是一個簡單的應用
能在iOS上撥打與接聽電話就像現在的iOS上的軟件一樣
在開始之前先讓我設置一個場景
Jane一直在歐洲旅遊
關心她的父母想要聯繫她
以確定她現在很好
因爲是國際長途他們要使用Speakerbox
給她打電話
現在看看給Jane的來電是什麼樣子
這是Jane的鎖屏屏幕
首先她收到爸爸的iMessage
在她還沒有回覆的時候就收到了媽媽打進來的電話
Jane不能分辨
iMessage通知
與打入電話通知的區別
因爲現在的VoIP電話
它僅僅是一個通知
如果Jane想接聽這個電話
她要打開Speakerbox輸入密碼
連接到應用上去然後開始講話
這是Jane開鎖後的屏幕體驗很糟糕
她收到媽媽打來的電話
你會不小心錯過這個電話嗎？
有可能它僅僅是一個頂部的橫條
那麼是不是這樣更好呢？
如果給Jane的來電是這個樣子
這是Jane的鎖屏屏幕
她收到媽媽打來的電話
注意全屏本地用戶界面
Jane滑動一下就可以接聽電話和媽媽交談了
而且在解鎖屏幕上也是這樣
同樣豐富的本地用戶界面上面有接聽和拒接按鈕
而且預先設置好的鈴聲會響起
這樣不是更好嗎？
如果VoIP電話能夠和系統中的其它電話互動
例如本地電話、FaceTime語音電話
或者另一個VoIP電話
甚至VoIP電話能夠從通話記錄、常用聯繫人、
甚至是聯繫人中撥打電話
或者從Siri、Bluetooth上撥打電話
甚至有請勿打擾和黑名單等功能
這就是CallKit
今天我們將講解CallKit的架構、
打入電話流程和打出電話流程
最後詳細講解一下它的API
現在開始
好 這兒我們有所有的系統服務例如藍牙、
Siri、CarPlay和本地用戶界面
這兒有全部的VoIP應用例如Speakerbox
它們是兩個獨立的實體
系統和服務不能獲知對Speakerbox進行的調用
在iOS 10中我們已經在系統服務中採用了CallKit
現在系統通過CallKit可以獲知對藍牙的調用
如果Speakerbox想要相似的體驗
它要使用CallKit
系統現在通過CallKit可以獲知對Speakerbox做出的調用
然後系統會給其它服務公佈這些調用
讓我們深入講解一下Speakerbox
現在我們有Speakerbox和它的所有代碼
它和網絡通信它有自己的應用用戶界面
現在我們要連接CallKit
在CallKit中我們關心兩個主要的類
第一個是CXProvider類
這個類是Speakerbox用來
讓系統獲知
發生過的帶外通知
第二個類是CXCallController
這個類是Speakerbox用來
讓系統獲知本地用戶的操作
讓我們詳細瞭解一下這兩個類首先是供應商
供應商 正如我剛纔說的
是讓系統獲知帶外通知的一個類
這些通知不是用戶的行爲
他們實際是外來的事件 例如
Speakerbox接到一個打來的電話
和CXCallController對比一下
CXCallController是Speakerbox用來
讓系統獲知來自應用內部請求的類
它實際上是用戶行爲
是內部事件 例如撥打電話的操作
通過CallControllerSpeakerbox
可以與系統的其它呼叫互動
例如在一個本地電話通話時
用戶想從Speakerbox界面發起一個Speakerbox通話
通過使用控制器
系統會獲知發起通話的操作
並且系統會通知本地電話的供應商
保持它的通話 從而讓Speakerbox開始它的通話
讓我們舉一些例子說明一下
供應商用來報告帶外通知
例如向Speakerbox發起的來電
或者向外撥出的電話已經連接
或者撥出的電話已被對方終止
而控制器用來請求
來自系統的操作 例如用戶想
發起一個的通話或者用戶想接聽
Speakerbox的來電或者結束Speakerbox的通話
當供應商想和
系統通信的時候它使用CSXCallUpdate類
當系統想讓Speakerbox
和用戶互動的時候
它使用CXAction類通知Speakerbox
控制器和系統通信時
用戶的操作被捆綁成CSTransaction
以便讓系統獲知這些操作
剛纔講了許多
讓我們看看打入電話的流程
我們有SpeakerboxJane接到了來自媽媽的呼叫
呼叫來到Speakerbox以後Speakerbox創建了CXCallUpdate
並且使用供應商把呼叫傳送給系統
然後系統會把呼入
公佈給所有的服務進程 包括用戶界面進程
如果Jane想通過應用界面來接聽呼叫
接聽操作會傳遞給系統
系統接着會告訴Speakerbox供應商
會回覆CXAnswerCallAction
在需要的情況下Speakerbox會接聽這個呼叫
如果Jane現在想從應用界面內結束這個通話
結束操作就傳遞到控制器中
控制器把它捆綁傳遞給CXTransaction
並且傳遞給系統如果一切順利的話
系統把它通過供應商返回給Speakerbox
然後Speakerbox就可以結束通話
下面我們讓Stewart爲我們做一下演示
謝謝Sirisha
現在你們瞭解了CallKit的好處
我將演示一下如何使用CallKit
在一個已經做好的VoIP應用中Speakerbox應用
就是Sirisha剛纔講過的應用
我首先給你們展示一下如何用它處理一個呼入的通話
我首先打開一個SpeakerboxXscript工程
在我深入講解在應用中使用CallKit之前
讓我給你們展示一下這個應用的架構
這樣你就有一個參考的框架
在應用中有兩個主要的類
SpeakerboxCallManager類它維護應用中的通話列表
它有一些操作比如發起通話和結束通話
另一個主要的類是SpeakerboxCall
這是一個模板類表示應用中的一個通話
它有關於通話的元數據和一些回調代碼區
在它運行的時候我們可以得知通話的生命週期
正如Sirisha提到的 我們使用CallKit時首先需要做的
是創建CX供應商
並且設置它的代理
首先我要創建一個新文件叫做供應商代理
在這個新文件中我要加入一些已經寫好的新代碼
首先讓我們看看它能做些什麼
在初始化程序中我們把一個引用參數
傳遞給SpeakerboxCallManager類
使供應商代理能夠訪問應用的通話列表
然後通過UUID引用它們我們在後面會演示
然後我們 我們創建一個CXProvider實例
然後我們傳遞
叫做供應商配置的東西我們現在看到的就是
供應商配置
會在後面詳細講解
它讓應用能夠配置一些系統選項
以決定它的行爲
現在回到初始化程序
我們把這個類設置爲供應商代理然後如果有必要的話
我們請求使用供應商的授權
好
現在已經設置好了供應商和代理
我們需要在應用代理中創建這個
我聲明一個變量供應商代理
並且在application函數中實現了
didFinishLaunchingWithOptions方法
酷
現在應用中有了一個供應商
那麼當有呼入的通話時應用怎樣對作出反應呢？
我把它往下拉
我們會看到應用現在使用PushKit
通過推送通知獲知呼入請求
我們看看這個代碼起了什麼作用
我們看到它查閱了dictionaryPayload
它從推送通知中查閱並且獲得一些
關於呼入電話的元數據例如UUID
和代表呼入者的標識符叫做句柄
然後我們調用顯示來電方法
我們看 這兒的代碼是
應用控制本地的通知
給用戶顯示來電
但是如果使用CallKit
我們不再需要本地通知來顯示這個
我們轉而可以使用系統的全屏本地來電用戶界面
我們這樣做是因爲這能獲得更好的體驗
要這樣做 我將回到供應商代理
我要創建一個helper方法
它讓我們爲供應商調用API
我將會調用reportIncomingCall方法
在這個方法中
我首先要創建一個CXCallUpdate類
它含有呼入電話的元數據
然後我們爲供應商調用reportNewIncomingCall方法
這將會告知系統來電的信息
現在我們要在代碼中加入異常處理
我們要檢查是否有異常
如果沒有異常我們就創建SpeakerboxCall實例且配置它
然後我們把這個通話添加到應用的通話列表中
後面我們會詳細講解
爲什麼這兒有個異常處理？
無需多說 有些情況下
設備沒有準備好
接聽來電
好 現在我們的供應商代理中有了helper方法
回到我的應用代理
把這些代碼改爲調用helper
發佈本地通知
好
現在我們使用CallKit
通知呼入電話
而過去我們通過推送通知獲知這個消息
系統使用全屏本地來電用戶界面顯示了來電
好 那麼如果用戶按下綠色按鈕
接聽來電會發生什麼呢？
在這個時候
供應商代理會收到另一個方法 我們還需要實現它
這就是ProviderPerformAnswerCallAction方法
讓我演示一下
首先我們創建一個
Speakerbox call類的實例 它和
我們正接聽的通話UUID相對應
下面我們調用answerSpeakerboxcall方法
這些代碼來自老版本的應用
它和網絡通信告訴它要應答這個來電
我們在供應商代理回調中這樣做
最後我們調用執行操作
在CallKit中 每一個動作要麼被執行
如果成功的話 要麼執行失敗如果有異常的話
這兒有幾行代碼
如果我們找不到Speakerbox對這個UUID的調用
我們就調用failed方法向系統報告
這個方法處理對來電的應答
那麼如果用戶如何結束通話呢？
爲此我們有一個相似的方法叫做
ProviderPerformEndCallAction
它們很相似
它查詢一個基於UUID的調用
它使用endSpeakerBoxCall方法和網絡通信
通過調用執行告知這方法執行成功
然後把通話從應用的通話列表中刪除
現在處理呼入的通話我們講的差不多了
還有一件事情
在處理呼入的通話時應該考慮
就是通話的音頻
使用CallKit時
你不需要直接激活應用的音頻會話
你只需要配置音頻會話
系統會爲你激活應用的音頻會話
並且提高它的優先級
讓我演示一下它是如何工作的
回到PerformAnswerCallAction方法中
我在函數configureaudiosession中插入一個通話
正如字面意思它能配置應用的音頻會話
但是並沒有激活它
音頻會話將被系統激活
然後
我們會收到一個返回的代理叫做供應商
didActivate audioSession
從這兒開始我們開始處理通話的音頻
最後一步是停止處理通話的音頻
它是用PerformEndCallAction方法實現的
好的 這是我們使用CallKit處理呼入通話的所有代碼
現在我把設備屏幕顯示在電腦屏幕上
讓我們編譯運行設備上的應用
爲了本次演示
我僅僅使用底部的按鈕模擬呼入通話
現在我按下它
我們會看到Speakerbox的呼入請求
它使用了全屏本地呼入用戶界面
我可以接聽這個電話
供應商代理就會收到PerformAnswerCallAction方法
它執行了最後當我和Jane交談完以後
我可以結束通話和應用供應商代理也執行了
這是使用CallKit處理呼入電話的演示
現在交給Sirisha
謝謝
謝謝 Stewart
讓我們再回顧一下Stewart的演示
首先 把呼入的請求
通過reportnewIncomingcall API通知給系統
然後我們處理接聽電話的操作
通過實現代理方法performActionAnswer
CallAction
然後我們接聽了電話
我們通過調用執行API執行了這個操作
CallKit能做的不僅僅只是接電話
這個列表列舉了它支持的其它操作
有保持通話、多人通話、雙音多頻電話等等
現在花點時間談談多人通話
假如Speakerbox可以處理多人通話
在這兒 在這個例子中
已經有一個活動的Speakerbox通話了
這時又呼入了一個電話
若用戶想用本地用戶界面結束這個活動的通話
並且接聽下一個呼叫
系統就會發送CXTransaction給Speakerbox
CXTransaction就是一個或多個操作的列表
在這種情況下 那就是結束和應答的操作
一旦Speakerbox處理
和執行其中的操作
它需要分別完成它們
這樣系統知道要轉換用戶界面
現在我要交給Nick講解打出電話流程
謝謝Sirisha
讓我們繼續用Jane的例子
她昨天和媽媽通了電話但是今天她有點想家了
她想和家人聯絡
讓我們看看如何打出電話
首先Jane要做的是到最近聯繫人中
點擊 給她的媽媽打電話應用啓動時
首先出現了可能通話操作列表
你們中有人可能已經看了SiriKit的演講介紹
我們介紹了可能通話操作列表
如果你想了解更多信息
你可以觀看在線視頻
一言以蔽之可能操作列表
就是期望的用戶行爲
被打包在NSUser活動中並且傳送給應用
應用收到可能通話操作列表
就創建可能通話操作
根據可能通話操作中的信息
我們會得到相應的操作 然後通過CallController發出請求
CallController會把操作傳送給系統
如果它接收了 它會通過供應商代理返回給應用
最後我們的應用會得到這個操作
使用網絡上必要的命令
打出電話
首先看看從這時開始的呼出電話的生命週期
我們已經開始進行呼出操作
所以呼叫現在處於正在開始狀態
這時我們完成了執行這個操作
執行操作把呼叫轉移到已經開始狀態
當對方接聽電話時
我們會通知供應商通話正在連接
最後
我們會通知供應商通話已經連接並且通知系統
雙方可以通話了
有請Stewart回臺上
做另一個演示
謝謝 Nick
現在我要演示第二部分
如何使用CallKit和Speakerbox
這一次是如何使用它處理呼出的通話
我要再次打開一個Speakerbox Xscript工程
回到我們的應用代理類
我們看到Speakerbox現在這樣處理啓動
用一個URL開始新的通話
當用CallKit的時候
撥出電話的過程是相似的
但是當用戶從這些場閤中發起通話的時候 例如電話應用、
最近聯繫人、聯繫人卡片或者Siri
應用啓動時有可能操作列表
並且會通過NSUser活動傳遞給我們
這兒使用CallKit的第一步是
實現applicationContinueUserActivity方法
看看是怎麼做的吧
先看看NSUser活動
我們要得到startCallHandle變量的值
這些代碼我們已經寫好了查看NSUser活動
得到可能操作列表 返回句柄
它是一個字符串代表我們想要把電話打給何人
現在一旦我們有了句柄
開始新通話的過程就等於上面的URL句柄
我們僅僅是在通話管理器中調用了開始通話方法
現在看看這個方法做了什麼
我們可以在SpeakerboxCallManager類中看到
我們通過創建模板類的一個新實例就開始了一個通話
Speakerbox通話
然後我們調用StartSpeakerBoxCall方法
它會和網絡通信 然後開始發起通話
最後還把這個通話加入到通話列表中
但是現在還沒有使用CallKit來通知系統
我們打算髮起一個新的通話
我們需要這樣做
所以我現在要刪除這些代碼
過一會兒我還要把某些部分添加回來
在這個類中採用CallKit首先要
導入框架
然後我需要Sirisha提到的第二個類
CXCallController
現在在開始通話方法裏已經有了
我需要創建startCallAction
然後用我想撥出的句柄配置它
然後創建CXTransaction它含有有上面的操作
最後我在callController中調用請求事務
請求系統執行操作
現在僅僅是重複Sirisha提到的這一點
你可能想知道爲什麼我們需要向系統請求這個事務
其實看起來這一切只是
發生在應用的內部
原因是當你試圖
發起一個通話的時候
系統可能已經有了一個其它的通話正在進行
例如 如果用戶使用本地電話、FaceTime電話
或者其它的VoIP應用電話
如果這樣的話 系統需要在你的通話開始之前保留原來的通話
爲什麼我們需要從系統層請求操作
要讓系統知道這些操作
現在 一旦系統接收並且改善了我們的開始通話操作
它要通過供應商代理把這個操作發送回給應用
所以我需要實現供應商代理的另一個方法
它叫做provider performStartCallAction方法
讓我們一起寫這些代碼吧
和以前一樣 我們首先
創建一個Speakerbox call模板實例
然後用我們用撥出通話的句柄來配置它
然後配置音頻會話這和以前一樣
當應答不同時間打來的電話時
我們需要在通話上配置一些屬性
這兒的代碼很多 讓我們梳理一下
我們爲通話設置兩個通話返回代碼區
hasStartedConnectingDidChange和hasConnctedDidChange
它們是異步的通話返回代碼區它們會被激活
當通話由已連接狀態
進入正在連接狀態然後再進入已連接狀態
在這些通話返回代碼區中
我們向系統報告通話的過程
這樣系統就會知道並且在界面中顯示出來
設置好了以後 我們就可以調用startSpeakerboxCall方法
在通話時
它會再次同網絡通信 然後撥出電話
完成了這個操作就可以向系統報告操作成功
並且把通話添加到通話管理列表中
好 這是對呼出通話的處理
但是如果用戶想結束通話我們該怎麼做呢？
從我們自己的--應用自己的用戶界面上
這樣我們需要回到Speakerbox callManager類中
看看結束通話方法
在這兒 我們可以看到和前面的發起通話方法一樣
它還沒有使用CallKit
所以我要替換一下代碼
我把它拖進來看看 我們創建了結束通話操作
它被打包成事務
從callController可以請求這個事務
這一次你不需要在供應商代理中做任何改動
因爲你可以看到
我們已經在前面的演示中實現了這個
這就是我們處理呼出通話的所有代碼
現在我要在設備上編譯和運行應用給你們另一個演示
我已經在設備上編譯和更新了應用
爲了給你們演示呼出通話
我想回到聯繫人卡中的電話應用
現我們能夠看到Speakerbox應用列在聯繫人卡中了
我只要點擊這兒就可以運行應用
應用啓動了
它會收到可能操作列表
使用callController開始一個通話
它會請求系統支持的一個事務
提供給供應商代理然後供應商代理執行操作
現在看 就是這樣
現在通話正在進行
現在正在通話 如果我按下home鍵退出 我們能看到一些新鮮玩意
竟然出現了綠色的雙倍高度的狀態條
在顯示我們的應用正在運行
以前這是本地電話
和FaceTime電話專用的如果我點擊它
將會回到Speakerbox通話頁面
謝謝！
當通話結束的時候我點擊結束通話
這會向系統發出請求 終止通話操作
供應商代理會執行這個操作
這是使用CallKit處理呼出通話的所有演示
現在交回給Nick回顧一下然後介紹幾個別的API
謝謝
謝謝 Stewart
首先快速回顧一下剛纔的內容
首先是Speakerbox收到可能通話列表
基於這個列表創建了開始通話操作
然後請求開始通話操作
開始通話操作通過供應商代理被接收
然後執行
最後 Speakerbox報告通話成爲正在連接狀態
然後是已經連接狀態
這是基本的流程
現在讓我們深入研究一下API的細節
以便充分的使用CallKit
我們要尤其關注供應商授權
和配置它們幫助在本地用戶界面中定製應用
我們看看如何處理操作異常
和系統約束
最後看看CallKit
在應用的通話音頻扮演什麼角色
所以和其它API一樣例如聯繫人和定位
CallKit要求用戶的使用許可
因此
應用在啓動的時候首先要做的是
檢查它當前授權的狀態
因爲從上次啓動應用以來它可能發生了變化
如果用戶設置激活或者終止你的應用
那麼現在
如果你發現應用的授權狀態
還沒有確定你應該請求應用的授權
這就是告訴操作系統給用戶展示一個
警告 請求獲得許可
這是爲你的應用做出的授權
因爲這是爲你的應用做出的授權你應該確定
在應用的info.plist中包含應用字符串 提供相應的信息
最後 當應用啓動的時候
你應該確定時刻監聽
可能發生的授權狀態的改變
這樣你能一直爲用戶顯示最新的用戶界面
現在談談供應商配置
供應商配置使你的應用
直接在本地或者通話用戶界面中定製通話體驗
可以定製
爲你的通話顯示應用的本地名稱
這包括特定的功能
例如應用是否支持視頻通話
這甚至包括
是否指定自己定製的圖像直接顯示在
終端用戶界面的按鈕處
當點擊的時候會讓用戶直接啓動應用
記一下 對於本應用圖標的支持
在下一個版本會實現
到目前爲止我們看到了執行順暢的時候應用的表現
但是如果碰到問題會怎樣呢？
看看前面撥出電話的例子吧
我們已經執行了開始通話操作
但是在執行的過程中我們碰到了異常
也許是和網絡服務器連接不好
導致我們無法撥出電話
在這種情況下 我們要終止通話操作
這很重要是因爲它要通知操作系統
出問題了
操作系統反過來
會通過調用失敗用戶界面通知用戶
同這些操作異常密切相關的是操作失敗時間
系統的每一個操作都有和它關聯的特定的失敗時間
這些失敗時間很重要因爲它們確保
用戶發出的操作
以操作和迴應的方式進行
因此應用應該總是確保
在一定時間內來執行這些操作
如果某個操作超時了
應用會通過合適的供應商代理方法得到通知
同時做出合適的反應
根據設備當時的狀態
一定的系統約束是必要的
讓我們用打入電話作爲例子
你的呼叫
應用的打入呼叫被拒絕了可能因爲
用戶停止了應用它不再被授權使用
或者撥入電話者
在接入電話的黑名單中
或者用戶啓用了禁止打擾功能
現在不想接任何電話
對於所有這些情況
應用會通過API的完成句柄得到通知
例如 reportNewIncomingCallAPI
在完成句柄中會返回一個錯誤代碼
你看 應用檢查了返回的錯誤代碼
看到錯誤代碼是禁止打擾
就會做出相應的處理
現在讓我們看看CallKit的音頻
有了CallKit的通話音頻應用得到很多好處
最大的好處是
它的音頻會話在系統中的優先級會得到很大提高
同本地電話和FaceTime電話不相上下
這意味着系統上的其它應用不能
打斷你的應用的通話音頻
除此之外
CallKit能分辨系統的特定音頻路由
這意味着它能知道如何路由音頻根據
用戶的當前訪問配置
還是當前連接的藍牙設備
讓我們把呼入電話流程作爲例子
我們知道在接到電話以後應用
會收到迴應呼叫操作然後執行這個操作
在收到迴應呼叫操作以後應該
配置音頻會話
因爲我們知道通話很快就會進入已連接狀態
當我們執行迴應呼叫操作以後
系統會自動爲應用開啓一個音頻會話
而且具有很高的優先級
然後讓應用知道這些已經完成
這是通過did activateaudiosessionProviderdelegatecallback告知的
這實際是通知應用
應該爲通話開啓多媒體了
這是對API 的細節的簡要介紹
它們幫助我們使用CallKit
現在我們邀請你在創建的VoIP 應用中採用CallKit
或者使用CallKit創建一個全新的VoIP 應用
使用CallKit你將直接調用整合系統的底層驅動
一旦你使用了CallKit你的應用將獲得
和本地電話服務平等的功能
最重要的是
使用CallKit你的應用將
在系統中是可見的無論是在全屏、
鎖屏的來電提醒、最近來電、
常用聯繫人和聯繫人中 還是和Siri、
CarPlay和Bluetooth的整合中
要獲得更多信息請查閱我們的演講網址
developer.apple.com
那兒也有Speakerbox的示例代碼
這個演講中我們也一直在引用上面的代碼
我們有很多精彩的相關演講
一定要參閱關於Siri、可能操作列表、
網絡和音頻的更多信息
非常感謝你們的到來希望在實驗室裏看到你們