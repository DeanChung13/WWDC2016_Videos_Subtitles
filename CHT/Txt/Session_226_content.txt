CloudKit新特性分享無限渴望
下午好 歡迎來到第226場演講
CloudKit新特性
我是Paul Seligman
CloudKit客戶小組的工程師
我今天很高興能跟你們在一起
聊一聊最新的消息
和新的特性關於CloudKit的生態系統
我們今天講什麼？
今天首先我們要簡單瞭解一下什麼是CloudKit
然後我們換個話題講一講Telemetry
這是一個新特性可以讓你想象
CloudKit支持的應用如何工作
我們會講到API的改進和可用性
我們還會講到Sharing
這是個新功能可以讓用戶
能夠分享數據
但同時又能完全控制他人的訪問權限
什麼是CloudKit？
CloudKit是一種技術讓你能夠
使應用數據和用戶數據
隨時隨地可用
CloudKit是一個框架給你訪問iCloud數據庫的權限
CloudKit被大量使用於Apple產品
它讓你們相信我們努力的貢獻
它讓我們自信能夠連接到
數千萬用戶
CloudKit可用於所有Apple平臺
現在 我簡明扼要地介紹一下CloudKit
就是過去幾年我們爲引進CloudKit所做的幾個方面
我建議你們去聽聽下一場演講
如果你想要更多的瞭解生態系統
我還要推薦這幾場演講
他們更詳細地講解了CloudKit的具體方面
通過這些方法你可以讓你和你的應用
利用CloudKit的優點
現在 所有的演講都已發佈到網上且相互關聯
developer.apple.com/CloudKit
這裏所列的東西
是使用CloudKit的開發者必須要熟悉的東西
我們一個個講先從Container開始吧
Container是一個機制通過它可以上傳數據到iCloud
所以 Notes會用到Container
照片會用到Container
當應用在CloudKit創建時
它也需要有自己的Container
如果我們看看Container內部就會發現它裏面裝的都是數據庫
直到上週這就是我們的數據模型
Container有兩個數據庫一個公用的和一個個人的
引進了分享後我們就用了第三個數據庫類型
分享數據庫
這個之後細講
存儲的基本單位在CloudKit裏是一個record（記錄）
它是一組鍵值對
通常映射到一個目標模型不對 是數據模型中的一個目標
現在 我們不會把記錄鬆散的存儲在數據庫裏
而是將它們封裝在Record Zones（記錄區）
一個記錄區可以存很多個記錄
一個數據庫可以有很多個記錄區
不同的數據庫支持不同類型的記錄區
公用的和個人的數據庫都有一個默認的記錄區
這是你所有記錄的歸屬除非你特別指定另外一個
個人數據庫也可以包括自定義的記錄區
這是由你的應用創建並上傳到數據庫
最後 新的分享數據庫由分享類記錄區組成
有了分享功能後這個列表上就多了一個新的核心概念
就是Share的概念
Share是record的子類並同樣地
與Records一起存在記錄區裏
你可以把Record想成你想要分享的東西
Share代表的就是你如何分享它們
比如參與者和許可
同樣 這個一會兒再說現在只要知道有這麼個東西
我們在Apple的很多系統中使用CloudKit
所以我想花點時間來着重介紹我們的幾個客戶
在公用數據庫裏有一些應用可能是你用過的
WWDC應用和News應用
特別是News應用它要將文章內容和圖片等
保存到公用數據庫裏
這是公用數據庫最大的好處
它存的數據是你希望所有用戶都能訪問的
與之相對的就是個人數據庫
個人數據庫是你存儲用戶私人數據的地方
這裏面有幾個是Apple的應用
包括iCloud Backup和iCloud Drive
iCloud Photo Library和Notes
我很高興地跟大家宣佈兩個新功能
Notes Collaboration和Activity Sharing
都是創建於CloudKit Sharing之上
因此Notes和Activity應用
是使用分享數據庫的應用
2年前 我們引入了CloudKit通過提供兩個本地框架
一個是iOS 另一個是macOS
去年我們這個家庭擴大了
新添了tvOS數據庫框架
還有兩個網絡框架
CloudKit JS和CloudKit網絡服務
網絡框架可以讓用戶訪問CloudKit數據
無論是在網上
還是在沒有其他本地框架的平臺上
今年我們繼續擴大來完善這個家庭
就是添加了watchOS本地框架
我們這就有了一個可用的CloudKit本地框架
覆蓋所有Apple平臺
那麼現在我們來慢慢了解
今年的一些值得注意的針對平臺的改進
從macOS開始吧
我們要與你們分享的這個大好消息
就是你不再需要通過MacApp Store來分發應用
只要好好利用CloudKit
使用iCloud forDeveloper ID新特性
你可以直接授權應用使用CloudKit
和其他iCloud服務通過你的許可配置
接下來我要講的是服務器對服務器
這個功能已經推出了幾個月了
它讓你能夠
使你的服務器直接與CloudKit服務器對話
就像管理用戶一樣
你的服務器可向CloudKit驗證自己
通過使用一個公用/個人的密鑰對
是你已在CloudKitDashboard建好的
你可以設置你的服務器
讓他們有完全權限改寫公用數據庫
這是個很好的方法讓你從服務器導入數據給CloudKit
或者從CloudKit導出數據到服務器
或者讓兩套數據更新保持服務器和CloudKit一致
CloudKit作爲watchOS的本地框架被引入後
你就有了另一個機制讓你的Watch應用
和iOS應用進行更新
這樣一來你可以將CloudKit想成一個代替
watch連接性框架的選項
CloudKit有一個亮點
就是獨立功能性
CloudKit使用NSURLsession
我們的網絡連接使用最好的可用界面
如果你的watch是連接到iOS設備
我們會將通過iOS設備通信
但是watch同時也可以直接與CloudKit服務器對話
只要有Wi-Fi
現在我們來展示完整版本的CloudKit API
引進了CloudKit作爲watchOS的本地框架
你就可以寫出差不多的使用CloudKit的應用代碼
在所有的Apple平臺上
比如Activity應用就使用了它
寫出CloudKit相似代碼用於iOS和watchOS
來開展活動“分享明天”
注意我說的是相似代碼不是一樣的代碼
當你編寫代碼並部署給各種Apple平臺
你要記住每個平臺的優勢和限制
也就是說有時你會打破資源的上限
你必須要時刻記得CPU的特性
存儲空間
網絡特點比如延遲和吞吐量
你可以用這些決定與服務器對話的頻率
以及想要傳送的數據量
同樣 測試仍是最好的辦法來調整你的應用去適應平臺
保證用戶能獲得最佳的體驗
現在我來換個話題講講Telemetry
Telemetry是一個新功能
讓你可以形象化
CloudKit應用的運行情況
Telemetry表現爲
一系列圖表 可見於CloudKit Dashboard
你可以通過它們看到你在公用數據庫中的行爲
或者是你在不同的用戶個人數據庫裏行爲的集合
你可以觀察這些圖表
這樣就能瞭解每時每天每週每月的數據
你可以選擇查看整個應用
也可以集中觀察某一種操作
那現在就看看它長什麼樣
這就是CloudKit Dashboard你可能很熟悉
我請你們看看左下角這個新的UI元素
性能標籤
當你選擇性能標籤
你可以訪問一系列圖表
告訴你你的客戶都在做什麼
它們分兩類
第一個是性能圖表示的信息有
每秒的操作量
以及你的請求的平均大小
你可以通過觀察它想象公用或個人數據庫中的數據
在不同時段的情況
也可根據不同操作類型觀察
現在顯示的這個圖我們叫做正確性圖表
我要你們注意的是客戶端錯誤
它告訴你你發出的請求中有百分之多少
導致了客戶端錯誤
那麼 客戶端錯誤
是一種錯誤的子集是CKOperation可能會產生的報錯
正是這個子集
才使你的應用能解決錯誤並採取行動
比如你可能要保存一個記錄
但是服務器上有一個與之衝突的記錄改變
又或者你試圖獲取更改
從一個記錄區但服務器不知道
這兩種情況都會認作客戶端錯誤從而顯示在這張圖裏
通過形象化你的錯誤趨勢
我們希望你可以利用它來發現
客戶發現異常頻繁的錯誤數量的情況
我們之前說過
錯誤處理很重要特別是對CloudKit支持的應用
區別能正確處理錯誤的應用
和不能正確處理錯誤的應用
就在於區別功能性應用和非功能性應用
重要的是它是編寫基於CloudKit的應用的一部分
所以我們希望你能好好用這些圖
來發現你需要檢查的地方
看看你的客戶是如何處理錯誤的
要了解更多如何處理錯誤的知識
我推薦你們參加明天的一個演講CloudKit的最佳操作
我們會拿出一部分時間深入探討正確的錯誤處理
接下來我要說說API的一些改進
這些都是上屆 WWDC後新出的
實際上我要講四點希望你們能仔細聽
首先是長時間操作
長時間操作是一個機制讓你不需要重複
你已經對服務器完成的工作
所以按照現在的情況應用關閉 操作就停止
所有它執行的未完成操作也會關閉
即使這個操作馬上就能完成了
通過延長你的操作時長
操作的時長可以超過應用的生存期
它們會繼續運行CloudKit也會繼續緩存
本地緩存服務器的反饋
當應用再次運行的時候操作又繼續運行
那麼我們只要返回給你本地緩存中的緩存就可以
在很多情況下這個可以完全消除
網絡連接再一次往返
關於創時間操作的更多細節我們明天再討論
最佳操作 9點歡迎你來參與
下一個我想講的話題是從我們的開發者那裏聽來的
是關於不良連接下CKOperation的行爲
我想爲你們描述的場景是我們有一臺設備
設備的網絡假設可用
但是我們收不到任何流量兩個方向都沒有
另外提一下你實際可以模擬這個場景
通過使用網絡連接調節器
這是一個很棒的開發者工具可以模擬類似的情況
現在 CKOperation是NS操作的子類
因此它有QualityOfService屬性
如果操作被標記爲用戶互動或用戶發起
那麼在不良網絡環境下
我們會在1分鐘後停止並給出連接超時的報錯
如果你的操作有任意一個其他的QualityOfServices
我們會繼續嘗試最多七天
這大概不是你理想的狀態
另外 如果你選擇不設置
一個明確的QualityOfService在你的CKOperation中
我們會幫你選一個就是utility
所以如果都算上很多開發者報告說
“都5天了怎麼我的操作還沒完成”
所以我們要解決這個問題
解決辦法是兩個新的API
第一個用來解決網絡無活動
我們視它爲CKOperation的TimeoutIntervalForRequest屬性
默認爲1分鐘
這個時間是我們等待封裝傳送的時間
如果在這段時間內我們沒有看到任何流量進出
我們會停止操作並告訴你網絡連接超時
我們還會設置一個端到端超時
表現爲CKOperation的timeoutIntervalForResource屬性
這個默認時長爲7天這一段時間是用來
等待整個網絡往返一次
也就是從你的設備到服務器然後再返回
我要提醒大家一個CKOperation可能發出多個網絡請求
去完成它的任務
因此一個CKOperation所需時間會超過你的預期
只要有所進展能傳遞就可以
下面來講講如何有效地獲取
一系列記錄更改
當服務器裏有很多記錄區的時候
我們在研究分享功能的時候發現客戶會看到更多的記錄區
比你過去見過的要多
以前你的解決方法是
從數據庫中截取一整列記錄區
通過使用CKFetchRecordZonesOperation
但是這會產生幾個問題
我們不想輪詢也不想去截取
一整列記錄區然後從服務器上下載
所以我們不再建議使用這種方法
我們用兩個新的概念代替了它
第一 CKDatabaseSubscription
這個新類型可以被激發
當數據庫裏出現任何更改的時候
即便是在一個你不曾瞭解的記錄區
第二個就是CKFetchDatabaseChanges操作
這是一種操作讓你可以請求服務器
給出一列記錄區裏麪包含了未完成更改
從過去的某個節點開始
那麼現在你有了一列記錄區你想從中截取更改
如何做到呢？
以前的方法是發出CKFetchRecordChanges操作
傳遞單一記錄區從這個區裏獲取更改
我們不想讓你逐個枚舉所有的記錄區
所以我們立刻棄用了這個操作
取而代之的是一個全新的操作名字聽上去差不多
CKFetchRecordZoneChangesOperation
它實際上是個批次接口覆蓋了以前的操作
讓你可以
從多個記錄區獲取記錄更改信息
只要一個網絡往返就能完成
那麼我們就來切實看一下
這是一個數據庫幾個記錄區
每個記錄區都有一系列記錄
而客戶更新過了所有更改
現在又出現了幾個新記錄
你的客戶由於已經存了CKDatabaseSubscription
會造成服務器生成推送併發給客戶
然後 使用CKFetchDatabaseChangesOperation
你可以向服務器請求一列包含未完成更改的記錄區
這個例子裏就是第一個和第三個
有了這個記錄區列表
你可以發起CKFetchRecordZoneChangesOperation
請求所有的記錄和所有更改的記錄區
完成在一個網絡往返中
最後我要講講如何快速的獲取更改
在多個記錄存在一個服務器的記錄區的情況下
如果你以前用過CloudKit獲取記錄
那你會比較熟悉moreComing標識
它定義在CKFetchRecordChangesOperation
用來告訴你這裏不僅有我們給你的更改
服務器上還有更多你能獲取的更改
需要隨後發起CKFetchRecordChangesOperation
這個方法有幾個問題
第一就是我們已經發出了檢查標識的邏輯
並且發起了另一個操作對所有其他客戶
這有可能再次失敗
第二就是在你考慮要不要獲取並尾接新的操作
通過尾接指令的時候
CloudKit是空閒狀態
我們想把兩個問題都解決
所以我們利用了我們創建的全新操作
CKFetchRecordChangesOperation來改變這個模型
不再是我們告訴你這裏有更多可用的更改
而是你告訴我們
你想通過新的fetchAllChanges屬性做什麼
它的定義爲真時
CloudKit會從服務器獲取一批更改
交給我們的客戶
然後立刻返回服務器獲取下一批更改
這就讓運轉持續進行
一邊開始拉取網絡數據一邊是你的處理進程
我們認爲這應該是個常見的行爲
所以將它設定爲這一新類的默認行爲
因此 新的CKFetchRecordZoneChangesOperation
默認的是獲取整個記錄
從指定的記錄區
你可能會想如果你有了一個大記錄區
比如說服務器上用戶的iCloud Photo Library
這就意味着後續的操作就要獲取記錄區中的所有記錄
需要很長一段時間完成
所以我們想能迅速恢復
如果操作中途失敗的話
我們不想重新下載已經從服務器上獲取的批
因此我們給這個新類添加了新的回調
RecordZoneChangeTokensUpdatedBlock
在給出一批更改之後
我們會告訴你一個最新的服務器更改token
那麼你寫的代碼要做到兩件事
首先你要commit
每個你從服務器獲得的記錄的更改
第二要緩存這個服務器token
如果操作在未來某個節點失敗了
你可以發起一個新的CKFetchRecordZoneChangesOperation
傳遞給已經本地緩存好的服務器token
然後直接從斷掉的地方繼續操作
不需要重新下載已經從服務器下載過的批數據
這4個API的改進功能是我們希望你們能好好利用的
如果你正在編寫基於CloudKit的應用
接下來 我要換一個話題了
讓我們有請Jacob Farkas上臺來爲我們講解Sharing UI
SHARING UI你和我的分享空間
謝謝你 Paul
我是Jacob Farkas是CloudKit小組的工程師
今天我要講的是
如何將CloudKit分享界面添加到你的應用中
而且只需要寫幾行代碼
我們已介紹了CloudKit新類型就是CKShare
這是CKRecord的子類
它負責存儲兩種重要的信息
第一 分享的信息
第二 分享給誰
那麼我們來看個例子
這是個人數據庫
這裏有一個備註在個人數據庫裏
我們想分享它
因此 我們要創建CKShare
並把那個記錄作爲root record（根記錄）來對它初始化
創建Share必須使用根記錄
所以Share裏必須有內容
接下來我們要保存這個Share和根記錄
要同時存到服務器
這麼做是因爲CKRecord有一個新屬性
就是我們正在創建的Share的一個引用
通過同時保存根記錄和Share
這個引用會與你剛剛創建的Share聯繫起來
我們不僅要定義分享什麼
也需要定義分享給誰
因此我們在CloudKit裏創建了新的lookup服務
這個lookup服務會利用一個電子郵箱
然後轉給一個CKShare使用者
你可在Share上設置這個Share使用者
將Share存到服務器
現在他的iCloud賬戶就可以訪問Share了
我們也支持通過電話號碼尋找用戶
或者通過CloudKit用戶記錄ID
現在我們希望用戶可以控制他們分享數據庫裏的動態
不想讓這些記錄反覆不停地出現
用戶需要能控制它這樣才能
接受這個Share並加入它
這就是說我們需要一個方法去告訴其他用戶
我們分享了東西給他們並邀請他們
並且告訴他們需要加入
這個就是通過URL來實現
每一個分享都帶一個URL作爲它唯一的身份
如果用戶在iOS按一下這個URL或者macOS上點擊它
接受UI會顯示出來
詢問他們是否要加入這個Share
如果是 會跳轉到應用
他們會看到這個Share的內容
URL最好的一點就是如果用戶使用比較老的平臺
或者是不支持分享的平臺
它會轉到iCloud.com
這樣我們也能讓他們看到Share的內容
告訴他們如何接受並加入這個Share
那麼就把這個URL放進電子郵件
然後發送給我們邀請的其他參與者
他們會收到這封郵件 點擊它
然後在他們的分享數據庫裏
就可看到這個Share和Note是我們創建並分享給他們的
這裏最精彩的就是這個分享數據庫
實際上是個視圖可以看到用戶的個人數據庫
所以 如果另一個用戶有權限訪問Share
並且更新了這個Note
我們會看到同樣的更改出現在我們的個人數據庫中
那麼我們來看一看UI裏這個是什麼樣子
好 我們做了Note並添加了分享
平臺是macOS X Sierra
通過使用我們今天發佈的CloudKit分享API
就會看到一個新的Share AddPerson按鈕出現在上方
點擊它
會收到一個新的菜單選擇如何分享URL
當我們點擊分享
系統UI會調令Notes...
告訴Notes要存下這個Share
以及根記錄給服務器
一旦成功系統UI會跳出一個寫郵件的窗口
這裏可以邀請其他用戶
點擊發送
系統UI就會將這個Share存到服務器
尋找參與者
然後再把郵件轉發給其他用戶
那麼換到iPad看看這裏另一個用戶
我們看到了剛發出去的郵件
我們可以點這個URL
然後會詢問我們是否要加入這個Share
如果選是我們會直接跳轉到Notes
Share會顯示Note開始下載
現在我們就把這個Note分享給其他用戶了
如果對Note進行更改在發起人的界面
比如說我取消選擇列表上的牛油果
添加青檸爲另外要買的東西
我們會看到分享給我們的note也變了
那麼現在看看背後的代碼
你們現在可能已經很熟悉CloudKit框架了
也就是CKRecord和新的CKShare目標存在的地方
如果要使用新的系統分享UI
你可以在macOS下的AppKit裏
和iOS下的UIKit裏找到
首先我們來看iOS分享API
在調出UI之前當然要先創建一個Share
我們就用這個根記錄創建Share
我們會設置幾個屬性讓UI顯示這個Share
標題和縮略圖
然後我們接着創建UI雲分享控制器
我們用剛建的Share對它初始化然後傳遞給他一個準備處理器
這個準備處理器會被調出
當要把這個分享記錄保存到服務器時
這個處理器會創建一個CKModifyRecordsOperation
保存記錄和Share到服務器
完成之後就會調出完成處理器
下面我們就要設置一個屬性給這個UI雲分享控制器
其中一個屬性就是available permissions
我們可以選擇是隻公開分享這個Share
還是隻給參與者讀或寫的許可
我們還要設置presentation controller源視圖
讓添加朋友的彈窗出現在我們點擊按鈕的地方
我們定義自己爲代理
這樣我們就可以收到UI活動的返回
最後調出Present這時
跳出一個這樣的彈窗
這時 如果你已經保存了這個Share到服務器
就可以只用Share調出UI雲分享控制器
然後它會顯示一個被邀請用戶的列表
讓他們管理Share上的用戶
也可以按他們的意願停止分享
所有的事情系統UI都爲你考慮好了
macOS分享API跟這個十分相似
所以我們就快速過一下着重講一下不同之處
首先創建一個NSItem provider
用它註冊CloudKit Share
這個處理器看上去跟我們之前看到的一樣
你要把記錄裏的Share保存到服務器
完成後 調出完成處理器
接下來你要創建一個NSSharingService
這個分享服務的代理就是你自己
然後調出perform
通過剛剛創建的NSItem provider
最後 NSSharingService可以回調
所以 如果你設置Share的可操作選項
你就要回調Share選項
macOS上Share創建的UI是這個樣子
如果要在Share上修改參與者界面是這樣
如果一個用戶接受你的應用的分享
你的應用就會發布
然後收到這個回調ApplicationuserAcceptedCloudKitShare
回調中包含Share元數據是根記錄中的Share
是用戶剛剛同意的
這個iOS的操作很像
除了用的是UIApplication而非NSApplication
最後 你要告訴系統你的應用支持CloudKit分享
這要通過CKSharingSupported key實現
就在info P list裏
我們還要高興地宣佈我們已經把完全分享支持添加到了
CloudKit JavaScript庫
這樣只要你在網上就可以創建和接受Share
而且我們已經提供了一些UI讓你可以用來管理Share
你現在就可以在CloudKit目錄裏試試看
現在我要將舞臺轉交給我的同事Vanessa
她會爲你們深入講解分享
謝謝你 Jacob
嗨 下午好
我叫Vanessa Hong
我是CloudKit服務器小組的工程師
今天我們要深入瞭解分享通過展示一些常見的使用場景
首先從被分享的數據講起吧
之後我們會逐步深入
講解CKShare對象中的internal
之後我們講講如何調出分享API
如果你想創建自定義的UI的話
最後結尾講一些特別需要注意的事項
現在就開始吧
Jacob展示了如何分享一個單一記錄
但是用戶想分享的有時不只是一個單一的記錄
可能是很多記錄
可能已經連接了CKReferences
但是你的應用只想讓參與者看到這個記錄的一部分
這就是爲什麼我們要在CKRecord上引進新的域
叫Parent Reference
設置Parent Reference
可以在任何你想在包含於分享結構層的記錄上
這個設置甚至可以在用戶決定分享之前完成
當用戶確實要分享
你可以只用根記錄創建CKShare
之後所有產生的記錄
都會通過Parent Reference鏈接到這個根記錄
並且自動存入分享結構層
那麼來看看在分享數據庫裏是什麼樣子
一個分享數據庫只是一個視圖可以看到用戶的個人數據庫
所以它不包含任何具體的記錄
當一個參與者接受了一個Share他們只能看到分享給他們的內容
所以他們看到是分享的那個層次
也就是說這些記錄沒有複製
只有一套數據並存在所有者的個人數據庫中
也就是說所有者和所有的參與者
都通過同一套記錄互動
這種爭用最後可能會導致衝突
要學習如何處理衝突
我推薦你們
2014年 WWDC的一場“高級CloudKit”演講
現在 可讀/寫參與者就可以修改 刪除和添加記錄了
但是我們又不想讓他們隨意添加東西
到別人的數據庫裏
比如他們不能隨意添加根記錄
也不能添加沒有Parent Reference的記錄
即便是它能連接到分享結構層
所以要通過分享數據庫正確的添加新紀錄
就要設置Parent Reference並連接到分享結構層
這樣即便你添加新的記錄給參與者
通過分享數據庫
新的記錄只存在所有者個人數據庫裏
這就意味着
所有參與者添加的記錄都不計入所有者的配額
因此創建的份額不受影響開發者的份額也不受影響
所有者的個人數據庫是唯一保存這些記錄的地方
所以我們只能讓他們不影響所有者的份額
這就是如何分享多個記錄
我們來近距離研究下分享數據庫
這裏我們有兩個Share來自兩個不同的所有者
但是兩個Shares名字一樣那怎麼區分？
我們忽略了一個十分重要的細節
就是所有CloudKit的記錄都存在記錄區裏
而這個區是由CKRecordZone ID定義的
這個區的名字
是你創建的自定義的區的名字
其所有者的個人數據庫中
所有者的名字就是所有者的用戶記錄名字
這個例子中的兩個區 有同樣的名字但是屬於不同的所有者
假設第一個所有者分享了一些東西但是在不同的區
那麼當你調出FetchDatabaseChanges API時
這個新的區會出現
之後當你調出FetchRecordZoneChanges
你會看到新的記錄和Share
假設第二個所有者分享的東西在現有的區裏
這個區已經存在所以不需要再建新的
我們只要再利用
當調出FetchChanges API時
你會看到這個區發生了變化新的記錄出現了
這就是我們的分享數據庫
那麼再深入一層看看CKShare對象
在所有者創建Share之前得有要分享的東西
因此 記錄代表了Share的內容
CKShare代表瞭如何分享
我們要講的是如何分享
就像Jacob說的
每個CKShare都是一個CKRecord但有附加屬性
我們之前講過了這些屬性如何應用於Share的生存期
所以如果重頭開始所有者就要創建一個Share
還要決定Share的publicPermission如何
這個例子裏所有者決定是none
因爲他想要邀請參與者
假設他邀請了兩個參與者
他們的狀態是自動接受邀請
之後所有者就要考慮給每個邀請者什麼樣的權限
然後所有者保存Share後就會收到Share的URL
這裏會發生兩件事
第一是這個Share有一個聲明
聲明說
只有兩個參與者可以接受這個Share
所有者是唯一知道該URL的人
只有他能將這個URL告訴其他人
所以即使他把這個URL告訴了100個人
還是隻有兩個人可以接受這個Share
當一個參與者通過URL接受了這個Share
接受之後他們的接受狀態就會變成已接受
然後Share的權限就是所有者給予他們的權限
假設所有者想要創建一個更加開放的分享
就讓我們重頭開始
所有者設立一個Share
將公用權限設置爲只讀或者是可讀/寫
他沒有邀請任何人只是保存這個Share
之後他獲得了這個分享的URL
這時仍然有兩件事會發生
第一是Share有一個聲明說任何人都可以參加
所有者還是唯一知道URL的人
他負責告訴其他人
假如他告訴了100個人那麼所有這100個人都能參加
他們也要通過這個URL參加
然後出現在Share裏的參與者狀態變爲已接受
他們的權限來自於Share的publicPermissionfield
這就是你如何創立一個分享和接受一個分享
Share的第二個階段就是當參與者退出時
當然參與者可以退出分享
通過刪除分享數據庫裏的CKShare對象
這同時會刪除分享數據庫裏的分享記錄
要明確的是CKShare仍然存在
它在所有者的個人數據庫裏
只是這個參與者
不再出現在Share裏也不再是被邀請的狀態
但是所有者對他的Share有完全掌控
他可以刪除任何一個人
假設他想把所有人都刪了
他就要刪除CKShared對象
從他的個人數據庫裏清除
這會刪除Share根記錄的pointer
這時所有者就回到初始狀態就是未分享狀態
接着我們來講講CKShareParticipant對象
如果你見過這個對象在生存期開始之前
你會看到接受狀態和許可
但是現在看一看UserIdentity類
這有lookupInfo
是指參與者是如何被邀請到Share的
所以這裏會有他們的郵箱電話或者用戶記錄ID
名字分爲姓和名
它會在參與者接受這個Share的時候彈出
每個CKShareParticipant會分到一個iCloud賬戶
那麼假設所有者邀請了4個人
我們能找到前兩個人的iCloud賬戶
但是後兩個人沒有
但是這沒什麼問題
CloudKit會創建一個臨時佔位符
給第三個和第四個人
而且只有第3和第4個參與者
需要證明
他們持有的郵箱地址和電話號碼
是所有者邀請他們時提供的這就是驗證過程
這個過程會將郵箱或者電話與賬戶聯繫在一起
這樣就不需要再走一遍驗證過程
這就是我們現在在分享中的所有對象
那麼接下來我們聊聊分享API
如果你想創建自定義UI
你可以調出我們的API有兩種方法
代表所有者你可以幫他們設立一個Share
代表參與者你可以幫他們接受一個Share
watchOS和tvOS沒有內置的系統UI
所以你可以讓你的用戶
用另一個平臺建立和接受一個Share
之後這個Share的數據在所有平臺上就都可用了
或者你也可以調出我們的分享API
你要這麼做
代表所有者你要幫他們添加參與者
你需要尋找他們通過郵件 電話或者用戶記錄ID
然後轉換成CKShareParticipant對象
一旦獲得了CKShareParticipant對象
就要添加到分享裏
然後調出CKModifyRecordsOperation來保存這個分享
現在你的應用就獲得了這個分享的URL
當然你可以決定是應用還是所有者
來把這個URL告訴別人
當一個參與者接受一個分享第一步都是從URL開始
首先要將URL轉換成CKShareMetadata對象
然後將這個元數據傳遞給CKAcceptSharesOperation
現在 參與者就會顯示在分享中並且是已接受的狀態
這個已接受的API也有一些限制
從隱私角度來說我們無法返回他們的姓名組件
那麼驗證程序不可用
如果你收到這個報錯
或者iCloud賬戶的Boolean爲假
那麼你要讓你的用戶親自打開這個URL
這樣可以觸發系統或者網絡
讓他們通過驗證過程
以上就是分享API
現在我們再來說說你的用戶
應用的用戶可以邀請任何他們想邀請的人
通過郵件或者電話
這就意味着
應用的潛在用戶要遠遠多於現在的用戶羣
這些被邀請人可能沒有安裝最新的操作系統
他們甚至可能沒有Apple的產品
所以當他們點擊這個URL我們會把他們轉到網頁
以Notes爲例這就是他們看到的畫面
他們會被要求加入分享然後他們就可以看到分享的內容
他們可以與這個Note互動就像在設備上一樣
但是這是個Note網頁應用存在於iCloud.com
你的應用如何呢？
默認的情況下你的用戶會看到這樣一個界面
這裏有你的應用的圖標並要求你的用戶使用最近使用的設備
這不是最理想的用戶體驗
所以我有一些好消息要告訴你
你可以到CloudKit Dashboard設置一個fallback URL
如果被邀請人點擊了這個分享給他們的URL
我們會把他們重新導向你的fallback URL
我們會在後面添加token代表Share的唯一URL
這樣你就可以立刻讓他們接受share
然後顯示分享的數據
現在我希望你們都等不及要開始分享了
這是最後一點你們要知道的
CKShare是最新的記錄類型
這種類型與CloudKit其他類型一樣
可以在上面創建自定義域你可以運行查詢指令
你也可以第一個在開發環境下創建新記錄
創建的最簡單的方法
就是使用用戶身份登錄開發環境
然後從你的個人數據庫分享點什麼
這樣就會觸發記錄類型的創建
然後去CloudKit Dashboard部署scheme給production
如果不這麼做
那麼用戶在production環境下創建分享時就會出錯
因爲記錄類型還沒成立
這就是最後我要講的
那麼 今天你們瞭解了
CloudKit可用於所有平臺包括watchOS
它也可用於網絡通過CloudKit JS
Telemetry在CloudKitDashboard可用
這是個很好的辦法來視覺化你的應用的行爲
包括錯誤趨勢
API有了很多改進包括長時間操作
QualityOfService還有最新fetch changes APIs
現在你也全面瞭解了我們的新功能 分享
你看到了這個系統UI
你知道了如何創建自定義UI
通過調出我們的分享API
你也看過了所有我們用在分享中的對象
包括分享者的存在週期
我打賭你們回去後會設置這些fallback URL
那麼 感謝你們與我們分享這樣的體驗
我想請大家關注這場演講“CloudKit的最佳操作”
就在明天早上九點
這場演講很精彩讓你瞭解如何能有效率地使用CloudKit
謝謝你們的到來希望你們享受 WWDC 的其他會議