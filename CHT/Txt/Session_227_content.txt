watchOS 3性能架構設計
大家下午好 歡迎來到watchOS 3性能架構設計
我是Tyler McAtee
稍後你會看到我的同事Todd Grooms
今天我們會討論在Apple我們思考性能優化的方法
和我們怎麼樣創建watchOS 3
我們從2-Second任務開始說
它是什麼 它對watchOS 3的設計有什麼幫助和影響
對你的應用架構意味着什麼
我還會討論一下設計策略是怎麼影響性能的
同時展示一個新的詳細分頁API
它可以減少不必要的導航時間
最後 Todd會上臺展示我們如何
利用這些想法並應用到watch股票應用上
我們從2-Second開始
我們專注於這個理念作爲經驗法則
和Apple Watch交互感覺是怎樣的
什麼是2-Second任務
2-Second任務是用戶想要完成操作
或看Apple Watch而學習
這些任務應該在幾秒內完成
這幾秒應該從
開始交互到結束衡量
從用戶擡起手看Apple Watch開始
到他們放下手結束
一些2-Second任務的例子可能是這樣
查看通知 設定定時器或者開始鍛鍊
今天我們會瞭解下
我們對系統做的一些重要變動
解釋這將怎麼影響開發者
思考你的WatchKit應用的性能
完成一個Apple Watch任務的第一個瓶頸
是訪問到相應應用 花費的導航的次數
Apple Watch上打開一個應用最快的方法
是通過點擊一個complication
只鼓勵開發者實現一個complication
如果他們有相關數據去顯示
大多程序 例如信息 郵件和手機並沒有complication
爲了增加Apple Watch的可操縱性
和同時給用戶提供更多選擇去定製化
現在在watchOS 3上應用都有complication
這些啓動complication對於從錶盤上快速訪問
你喜歡的應用是很有用的
對於你的應用我們也鼓勵你去適應這個規則
實現一個complication無論是否有數據顯示
新的watchOS 3中我們爲你帶來了dock
通過按壓側鍵開關用戶可以調用dock
且快速瀏覽所有他們最愛的應用程序
瀏覽這些應用程序是非常快和容易的
我們想要我們的用戶能夠使用這些最愛的應用程序
並且使他們準備好加載好
而不是必須等待
因爲這個應用已開始運行了
在watchOS 3中爲了記錄這些所有的應用程序
一個用戶選擇放在錶盤上或者在他們的dock中
應用將在系統中保持運行或暫停在內存中
這樣當他們和應用程序交互時
他們只需等待恢復 無需重新啓動
但是系統只有固定大小的內存
並且在一個在系統中應用需要成爲一個好的公民
因爲最多可以有10個dock應用5個complications
同時還有系統應用 進程等等
你要記得你僅是龐大生態系統中的一部分
因此你需要儘可能只用你需要的資源
這個系統 因爲生態系統的自然性
我們的系統提高了固定內存數量的上限
一個WatchKit的應用可使用的量
如果應用超出這個限制
我們的系統將會終止應用連哭的機會都不給你
因此內存可以被其他的程序使用
限制不是目的
儘量別用光內存
事實上 它應該遠不及限制
現在在watchOS 3上的限制是30兆字節
每個WatchKit應用程序但這個將來可能會改變
所以有什麼好的技巧控制應用的內存使用？
用合適於watch屏幕尺寸的圖片
這個不僅可以控制內存使用
而且將會有助於提高整體性能
{\an2因爲這讓watch不用做額外去調整圖片大小的工作
用大小合適的數據集不要去下載大量的數據集
如果你只顯示很少的數據在屏幕上
如果你只顯示一個數據對象的屬性
不要下載或保存其他屬性
如果你能控制API下載數據
讓我們看這個簡單的應用
因爲watch將可能顯示
一個更濃縮的信息版本
這將會幫助節省大量的網絡流量
你的watch會處理它
瞬時數據和內存也會減少
最後 重要的是釋放你不再使用的對象
花些時間過一遍你的代碼
並且確定你只保存必需的東西
因爲用戶選擇的應用放在他們的錶盤上
或者在dock中 系統會讓它們保持存活和懸掛在內存中
它們更多的是被恢復而不是被啓動
因爲這個 對於watchOS 3
我們想要集中優化的關鍵是恢復時間
現在應用程序將不經常被恢復
因爲它們將被保存在內存裏但也因爲它們在dock裏
當用戶在dock欄中滑到你的應用
應用會被恢復
當用戶滑過應用應用將會被暫停
這種經常恢復和暫停的行爲
是watchos3中應用典型的方式
理解軟件生命週期中哪一個方法
用來做主要工作
哪一個用來做不重要的工作很重要
來看一下不同的生命週期方法
在watchKit擴展代理會遇到
你的代理中看到的第一個方法是ApplicationDidFinishLaunching
當程序第一次運行時 它將會被調用
並且這是一個不錯的地方來執行應用應用的最終初始化
像其他任務一樣 這隻需要被執行一次
在你的代理中接下來看到的是
applicationDidBecomeActive
只要你的應用在系統中變成活躍應用 這個將會被調用
重新開始任何一個之前被暫停的任務
或者沒有啓動 只要有需要將會刷新用戶界面
一旦應用從活躍變爲非活躍狀態
applicationWillResignActive會被調用
這可能因爲某些類型的臨時中斷而發生
例如一個打進來的電話或者通知
當用戶按下側鍵來喚醒dock時
或者當用戶退出你的應用時
並且它將會過渡到後臺運行狀態
當你的應用不再活躍並且被調到後臺
applicationDidEnterBackground將被調用
當你的應用返回到前臺時
applicationWillEnterForeground將會被調用
這些函數只有在程序從後臺到前臺時纔會被調用
或者當程序從前臺到後臺所以在程序第一次啓動時不會被調用
另外 有些生命週期方法和接口控制器相關聯
AwakeWithContext會被調用
在你的接口控制器第一次實例化的時候
這是一個好位置對那些只需要做一次的工作
當界面激活時willActivate將被調用
或者能夠更新的時候它將會被調用
在界面對於用戶確實可見之前
一旦用戶完全看見界面
didAppear被調用
如果你有在恢復時需要做的工作這些方法是是合適的位置
如果需要做的比較多 你最好
把任務分發到後臺的隊列
這樣這些方法可以完成並且你的應用能夠完成恢復
一旦你的應用暫停了
在接口控制器中willDisappear將被調用
當用戶界面不再對用戶可見時
或者用戶界面無效並且不再更新
didDeactivate將會被調用
這些方法是取消任何繁重任務的地方
你在willActivate和didAppear中啓動的任務
理解這個生命週期非常重要
並且明白這些方法可能被重複頻繁的調用
我想通過一個例子
一個程序是怎樣遇到這些事件在它的生命週期中
我們將會從一個程序開始爲了這次課程的目的
程序在前臺和後臺都沒有運行
當用戶點擊你的應用
第一個方法將進入到WatchKit擴展代理中
didFinishLaunching和didBecomeActive
還有接口控制器將會接收到awakeWithContext
willActivate和didAppear
現在你的應用正在前臺運行並且是活躍的
但是當用戶按下側鍵開關調出dock時會發生什麼呢
此時你的應用不再是前臺活躍的應用
這是系統應用
所以你的代理將會調用applicationWillResignActive
當用戶繼續選定你的應用
程序將會在前臺一直運行一直在被CPU執行
更新用戶界面
一旦用戶滑走你的應用
系統將會懸掛你的應用
所以你的界面控制器將會調用willDisappear和didDeactivate
並且應用的didEnterBackground會被調用
現在這裏你的應用剛進入後臺
因此係統可能喚起你的應用
爲了一個後臺快照任務
瞭解更多這些快照任務看看我們今早的課程
保持你的watch應用持續更新
你的設備接口控制器被willActivate和didAppear激活
在你的代理把機會給handleBackgroundTasks之前
然後你的接口控制器會調用willDisappear和didDeactivate
現在你的應用被完全暫停並且應用將執行它的後臺任務
一旦用戶滑回你的應用
程序將會調用applicationWillEnterForeground
還有willActivate和didAppear
你的應用再次運行同時進入dock的前臺中
直到用戶點進你的應用
你的應用纔會變成前臺中活躍的應用
並且調用applicationDidBecomeActive
從用戶進入到dock時發生了大量的事情
自從用戶滑出應用又滑回應用
這就是爲什麼理解程序的生命週期很重要
就像用戶瀏覽他們的dock
你的應用可能重複頻繁的遇到這些事件
還有什麼其他技巧能縮短恢復時間
你應該用discretion當更新WKInterface對象時
你每次給WKInterface對象設置一個屬性
系統會創造一個信息來發送
將它打包 並且分發到應用進程中UI正在被更新的位置
那可能是臨時的在你的應用上來建立一些方法
更新應用的UI且在每次恢復的時候調用
但是設置每一個屬性需要花費時間
哪怕屬性不會改變
這導致了在應用和擴展間不必要的溝通
僅設置這些屬性是值得的
若屬性變了那你必須這麼做
你需要注意WKInterfaceTable和UITableView的不同
手機有大量的內存來存儲大量的信息
UITableView做了專門的優化
當在這些比較大的數據集上快速滑動時
cells被按需創建當你滑動時會被重新使用
然而用WKInterfaceTable
所有的cells被提前創建並且不會被重新使用
所以watch需要做的工作
和表格的大小呈正相關
由於這個原因控制WKInterfaceTable的大小非常重要
watch不合適這種類型
翻閱數以百計的記錄
事實上 我們發現最好
WKInterfaceTable大小保持20出頭
你的應用應該避免重新加載一個WKInterfaceTable
無論如何
這是一個耗費資源的操作
它可能嘗試重新加載整個表
在恢復或數據集改變時
但若你需要添加或移動一些行
最好用插入和刪除API
我現在想談一些設計方面的
想想適合watch的信息展示方式
好的展示方式對性能也很有幫助
在watchos 3中你應把應用設計成可以掃着看的
dock讓用戶可快速訪問收藏的應用
你的應用可能只會被大體的掃一下
當用戶從一個應用滑到另一個的時候
集中顯示最重要的信息
並儘量清晰的顯示
根據特定的目的來設計可以讓應用變得更利於掃視
watch不是合適的載體
對於瀏覽大量的內容
或者查看複雜的數據繼承
通過僅展示最基礎的信息
同時你會得到更好的性能
由於你展示更少的信息可以節省處理器和內存
同時保持更新時需要更少的網絡請求
最後 導航也很重要
我已經講了很多關於我們如何在系統層面提升導航了
在應用層面考慮這些同樣很重要
爲了幫助實現這些我們引進了一個新的
詳細分頁API
WatchKit應用的一個標準配置是繼承數據視圖
你有一個表格
點擊其中一個單元進入這個項目的詳細
這種設置的問題是
如果你想瀏覽多個項目的詳細
你需要後退好多次
爲了解決這個問題新的詳細分頁API
可以讓我們快速的瀏覽從一個詳細視圖到另一個
通過從屏幕上滑動或者旋轉數字表冠
爲了瞭解在代碼中如何設置這些API
同時學習其他快速交互技術
我們向開發者發佈的
請查閱昨天的“watchOS快速交互技巧”演講
在本次演講中 我想說說這些API
的視圖控制器生命週期
從視圖的性能方面這很重要
所以這裏我們有一個有三個單元的表格紅的 橘黃的 黃的
詳細分頁API觸發segue
從內部表到接口控制器
當你點擊其中的一個單元我們會觸發一個segue
當你點擊這個單元你的主接口控制器
將會調用contextForSegue:withIdentifier:inTable方法
你可以在這裏創建上下文對象傳遞給
詳細視圖控制器和awakeWithContext方法
你的主視圖控制器不會只接到它的調用
你點擊的單元而是表格每一個單元
我們爲每一個詳細視圖控制器都準備了上下文
所以當我們準備上下文的時候
我們可以提前實例化
那樣的話 當用戶點擊第一個的時候
可以在所有的單元間快速的滑動
你的第一個視圖控制器
會是第一個調用awakeWithContext
包括willActivate和didAppear
這個是滑動試圖最有意思的部分
我們讓控制器接近這個選擇的詳細視圖控制器
然後用戶可以滑動到下一個
其他的顏色進入他們的生命週期方法
會一樣調用
他們會首先調用awakeWithContext
然後是willActivate和didDeactivate
如何設置工作很重要
對那些還沒有渲染的視同控制器
不要盲目的啓動耗費CPU的任務
這可能導致CPU處理不過來
如果你有很多表格單元的話
當用戶從一個詳細視圖滑動到另一個的時候
你之前的接口控制器會是第一個調用willDisappear
willActivate didDeactivate和didAppear
這使你的接口控制器維持一致的狀態
那些最近展示到屏幕上的調用didAppear
那些最近離開屏幕的調用didDeactivate
當你點擊後退
回到主控制界面 只有一個控制器
需要用生命週期方法調用它並且它是可視的
應用調用willDisappear和didDeactivate
當然 我想要邀請Todd去談論這些
我們如何應用這些想法到我們的Stocks WatchKit應用
謝謝
下午好
我是一個watch OS的工程師
我們把Stocks作爲一個案例研究面向WatchKit和開發者
你們中大多數可能不知道這個
但Stocks是用WatchKit建立的watch應用
在Apple我們想要有第一手的經驗
在WatchKit開發中我們感覺Stocks
將會是WatchKit開發中一個很棒的應用方案
今天我有三個想要討論的主題
關於Stocks和WatchKit開發
我將要去分辨Stocks中的2-Second任務
之後我將要討論一些實現的細節
在我們的後臺刷新用例中
最後 我將要說一些關於我們做的優化
通過擴展優化恢復時間啓動時間
因此 我們將從2-Second任務開始
我們思考Stocks時
我們想到三個重要的2-Second任務
第一個是你很可能喜歡想要看的
一個最愛的股票現在的價格是如何的
這可以用一個complication實現
但是在dock
我們能夠得到一點2-Second任務的細節
特別地 我想到另一個2-Second任務
想看看你最愛的股票的流通表現
通過日線圖
最後 我們認爲很重要的是 你能看見
一些股票的當前價格
我們從complication說起
當然 complication是最快的
在你的watch上察看數據的方法
數據總是最新的
你每次從watch上看時間也能看到它們
這裏最重要的一點在watchOS 3中
是數據在complication和應用之間是同步的
想要了解更多的信息
可以去看看“讓你的Watch應用保持更新”的演講
今天早上開始的這個課程
現在我們將要開始討論
一些其他的2-Second任務是如何在watchOS 2表現的
所以在watchOS 2中你可以啓動Stocks
並且你可以看到現在的股票價格
你感興趣的或者其他的股票
如果你想看到其他其他的股票在一天中的表現情況
你需要點一下那個股票現在你可以看見了
這是一點小信息但是它還是沒有回答
一天股票價格是怎麼被展示的
所以 如果你想知道
你得向下滾動一點現在你在圖表上了
我們有四個選項 關於這個列表我們有一天的間隔
一週 一個月 半年
你第一次可能滾動到這裏
你甚至不能看到你關心的間隔
那可能是一天的間隔
因此這需要你點擊這些小按鈕
並且打開那個圖表
之後
你將從下面獲取其他的元數據
其實大量的時間並不是必要的
當你瞥一眼今天的信息
當然 如果你想看多個股票
他們一天是如何表現的
你得向前瀏覽 點進一個新的去
很像剛剛Tyler在動畫中給你們展示的
讓我們看看watchOS 3
這是新的watchOS 3設計正如你看到的
首先 仍然是一個你們可以進入的列表
但是字體變大了 更易讀了
一點簡化的接口
對我來說很好並且小字體也很容易讀
像你在dock中看的
如果你想看看apple今天怎麼樣
該怎麼操作你會再一次點擊Apple
但現在你在那裏看到了表格
同時我們假設你總是想看日線圖
也有例外 沒有日線圖
像基金沒有日線圖
我們可以回退到一個月的圖表
當我們瀏覽它
這可能是你更期望的一目瞭然的間隔
我們同時去掉了下面分鐘的詳細信息
這讓我們獲得兩個好處
一個是 去掉了一個網絡請求加快了加載性能
第二個是 我們可以使用新的垂直詳細分頁API
那樣的話 你可以瀏覽多個股票
可以通過旋轉數字表冠或者用手指輕掃
當然 如果你想查看股票的詳細信息
像以前的分鐘信息
比如52周最高 52周最低
你可以使用Handoff
通過Handoff
你可以設置一個上下文然後把它轉移到iPhone上
所以我們感覺watch是大體瀏覽數據的地方
iPhone纔是瀏覽 像一個視圖
詳細和複雜的數據的地方
好的是新的設計 像我剛纔說的
在dock上是易讀的
通過dock
我們決定重新評估對於股票我們應該在dock顯示什麼
如果你參加了其他的一些課程
你會注意到有一個理念默認狀態和一個快照
這表示這應該是一個粘性的視圖
粘性的意思是當你離開股票應用時
如果你正在看股票列表
當你回到股票 無論從dock中或者
通過應用進入
你還會看到股票列表
這個視圖我們會持續更新
在這一天中
然而 如果你點擊進入股票詳細
然後返回dock或進入應用
你將會看到詳細視圖
這裏有一個需要注意的地方
在股票中你設置complication股票
你可以看到的股票在你的complication
我們這麼做是這很可能是你喜歡的股票
一旦你設置了它
這將是我們返回給你的詳細視圖
如果你打開股票
你從Apple瀏覽到Facebook
然後回到桌面
差不多一個小時內
當我們返回快照默認狀態標識時
我們會回到Apple的股票
我們這樣做是因爲
你已選擇了它作爲你的complication股票
然後將會是你的收藏股票
這個是我們想要返回給你的
我們有一個可預期的體驗
總是返回用戶期望看到的東西
在過一段時間後
讓我們概括下關於股票我們做了什麼2-Second任務
第一件事是
我們要保證應用和complication間的數據一致性
另一個是
我們簡化了我們的設計
我們在減小大小的同時讓它變得更清晰易讀
更易用
無論何時你通過詳細分頁API垂直滾動
可以快速的讓你查看多個股票
替代以前的來回拖拽
接下來 我們講一下後臺刷新
我會多講一下
我們如何實現股票的後臺刷新
當我們開始實現股票中的後臺刷新
我們需要考慮兩個問題
第一
我們需要一個什麼樣的頻率來更新股票中的信息
第二我們需要獲取什麼樣的數據來更新應用
決定我們應該多久刷新下股票的數據
有一點取巧的意思
首先我們感覺每15分鐘更新一次看起來不錯
這將會使應用在一天中更新好多次
但是其中很多時候的更新都沒有用
像當每天結束或者週末閉盤的時候
讓我們參考下已知的一些事實情況
因爲我們感覺可以更好的實現它
首先 股市只在每天的特定時間開盤
例如 我們訂閱了一個
紐交所的股票
同時我們知道
紐交所在東部時間早上9:30開盤
並且會在東部時間下午4點閉盤
如果我們限制了後臺刷新請求
僅當股市開盤時
我們可以減少更新次數
可以節省出資源給其他應用
同時也會讓我們受益
不用多次更新我們的應用和complication
它會很沒效率
同時這樣也很好
讓我們看一點我們怎麼實現的僞代碼
我們如何判斷何時需要進行下一次刷新
首先 我們會遍歷我們的股票列表
然後我們檢查股市是不是都關閉了
因爲如果我們知道股市都閉盤了
我們想知道股票列表中的下一個最近的開盤時間
不然的話 這表示至少有一個股市是開着的
那我們就需要15分鐘刷新一次了
我們看一點源代碼
首先大家需要注意
一個函數 我們在股票應用中用來
在後臺定時刷新
在特定的時間裏
我們用的是WKExtension中的scheduleBackgroundRefresh方法
我們會傳入preferredDate
這個preferredDate是在應用中的其他地方計算的
代表我們的後臺計劃刷新時間
我們從最後往前看一下
我們看看在nextPreferredRefreshDate裏有什麼
這個函數的開始有個guard
我們會調用earliestNextOpenDateInStocks
如果返回nil
我們繼續往前
因爲在earliestNextOpenDateInStocks中
如果列表中沒有股票我們會返回nil
因爲這時候 做後臺刷新沒有用
因爲沒有數據刷新
我們接着往下並且計算下一個nextRegularRefreshDate
剛好是更新頻率 每15分鐘一次
最後我們在這裏檢查
所以 我們用earliestNextOpenDateInStocks
我們會和nextRegularRefreshDate做時間比較
現在我們的earliestNextOpenDateInStocks
也會多了一個返回distantPast
如果我們的任何一支股票正在開盤
這段代碼中後面的時間會一直是固定的刷新時間
我們看看earliestNextOpenDateInStocks方法
首先我們將獲取我們的股票列表
然後做檢查
如果這裏還是0我們會退出 返回nil
這時後臺刷新沒有用
然後我們遍歷我們列表中的股票
如果任何其中一個開盤
我們會提前返回distantPast
不然的話我們將檢查
我們會遍歷列表找到earliestNextOpenDate
我的意思是 我想展示一些代碼
因爲我們認爲這是限制後臺刷新
次數的很好的方式不用全部的代碼
我們說說多個後臺請求調度
因爲特別對股票來說
我們需要在兩個地方保持應用數據更新
我們需要在終點A
保持應用數據更新
我們還需要終點B更新complication
所以如果我們計劃後臺刷新時間
我們這麼做
我們一旦收到處理後臺任務
我們會提交終端A的請求提交終端B的請求
我們會計劃我們未來後臺刷新時間
它看起來是什麼樣的好的...
在WKExtension代理中我們有處理後臺任務的方法
我們會遍歷這些後臺任務
我們會首先檢查
是否是一個應用刷新任務
如果是 我們會進行和計劃那些數據更新請求
在那裏我們進行我們的NSURL請求
接着我們會計劃下一次後臺刷新時間
使用nextPreferredRefreshDate
然後我們會完成我們的應用刷新任務
最後一部分大家需要注意的是
這個URL會話後臺刷新任務
你會得到其中的一個
當你觸發一個後臺NSURL會話調用
我們需要把它先存到某個地方
我們會稍後完成它無論請求何時結束
現在我們討論過了它我們看看 它看起來啥樣
當我們觸發那些NSURL請求
在一個高的層級
我們安排那些請求然後當那些請求結束了
我們會計劃一個快照重新加載complication
當我們將要完成我們的後臺刷新任務
第一件事
我們會設置應用數據請求和complication數據請求
然後我們設置我們的完成更新處理函數
現在完成更新處理函數僅僅是
一個我設置的塊無論何時NSURL會話
的完成後臺請求代理方法被調用
我就能調用那個完成更新處理函數
這是那個塊裏面的所有內容
然後我們有一個submitRequest
作用就是開始這個網絡請求
同時調用這個任務的恢復
一旦該任務完成了 我們可從urlSessionTasks裏得到該任務
它是一個字典
我們會計劃快照重新加載complication
我們繼續然後完成那個URL會話任務
最後我要調用的是urlSessionDidFinishEvents
爲了給你展示無論何時你的請求完成了
我們會從會話配置裏得到標識
然後我們請求我們的finishUpdateHandler
這個給你一個線索
如何同時運行多個請求保持你的應用更新
如果你的應用和complication有不同的請求
第一件事明顯是你想優化
調用你應用的更新頻率是多少
當你做後臺刷新時
這是第一目標
如果你從服務器上更新數據
儘量單獨制定的端點如果你能控制的話
如果你不能 它可以
提交多個請求在後臺刷新時
現在我們看下恢復時間優化
當通過擴展你優化你的恢復時間
你將同時會優化你的啓動時間
這很棒
我們說說我們能做什麼
就像Tyler剛纔說的
你可以在willActivate和didAppear時 將任務最小化
你知道做它
避免從willActivate中觸發較長運行時間的任務
我們將會做一個聰明的加載和重新加載數據
當然像他剛纔說的我們最好只設置屬性
屬於接口中改變的元素的
我將會用一個警示開始
這包括實現垂直詳細分頁API
像Tyler剛纔說的
相鄰的詳細分頁的willActivate會被調用
你同時想要避免耗時的操作
在詳細頁面willActivate中
尤其是 在這個視圖裏有一個非常耗時的操作
所以由幾個錯誤報告開始
我們基本上得到的是加載慢的報告
股票視圖加載慢當你第一次進入詳細頁面時
其他詳細頁從來沒有加載他們的圖表
或者是相當慢
現在我們看看代碼
嘗試看看到底發生了什麼
這是一個縮減版的股票接口控制器
你會發現
在willActivate我們調用了downloadAndGenerateChart
基本上NSOperation是一個長時間運行的
並且做很多工作獲取圖表數據繪製圖表
我們能在這個基礎上提高點什麼呢
我們知道didAppear被調用
當視圖控制器可見的時候
對用戶同時被選中
如果我們開始在這裏下載和生成數據表呢
如果你頻繁的滑動會發生什麼
我們不想繼續下載和生成圖表數據
對於已經離開的視圖
我們會調用cancelDownloadAndGenerateChart
它會獲得運行的操作
並取消它
我們看看再一次看看其中的注意事項
因爲我已經知道了這裏的錯誤
想在willActivate避免觸發長時間的運行任務
如果可能 最好使用可取消的操作
做這個NSOperation是一個比較好的模板
我們看看WKInterfaceTable加載
我們知道所有的行被加載到內存
我們知道它提前有個線性的花費
根據你表中的行數
同時不會像UITableView會有重用
我將會展示一個圖一個性能分析
我對這個股票做的
這是初始化啓動時間重啓以後
沒有恢復時間或其他的
重要的是你要注意這裏我們沒有股票在列表中
一個空的股票列表用了5.5秒加載
如果我們添加一個股票進去它會多一點
差不多6.5秒如果加5個股票
稍微多餘6.5秒
如果我們添加10個股票現在開始接近7秒了
如果你有大量的行
在你的表中那會延長
接口控制器的加載時間
我們這裏能做什麼才能降低加載時間
第一我們可以限制加載的行數
我們可以智能的更新我們的表格
當行發生變化 當列表發生變化
我們看看loadTable的初始化部分
我們從manager裏面獲取數據
接着設置表的行數
然後
我們計算每個股票的行控制器
開始看起來沒有問題那裏放生了什麼
股票的數量沒有被限制如果你有20個股票
那將有20行 若有30個會有30行依次往下
我們一直使用一定數量行的集合
如果有一行被添加當使用那一行時
你會擦掉之前有的
然後從頭開始
這很沒有效率
我們看看我們怎麼樣處理讓它變得智能點
我們像之前一樣先獲取股票我們檢查數量
然後我們設置一個最大值
在這個股票例子 爲20
我們接着計算行差異
看他們之間的不同變了多少
然後我們調用insertRemoveTableRows
稍後我們會仔細看看
在下面
我們確定我們沒有做超過必須的過多工作
我們會檢查確認索引
在最大的股票列表大小之內
我們看看insertRemoveTableRows
第一個要做的是計算行變化
然後我檢查股票行變化
如果大於零我們會處理
如果小於零我們需要刪除掉
最重要是
你可以做的更聰明點如果你想
基於列表實際變了多少來更新
但我們發現 因爲性能原因
僅僅做一個在0處插入或刪除
在索引0處看起來工作的不錯
所以我們不要做我們不需要做的工作
概括來說你的股票列表的股票的數量
或者像我的例子 這個股票列表
你的情況中 我不確定你放了什麼進去
但是保持這個數量降低並且控制在
一個合理的數量在你的用例中
下一步 當你插入和移除行時
那將會更有效
比你僅僅調用WKInterfaceTable的設置行數方法
最後一件事不要遍歷整個表
當一行數據更新時
所以這麼想 就像如果我們正在更新Apple股票的價格
在表列表或股票列表
作爲取代遍歷和
更新每一行當我們不必這麼做時
我們可以使用rowController(at index)
這樣我們就可以只更新我們想更新的那一行
或者 你甚至可以做類似存儲一個引用
對於rowController且在稍後更新
我們討論下更新UIElements
Tyler剛纔提到的UIObjects和WatchKit
他們在extension進程中被修改更新這些屬性
需要從extension進程發送到應用進程
app進程處理界面的佈局
我們看看股票的UI只有一個rowController
但我們有個錶盤這裏
對於這行是可點擊的
我們也有一個列表名字就是股票代碼
的公司名 它是個標籤
還有changeInPointsLabel
這就是需要修改的地方
還有價格標籤表示當前價格
我們看看我們需要做什麼
更新rowController時
我們有更新方法
它會接收我們給它的任何值
它會立刻設置那些屬性
現在不好 因爲界面上的對象屬性
沒有被緩存 對麼
設置對象的屬性會每次
都發送值給應用進程我們會減少它
但我想強調它的重要性
一般來說 在我的分析中
在股票中需要花費大約200毫秒把一個值
從extension進程發送到應用進程
看起來時間不長 但是
在有些分析中在初次啓動時
我發現會超過平均值很多
最壞的情況需要1.4秒
從extension進程發送到應用進程
變化很大
我們該如何做才能更智能些
緩存那些已經發送的數據
只在發生變化時發送
我們來概括下恢復時間的討論
我們想盡量減少willActivate裏的工作
在 didAppear 我們想使用
可取消的操作 當可能的時候
你還要注意 過於複雜的用戶界面
會導致更慢的加載時間
所以當數據越多
需要更新到UI上它就可能越慢
當然 我們只想更新我們的用戶界面
在必要的時候 當發生變化時
總結一下 這個股票的案例
希望大家能從這裏開始思考關於你的應用
保證你的任務小和簡單
簡化你的用戶界面
使用新的後臺刷新API
集中在應用的恢復時間
我們需要多注意WKInterfaceController生命週期方法
尤其是willActivate和didAppear
充分利用可取消的操作
在你更新UI時要做優化
不要發送冗餘的信息
想要了解更多你可以訪問開發者網站
我們的演講編號是227
一些相關的演講 不幸的是已經開始了
其中一些我感覺很重要
不僅是WatchKit開發我們也有併發編程
Swift 3中的GCD所以也同樣重要
謝謝祝大家本週接下來的日子過得愉快