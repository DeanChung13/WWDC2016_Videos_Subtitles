00:00:20.320 --> 00:00:22.589
最大限度利用Search APIS

00:00:22.656 --> 00:00:25.993
新特性和更新扩展搜索能力
演讲223

00:00:29.229 --> 00:00:32.131
欢迎各位 我是
Vipul Ved Prakash

00:00:32.198 --> 00:00:35.002
我在Apple从事
Siri和Search的开发

00:00:35.302 --> 00:00:38.138
今天 我将和同事
John Hornkvist

00:00:38.338 --> 00:00:40.507
展示
Search APIs的新特性

00:00:40.574 --> 00:00:42.176
以及该如何最大限度地利用

00:00:42.776 --> 00:00:47.347
众所周知 Spotlight逐渐
成为了一个更强大的搜索工具

00:00:47.481 --> 00:00:49.316
在最近发行的一些iOS版本里

00:00:49.883 --> 00:00:53.787
在iOS 8里
我们加入了查询网络资源的功能

00:00:53.854 --> 00:00:56.456
例如App Store
Maps和Wikipedia

00:00:57.291 --> 00:01:01.028
之后 在iOS 9里
我们大幅扩大了范围

00:01:01.094 --> 00:01:06.099
加入了资源 像音乐 货币换算
实时体育赛事得分

00:01:06.166 --> 00:01:08.135
网页 还有很多很多

00:01:08.569 --> 00:01:12.773
或许 最主要的是
我们加入了简单且强大的方式

00:01:13.040 --> 00:01:16.310
能让我们使你们应用的内容
在Spotlight被搜索

00:01:16.510 --> 00:01:22.082
在iOS 10里 今天我们要宣布
这些Search APIs的扩展

00:01:22.149 --> 00:01:25.319
这将能让你们对应用的内容进行
更深层次的搜索

00:01:25.752 --> 00:01:30.057
我们也简化了Spotlight使用
也让它更容易被找到

00:01:30.123 --> 00:01:33.927
那让我们从看一些例子开始

00:01:33.994 --> 00:01:36.129
关于我们对Spotlight的改动

00:01:37.998 --> 00:01:40.701
Spotlight现可在
Notification Center里找到

00:01:40.868 --> 00:01:42.903
这使它可以被更快捷地打开

00:01:44.571 --> 00:01:45.806
让我们在这里看个例子

00:01:45.873 --> 00:01:48.442
用户收到了一条包含问题的信息

00:01:49.443 --> 00:01:51.345
这是经常有的事

00:01:51.612 --> 00:01:53.714
那他们想要查询并回复

00:01:54.014 --> 00:01:58.952
不用退出messages 来到
主屏幕 下拉出Spotlight

00:01:59.052 --> 00:02:02.122
他们只需下拉出Spotlight
盖过messages

00:02:03.423 --> 00:02:06.994
进行查询 然后找到答案

00:02:08.461 --> 00:02:09.830
十分好用

00:02:12.165 --> 00:02:15.169
我们也在锁定屏幕
添加了Spotlight

00:02:15.402 --> 00:02:17.538
也添加了对快速预览结果的支持

00:02:17.604 --> 00:02:19.206
通过使用3D Touch

00:02:19.706 --> 00:02:21.208
让我们来看一下操作

00:02:23.243 --> 00:02:25.546
假设你们在和朋友争论

00:02:25.612 --> 00:02:27.314
Steph Curry在哪出生

00:02:28.182 --> 00:02:29.750
你们可以来到锁定屏幕

00:02:31.251 --> 00:02:32.486
进行搜索

00:02:36.190 --> 00:02:39.393
找到结果 你们现在可用
3D Touch预览这些结果

00:02:44.598 --> 00:02:47.701
找到你们想要的那个
在这里是Wikipedia

00:02:48.535 --> 00:02:49.570
真的很好用

00:02:49.636 --> 00:02:51.371
当然 当你们在锁屏状态时

00:02:51.438 --> 00:02:55.542
我们只显示从网上获取的公开信息

00:02:59.046 --> 00:03:03.016
另外一个我们添加的很酷的功能是
Spotlight查询建议

00:03:03.083 --> 00:03:07.754
它在输入问题关键词的上方
“快速输入”那里

00:03:08.055 --> 00:03:09.256
让我们看个例子

00:03:09.690 --> 00:03:13.093
这里用户查询班桌琴
通过以往的查询 我们知道

00:03:13.160 --> 00:03:18.398
两个常见完整输入是
班卓琴弦和班卓琴调音器

00:03:18.532 --> 00:03:21.668
所以 如果他们所要的结果
不在屏幕上

00:03:21.869 --> 00:03:23.704
他们能从中选一个 找到答案

00:03:23.770 --> 00:03:28.342
这可让许多查询更快
被Spotlight处理

00:03:28.942 --> 00:03:30.277
我们做了许多的改进

00:03:30.644 --> 00:03:32.880
我们改进了自动拼写更正

00:03:32.946 --> 00:03:34.515
为应用开启用例

00:03:34.581 --> 00:03:38.085
我们改进了对中文和日文脚本的支持

00:03:38.852 --> 00:03:40.053
在设备上

00:03:40.120 --> 00:03:42.456
总体来说 我们也提高了相关度

00:03:42.523 --> 00:03:43.991
所有的这些改动

00:03:44.057 --> 00:03:48.128
当然也适用被插入的内容
当使用Search APIs

00:03:49.463 --> 00:03:52.232
现在 让我们将注意转移到
Search APIs

00:03:53.400 --> 00:03:58.839
也许你们记得我们在iOS 9里
加入了三个Search APIs

00:03:59.072 --> 00:04:02.843
有CoreSpotlight
它能让你们添加用户指定的

00:04:02.910 --> 00:04:06.813
或用户创建的Spotlight
设备索引

00:04:07.981 --> 00:04:11.318
我们还加入了NSUserActivity
一个可搜索版本

00:04:11.718 --> 00:04:16.190
它能提供一个简便的途径
索引一切用户

00:04:16.255 --> 00:04:20.194
在你们应用里看过的内容
这样他们就能被快速搜索和找回

00:04:21.128 --> 00:04:24.665
最后 我们加入了
通用链接索引

00:04:24.731 --> 00:04:28.569
这是一个服务器端的索引
有链接组成

00:04:28.635 --> 00:04:31.972
这些链接是我们通过
爬应用网站找到的

00:04:32.272 --> 00:04:34.074
我们的设计让APIs和谐工作

00:04:34.141 --> 00:04:37.878
所以 无论结果来自设备或服务器

00:04:37.945 --> 00:04:42.816
它们看起来都一样
让你们应用的搜索成为无缝体验

00:04:44.918 --> 00:04:46.320
我兴奋地宣布...

00:04:47.154 --> 00:04:50.891
App Store有超过50,000
应用使用Search APIs

00:04:51.625 --> 00:04:52.759
这是十分惊人的

00:04:58.165 --> 00:05:01.869
我想那会是多么酷
看见Search APIs用户

00:05:01.935 --> 00:05:04.137
改善了日常的互动

00:05:04.204 --> 00:05:07.875
在我们的客户和你们应用
还有iOS之间

00:05:07.975 --> 00:05:10.844
我想向你们介绍一些
我最喜欢的案例

00:05:11.812 --> 00:05:12.980
这是一个近期的例子

00:05:13.046 --> 00:05:17.651
我在计划一个这周末去
夏威夷的毛伊岛旅行

00:05:17.718 --> 00:05:21.154
我在过去的一个月里
间歇地计划着这个旅行

00:05:21.688 --> 00:05:25.325
有许多信息像酒店预订和票务

00:05:25.392 --> 00:05:28.462
那些都可以通过我的设备找到
我通常

00:05:28.529 --> 00:05:33.800
使用应用或网站或翻阅邮件来
寻找它们

00:05:34.568 --> 00:05:36.069
但有了Search APIs

00:05:38.071 --> 00:05:39.840
我的经历是这样的

00:05:40.374 --> 00:05:43.277
那个我用来做这些预定的应用

00:05:43.343 --> 00:05:48.115
用CoreSpotlight将主要
信息添到Spotlight的索引

00:05:48.182 --> 00:05:50.817
以至于 我能看见我的机票

00:05:51.118 --> 00:05:53.954
我能看见通过Hotel
Tonight预定的酒店

00:05:54.021 --> 00:05:57.157
和一些通过Open Table
预定的晚餐

00:05:57.758 --> 00:06:00.394
我可以通过触点这些结果
找到更多的信息

00:06:00.460 --> 00:06:02.196
像我签到的时间...

00:06:04.765 --> 00:06:06.767
或是这些餐馆的地址

00:06:11.338 --> 00:06:12.506
你会留意到

00:06:12.906 --> 00:06:15.375
我有些从Pinterest上
搜来的结果

00:06:15.442 --> 00:06:17.177
我有使用Pinterest应用

00:06:17.377 --> 00:06:20.047
来探寻在毛伊岛能做些什么

00:06:20.113 --> 00:06:22.616
Pinterest使用
NSUserActivity

00:06:23.217 --> 00:06:26.153
来为我所在应用里
浏览过的东西建立索引

00:06:28.589 --> 00:06:32.092
我能触点其中一条结果
然后 继续我的探索

00:06:36.196 --> 00:06:41.435
这是一个极好的行程搜索经历

00:06:41.502 --> 00:06:44.371
通过我的设备找到所有
我知道能找到的信息

00:06:44.438 --> 00:06:47.040
以我们的经验 一般来说

00:06:47.374 --> 00:06:52.312
为用户想返回去看的内容建立索引
会是一个明智的选择

00:06:54.047 --> 00:06:56.617
另一个 我想分享的例子是
关于联系方式

00:06:56.683 --> 00:07:01.522
联系方式是最普遍的
Spotlight查询用例之一

00:07:01.622 --> 00:07:03.357
这里 我想搜索好兄弟Allen

00:07:03.423 --> 00:07:07.794
我看见了他的联系方式
是一个iPhone的方式

00:07:07.861 --> 00:07:12.065
我也看到了他的Skype资料和
一些对话

00:07:12.132 --> 00:07:15.369
在我们之间通过Yahoo
Mail和WhatsApp

00:07:15.435 --> 00:07:18.138
我能方便地返回到这些对话里

00:07:21.475 --> 00:07:23.877
这是很有用的 因为
这能提供给我

00:07:23.944 --> 00:07:28.782
对我的联系人有一个全方位的视角

00:07:28.849 --> 00:07:32.886
也能让我通过他们选择的途径交流

00:07:37.925 --> 00:07:42.429
现在我们看过了用户能自然地
应用Spotlight于

00:07:42.496 --> 00:07:45.432
Spotlight能本地支持的
所有事情

00:07:45.966 --> 00:07:48.435
如果你们有上述类型的内容

00:07:48.602 --> 00:07:51.572
利用它会是一个很棒的
扩大搜索范围的方式

00:07:51.638 --> 00:07:54.208
也能让你们的用户对应用更感兴趣

00:07:58.111 --> 00:08:01.448
那现在让我们来看一个
通用链接索引的例子

00:08:01.548 --> 00:08:05.018
wikiHow是一个高质量
关于怎么做的资源

00:08:05.085 --> 00:08:09.189
它有成千上万的关于各种主题的文章

00:08:09.456 --> 00:08:13.093
在这我查询一个重要的急救问题
怎样做心肺复苏

00:08:13.160 --> 00:08:17.998
Spotlight显示了一堆结果
有网页 YouTube

00:08:18.198 --> 00:08:20.767
还有wikiHow上的部分

00:08:22.569 --> 00:08:26.240
wikiHow使用通用链接
并且他们是一款热门应用

00:08:26.306 --> 00:08:29.309
所以我们在服务器上
对他们的文章建立了索引

00:08:29.376 --> 00:08:32.279
我们利用这些索引对应
适当的询问

00:08:33.780 --> 00:08:37.183
这些结果还是十分完整的
点击其中的一条

00:08:37.251 --> 00:08:41.087
我来到了这篇描述清晰的文章

00:08:42.456 --> 00:08:49.196
对wikiHow建立索引赋予了
Spotlight一个全新的功能

00:08:49.263 --> 00:08:52.032
这凸显出了Search APIs
的强大之处

00:08:53.100 --> 00:08:55.402
看过上面的例子 让我们来看下

00:08:55.469 --> 00:08:58.939
Search APIs
在iOS 10上有哪些新特性

00:08:59.573 --> 00:09:05.112
我们加入的第一个功能是
Continue Search in App

00:09:05.546 --> 00:09:07.181
有许多的查询

00:09:07.514 --> 00:09:12.352
用户想见到更多的结果
或你们也许无法添加

00:09:12.419 --> 00:09:15.322
正确的结果至Spotlight
由于各种原因

00:09:16.056 --> 00:09:18.992
那现在应用有了一个选择

00:09:19.059 --> 00:09:22.229
在App Punch Out里查询

00:09:22.362 --> 00:09:28.836
如你们所见 在右上方的角落

00:09:31.138 --> 00:09:38.078
触点这里会将用户与问题一起
带入你们的应用

00:09:38.178 --> 00:09:42.616
这样就可以在应用里继续搜索
很酷

00:09:46.453 --> 00:09:50.324
我们加入的第二个特性是
CoreSpotlight Search API

00:09:50.390 --> 00:09:52.092
这个名字有点冗长 但是

00:09:52.326 --> 00:09:56.430
事实上就是你们能将所有的东西
添加至

00:09:56.496 --> 00:10:01.134
Spotlight的搜索索引
通过CoreSpotlight API

00:10:01.235 --> 00:10:03.837
是不是很棒
如果可以通过这个索引

00:10:03.904 --> 00:10:06.673
支持应用内的搜索？
我认为一定是

00:10:06.740 --> 00:10:10.611
然而这是CoreSpotlight
Search API能让你做到的

00:10:13.146 --> 00:10:14.448
我们加入的第三个功能是

00:10:14.515 --> 00:10:17.351
估计深层链接受欢迎度的一个方式

00:10:17.518 --> 00:10:21.054
通过使用差分隐私
一个在keynote里提过的技术

00:10:21.588 --> 00:10:24.825
我们会对此做更多的讨论
在下面关于排序的讨论里

00:10:26.460 --> 00:10:28.428
最后 在众多的要求下

00:10:28.495 --> 00:10:31.265
我们在web markup
预览工具里加入了一个新特性

00:10:31.632 --> 00:10:34.968
它能让你们看到和检验
架构的结果

00:10:35.269 --> 00:10:38.305
在你们将其加入到
通用链接索引之前

00:10:39.973 --> 00:10:43.377
除此之外 我们还做了许多改进

00:10:43.911 --> 00:10:45.913
对Search APIs
基于你们反馈

00:10:46.613 --> 00:10:50.584
我将邀请John介绍这些APIs

00:10:50.651 --> 00:10:52.719
并更深层地讲述这些新功能

00:10:55.856 --> 00:10:59.860
让我们来探讨一下
如何利用Search APIs

00:11:00.727 --> 00:11:01.962
在下面的半小时里

00:11:02.663 --> 00:11:05.766
我将讲解一些
你们要为应用做的事

00:11:06.166 --> 00:11:07.668
为它能与Spotlight一起工作

00:11:08.268 --> 00:11:11.772
一些为了让你们的用户有个很棒的体验
而应该要做的

00:11:11.939 --> 00:11:13.607
和一些我们加入的新APIs

00:11:13.674 --> 00:11:16.710
为了让你们能更便捷地达到
你们想要的结果

00:11:18.312 --> 00:11:21.415
那大概以你们实现这个的顺序

00:11:21.782 --> 00:11:25.586
我来讲一下
关于如何把你们的内容加入到

00:11:25.652 --> 00:11:28.622
Spotlight的索引
并保持最新

00:11:29.890 --> 00:11:31.525
展示方式和用户体验

00:11:32.860 --> 00:11:36.230
在你们的应用里运行无论是恢复内容

00:11:36.663 --> 00:11:38.265
或是继续搜索

00:11:39.132 --> 00:11:41.768
之后 我将会聊一下
新的Search API

00:11:42.603 --> 00:11:46.106
在Vipul回到台上给你们一个
关于排序的简介之前

00:11:48.375 --> 00:11:51.612
我们使用了三种技术
它们能支持大部分的用例

00:11:52.312 --> 00:11:55.015
你们设备上的核心支持
CoreSpotlight

00:11:56.116 --> 00:11:58.752
用于应用历史记录的
NSUserActivity

00:11:59.953 --> 00:12:03.957
及web markup公开在线内容
的通用链接

00:12:05.559 --> 00:12:08.295
当然 你们可以将这三者一起使用

00:12:09.229 --> 00:12:12.099
举个例子 设想一个食谱的应用

00:12:13.367 --> 00:12:16.603
它提供一个能访问大量食谱的接口

00:12:17.237 --> 00:12:21.675
由于网站上有许多宿主
深层链接会是一个好的选择

00:12:22.342 --> 00:12:26.180
这个应用也许会有收藏功能
通过CoreSpotlight实现

00:12:27.748 --> 00:12:31.418
你们的用户会想返回至之前看过的内容

00:12:31.652 --> 00:12:34.354
那为了最好的体验
你们也可以使用应用历史

00:12:34.721 --> 00:12:36.557
通过NSUserActivity

00:12:38.892 --> 00:12:41.929
好的 在座没离开去午餐的各位

00:12:42.296 --> 00:12:43.964
我们跳过Search APIs简介

00:12:44.031 --> 00:12:46.166
直接来聊下怎样对内容建立索引

00:12:46.800 --> 00:12:48.468
从CoreSpotlight开始

00:12:49.837 --> 00:12:53.073
CoreSpotlight是
在iOS上用于建立索引的API

00:12:53.407 --> 00:12:55.676
在设备上并支持文件保护

00:12:56.109 --> 00:12:58.278
这样你们可以
对用户的私人内容建立索引

00:12:59.179 --> 00:13:02.583
你们的应用拥有掌控权
你们决定对什么添加索引

00:13:04.251 --> 00:13:07.254
你们可以对应用的所有内容建立索引
可以是收藏

00:13:07.387 --> 00:13:10.557
和书签 信息和邮件

00:13:10.724 --> 00:13:14.428
文档 图片 音乐视频 游戏关卡

00:13:14.494 --> 00:13:17.431
你们应用的进入点 等等

00:13:19.666 --> 00:13:21.268
有两个基本的操作

00:13:22.603 --> 00:13:25.239
第一 你们要将那些东西添加至索引

00:13:26.440 --> 00:13:29.877
通过创建一个
CSSearchableItemAttributeSet来实现

00:13:30.344 --> 00:13:37.150
它包含了元数据和其它的相关内容

00:13:37.851 --> 00:13:38.685
然后

00:13:40.854 --> 00:13:41.955
你们要设置至少一个属性

00:13:42.022 --> 00:13:43.824
这里 我们设定了
display name

00:13:46.727 --> 00:13:49.796
你们可使用AttributeSet
创建可搜索内容

00:13:51.431 --> 00:13:54.801
可使用uniqueIdentifier
Spotlight将会用它

00:13:55.335 --> 00:13:58.372
在下面的操作里
来识别项目内容

00:13:58.438 --> 00:14:01.141
当我们开启你们应用的时候
它也会被用到

00:14:02.309 --> 00:14:04.011
那domainIdentifier

00:14:04.478 --> 00:14:08.248
它让你们能设定共享的属性

00:14:08.315 --> 00:14:11.118
在各种的项目之间
之后的删除里可以用得到

00:14:12.419 --> 00:14:15.689
你们指示CoreSpotlight
添加项目至索引

00:14:16.957 --> 00:14:18.492
当回调方法被调用时

00:14:19.526 --> 00:14:21.762
项目会被安全地提交至储存

00:14:22.529 --> 00:14:24.998
或 一个错误信息会被传递至
回调日志

00:14:28.202 --> 00:14:31.572
对删除项目 我们有三个APIs

00:14:32.039 --> 00:14:35.008
你们可以通过识别符来删除
一个特定的项目

00:14:35.909 --> 00:14:37.878
举例 如要删除一个文档

00:14:41.748 --> 00:14:43.617
也能删除一组项目

00:14:44.084 --> 00:14:46.587
通过使用之前提过的
domainIdentifier

00:14:46.653 --> 00:14:49.456
这会很有用
如果用户从一个账户注销

00:14:49.623 --> 00:14:52.726
终止订阅或是类似的

00:14:54.127 --> 00:14:58.131
最后 你们可以从应用里
删除所有的项目

00:14:58.298 --> 00:15:02.236
这会很有用
如果你们遇到像版本不匹配

00:15:02.569 --> 00:15:05.138
然后你们要清楚索引 重新建立

00:15:05.939 --> 00:15:09.643
这也会在应用被卸载时被系统调用

00:15:14.114 --> 00:15:17.351
那现在让我们来看一些最佳的实践和
一些进阶的使用

00:15:17.918 --> 00:15:21.955
我们将会讲一下如何注册索引代理
使用CoreSpotlight

00:15:22.022 --> 00:15:24.358
客户状态操控渐进的
索引建立

00:15:25.392 --> 00:15:26.994
一些性能问题

00:15:28.095 --> 00:15:30.097
和如何创建
CoreSpotlight扩展

00:15:32.633 --> 00:15:34.468
你们需要注册一个
索引代理

00:15:34.535 --> 00:15:36.803
因为这让Spotlight初始索引

00:15:37.070 --> 00:15:39.540
当你们的应用第一次在系统上运行时

00:15:39.773 --> 00:15:41.375
或在恢复备份之后

00:15:41.909 --> 00:15:45.612
当用户安装你们的应用时,
或在灾难恢复时

00:15:46.647 --> 00:15:48.715
这也能让Spotlight发出

00:15:48.782 --> 00:15:51.084
请求让你们重新对某项目建立索引

00:15:52.920 --> 00:15:55.189
这通常是由于
你们设定了一个过期日期

00:15:55.255 --> 00:15:58.458
Spotlight想检测项目
是否已真的过期

00:16:00.661 --> 00:16:03.230
那作为索引代理
需要实现

00:16:03.297 --> 00:16:05.265
CSSearchableIndexDelegate协议

00:16:06.233 --> 00:16:07.768
它有两个必要的方法

00:16:09.002 --> 00:16:10.838
ReindexAllSearchableItems

00:16:11.305 --> 00:16:14.908
当要添加任何东西至索引时
它就会被调用

00:16:15.342 --> 00:16:18.412
如果你们在自己的数据库里跟踪
个别项目的索引

00:16:18.879 --> 00:16:22.716
当接收到这个方法时
你们要清除索引的状态

00:16:23.050 --> 00:16:25.652
除非你们用客户状态
我们等下细说

00:16:27.487 --> 00:16:31.091
第二个被调用的方法是
使用识别符重新建立索引

00:16:32.626 --> 00:16:36.196
当它被调用时 你们查看
Spotlight正请求的项目

00:16:37.231 --> 00:16:40.100
然后 将它们添加至索引或删除
视情况而定

00:16:40.534 --> 00:16:44.271
对于这两个方法 你们要调用
acknowledgmentHandler

00:16:44.338 --> 00:16:48.041
仅当你们完成了或收到了最后的回调
对任何任务

00:16:48.108 --> 00:16:49.543
你们派给CoreSpotlight

00:16:49.910 --> 00:16:54.548
这样就能确保项目的索引被完整建立

00:16:54.648 --> 00:16:56.483
并在下面的流程不再被调用

00:16:57.184 --> 00:17:02.689
若你们不调用acknowledgmentHandler
那两个方法或许会被再次调用 若过早地调用

00:17:03.357 --> 00:17:05.358
你们也许还未来得及完成对索引的建立

00:17:07.060 --> 00:17:10.196
对某些应用来说
我们发现会更便捷

00:17:10.263 --> 00:17:13.300
通过使用客户状态
相比较于尝试着管理

00:17:13.400 --> 00:17:16.270
索引建立的回调与数据库的事务

00:17:19.205 --> 00:17:22.809
客户状态提供了
一个异步的方式

00:17:22.876 --> 00:17:26.012
让你的项目能与
Spotlight里的同步

00:17:27.414 --> 00:17:31.785
因为是异步 你们其实是在应用一个
一致性模型

00:17:33.687 --> 00:17:37.124
但你们保持对Spotlight与
你们数据库之间的同步

00:17:37.824 --> 00:17:39.393
没有任何多余步骤

00:17:41.128 --> 00:17:44.464
客户状态是个opaque token
它被储存在Spotlight索引里

00:17:44.631 --> 00:17:46.166
在索引建立的同时被更新

00:17:46.233 --> 00:17:48.502
然后当应用被再次开启时被取回

00:17:49.903 --> 00:17:52.606
一般来说 最简单的实现方式是

00:17:52.673 --> 00:17:54.842
在你们的数据库里添加注释

00:17:55.442 --> 00:17:56.910
举例 次序号

00:17:57.911 --> 00:18:00.914
你们在Spotlight里将它
作为客户状态使用

00:18:01.348 --> 00:18:04.451
再次开启后
你们要检测客户状态

00:18:04.852 --> 00:18:06.954
如果它与你们所期望的不符

00:18:07.020 --> 00:18:09.056
那你们要为数据库里所有的项目
建立索引

00:18:09.456 --> 00:18:12.426
使用比你们回传至Spotlight
的更高次序号

00:18:13.560 --> 00:18:16.063
另一个方式是 通过次序号取得

00:18:16.763 --> 00:18:20.567
journal playback
的起始位置

00:18:22.236 --> 00:18:23.737
这会是很有用的

00:18:23.971 --> 00:18:26.340
让你们的内容异步保持最新

00:18:27.407 --> 00:18:30.110
也能确保不消耗过多的能源

00:18:33.680 --> 00:18:37.117
为能使用客户状态
你们要创建一个命名的索引实例

00:18:37.651 --> 00:18:41.088
这名字让我们知道
你们想要的客户状态

00:18:41.688 --> 00:18:43.824
只能获取
应用的客户状态

00:18:43.891 --> 00:18:46.960
但你们可以对多个数据库
建立索引

00:18:47.528 --> 00:18:50.631
这样的话 你们要给每个数据库
一个特有的名字

00:18:51.598 --> 00:18:54.134
有了索引后
你们要初始一个索引批处理

00:18:54.968 --> 00:18:56.637
你们像往常一样添加可查询项目

00:18:57.571 --> 00:18:59.973
completionHandler
在这里并不重要

00:19:00.974 --> 00:19:04.144
因为当批处理完成时
你们会得到一个完成信号

00:19:06.013 --> 00:19:08.482
你们要通过运算得到所选状态

00:19:10.184 --> 00:19:11.818
再将它递入Spotlight

00:19:13.320 --> 00:19:15.022
当你们完成了批处理后

00:19:16.356 --> 00:19:20.961
这里你们需要留意
completionHandler

00:19:23.630 --> 00:19:26.133
你们应用下次开启时
你们获取客户状态

00:19:27.000 --> 00:19:30.037
你们要决定需要执行哪些操作

00:19:30.804 --> 00:19:33.073
让Spotlight才能和
你们当前状态同步

00:19:34.241 --> 00:19:37.211
由于客户状态是
与批处理一起储存于索引

00:19:37.611 --> 00:19:38.879
因此确保了完整性

00:19:39.179 --> 00:19:41.648
你们可以重演每一个需要的操作

00:19:42.049 --> 00:19:43.684
使两者同步

00:19:44.585 --> 00:19:45.953
当你们的应用下次被开启时

00:19:46.053 --> 00:19:48.288
你们会使用同一个名字
创建一个索引实例

00:19:49.089 --> 00:19:52.326
你们会取得客户状态
这就是一个异步的调用

00:19:53.227 --> 00:19:55.896
你们要在回调里处理所有的错误

00:19:57.097 --> 00:20:00.100
还要检查你们取回的状态
是否是你们想要的

00:20:00.601 --> 00:20:04.137
如果不是 你们调用这方法 使其同步

00:20:05.138 --> 00:20:07.174
现在让我们来看下性能问题

00:20:07.541 --> 00:20:09.610
Spotlight处理速度很快

00:20:09.977 --> 00:20:12.045
所以要在你们那端将开销最小化

00:20:12.179 --> 00:20:15.115
来确保应用能跟得上

00:20:16.216 --> 00:20:19.186
你们要优化任何对
文件或数据库的访问

00:20:20.454 --> 00:20:23.423
并留意内存使用情况

00:20:24.625 --> 00:20:27.227
注意对CoreSpotlight
每次调用都有一定成本

00:20:27.928 --> 00:20:31.565
所以 可能时 尽量成批传递
避免单个传递

00:20:32.900 --> 00:20:36.136
只是十个一小批

00:20:36.370 --> 00:20:39.540
也会减少一个数量级的IPC开销

00:20:42.009 --> 00:20:45.612
由于你们的应用会在用户使用的同时
建立索引

00:20:45.979 --> 00:20:48.148
确保你们不会阻塞主线程

00:20:49.316 --> 00:20:54.188
最后 避免干扰在使用后台线程的UI

00:20:55.756 --> 00:20:58.258
好 让我们看下
CoreSpotlight扩展

00:20:58.859 --> 00:21:01.662
扩展能在你们的应用不运行的情况下
建立索引

00:21:03.430 --> 00:21:04.698
这能让你们赶上进度

00:21:05.866 --> 00:21:09.236
在使用备份进行灾难恢复之后

00:21:09.903 --> 00:21:12.139
或你们的图标过期时

00:21:12.206 --> 00:21:14.174
Spotlight能使用你们的扩展

00:21:14.508 --> 00:21:17.144
不用使用你们的应用

00:21:17.244 --> 00:21:19.613
这很好 因为那时你们的应用
可能没在运行

00:21:21.315 --> 00:21:24.384
扩展的接口与
索引代理相同

00:21:24.985 --> 00:21:29.923
若你们能构建你们的代码让索引代理
成为独立的部分

00:21:30.190 --> 00:21:33.660
那实现扩展也是十分容易的

00:21:35.662 --> 00:21:37.764
让项目能被你们的扩展访问

00:21:37.831 --> 00:21:39.533
你们可使用share.groups

00:21:39.766 --> 00:21:41.468
要获得更多相关信息

00:21:41.535 --> 00:21:45.005
看一下去年
“应用扩展最佳实践”的演讲

00:21:45.906 --> 00:21:48.208
下面让我们来看下
如何保持项目为最新

00:21:48.675 --> 00:21:51.044
如我之前所提到的
你们能用过期日期

00:21:51.845 --> 00:21:54.481
来预防旧内容堆积在索引里

00:21:55.115 --> 00:21:59.686
CoreSpotlight会在
将近过期日期时调出你们的应用

00:22:00.521 --> 00:22:03.290
你们可以更新过期日期
或更新项目的数据

00:22:03.357 --> 00:22:04.324
如果有需要

00:22:05.392 --> 00:22:07.594
若你们要将新内容
加至Spotlight

00:22:08.495 --> 00:22:10.030
你们可以使用后台获取

00:22:10.464 --> 00:22:13.133
这能让你们的应用在后台打开

00:22:14.234 --> 00:22:18.005
让你们添加内容并建立索引

00:22:18.972 --> 00:22:19.806
最后

00:22:21.408 --> 00:22:25.646
若你们采用非常规或非高频率的更新推送模型

00:22:25.913 --> 00:22:28.382
你们可以使用静默推送

00:22:29.449 --> 00:22:32.819
让你们的服务器来告诉你们必要的更新

00:22:34.021 --> 00:22:35.689
想了解跟多关于后台获取

00:22:35.756 --> 00:22:37.291
和静默推送

00:22:37.791 --> 00:22:41.562
可以看下“多任务的新特性”演讲

00:22:41.628 --> 00:22:43.430
2013年的 WWDC

00:22:44.665 --> 00:22:47.034
这就是CoreSpotlight
索引的所有内容

00:22:47.568 --> 00:22:50.404
下面我们聊下应用历史
与NSUserActivity

00:22:52.840 --> 00:22:56.243
NSUserActivity
在iOS 8里为Handoff添加

00:22:56.710 --> 00:23:00.380
他让你们能创建应用当前状态的
一个代表

00:23:00.614 --> 00:23:02.282
可以被递入另一个设备

00:23:02.349 --> 00:23:06.119
iOS 9后存于Spotlight
索引里支持应用历史

00:23:09.523 --> 00:23:13.160
当用户浏览你们的应用时
你们提交活动

00:23:13.760 --> 00:23:17.130
为了用户可能会记得并想返回去的内容

00:23:19.299 --> 00:23:22.936
那你们应该问自己
什么时候用户活动

00:23:23.003 --> 00:23:26.974
应该有索引 简单的说
就是用户是否会返回到这

00:23:27.508 --> 00:23:30.110
若相同项目通过
CoreSpotlight有索引

00:23:30.611 --> 00:23:32.379
那答案基本上时肯定的

00:23:34.381 --> 00:23:38.085
2014年的“采用切换”演讲
有许多相关的信息

00:23:38.151 --> 00:23:40.153
关于如何使用
NSUserActivity

00:23:42.456 --> 00:23:44.691
为了让搜索能使用
NSUserActivity

00:23:44.791 --> 00:23:47.794
你要标记它为可查询
并为元数据添加索引

00:23:47.861 --> 00:23:49.930
通过使用
CSSearchableItemAttributeSet

00:23:52.366 --> 00:23:53.634
你们标记它为可查询

00:23:53.967 --> 00:23:56.470
通过设定eligibleForSearch属性为真

00:23:58.972 --> 00:24:02.209
你们也可标记NSUserActivity
让它能建立公开索引

00:24:02.276 --> 00:24:04.378
让它成为网上索引的候选

00:24:04.645 --> 00:24:06.313
Vipul会等一下来细谈

00:24:07.147 --> 00:24:09.983
完成后 它将作为搜索结果显示在
Spotlight Search里

00:24:10.050 --> 00:24:12.953
你们的应用可以返回到用户的活动

00:24:13.287 --> 00:24:15.022
当用户在Spotlight里选择它

00:24:22.296 --> 00:24:25.199
你们的用户只需记得一个关键词

00:24:26.733 --> 00:24:28.802
从他们之前所见的
这就能将他们带回到

00:24:28.869 --> 00:24:30.470
你们应用里的内容

00:24:33.941 --> 00:24:38.745
好的 就如我所说的 你们可使用
CoreSpotlight和NSUserActivity

00:24:38.812 --> 00:24:40.480
对一样的内容

00:24:42.950 --> 00:24:45.252
区别在于
NSUserActivity显示

00:24:45.352 --> 00:24:47.855
用户在你们的应用里做了些什么

00:24:48.255 --> 00:24:51.124
CoreSpotlight是指
你的应用有些什么

00:24:51.959 --> 00:24:55.429
所以若你们同时使用两者
可关联NSUserActivity

00:24:55.495 --> 00:24:57.831
与CSSearchableItem
对相同的内容

00:24:58.198 --> 00:25:01.168
为排序提供帮助
并防止重复的结果

00:25:02.202 --> 00:25:05.405
这能通过设定
relatedUniqueIdentifier属性来达成

00:25:06.340 --> 00:25:08.942
它在AttributeSet里
将它设定成uniqueIdentifier

00:25:09.009 --> 00:25:11.378
对应你想关联的
CSSearchableItem

00:25:12.913 --> 00:25:15.682
这会把NSUserActivity
的生存周期

00:25:16.083 --> 00:25:17.384
与CSSearchableItem
联系在一起

00:25:17.718 --> 00:25:20.654
为保护你们
防止数据被遗留在设备上

00:25:20.888 --> 00:25:23.557
在用户删除了私人的内容之后

00:25:26.093 --> 00:25:30.831
不过 不是所有数据都是私人的
都由用户所管理

00:25:31.698 --> 00:25:34.968
举例 我们之前提到的食谱应用里

00:25:35.269 --> 00:25:37.371
你们或许想关联
NSUserActivity

00:25:38.105 --> 00:25:41.775
与一个可能CSSearchableItem
一个当前不存在的项目

00:25:43.443 --> 00:25:46.079
用户可能在将来把其作为收藏

00:25:47.748 --> 00:25:50.050
如果你们用了relatedUniqueIdentifier

00:25:50.117 --> 00:25:55.055
CoreSpotlight会在你们添加
NSUserActivity时立即将其删除

00:25:55.923 --> 00:25:57.891
因为 它所关联的项目当前不存在

00:25:58.692 --> 00:26:01.161
为了解决这个问题
我们加入了一个新的属性

00:26:01.395 --> 00:26:06.366
weakRelatedUniqueIdentifier
它让你们能弱绑定CSSearchableItem

00:26:07.835 --> 00:26:10.437
它能在CSSearchableItem之前存在

00:26:10.504 --> 00:26:12.940
并会一直存在
直至CSSearchableItem被删除

00:26:14.174 --> 00:26:16.543
至于relatedUniqueIdentifier

00:26:16.610 --> 00:26:19.279
你们只要在AttributeSet
设定这个属性

00:26:19.346 --> 00:26:20.848
给NSUserActivity

00:26:23.550 --> 00:26:28.589
缺点是当
CSSearchableItem被删除后

00:26:29.189 --> 00:26:31.325
NSUserActivity
会继续存在

00:26:31.825 --> 00:26:35.829
所以 如果你们担心
可查询项目的生存期

00:26:35.896 --> 00:26:37.397
或NSUserActivity

00:26:37.464 --> 00:26:41.435
那你们要自己删除
NSUserActivity

00:26:42.236 --> 00:26:44.705
有幸的是 在iOS 10里

00:26:45.205 --> 00:26:46.473
我们让这成为了可能

00:26:47.674 --> 00:26:50.377
我们添加了domainIdentifiers
至NSUserActivities

00:26:51.612 --> 00:26:54.548
这是CSSearchableItemAttributeSet的一部分

00:26:55.883 --> 00:26:59.987
它能让你们通过domainIdentifier
删除NSUserActivities

00:27:00.087 --> 00:27:02.222
就像对CSSearchableItem一样

00:27:03.323 --> 00:27:06.426
如果你们同时使用CSSearchableItems
和NSUserActivities

00:27:06.493 --> 00:27:09.596
使用相同的domainIdentifier会是一个
明智的选择

00:27:10.898 --> 00:27:14.868
这就是如何在iOS 10里
通过NSUserActivity建立索引

00:27:15.335 --> 00:27:18.906
下面 让我们来聊下通用链接
与web markup

00:27:20.774 --> 00:27:25.245
驱动你们应用的内容也许是在网上的
而不是在本地应用的内部

00:27:26.313 --> 00:27:28.682
如这些是公开内容
你们可使用web markup

00:27:28.749 --> 00:27:31.785
让它们通过通用链接索引
在Spotlight里成为可查询的

00:27:33.220 --> 00:27:35.522
这很适合网站上的内容

00:27:35.589 --> 00:27:36.790
和应用内部的

00:27:36.957 --> 00:27:40.727
也是一个好的解决方法
当项目内容太大 无法储存在设备上时

00:27:41.762 --> 00:27:43.830
由于 你们的内容在网上

00:27:44.331 --> 00:27:47.768
没有应用的用户也可以看到结果

00:27:48.869 --> 00:27:53.807
这能让你们招揽更多的用户
增进应用的安装

00:27:54.875 --> 00:27:59.146
结果可同时在Spotlight
和Safari里显示

00:27:59.346 --> 00:28:01.782
让你们的内容可以
让更多的用户看到

00:28:04.518 --> 00:28:08.422
那要实现
通用链接索引

00:28:08.822 --> 00:28:10.190
你们要允许索引

00:28:10.858 --> 00:28:14.161
要让Applebot能调用
你们网站的文本

00:28:15.229 --> 00:28:16.997
还要让Apple Note
能进入网站

00:28:17.064 --> 00:28:20.434
在提交应用至App Store时
指定调用的URL

00:28:22.970 --> 00:28:26.006
对于深层链接 强烈建议
用通用链接

00:28:26.373 --> 00:28:28.675
这里你们需要实现
双重身份验证

00:28:28.742 --> 00:28:30.110
在网站端和在应用端

00:28:31.411 --> 00:28:34.314
在你们的应用代理里实现
continueUserActivity方法

00:28:34.414 --> 00:28:37.851
为确保当用户选择了结果时
你们的应用会处理深层链接

00:28:39.586 --> 00:28:42.222
使用schema.org和
Open Graph标记你们的内容

00:28:42.723 --> 00:28:45.259
这能让你们的内容被丰富多样地展现

00:28:46.627 --> 00:28:48.662
利用Search API验证工具

00:28:49.630 --> 00:28:52.966
来检查深层链接、标记
标题、描述 等等

00:28:55.068 --> 00:28:58.572
去看下2015年的
“引入Search APIs”演讲

00:28:59.006 --> 00:29:02.342
和关于通用链接
的开发者文档

00:29:04.678 --> 00:29:08.182
这些就是我们当前支持的构架

00:29:08.248 --> 00:29:09.783
我们打算在将来加入更多

00:29:11.251 --> 00:29:13.887
留意交互计算
和总体评级

00:29:13.954 --> 00:29:17.057
这些对应用的搜索结果排序
会是十分有用的

00:29:18.759 --> 00:29:20.260
Apple提供了一个测试工具

00:29:21.728 --> 00:29:23.997
在search.developer.apple.com

00:29:24.464 --> 00:29:28.302
如果你们的应用使用深层链接
应该去看一下

00:29:30.237 --> 00:29:32.906
它现在可以将你们的结果
可视化地显示

00:29:32.973 --> 00:29:35.175
包括对schema.org
标记的支持

00:29:37.044 --> 00:29:38.912
从验证工具里所得的内容

00:29:39.079 --> 00:29:42.482
能帮助你们可视化
那些通过Applebot爬网程序

00:29:42.883 --> 00:29:46.186
建立过索引的内容
包括标题、描述、标记和URL

00:29:47.421 --> 00:29:50.991
现在你们看过如何通过这三个APIs
对内容建立索引

00:29:51.191 --> 00:29:54.094
很有可能你们会想将它们一起使用

00:29:55.562 --> 00:29:57.064
即使是对相同的内容

00:30:00.968 --> 00:30:04.137
那当使用多个APIs时 要牢记的是

00:30:04.204 --> 00:30:08.408
在所有APIs里
关联代表同一内容的项目

00:30:09.109 --> 00:30:12.145
通过设定与NSUserActivity
相关的uniqueIdentifier

00:30:12.212 --> 00:30:14.548
为CoreSpotlight
的uniqueIdentifier

00:30:15.048 --> 00:30:20.087
CoreSpotlight内容的URL
和NSUserActivity的网页URL

00:30:21.021 --> 00:30:22.523
为网页URL

00:30:22.589 --> 00:30:26.493
你们告诉Spotlight
所有索引里的纪录代表同一个项目

00:30:27.461 --> 00:30:29.530
这能让你们的查询不会重复

00:30:30.297 --> 00:30:32.999
这也帮助了项目的排序

00:30:35.569 --> 00:30:39.239
好的  现在我们看了如何将内容
添加至索引的三个方法

00:30:40.274 --> 00:30:42.276
CoreSpotlight对应内容

00:30:43.043 --> 00:30:45.379
NSUserActivity
对应用历史

00:30:46.079 --> 00:30:48.048
通用链接
与web markup

00:30:48.115 --> 00:30:50.851
对应网上公开的内容

00:30:53.020 --> 00:30:56.490
下面让我们聊下
怎样向用户展示这些信息

00:30:59.893 --> 00:31:03.397
要在Spotlight里有好的展现
你需要一组好的缩略图

00:31:03.931 --> 00:31:06.333
默认下Spotlight会
使用你们应用图标

00:31:07.234 --> 00:31:09.770
这会让结果乍一看很难区分

00:31:10.637 --> 00:31:13.473
这不碍事 如果你们只有一个结果

00:31:13.540 --> 00:31:16.710
但如果有多个结果
那感觉会是十分不同的

00:31:18.111 --> 00:31:21.481
与缩略图一样重要
或许更重要的是标题

00:31:21.615 --> 00:31:23.917
一个好的标题不只是看起来舒服

00:31:23.984 --> 00:31:26.320
它也是经常被用户用来搜索的

00:31:28.088 --> 00:31:29.990
在缩略图和标题之后

00:31:30.858 --> 00:31:33.827
你们要设置其它的
适合你们内容的字段

00:31:34.294 --> 00:31:38.465
提供描述信息会是一个好主意
像评分 评价

00:31:38.932 --> 00:31:41.368
日期相关项目的日期属性

00:31:41.435 --> 00:31:47.674
比如 旅程预定 日期 提醒 事件
还有很多

00:31:49.543 --> 00:31:52.246
对于文档 一般的元数据

00:31:52.646 --> 00:31:55.716
比如 文档大小和页数
都是很有帮助的

00:31:57.451 --> 00:32:00.020
如果你们设定了适合内容的类型

00:32:00.087 --> 00:32:02.556
Spotlight可以更好的工作

00:32:03.257 --> 00:32:04.591
让我们来看些例子

00:32:07.127 --> 00:32:11.064
Hotel Tonight应用
很好地利用了缩略图

00:32:11.131 --> 00:32:13.267
显示了容易识别的地标

00:32:13.367 --> 00:32:15.802
同时还有标题和有用的描述

00:32:20.374 --> 00:32:22.976
你们可以使用web markup
取得相同的效果

00:32:23.043 --> 00:32:26.780
通过设定og:image og:title
和og:description

00:32:29.316 --> 00:32:32.486
Open Table使用
标题描述 评级

00:32:32.553 --> 00:32:36.657
与评价相关的属性
用户能得到很有用的信息

00:32:36.890 --> 00:32:39.393
让他们在进入应用前
有适合的选择

00:32:41.295 --> 00:32:43.730
通过让属性
能在web markup里获取

00:32:43.964 --> 00:32:47.434
你们确保了用户会得到一个
一致的体验

00:32:47.768 --> 00:32:50.304
无论他们的结果是从
爬网程序

00:32:51.371 --> 00:32:53.006
或本地设备的索引得到的

00:32:57.845 --> 00:33:01.248
一个好的用户体验不仅是关于
外在的展现

00:33:01.315 --> 00:33:04.151
也与可搜索的数据有关

00:33:05.085 --> 00:33:09.022
设定让用户能看懂和记住的属性

00:33:09.289 --> 00:33:11.358
让你们的内容能很快地被找到

00:33:12.759 --> 00:33:16.930
相反 在元数据里设定了
误导性的属性

00:33:17.364 --> 00:33:19.099
或太多的内容和关键词

00:33:19.166 --> 00:33:22.236
字典里的词
会导致你们的结果频繁的呈现

00:33:22.603 --> 00:33:25.105
但极少会被选中
这会让你的用户不爽

00:33:25.372 --> 00:33:27.708
这对排序会有强烈的负面影响

00:33:30.043 --> 00:33:32.713
另一个好的用户体验的方面

00:33:33.146 --> 00:33:36.183
是能获取结果重要的部分

00:33:36.250 --> 00:33:37.885
利用最少的步骤

00:33:38.385 --> 00:33:39.887
允许快速方式

00:33:41.588 --> 00:33:45.626
像路线和通话是能让
你们的用户受益的

00:33:46.393 --> 00:33:47.227
最后

00:33:49.096 --> 00:33:50.631
当用户选择了一个项目

00:33:50.697 --> 00:33:54.268
你们要尽可能快地开启

00:33:54.334 --> 00:33:58.172
不能有间隙感或多步加载
阻碍用户

00:33:58.906 --> 00:34:00.207
让我们来看些例子

00:34:02.676 --> 00:34:05.345
Redfin应用
提供了一些吸引人的结果

00:34:05.812 --> 00:34:09.416
通过设定经纬度和允许导航

00:34:09.783 --> 00:34:13.387
应用让用户能直接到Maps查看地产

00:34:13.853 --> 00:34:18.625
相似的 这还有个很好的call
action result的用例

00:34:19.525 --> 00:34:22.763
你们可以通过设定电话号码属性
取得相同的结果

00:34:22.829 --> 00:34:25.899
同样也支持Spotlight的
phone call属性

00:34:26.333 --> 00:34:27.501
看着这些结果

00:34:28.034 --> 00:34:30.571
已经对地点熟悉了的用户

00:34:30.637 --> 00:34:33.407
可以立刻打电话预约

00:34:34.842 --> 00:34:37.411
你们可以通过web markup
取得相同的结果

00:34:37.878 --> 00:34:40.581
通过利用邮寄地址和电话号码

00:34:42.516 --> 00:34:45.252
下面让我们来聊下
开启你们的应用

00:34:49.322 --> 00:34:51.158
对于CoreSpotlight
和应用历史

00:34:51.225 --> 00:34:53.560
我们使用NSUserActivity
来恢复状态

00:34:54.661 --> 00:34:57.564
你们的应用代理会
与continueUserActivity一起被调用

00:34:57.965 --> 00:35:00.334
你们检测NSUserActivity
的活动类型

00:35:00.834 --> 00:35:02.836
和用户信息字典 如果必要

00:35:03.470 --> 00:35:07.107
如果你们的应用是由于用户
在Spotlight里选择了CSSearchableItem而启动

00:35:07.174 --> 00:35:10.477
那活动类型会是
CSSearchableItemActionType

00:35:10.677 --> 00:35:13.914
然后你们从用户信息字典里取得识别符

00:35:14.214 --> 00:35:16.750
通过使用
CSSearchableItemActivityIdentifier

00:35:17.618 --> 00:35:19.720
2014年“引入切换”的演讲

00:35:19.786 --> 00:35:23.924
更深层讲解了如何开启
NSUserActivity审阅和活动类型

00:35:24.758 --> 00:35:28.662
对通用链接
同样我们使用NSUserActivity

00:35:29.530 --> 00:35:32.499
那样你们的应用代理可和
continueUserActivity一起被调用

00:35:33.033 --> 00:35:36.603
同样 你们检测NSUserActivity的活动类型

00:35:36.870 --> 00:35:40.541
它会是
NSUserActivityTypeBrowsingWeb

00:35:41.542 --> 00:35:46.747
你们解析URL
然后 将用户带到URL所指的地方

00:35:47.447 --> 00:35:48.515
这就是开启

00:35:49.683 --> 00:35:51.251
现在让我们来看个新特性

00:35:54.154 --> 00:35:57.791
在iOS 10里
我们添加了一个功能

00:35:58.225 --> 00:36:00.894
能让用户直接在你们的应用里继续搜索

00:36:03.664 --> 00:36:05.799
让Spotlight显示人性化结果

00:36:07.568 --> 00:36:11.572
是一种直观的体现 你们应选择使用
Spotlight Search continuation

00:36:11.638 --> 00:36:14.074
那样用户就可以直接打开你们的应用

00:36:14.141 --> 00:36:16.944
如果你们已经支持了搜索
那对它的采用就更简单了

00:36:18.312 --> 00:36:21.648
它能让你们使用定制的搜索接口

00:36:22.249 --> 00:36:24.785
它已经广泛被我们内部的应用采用了

00:36:26.119 --> 00:36:29.256
这是另一个增加互动性的方式

00:36:29.323 --> 00:36:30.557
与你们的应用

00:36:30.624 --> 00:36:33.460
用户直接被从Spotlight

00:36:33.694 --> 00:36:36.763
带入了你们已有的搜索体验

00:36:46.306 --> 00:36:47.140
现在——

00:36:52.412 --> 00:36:53.247
谢谢

00:36:54.381 --> 00:36:56.216
为这能在你们的应用里被支持

00:36:57.184 --> 00:36:59.319
你们要在info.plist里
添加一个关键值

00:37:01.288 --> 00:37:03.290
声明你们支持这个功能

00:37:06.760 --> 00:37:09.429
你们应用的代理将被调用
有一个新活动类型

00:37:09.630 --> 00:37:11.832
CSQueryContinuationActionType

00:37:12.466 --> 00:37:15.969
然后新的查询字符串
被递入用户信息

00:37:16.036 --> 00:37:17.671
与CSSearchQueryString
关键值一起

00:37:17.971 --> 00:37:20.974
至此 你们可以执行
你们自己的搜索UI

00:37:21.074 --> 00:37:24.645
利用相同的查询字符串
让用户在你们应用里继续搜索

00:37:25.379 --> 00:37:27.514
为避免困惑
通常是一个好主意

00:37:27.581 --> 00:37:31.218
确保你们的搜索结果
与Spotlight的大概一致

00:37:31.618 --> 00:37:33.854
由于Spotlight
是基于前缀搜索

00:37:34.054 --> 00:37:36.156
我们建议你们使用
相似的规则

00:37:36.723 --> 00:37:38.659
如果你们无法支持前缀搜索

00:37:38.792 --> 00:37:41.662
考虑将用户带至一个完成接口

00:37:44.665 --> 00:37:46.967
另一个确保与
Spotlight一致的方式

00:37:47.034 --> 00:37:49.136
是利用CoreSpotlight
的Search API

00:37:49.503 --> 00:37:52.172
我们有许多内部应用使用这个方式

00:37:57.711 --> 00:38:03.283
CoreSpotlight Search API
让你们能便捷地实现对你们数据的搜索

00:38:03.717 --> 00:38:05.686
它利用你们已经提供给

00:38:05.752 --> 00:38:07.621
CoreSpotlight的数据
支持Spotlight Search

00:38:11.058 --> 00:38:13.293
全美一致

00:38:14.862 --> 00:38:16.897
它已经被我们许多内部的应用使用

00:38:16.964 --> 00:38:18.699
包括Mail
Messages和Notes

00:38:19.466 --> 00:38:24.338
它避免了开销
你们不用管理一个额外的索引

00:38:24.838 --> 00:38:28.108
因为它与Spotlight
使用同一个索引

00:38:29.510 --> 00:38:32.179
这个索引提供了全套的
对元数据和内容的搜索

00:38:33.514 --> 00:38:35.816
如果你们所有的内容都在设备上

00:38:35.883 --> 00:38:38.285
CoreSpotlight是
对于搜索的完全解决方案

00:38:38.819 --> 00:38:42.489
如果你们有设备上和
网上内容的混合

00:38:42.689 --> 00:38:44.825
你们可以合并查询和合并单元

00:38:44.992 --> 00:38:47.294
通过设备上
CoreSpotlight获响应

00:38:47.361 --> 00:38:49.530
通过网上的索引获得完整性

00:38:51.164 --> 00:38:53.867
Mail不仅将
CoreSpotlight用于搜索

00:38:54.368 --> 00:38:57.838
还用它创建搜索建议
建立复杂的查询

00:38:58.338 --> 00:39:01.642
这是个很好利用
CoreSpotlight Search的方式

00:39:01.708 --> 00:39:03.577
同时还能保持简洁的UI

00:39:05.779 --> 00:39:09.983
CoreSpotlight Search API
创建了你们提供给Spotlight的数据

00:39:10.484 --> 00:39:13.220
但你们的数据是受保护的
不会被其它的应用访问

00:39:13.787 --> 00:39:15.956
查询引擎很快并可以被扩展

00:39:16.023 --> 00:39:18.225
所以你们能在应用里得到很好响应

00:39:18.592 --> 00:39:21.328
查询语法允许复杂
完整的提问

00:39:21.461 --> 00:39:24.131
也支持范围查询
数字和时间日期

00:39:24.331 --> 00:39:26.366
还有一组强大的短消息的功能

00:39:26.700 --> 00:39:30.037
对于你们熟悉Mac OS上
元数据框架的人

00:39:30.304 --> 00:39:32.039
会对这个语法感到很熟悉

00:39:33.740 --> 00:39:36.777
简单介绍一些常见的搜索操作

00:39:37.044 --> 00:39:40.547
如所见 CoreSpotlight
支持全套搜索比较运算符

00:39:40.681 --> 00:39:43.684
也支持布尔运算符AND
OR和NOT

00:39:46.787 --> 00:39:49.623
此外 CoreSpotlight
能让你定制

00:39:49.690 --> 00:39:51.458
适合你们需要的字符串匹配

00:39:51.825 --> 00:39:54.461
如果你们要补区分大小写
你们可以添加标志c

00:39:56.330 --> 00:39:59.867
如果你们想忽略注音符号
像注音符

00:40:00.767 --> 00:40:04.371
如果它们在当前的语言里不重要
你们可以用标志d

00:40:05.572 --> 00:40:08.075
如果你们想匹配一个字段里的单词

00:40:08.275 --> 00:40:10.777
你们不用在字段的开始定位标记查询

00:40:10.844 --> 00:40:12.513
你们只需使用标志w

00:40:13.080 --> 00:40:15.782
这些也适用于信息内容

00:40:16.483 --> 00:40:19.219
如果你们想要让多个词被分开
一一处理

00:40:20.554 --> 00:40:23.690
那你们可以递入标志t
那样查询字符串就会被标记

00:40:25.659 --> 00:40:27.027
让我们来看个例子

00:40:27.928 --> 00:40:31.598
我们来实现一个搜索函数
它接收一个用户查询作为输入

00:40:32.232 --> 00:40:34.501
我们确保取消所有
正在运行的查询

00:40:34.568 --> 00:40:37.471
那样我们就不会有
多个查询在同时运行

00:40:37.538 --> 00:40:39.339
这会降低查询速度

00:40:41.875 --> 00:40:45.546
因为我们在处理用户输入
我们确保将查询字符串转义

00:40:47.881 --> 00:40:50.984
我们使用双星语法来创建一个查询
它会匹配

00:40:51.251 --> 00:40:52.920
内容或元数据

00:40:53.654 --> 00:40:55.956
转义的输入作为搜索字符串

00:40:56.690 --> 00:40:59.259
我们有cdw和t运算符

00:40:59.326 --> 00:41:02.129
这表示创建一个
不区分大小写 能本土识别的

00:41:02.296 --> 00:41:05.632
不区分注音符的
匹配单词 标记字段的搜索

00:41:06.733 --> 00:41:09.136
有了查询字符串
我们来创建一个查询对象

00:41:09.703 --> 00:41:12.406
我们请求一个
display name

00:41:13.140 --> 00:41:14.508
这将会在

00:41:14.575 --> 00:41:17.077
返回的可查询项目的
AttributeSet里

00:41:19.146 --> 00:41:20.981
我们设定
foundItemsHandler

00:41:21.315 --> 00:41:23.650
它会接收到多批的可查询项目

00:41:23.984 --> 00:41:25.719
如果你们的查询无结果

00:41:27.321 --> 00:41:30.290
一个completionHandler
会被调用一次

00:41:30.357 --> 00:41:33.493
当有错误时或查询成功

00:41:36.196 --> 00:41:37.865
在我们的completionHandler里

00:41:37.931 --> 00:41:40.734
我们可以选择让它显示完成处理
或其它的

00:41:42.603 --> 00:41:44.505
然后就是开始查询

00:41:44.938 --> 00:41:47.407
CoreSpotlight有了结果
然后调用解决

00:41:47.474 --> 00:41:49.243
然后调用
completionHandler

00:41:50.944 --> 00:41:54.214
让我们来实践一下
我们创建了一个应用

00:41:55.749 --> 00:41:57.451
有一个简单的图片收集功能

00:42:03.757 --> 00:42:05.859
它已支持用CoreSpotlight
建立索引

00:42:05.926 --> 00:42:07.394
也已支持搜索

00:42:08.762 --> 00:42:11.932
那我们要做的第一件事是
添加支持

00:42:13.100 --> 00:42:16.136
Continue Search in App
这很简单

00:42:17.538 --> 00:42:22.409
我们来到应用的info.plist
我们准许CoreSpotlightContinuation

00:42:28.715 --> 00:42:31.351
完成后
我们来到应用的代理...

00:42:33.086 --> 00:42:38.659
在我们的用户活动
continuationHandler里

00:42:40.527 --> 00:42:41.562
我们添加支持...

00:42:43.964 --> 00:42:45.332
Continue Search in App

00:42:45.666 --> 00:42:48.202
如你们所见 活动类型

00:42:48.569 --> 00:42:52.472
是一个CSQueryContinuationActionType

00:42:53.473 --> 00:42:54.975
我们取得搜索的查询...

00:42:56.343 --> 00:42:59.780
通过查看CSSearchQueryString
对应的用户信息

00:43:01.081 --> 00:43:04.017
我们使用搜索询问激活视图控制器

00:43:06.320 --> 00:43:07.821
我们来看下实践

00:43:18.899 --> 00:43:20.968
好的
这里有我们的图片收集

00:43:22.035 --> 00:43:23.804
我们下拉出Spotlight

00:43:27.174 --> 00:43:30.611
搜索单词“雪”

00:43:30.777 --> 00:43:32.846
凑巧在这个相册里很普遍

00:43:34.248 --> 00:43:39.586
我们获取两个结果和
一个在应用里继续搜索

00:43:40.354 --> 00:43:43.423
点击在应用里搜索
我被带入了我的应用

00:43:51.665 --> 00:43:54.735
现在你们或许会观察到
我在Spotlight里有两个结果

00:43:54.968 --> 00:43:56.603
而在我的应用里只有一个

00:43:56.937 --> 00:43:59.973
这是因为我没使用
CoreSpotlight Search

00:44:02.009 --> 00:44:05.279
这个搜索只是一个简单的前缀搜索

00:44:06.079 --> 00:44:07.514
那让我们来修复它

00:44:13.921 --> 00:44:15.155
在我们的视图控制器里

00:44:18.992 --> 00:44:20.127
我们有一个搜索方法

00:44:23.797 --> 00:44:27.568
我将删除这个简单
对搜索的实现

00:44:27.734 --> 00:44:28.902
我们现有的

00:44:31.805 --> 00:44:33.607
然后开始实现
CoreSpotlight

00:44:35.209 --> 00:44:36.743
首先 我们想要添加一个变量

00:44:42.783 --> 00:44:45.886
一个能储存现有搜索查询的
查询对象

00:44:49.423 --> 00:44:51.792
我们要取消正在运行的查询

00:44:55.562 --> 00:44:56.930
将查询字符串转义

00:45:02.135 --> 00:45:02.970
然后创建——

00:45:12.379 --> 00:45:19.152
一个查询对象 当然
是创建一个查询字符串  失误

00:45:22.656 --> 00:45:25.692
好的  那现在我们有了
一个查询字符串 一个查询对象

00:45:27.027 --> 00:45:29.096
然后我们要设定
foundItemsHandler

00:45:34.201 --> 00:45:38.071
foundItemsHandler
创建displayables

00:45:40.707 --> 00:45:43.710
然后添加它们至
我们的结果列表

00:45:44.278 --> 00:45:47.114
现在 由于查询取回了
CSSearchableItems

00:45:47.614 --> 00:45:52.319
我要实现一个能接收
CSSearchableItems的一个配适器

00:45:52.386 --> 00:45:55.088
创建一些能被显示的东西

00:45:55.789 --> 00:45:57.658
让我们来看下

00:46:01.461 --> 00:46:03.864
我称之为懒图的对象

00:46:05.265 --> 00:46:07.701
它能获取数据

00:46:07.801 --> 00:46:12.806
那些通过我们的查询得到的
并适当的时候能使用它们

00:46:13.607 --> 00:46:17.644
当不充足时
它回到数据库

00:46:18.712 --> 00:46:22.316
获取对应识别符的图片对象

00:46:22.950 --> 00:46:25.886
储存起来为将来使用
然后返回它

00:46:25.953 --> 00:46:28.055
那让它能连同返回所有其它的属性

00:46:28.255 --> 00:46:30.123
那些无法从数据库里获得的

00:46:31.658 --> 00:46:35.095
通过使用懒图对象
我们确保可以显示我们的结果

00:46:35.162 --> 00:46:37.130
省去要回到数据库的步骤

00:46:37.764 --> 00:46:39.366
这样对性能有利

00:46:39.800 --> 00:46:42.669
让我们来实现
completionHandler

00:46:44.471 --> 00:46:46.974
completionHandler
里 我们对结果进行排序

00:46:48.141 --> 00:46:49.543
进入主队列

00:46:52.346 --> 00:46:57.150
使结果变为可显示的
然后调用我们的表视图更新

00:46:58.552 --> 00:47:01.188
之后 剩下的就是调用start

00:47:05.759 --> 00:47:07.427
让我们来看下

00:47:20.307 --> 00:47:21.141
好的

00:47:23.710 --> 00:47:26.046
现在因为这是在使用
CoreSpotlight Search

00:47:26.113 --> 00:47:28.815
而且我的查询的条件很宽松

00:47:29.149 --> 00:47:33.053
我应该能输入任何在这里看见的词
比如 河

00:47:34.388 --> 00:47:37.958
我找到了所有在元数据或在内容里
包含河的

00:47:39.693 --> 00:47:43.430
好 通过CoreSpotlight
实现搜索 就这么简单

00:47:44.831 --> 00:47:48.902
下面 我想请Vipul回到台上
来聊一下排序

00:47:56.009 --> 00:47:59.947
谢谢John 刚才是一个对
Search APIs很精彩的简介

00:48:00.247 --> 00:48:03.550
在你们思考如何在应用里
实现这些APIs时

00:48:04.785 --> 00:48:07.154
了解Spotlight
如何对结果排序的会很有帮助

00:48:07.221 --> 00:48:10.057
还有你们怎样正面影响排序

00:48:10.657 --> 00:48:13.327
那让我么来看下
Spotlight里的排序

00:48:14.461 --> 00:48:17.064
Spotlight的主要目的守则

00:48:17.164 --> 00:48:20.400
是依次显示你们查询的最佳结果

00:48:20.467 --> 00:48:23.570
这个顺序由一组因素决定

00:48:23.971 --> 00:48:28.408
两个主要因素
engagement ratio和content popularity

00:48:28.642 --> 00:48:30.511
然我先来聊下
engagement ratio

00:48:31.578 --> 00:48:36.083
Engagement ratio
其实是对频率的衡量结果通过你们的应用

00:48:36.750 --> 00:48:39.253
被用户选择的次数 当它们被展现时

00:48:39.686 --> 00:48:44.191
Spotlight里有三类
engagement ratios

00:48:44.258 --> 00:48:47.261
一个在设备上 两个在服务器上

00:48:47.995 --> 00:48:52.165
在设备上
engagement ratio测量

00:48:52.232 --> 00:48:55.202
用户个人与你们应用的互动

00:48:56.236 --> 00:48:59.773
服务器对每个查询都有一个
engagement ratio

00:48:59.840 --> 00:49:02.276
这是基于每一个查询

00:49:02.342 --> 00:49:04.578
对曾经显示过的结果

00:49:04.645 --> 00:49:10.851
通过使用Spotlight可让结果
提升或降低排序 对应某个查询

00:49:11.285 --> 00:49:13.287
最后 还有一个global
engagement ratio

00:49:13.353 --> 00:49:16.857
它是基于所有用户的
所有互动

00:49:17.891 --> 00:49:19.726
曾经与你们应用发生过的

00:49:20.093 --> 00:49:24.364
没可用查询级别engagement
ratio时 它会被调用

00:49:25.799 --> 00:49:27.100
一些要紧的事

00:49:27.167 --> 00:49:32.539
第一 你们不会得到处罚
如果某个查询结果

00:49:32.606 --> 00:49:34.208
没有显示给用户

00:49:34.274 --> 00:49:37.144
它们可以说是在分割线以下
键盘的下面

00:49:37.845 --> 00:49:43.784
这里最佳的实践
其实是使用关键词 标题和描述

00:49:44.051 --> 00:49:48.422
那些能清楚地形容你们
建立索引的内容

00:49:48.488 --> 00:49:50.858
也能将用户带至相同的内容

00:49:54.394 --> 00:49:55.662
第二个重要的事是

00:49:56.430 --> 00:50:01.068
content popularity
一般来说 更受欢迎的内容

00:50:01.301 --> 00:50:02.436
趋向于被排得更高

00:50:03.170 --> 00:50:07.140
Spotlight能通过三个方式来
了解受欢迎度

00:50:07.574 --> 00:50:09.142
如果你们使用
通用链接

00:50:09.276 --> 00:50:12.813
它们会自动地去查看
网站结构

00:50:12.880 --> 00:50:15.082
然后得到你们网站的声誉

00:50:15.215 --> 00:50:16.617
这里 你们不用做任何事

00:50:16.683 --> 00:50:18.886
你们只要实现
通用链接

00:50:20.254 --> 00:50:23.123
如果一个项目有关联的
NSUserActivity

00:50:23.190 --> 00:50:27.528
Spotlight能跟踪用户
在设备上查阅此项目的频率

00:50:27.594 --> 00:50:29.162
然后在排序里使用

00:50:30.163 --> 00:50:34.468
若你们同时使用通用链接
和公开的NSUserActivities

00:50:34.635 --> 00:50:38.772
那些被允许公进行开索引的
iOS 10现在能估计

00:50:38.972 --> 00:50:42.242
整个iOS用户群

00:50:42.309 --> 00:50:45.546
在你们的应用里查看一个链接的频率
这会被用于排序

00:50:45.712 --> 00:50:48.815
这是为了新的差分隐私条款所建立的

00:50:49.416 --> 00:50:50.884
让我向你们展示下

00:50:52.119 --> 00:50:55.689
这个例子里 Yelp采用了
NSUserActivities

00:50:55.756 --> 00:50:59.092
被允许进行公开索引
和使用通用链接

00:50:59.159 --> 00:51:01.628
当用户在Yelp里遇到一个
深层链接

00:51:01.929 --> 00:51:04.965
iOS计算机哈希添加一些干扰

00:51:05.098 --> 00:51:08.669
之后获取一个碎片
传送至Apple的服务器

00:51:09.069 --> 00:51:13.740
单独的碎片是没用处的
它不包含任何的信息

00:51:14.141 --> 00:51:17.644
可一旦成千的用户报告了很多的碎片

00:51:17.711 --> 00:51:23.250
Apple的服务器能找回
被看了成千次的哈希

00:51:24.918 --> 00:51:29.456
不用知道哪些用户
报告了哪些碎片

00:51:29.990 --> 00:51:34.161
这提供了一个方式用于决定
如用户的总体行为

00:51:34.228 --> 00:51:38.932
不用对任何用户的独立行为
作任何的的分析

00:51:39.600 --> 00:51:42.236
当受欢迎的深层链接
被这样的方式发现后

00:51:42.302 --> 00:51:46.039
它们在Spotlight里的
排名会上升 这很酷

00:51:48.342 --> 00:51:51.945
那让我们很快地看一下
排序的最佳实践

00:51:53.080 --> 00:51:55.549
John展示了许多最佳实践

00:51:55.616 --> 00:51:58.719
对通过CoreSpotlight
给你们应用内容建立索引

00:51:58.785 --> 00:52:02.523
你们应该遵循这些 因为它们会提供
一个一致的搜索体验

00:52:02.589 --> 00:52:06.660
为你们应用的内容
之后用户会去到Spotlight

00:52:06.727 --> 00:52:10.631
搜索你们应用里的东西
这将会影响到engagement ratios

00:52:12.199 --> 00:52:16.837
如果你们有应用的内容 允许Apple
对它们通过通用链接建立索引

00:52:17.604 --> 00:52:21.842
这样能暴露你们的应用给潜在的用户

00:52:23.443 --> 00:52:26.413
你们现知道content
popularity很重要 那就关联

00:52:27.047 --> 00:52:31.318
通用链接和CoreSpotlight
的项目至NSUserActivities

00:52:31.785 --> 00:52:37.858
我们今年添加了weakRelatedUniqueIdentifier
来帮助你们更容易地达成这个

00:52:38.959 --> 00:52:42.029
我重复这个 因为很重要

00:52:42.095 --> 00:52:46.867
你们所建立索引的项目的
标题、描述和关键词

00:52:46.934 --> 00:52:50.571
是与深层链接相关的

00:52:51.071 --> 00:52:52.439
留意你们的表现方式

00:52:52.506 --> 00:52:57.444
我们知道表现合理的链接会有更高的
engagement rates

00:52:57.778 --> 00:53:01.448
最后 在适当的时候实现
Continue Search in App

00:53:01.615 --> 00:53:05.118
它让用户能在你们的应用里
完成搜索任务

00:53:08.388 --> 00:53:10.424
结论 关键的几点

00:53:10.724 --> 00:53:13.660
Spotlight是iOS里
一个全新的万能搜索工具

00:53:13.727 --> 00:53:16.997
在iOS 10里
我们让它变得更实用 更方便被使用

00:53:17.264 --> 00:53:21.969
越来越多的用户期望
一个优质的应用

00:53:22.035 --> 00:53:23.837
能通过Spotlight进行搜索

00:53:23.904 --> 00:53:27.307
所以 如果你们还没采用这些APIs

00:53:27.374 --> 00:53:29.443
我们建议你们考虑采用

00:53:29.510 --> 00:53:32.813
为配合iOS 10的大众发行

00:53:33.080 --> 00:53:35.516
若你们已实现了
Search APIs

00:53:35.582 --> 00:53:38.619
我们建议采用新的规则

00:53:38.685 --> 00:53:40.120
那些我们今天所介绍的

00:53:43.290 --> 00:53:45.125
一些相关的讲座
优秀的讲座

00:53:45.192 --> 00:53:46.960
明天“前摄的建议”的演讲

00:53:47.327 --> 00:53:53.200
在座的你们都应该去
因为你们在搜索里所做的

00:53:53.267 --> 00:53:56.503
能直接被应用到“前摄的建议”里

00:53:56.570 --> 00:53:59.439
我们昨天也有个
SiriKit APIs的精彩演讲

00:53:59.506 --> 00:54:01.675
你们可以在会议的网站上找到它

00:54:01.909 --> 00:54:04.478
我们也推荐星期三关于
隐私的演讲

00:54:04.545 --> 00:54:06.813
那会对差分隐私进行更细致的讨论

00:54:07.447 --> 00:54:10.651
像其它的讲座一样 这个讲座会
被上传 参见第一个URL

00:54:10.717 --> 00:54:13.887
我们也会上传所有
Search API的相关文档

00:54:13.987 --> 00:54:16.323
至search.developer.apple.com

00:54:16.690 --> 00:54:17.791
这就是我们的所有内容

00:54:18.058 --> 00:54:19.493
祝大家在余下的
WWDC 中过得愉快