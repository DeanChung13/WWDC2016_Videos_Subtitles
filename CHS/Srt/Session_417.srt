00:00:19.353 --> 00:00:21.488
调试要诀和技巧

00:00:28.896 --> 00:00:32.232
大家下午好
欢迎参加“调试要诀和技巧”演讲

00:00:32.598 --> 00:00:36.570
看到这么多人来参加这个主题演讲
我感到很欣慰

00:00:36.637 --> 00:00:38.105
很激动

00:00:38.405 --> 00:00:39.239
我叫Kate Stone

00:00:39.306 --> 00:00:42.910
我是Apple调试技术核心团队的组长

00:00:43.644 --> 00:00:45.312
非常激动

00:00:45.379 --> 00:00:48.282
我希望能从我们的团队中
请几名工程师

00:00:48.348 --> 00:00:52.452
讲一些新鲜事儿
如果你刚开始着手的话

00:00:52.519 --> 00:00:54.922
还有一些比较新鲜的小技巧

00:00:54.988 --> 00:00:58.592
即使你已经在你自己的平台上做了十年
的调试工作 你仍然还会觉得新鲜

00:00:58.659 --> 00:01:02.262
这真的是个深水区
我们有很多内容要讲

00:01:02.329 --> 00:01:03.363
让我们开始吧

00:01:04.932 --> 00:01:09.403
特别注意
我们要讲的技术就是LLDB

00:01:09.469 --> 00:01:11.505
若你用Xcode做过调试
你可能没注意过

00:01:11.572 --> 00:01:14.842
后台有一个叫做LLDB的技术

00:01:14.908 --> 00:01:17.945
这是一个底层调试工具
支持所有核心技术

00:01:18.545 --> 00:01:21.615
不仅仅存在于Xcode中
只要你需要 它无处不在

00:01:21.682 --> 00:01:24.518
但是 当然了 你跟它打交道
最多的地方之一

00:01:24.585 --> 00:01:27.120
是Xcode的调试控制台

00:01:27.821 --> 00:01:30.858
Xcode把那个控制台作为调试区
的一个部分

00:01:31.925 --> 00:01:35.863
你将看到可视化的变量
同时也会看到这个LLDB控制台

00:01:36.096 --> 00:01:38.632
我们今天要讲的内容很多

00:01:38.899 --> 00:01:42.469
在那个提示框中
你可以获得提示和一些很棒的东西

00:01:44.905 --> 00:01:46.940
当然 那个区域通常不只是包含

00:01:47.007 --> 00:01:50.611
LLDB的提示框以及
与调试器交互

00:01:50.677 --> 00:01:52.779
还包含你应用的输出

00:01:52.846 --> 00:01:56.183
若是基于控制台的应用 还可以键入

00:01:56.817 --> 00:01:58.685
那也许不是最便捷的方式

00:01:58.752 --> 00:02:01.355
如果你的应用利用了控制台的其他功能

00:02:01.421 --> 00:02:05.993
如移动指针或色彩或其他
ANSI指针操作功能

00:02:06.326 --> 00:02:08.595
那么 在Xcode 8中有个新选项

00:02:08.662 --> 00:02:12.199
允许你给你的应用分配独立终端

00:02:12.266 --> 00:02:14.801
而LLDB仍留在Xcode中

00:02:14.868 --> 00:02:17.037
用起来很简单 提出了选择方案

00:02:17.938 --> 00:02:21.041
并且在最底部的选项标签中
你能看到这个新控制台

00:02:21.108 --> 00:02:26.079
你可以从默认切换到Xcode和终端

00:02:26.313 --> 00:02:28.382
然后 当你运行时
你将得到一个独立终端

00:02:28.448 --> 00:02:31.652
用于处理应用的输入和输出
与Xcode是分离的

00:02:37.558 --> 00:02:40.360
接下来的演讲 我们主要讲LLDB

00:02:40.427 --> 00:02:43.130
若你对Xcode其它具体功能感兴趣

00:02:43.497 --> 00:02:45.532
请查看这两场演讲的相关信息

00:02:45.599 --> 00:02:49.102
当然 演讲已结束
但是你们可以看一下视频

00:02:50.704 --> 00:02:53.440
你还要注意 LLDB不只是
Xcode的一部分

00:02:53.674 --> 00:02:57.110
而Swift REPL
其实就是LLDB

00:02:57.578 --> 00:03:00.080
当你打开Swift REPL
并开始跟它交互时

00:03:00.147 --> 00:03:02.816
你就已经在调试环境中了

00:03:02.883 --> 00:03:05.919
因此 无论什么时候你需要调试器
它都在那儿

00:03:05.986 --> 00:03:08.422
事实上 我们今天要讲的每个命令

00:03:08.488 --> 00:03:10.090
你都能在REPL中直接使用

00:03:10.157 --> 00:03:12.793
只需要在REPL的提示框中加个
冒号前缀即可

00:03:13.093 --> 00:03:16.930
先是冒号 然后是命令 这样就能直接
在LLDB中发出命令了

00:03:17.664 --> 00:03:19.766
比如
我现在Swift REPL提示框

00:03:20.367 --> 00:03:23.570
此刻 我想查找某类型的信息

00:03:23.637 --> 00:03:26.240
当然 我可以打开Xcode并查看帮助

00:03:26.306 --> 00:03:27.774
但是在提示框中

00:03:28.108 --> 00:03:31.411
我可以简单地使用
：type lookup Comparable

00:03:31.912 --> 00:03:34.414
我要查找这个协议 我发现事实上

00:03:34.481 --> 00:03:37.718
它是从另一个协议衍生出来的
添加了以下四个函数

00:03:38.285 --> 00:03:42.155
如果你熟悉并且一直在使用类型查找
它是个很棒的功能

00:03:42.222 --> 00:03:45.492
但你可能不会注意这一点
尽管它的名字是类型查找

00:03:45.559 --> 00:03:47.895
它实际上可以用来查找更多的东西

00:03:47.961 --> 00:03:50.831
实际上我可以查找函数
得到完整的签名

00:03:51.265 --> 00:03:53.667
甚至可以查找整个模块

00:03:53.734 --> 00:03:55.636
当然了 内容会很多

00:03:55.702 --> 00:03:58.872
因为它是那个模块中每个类型的
完整说明

00:03:59.072 --> 00:04:00.407
在这里 我们把它简化了

00:04:02.042 --> 00:04:05.679
那么 REPL可以很好地处理
这种附加的命令

00:04:05.746 --> 00:04:11.552
还可以用来与你在REPL中写的代码
进行交互

00:04:11.818 --> 00:04:13.620
假如我写一个简单的函数

00:04:14.221 --> 00:04:17.391
我写好了一个函数
当我在函数中时 我想停止

00:04:17.457 --> 00:04:19.459
查看某一行正在发生什么

00:04:19.526 --> 00:04:21.361
那么我可以发布断点命令

00:04:21.695 --> 00:04:23.730
加一个冒号前缀 ：b 2

00:04:23.797 --> 00:04:25.432
我在第二行设置了一个断点

00:04:25.499 --> 00:04:28.769
当我调用这个函数时 正如我所
期待的那样停止了

00:04:29.136 --> 00:04:33.006
因为执行已经停止了
它会立即切回LLDB提示框

00:04:33.073 --> 00:04:34.541
在LLDB提示框中

00:04:34.608 --> 00:04:39.146
我可以发布其他LLDB命令
进行交互并探测我的应用

00:04:39.446 --> 00:04:43.150
REPL还将自动进行这些操作
如果你遇到溢出的情况

00:04:43.217 --> 00:04:45.552
或一般会终止你应用的其他东西

00:04:45.619 --> 00:04:47.754
所以 你可以直接从Swift REPL中

00:04:47.821 --> 00:04:49.289
利用调试器的全部功能

00:04:50.324 --> 00:04:53.694
你还要注意 你可以随时在两个
提示框之间切换

00:04:53.760 --> 00:04:55.095
如果你在REPL提示框中

00:04:55.262 --> 00:04:59.533
只写一个冒号 然后按Enter
将打开LLDB提示框

00:04:59.900 --> 00:05:02.636
而REPL命令将切回REPL提示框

00:05:02.703 --> 00:05:05.005
这样 你可以随时使用这两个提示框

00:05:05.472 --> 00:05:07.174
REPL有一些不同的特点

00:05:07.241 --> 00:05:09.376
可能更适用于调试Swift代码时

00:05:09.443 --> 00:05:10.711
的调试会话中

00:05:12.813 --> 00:05:13.647
这很棒

00:05:14.014 --> 00:05:17.084
这是大多数人跟LLDB互动的
主要方式

00:05:17.150 --> 00:05:20.220
但LLDB还是个独立的
命令行工具

00:05:20.587 --> 00:05:23.590
如果我要远程连接到一台机器的
命令窗口 很奇妙

00:05:23.657 --> 00:05:25.125
我的连接很慢

00:05:25.192 --> 00:05:28.729
我非常想利用命令行工具

00:05:28.996 --> 00:05:31.131
但在其它环境下也很有用

00:05:31.198 --> 00:05:35.068
你可能想用它来 比如说
如果你正在自动化调试任务

00:05:35.369 --> 00:05:38.372
我想把调试器设置成每次开启时
加载的命令都一样

00:05:38.438 --> 00:05:40.741
所以我可能要提供

00:05:40.807 --> 00:05:44.378
一个包含一大堆LLDB命令的文件
用于进行配置

00:05:44.444 --> 00:05:48.115
LLDB -- source
后边跟一个文件名

00:05:48.182 --> 00:05:51.151
这将调用LLDB并
source所有命令

00:05:51.218 --> 00:05:53.487
按照我想要的方式设置调试会话

00:05:54.688 --> 00:05:57.057
如果你不想陷入设置文件的麻烦中

00:05:57.124 --> 00:06:00.928
你可以调用LLDB
然后直接在命令行上写命令

00:06:00.994 --> 00:06:04.464
-one-line接着是命令

00:06:04.531 --> 00:06:07.000
只要我启动LLDB 就会发出命令

00:06:07.267 --> 00:06:09.303
如果我想附加命令

00:06:09.369 --> 00:06:12.372
我可以在这里重复option的
简化形式

00:06:12.439 --> 00:06:15.609
-o后边跟着另一个命令
可以重复无数次

00:06:16.043 --> 00:06:19.146
所以 在自动化脚本中
把LLDB设置成

00:06:19.213 --> 00:06:20.480
我所期待的方式非常琐碎

00:06:20.914 --> 00:06:24.017
当然 这也非常有价值

00:06:24.251 --> 00:06:28.488
如果我有一个应用
只有百分之一的错误率

00:06:28.555 --> 00:06:31.792
是一个竟用条件
我想一次次地运行同样的调试顺序

00:06:31.859 --> 00:06:34.695
我也有个特殊选项可以实现

00:06:35.662 --> 00:06:38.832
LLDB -- batch
启动批处理模式

00:06:39.066 --> 00:06:43.804
那将执行我提供的指令
从单行命令或从文件中获得

00:06:44.338 --> 00:06:48.041
并且假设我的应用正常运行
然后正常退出

00:06:48.942 --> 00:06:50.511
如果应用崩溃

00:06:50.577 --> 00:06:53.847
它会在LLDB提示框中停止
我可以查找问题所在

00:06:54.615 --> 00:06:58.085
当然 我可以用其他窗口命令
把它打包

00:06:58.151 --> 00:07:01.088
无限重复那一系列动作

00:07:01.154 --> 00:07:04.925
或者至少直到应用崩溃
并且我也准备好调查问题了

00:07:07.060 --> 00:07:09.496
LLDB有大量的选项

00:07:09.563 --> 00:07:11.932
如果你之前没有看过
LLDB -- help

00:07:11.999 --> 00:07:15.235
我建议你看一看 帮助文档中描述了
这些选项以及更多的内容

00:07:17.604 --> 00:07:21.675
我要在这里介绍一个非常有趣的概念

00:07:22.209 --> 00:07:25.345
这可能是整场演讲中
最无关紧要的事了

00:07:25.412 --> 00:07:28.382
那么 如果你打算忘记某张幻灯片
请从这张开始

00:07:29.550 --> 00:07:32.886
因为它大部分是透明的
你可能没注意到效果

00:07:32.953 --> 00:07:35.856
我还想要介绍一些微妙的地方

00:07:36.089 --> 00:07:37.491
从Xcode 8开始

00:07:37.558 --> 00:07:40.928
LLDB已经从Xcode的程序中
完全分离

00:07:41.094 --> 00:07:42.462
它对你完全透明

00:07:42.529 --> 00:07:44.531
你按照你一般的调试方式开始调试

00:07:45.065 --> 00:07:49.403
支持多个不同的调试器版本

00:07:50.237 --> 00:07:51.905
它会自动为你选择

00:07:51.972 --> 00:07:55.409
因此 如果我要调试Swift 3
我会得到最新的调试器

00:07:55.475 --> 00:07:58.312
有我们在这场演讲中介绍的所有功能

00:07:58.378 --> 00:08:02.883
其实若我使用纯C++或
Objective C 也是一样的

00:08:02.950 --> 00:08:06.186
我会得到最新的调试器
拥有我们在这里讲的所有功能

00:08:07.187 --> 00:08:09.590
另一方面
如果我调试Swift 2.3

00:08:09.656 --> 00:08:11.258
我将得到一个调试器

00:08:11.325 --> 00:08:16.263
其实是跟我们今年早些时候发布
Xcode 7.3.1时一起发布的

00:08:16.730 --> 00:08:18.765
意思是 有些新命令不可用

00:08:18.832 --> 00:08:23.237
但我们支持自Swift编译器
时代的全部调试器

00:08:25.873 --> 00:08:27.307
但最重要的是

00:08:27.374 --> 00:08:29.176
如果你是我们开源社区中的一员

00:08:29.576 --> 00:08:32.379
你可以使用调试器进行调试

00:08:32.446 --> 00:08:35.349
该调试器与
你正使用的开源Swift匹配

00:08:35.414 --> 00:08:37.985
因此 如果你下载正在开发中的快照

00:08:38.051 --> 00:08:40.453
或如果你开始添加代码

00:08:40.520 --> 00:08:42.756
那么调试器会立即可用

00:08:42.823 --> 00:08:44.458
你可以使用那个

00:08:44.525 --> 00:08:48.662
同时调试在Swift 3或
Swift 2.3中写的程序

00:08:48.729 --> 00:08:50.697
一切都是完全透明的

00:08:52.065 --> 00:08:54.168
有一个额外的好处：

00:08:54.234 --> 00:08:57.905
如果LLDB陷入了一个
不能继续的情况

00:08:57.971 --> 00:09:00.040
它需要关闭调试会话

00:09:00.240 --> 00:09:01.742
调试会话将会被终止

00:09:01.808 --> 00:09:05.078
LLDB可以优雅地退出
而Xcode将继续运行

00:09:09.082 --> 00:09:13.153
说起如何利用LLDB这个强大的工具

00:09:13.620 --> 00:09:17.191
以及如何自定义你的体验
我要邀请我们的一位工程师上台

00:09:17.257 --> 00:09:18.392
Enrico Granata

00:09:24.498 --> 00:09:26.400
谢谢Kate 大家好

00:09:27.267 --> 00:09:32.139
对于LLDB
我最看好的是调试器的定制性

00:09:32.573 --> 00:09:36.577
开启调试器定制技术
不仅能收获很大的乐趣

00:09:36.643 --> 00:09:39.847
还能让你在调试应用的过程中

00:09:39.913 --> 00:09:41.582
获得令人惊叹的效率

00:09:41.648 --> 00:09:46.353
LLDB提供许多切入点
你可以进行自定义

00:09:46.820 --> 00:09:48.755
你可以从命令别名开始

00:09:48.822 --> 00:09:53.160
然后以你的方式定制命令
或定制数据格式化程序

00:09:53.227 --> 00:09:56.964
在Xcode 8中
我们有一个新的扩展点

00:09:57.097 --> 00:09:58.498
阶梯效应

00:09:59.700 --> 00:10:04.371
考虑阶梯效应的方式是你想
让下一行命令做什么？

00:10:04.438 --> 00:10:06.240
你想让阶梯命令做什么？

00:10:06.306 --> 00:10:09.276
但你是否发现你自己想要
以一种或两种方式随处

00:10:09.343 --> 00:10:11.578
调整它的行为？

00:10:11.912 --> 00:10:14.581
通过阶梯效应 你全部可以实现

00:10:15.682 --> 00:10:21.054
但使LLDB...自定义LLDB
满足你需求的最简单方式

00:10:21.121 --> 00:10:22.589
是创建一个命令别名

00:10:22.923 --> 00:10:25.592
这种方式需要取一段你频繁使用的

00:10:25.659 --> 00:10:27.761
调试器语句

00:10:27.828 --> 00:10:30.531
并给它附上一段短语句

00:10:31.064 --> 00:10:36.537
现在 在Xcode 8中
你还可以附上帮助文本

00:10:36.603 --> 00:10:38.972
这样可以达到你自己的或跟你一起分享

00:10:39.039 --> 00:10:41.842
那些别名的人目的

00:10:41.909 --> 00:10:44.144
可以帮你记住别名是干什么用的

00:10:44.678 --> 00:10:45.712
让我们来看个例子

00:10:46.780 --> 00:10:50.384
首先 要创建别名
从command alias命令起

00:10:50.851 --> 00:10:54.154
然后 正如我刚说过的
你可以附上帮助文本

00:10:54.421 --> 00:10:57.491
你提供给我们一段短语句

00:10:57.791 --> 00:11:00.661
然后给我们一个你想要替换的
完整的调试器命令

00:11:01.261 --> 00:11:05.065
shell现在就是个正常的调试器命令

00:11:05.132 --> 00:11:07.334
跟我们内建的其他命令一样

00:11:07.534 --> 00:11:09.503
你可以 比如 help shell

00:11:09.770 --> 00:11:13.607
它会显示那些你定义的帮助文本

00:11:14.408 --> 00:11:19.012
在这些情况下 调试变得有些粗糙

00:11:19.079 --> 00:11:22.649
你可能在查找漏洞时忘记你自己是谁

00:11:22.716 --> 00:11:25.352
你可以要求调试器提醒你的身份

00:11:25.686 --> 00:11:28.655
它会像这样通知你 我是Enrico

00:11:29.423 --> 00:11:33.060
这很棒 但如果你想做一些
更高级的事儿

00:11:33.126 --> 00:11:35.495
而不仅仅是给现有命令
附上一个新名称

00:11:35.829 --> 00:11:38.265
我们还公布了一Python API

00:11:38.532 --> 00:11:40.501
这是一个有相当广泛选项的模型

00:11:40.567 --> 00:11:43.003
可以让你按照你的意愿绑定调试器

00:11:43.871 --> 00:11:46.340
相当容易上手

00:11:46.673 --> 00:11:50.177
我们在之前的WWDC演讲中
曾详细阐述过这个工具

00:11:50.244 --> 00:11:51.678
你可以看一下在线视频

00:11:52.212 --> 00:11:55.682
我们有个网站 里面有文档和示例

00:11:56.016 --> 00:11:59.353
你可以在线搜索一下

00:11:59.553 --> 00:12:01.555
有一个社区在LLDB脚本处理方面

00:12:01.622 --> 00:12:02.990
做得很棒

00:12:03.891 --> 00:12:05.392
让我们快速地看一个例子

00:12:05.959 --> 00:12:10.464
假如 我想要一个命令
可以让我检索

00:12:10.531 --> 00:12:13.800
调试时退出的最后一个函数的返回值

00:12:14.601 --> 00:12:15.736
这里有一些注意事项

00:12:16.336 --> 00:12:20.607
这个命令只有在你执行完函数
并且之后不再执行任何

00:12:20.674 --> 00:12:23.877
阶梯效应后
才起作用

00:12:24.111 --> 00:12:26.680
你可以键入表达式
你可以查看变量

00:12:26.747 --> 00:12:28.482
只要不单步跳过就没问题

00:12:28.916 --> 00:12:30.651
让我们快速看一个例子

00:12:30.984 --> 00:12:34.788
你导入一个包含那个命令的文件

00:12:35.255 --> 00:12:37.991
然后 正如我所说的
执行完函数

00:12:38.058 --> 00:12:40.527
就能看到返回值

00:12:40.627 --> 00:12:41.728
好的 很棒

00:12:41.795 --> 00:12:44.598
这是默认的 不需要自定义

00:12:44.765 --> 00:12:48.202
但是 比如说 如果我键入回溯

00:12:48.468 --> 00:12:51.271
这是个冗余的回溯

00:12:51.338 --> 00:12:53.807
现在 我不记得返回值在哪儿了

00:12:54.007 --> 00:12:56.710
好的 我会进入终端
尝试把它挖掘出来

00:12:56.977 --> 00:12:58.645
但是很幸运

00:12:58.979 --> 00:13:01.582
我们实际上可以写一个命令
告诉我们答案

00:13:01.915 --> 00:13:04.985
从而再次得到返回值

00:13:07.087 --> 00:13:09.623
这就是再次得到返回值要做的
所有工作

00:13:09.857 --> 00:13:12.826
另外 不要再担心读取那个值了

00:13:12.893 --> 00:13:15.162
它会一直在那儿

00:13:16.196 --> 00:13:19.766
另一方面 你看到那是个文本

00:13:19.833 --> 00:13:23.370
现在你可以键入你的别名shell
键入文本

00:13:23.670 --> 00:13:25.606
你会发现你自己键入这些内容

00:13:25.672 --> 00:13:27.808
是因为每次你开始调试时
它们都很棒

00:13:27.875 --> 00:13:29.810
你会一次一次再一次地键入它们

00:13:29.877 --> 00:13:34.281
直到你变成一只会打字的猴子
你要做的就是键入这些内容

00:13:34.848 --> 00:13:36.884
不 我要说不

00:13:37.150 --> 00:13:40.554
我要说不要再让你自己重复键入了

00:13:40.921 --> 00:13:41.989
完全没必要

00:13:42.055 --> 00:13:44.157
LLDB有一个初始化文件

00:13:44.558 --> 00:13:48.529
叫做.llbdinit
就在你的主文件夹中

00:13:49.463 --> 00:13:53.033
如果你需要LLDB做一些特别的事
一些不同的事

00:13:53.100 --> 00:13:56.503
在Xcode下启动或终端下启动时

00:13:57.671 --> 00:14:00.340
有一个.llbdinit -Xcode文件

00:14:00.541 --> 00:14:04.511
当在Xcode下的调试器中启动时
很好用

00:14:05.279 --> 00:14:06.380
还有一个诀窍

00:14:06.680 --> 00:14:09.750
如果你需要在调试器启动时
带有Python命令

00:14:10.050 --> 00:14:12.853
请不要把它们键入
.llbdinit中

00:14:13.120 --> 00:14:17.191
而是要把它们放在一个.py文件中
然后source该.py文件

00:14:17.524 --> 00:14:20.494
在.llbdinit中导入命令脚本

00:14:23.530 --> 00:14:26.967
如果你们用过LLDB

00:14:27.467 --> 00:14:30.604
你很可能非常熟悉p和po命令

00:14:31.305 --> 00:14:32.906
这些是很不错的命令

00:14:33.207 --> 00:14:37.611
可以查找数据
因为它们是完全表达式

00:14:38.078 --> 00:14:41.815
它们有你编写应用所使用的语言的
全部功能

00:14:41.882 --> 00:14:44.051
你可以在调试器控制台上使用

00:14:44.918 --> 00:14:48.288
另外 强大的功能伴随着
重大的责任

00:14:49.156 --> 00:14:52.593
这些命令在你的目标进程中
运行代码

00:14:52.726 --> 00:14:55.429
它们可能会导致一些副作用

00:14:55.729 --> 00:14:58.866
有时候 几乎不可能

00:14:58.932 --> 00:15:01.768
在你当前停止的点上运行代码

00:15:02.769 --> 00:15:07.508
如果p运行了一次代码
那么po实际上将运行两次代码

00:15:07.875 --> 00:15:11.245
因为它不仅会评估你提供的表达式

00:15:11.311 --> 00:15:14.481
还会评估代码

00:15:14.548 --> 00:15:17.384
以便以一种作者可定制的方式

00:15:17.451 --> 00:15:19.920
打印你的自定义类型

00:15:20.954 --> 00:15:25.359
这种方式很棒 如果作者给他们的类型
完全按照你想要的方式

00:15:25.425 --> 00:15:27.194
定制了显示

00:15:27.661 --> 00:15:28.996
如果你没那么幸运

00:15:29.263 --> 00:15:32.099
p命令提供另一种变量视角

00:15:32.165 --> 00:15:33.767
可能更接近你想要的

00:15:34.468 --> 00:15:38.105
同时po是一个运行两次的命令

00:15:38.172 --> 00:15:41.608
在编码你的目标进程时也很可能
会产生副作用

00:15:42.643 --> 00:15:43.777
如果你担心这个问题

00:15:44.311 --> 00:15:48.148
我们有另一个查看变量的
命令frame variable

00:15:48.549 --> 00:15:52.352
这是个可预见的命令
它不会运行任何代码

00:15:52.953 --> 00:15:53.921
另一方面

00:15:53.987 --> 00:15:56.423
因为它没有运行代码的能力

00:15:56.690 --> 00:15:59.860
它提供的语句也极其有限

00:16:01.562 --> 00:16:04.031
现在有很多方法可以查看数据

00:16:04.431 --> 00:16:08.969
但是剧透一下 在Xcode 8中
我们有更多方式来实现

00:16:10.771 --> 00:16:14.141
有两种新方式
分别是parray和poarray

00:16:14.875 --> 00:16:17.644
是的 你说对了 听起来像p和po

00:16:17.878 --> 00:16:20.347
但它们可以专门处理数组

00:16:21.415 --> 00:16:23.417
它们如何专门处理数组？

00:16:23.984 --> 00:16:24.818
嗯

00:16:26.019 --> 00:16:31.058
如果你在Objective C
或Swift数组中用过NS数组

00:16:31.124 --> 00:16:35.762
你习惯于安全容器
该容器知道包含了多少东西

00:16:36.296 --> 00:16:38.065
C指针并不能了解这个信息

00:16:38.265 --> 00:16:40.901
C指针并不包含某种电量模块

00:16:41.068 --> 00:16:43.403
它们不知道要指向多少元素

00:16:43.637 --> 00:16:48.709
那么 当我们像在这个调试器中
打印C指针时

00:16:49.042 --> 00:16:51.612
我们所能了解的只是指针的值

00:16:52.479 --> 00:16:54.581
但现在我们知道它指向一群元素

00:16:54.648 --> 00:16:56.717
所以我们可以开始打印第一个

00:16:57.117 --> 00:16:58.285
打印第二个

00:16:58.886 --> 00:17:01.889
继续依次打印 现在我们又变成
那只打字的小猴子了

00:17:01.955 --> 00:17:03.290
我们并不想这样

00:17:04.858 --> 00:17:05.692
嗯

00:17:06.859 --> 00:17:11.265
在Xcode 8中 你可以这样处理
parray 元素个数 指针

00:17:11.665 --> 00:17:13.800
这会扩展指针

00:17:13.867 --> 00:17:17.171
就像指定元素个数的一个数组一样

00:17:18.872 --> 00:17:20.641
谢谢 谢谢

00:17:22.409 --> 00:17:26.914
这个方案已经很好了 但我为什么
要猜测元素个数呢？

00:17:27.481 --> 00:17:30.150
它就在那儿 个数就在那儿

00:17:30.217 --> 00:17:35.422
我真正想要的是能键入parray
个数 数据集

00:17:36.456 --> 00:17:37.791
几乎就要实现了

00:17:38.192 --> 00:17:40.894
我要做的就是把count
放在倒引号中

00:17:41.428 --> 00:17:45.365
那个倒引号是个常用的
LLDB语法功能

00:17:45.432 --> 00:17:48.168
可以让你取出表达式
并进行评估

00:17:48.235 --> 00:17:52.005
然后在执行命令之前 在命令中
替换那个表达式的值

00:17:52.739 --> 00:17:55.509
现在 我已经显示出了完整的数组

00:17:57.678 --> 00:17:58.512
谢谢大家

00:18:02.149 --> 00:18:04.384
而po也一样

00:18:04.451 --> 00:18:06.453
poarray 元素个数

00:18:07.387 --> 00:18:10.891
指针 然后我得到了po式的对象描述

00:18:11.859 --> 00:18:13.961
在po的话题上

00:18:14.261 --> 00:18:17.965
我确定你们可以
写Objective C代码

00:18:18.031 --> 00:18:19.233
我确定有不少人

00:18:19.299 --> 00:18:23.704
就是那样实现的
很可能没有认真思考过

00:18:24.271 --> 00:18:25.906
你取出po 键入po

00:18:25.973 --> 00:18:29.176
接着是一个数字
恰巧你知道是个指针值

00:18:29.243 --> 00:18:31.111
然后你取回一个非常漂亮的描述

00:18:31.745 --> 00:18:35.916
你在Swift中尝试做同样的事
你取回的只是个数字

00:18:36.183 --> 00:18:37.784
为什么？怎么回事？

00:18:38.685 --> 00:18:42.122
嗯 我确定你不止一次
听过这样的事

00:18:42.189 --> 00:18:43.824
但我再说一次

00:18:44.091 --> 00:18:46.994
Swift是一种比
Objective C类型更安全的语言

00:18:47.194 --> 00:18:50.130
我们不能假设数字是任意对象

00:18:50.197 --> 00:18:53.634
因为并不是所有的Swift对象
都关联着一个指针值

00:18:53.967 --> 00:18:57.471
那么当我们po一个数字时
我们会得到数字

00:18:58.405 --> 00:19:01.408
好的 这很棒 但拜托
我知道那儿有个对象

00:19:01.475 --> 00:19:02.876
刚刚已经显示出来了

00:19:03.677 --> 00:19:04.978
有一种方式可以实现

00:19:06.613 --> 00:19:07.447
就是这个

00:19:08.081 --> 00:19:10.651
看起来有很多词 我知道

00:19:10.717 --> 00:19:13.020
但它实际上...听我讲

00:19:13.353 --> 00:19:16.757
expr -O的意思是po

00:19:17.291 --> 00:19:20.260
如果你在LLDB控制台中
键入help po

00:19:20.460 --> 00:19:24.498
它将告诉你那是expr -O的
一个别名

00:19:25.065 --> 00:19:27.201
那么我们实际上在这里键入的是

00:19:27.534 --> 00:19:30.904
po这个东西 就像我们在
Objective C代码中做的那样

00:19:31.438 --> 00:19:35.075
这样 我们实际上会得到
我们想要的描述

00:19:36.577 --> 00:19:37.644
这很棒

00:19:38.312 --> 00:19:42.349
在一个实际检验内存地址
相关的主题上

00:19:42.416 --> 00:19:43.984
并尝试搞清楚它们的

00:19:45.285 --> 00:19:46.653
底层调试

00:19:47.487 --> 00:19:51.458
关于底层调试
如果你只记得一件事

00:19:51.725 --> 00:19:54.394
那就是离它越远越好

00:19:54.628 --> 00:19:55.762
不要碰底层调试

00:19:59.399 --> 00:20:03.170
很不幸的是 有时候你必须得碰

00:20:03.904 --> 00:20:07.307
也许你要调试只存在于
你应用发布版本中

00:20:07.374 --> 00:20:08.842
优化代码的东西

00:20:08.909 --> 00:20:10.377
我有时候会遇到这种情况

00:20:11.245 --> 00:20:15.716
或者你要调试第三方代码
而你没有任何调试信息

00:20:16.583 --> 00:20:18.118
如果出现以上任意一种情况

00:20:18.719 --> 00:20:22.990
那么请听我讲 在这段旅程中
我们将穿越赫丘利斯之柱

00:20:24.091 --> 00:20:29.129
但请注意 在这段旅程中
如要前行 风险自担

00:20:31.598 --> 00:20:33.500
就像这样开始

00:20:34.101 --> 00:20:37.004
去年 有一位先生来到我的实验室

00:20:37.070 --> 00:20:40.307
拿着他的笔记本电脑
让我看那种状态下的Xcode

00:20:40.374 --> 00:20:43.210
在Objc msgSend中崩溃了

00:20:43.844 --> 00:20:45.112
他给我讲了一个故事

00:20:45.512 --> 00:20:48.916
我在商店中有个应用
很棒

00:20:49.249 --> 00:20:50.918
然后 我的框架供应商对我说

00:20:50.984 --> 00:20:54.588
“嘿 我的框架有新版本了
更新一下吧 没问题的 ”

00:20:54.955 --> 00:20:58.158
我就更新了 我听了他的话
然后现在 我的应用一启动就崩溃

00:20:58.225 --> 00:20:59.793
我该怎么做 请帮帮我

00:21:00.394 --> 00:21:04.831
然后 我们坐下来 我告诉他说
“嗯 我们几乎都不了解情况

00:21:04.898 --> 00:21:09.837
但有一件事我们可以做...
就是开始读取机器寄存器”

00:21:10.604 --> 00:21:12.806
LLDB有一个功能可以实现
读取寄存器

00:21:12.873 --> 00:21:17.010
它允许你查看所有寄存器
其中只有一小部分寄存器

00:21:17.077 --> 00:21:19.313
甚至会允许你进行
自定义格式化

00:21:19.947 --> 00:21:21.048
它是什么样的呢？

00:21:21.815 --> 00:21:23.016
键入register read

00:21:24.218 --> 00:21:25.853
你将得到你的寄存器的值

00:21:26.753 --> 00:21:27.988
这里有很多寄存器

00:21:28.055 --> 00:21:32.426
那么 我为什么要关心屏幕上所有
这些怪异的数字和文字呢？

00:21:32.626 --> 00:21:34.061
嗯 你一定要关心

00:21:35.095 --> 00:21:38.265
因为参数通常是在寄存器中
进行传递的

00:21:38.832 --> 00:21:41.268
好的 很好玩儿
但寄存器也太多了

00:21:41.335 --> 00:21:43.637
我如何了解实际上哪个
比较重要呢？

00:21:44.204 --> 00:21:49.610
这个问题要问你平台应用的
二进制ABI接口

00:21:49.676 --> 00:21:51.812
：convention
会提供一些规则

00:21:52.479 --> 00:21:54.815
但LLDB还提供

00:21:54.882 --> 00:21:59.553
便捷的伪寄存器的命名
像$arg1 $arg2等等

00:21:59.620 --> 00:22:04.057
适用于参数为简单计数器的情况

00:22:04.124 --> 00:22:05.492
或指针类型

00:22:05.559 --> 00:22:09.363
实际上寄存器和参数是一一对应的

00:22:10.030 --> 00:22:13.700
在C阵营表达式中也有类似的便捷方式

00:22:14.368 --> 00:22:15.502
比如说

00:22:16.537 --> 00:22:20.207
如果我有个函数读取这三个参数
然后我调用函数

00:22:20.874 --> 00:22:26.313
这些参数实际上将一对一映射为
$arg1 $arg2和$arg3

00:22:27.648 --> 00:22:30.217
好的 这符合我们的情况

00:22:30.284 --> 00:22:33.987
在Objc msgSend中
我们开始读取参数

00:22:34.521 --> 00:22:37.491
第一个参数是
指针 0 X 4 D 2

00:22:37.724 --> 00:22:40.894
第二个参数是选择器符字符
紧接着一个附加字符

00:22:41.361 --> 00:22:44.531
我们恰巧知道Objc
msgSends的第一个参数

00:22:44.598 --> 00:22:46.667
是我们尝试与对象
进行通讯的参数

00:22:46.733 --> 00:22:49.436
第二个参数是我们尝试
要发送的选择符

00:22:50.204 --> 00:22:52.506
且我们还可使用
memory read命令

00:22:52.573 --> 00:22:55.375
来查看我们要通讯的那个对象
到底怎么了

00:22:55.809 --> 00:22:57.711
原来那是个不好的对象

00:23:01.582 --> 00:23:02.616
实际情况是

00:23:02.683 --> 00:23:05.552
我们在一个坏的对象上调用
这个选择符

00:23:06.053 --> 00:23:07.387
我们是如何变成这样的呢？

00:23:09.189 --> 00:23:12.626
嗯 在Objc msgSend中
崩溃了

00:23:12.960 --> 00:23:16.964
有东西调用了Objc msgSend
有东西调用了那个调用Objc msgSend的东西

00:23:17.030 --> 00:23:18.332
以此类推

00:23:18.398 --> 00:23:21.768
直到我们到达应用的切入点

00:23:22.603 --> 00:23:27.307
在LLDB中 我们从最小的
框架0开始调用

00:23:27.574 --> 00:23:30.511
一直到最大的框架N

00:23:30.978 --> 00:23:32.813
并且 如果你想移动到某个框架

00:23:33.113 --> 00:23:34.648
你可以使用up命令

00:23:34.715 --> 00:23:37.417
返回到堆栈上的一个编号较大的框架

00:23:37.484 --> 00:23:40.554
down命令可以返回到
编号较小的框架

00:23:42.656 --> 00:23:46.126
另一个需要了解的是
disassemble命令

00:23:46.193 --> 00:23:48.862
可以让你反汇编一个函数

00:23:49.363 --> 00:23:52.399
你可以用在当前函数、任意框架、

00:23:52.633 --> 00:23:54.902
地址、函数名称上

00:23:55.102 --> 00:23:57.437
你可以自定义反汇编的显示方式

00:23:57.738 --> 00:24:00.207
在某些情况下 它会在有源代码

00:24:00.407 --> 00:24:02.476
和调试信息的地方执行调试

00:24:02.543 --> 00:24:05.879
但如果你想比较这些指令
和机器指令

00:24:05.946 --> 00:24:11.518
你还可以让LLDB总是随着
源代码一起显示反汇编

00:24:12.052 --> 00:24:13.153
那么在我们的例子中

00:24:14.855 --> 00:24:17.925
我们在那儿崩溃了 我们可以
看到谁调用了函数

00:24:17.991 --> 00:24:19.793
是一个启动完成的应用

00:24:20.027 --> 00:24:23.764
让我们快速看一眼那个函数
正在做什么

00:24:26.667 --> 00:24:29.069
那个函数正在调用这个
初始化程序

00:24:29.136 --> 00:24:33.240
框架供应商告诉我们 “是的
编码那个初始化程序getGlobalToken”

00:24:33.607 --> 00:24:35.375
它正在来回来去地填充东西

00:24:35.442 --> 00:24:39.179
然后调用Objc msgSend
我们就崩溃了

00:24:40.514 --> 00:24:44.952
那么我们可以单步跳过机器编码
并查看这些调用实际上是在做什么

00:24:45.219 --> 00:24:48.755
首先 我们单步跳过
getGlobalToken调用

00:24:49.189 --> 00:24:52.125
然后我要做个弊

00:24:52.392 --> 00:24:56.029
我恰巧知道寄存器叫做rax

00:24:56.296 --> 00:24:58.398
包含那个函数的返回值

00:24:58.665 --> 00:24:59.900
若我读取这个函数返回值

00:25:01.568 --> 00:25:03.470
我只能得到不正确的指针值

00:25:03.937 --> 00:25:05.138
有意思

00:25:05.472 --> 00:25:07.708
让我们再做几次单步跳过

00:25:08.208 --> 00:25:10.677
不 并没有修改它 并没有修改它

00:25:11.211 --> 00:25:14.815
我们正在做的是取出那个指针值
不做任何修改

00:25:14.882 --> 00:25:16.783
并把它移动到rdi中

00:25:17.150 --> 00:25:19.720
然后调用Objc msgSend

00:25:20.153 --> 00:25:21.722
我在想是否关联？

00:25:22.289 --> 00:25:25.626
如果我在这时候
在进入Objc msgSend之前

00:25:25.826 --> 00:25:28.662
reg read $arg1

00:25:30.264 --> 00:25:32.366
rdi是不正确的指针值

00:25:33.600 --> 00:25:35.369
我们证明了什么呢？

00:25:35.435 --> 00:25:38.705
我们证明了
getGlobalToken函数

00:25:38.772 --> 00:25:41.575
就是我们的框架供应商非常激动地
让我们调用的函数

00:25:41.642 --> 00:25:43.844
实际上给我们返回了一个
不正确的对象

00:25:44.044 --> 00:25:47.080
一尝试给那个不正确的对象
发送消息

00:25:47.414 --> 00:25:50.584
就会收到一个大惊喜
我们的应用就会崩溃

00:25:51.318 --> 00:25:53.754
最后验证了我们的情况后

00:25:53.820 --> 00:25:55.822
轻轻拍了拍我们的背

00:25:56.156 --> 00:25:58.258
接着有请
Sean Callanan上台

00:25:58.325 --> 00:26:01.595
他会讲解表达式解析器
相关的新特性 谢谢

00:26:07.734 --> 00:26:08.836
不觉得神奇吗？

00:26:09.203 --> 00:26:10.237
感觉像魔术一样

00:26:10.304 --> 00:26:13.740
你的程序只是把数据以数字、数字数组

00:26:14.041 --> 00:26:15.475
的方式进行存储

00:26:16.109 --> 00:26:19.012
但你可以用LLDB这个强大的工具

00:26:19.446 --> 00:26:22.983
以你想要的方式来表现数据

00:26:25.219 --> 00:26:26.286
有时候

00:26:26.720 --> 00:26:30.624
并不是只看数字和判断是什么数据

00:26:31.225 --> 00:26:32.860
那么容易

00:26:33.861 --> 00:26:36.330
有时候你需要使用表达式解析器

00:26:37.164 --> 00:26:38.632
Enrico已经展示了

00:26:38.699 --> 00:26:42.269
表达式解析器在一般情况下的
命令语句

00:26:42.636 --> 00:26:44.404
但是它还有好多功能

00:26:45.572 --> 00:26:50.878
表达式解析器的工作是跟你的程序
和SDK一起运行

00:26:51.745 --> 00:26:54.882
在你当前的断点上

00:26:55.582 --> 00:27:00.120
表达式解析器通过变形数据
来得到你想要

00:27:01.054 --> 00:27:04.057
实际检测的数据

00:27:05.559 --> 00:27:10.831
我说过
程序和SDK是一起运行的

00:27:11.732 --> 00:27:15.636
回忆一下前几年的情况
SDK在LLDB中运行

00:27:15.702 --> 00:27:17.571
并不总是那么容易

00:27:18.939 --> 00:27:22.109
那么比如说 如果你在
Objective C程序上断点了

00:27:22.576 --> 00:27:25.812
你尝试获取程序的撤销管理器

00:27:27.247 --> 00:27:31.919
你很可能会得到至少一次
或两次烦人的报错

00:27:33.020 --> 00:27:37.024
这跟你正在尝试做的完全无关

00:27:37.858 --> 00:27:39.193
真是莫名其妙

00:27:39.726 --> 00:27:42.429
但是去年我们就讲了一个
解决方式

00:27:44.364 --> 00:27:48.368
如果你手动导入AppKit

00:27:49.736 --> 00:27:52.606
那么你的表达式就能起作用了

00:27:53.273 --> 00:27:56.677
好吧 但是我们为什么要这么做呢？
它已经在那儿了

00:27:58.445 --> 00:27:59.479
我都能听见你在哀嚎

00:28:02.516 --> 00:28:03.750
并非只有你一个人遇到这种情况

00:28:05.052 --> 00:28:09.323
因此今年我们考虑如何使这个
方式变得更好

00:28:10.290 --> 00:28:11.558
效果非常明显

00:28:12.259 --> 00:28:15.462
我们查看了当前源文件导入的
那个模块

00:28:16.129 --> 00:28:18.332
然后就自动导入

00:28:18.532 --> 00:28:20.868
不再需要手动导入了

00:28:26.807 --> 00:28:27.641
很酷

00:28:27.708 --> 00:28:30.544
我们可以更有效地摆脱
手动实现方式

00:28:30.878 --> 00:28:34.348
非常棒 但我们认为这是一个
很强大的工具

00:28:34.815 --> 00:28:39.353
让我来讲一下这个工具的一些
不错的功能

00:28:40.687 --> 00:28:44.424
现在 有时候 这种便捷可能会
阻碍你的开发

00:28:44.491 --> 00:28:48.328
你实际上想手动地导入
你想要的东西

00:28:49.263 --> 00:28:50.464
有个功能可以实现

00:28:50.764 --> 00:28:55.102
有一个设置
你可以禁用自动导入功能

00:28:55.169 --> 00:28:58.071
然后你就能使用去年的老功能了

00:28:58.972 --> 00:29:01.608
我们认为你一定会喜欢上这个功能
它的默认状态为开启

00:29:02.709 --> 00:29:03.544
很好

00:29:03.877 --> 00:29:07.881
现在 让我们谈谈
如何通过重用代码

00:29:08.448 --> 00:29:10.017
有效地使用表达式解析器

00:29:11.985 --> 00:29:16.790
重用代码最简单的情况是
重用变量

00:29:17.758 --> 00:29:22.162
请记住 我说过
你可能需要做多级表达式

00:29:22.596 --> 00:29:26.433
从你当前位置获得你实际
想要的数据

00:29:27.701 --> 00:29:32.706
在Swift中 你可以执行像定义
和使用

00:29:33.006 --> 00:29:33.841
临时变量那么简单的操作

00:29:35.175 --> 00:29:37.978
这就能解决问题 就像你在你自己的
程序中键入一样

00:29:39.313 --> 00:29:43.684
现在 可能会超出你想象的是如果
你再次使用它 会发生什么

00:29:44.818 --> 00:29:47.221
那么我们会问
变量名称是什么？

00:29:49.122 --> 00:29:52.526
嗯 实际上我们刻意
让它这样工作

00:29:53.060 --> 00:29:56.230
原因是你可能会单步跳过

00:29:56.296 --> 00:29:58.365
你可能会在不同的地方设置断点

00:29:58.432 --> 00:30:02.603
也许稍后 你会位于一个程序
定义A的地方

00:30:02.836 --> 00:30:06.273
我们希望作为临时变量的A
给你带来阻碍吗？

00:30:07.174 --> 00:30:10.777
很可能不希望
但有一个解决方法

00:30:14.047 --> 00:30:16.517
我们可以设置一个功能可见性

00:30:16.917 --> 00:30:20.087
确保你的变量不会像那样消失

00:30:20.153 --> 00:30:22.222
实际上我们会设置一个
本地环境

00:30:22.289 --> 00:30:25.626
就像你在程序中添加了
一对大括号

00:30:25.959 --> 00:30:28.195
把let A放在大括号中
然后是打印

00:30:29.329 --> 00:30:31.365
但是如果你想让A起作用

00:30:31.798 --> 00:30:34.401
你要做的就是给它一个专用名称

00:30:34.868 --> 00:30:36.336
一个名称外加$符号

00:30:37.171 --> 00:30:40.941
意思是 它将永远不会跟你自己的
程序名称冲突

00:30:41.875 --> 00:30:45.846
这意味着只要你的调试会话存在
它就会存在

00:30:47.080 --> 00:30:47.915
了不起

00:30:48.448 --> 00:30:51.251
你还可以用这个工具做什么？
可以做很多

00:30:52.719 --> 00:30:55.956
在Swift中
自LLDB和Swift发布的第一天起

00:30:56.023 --> 00:30:58.559
你就可以用函数来解决
同样的问题

00:30:59.626 --> 00:31:01.328
现在 当你解决问题时

00:31:01.395 --> 00:31:05.132
你很可能想要使用
多行表达式模式

00:31:05.199 --> 00:31:08.101
事实上 如果你键入表达式命令
并按下Enter键

00:31:08.168 --> 00:31:10.504
你会立即打开一个多行编辑器

00:31:10.571 --> 00:31:12.873
你可以键入你自己的函数

00:31:13.640 --> 00:31:15.108
如果你定义你的函数

00:31:15.843 --> 00:31:20.514
你就可以简便地重用这个函数
请不要忘了$符号

00:31:22.015 --> 00:31:25.853
若你们曾在Swift中尝试过
这样做并且说过“太棒了！”

00:31:26.286 --> 00:31:28.155
你可能在Objective C中
也尝试过了

00:31:29.690 --> 00:31:32.492
效果并没那么好

00:31:34.061 --> 00:31:36.296
这里不允许函数定义

00:31:36.630 --> 00:31:38.999
“不是吧 LLDB那东西
总是会妨碍我 ”

00:31:39.399 --> 00:31:43.837
好吧 嗯 看起来我们
也喜欢这个功能

00:31:43.904 --> 00:31:45.739
我们认为这功能很不错
我们想让它变得更好

00:31:46.807 --> 00:31:50.110
但我们不能让它变得那么神奇

00:31:50.377 --> 00:31:54.248
因为 你记得吧
我们在你的代码中停止了

00:31:54.615 --> 00:31:57.751
我们想表现得像在你的函数内一样

00:31:58.652 --> 00:32:01.588
如果你在Swift中
你可以定义余下的函数

00:32:01.655 --> 00:32:03.690
没什么大不了的
编译器会喜欢的

00:32:03.757 --> 00:32:06.493
它不喜欢$符号
你可以去掉它

00:32:06.560 --> 00:32:08.262
但余下的就没什么问题了

00:32:08.996 --> 00:32:10.097
这完全合法

00:32:11.665 --> 00:32:14.234
但是在C、C++
和Objective C中

00:32:14.301 --> 00:32:16.970
尝试像那样处理余下的函数

00:32:17.137 --> 00:32:19.706
没有用 编译器会对你咆哮的

00:32:22.276 --> 00:32:28.715
嗯 避免方式是使用
顶层表达式模式

00:32:29.383 --> 00:32:31.752
是expression命令的
一个扩展

00:32:31.818 --> 00:32:32.986
可以使它完全脱离

00:32:33.053 --> 00:32:36.056
你停止的那个当前函数

00:32:36.123 --> 00:32:38.058
并定义全局代码

00:32:38.559 --> 00:32:41.328
可以是函数或变量或其他你想要的

00:32:42.129 --> 00:32:45.499
现在 你可以定义函数
并按照你期待的方式使用函数

00:32:46.733 --> 00:32:47.568
好的

00:32:48.502 --> 00:32:52.139
现在 函数不是你可以定义的
唯一能重用的东西

00:32:52.206 --> 00:32:55.442
我已经讲过变量了
你还可以定义闭包

00:32:55.509 --> 00:32:58.111
闭包是变量和代码的一种合并

00:32:59.146 --> 00:33:00.881
在Swift中 你可定义一个闭包

00:33:00.948 --> 00:33:01.782
并使用它

00:33:02.916 --> 00:33:04.585
今年 Xcode有了新特性

00:33:05.219 --> 00:33:07.154
你可在Objective C中
实现同样的功能

00:33:07.554 --> 00:33:09.957
你可以定义和重用块

00:33:11.124 --> 00:33:14.394
如果你是C++的铁杆粉丝

00:33:14.461 --> 00:33:16.730
你可以用匿名函数实现
完全一样的功能

00:33:18.599 --> 00:33:19.433
现在

00:33:20.501 --> 00:33:23.170
你可以用这些块做什么呢？
它们有什么特殊作用呢？

00:33:23.370 --> 00:33:25.939
嗯 比如说
你可以把它们传给函数

00:33:26.773 --> 00:33:30.611
有时候你可能需要在指定队列上
手动运行某些东西

00:33:31.845 --> 00:33:32.679
那样是可以的

00:33:33.013 --> 00:33:35.449
你可以把素材发送给
比如说 一个全局队列

00:33:35.749 --> 00:33:37.217
块就会运行

00:33:38.585 --> 00:33:39.419
现在

00:33:40.420 --> 00:33:43.123
有时候有点儿烦人

00:33:43.457 --> 00:33:49.496
因为这些复杂的表达式会增加
错别字的出现频率

00:33:50.564 --> 00:33:52.132
现在 不同的是

00:33:52.733 --> 00:33:55.469
速度很快 不用回头看之前的代码

00:33:55.536 --> 00:33:58.672
在这个表达式和之前代码中的表达式？

00:33:59.439 --> 00:34:00.607
你很可能会错过它

00:34:00.707 --> 00:34:02.276
但编译器一定不会错过它

00:34:02.943 --> 00:34:06.246
如果丢了分号
编译器会对你咆哮

00:34:07.814 --> 00:34:09.216
但还有个更好的方式

00:34:09.583 --> 00:34:13.152
如果你在源编辑器中键入
我们会告诉你

00:34:13.453 --> 00:34:16.556
“这里很可能丢失了一个分号
你想加上它吗？”

00:34:18.192 --> 00:34:21.728
嗯 看起来LLDB可以实现
同样的功能

00:34:21.995 --> 00:34:23.496
并且我们可以做得更好

00:34:23.563 --> 00:34:26.967
只需要自动添加遗失的分号

00:34:27.266 --> 00:34:28.534
然后就能运行表达式了

00:34:28.902 --> 00:34:30.571
我们管这个叫做修订

00:34:30.871 --> 00:34:34.808
以前是在Clang中使用
现在LLDB也可以实现同样的功能了

00:34:36.777 --> 00:34:38.512
Swift中也有修订

00:34:39.646 --> 00:34:42.815
在Swift中 你不太可能会遇到
分号问题

00:34:43.083 --> 00:34:45.418
但是同志们 那些感叹号很烦人

00:34:49.056 --> 00:34:53.860
是的 嗯 它们很有用 因为它们
在你自己的代码中

00:34:53.927 --> 00:34:56.096
当你调试时 帮助你理解它

00:34:56.163 --> 00:34:58.131
你只是希望它们不要阻碍你

00:34:58.599 --> 00:35:00.234
相信我 我们也是这么想的

00:35:01.668 --> 00:35:04.872
如果你尝试使用一些没有
解包的东西

00:35:06.039 --> 00:35:08.075
我们就会应用修订并为你解包

00:35:09.209 --> 00:35:12.045
现在 可能会有一两个人

00:35:12.112 --> 00:35:14.548
说“我不希望调试器碰我的代码 ”

00:35:15.048 --> 00:35:15.883
现在

00:35:18.285 --> 00:35:20.988
对于这些人 我也有过这样的顾虑

00:35:21.688 --> 00:35:23.524
我们有设置

00:35:23.824 --> 00:35:26.960
可以关闭整个自动应用修订功能

00:35:27.628 --> 00:35:31.198
如果你不喜欢调试器
自鸣得意地指出

00:35:31.265 --> 00:35:34.001
你代码中的每一个小错误
并为你修改好

00:35:34.101 --> 00:35:36.303
那么你也可以关闭那部分功能

00:35:37.871 --> 00:35:38.705
好的

00:35:39.573 --> 00:35:40.407
谢谢

00:35:44.745 --> 00:35:45.579
好了

00:35:45.846 --> 00:35:48.182
很好 这是个不错的便捷功能

00:35:48.248 --> 00:35:51.985
但是我还要提另一个

00:35:52.052 --> 00:35:53.854
你能定义为可重用的东西

00:35:55.155 --> 00:35:56.857
你可以在Swift中定义你自己的类型

00:35:57.925 --> 00:36:00.761
比如说
你可以输入多行表达式

00:36:00.827 --> 00:36:02.196
定义一个类

00:36:03.130 --> 00:36:05.933
当你尝试实例化那个类时

00:36:05.999 --> 00:36:08.435
它就是这样

00:36:08.502 --> 00:36:11.004
就像你已经在程序中
定义过的类一样

00:36:12.239 --> 00:36:17.411
在C++中也一样 你可以定义
一个类并重用它

00:36:19.513 --> 00:36:22.716
现在让我们来看个例子

00:36:22.783 --> 00:36:25.786
我们可以在你自己的程序中
使用所有这些概念

00:36:28.422 --> 00:36:32.693
通常尤其是当你的程序
与web API交互时

00:36:32.759 --> 00:36:35.229
你会得到返回的许多数据
你想要筛选数据

00:36:35.295 --> 00:36:36.797
尤其是当你正在调试时

00:36:37.698 --> 00:36:41.401
筛选数据的方式
尤其是在NS数组中

00:36:41.602 --> 00:36:43.203
是通过定义一个判断实现的

00:36:44.438 --> 00:36:48.342
现在 在表达式分析器中
你可以定义自定义判断

00:36:49.076 --> 00:36:52.346
在这种情况下 我们写一个块

00:36:52.646 --> 00:36:56.383
从web服务器取出结果字符串

00:36:56.917 --> 00:37:01.054
进行筛选 查找有文本错误的字符串

00:37:01.755 --> 00:37:03.190
很可能有利于调试

00:37:04.258 --> 00:37:09.530
现在 如果你只从web服务器
取出完整数据的数组

00:37:10.464 --> 00:37:12.432
然后就应用判断

00:37:12.599 --> 00:37:15.869
你可以立即获得
你实际关心的消息

00:37:18.338 --> 00:37:23.076
现在你已经了解表达式分析器
是如何强大了

00:37:23.143 --> 00:37:24.978
接着有请
Jim Ingham上台

00:37:25.045 --> 00:37:27.147
他会给你们讲LLDB更强大的特性

00:37:32.319 --> 00:37:33.153
谢谢 Sean

00:37:33.353 --> 00:37:36.657
目前我们已经按先后顺序

00:37:36.723 --> 00:37:40.160
讲了如何当你停止后

00:37:40.227 --> 00:37:42.529
查看程序状态 但我们还没讲

00:37:42.596 --> 00:37:44.865
如何得到这样一个有趣的点

00:37:44.932 --> 00:37:46.834
这是我要跟你们讲的内容

00:37:47.267 --> 00:37:51.839
当然 断点是停止程序的一种
顺其自然的方式

00:37:51.905 --> 00:37:56.476
那么 我想谈谈你们觉得断点
就是自然而然地

00:37:56.543 --> 00:37:59.580
在我设置断点的地方停止
我的程序

00:37:59.713 --> 00:38:03.550
但这并不是它们的实现方式
LLDB也不是这么认为的

00:38:03.750 --> 00:38:07.221
对于LLDB来说
断点其实是一个搜索

00:38:07.287 --> 00:38:10.757
在你的程序空间中寻找这些
有趣的位置以便停止

00:38:10.824 --> 00:38:13.360
事实证明也许是很多不同的搜索

00:38:14.027 --> 00:38:16.730
因此 断点其实是搜索条件

00:38:16.797 --> 00:38:20.734
你停止的个别位置

00:38:20.801 --> 00:38:23.036
就是你认为的那个
自然而然的断点

00:38:23.103 --> 00:38:25.138
我们叫做断点位置

00:38:25.372 --> 00:38:29.209
让我们具体讲一下 我要把这个
连到Xcode的断点

00:38:29.276 --> 00:38:33.447
因为不管怎样 当使用LLDB调试时
Xcode都在幕后

00:38:33.514 --> 00:38:37.217
所以 Xcode断点必须
都得是LLDB断点

00:38:37.284 --> 00:38:41.588
那么比如说 当你在Xcode中
点击源边列时

00:38:41.688 --> 00:38:44.858
你实际正在做的是在LLDB中
运行这条命令

00:38:44.925 --> 00:38:46.627
有些断点设置命令

00:38:46.894 --> 00:38:49.229
类似地 当你做符号断点时

00:38:49.296 --> 00:38:52.399
你正在运行一个按名称
设置的断点

00:38:52.833 --> 00:38:56.970
那么我想让你们有一点概念
就是这些实际上是搜索

00:38:57.037 --> 00:38:58.572
我要演示一些例子

00:38:58.639 --> 00:39:02.776
从而你可以自然而然地得到
多种结果

00:39:02.843 --> 00:39:06.146
虽然以前你觉得只是一个
单一的断点设置

00:39:06.446 --> 00:39:10.651
那么 第一个例子是符号断点

00:39:10.851 --> 00:39:14.221
这是一个只在主函数上
设置断点的例子

00:39:14.288 --> 00:39:16.156
这应该很简单 对吧？

00:39:16.223 --> 00:39:18.692
但是稍后它会告诉你
“不 我有19个位置 ”

00:39:18.759 --> 00:39:20.561
为什么最终会得到19个呢？

00:39:20.861 --> 00:39:24.398
执行break list命令是不是
查看断点设置的结果

00:39:24.464 --> 00:39:28.202
你看到的是断点名称搜索

00:39:28.268 --> 00:39:31.305
实际上是一个不精确的
名称匹配搜索

00:39:31.371 --> 00:39:35.075
那么比如说 它在一个类中
选取了选择器名称

00:39:35.142 --> 00:39:37.044
在很多情况下
这样的确很方便

00:39:37.110 --> 00:39:40.714
因为就像你在C++中调试时
你有命名空间、

00:39:40.781 --> 00:39:43.050
命名空间内部、类、方法

00:39:43.116 --> 00:39:47.154
你并不想键入整条路径

00:39:47.521 --> 00:39:48.922
另一方面 也确实意味着

00:39:48.989 --> 00:39:51.992
搜索也许比你想要的范围更广

00:39:52.526 --> 00:39:54.862
我们提供很多不同类型的搜索

00:39:54.928 --> 00:39:57.865
当然 我们提供更精确的搜索

00:39:57.931 --> 00:40:01.869
即全名搜索 强制名称匹配

00:40:01.935 --> 00:40:05.305
你指定的符号全名

00:40:05.639 --> 00:40:07.875
我们尝试过 但就算那样也不行

00:40:08.141 --> 00:40:10.911
因为某些原因
某人决定在库内加

00:40:10.978 --> 00:40:13.514
一个函数调用主函数
不知道为什么 但确实起作用了

00:40:13.814 --> 00:40:16.350
因此 你甚至可以指定

00:40:16.416 --> 00:40:19.119
通过shlib选项

00:40:19.186 --> 00:40:21.822
限制搜索特定的共享库

00:40:21.889 --> 00:40:24.558
那么最后 你就得到
你想要的断点了

00:40:24.625 --> 00:40:27.494
我要再举一个例子 不是因为
我认为你们不相信我

00:40:27.561 --> 00:40:30.297
而是因为这个例子
经常会在Swift中出现

00:40:30.364 --> 00:40:32.132
文件和行断点

00:40:32.332 --> 00:40:34.201
因为Swift有个不错的功能

00:40:34.268 --> 00:40:36.904
就是你调用一个使用闭包

00:40:36.970 --> 00:40:39.706
并定义闭包函数的函数

00:40:39.773 --> 00:40:42.709
简单地通过用波形号来继续

00:40:42.776 --> 00:40:45.012
然后接着是闭包体

00:40:45.179 --> 00:40:47.548
但是 如果你尝试在那行设置断点

00:40:47.614 --> 00:40:50.584
你就会发现有两个停止的点

00:40:50.651 --> 00:40:51.652
为什么会这样？

00:40:52.019 --> 00:40:54.688
你观察时 你觉得很简单
对吧？

00:40:54.855 --> 00:40:59.960
源代码行实际上给闭包函数
提供了一些代码

00:41:00.027 --> 00:41:03.664
你可以看到 我们在闭包函数上
有一个断点位置

00:41:03.931 --> 00:41:07.501
但是它也是函数引用的位置

00:41:07.701 --> 00:41:10.537
因此还有一个位置是
那个引用的位置

00:41:12.172 --> 00:41:14.208
那么无论怎么样 就是这样

00:41:14.274 --> 00:41:16.910
已经讲了一些例子

00:41:16.977 --> 00:41:19.079
我要给你们一个命令的通用格式

00:41:19.146 --> 00:41:22.850
然后再继续讲其他功能

00:41:23.317 --> 00:41:25.652
断点设置命令是这样的：

00:41:25.719 --> 00:41:27.187
键入break set

00:41:27.254 --> 00:41:30.390
然后有一些指定类型的选项

00:41:30.958 --> 00:41:34.661
这是指定你要进行
哪种搜索的选项

00:41:34.728 --> 00:41:36.930
是文件和行搜索
还是符号名搜索

00:41:36.997 --> 00:41:38.131
等等诸如此类？

00:41:38.198 --> 00:41:43.036
那个类型选项的值是用于
搜索的数据

00:41:43.270 --> 00:41:48.108
然后还有其他选项 比如忽略计数
条件 等等

00:41:48.175 --> 00:41:52.412
这些选项规定的不是指定
在哪儿中断

00:41:52.479 --> 00:41:54.314
而是规定是不是中断

00:41:55.415 --> 00:41:59.253
所以 搜索后是否可以修改

00:41:59.419 --> 00:42:02.089
是不能改变的
因为我们已经搜索完了

00:42:02.155 --> 00:42:04.658
如果你希望这样做的话
你只能设置一个新断点来实现

00:42:04.725 --> 00:42:07.394
让我们讲讲断点位置相关的事

00:42:07.461 --> 00:42:09.630
断点位置就是你要停止的位置

00:42:09.696 --> 00:42:11.765
它们是个别的搜索结果

00:42:11.965 --> 00:42:13.333
一般都会有地址

00:42:13.400 --> 00:42:16.270
是程序要叫停的地址

00:42:17.070 --> 00:42:21.542
当你查看它们时
它们通过生成断点和位置编号被指定

00:42:21.642 --> 00:42:24.244
通过一个点分开

00:42:24.311 --> 00:42:27.714
因此 当你在Xcode中调试
并且在某个断点上停止时

00:42:27.781 --> 00:42:31.518
你注意一下
你看一下PC小功能区

00:42:31.585 --> 00:42:34.421
PC功能区将在右侧给出停止原因

00:42:34.488 --> 00:42:37.591
它总是会给出像2.1
这样形式的断点

00:42:37.658 --> 00:42:39.459
它从不给出像2这样形式的断点

00:42:39.526 --> 00:42:42.196
因为你只能在这些位置上中断

00:42:42.262 --> 00:42:44.331
所以是1.1 1.2等等

00:42:45.165 --> 00:42:49.269
另外 位置和断点在某种程度上
与我讲的其他选项

00:42:49.336 --> 00:42:52.606
是对称的

00:42:52.773 --> 00:42:57.244
它们都有像命令和条件等那样
相同的通用选项

00:42:57.311 --> 00:43:00.581
你可在断点上指定任何命令条件

00:43:00.647 --> 00:43:03.550
然后它将适用于所有位置

00:43:03.617 --> 00:43:06.587
但是你还可以重载特定位置

00:43:06.653 --> 00:43:10.824
通过在位置上设置其中一个
命令或条件来实现

00:43:11.525 --> 00:43:13.560
还有一点好处

00:43:14.294 --> 00:43:17.798
很多时候
若你有一个生成一批位置的断点

00:43:17.865 --> 00:43:20.067
你想得到其中五个
或你不想得到其中五个

00:43:20.133 --> 00:43:22.936
那么你可以禁用它们
你可以分别执行

00:43:23.203 --> 00:43:25.672
但是 如果你不想搜索到它们

00:43:25.739 --> 00:43:27.941
你想禁用整个断点

00:43:28.008 --> 00:43:29.643
你可以通过禁用断点来实现

00:43:29.710 --> 00:43:33.847
但看起来并没有改变位置的开启
或禁用状态

00:43:33.914 --> 00:43:35.983
因此 你只需要再把它打开即可

00:43:36.049 --> 00:43:39.219
就会像你所期待的那样改变
所有位置的状态

00:43:39.520 --> 00:43:42.389
这只是一个小贴士
那么现在你已经看到

00:43:42.756 --> 00:43:45.726
断点在LLDB中的概念

00:43:45.959 --> 00:43:49.162
让我展示一些
LLDB提供的

00:43:49.229 --> 00:43:50.564
更强大的断点类型

00:43:50.631 --> 00:43:53.033
这些仍然是搜索要停止的位置

00:43:53.133 --> 00:43:55.536
我们要进行哪种搜索呢？

00:43:55.602 --> 00:43:59.406
这正是你程序中的命名空间
所感兴趣的

00:43:59.473 --> 00:44:03.143
看起来所有命名空间都是
黏糊糊的东西

00:44:03.210 --> 00:44:05.512
因为它们都像函数名
或诸如此类的东西

00:44:05.746 --> 00:44:10.984
因为我们总是使用常规表达式
作为搜索模式的表达方式

00:44:11.084 --> 00:44:12.486
那么如果你知道常规表达式

00:44:12.553 --> 00:44:14.054
你一定会觉得它很可爱

00:44:14.121 --> 00:44:15.889
如果你不熟悉常规表达式

00:44:16.290 --> 00:44:17.891
几年前我就说过

00:44:17.958 --> 00:44:22.129
在你的办公室找一个
有动物封面书的人

00:44:22.196 --> 00:44:24.164
即使现在 如果你想找个前辈

00:44:24.231 --> 00:44:27.201
你可以找个有书的人

00:44:28.168 --> 00:44:29.036
那么无论如何...

00:44:32.773 --> 00:44:36.743
我们提供两种搜索
一种显而易见

00:44:36.977 --> 00:44:40.647
是搜索程序中的函数名

00:44:40.714 --> 00:44:42.216
这是那种搜索的选项

00:44:42.282 --> 00:44:43.984
还有一种可能不那么明显

00:44:44.051 --> 00:44:46.687
但我希望随着我们更深入地讲解
我能说服你 让你觉得那很有意思

00:44:46.753 --> 00:44:49.590
就是源文本搜索断点

00:44:49.890 --> 00:44:51.458
这就是搜索的选项

00:44:51.892 --> 00:44:52.993
让我们先来看第一种

00:44:53.060 --> 00:44:55.829
函数名模式跟断点相匹配

00:44:55.896 --> 00:44:57.631
我只展示一些例子

00:44:57.698 --> 00:45:00.067
假如某人给了你一个新类

00:45:00.133 --> 00:45:02.736
你不知道这个类是干什么的
你想知道它是如何工作的

00:45:02.803 --> 00:45:06.740
那么你想要做的其实是中断
那个类实现的所有方法

00:45:06.807 --> 00:45:09.676
你可以通过在Xcode中
仔细检查源文件来实现

00:45:09.743 --> 00:45:12.946
从最开始进行 但很快你会觉得乏味

00:45:13.380 --> 00:45:16.183
顺便说一下 你不想在父类
或子类这样的类上中断

00:45:16.750 --> 00:45:19.953
最好是尝试制定一个
常规表达式

00:45:20.020 --> 00:45:23.790
匹配给定类中的所有函数

00:45:23.957 --> 00:45:26.760
那么在Swift中
这是个合适的常规表达式

00:45:26.960 --> 00:45:29.763
或在Objective C中
这是个合适的常规表达式

00:45:29.830 --> 00:45:32.633
然后你要在这些表达式上
设置断点

00:45:32.699 --> 00:45:35.402
然后你就可以运行程序
看看会发生什么

00:45:35.469 --> 00:45:38.071
请记住 因为你可以禁用个别位置

00:45:38.272 --> 00:45:40.407
当你做这种实验时

00:45:40.474 --> 00:45:44.478
你会发现你可能搜索到其中一个
你知道它是干什么的 你并不感兴趣

00:45:44.545 --> 00:45:47.214
所以你只需要禁用那个位置
然后继续

00:45:47.281 --> 00:45:49.716
发现第二个 禁用
然后继续 以此类推

00:45:49.983 --> 00:45:52.119
那么这是一种探索新代码的
不错的方式

00:45:52.186 --> 00:45:54.955
更高级的版本是

00:45:55.022 --> 00:45:57.791
某人给你一个共享库

00:45:57.858 --> 00:46:00.561
你想看看它在运行时到底
有什么功能

00:46:00.627 --> 00:46:05.098
然后设置一个常规表达式断点
我在这里用的是简化的-r形式

00:46:05.165 --> 00:46:07.734
常规表达式匹配一切

00:46:07.801 --> 00:46:09.169
用.*实现

00:46:09.236 --> 00:46:12.372
然后把它限制在
你感兴趣的那个库

00:46:12.439 --> 00:46:14.408
把这些和断点命令相结合

00:46:14.474 --> 00:46:16.143
通常是一种很好的方式

00:46:16.210 --> 00:46:20.447
以便又迅速又随性地获得
这个库的执行轨迹

00:46:20.514 --> 00:46:22.883
你可以向后追踪 也许会打印局部

00:46:22.950 --> 00:46:25.485
然后继续 你只需要运行程序

00:46:25.552 --> 00:46:29.690
并且得到那个库的执行磁带输出即可

00:46:30.390 --> 00:46:33.460
当然了 在执行过程中速度会慢下来
但值得等待

00:46:34.394 --> 00:46:36.230
然后另一个小技巧是

00:46:36.296 --> 00:46:39.433
如果你找到你并不感兴趣的
你可以禁用它们

00:46:39.833 --> 00:46:43.971
那么让我们谈谈另一种
匹配模式吧

00:46:44.304 --> 00:46:47.841
这里的重点是有一些构造函数

00:46:47.908 --> 00:46:50.844
当你查看源文本时非常明显

00:46:50.911 --> 00:46:53.680
但如何在生成的代码中得到
那些构造函数

00:46:53.747 --> 00:46:55.182
真的很不明显

00:46:55.315 --> 00:46:57.551
其中一个例子是宏

00:46:57.618 --> 00:47:01.088
通常在你的程序中替代文本

00:47:01.154 --> 00:47:02.356
然后它就悄悄消失了
但你知道

00:47:02.422 --> 00:47:06.293
它们插在代码的哪个位置
因为它们是大写字母

00:47:06.360 --> 00:47:09.196
那么想要搜索到它们
也许需要搜索全部大写字母

00:47:09.263 --> 00:47:11.431
或你所关注的特定的宏

00:47:11.498 --> 00:47:13.300
但是你可以更有创造力

00:47:13.367 --> 00:47:17.905
比如说 我想了解指针

00:47:17.971 --> 00:47:19.506
指定字段的位置

00:47:19.773 --> 00:47:22.242
很明显是在源文本中

00:47:22.309 --> 00:47:24.077
因为看起来就像是那样

00:47:24.178 --> 00:47:27.915
但在生成的代码中
寻找这些位置可能会很困难

00:47:27.981 --> 00:47:32.386
因此还有另一个实例
在源文本中使用模式匹配

00:47:32.452 --> 00:47:36.590
可以允许你发现你用其他方式
发现不了的构造函数

00:47:37.191 --> 00:47:38.759
另一种使用方法是

00:47:38.825 --> 00:47:42.696
做主题分组

00:47:42.763 --> 00:47:44.631
你可以在上边设置断点

00:47:44.698 --> 00:47:48.569
通过插入手动模式到你的源代码

00:47:48.635 --> 00:47:51.605
就像注释里说的中断这里
或中断那里

00:47:51.672 --> 00:47:53.640
如果你有兴趣检测

00:47:53.707 --> 00:47:57.211
程序功能中的这个特定的部分

00:47:57.444 --> 00:47:59.913
然后使用这些源常规表达式断点

00:47:59.980 --> 00:48:01.048
来捕捉它

00:48:01.415 --> 00:48:06.320
那么这就是源断点的工作原理

00:48:06.386 --> 00:48:09.356
选项是源常规表达式

00:48:09.423 --> 00:48:12.226
为搜索提供的数据是模式

00:48:12.292 --> 00:48:14.928
然后你可以把它限定在一个文件中

00:48:15.229 --> 00:48:20.434
你可以通过多次给出-f选项
限定在多个文件中

00:48:20.567 --> 00:48:23.103
并且还有一个标志可以搜索
全部源文件

00:48:24.004 --> 00:48:27.841
让我举个例子来吊你的胃口

00:48:27.908 --> 00:48:31.044
假如我有个复杂的函数
比如状态机

00:48:31.111 --> 00:48:34.481
是计算用的
然后从许多不同的地方返回

00:48:34.548 --> 00:48:37.384
在某些恐怖的超长的选择语句中
或其他类似的选择语句中

00:48:37.451 --> 00:48:41.154
我想找到什么时候会返回空

00:48:41.221 --> 00:48:45.826
但我想了解返回空时

00:48:46.026 --> 00:48:47.594
的具体情况

00:48:48.095 --> 00:48:49.563
很难实现

00:48:49.630 --> 00:48:51.398
因为你可以在函数返回后中断

00:48:51.465 --> 00:48:52.699
并查看是否为空

00:48:52.766 --> 00:48:55.802
你可以点击所有返回空的位置

00:48:55.869 --> 00:48:59.740
但你可能会遗漏其中一个
或你只关注模式

00:49:00.340 --> 00:49:02.376
这里有另外一个便捷方式

00:49:02.442 --> 00:49:05.012
在源常规表达式断点类型中

00:49:05.078 --> 00:49:07.314
你不仅可以指定一个文件

00:49:07.381 --> 00:49:09.483
你还可以把它限定在一个
特定的函数中

00:49:09.550 --> 00:49:11.385
如果那样的话
我要做这样的操作

00:49:11.451 --> 00:49:14.621
中断要返回的模式

00:49:14.688 --> 00:49:18.625
我正在展示我会用常规表达式
因为我正在炫耀

00:49:18.692 --> 00:49:20.961
空格+星号代表任意数量的空格

00:49:21.028 --> 00:49:22.462
然后空指针

00:49:22.529 --> 00:49:25.432
我把它限定在一个函数中
且限定在我感兴趣的一个文件中

00:49:25.499 --> 00:49:29.803
然后我会发现
在这个特定的用法中

00:49:29.870 --> 00:49:31.138
我精确地找到了返回空的位置

00:49:32.539 --> 00:49:35.776
那么值得谈一些额外的断点选项

00:49:35.843 --> 00:49:37.711
你可能没听说过

00:49:37.778 --> 00:49:42.349
其中一个类似逐行或筛选

00:49:42.816 --> 00:49:47.888
很有用 因为我们程序中同时存在
Swift和Objective C

00:49:48.255 --> 00:49:51.024
可以给指定的一种语言设置断点

00:49:51.091 --> 00:49:54.795
那么比如说 随处都有计数方法

00:49:54.862 --> 00:49:56.597
如果你在计数上设置一个断点

00:49:56.663 --> 00:49:58.999
你将在Swift代码中得到一批断点

00:49:59.066 --> 00:50:01.502
你也会得到一批
Objective C方法的断点

00:50:01.568 --> 00:50:03.504
但你并不关心
Objective C方法

00:50:03.570 --> 00:50:05.138
你只想查看Swift代码

00:50:05.405 --> 00:50:07.841
然后你可以指定语言为Swift

00:50:08.041 --> 00:50:10.711
它将不会在 Objective C
名称上执行恰巧匹配的断点

00:50:10.777 --> 00:50:13.680
这很有用

00:50:13.747 --> 00:50:15.482
是的 对

00:50:15.549 --> 00:50:18.485
另一个有用的选项

00:50:18.552 --> 00:50:22.723
能使搜索缩小到一个
指定的线程

00:50:22.856 --> 00:50:26.326
假如你有一些能调用的代码
和一批不同的线程

00:50:26.393 --> 00:50:27.928
就像内核或诸如此类的

00:50:27.995 --> 00:50:31.164
但当你开始执行一个线程时

00:50:31.231 --> 00:50:34.635
你不想让用于检测的断点

00:50:34.701 --> 00:50:37.704
把你带到其他线程上去 很简单

00:50:37.871 --> 00:50:40.240
有一个线程ID选项

00:50:40.774 --> 00:50:42.776
这个选项可以让你按照
线程名执行

00:50:42.843 --> 00:50:45.812
可以通过调用
pthread_setname_np设置

00:50:45.879 --> 00:50:48.615
这很方便 因为如果你命名
一个线程

00:50:48.682 --> 00:50:51.084
然后保留在多个调试会话中

00:50:51.151 --> 00:50:53.620
线程ID当然会随时变更

00:50:53.954 --> 00:50:55.322
你甚至可以限制它

00:50:55.389 --> 00:50:59.593
按照名称对指定队列进行编码

00:51:00.994 --> 00:51:02.596
还有一点你可能会注意到

00:51:02.663 --> 00:51:06.166
就是你可以把全部选项
添加到现有断点上

00:51:06.633 --> 00:51:07.935
特别有用

00:51:08.001 --> 00:51:11.605
如果你已经在Xcode的边列中
设置了文件和行断点的话

00:51:11.672 --> 00:51:15.642
比如说 你决定你想限定到
一个指定线程

00:51:15.709 --> 00:51:18.946
你可以在查询后进行变更
命令是break modify

00:51:19.012 --> 00:51:22.983
另一件有用的事是展示
如何指定它们

00:51:23.050 --> 00:51:26.620
因为你可以通过断点指定

00:51:26.920 --> 00:51:28.622
通过断点位置编号指定

00:51:28.689 --> 00:51:31.325
还有一个小语句来指定范围

00:51:33.227 --> 00:51:34.061
就是这样

00:51:35.229 --> 00:51:39.099
那么现在 你得到了你想要的
所有断点

00:51:39.166 --> 00:51:41.201
但你遇到了绊脚石

00:51:41.268 --> 00:51:43.570
就是目前Xcode看起来

00:51:43.637 --> 00:51:46.640
只保留了它已知的你设置的断点

00:51:46.707 --> 00:51:51.211
而那些你想方设法手动写入的断点
它并不了解

00:51:51.345 --> 00:51:53.013
那么如何保留那些断点呢？

00:51:53.247 --> 00:51:55.582
第一种方法是Enrico讲过的：

00:51:55.649 --> 00:51:58.185
如果你想把它保留在所有对象中

00:51:58.252 --> 00:52:01.054
你只需要把它放在LLDB初始化
文件中即可

00:52:01.288 --> 00:52:05.392
但是如果你想指定对象
有一个小技巧你可以使用

00:52:05.459 --> 00:52:10.030
当你每次调试那个指定对象时
加载断点

00:52:10.097 --> 00:52:13.333
这其实是做一个
Xcode存储的断点

00:52:13.400 --> 00:52:17.037
最好是在程序执行中
早期断开的断点

00:52:17.104 --> 00:52:19.540
然后你把你的断点和命令
放在那个断点中

00:52:19.606 --> 00:52:22.676
这样你就知道
如果是主可执行文件

00:52:22.743 --> 00:52:24.978
比如说 主函数是个快速接口

00:52:25.045 --> 00:52:26.980
那么你可以做一个符号断点

00:52:27.080 --> 00:52:29.650
然后把主函数放进去

00:52:29.716 --> 00:52:32.786
然后你还记得刚才那张幻灯片吧

00:52:32.853 --> 00:52:34.821
我说过有个主函数的小麻烦

00:52:34.888 --> 00:52:37.090
那么你可以指定共享库

00:52:37.791 --> 00:52:41.061
然后你可以添加动作
是个调试器命令动作

00:52:41.128 --> 00:52:44.331
然后不要一个一个地
键入所有断点

00:52:44.398 --> 00:52:45.999
因为会很乏味

00:52:46.066 --> 00:52:48.869
把命令放在一个文件中很方便

00:52:48.936 --> 00:52:54.274
然后使用LLDB的command
source命令来加载这些断点

00:52:54.341 --> 00:52:56.009
最后 如果你自动继续

00:52:56.076 --> 00:52:58.712
每次你运行时 你都将自动获得

00:52:58.779 --> 00:53:00.380
所有那些断点集

00:53:01.281 --> 00:53:04.084
我还想讲另一个便捷方式

00:53:04.151 --> 00:53:06.386
用来克服

00:53:06.453 --> 00:53:11.825
你在现代语言中常见的一种
特定的烦人的麻烦

00:53:12.326 --> 00:53:16.330
就是当你尝试单步跳入某个东西时

00:53:16.396 --> 00:53:19.199
问题是在大部分现代语言中

00:53:19.266 --> 00:53:22.970
大多数变量存取现在都是通过属性
完成的

00:53:23.036 --> 00:53:25.205
或通过存取子函数或诸如此类

00:53:25.272 --> 00:53:26.106
所以...

00:53:26.473 --> 00:53:29.910
一般来说 这并不是你尝试
要调试的代码

00:53:30.811 --> 00:53:32.913
最后导致了这样一个情况

00:53:32.980 --> 00:53:35.782
我在这儿 我尝试进入这个函数
完成某些功能

00:53:35.849 --> 00:53:36.950
我想进入那里

00:53:37.017 --> 00:53:39.987
所以我尝试单步跳入
但并没有成功

00:53:40.053 --> 00:53:42.556
因为我正在传递的一个参数

00:53:42.623 --> 00:53:44.858
是存取子函数
所以我在那个存取器中中断了

00:53:44.925 --> 00:53:47.394
我并不想在那儿中断
因为那一点儿都没有意义

00:53:47.461 --> 00:53:50.364
因此我要做的是完成并返回

00:53:50.430 --> 00:53:53.033
是不是有一种方式可以让这个
过程变得更简单？

00:53:53.100 --> 00:53:56.436
看起来我们添加了一个叫做
定向单步跳入的东西

00:53:56.503 --> 00:54:00.841
选项是step_in_target
表示你要单步跳入

00:54:00.908 --> 00:54:02.809
我要做的是单步跳入

00:54:02.876 --> 00:54:05.479
但我只想让你在这个指定的地方中断

00:54:05.546 --> 00:54:07.514
就是你正在用这个表达的意思

00:54:07.581 --> 00:54:09.416
让我们在这种情况中尝试一下

00:54:09.483 --> 00:54:12.286
我们发现它几乎不怎么工作

00:54:12.352 --> 00:54:13.820
不怎么工作的原因是

00:54:13.887 --> 00:54:16.290
虽然我们没有在存取器中中断

00:54:16.356 --> 00:54:20.093
但是我们却在下一个源文件上中断了
而不是在函数中中断

00:54:20.160 --> 00:54:21.261
这是有道理的

00:54:21.328 --> 00:54:24.231
因为实际上单步跳入是按照
源代码逐行执行的

00:54:24.298 --> 00:54:26.266
这就是多行调用

00:54:26.333 --> 00:54:28.402
那么我们也要通过给出

00:54:28.468 --> 00:54:31.238
结束行的编号添加能指定

00:54:31.305 --> 00:54:33.140
单步跳入的终止范围

00:54:33.207 --> 00:54:36.510
或更方便的是只进入这个块

00:54:36.577 --> 00:54:38.846
让我进入 做一些操作

00:54:38.912 --> 00:54:43.383
甚至还有一个别名
即函数中的sif单步跳入

00:54:43.584 --> 00:54:47.654
那么 你要做的就是坐在这里
并在函数中键入step

00:54:47.721 --> 00:54:49.756
然后你就会着陆在正确的位置

00:54:49.823 --> 00:54:51.625
若你没着陆在正确的位置
我就不会把它放在幻灯片中讲了

00:54:52.292 --> 00:54:56.029
最后我想讲一下排错

00:54:56.263 --> 00:54:59.600
你需要了解的一个信息是

00:54:59.666 --> 00:55:02.436
运行程序中到底有什么

00:55:02.536 --> 00:55:05.405
比如 也许我创建了发布版本
和调试版本

00:55:05.472 --> 00:55:07.841
我想了解我实际使用的是
哪个版本

00:55:07.908 --> 00:55:09.977
或某人给了我一个带dSYM的库

00:55:10.043 --> 00:55:11.545
这个dSYM允许读入吗？

00:55:11.812 --> 00:55:14.681
那么 需要那种信息的命令

00:55:14.748 --> 00:55:16.116
是image list命令

00:55:16.183 --> 00:55:19.219
你可以给它一个模块名
这样它将给出

00:55:19.286 --> 00:55:21.522
关于加载到你程序中
某个模块的信息

00:55:21.588 --> 00:55:25.559
或者为了消遣
你可以不提供任何选项

00:55:25.626 --> 00:55:28.262
将会显示全部
有时候多得令人震惊

00:55:29.830 --> 00:55:32.232
那么 这里有个例子
让我们看看如何使用它

00:55:32.432 --> 00:55:35.335
我键入image list

00:55:35.402 --> 00:55:37.938
我看到这里有个
二进制映像的路径

00:55:38.005 --> 00:55:41.041
那么假如 如果我想查看我是否
使用的是调试版本

00:55:41.108 --> 00:55:43.544
是的 看起来我的确像是用的调试版本

00:55:43.610 --> 00:55:47.481
如果有dSYM的话 它总是会在
二进制映像后列出来

00:55:47.548 --> 00:55:49.683
此情况下
我看到我的确得到了二进制映像

00:55:50.517 --> 00:55:53.654
我想告诉你一个
Swift调试的信息

00:55:53.720 --> 00:55:56.857
我这张幻灯片上的内容实际上
并不是我要讲的内容

00:55:56.924 --> 00:55:58.759
因为我们时间很紧

00:55:58.825 --> 00:56:00.994
但我会告诉你TLDR

00:56:01.428 --> 00:56:03.130
因为我讲得太快 你可能读不完

00:56:03.197 --> 00:56:07.868
由于Swift和LLDB之间的
工作方式

00:56:07.935 --> 00:56:11.338
所有带调试信息的Swift代码

00:56:11.405 --> 00:56:13.273
都必须在本地创建

00:56:13.340 --> 00:56:17.277
因此 从其他人那儿拷贝二进制
映像是行不通的

00:56:17.344 --> 00:56:20.013
你要确保一切都是在本地创建的

00:56:20.080 --> 00:56:21.682
并且有编译器

00:56:21.748 --> 00:56:24.585
随着你正在使用的调试器一起运行

00:56:26.253 --> 00:56:28.922
我想说的是 这是我们提供的
一个小便利

00:56:28.989 --> 00:56:31.692
那么 Enrico讲的优化代码
优化的规则

00:56:31.758 --> 00:56:34.561
我们之前听到
如果不是不得不做的话 就不要做

00:56:34.628 --> 00:56:39.533
由于大部分软件开发者都是理性的人

00:56:39.600 --> 00:56:42.069
你可以写一个推论

00:56:42.135 --> 00:56:45.873
调试优化代码的绝大多数人
实际上都不是故意执行的

00:56:46.106 --> 00:56:48.575
那么现在当你中断在文件中时

00:56:48.642 --> 00:56:52.112
 LLDB将告诉你
那个文件被优化了

00:56:52.179 --> 00:56:56.216
每个库只通知一次
你将得到一条像这样的消息

00:56:56.283 --> 00:56:59.586
然后你快速进入设置
把它们改回来

00:57:00.921 --> 00:57:03.957
刚刚添加到Clang中的
另一个新功能

00:57:04.024 --> 00:57:05.926
是这个模块概念

00:57:05.993 --> 00:57:09.363
模块是允许编译器

00:57:09.429 --> 00:57:13.066
查看你程序标头环境中的
所有标头的方式

00:57:13.667 --> 00:57:16.870
编译并解析它们

00:57:16.937 --> 00:57:19.740
然后在所有编译器中重用

00:57:19.806 --> 00:57:22.376
然后我们想
为什么我们不能对调试信息

00:57:22.442 --> 00:57:23.944
做同样的事呢？

00:57:24.011 --> 00:57:28.215
为什么不能允许
类型信息的解析形式

00:57:28.282 --> 00:57:31.251
也一次性完成然后

00:57:31.318 --> 00:57:35.222
在所有带调试信息.o文件中共享呢？

00:57:35.289 --> 00:57:38.258
这叫做Clang模式调试功能

00:57:38.959 --> 00:57:40.827
此外 我们还可以使用
PCH文件

00:57:40.894 --> 00:57:44.631
Xcode中的设置
是Clang模块调试

00:57:44.698 --> 00:57:47.067
这是由于某种原因
我放进去的标志

00:57:47.367 --> 00:57:50.270
这很棒 因为就像编译器一样

00:57:50.337 --> 00:57:53.273
提高了调试信息的生成速度

00:57:53.340 --> 00:57:57.010
它将缩短编译时间
但它有一个警告

00:57:57.077 --> 00:58:00.380
那个警告实际上可能是个重要警告

00:58:00.447 --> 00:58:04.518
那么 那个警告是你的调试不仅
依赖于.o文件

00:58:04.585 --> 00:58:07.721
还依赖于内存中的某些东西

00:58:07.988 --> 00:58:11.625
因此 一般来说 那不是个问题
每个东西都在自己的位置上

00:58:11.692 --> 00:58:16.096
但当你要给某人发布库或应用时

00:58:16.363 --> 00:58:20.300
该怎么工作呢？
嗯 如果是应用或框架

00:58:20.367 --> 00:58:23.237
你只需要运行dsymutil即可

00:58:23.303 --> 00:58:26.740
效果是一样的 它把一切都集合起来
一切都能正常运行

00:58:26.807 --> 00:58:30.177
但请记住
dsymutil只在关联产品上运行

00:58:30.244 --> 00:58:32.145
并不在.o文件上运行

00:58:32.212 --> 00:58:35.916
因此 若你发布的是
带调试信息的静态库

00:58:35.983 --> 00:58:38.519
那么你必须关闭这个
G模块的功能

00:58:38.585 --> 00:58:41.488
否则你将会给客户发布
已损毁的调试信息

00:58:41.989 --> 00:58:44.458
顺便说一下 如果磁盘空间不足

00:58:44.525 --> 00:58:46.193
你删除了模块缓存

00:58:46.260 --> 00:58:48.495
那么你就不能再调试了

00:58:48.695 --> 00:58:51.365
这是那个功能的一个不利因素

00:58:51.965 --> 00:58:55.669
那么 让我来总结一下吧

00:58:56.103 --> 00:58:59.773
我希望你了解LLDB是个
定制化很强的调试器

00:58:59.840 --> 00:59:02.242
提供多种查看数据的方式

00:59:02.743 --> 00:59:07.114
表达式实际上可以提供
更强大的检测功能

00:59:07.181 --> 00:59:11.251
我认为Sean的例子很好
讲了如何在live状态下

00:59:11.318 --> 00:59:14.221
从一个复杂的数组中通过
并发现你感兴趣的点

00:59:15.022 --> 00:59:18.592
在Xcode中 我们有很多断点类型
比你想象的多

00:59:19.326 --> 00:59:22.729
你可以把自己陷入超级深的麻烦中

00:59:22.796 --> 00:59:24.431
比源代码层的调试还深

00:59:24.498 --> 00:59:28.936
总之 希望我们提供了丰富的
工具集让你探索自己的代码

00:59:29.002 --> 00:59:33.440
这里有一些之前演讲的信息
可能涉及你感兴趣的内容

00:59:33.507 --> 00:59:36.543
还有一些早些时候的演讲
你可能没参加

00:59:36.910 --> 00:59:39.213
或参加了 但无论如何
我把它们列在幻灯片上了

00:59:39.279 --> 00:59:40.214
谢谢大家

00:59:40.414 --> 00:59:43.584
希望你们能在仅剩的WWDC
期间度过一段美好的时光