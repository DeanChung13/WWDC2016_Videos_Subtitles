00:00:19.453 --> 00:00:23.524
Swift Foundation
的新特性

00:00:32.165 --> 00:00:33.033
谢谢

00:00:34.801 --> 00:00:36.904
大家好 欢迎
我是Tony Parker

00:00:36.970 --> 00:00:38.772
我在Apple带领
Foundation团队

00:00:38.839 --> 00:00:41.241
今天我在这里和
Michael LeHew一起讨论

00:00:41.308 --> 00:00:42.976
Swift Foundation
的新特性

00:00:44.678 --> 00:00:46.847
这一年来Foundation团队
付出了很大的努力

00:00:46.914 --> 00:00:49.049
改善你使用Cocoa的方式

00:00:49.116 --> 00:00:51.318
以及Swift中
Cocoa Touch的API

00:00:51.785 --> 00:00:54.488
从Swift API设计指引开始

00:00:55.088 --> 00:00:57.524
随后 我们研究了
所有Objective-C的代码

00:00:57.591 --> 00:01:01.428
包括Cocoa SDK使用及
你自己编写的代码如何引入Swift

00:01:02.496 --> 00:01:04.131
但是我们知道
我们可以做到更好

00:01:04.197 --> 00:01:07.868
所以 我们引入了一套新的
值类型到Foundation里

00:01:08.335 --> 00:01:12.005
同时也引入了大量
很棒的针对Swift的新API

00:01:13.207 --> 00:01:15.509
我们继续从设计指引开始

00:01:17.144 --> 00:01:19.313
我们今年的工作
围绕着Swift 3 但是

00:01:19.446 --> 00:01:21.949
我们最初设计Swfit的目标
一直没有变

00:01:22.416 --> 00:01:26.119
我们希望你编写的代码
快速 安全 表达性强

00:01:26.854 --> 00:01:28.755
我们创建了标准库

00:01:28.822 --> 00:01:30.991
以及围绕这些核心思想的
编程语言

00:01:31.458 --> 00:01:34.228
你们很多人也都
理解了这些原则

00:01:34.428 --> 00:01:36.230
并且根据它们
建立了自己的应用程序

00:01:36.830 --> 00:01:39.533
但是 我们都知道
还有另一部分内容没有提到

00:01:39.600 --> 00:01:41.034
那就是Cocoa SDK

00:01:41.902 --> 00:01:44.304
你的程序也非常依赖它

00:01:44.371 --> 00:01:46.740
甚至对它的依赖
要大于Swift标准库

00:01:47.007 --> 00:01:49.543
它需要看起来
属于同一个生态系统

00:01:50.410 --> 00:01:52.980
因为SDK在这里至关重要

00:01:53.046 --> 00:01:55.282
有关我们如何
在自己的平台上开发应用

00:01:55.349 --> 00:01:59.052
让语言和库相互合作
至关重要

00:02:01.088 --> 00:02:03.991
所以今年我们专注于表达性

00:02:04.358 --> 00:02:06.927
我提到表达性这个词时
有两层含义

00:02:06.994 --> 00:02:09.295
第一层意思指的是
你作为应用作者的能力

00:02:09.363 --> 00:02:11.765
你编写的Swift代码
能把你的意图

00:02:11.832 --> 00:02:13.634
传达给编译器和库

00:02:14.134 --> 00:02:15.435
但它还有另一种意思

00:02:15.736 --> 00:02:18.105
库需要能表达它们自己的目的

00:02:18.172 --> 00:02:19.339
它们的设计模式

00:02:19.406 --> 00:02:23.677
以及它们对于如何让作为应用作者的你
能最方便地使用API的想法

00:02:25.546 --> 00:02:27.347
所以在研究指引的时候

00:02:27.414 --> 00:02:29.983
我们注重一致的体验这一概念

00:02:30.217 --> 00:02:33.187
有关指引的决策
都基于这一概念

00:02:33.253 --> 00:02:35.522
语言和库密不可分

00:02:35.589 --> 00:02:36.823
它们必须协同工作

00:02:37.224 --> 00:02:40.961
举个例子
库带来了一堆新的特性

00:02:41.261 --> 00:02:44.565
很多你看到的
今年我们新版平台上的特性

00:02:44.631 --> 00:02:48.535
都源于库中的新特性
你也可以把它们用到自己的应用里

00:02:48.635 --> 00:02:50.304
提升你的开发体验

00:02:51.104 --> 00:02:54.508
这些库在我们所有的平台中
都有广泛应用

00:02:54.575 --> 00:02:57.711
包括今年新的Swift Auto ARC
和Swift Open Source

00:02:58.245 --> 00:03:00.214
我们有Swift Core
Libs Foundation

00:03:00.347 --> 00:03:04.718
把大部分Foundation
API移植到其他平台 如Linux

00:03:05.786 --> 00:03:08.322
这些库的实现经受得住考验

00:03:08.455 --> 00:03:10.724
其中很多自OS X时代
就已经存在了

00:03:10.791 --> 00:03:12.159
有些甚可追溯到更久远

00:03:13.794 --> 00:03:16.430
得益于Cocoa命名指引
它们还带来了

00:03:16.496 --> 00:03:17.998
一套悠久传统

00:03:18.265 --> 00:03:20.667
这意味着
当你看到一套新的API时

00:03:20.934 --> 00:03:24.104
你马上就能明白
它的工作原理以及功能

00:03:24.838 --> 00:03:26.273
最后重要的一点是

00:03:26.340 --> 00:03:29.142
这些库在不断更新中

00:03:29.443 --> 00:03:31.311
除了添加新的特性

00:03:31.378 --> 00:03:34.848
我们还在改进 修复漏洞 等等

00:03:35.048 --> 00:03:38.752
每年发布新系统
我们都会继续这样做

00:03:40.120 --> 00:03:42.589
另一方面 Swift语言

00:03:42.656 --> 00:03:45.459
带来了一些
Objective-C所没有的特性

00:03:45.826 --> 00:03:47.895
比如 对泛型的第一类支持

00:03:48.462 --> 00:03:50.297
以及内置的对可变类型的支持

00:03:50.364 --> 00:03:52.666
这些都是Swift语言
安全性的重要部分

00:03:53.901 --> 00:03:55.669
其中包括协议扩展

00:03:55.736 --> 00:03:58.172
函数重载 以及默认参数值

00:03:58.438 --> 00:04:01.842
这些都对如何设计Swift的API
有着重要的影响

00:04:03.043 --> 00:04:05.879
这个清单两边都没有列全
我没有足够空间

00:04:05.946 --> 00:04:07.314
可以提到的还有很多

00:04:07.814 --> 00:04:12.219
所以我们提炼了三份关键文档

00:04:12.586 --> 00:04:16.089
第一份是SE-0023
API设计指引

00:04:16.156 --> 00:04:20.027
所有文档都发送到了Swift
Evolution邮件列表

00:04:20.093 --> 00:04:22.262
给你和Swift社区

00:04:22.329 --> 00:04:25.666
一个机会
参与到语言的设计和进化中

00:04:26.233 --> 00:04:28.735
我们把这些指引
视作统一的文档

00:04:28.802 --> 00:04:30.804
无论是现在还是将来的Swift库

00:04:31.205 --> 00:04:32.773
此外我们还有SE-0006

00:04:32.840 --> 00:04:35.576
将这些设计指引
用于标准库

00:04:35.642 --> 00:04:38.145
提供了一套
一致且可预测的原语集

00:04:38.212 --> 00:04:41.315
我们可以把它们作为基础
还有SE-0005

00:04:41.648 --> 00:04:44.785
它大幅提升了Cocoa SDK
的表达性

00:04:45.052 --> 00:04:47.154
通过引入默认参数值

00:04:47.221 --> 00:04:49.389
改进可选集以及编译属性

00:04:49.456 --> 00:04:51.892
甚至在一些情况下自动采用协议

00:04:54.661 --> 00:04:55.796
有一期关于此的演讲

00:04:55.863 --> 00:04:58.065
你如果没看过的话
建议你去看看

00:04:58.131 --> 00:05:00.033
Swift API设计指引

00:05:02.369 --> 00:05:06.640
这些已经算得上巨大的进步
但我们知道 还可以更进一步

00:05:07.140 --> 00:05:09.776
因为Swift的目标
不止于其名

00:05:11.311 --> 00:05:14.882
可变性是这门语言
至关重要的一部分

00:05:15.549 --> 00:05:18.485
所以我们把目光
聚焦于Foundation

00:05:19.953 --> 00:05:22.022
若你在想
为何选择Foundation？

00:05:22.589 --> 00:05:24.658
答案是它比较特别

00:05:24.725 --> 00:05:26.827
我这么说
不是因为我的工作是关于它的

00:05:27.427 --> 00:05:30.664
Foundation在SDK中
处于一个特别的位置

00:05:30.797 --> 00:05:32.766
它的层级足够低

00:05:32.833 --> 00:05:35.602
适用于任何我提到过的平台

00:05:36.203 --> 00:05:38.539
但与此同时
它的层级又足够高

00:05:38.872 --> 00:05:42.476
足以建立一整套
通用类型和设计模式

00:05:42.543 --> 00:05:45.279
同样你会发现
它会反映到整个SDK

00:05:45.913 --> 00:05:49.816
我们回顾一下刚才的图片
放大这里的Cocoa SDK

00:05:49.883 --> 00:05:53.520
你会发现很多
应用的日常开发中用到的框架

00:05:53.587 --> 00:05:56.924
从UIKit到SpriteKit
从WatchKit到CoreData

00:05:56.990 --> 00:05:59.560
还有很多其它不适合放于此的
Cores和Kits

00:06:00.394 --> 00:06:02.062
有趣之处在于

00:06:02.129 --> 00:06:04.665
所有这些都建立在
Foundation的基础上

00:06:05.599 --> 00:06:07.701
因此将Foundation
<c.magnenta>视作一杠杆点

00:06:08.635 --> 00:06:11.772
在Foundation里的
一小点改动

00:06:12.005 --> 00:06:15.209
会对整个SDK产生巨大的影响

00:06:16.476 --> 00:06:20.547
一定程度上由于很多数值类型
出自Foundation

00:06:21.481 --> 00:06:25.485
所以我们注重
进化胜过彻底改变这一观点

00:06:25.853 --> 00:06:29.489
我们看到了标准库
为你的应用开发带来的所有东西

00:06:29.590 --> 00:06:32.693
我们不会因为新语言
而摒弃已有的一切

00:06:32.926 --> 00:06:37.097
我们做的是
让语言和库更加紧密

00:06:37.164 --> 00:06:39.166
通过同时改进双方

00:06:39.700 --> 00:06:43.704
我们今天谈论的
正是这一过程的延续

00:06:45.739 --> 00:06:47.975
把这一点放在心上
Foundation团队

00:06:48.041 --> 00:06:50.878
在Swift Evolution
邮件列表提出了两个新的提议

00:06:51.178 --> 00:06:53.814
第一个是Foundation中
数值类型的可变性

00:06:54.114 --> 00:06:56.583
把Swift的可变性模型

00:06:56.650 --> 00:06:57.985
应用到Foundation框架上

00:06:59.720 --> 00:07:02.923
另一个是抛弃Swift
Foundation里的NS前缀

00:07:03.190 --> 00:07:06.193
为Swift建立通用类型和设计模式

00:07:06.260 --> 00:07:08.729
以适用于任何平台

00:07:12.099 --> 00:07:15.536
这是我们今年对API
做的一些改进的概述

00:07:15.836 --> 00:07:17.838
第一点最重要的是数值语义

00:07:17.905 --> 00:07:20.908
一套全新的数值类型
在整个SDK随处可见

00:07:21.375 --> 00:07:23.911
此外我们对命名进行了些改进

00:07:23.977 --> 00:07:26.980
超越了Objective-C
翻译成Swift能做到的

00:07:27.514 --> 00:07:30.317
我们让这些类型
采用了很多标准库协议

00:07:30.384 --> 00:07:34.121
这意味着你的通用算法
现在同样适用于Foundation类型

00:07:34.688 --> 00:07:38.525
我们额外添加了类型安全性
以及很多针对Swift的新特性

00:07:41.228 --> 00:07:43.130
我们来快速浏览一下数值类型

00:07:44.498 --> 00:07:46.633
数值类型和引用类型不同

00:07:46.700 --> 00:07:50.437
主要区别于复制时的行为

00:07:50.504 --> 00:07:54.474
数值类型在赋值或作为参数传递时
会复制它们的内容

00:07:54.575 --> 00:07:56.476
举个简单例子
我有一个点

00:07:57.010 --> 00:08:00.447
我用等号
把这个点赋值给另一个点

00:08:00.514 --> 00:08:03.851
当我修改第二个点的时候
你可以看到 只有副本改变了

00:08:03.917 --> 00:08:08.155
我没有影响两个点的内容
因为CGPoint是数值类型

00:08:09.156 --> 00:08:12.326
另一方面
引用类型默认共享内容

00:08:12.759 --> 00:08:16.330
这里我用引用类型创建些数据
它们是可变数据

00:08:16.763 --> 00:08:20.567
同样用等号
把data赋值给otherData

00:08:21.101 --> 00:08:23.704
然而这一次
当我修改第二个数据的时候

00:08:24.004 --> 00:08:26.073
你会发现
它影响到了两个数据的内容

00:08:27.341 --> 00:08:30.744
重要的是要理解
这两者没有好坏之分

00:08:30.811 --> 00:08:32.412
只是使用方式不同

00:08:33.212 --> 00:08:36.517
我喜欢把它们看做
工具箱中的不同工具

00:08:36.582 --> 00:08:39.052
当你需要解决某个问题时
可以使用它们

00:08:41.288 --> 00:08:43.423
所以当你试着决定

00:08:43.924 --> 00:08:46.193
你的类型是数值类型还是引用类型

00:08:46.860 --> 00:08:49.830
你应该从对象身份和存储内容考虑

00:08:50.597 --> 00:08:52.566
我举几个例子来解释

00:08:54.001 --> 00:08:57.037
Foundation中有个叫
OperationQueue的类

00:08:57.304 --> 00:09:00.307
OperationQueue中有一个单例
叫main OperationQueue

00:09:01.308 --> 00:09:03.310
这个main
OperationQueue

00:09:03.377 --> 00:09:05.946
用于放置
你希望在主线程上完成的工作

00:09:06.013 --> 00:09:09.116
所以它只有一个
这一定程度上代表了身份

00:09:09.383 --> 00:09:13.453
若我能复制main OperationQueue
它就不再是主队列了

00:09:13.954 --> 00:09:17.357
所以我们相信OperationQueue
是一个引用类型

00:09:18.592 --> 00:09:22.396
另一个例子 Cocoa SDK里
随处可见的一种模式就是代理

00:09:23.096 --> 00:09:26.366
这是一个代理
或者说是URLSession的代理之一

00:09:26.433 --> 00:09:30.237
你会发现这个代理协议
有一个参数 就在这儿

00:09:30.304 --> 00:09:34.908
名叫Session
它告诉被委托的对象

00:09:34.975 --> 00:09:37.377
它将以哪个URLSession的名义工作

00:09:37.845 --> 00:09:42.816
这里的哪个URLSession
同样暗示了身份

00:09:43.150 --> 00:09:47.054
所以我们相信代理使用的类型
通常是引用类型

00:09:48.989 --> 00:09:52.192
从另一方面 很多类型的重点
在于它们存储的内容

00:09:52.259 --> 00:09:53.560
比如Date

00:09:53.627 --> 00:09:55.729
这是我们新Foundation
数值类型之一

00:09:56.396 --> 00:09:57.898
Date是一个绝对的时间点

00:09:58.532 --> 00:10:01.301
我们可以有两个具有相同值的Date

00:10:01.368 --> 00:10:04.538
同样的绝对时间点
它们是同一个Date

00:10:04.605 --> 00:10:07.508
我们不需要讨论那个时间点的引用

00:10:07.574 --> 00:10:09.710
如果我们查看Date的实现

00:10:09.776 --> 00:10:11.879
正如你所见
其实它只是个Double

00:10:12.312 --> 00:10:15.916
Double我们可以本能地认为
是一个数值类型

00:10:17.050 --> 00:10:18.519
另一个例子就是Data

00:10:18.952 --> 00:10:21.555
Data是另一个
新的Foundation数值类型

00:10:22.055 --> 00:10:24.992
Data 通常情况下
你关心的是Data的内容

00:10:25.125 --> 00:10:28.395
它所包含的字节
而不是NSData对象

00:10:28.495 --> 00:10:31.765
所以Foundation
把Date设为数值类型

00:10:34.101 --> 00:10:36.970
每次我们把它作为参数传递时
都需要复制数据

00:10:37.037 --> 00:10:38.772
很快开销会变得很大

00:10:39.006 --> 00:10:41.675
所以我们进行了一种优化
叫做写时复制

00:10:42.476 --> 00:10:44.178
这里我建立了一些数据

00:10:44.845 --> 00:10:46.580
看到我建立了一个Struct

00:10:46.647 --> 00:10:48.849
但是在它内部
还有一个引用

00:10:48.916 --> 00:10:51.885
又一个合作提高效率的例子

00:10:51.952 --> 00:10:54.154
我同时使用了引用和数值

00:10:54.221 --> 00:10:56.156
来得到我想要的性能特征

00:10:56.223 --> 00:10:58.992
以及重要的数值语义

00:10:59.960 --> 00:11:04.064
如果我用等号
把这个数据赋值给另一个数据

00:11:04.131 --> 00:11:06.733
你会发现我得到了另一个Struct

00:11:06.800 --> 00:11:09.469
但其实在内部
它们还是指向同一个类

00:11:10.103 --> 00:11:14.241
但是如果我修改这个数据
那我们就需要复制数据了

00:11:14.408 --> 00:11:17.544
修改副本
我们就有了两个独立的Data

00:11:18.812 --> 00:11:20.681
如果我继续修改第二个数据

00:11:20.914 --> 00:11:23.617
我们可以断定
Data各有独自的引用

00:11:23.684 --> 00:11:25.352
而我们也不需要每次都去复制它

00:11:25.953 --> 00:11:29.256
这是一种扩展 或者说
其实就是同样技术的另一种使用方式

00:11:29.323 --> 00:11:32.226
这个技术我们以前谈论过
包括去年谈到的

00:11:32.292 --> 00:11:34.328
在Swift里构建更好的
应用和值类型

00:11:34.394 --> 00:11:37.464
如果你想了解更多它的工作原理
可以去看看

00:11:38.632 --> 00:11:41.435
所以我们调查了
Foundation里每一个API

00:11:41.602 --> 00:11:45.239
总结出了这份列表
我们认为它们作为数值类型很棒

00:11:45.639 --> 00:11:49.610
你会很高兴看到
很多你平时使用的类型都在列表上

00:11:49.877 --> 00:11:52.012
包括我刚刚提到的Data和Date

00:11:52.279 --> 00:11:54.815
还有很多别的常用类型
比如URL

00:11:55.115 --> 00:11:58.018
IndexPath
CharacterSet 等等

00:11:58.285 --> 00:12:00.454
它们当中很多不只是变成了数据类型

00:12:00.654 --> 00:12:03.223
还增加了很多很棒的新API

00:12:05.425 --> 00:12:08.629
为了让你们了解它们是什么样的
我想有请Michael上台

00:12:14.201 --> 00:12:15.102
谢谢你 Tony

00:12:15.636 --> 00:12:19.072
咱们先看看
Foundation枚举类型的新家

00:12:20.240 --> 00:12:21.909
Objective-C里的枚举

00:12:21.975 --> 00:12:24.144
以及选项集合
生存在全局命名空间里

00:12:24.211 --> 00:12:25.946
和使用它们的类型在一起

00:12:26.113 --> 00:12:30.083
比如NSNumberFormatter
定义了四个枚举

00:12:30.184 --> 00:12:33.720
包括样式、行为、填充位置以及舍入模式

00:12:34.354 --> 00:12:37.324
它们和NumberFormatter
有一定暗中的联系

00:12:37.391 --> 00:12:39.760
通过严格一致的命名传统

00:12:39.960 --> 00:12:43.597
在Swift 2中 你也知道
它们同样在全局命名空间里

00:12:45.065 --> 00:12:46.934
但这就感觉不像是纯粹的Swift

00:12:47.467 --> 00:12:49.336
Swift支持嵌套类型

00:12:49.903 --> 00:12:53.173
所以在Swift 3里
我们决定改变这些类型的位置

00:12:53.807 --> 00:12:56.443
在它们注定应该在的地方
进行声明

00:12:56.510 --> 00:12:58.946
现在NumberFormatter
拥有内置的样式

00:12:59.012 --> 00:13:00.848
行为、填充位置以及舍入模式类型

00:13:00.914 --> 00:13:02.850
它们的名字不再繁冗

00:13:03.784 --> 00:13:05.719
这极大程度减少了

00:13:05.786 --> 00:13:08.255
Foundation在顶级命名空间
声明的类型数量

00:13:08.522 --> 00:13:10.524
关系也更加明确

00:13:10.591 --> 00:13:12.993
我们的API表达性变得更强
更易被发现

00:13:14.528 --> 00:13:16.830
还是关于枚举这个主题

00:13:17.164 --> 00:13:20.868
很多Foundation API
也使用字符串常量家族

00:13:20.968 --> 00:13:24.671
比如Notification Name
和URL Resource Key

00:13:25.472 --> 00:13:30.377
Swift支持建立在
其它原始类型上的枚举类型

00:13:30.444 --> 00:13:33.413
可以是整型以外的类型
包括字符串类型

00:13:33.847 --> 00:13:36.750
若我们在Objective-C里
也能做到这些岂不更妙？

00:13:37.317 --> 00:13:40.087
今年 我们可以了
常量现在被定义成了

00:13:40.153 --> 00:13:42.823
类型非常具体的字符串常量

00:13:42.956 --> 00:13:46.326
如Notification Name
及URL Resource Key

00:13:46.727 --> 00:13:47.794
以及很多很多别的

00:13:49.630 --> 00:13:53.867
这些常量保留了可扩展性
无论在Objective-C里

00:13:54.501 --> 00:13:56.537
还是在Swift里

00:13:56.603 --> 00:14:02.476
我们都可以对它们进行嵌套
就像对待它们的兄弟整数类型一样

00:14:03.277 --> 00:14:06.213
这样在Swift 3中使用它们
非常自然 表达性也很强

00:14:06.813 --> 00:14:10.918
另一个常见的Foundation
设计模式是把状态和类型联系起来

00:14:11.185 --> 00:14:14.087
比如standardUserDefaults

00:14:14.821 --> 00:14:19.560
Swift对于类属性的支持
可以很好地适用于这里

00:14:20.694 --> 00:14:24.264
今年我们把类属性
引入了Objective-C

00:14:24.331 --> 00:14:26.633
它们的定义和对象属性一样

00:14:26.700 --> 00:14:29.469
除了现在我们支持这个
酷酷的类别关键词

00:14:29.736 --> 00:14:33.273
由于我们知道它是类属性

00:14:33.340 --> 00:14:36.543
我们不需再像Swift 2.2那样
把它作为函数引入

00:14:36.643 --> 00:14:39.646
它现在可以作为类属性出现

00:14:39.713 --> 00:14:42.449
如同你会在Swift里定义一样

00:14:43.584 --> 00:14:44.885
但我们没有止步于此

00:14:46.019 --> 00:14:48.155
有些累赘的词
在Swift 3中

00:14:48.222 --> 00:14:50.791
我们彻底修改了
Swift代码的显示方式

00:14:50.858 --> 00:14:53.093
以及Swift里
Objective-C代码的显示方式

00:14:53.393 --> 00:14:56.597
所以我们的最终API更像这个

00:14:57.164 --> 00:15:00.033
我们知道它是userDefault
通过帮助把Foundation

00:15:00.100 --> 00:15:02.236
变得更像Swift
我们获取了很多好处

00:15:02.302 --> 00:15:04.304
无论是对于Objective-C
还是Swift

00:15:06.273 --> 00:15:09.943
Tony刚才说很多Foundation
类型值得变成数值类型

00:15:10.010 --> 00:15:12.546
我谈谈其中的一些
我们从Date说起

00:15:14.281 --> 00:15:16.316
假设我们要安排一条备忘录

00:15:16.383 --> 00:15:17.784
提醒我们什么时候该回家

00:15:17.851 --> 00:15:21.355
我们从Swift 2.2开始
引出我们的例子

00:15:21.555 --> 00:15:25.025
假设我们有一个函数
它会告诉我们什么时候应该回家

00:15:25.092 --> 00:15:29.963
我们调用它
五分钟看起来正适合我们的提醒

00:15:30.030 --> 00:15:32.633
我们继续 你知道的
把它偏移一点

00:15:33.200 --> 00:15:37.538
有一点值得说明 NSDate
是且一直会是一个引用类型

00:15:37.604 --> 00:15:41.375
所以在这里
实际隐藏着两个动态分配

00:15:41.842 --> 00:15:43.777
一个在这里
另一个在这里

00:15:45.412 --> 00:15:48.215
在Swift 3里
我们可以使用Date数值类型

00:15:49.249 --> 00:15:53.086
所以现在我们就来使用它
用法和原来类似

00:15:53.153 --> 00:15:56.490
但是这个变量的行为
和以前大不相同

00:15:56.890 --> 00:15:59.493
特别地 我们允许内联修改

00:16:00.460 --> 00:16:01.562
我们没做额外的事情

00:16:02.196 --> 00:16:04.565
这两个例子做的是一样的事

00:16:04.631 --> 00:16:09.203
除了对于数值类型
我们不需要额外进行动态分配

00:16:09.436 --> 00:16:10.737
继续我们的例子

00:16:11.071 --> 00:16:13.073
当然了
我们也可以这样内联

00:16:15.075 --> 00:16:17.277
关于提醒事项
只有把它安排在事情发生前

00:16:17.344 --> 00:16:19.513
才是有意义的

00:16:20.080 --> 00:16:22.416
Swift带来的最棒的是

00:16:22.482 --> 00:16:28.255
满足某些条件时
协议会自动被采用

00:16:28.322 --> 00:16:31.625
在这个例子里Date自动遵从了
Comparable协议

00:16:31.692 --> 00:16:35.863
它赋予了我们使用小于号的能力
我们现在就在使用

00:16:36.797 --> 00:16:39.399
我们可以设定定时器
但首先我们要创建它

00:16:39.466 --> 00:16:42.035
我们要使用另一个今年的新API

00:16:42.336 --> 00:16:45.973
就是这个看起来很棒的
基于闭包的定时器API

00:16:46.306 --> 00:16:48.308
我们用一个闭包初始化定时器

00:16:48.375 --> 00:16:50.577
不再需要selector
和target了

00:16:51.712 --> 00:16:53.580
我们把它安排在主RunLoop上

00:16:59.052 --> 00:17:03.056
我相信线程和RunLoop
也有这样的方法

00:17:03.123 --> 00:17:05.559
把它安排在主RunLoop上
然后就完成了

00:17:06.460 --> 00:17:09.730
这是个绝佳的例子 它展示了所有熟悉的
Foundation API是如何

00:17:09.796 --> 00:17:12.266
如此优雅地
移植到Swift 3里的

00:17:12.799 --> 00:17:16.069
这是我能在演示里展示的最具
Foundation特色的代码

00:17:16.136 --> 00:17:18.137
我有个RunLoop
一个定时器及几个日期

00:17:18.204 --> 00:17:21.808
基本上全是Foundation的内容
极少的其他内容

00:17:22.108 --> 00:17:23.977
看不到任何方括号

00:17:25.612 --> 00:17:28.782
另一个新例子
或说Fondation里另一新类型

00:17:28.849 --> 00:17:30.350
Measurement数值类型

00:17:31.318 --> 00:17:34.788
假设一个新例子
我们关心上下班线路有多长

00:17:34.855 --> 00:17:37.791
而且我们很幸运
我们住的地方距离上班的地方

00:17:37.858 --> 00:17:38.692
只有两条短街之隔

00:17:39.326 --> 00:17:43.063
Measurement是数值类型
并且Swift支持运算符重载

00:17:43.330 --> 00:17:44.932
它们不仅仅是数值类型

00:17:44.998 --> 00:17:50.838
它们还是Mathematical类型
所以给它们设置运算符有实际意义

00:17:51.405 --> 00:17:54.474
没人会轻视它或不待见它

00:17:54.541 --> 00:17:56.977
如果我们考虑把它们加起来

00:17:57.044 --> 00:18:00.547
我们就可以计算出它们的总和
甚至对它们进行转换

00:18:00.614 --> 00:18:01.815
转换成另一个单位

00:18:02.049 --> 00:18:05.285
假设我们很好奇
想知道去工作路上要花费多久

00:18:05.552 --> 00:18:06.920
这个我们也能做到

00:18:07.287 --> 00:18:10.190
只是在Swift 3里
如果我们试着编译这段代码

00:18:10.257 --> 00:18:12.960
它会失败的
而且是在编译的时候失败

00:18:13.026 --> 00:18:16.563
得益于Swfit 3中
泛型和类型限制的能力

00:18:17.030 --> 00:18:20.267
我们设计成
让单位的区别

00:18:20.334 --> 00:18:21.869
在编译的时候就可以看出来

00:18:22.002 --> 00:18:24.004
Swift编译器可检测出
然后提醒我们

00:18:24.071 --> 00:18:26.173
我们正在进行无效转换

00:18:26.707 --> 00:18:30.210
想了解更多Measurement类
单位以及今年新引入类型的

00:18:30.277 --> 00:18:33.180
整个新的生态系统的话
记得去收听这场演讲

00:18:33.247 --> 00:18:37.017
在周五下午 了解更多
Measurements和单位

00:18:38.118 --> 00:18:39.953
换一个例子

00:18:41.488 --> 00:18:43.390
我说过这将是一场探索

00:18:43.991 --> 00:18:45.692
假设我们想买几台MacBook

00:18:45.826 --> 00:18:48.161
会使用新
URLComponent数值类型

00:18:48.896 --> 00:18:50.564
可以表达性很强地做到

00:18:51.198 --> 00:18:53.300
从描述可变部分开始

00:18:53.367 --> 00:18:55.569
把它作为下面的模板

00:18:55.802 --> 00:18:58.572
遍历我们想要购买的产品

00:19:00.140 --> 00:19:03.844
复制我们的模板
然后修改这个副本

00:19:03.911 --> 00:19:06.213
指定我们想要买的产品

00:19:06.980 --> 00:19:09.783
在这里
我们可以放心地展开这个可选类型

00:19:10.083 --> 00:19:13.287
因为在我们的模板里把它设为了非空

00:19:14.421 --> 00:19:18.358
继续把我们的URL打印出来
我们发现可以

00:19:20.427 --> 00:19:26.633
不进行任何内存管理
创建我们想要购买的产品的链接

00:19:26.967 --> 00:19:30.604
只需声明我们的意图
指明是否可变

00:19:30.671 --> 00:19:33.273
然后语言就会为我们处理好剩下的事

00:19:35.175 --> 00:19:38.979
Swift 3 或者广泛地说Swift
带来的另一个特性

00:19:39.046 --> 00:19:42.549
是ProtocolComponents
在很多Foundation类型中 比如Date

00:19:42.683 --> 00:19:46.553
得到了有用的新能力
这得益于新的遵循协议的方式

00:19:46.653 --> 00:19:51.391
比如CharacterSet和IndexSet
现在遵循SetAlgebra协议

00:19:51.458 --> 00:19:54.094
你可以对它们进行并集
交集 对称差集操作

00:19:54.161 --> 00:19:55.495
根据你的需要

00:19:56.463 --> 00:19:59.032
Data现在遵循
8位无符号整数的

00:19:59.333 --> 00:20:02.803
MutableCollection协议和
MutableRandomAccessCollection协议

00:20:03.403 --> 00:20:05.339
就像你一直认为的那样

00:20:06.740 --> 00:20:10.244
我们来看看遵从新的协议后
Data现在能做些什么

00:20:11.278 --> 00:20:15.482
首先需要一些数据
我手头上有一些Base64数据

00:20:15.549 --> 00:20:17.885
通过普通的初始化函数
进行解析

00:20:18.785 --> 00:20:23.690
这里有个显式展开
我知道这么做是安全的

00:20:23.757 --> 00:20:27.060
因为这里只是个演示
我知道它是有效的Base64值

00:20:28.929 --> 00:20:31.899
你自己使用过程中
可能需要用到try语句

00:20:31.965 --> 00:20:36.670
我喜欢统计
以及看起来很棒的图表

00:20:36.737 --> 00:20:40.507
当你的统计用直方图的形式表现时
我们要来建立一个直方图

00:20:40.574 --> 00:20:43.577
我们需要用到后台存储
使用原始的Swift数组

00:20:43.644 --> 00:20:45.012
把它全都初始化为0

00:20:45.078 --> 00:20:49.783
我们把data里
每一字节的值作为索引

00:20:49.850 --> 00:20:51.351
然后维护一个频率计数

00:20:52.686 --> 00:20:55.489
由于Data是一个
Collection 遍历它的字节

00:20:55.556 --> 00:20:58.859
很自然且表达性高
我们可通过一个for-in循环做到

00:20:59.560 --> 00:21:02.095
接着我们创建直方图
来看一看

00:21:02.963 --> 00:21:04.798
这看着绝对像直方图

00:21:04.865 --> 00:21:06.967
就像所有直方图一样
里面有信号和噪声

00:21:07.034 --> 00:21:09.303
我在这看到了不少高频率数据

00:21:09.803 --> 00:21:11.471
我想要把它过滤出去

00:21:11.839 --> 00:21:13.607
幸运的是
Data现在是Collection了

00:21:13.674 --> 00:21:16.143
所以我们可使用到类似Map、
Reduce、Filter的功能

00:21:16.210 --> 00:21:19.146
以及其他你喜欢的
Collection函数

00:21:19.746 --> 00:21:23.517
假设我们想要剔除
所有大于三的数据

00:21:23.717 --> 00:21:26.019
就如同声明谓词一样简单

00:21:26.453 --> 00:21:29.690
然后我们可以就生成
过滤后的数据了

00:21:30.991 --> 00:21:33.327
作为一个Collection
Data是可切分的

00:21:33.760 --> 00:21:37.197
这些切片功能上和Mutable
Collection一样

00:21:37.297 --> 00:21:40.467
或是你在Swift里见到过的
数值类型Collection

00:21:41.735 --> 00:21:44.338
修改它们会触发
同样的写时复制机制

00:21:44.404 --> 00:21:48.208
正如Tony刚才描述的
它们的运行方式完全相同

00:21:49.810 --> 00:21:53.347
Data还保留了可扩展性

00:21:53.413 --> 00:21:55.082
通过继承隐含的引用类型

00:21:55.148 --> 00:21:57.651
这是很重要的一句话
我会详细讲个例子

00:21:57.718 --> 00:21:59.653
来解释我的意思

00:21:59.987 --> 00:22:04.124
举个例子 我们先创建一个
自定义的NSData子类

00:22:04.358 --> 00:22:05.726
不给它分配任何存储空间

00:22:05.859 --> 00:22:08.495
代表一个虚拟的
全是1的Collection

00:22:09.096 --> 00:22:11.598
我们将它名为
AllOnesData 描述性很强

00:22:11.798 --> 00:22:14.768
这里我只展示一个方法的实现

00:22:15.269 --> 00:22:20.574
获取指定的字节getBytes
多少可以实现这个类期望的功能

00:22:20.641 --> 00:22:22.009
我们把所有字节设置为1

00:22:22.976 --> 00:22:24.511
不需要储存任何东西

00:22:25.245 --> 00:22:27.981
接着我们创建一个它的只读对象

00:22:28.849 --> 00:22:31.518
我们不会单纯地使用引用
而是会建立一个数值类型

00:22:31.585 --> 00:22:35.656
并把引用包含其中

00:22:35.889 --> 00:22:39.593
我们使用了刚刚创建的
新的初始化方法

00:22:40.227 --> 00:22:42.095
它和你预期的效果一样

00:22:42.563 --> 00:22:46.900
现在我们的ones数值类型
指向全是1的数据的引用

00:22:46.967 --> 00:22:47.801
它们是虚拟的

00:22:47.868 --> 00:22:50.470
现在不会在内存里占用字节

00:22:50.871 --> 00:22:54.474
现在我们来创建一个可变副本
同样 我们不做任何修改

00:22:54.541 --> 00:22:58.312
所以我们现在不需要分配或管理
任何这些内存中的字节

00:22:59.112 --> 00:23:01.582
我们准备好对bytes进行需改
为了做到这一点

00:23:01.648 --> 00:23:04.585
要用到一个今年新添的
Foundation API

00:23:04.651 --> 00:23:07.688
它是一个Scoped
Pointer Accessor

00:23:08.989 --> 00:23:10.891
叫做withUnsafeMutableBytes

00:23:11.024 --> 00:23:15.395
这比直接对data本身
调用mutableBytes好得多

00:23:15.462 --> 00:23:19.099
因为我们把
对这些字节的访问限制在了

00:23:19.166 --> 00:23:21.068
我们定义的闭包内

00:23:21.635 --> 00:23:23.670
这很好理解

00:23:23.737 --> 00:23:25.372
没有漫天乱飞的指针

00:23:25.439 --> 00:23:27.975
指针只在这个小的访问器内部有效

00:23:29.376 --> 00:23:32.679
我们实际进行修改
引起写时复制机制

00:23:32.746 --> 00:23:34.114
现在这些字节

00:23:34.214 --> 00:23:37.150
这些复制的字节
真正是可见的内存了

00:23:38.852 --> 00:23:41.755
接着下一个例子
我厌倦谈论Data了

00:23:42.523 --> 00:23:47.261
我们来说说URL
以及URL属性

00:23:47.394 --> 00:23:48.562
为了说明这个例子

00:23:48.629 --> 00:23:52.065
我想先说一说在Swift 2.2中
我们是怎么做的

00:23:53.100 --> 00:23:56.303
在Swift 2.2我们会请求
NSURL.fileURL

00:23:56.370 --> 00:23:58.005
以my-special-file
为例

00:23:58.071 --> 00:24:01.375
这个文件太特殊了
我把它放在我的文件系统的根目录

00:24:02.042 --> 00:24:03.544
我对三个属性很好奇

00:24:03.610 --> 00:24:07.014
我想知道创建日期
它是否是常规文件

00:24:07.247 --> 00:24:11.218
以及出于某些原因
这个文件所处卷的最大文件大小

00:24:11.885 --> 00:24:15.689
这些在Swift 2.2只是字符串
所以这只是个字符串数组

00:24:16.156 --> 00:24:18.292
而且当我向我的URL
请求资源值的时候

00:24:18.358 --> 00:24:21.295
只会得到个普通的字典类型
不包含任何类型信息

00:24:21.361 --> 00:24:25.799
它只是字符串指向对象
这意味着使用它时

00:24:26.834 --> 00:24:29.803
需要用到很多as某个类
所以我必须

00:24:29.870 --> 00:24:32.439
暗示说它是布尔型
暗示它是整数型

00:24:32.506 --> 00:24:37.077
我一直在不停检查引用值
来确保我做的是对的

00:24:37.144 --> 00:24:40.047
除此之外
修改只是针对字典类型的

00:24:40.380 --> 00:24:42.416
所以你可以做类似这样的荒唐事情

00:24:45.285 --> 00:24:48.255
并且每一个错误都是运行时错误

00:24:49.256 --> 00:24:51.425
我们来看看Swift 3的改进

00:24:52.659 --> 00:24:55.462
在Swift 3中
建立URL的过程也很类似

00:24:56.029 --> 00:24:59.032
但是我们不再使用类工厂方法

00:24:59.766 --> 00:25:02.669
它变成了普通的初始化语法

00:25:03.370 --> 00:25:05.405
我们现在谈的依然是
my-special-file

00:25:05.939 --> 00:25:09.243
我们不再请求字符串数组

00:25:09.309 --> 00:25:11.812
而是使用强类型的字符串枚举

00:25:11.879 --> 00:25:14.615
正如我之前说的一样
我们要创建它们的集合

00:25:15.482 --> 00:25:17.384
当我们向URL请求资源值时

00:25:17.451 --> 00:25:19.319
我们得到的不再是个字典

00:25:19.520 --> 00:25:23.590
我们会得到一个值
一个新的Foundation数值类型

00:25:23.657 --> 00:25:25.692
我们看看这个
Foundation值的类型是什么

00:25:25.759 --> 00:25:28.428
针对我们请求的三个属性

00:25:29.296 --> 00:25:31.698
你可以看到creationDate
是一个Date

00:25:31.865 --> 00:25:33.200
isRegularFile
是一个Bool

00:25:33.267 --> 00:25:35.402
volumeMaximumFileSize
是一个Integer

00:25:37.271 --> 00:25:39.706
而且还有一点需要指出的是

00:25:39.773 --> 00:25:42.276
URLResourceValue
结构本身是惰性的

00:25:42.342 --> 00:25:44.578
它仍然是用字典实现的

00:25:45.045 --> 00:25:47.548
正如Swift 2 API一样
没有必要

00:25:47.614 --> 00:25:51.251
这个巨大的Struct会消耗内存

00:25:51.318 --> 00:25:54.388
我请求了三个东西
就会得到三个东西

00:25:54.721 --> 00:25:57.457
如果你有自定义keys
字典还是在那里

00:25:57.524 --> 00:26:00.527
你请求的不是字符串
而是你所感兴趣的

00:26:00.594 --> 00:26:01.995
URLResourceKey

00:26:02.563 --> 00:26:04.665
你可能注意到有很多问号

00:26:04.731 --> 00:26:07.167
原因就是 恩
其实有两个原因

00:26:07.234 --> 00:26:09.102
第一个原因是你并没有请求它

00:26:09.469 --> 00:26:11.505
所以这个创建日期就不存在

00:26:11.572 --> 00:26:13.807
这涉及到数据的稀疏性

00:26:14.074 --> 00:26:15.943
第二个它不存在的原因是

00:26:16.009 --> 00:26:19.046
就是属性本身可能是无效的

00:26:19.279 --> 00:26:21.982
volumMaximumFileSize就是个例子

00:26:22.049 --> 00:26:24.284
我们来看看
两个关于工作原理的例子

00:26:25.519 --> 00:26:27.654
因为我们请求的是普通文件

00:26:27.721 --> 00:26:30.724
我们完全可以显式展开
这个Optional值

00:26:30.958 --> 00:26:32.593
它会出现在此
因为我们请求了它

00:26:32.659 --> 00:26:35.729
然而 VolumeMaximumFileSize
的文档里面说到

00:26:35.796 --> 00:26:37.764
不是所有的卷
或所有的文件系统

00:26:37.831 --> 00:26:41.235
都支持最大文件尺寸这个属性
所以它可能并不在那儿

00:26:41.435 --> 00:26:45.639
这是Swift里
使用if let结构的绝佳例子

00:26:45.706 --> 00:26:47.708
有条件的设置局部变量

00:26:49.877 --> 00:26:51.378
现在咱们说说修改

00:26:51.445 --> 00:26:55.482
当然URLResourceValues中
URL的修改API

00:26:55.549 --> 00:26:58.418
与它新的值类型相关
所以当你尝试这么做的时候

00:26:58.485 --> 00:27:00.087
尽管这是我的特殊文件

00:27:00.153 --> 00:27:02.689
我非常努力地说它不是常规的

00:27:02.756 --> 00:27:04.925
编译器会在我编译的时候就会报错

00:27:04.992 --> 00:27:07.694
而不是让我自己在运行时
发现这个问题

00:27:07.828 --> 00:27:12.266
更进一步 文件创建日期也是强类型的
类型为Date

00:27:12.332 --> 00:27:16.904
如此荒唐的事 在Siri那可能行得通
但写代码的时候是不可能的

00:27:19.139 --> 00:27:22.543
关于Foundation的探索
我最后想说的一点

00:27:22.609 --> 00:27:24.778
就是Swift的原始枚举类型

00:27:24.912 --> 00:27:27.481
然后我们又要再一次
谈谈数据了

00:27:27.548 --> 00:27:29.449
因为有个例子真的很不错

00:27:30.217 --> 00:27:32.719
当data拥有一个
UnsafeMutablePointer时

00:27:32.786 --> 00:27:35.155
你可以选择设置
一个deallocator

00:27:36.557 --> 00:27:38.492
Data默认支持多种类型

00:27:39.726 --> 00:27:43.463
包括自定义deallocator

00:27:44.231 --> 00:27:48.969
现在 Swift支持
把值和枚举相关联

00:27:49.036 --> 00:27:50.938
你经常会看到这些和整数关联

00:27:51.004 --> 00:27:54.842
你可以在case表达式里使用它们
这样你就可以

00:27:54.908 --> 00:27:57.945
用它们做一些很酷的模式匹配
但这里我们接受的是一个闭包

00:27:58.011 --> 00:28:01.515
因为我们想把你提供的行为
包含其中

00:28:01.715 --> 00:28:03.083
我们来实际做一下

00:28:03.183 --> 00:28:05.085
我们从一个简单的
malloc例子说起

00:28:05.752 --> 00:28:07.087
在Swift
你依然可使用malloc

00:28:07.154 --> 00:28:10.357
尽管你在演示中不常看到它

00:28:10.524 --> 00:28:15.028
使用malloc分配内存
当你把这个指针指向Data时

00:28:15.162 --> 00:28:17.064
你可以把deallocator
设置为free

00:28:19.032 --> 00:28:23.203
语法和使用集成值一样简单

00:28:23.437 --> 00:28:24.805
我们再看一个自定义的例子

00:28:24.872 --> 00:28:28.942
假设我们有一个函数
create_glorious_pointer

00:28:29.009 --> 00:28:31.378
我们想光荣地释放它

00:28:31.445 --> 00:28:32.479
以免它们受到冒犯

00:28:32.846 --> 00:28:37.618
设置自定义deallocator非常简单
只需提供一个闭包

00:28:37.684 --> 00:28:40.220
并且确保你进行了想要进行的操作

00:28:41.288 --> 00:28:42.656
这非常强大

00:28:42.723 --> 00:28:46.994
对于框架开发者来说
也是一个很强大的概念

00:28:47.294 --> 00:28:50.664
因为在别的语言里 我们不得不

00:28:50.731 --> 00:28:52.933
提供另一个基于函数指针的API

00:28:53.233 --> 00:28:57.938
但在Swift 3里
我们可以直接提供基于枚举的API

00:28:58.005 --> 00:29:01.208
它可以简洁地表达所有内容
非常有表现力

00:29:02.342 --> 00:29:04.311
至此我们的API探索之旅结束了

00:29:04.545 --> 00:29:06.113
但愿我们见到了不少奇妙之处

00:29:06.180 --> 00:29:08.949
现在让Tony给大家
详细讲讲Adoption

00:29:16.156 --> 00:29:17.057
谢谢 Michael

00:29:18.692 --> 00:29:21.528
现在你对于可能做到的事情
有了一点大致了解

00:29:21.595 --> 00:29:23.664
我们来谈谈
如何在你的应用中使用

00:29:24.932 --> 00:29:26.700
咱们先来讲讲桥接

00:29:26.934 --> 00:29:29.369
在这个主题上
我们不断迭代更新

00:29:29.436 --> 00:29:32.973
我们把Swift 2里面的一些
你已经熟悉的概念进行了扩充

00:29:33.207 --> 00:29:35.342
用于桥接Objective-C
和Swift

00:29:35.676 --> 00:29:38.111
如果你理解String和
NSString是如何桥接的

00:29:38.178 --> 00:29:40.814
我们把同样的概念
应用到了Data和NSData上

00:29:40.981 --> 00:29:43.050
以及你看到的
这里所有的数据类型

00:29:43.851 --> 00:29:48.488
这就表示所有从
Cocoa SDK引入的API

00:29:48.555 --> 00:29:50.724
都会使用这些新的数据类型

00:29:51.091 --> 00:29:54.628
这就是我们形成杠杆的核心思想

00:29:57.130 --> 00:29:59.466
例如 在Swift 2.2
的AppKit中

00:29:59.533 --> 00:30:02.135
你能看到这个类
名叫NSDatePicker

00:30:02.769 --> 00:30:06.440
它允许我们展示一个UI
并让你的用户选择日期

00:30:06.507 --> 00:30:09.209
除去其他属性
它有两个能够控制日期的属性

00:30:09.510 --> 00:30:11.612
你能在这里看到
它们被标成了@NSCopying

00:30:11.712 --> 00:30:13.647
它们是NSDate引用类型的

00:30:14.948 --> 00:30:17.184
在Swift 3
不改变AppKit前提下

00:30:17.451 --> 00:30:20.821
我们只改变了Foundation
这个类现在看起来是这样的

00:30:20.888 --> 00:30:22.756
你看 我们现在有Date结构类型了

00:30:22.823 --> 00:30:27.160
而且我们不需把它标作@NSCopying了
因为他们是数值类型

00:30:27.227 --> 00:30:28.795
我们会帮你进行复制

00:30:32.132 --> 00:30:34.801
进行桥接可能会有一定的性能折损

00:30:34.868 --> 00:30:37.771
为了介绍原因
我需要深入讲解一下具体细节

00:30:37.838 --> 00:30:39.573
桥接的原理究竟是什么

00:30:39.873 --> 00:30:42.743
桥接有两个主要策略
一个针对大型类型

00:30:42.809 --> 00:30:45.445
它会存储引用
另一个针对小型类型

00:30:45.512 --> 00:30:46.680
它会创建引用

00:30:47.314 --> 00:30:49.550
举个例子
我们再讨论一下数据

00:30:51.118 --> 00:30:52.452
我又创建了一次data

00:30:52.519 --> 00:30:54.755
它是一个结构体
包含了一个引用类型数据

00:30:55.222 --> 00:30:57.324
若调用
Objective-C的API

00:30:57.391 --> 00:31:01.128
将会发生的是 我们把引用交到
Objective-C端处理

00:31:01.261 --> 00:31:03.897
因为Objective-C
不会处理结构体数据

00:31:03.964 --> 00:31:05.499
它只能看懂NSData

00:31:05.933 --> 00:31:08.168
在这个例子里
也许对于同步方法调用

00:31:08.235 --> 00:31:11.572
Objective-C的代码
在任何时间都不会持有这个数据

00:31:11.638 --> 00:31:13.373
它可以访问它
随后就忘记它

00:31:13.440 --> 00:31:16.510
仅仅保存一小段时间引用即可

00:31:17.110 --> 00:31:22.416
你会看到
许多API会长时间持有数据

00:31:22.482 --> 00:31:25.953
通常会被标注上Copying属性

00:31:26.854 --> 00:31:28.789
那样 在Objective-C中

00:31:29.056 --> 00:31:31.692
Objective-C代码
会调用数据的复制方法

00:31:32.059 --> 00:31:33.760
因为它需要保护自己

00:31:33.827 --> 00:31:36.864
以免潜在的对于原始数据的修改

00:31:36.930 --> 00:31:38.332
从一个完全未知的来源

00:31:39.199 --> 00:31:42.469
这意味着 当发生桥接时
可能发生数据的复制

00:31:43.237 --> 00:31:44.371
我们把它翻过来看

00:31:44.471 --> 00:31:47.274
这里是一段Swift代码
它调用了Objective-C方法

00:31:47.341 --> 00:31:48.742
并获取返回的数据

00:31:48.809 --> 00:31:52.779
这里 Objective-C代码
创建了NSData类

00:31:52.846 --> 00:31:54.281
当它回到Swift的时候

00:31:54.648 --> 00:31:56.984
我们建立结构体数据
并把引用包含其中

00:31:57.050 --> 00:32:00.354
然后调用复制方法
原因和上一页演示文档说的一样

00:32:00.721 --> 00:32:03.156
这个结构体需要保持
它对这份副本的控制

00:32:03.223 --> 00:32:06.426
这样它才可以向你提供
正确的语义

00:32:07.895 --> 00:32:10.330
幸运的是 基本上所有通过这个方式
接收到的来自SDK的数据

00:32:10.397 --> 00:32:12.032
都是不可变的

00:32:12.232 --> 00:32:14.501
这意味着 这份副本在本质上
只用于保持计数

00:32:14.568 --> 00:32:16.403
但是有一点很重要
需要明白

00:32:16.470 --> 00:32:18.872
当桥接的时候
可能会出现复制操作

00:32:19.940 --> 00:32:23.377
对于小的类型 比如Date
你会发现并不存在引用

00:32:23.443 --> 00:32:25.846
我们刚才看到了它的实现
只有一个Double

00:32:25.913 --> 00:32:30.384
所以在Swift里 若我调用了一个
Objective-C的函数或方法

00:32:30.851 --> 00:32:35.656
它接受一个Date 我们需通过桥接
分配一个NSDate

00:32:36.323 --> 00:32:39.893
那是因为Objective-C代码
只知道如何处理引用类型

00:32:40.194 --> 00:32:41.995
在Objective-C方面
我们采用了很多技巧

00:32:42.062 --> 00:32:44.831
使NSDate分配的开销很小

00:32:45.132 --> 00:32:49.002
这点很重要 我们要明白
桥接的时候会产生内存分配

00:32:53.473 --> 00:32:56.043
所以我们优化了这些数据类型
以适配Swift

00:32:56.910 --> 00:33:00.814
在你的编码中
你应该避免来回桥接

00:33:01.748 --> 00:33:04.251
这是因为我们想让我们的
编码默认是安全的

00:33:04.585 --> 00:33:07.087
但是它确实说明
在这里可能有潜在的复制操作

00:33:07.154 --> 00:33:10.958
这是使用新的数值类型时
需要注意的几点

00:33:12.059 --> 00:33:13.594
现在咱们来谈一谈迁移

00:33:14.261 --> 00:33:15.462
先来说说好消息

00:33:16.096 --> 00:33:19.833
我们今天说的新类型
适用于所有Swift部署目标

00:33:20.400 --> 00:33:22.369
这些都是Swift标准库的一部分

00:33:22.436 --> 00:33:24.204
所以你不需要等待客户

00:33:24.271 --> 00:33:26.673
升级到我们最新版本的平台

00:33:26.740 --> 00:33:28.909
一旦Swift 3和
Xcode 8发布

00:33:28.976 --> 00:33:30.677
你马上就可以使用它们

00:33:32.112 --> 00:33:34.982
现在 为了帮助你
我们升级了Migrator

00:33:35.349 --> 00:33:38.585
这就代表当你打开Xcode 8里
你的项目

00:33:38.652 --> 00:33:42.189
你会看到一个类似这个的对话框
我建议你点击Convert

00:33:42.489 --> 00:33:45.726
我来展示一下
Migrator可以帮你做的一些事

00:33:47.227 --> 00:33:49.663
现在我们在Swift 2.2中
有一些NSDate

00:33:50.163 --> 00:33:53.066
我们调用它的
dateByAddingTimeInterval方法

00:33:53.400 --> 00:33:56.470
Migrator会把NSDate
这个引用类型

00:33:56.537 --> 00:33:58.505
修改为结构类型的Date

00:33:59.139 --> 00:34:01.041
然后它会改变方法

00:34:01.241 --> 00:34:04.645
因为它们已依据最新的Swift 3
API设计指引进行了修改

00:34:04.945 --> 00:34:07.381
无论是针对引用类型
还是数值类型

00:34:08.549 --> 00:34:09.683
我们再来举一个例子

00:34:10.016 --> 00:34:12.652
我在Swift 2里创建了一个
NSDateComponents

00:34:12.886 --> 00:34:15.222
然后对它的属性进行了设定

00:34:15.789 --> 00:34:19.893
我能做到这些是因为NSDateComponents
永远是可变的引用类型

00:34:20.561 --> 00:34:23.463
Swift 3里引入了新的结构体
DateComponents

00:34:23.597 --> 00:34:26.166
所以Migrator
会把引用变成结构

00:34:26.366 --> 00:34:30.469
但是它注意到你对它进行了修改
所以它还会帮你把let改成var

00:34:31.438 --> 00:34:33.540
Migrator可以帮你做很多

00:34:33.806 --> 00:34:36.844
但有些地方
如果你检查一下它做了什么

00:34:36.909 --> 00:34:40.347
你自己可以做到更好
利用我们提供的新功能

00:34:40.647 --> 00:34:43.516
该例中DateComponents
有一个新的initializer

00:34:43.583 --> 00:34:45.585
这我们只能在Swift里做到

00:34:45.786 --> 00:34:49.389
这个initializer为 DateComponents
里的每一个属性提供了参数

00:34:49.456 --> 00:34:51.725
这些都不是必需项
而且都有默认值

00:34:51.792 --> 00:34:54.962
你可只利用自己在乎的值
创建DateComponents

00:34:55.027 --> 00:34:56.463
比如这个例子里
只提供月和日

00:34:56.697 --> 00:34:58.165
然后把var变回let

00:34:58.232 --> 00:35:01.435
因为初始化后
你不需要改变它

00:35:03.337 --> 00:35:05.005
最后又要说到我们的朋友
Data类型了

00:35:05.072 --> 00:35:08.075
Swift 2里我建立了
一个NSMutableData

00:35:08.175 --> 00:35:10.577
它是一个引用类型
然后我给它添加了一些数据

00:35:11.778 --> 00:35:14.581
在Swift 3里
Migrator会处理好方法名称

00:35:14.781 --> 00:35:18.218
比如contentsOfURL
以及appendData

00:35:19.319 --> 00:35:21.822
而且它会把NSData
变成Data结构

00:35:22.222 --> 00:35:25.025
但是 它没有处理
NSMutableData引用类型

00:35:25.459 --> 00:35:27.961
有些情况下 信息量不够

00:35:28.028 --> 00:35:30.731
Migrator没办法
做到我们认为最佳的选择

00:35:30.797 --> 00:35:33.267
我们不去管它
它依然能正常运行

00:35:33.700 --> 00:35:37.004
但是如果你回去自己做一些修补

00:35:37.070 --> 00:35:38.605
你可以做到些很酷的事情

00:35:38.672 --> 00:35:41.074
我们可以把MutableData
变成Data结构

00:35:41.575 --> 00:35:43.544
即我们把它从let改为var

00:35:43.810 --> 00:35:47.447
还可以删除掉options参数
因为它现在已经有默认值了

00:35:50.484 --> 00:35:53.820
我们今天谈了不少东西
现在让我们来稍微回顾一下

00:35:54.421 --> 00:35:56.456
相信这些对Foundation的改进

00:35:56.523 --> 00:35:58.525
会让整个SDK受益

00:35:58.592 --> 00:36:00.928
并提升你的整个Swift开发体验

00:36:01.328 --> 00:36:03.530
一方面是由于API重命名

00:36:03.897 --> 00:36:06.433
另外我们把握住了机会更进一步

00:36:06.567 --> 00:36:10.470
添加了一套全新的数据类型
以及很多针对Swift的新API

00:36:11.538 --> 00:36:13.473
我们将此视为一段旅程的开始

00:36:13.540 --> 00:36:16.910
并且在未来
我们也愿意继续成为支点

00:36:17.311 --> 00:36:19.112
我们要做很多改进

00:36:19.179 --> 00:36:22.082
让你的Swift应用
更安全 更迅速 表达性更好

00:36:23.217 --> 00:36:25.552
有兴趣多了解的话
去查看下这个URL结构

00:36:26.453 --> 00:36:29.323
以及这些相关演讲 包括

00:36:29.389 --> 00:36:32.426
使用Swift Open Source深入服务器端
Measurement类型和Unit类型

00:36:34.127 --> 00:36:35.028
谢谢大家