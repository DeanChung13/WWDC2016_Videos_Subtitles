00:00:19.553 --> 00:00:23.390
掌握tvOS的UIKit

00:00:24.157 --> 00:00:26.960
欢迎来到
“掌握tvOS的UIKit”

00:00:27.661 --> 00:00:29.563
我是Justin
我负责UIKit工作

00:00:29.830 --> 00:00:32.266
我在这里向你展示
如何超越普通点

00:00:32.332 --> 00:00:35.169
真正让你的tvOS应用达到新高度

00:00:36.870 --> 00:00:38.939
要做到那些 我们今天需要讨论几件事

00:00:39.473 --> 00:00:40.974
首先是事件处理

00:00:41.275 --> 00:00:43.043
你的应用将会收到什么样的事件

00:00:43.110 --> 00:00:45.312
处理这些事件的最好方法
是什么

00:00:46.780 --> 00:00:48.582
然后我们会讨论分层图片

00:00:48.649 --> 00:00:51.285
这是tvOS独一无二的用户界面元素

00:00:51.351 --> 00:00:53.387
我们将展示如何利用它

00:00:55.222 --> 00:00:56.823
第三 我们将讨论滚动条

00:00:56.890 --> 00:00:59.826
滚动条在tvOS的工作方式
与在iOS中有些不同

00:00:59.893 --> 00:01:02.262
我们将展示如何控制滚动条

00:01:03.797 --> 00:01:05.599
最后我们将讨论文本输入

00:01:05.699 --> 00:01:07.167
和如何使用系统键盘

00:01:07.234 --> 00:01:08.735
接收用户的文本

00:01:09.469 --> 00:01:11.738
让我们开始吧 首先进入事件处理

00:01:12.472 --> 00:01:14.007
当讲到事件处理

00:01:14.341 --> 00:01:15.943
这里几个全面的最佳实践

00:01:16.009 --> 00:01:17.644
我马上与你们分享

00:01:18.045 --> 00:01:21.548
第一个是当它允许你的用户

00:01:21.615 --> 00:01:23.016
去导航你的应用程序

00:01:23.083 --> 00:01:25.219
并转移焦点从一个项目到另外一个项目

00:01:25.652 --> 00:01:28.155
你不需要写任何你自己的事件处理程序

00:01:28.222 --> 00:01:30.858
焦点引擎会为你处理一起

00:01:31.225 --> 00:01:33.627
包括处理不同类型的事件

00:01:33.694 --> 00:01:36.463
基于用户当前使用的输入设备类型

00:01:36.597 --> 00:01:38.232
它会为你处理好一切

00:01:41.201 --> 00:01:43.971
第二 如果你决定需要开始处理事件

00:01:44.037 --> 00:01:46.373
我们建议你开始使用
UIGestureRecognizer

00:01:46.640 --> 00:01:48.509
不仅得到一个极富表现力的API

00:01:48.575 --> 00:01:51.912
而且它会帮助确保你的应用里
所有的手势和交互

00:01:51.979 --> 00:01:54.982
将同所有系统应用和其他应用保持一致

00:01:57.484 --> 00:02:00.087
最终 当你正在设计应用交互模型

00:02:00.153 --> 00:02:01.922
记住并非每个输入设备

00:02:01.989 --> 00:02:03.457
能够生成每一种类型的事件

00:02:03.657 --> 00:02:06.126
例如 一个用户可能使用游戏控制器

00:02:06.193 --> 00:02:07.661
来导航你的应用程序

00:02:07.861 --> 00:02:10.030
游戏控制器能够生成触摸事件

00:02:10.097 --> 00:02:11.765
你可能不想使用触摸事件

00:02:11.832 --> 00:02:13.834
作为与你应用交互的唯一方式

00:02:13.901 --> 00:02:16.136
所以当你正在设计应用时记住这些

00:02:18.071 --> 00:02:19.473
谈到触摸

00:02:19.673 --> 00:02:21.141
我们在tvOS上的触摸技术

00:02:21.208 --> 00:02:23.177
在Siri Remote上
使用触摸表面

00:02:23.644 --> 00:02:25.479
我们以UITouch交付给你

00:02:25.546 --> 00:02:27.748
它是一个API
你可能从iOS中认出

00:02:28.182 --> 00:02:30.984
一次触碰代表用户手指

00:02:31.218 --> 00:02:32.886
和遥控器屏幕的联系

00:02:35.189 --> 00:02:36.223
这就像iOS版本

00:02:36.290 --> 00:02:37.925
他包括位置和其他属性

00:02:37.991 --> 00:02:38.959
你经常使用的

00:02:39.960 --> 00:02:41.028
这点是很重要的差别

00:02:41.094 --> 00:02:43.297
tvOS和iOS的触摸技术之间

00:02:43.697 --> 00:02:46.667
iOS触摸直接发生于用户界面

00:02:46.733 --> 00:02:49.136
用户肢体触摸UI

00:02:49.837 --> 00:02:51.271
tvOS却并非如此

00:02:51.338 --> 00:02:53.006
离用户界面10英尺远

00:02:53.140 --> 00:02:54.842
用户触摸的是其遥控器

00:02:55.409 --> 00:02:58.245
所以我们把这些分为两个不同的类别

00:02:58.312 --> 00:03:00.347
我们称在iOS上的为直接触摸

00:03:00.414 --> 00:03:02.850
在tvOS上的为间接触摸

00:03:03.150 --> 00:03:06.053
我们称该触摸类型为
UITouchTypeIndirect

00:03:06.119 --> 00:03:07.921
来帮助你区分两者不同

00:03:09.656 --> 00:03:12.626
因为这种间接触摸
假如你问UITouch

00:03:12.693 --> 00:03:16.463
在一个直接触摸界面
“你在屏幕上位置是什么？”

00:03:16.730 --> 00:03:17.865
答案显而易见

00:03:17.931 --> 00:03:18.932
我们提供一个位置

00:03:18.999 --> 00:03:21.602
它能准确配对用户手指在屏幕上的位置

00:03:21.902 --> 00:03:23.737
但是在tvOS
用户不会触摸屏幕

00:03:23.804 --> 00:03:25.839
那我们会怎么报告触摸的位置呢？

00:03:26.740 --> 00:03:28.008
在这情况下 我们会

00:03:28.075 --> 00:03:30.544
无论用户手指在遥控器上
从何处开始触摸

00:03:30.611 --> 00:03:32.513
我们总将该触摸传递至你的应用

00:03:32.579 --> 00:03:35.516
好像它是从焦点视图的中央直接开始的

00:03:36.149 --> 00:03:37.384
这方法很好
因为它意味着

00:03:37.451 --> 00:03:39.820
任何手势识别器或事件处理逻辑

00:03:39.887 --> 00:03:41.855
你可能已附加到焦点视图上

00:03:42.122 --> 00:03:44.625
将总有机会参与到手势上

00:03:46.593 --> 00:03:47.995
我们不能暴露的是

00:03:48.061 --> 00:03:49.563
用户手指的绝对位置

00:03:49.630 --> 00:03:50.464
在触控板上

00:03:50.531 --> 00:03:52.933
我们为什么那么做是有一些原因的
其中最重要的一点是

00:03:52.999 --> 00:03:56.270
在tvOS上
我们想阻止基于指针的UI

00:03:56.336 --> 00:03:58.071
我们不想看到一些如鼠标指针类的东西

00:03:58.138 --> 00:03:59.139
或像它一样的

00:03:59.206 --> 00:04:01.041
我们真的很希望应用程序能够坚持

00:04:01.108 --> 00:04:02.910
我们所创建的焦点交互模型

00:04:05.412 --> 00:04:06.747
除了触摸

00:04:06.813 --> 00:04:08.849
你还能在tvOS上获得另外一种事件

00:04:08.916 --> 00:04:10.250
它们被称作按下

00:04:10.651 --> 00:04:13.153
按下方法
通过经典UIPress类提供

00:04:13.487 --> 00:04:16.290
一次按下代表一个真实的硬件按钮

00:04:16.356 --> 00:04:17.891
用户正在与它交互

00:04:18.692 --> 00:04:21.695
并不是所有的这些按钮被简单按下
或者没被按下

00:04:21.762 --> 00:04:23.997
比如游戏控制器这样的一些按钮
是压力感应的

00:04:24.064 --> 00:04:26.967
我们能真实检测到用户按下按钮的强度

00:04:27.034 --> 00:04:28.669
我们可以把那个信息传递给你

00:04:30.437 --> 00:04:31.305
你能够识别按下

00:04:31.371 --> 00:04:32.706
通过UIGestureRecognizer类

00:04:32.773 --> 00:04:34.842
包括如TapGestureRecognizer

00:04:34.908 --> 00:04:36.610
和LongPressGestureRecognizer

00:04:38.078 --> 00:04:39.646
我们有低级别的按下处理事件

00:04:39.713 --> 00:04:42.482
它与低级别的触摸处理事件
遵循相同的模式

00:04:42.549 --> 00:04:44.518
pressesBegan会触发

00:04:44.585 --> 00:04:46.186
一旦用户开始按下按钮

00:04:46.253 --> 00:04:47.955
pressesChanged方法
会被调用

00:04:48.021 --> 00:04:49.289
若它是一个压力感应按钮

00:04:49.356 --> 00:04:50.958
并且压力值会改变

00:04:51.491 --> 00:04:53.760
还有pressesEnded
和pressesCancelled

00:04:53.827 --> 00:04:56.797
像touchesCancelled
是的 你真的必须执行它

00:04:57.965 --> 00:04:59.833
关于这些方法 有件事需要知道

00:04:59.900 --> 00:05:03.003
那就是按下事件
以为它们不是真的有一个位置

00:05:03.070 --> 00:05:04.738
它们直接传递到焦点视图

00:05:04.805 --> 00:05:06.707
他们从那里到达响应者链

00:05:06.773 --> 00:05:09.009
它们不会去任何焦点视图的子视图

00:05:09.076 --> 00:05:10.911
所以要记住这点 当你决定

00:05:10.978 --> 00:05:12.946
把什么样的视图附加到手势识别器上

00:05:15.315 --> 00:05:16.750
我们说了好多关于按下的事

00:05:16.817 --> 00:05:18.051
让我们过一遍按下的类型

00:05:18.118 --> 00:05:20.687
对于你来说是可用的
和什么类型的按钮会触发它们

00:05:20.754 --> 00:05:21.989
在不同类型的输入设备上

00:05:22.389 --> 00:05:24.191
所以我要向你展示
Siri Remote

00:05:25.092 --> 00:05:27.528
上一代Apple TV
的Apple Remote

00:05:28.428 --> 00:05:29.963
我要向你展示游戏控制器

00:05:30.030 --> 00:05:31.732
幻灯片上没有空间 但是记住

00:05:31.798 --> 00:05:35.035
按下也能够从可编程通用的遥控器里

00:05:35.102 --> 00:05:36.503
和从Bluetooth键盘中产生

00:05:36.570 --> 00:05:38.272
所以有很多方法得到按下

00:05:40.574 --> 00:05:43.377
可能你最常碰到的按下类型是
UIPressTypeSelect

00:05:43.443 --> 00:05:45.646
这种按下类型代表

00:05:45.712 --> 00:05:48.415
用户想激活一个控制或选择一个
CollectionView单元

00:05:48.482 --> 00:05:49.449
诸如此类

00:05:50.117 --> 00:05:52.986
在Siri Remote上
那是在遥控器触摸表面

00:05:53.053 --> 00:05:53.887
之下的按钮

00:05:54.821 --> 00:05:56.690
在Apple Remote上
那是一个银色的圆圈

00:05:56.757 --> 00:05:57.691
在游戏控制器上

00:05:57.758 --> 00:05:59.826
我们使用A按钮生成此按下类型

00:06:01.795 --> 00:06:04.464
另外一种你会碰到的常用按下类型
是UIPressTypeMenu

00:06:04.531 --> 00:06:07.167
这种按下类型指用户想返回

00:06:07.234 --> 00:06:09.169
他们想释放一个presentedviewcontroller

00:06:09.236 --> 00:06:12.372
或甚完全释放你的应用并返回到主界面

00:06:13.006 --> 00:06:16.543
这三者在屏幕上 就是菜单按钮

00:06:17.811 --> 00:06:20.280
在游戏控制器上
我们也使用B按钮

00:06:22.649 --> 00:06:24.818
最后 就是UIPressTypePlayPause

00:06:24.885 --> 00:06:27.754
这对于暂停和播放内容明显是有用的

00:06:27.955 --> 00:06:30.557
但是它也被用作除选择按钮以外的
快捷图标

00:06:30.958 --> 00:06:33.360
所以如果用户选中一个电影海报

00:06:33.594 --> 00:06:36.129
按下选择按钮可能会展示这个
电影的详细信息

00:06:36.196 --> 00:06:38.765
但是按下播放/暂停将直接跳转到回放

00:06:39.566 --> 00:06:41.468
所以这图标有——

00:06:41.535 --> 00:06:43.670
或者有播放/暂停图标的按钮

00:06:43.770 --> 00:06:44.671
在游戏控制器上

00:06:44.738 --> 00:06:46.974
我们将使用X按钮生成按下类型

00:06:48.775 --> 00:06:50.844
为了更完整些 这还有几个按下类型

00:06:50.911 --> 00:06:52.613
它们是定向按下

00:06:52.679 --> 00:06:55.282
所以我们有上 下 左 右箭头按下

00:06:55.349 --> 00:06:56.350
能够被生成

00:06:56.884 --> 00:06:59.686
在Apple Remote上
我们使用四个定向按钮

00:07:00.621 --> 00:07:02.389
在游戏控制器上
有好多方法去实现

00:07:02.456 --> 00:07:03.924
所以我们将使用D pad

00:07:05.192 --> 00:07:07.194
我们也使用定向手柄

00:07:08.161 --> 00:07:10.063
我们甚至生成左和右的按下

00:07:10.130 --> 00:07:11.932
在游戏控制器上使用肩按钮

00:07:13.033 --> 00:07:15.802
在Siri Remote上
这些箭头不是具体的硬件按钮

00:07:15.869 --> 00:07:17.971
所以你可能想到在那里生成是不可能的

00:07:18.038 --> 00:07:19.406
但那其实是错的

00:07:19.640 --> 00:07:21.875
如果你做了一个触摸点击
而非一直长按

00:07:21.942 --> 00:07:23.443
选择按钮 但只是触摸

00:07:23.510 --> 00:07:25.779
在表面的这四个基本方位点

00:07:26.013 --> 00:07:27.214
然后UIKit会检测到它

00:07:27.281 --> 00:07:29.516
将为你生成箭头按下

00:07:29.583 --> 00:07:31.485
这是一个真正简便的导航方法

00:07:31.552 --> 00:07:34.021
一次一项目地通过你的用户界面

00:07:34.488 --> 00:07:36.557
只因用户
正使用Siri Remote

00:07:36.623 --> 00:07:38.792
那并不意味着它们不能生成箭头按下

00:07:40.961 --> 00:07:43.497
我保证你可以用手势识别器去识别它们

00:07:43.564 --> 00:07:46.700
我不会详细过一遍
但是我想给你们举些例子

00:07:46.800 --> 00:07:49.002
你知道 我们可以使用顶端的
TapGestureRecognizer

00:07:49.469 --> 00:07:51.371
我们甚至可能长按 正如你可能这么做

00:07:51.438 --> 00:07:53.674
在tvOS主界面进入编辑模式

00:07:54.274 --> 00:07:56.577
在底层我甚至可以调整所需点击的次数

00:07:56.643 --> 00:07:59.179
所以我现在选择按钮上监听一个双击

00:08:02.082 --> 00:08:04.451
好的 让我们特别谈谈一个按钮

00:08:04.518 --> 00:08:05.786
它是菜单按钮

00:08:06.887 --> 00:08:09.656
菜单按钮在tvOS上有些有趣的行为

00:08:09.723 --> 00:08:11.091
它似乎有两个角色

00:08:11.458 --> 00:08:13.861
它不仅需要在你的应用内部有用

00:08:13.927 --> 00:08:16.129
因为我们要做
诸如释放视图控制器之类的事

00:08:16.196 --> 00:08:18.866
或弹出UINavigationController

00:08:18.932 --> 00:08:20.767
而且它还需要有系统层级的行为

00:08:20.834 --> 00:08:23.170
最终你的应用需要去释放——

00:08:23.237 --> 00:08:25.639
被释放 因而用户可以返回主界面

00:08:25.873 --> 00:08:28.575
若那不可能 你的用户将感到非常沮丧

00:08:28.642 --> 00:08:29.810
可以想象这非常重要

00:08:29.877 --> 00:08:32.712
这就是应用审查的特别关注点

00:08:32.846 --> 00:08:34.515
如果你的应用程序无法退出

00:08:34.581 --> 00:08:37.083
通过按菜单按钮
你可能无法通过应用审查

00:08:37.150 --> 00:08:38.150
我们不想发生这事

00:08:39.453 --> 00:08:41.688
所以这怎样进行？

00:08:41.755 --> 00:08:44.525
我们如何得到它以致菜单按钮不仅

00:08:44.591 --> 00:08:46.693
被应用程序捕获而且可以被系统使用？

00:08:47.261 --> 00:08:48.896
所需技术层面的

00:08:48.962 --> 00:08:52.266
为了你的应用能完美退出并返回主界面

00:08:52.699 --> 00:08:54.501
是当菜单按钮被释放的时候

00:08:54.568 --> 00:08:56.837
pressesEnded事件
需要一路沿

00:08:56.904 --> 00:08:59.373
响应者链向上
若你被UIApplication接收

00:08:59.773 --> 00:09:01.875
如果那不发生 你的应用不会退出

00:09:02.609 --> 00:09:04.044
有时候那正是你想要的

00:09:04.111 --> 00:09:06.113
如果你已深入到
UINavigationController

00:09:06.180 --> 00:09:07.614
用户按下菜单按钮

00:09:07.681 --> 00:09:08.882
他们不想退出你的应用程序

00:09:08.949 --> 00:09:10.484
他们只想返回到前一个视图控制器

00:09:10.918 --> 00:09:13.320
在那种情况下 有可能是
TapGestureRecognizer

00:09:13.387 --> 00:09:14.922
它是用于监听菜单按钮

00:09:15.022 --> 00:09:17.024
如果那个识别器开始识别

00:09:17.090 --> 00:09:19.560
它会发送pressesCancelled到响应者链

00:09:19.626 --> 00:09:21.261
在这种情况下 应用不会退出

00:09:21.328 --> 00:09:24.431
然后UINavigationController
可以抛开视图控制器

00:09:24.498 --> 00:09:27.434
不总发送pressesEnded
到你的应用是可以的

00:09:27.501 --> 00:09:29.469
你只要确认这是可能的

00:09:29.703 --> 00:09:31.538
当它出现在一个合适的时机

00:09:33.473 --> 00:09:34.608
所以正确的做法是

00:09:34.675 --> 00:09:36.543
我们强烈建议你从手势识别器开始

00:09:36.610 --> 00:09:39.346
当你不再对处理菜单按钮感兴趣时

00:09:39.680 --> 00:09:42.216
你需确保GestureRecognizer已移除

00:09:42.282 --> 00:09:45.385
一种做法是从视图中移除
GestureRecognizer

00:09:46.353 --> 00:09:47.487
同时禁用手势

00:09:47.554 --> 00:09:49.456
手势识别器有个属性叫做已启用

00:09:49.523 --> 00:09:52.159
如果你把值设置为假
然后手势将被禁用

00:09:53.493 --> 00:09:54.728
如果你不想那么做

00:09:54.795 --> 00:09:58.732
这里有UIGestureRecognizer delegate API
叫做gestureRecognizerShouldBegin

00:09:59.099 --> 00:10:01.668
你可以执行它
然后对于每个菜单按钮的按下

00:10:01.735 --> 00:10:03.770
你有机会在那刻决定

00:10:03.837 --> 00:10:05.405
是否想处理手势

00:10:07.174 --> 00:10:09.610
如果你正执行低级别按下处理方法

00:10:09.676 --> 00:10:11.612
在pressesEnded实现中

00:10:11.678 --> 00:10:13.914
决定你是否想处理这个事件

00:10:13.981 --> 00:10:16.650
如果你想去处理这个事件
就不要调用super

00:10:17.084 --> 00:10:18.552
但如果你不打算处理这个事件

00:10:18.619 --> 00:10:20.187
就确保调用super

00:10:20.254 --> 00:10:22.322
这样它就可以继续沿响应链向上走

00:10:22.389 --> 00:10:24.892
UIApplication
有机会去接收它

00:10:26.660 --> 00:10:27.694
最后 若你正写游戏

00:10:27.761 --> 00:10:29.730
你只有一个视图控制器是非常常见的

00:10:29.796 --> 00:10:31.298
它是用于展示你的游戏

00:10:31.431 --> 00:10:32.666
所以这种情况下

00:10:32.733 --> 00:10:35.068
你可能考虑使用
GCEventViewController

00:10:35.269 --> 00:10:37.971
它有这个属性
controllerUserInteractionEnabled

00:10:38.305 --> 00:10:39.706
功能是

00:10:39.773 --> 00:10:42.376
当用户使用游戏控制器浏览你的应用时

00:10:42.442 --> 00:10:44.511
不但事件将会到游戏控制器框架中

00:10:44.578 --> 00:10:46.346
这框架可能你早已在游戏中使用

00:10:46.547 --> 00:10:50.017
而且它可能产生UIKit事件
如按下或其他

00:10:50.217 --> 00:10:52.186
当你正在玩游戏
你可能没有兴趣

00:10:52.252 --> 00:10:54.154
接收这些事件的UIKit版本

00:10:54.221 --> 00:10:56.490
如果你设置
controllerUserInteractionEnabled

00:10:56.657 --> 00:10:59.726
值为假 在游戏进行中

00:10:59.793 --> 00:11:03.063
然后按下菜单按钮
不会立刻退出你的应用程序

00:11:03.130 --> 00:11:06.033
取而代之 你将能够捕获它
并你自己处理它

00:11:06.300 --> 00:11:08.569
但是当用户返回到游戏根菜单

00:11:08.635 --> 00:11:10.037
你将把值设置为是

00:11:10.103 --> 00:11:12.339
所以按下菜单按钮能够退出程序

00:11:13.740 --> 00:11:15.542
这就是事件处理

00:11:16.543 --> 00:11:18.345
现在让我们讨论下分层图像

00:11:20.047 --> 00:11:22.082
分层图像是一个用户界面元素

00:11:22.149 --> 00:11:23.617
这是tvOS特有的

00:11:24.117 --> 00:11:27.254
你可能在所有演示中看过这些图像了

00:11:29.089 --> 00:11:30.824
它们最多可以有五层图像

00:11:30.891 --> 00:11:32.860
是移动的parallaxing内容

00:11:34.228 --> 00:11:35.996
这些是应用图标需要的

00:11:36.063 --> 00:11:39.633
在tvOS上 你的应用图标至少两层

00:11:39.867 --> 00:11:41.635
你至少需要对该格式有点熟悉

00:11:41.702 --> 00:11:43.170
如果你将在tvOS上开发

00:11:44.738 --> 00:11:45.506
它们是交互的

00:11:45.572 --> 00:11:48.275
当用户在Siri Remote上
移动手指时

00:11:48.609 --> 00:11:51.678
图像会随着他们的手指移动

00:11:51.745 --> 00:11:53.380
这不仅仅是看起来很好看

00:11:53.447 --> 00:11:56.450
这帮用户意识到他们的输入被实时接收

00:11:56.517 --> 00:11:59.353
帮他们预见焦点运动发生的轨迹

00:12:01.255 --> 00:12:01.889
它们是动画

00:12:01.955 --> 00:12:04.525
所以他们有很多很棒的内置动画

00:12:04.591 --> 00:12:06.226
特别是当它们获取聚焦时

00:12:06.360 --> 00:12:09.062
我们将展示怎样才能协调这些动画

00:12:09.129 --> 00:12:10.898
使你的应用变得生动

00:12:13.400 --> 00:12:15.202
所以让我们来讨论一下交互

00:12:16.637 --> 00:12:19.673
我刚才播放的视频
是UIImageView

00:12:19.740 --> 00:12:21.108
若UIImageView获得聚焦

00:12:21.175 --> 00:12:24.478
它会给你一个很棒的浮动外表

00:12:24.545 --> 00:12:26.713
若你有一分层图像在
ImageView里

00:12:27.381 --> 00:12:29.917
但是这是常出现的情况一个
UI图像不是

00:12:29.983 --> 00:12:31.118
实际获得聚焦的控件

00:12:31.185 --> 00:12:34.721
图像通常是较大控件的组件

00:12:34.788 --> 00:12:37.324
在这种情况下 较大控件将获得聚焦

00:12:37.391 --> 00:12:38.892
所以怎么获取浮动外观

00:12:38.959 --> 00:12:40.928
如果图像不被聚焦？

00:12:41.128 --> 00:12:42.663
它不一定要获得聚焦

00:12:42.763 --> 00:12:44.631
我们已拥有添加至
UIImageView的属性

00:12:44.698 --> 00:12:47.234
叫作
adjustsImageWhenAncestorfocused

00:12:47.668 --> 00:12:49.002
如果你设置它的值为真

00:12:49.069 --> 00:12:51.638
如果任何父图片视图获得聚焦

00:12:51.905 --> 00:12:53.907
然后图像会自动获得浮动外观

00:12:53.974 --> 00:12:55.709
并开始对用户的输入有响应

00:12:57.711 --> 00:12:59.580
而且这些图像也有
“按入”状态

00:12:59.646 --> 00:13:02.516
这与一些正常默认值状态有点不同

00:13:02.583 --> 00:13:04.484
它们就在屏幕上

00:13:04.718 --> 00:13:06.486
它们有种“压入”外观

00:13:06.553 --> 00:13:08.655
好像用户用手压下一样

00:13:09.256 --> 00:13:10.924
你可以手动触发它

00:13:10.991 --> 00:13:13.493
通过在ImageView设置
isHighlighted属性值

00:13:13.560 --> 00:13:16.663
为真或假 那会产生打开或关闭的效果

00:13:17.264 --> 00:13:19.900
你可能想在控件子类里这样做

00:13:19.967 --> 00:13:22.369
当用户开始按下选择按钮 例如

00:13:23.036 --> 00:13:25.472
但有一些情况 我们已为你考虑到了

00:13:25.539 --> 00:13:27.508
你完全没有必要手动去做这些

00:13:27.641 --> 00:13:30.844
这些图像是在
UICollectionViewCells内部

00:13:30.911 --> 00:13:32.913
还有图像在自定义
UIButton内部

00:13:32.980 --> 00:13:35.616
这些情况下 你完全无需管理
isHighlighted属性

00:13:35.682 --> 00:13:37.050
我们会为你管理它

00:13:39.186 --> 00:13:42.356
我们谈过了动画
让我们再进一步了解它

00:13:43.423 --> 00:13:46.527
当这些图像形成时发生的事情之一

00:13:46.593 --> 00:13:48.629
在浮动外观里它们变得更大

00:13:48.695 --> 00:13:49.663
或者看起来更大

00:13:50.330 --> 00:13:51.732
你可能不得不在毗邻使用它

00:13:51.798 --> 00:13:52.866
你可能把它移开

00:13:52.933 --> 00:13:55.536
比如在电影画报下方你有一个标签

00:13:56.170 --> 00:13:58.572
你可以使用自动布局去限制这些

00:13:58.639 --> 00:14:00.641
所以 若我在此有ImageView

00:14:00.807 --> 00:14:03.911
若我改变ImageView大小
使其与图像一样尺寸

00:14:04.912 --> 00:14:06.914
然后你可以限制图像的边框

00:14:06.980 --> 00:14:09.183
但当它放大 边框不变

00:14:09.249 --> 00:14:11.485
但图片的可见度会变

00:14:13.020 --> 00:14:15.656
所以弄清图片获得聚焦时会有多大

00:14:15.722 --> 00:14:18.258
我们展示focusedFrameGuide布局指引

00:14:18.358 --> 00:14:21.528
你可以附加其他限制条件到
那个布局指引上

00:14:21.595 --> 00:14:23.730
这样 那些视图将会离图像足够远

00:14:23.797 --> 00:14:26.567
当它们变大时 不会被剪辑

00:14:27.835 --> 00:14:28.735
让我们过一遍这个

00:14:28.802 --> 00:14:31.205
我在此有个ImageView
并且有个红色轮廓

00:14:31.271 --> 00:14:33.373
它代表UIImageView的框架

00:14:34.374 --> 00:14:37.444
当它获得聚焦时会变大

00:14:37.511 --> 00:14:39.479
但是框架依旧在那个红色轮廓

00:14:41.114 --> 00:14:44.518
这个虚线轮廓显示的就是
focusedFrameGuide的位置

00:14:44.585 --> 00:14:46.353
那个focusedFrameGuide一直在那里

00:14:46.420 --> 00:14:47.955
即使现在没有获取聚焦

00:14:48.021 --> 00:14:49.590
你可以选择其中一个

00:14:49.656 --> 00:14:51.158
以附加布局约束

00:14:52.359 --> 00:14:55.629
或者你可以选择改变哪个活跃约束

00:14:55.696 --> 00:14:57.764
基于该元素现在是否被聚焦

00:14:57.831 --> 00:15:00.701
若你那样做 你真该使用协调API

00:15:00.767 --> 00:15:02.803
那个我们在焦点更新上展示的

00:15:02.870 --> 00:15:05.873
确保动画同系统动画发生时间一致

00:15:06.473 --> 00:15:08.208
系统动画有很多微妙的东西

00:15:08.275 --> 00:15:10.110
比如具体时间

00:15:10.177 --> 00:15:12.346
它取决于用户滑动得多快

00:15:12.412 --> 00:15:14.381
或者视图离屏幕多远被聚焦

00:15:14.448 --> 00:15:15.716
此时它获得聚焦

00:15:16.016 --> 00:15:18.318
所以将目标值放入你的应用
是不太可能的

00:15:18.385 --> 00:15:20.454
你需要使用协调API

00:15:20.521 --> 00:15:23.123
确保你的动画同系统动画匹配

00:15:23.290 --> 00:15:24.391
向你展示这是如何做到的

00:15:24.458 --> 00:15:26.660
我想邀请Randy上台
给你们做个演示

00:15:26.727 --> 00:15:27.594
Randy

00:15:31.865 --> 00:15:32.833
谢谢你 Justin

00:15:33.300 --> 00:15:36.770
今天我将要过一遍这两个
我们经常碰到的情况

00:15:36.937 --> 00:15:39.273
关于添加交互至分层图像

00:15:39.773 --> 00:15:42.643
首先我们将看一个UIButton

00:15:42.809 --> 00:15:45.913
其次我们将看一下
自定义集合视图表单元

00:15:46.413 --> 00:15:49.416
现在开始
我有一个在Xcode中已打开的项目

00:15:49.483 --> 00:15:51.752
有一个资产目录 里面包含分层图像

00:15:51.818 --> 00:15:53.120
我只有一个...

00:15:54.721 --> 00:15:56.490
ViewController子类

00:15:56.857 --> 00:15:58.992
我们将要拖拽出一个按钮——

00:16:03.063 --> 00:16:03.964
到画布

00:16:05.199 --> 00:16:06.266
查看它

00:16:07.534 --> 00:16:09.303
给它一个图像

00:16:17.444 --> 00:16:18.679
我们将删除它的标题

00:16:21.815 --> 00:16:23.684
接下来我们将加几个约束条件

00:16:24.985 --> 00:16:26.887
让它垂直和水平居中

00:16:28.956 --> 00:16:33.427
接下来我们将更新按钮框架来匹配
这些约束条件

00:16:33.594 --> 00:16:35.495
你可以通过下拉菜单来做

00:16:35.796 --> 00:16:39.099
但是我通常用键盘快捷键
Command Option Equals

00:16:40.467 --> 00:16:42.402
如果你仔细看

00:16:42.603 --> 00:16:45.472
按钮的周围有一点额外空间

00:16:46.139 --> 00:16:48.175
这些是边缘内容插图

00:16:48.442 --> 00:16:50.544
我们不需要这些 所以可以删除

00:16:53.113 --> 00:16:54.515
这看来差不多是我们想要的

00:16:54.615 --> 00:16:57.551
我们将构建和运行并且看看它怎样运作的

00:16:58.418 --> 00:17:02.122
我正用tvOS模拟器 但已将Mac
与Siri Remote配对了

00:17:03.257 --> 00:17:07.060
对于交互是怎样工作的
你会得到一个较好的认识

00:17:08.127 --> 00:17:11.464
我的手指正按下选择按钮

00:17:12.132 --> 00:17:15.602
但这只是变暗的效果和稍微压入的效果

00:17:15.969 --> 00:17:17.738
当手指移动到数字转换器上

00:17:17.804 --> 00:17:19.205
它对我的触摸没有回应

00:17:19.640 --> 00:17:20.374
让我们做得更好

00:17:22.576 --> 00:17:23.443
为此

00:17:23.510 --> 00:17:28.882
我将打开Assistant Editor
为ViewController的子类

00:17:29.883 --> 00:17:32.152
为按钮拖拽出一个轮廓

00:17:36.790 --> 00:17:38.192
在viewDidLoad里

00:17:38.258 --> 00:17:41.495
我将从那个按钮里
抓取ImageView

00:17:47.401 --> 00:17:50.337
我要去打开
Justin告诉我们的那个属性

00:17:51.471 --> 00:17:53.607
adjustsImageWhenAncestorFocused

00:17:56.410 --> 00:17:57.978
现在如果我构建并且运行

00:17:59.746 --> 00:18:02.282
你应该看到按钮

00:18:02.349 --> 00:18:04.017
对在遥控器上的手指作出回应

00:18:05.319 --> 00:18:07.354
当我点击它的时候 它推进去

00:18:07.788 --> 00:18:08.989
但是我们仍然还有一个问题

00:18:09.056 --> 00:18:10.757
因为这个按钮的边缘被裁剪了

00:18:11.225 --> 00:18:13.060
由于默认

00:18:13.594 --> 00:18:17.030
按钮的ImageView
把clipsToBounds打开

00:18:17.764 --> 00:18:18.832
我们把它关闭就好

00:18:19.967 --> 00:18:20.868
再一次构建和运行

00:18:22.002 --> 00:18:23.770
我们应该能够得到我们想要的结果

00:18:24.204 --> 00:18:26.807
交互的分层图像是非常棒的

00:18:26.874 --> 00:18:28.842
它们围绕着我的手指移动

00:18:29.009 --> 00:18:30.844
当我按下它 它就压入

00:18:31.745 --> 00:18:32.579
很好

00:18:33.146 --> 00:18:34.348
让我们来一些更复杂的

00:18:37.317 --> 00:18:38.585
我在此还有一个项目

00:18:39.586 --> 00:18:42.890
这个项目有CollectionViewController的子类

00:18:44.057 --> 00:18:46.260
我继续

00:18:46.326 --> 00:18:49.730
并且配置了CollectionView的尺寸参数

00:18:50.197 --> 00:18:52.699
根据tvOS的Human Interface Guidelines

00:18:52.766 --> 00:18:53.967
一个六栏位布局

00:18:54.735 --> 00:18:57.871
这些指引告诉我们
我想要一个宽度为250点的单元

00:18:58.438 --> 00:19:02.176
我知道 基于我的设计
我需要垂直450点

00:19:02.376 --> 00:19:03.677
作为单元的内容

00:19:04.344 --> 00:19:06.213
指引告诉我们
对于一个六栏位布局

00:19:06.280 --> 00:19:08.982
我们需要水平单元间48点

00:19:09.349 --> 00:19:11.585
及垂直单元间至少100点

00:19:12.085 --> 00:19:15.722
最后 为在广泛TV的安全区域内

00:19:15.789 --> 00:19:17.958
我们想在顶部和底部各保留60点离

00:19:18.025 --> 00:19:19.726
及左边和右边各保留90点

00:19:19.826 --> 00:19:21.695
这些数字在指引里都有

00:19:22.696 --> 00:19:24.398
让我们看下单元本身

00:19:25.866 --> 00:19:29.436
我已经给它一个自定义类和复用标识

00:19:30.170 --> 00:19:31.839
我们将要放大一点

00:19:32.506 --> 00:19:34.041
增加一些...

00:19:35.175 --> 00:19:36.210
自定义子视图

00:19:38.178 --> 00:19:40.280
首先我们将拖拽出
一个ImageView

00:19:45.786 --> 00:19:47.154
然后拖拽出一个标签

00:19:52.793 --> 00:19:55.796
现在我将增加一些限制条件来布局视图

00:19:55.863 --> 00:19:59.399
我想让ImageView紧靠
左右顶部边缘

00:19:59.900 --> 00:20:03.770
我们恰巧知道我们所有的图像
有相同的宽高比

00:20:03.837 --> 00:20:06.106
所以我将添加宽高比限制条件

00:20:07.875 --> 00:20:09.676
我将编辑宽高比约束条件

00:20:09.743 --> 00:20:12.179
以匹配我们的图像
所以它们的比例是2:3

00:20:14.114 --> 00:20:16.216
我将为我的标签添加一些限制条件

00:20:16.416 --> 00:20:18.819
我从标签按Control拖拽
至ImageView

00:20:18.886 --> 00:20:22.322
添加一个水平居中的约束条件

00:20:23.924 --> 00:20:27.261
我也想要我的ImageView

00:20:27.594 --> 00:20:31.265
我的标签顶部离
ImageView底部有15点

00:20:31.431 --> 00:20:33.901
我会在它们两项之间添加一个约束

00:20:36.236 --> 00:20:38.205
现在我们已经添加了这些约束

00:20:38.272 --> 00:20:39.806
我们可以执行
Command Option Equals

00:20:40.140 --> 00:20:42.109
把一切回归原位

00:20:43.243 --> 00:20:45.712
最后 这个字体有点小

00:20:45.779 --> 00:20:48.982
我把它更改成Body风格

00:20:49.316 --> 00:20:50.150
不错的选择

00:20:51.218 --> 00:20:55.689
我们已从海报上的
ImageView获得一些轮廓

00:20:55.923 --> 00:20:57.858
我们只要钩住上面的和标签

00:20:59.359 --> 00:21:02.362
现在让我们快速浏览下
CollectionViewController

00:21:02.829 --> 00:21:05.098
你可以看到我们刚在这部分执行的项数

00:21:05.165 --> 00:21:06.900
以及cellForItemAtindexPath

00:21:07.568 --> 00:21:09.069
如果我构建和运行

00:21:10.571 --> 00:21:13.540
我应该能得到我们寻找的基本布局

00:21:14.141 --> 00:21:15.976
但是我们将看看行为是怎样的

00:21:20.514 --> 00:21:22.216
这几乎是我想要的布局

00:21:22.282 --> 00:21:23.584
全是我想要的

00:21:23.650 --> 00:21:26.420
但一下子你说不出哪个项目被聚焦

00:21:26.486 --> 00:21:29.823
当我点击 你看不到我选择的单元

00:21:30.891 --> 00:21:33.627
让我们来处理这些事情

00:21:34.862 --> 00:21:40.234
现在 首先 为了看到焦点所在
我们将进入Interface Builder

00:21:40.300 --> 00:21:41.835
选择我们的ImageView

00:21:41.902 --> 00:21:44.805
检查adjustImagewhenfocused检查标记

00:21:45.873 --> 00:21:49.910
这足以让我们的单元

00:21:49.977 --> 00:21:51.645
开始回应焦点

00:21:52.513 --> 00:21:55.315
如你看到
它很大 它对我的触摸作出反应

00:21:55.382 --> 00:21:56.917
当我点击它 它推进

00:21:57.584 --> 00:21:59.653
但是标签重叠在底部

00:21:59.820 --> 00:22:03.123
他们对焦点尺寸变化没有反应

00:22:04.024 --> 00:22:05.526
为此

00:22:05.592 --> 00:22:09.263
我们将打开自定义单元类

00:22:09.329 --> 00:22:10.430
在Assistant Editor里

00:22:11.865 --> 00:22:12.699
还有...

00:22:13.534 --> 00:22:18.005
首先 我们将拖拽出一个轮廓

00:22:18.071 --> 00:22:20.707
为标签顶部和ImageView底部
之间的垂直约束

00:22:21.508 --> 00:22:22.643
我们将为它添加一个轮廓

00:22:22.709 --> 00:22:28.315
我们称它为
unfocusedConstraint

00:22:33.687 --> 00:22:35.222
然后我将添加另外一个属性

00:22:39.126 --> 00:22:41.094
为
focusedConstraint

00:22:42.029 --> 00:22:44.831
我们将在awakeFromNib里
设置focusedConstraint

00:22:48.202 --> 00:22:50.604
成为label.topAnchor

00:23:00.314 --> 00:23:06.687
与imageView的
focusedFrameGuide.bottomAnchor相关

00:23:07.788 --> 00:23:09.022
还有那15点

00:23:12.726 --> 00:23:13.560
然后在...

00:23:15.362 --> 00:23:17.231
updateConstraints

00:23:18.332 --> 00:23:20.200
我们将设置
focusedFrame

00:23:20.334 --> 00:23:22.402
我们将使focusedConstraint为活跃状态

00:23:22.870 --> 00:23:24.905
当单元获得聚焦

00:23:25.706 --> 00:23:29.209
我们将使
unfocusedConstraint为活跃状态

00:23:31.178 --> 00:23:32.579
在相反的情况下

00:23:34.515 --> 00:23:38.118
最后 在didUpdateFocus里
我们将使约束无效

00:23:38.185 --> 00:23:41.421
通过调用
setNeedsUpdateConstraints

00:23:42.956 --> 00:23:44.858
我们将添加一个协调动画

00:23:45.492 --> 00:23:48.328
通过调用
addCoordinatedAnimations

00:23:50.230 --> 00:23:51.532
在那里面

00:23:52.666 --> 00:23:54.635
我们将调用
layoutIfNeeded

00:24:02.342 --> 00:24:04.945
这应该够了
现在当我们构建和运行

00:24:08.081 --> 00:24:11.218
我们应该看到标签移动到下方

00:24:11.285 --> 00:24:13.954
离开焦点海报

00:24:14.621 --> 00:24:18.392
当我从一个移动到另一个

00:24:18.992 --> 00:24:22.396
它们全部动画离开
回到它们应该在的地方

00:24:23.363 --> 00:24:24.198
很好！

00:24:30.370 --> 00:24:33.473
记住 使用focusedFrameGuide
和coordinatedAnimations

00:24:33.540 --> 00:24:36.944
不要忘记打开
adjustsImageWhenAncestorFocused

00:24:37.010 --> 00:24:37.978
去获取这些效果

00:24:38.111 --> 00:24:39.746
关于那些 现在交还给Justin

00:24:45.485 --> 00:24:46.920
谢谢那很棒的演示 Randy

00:24:46.987 --> 00:24:48.455
你可以看到它是多么的容易

00:24:48.522 --> 00:24:50.991
去真正利用独特的用户接口元素

00:24:51.058 --> 00:24:52.793
真正让你的tvOS应用变得生动

00:24:54.261 --> 00:24:55.329
让我们说些别的

00:24:55.395 --> 00:24:56.763
讨论一下滚动条

00:24:57.197 --> 00:25:00.767
tvOS上滚动条与iOS上有些不同

00:25:00.868 --> 00:25:02.870
它必须间接触摸

00:25:03.203 --> 00:25:05.906
当用户在iOS上
ScrollView里滚动

00:25:05.973 --> 00:25:07.441
它们用肢体触摸ScrollView

00:25:07.508 --> 00:25:08.675
当他们移动手指

00:25:08.742 --> 00:25:10.210
ScrollView偏移将会调整

00:25:10.277 --> 00:25:11.879
去匹配他们手指的运动

00:25:12.379 --> 00:25:14.882
但在tvOS上并非如此

00:25:14.948 --> 00:25:16.850
在tvOS上
你并不是在触摸屏幕

00:25:17.184 --> 00:25:19.920
也不是直接操控滚动视图

00:25:19.987 --> 00:25:22.456
你真正做的是改变焦点项目

00:25:22.656 --> 00:25:25.826
当焦点项目改变
焦点引擎会检测到它

00:25:25.893 --> 00:25:28.762
它会自动滚动到
它需要的任何滚动视图

00:25:28.829 --> 00:25:31.298
确保焦点视图总是在屏幕上

00:25:34.034 --> 00:25:36.670
焦点引擎会选择它能够调整的最佳偏移

00:25:36.737 --> 00:25:38.805
基于视图的尺寸和滚动视图的尺寸

00:25:38.972 --> 00:25:40.807
但也有时候你想控制

00:25:40.874 --> 00:25:42.609
它将发送给你什么样的偏移

00:25:42.843 --> 00:25:45.579
例如 一个人们常用的自定义

00:25:45.646 --> 00:25:47.915
是他们想要焦点视图始终居中

00:25:47.981 --> 00:25:49.383
在ScrollView的边界内

00:25:49.449 --> 00:25:50.317
你可以那样做

00:25:50.484 --> 00:25:53.086
你可以那样做的方法是
使用UIScrollViewDelegate方法

00:25:53.287 --> 00:25:54.521
你有可能从iOS中识别

00:25:54.588 --> 00:25:59.026
那是scrollViewWillEndDragging:
withVelocity:targetContentOffset

00:25:59.493 --> 00:26:01.862
那里最终的参数
targetContentOffset

00:26:01.929 --> 00:26:03.797
是一个指针指向CGPoint

00:26:04.531 --> 00:26:06.934
那个指针代表偏移

00:26:07.000 --> 00:26:10.304
焦点引擎将滚动到的地方
如果你什么也不做

00:26:10.370 --> 00:26:12.639
那个是偏移
它会自动为你展示

00:26:12.940 --> 00:26:14.908
但是如果你愿意自己计算

00:26:14.975 --> 00:26:17.177
滚动偏移是多少

00:26:17.277 --> 00:26:18.178
你也可以那样做

00:26:18.245 --> 00:26:20.314
计算你想要的偏移

00:26:20.380 --> 00:26:22.616
把它的值存在指针中

00:26:22.916 --> 00:26:24.218
让指针指向你

00:26:24.284 --> 00:26:26.119
焦点引擎将滚到那里

00:26:26.320 --> 00:26:28.288
伴随着它
你会得到很多很棒的系统动画

00:26:28.355 --> 00:26:29.623
对于你所选择的偏移

00:26:31.725 --> 00:26:33.727
但是并不是说直接操控总是不好的

00:26:33.794 --> 00:26:35.729
或者在tvOS上从来不是个好主意

00:26:36.029 --> 00:26:38.031
有些情况下 你想这样做

00:26:38.098 --> 00:26:40.601
所以 一些情况下需要

00:26:40.667 --> 00:26:42.769
比如你有许多全屏内容

00:26:42.836 --> 00:26:44.438
可能是一个全屏相片集

00:26:44.605 --> 00:26:46.740
那里照片可以完全覆盖到屏幕边缘

00:26:47.074 --> 00:26:49.543
一个UIKit的例子
是UIPageViewController

00:26:49.810 --> 00:26:52.446
当你有一个UIPageViewController
它并不做焦点滚动

00:26:52.513 --> 00:26:54.114
取而代之 你直接操控

00:26:54.181 --> 00:26:56.450
PageViewController
的ScrollView内容

00:26:56.950 --> 00:26:58.919
还有其他情况下 你有很多滚动文本

00:26:58.986 --> 00:27:01.321
这是你想直接操控的另外一处

00:27:01.455 --> 00:27:04.758
基本上 不清楚焦点项目是什么时

00:27:05.025 --> 00:27:08.328
你不能够看到下一个焦点项目是什么

00:27:08.662 --> 00:27:10.531
这些都是非常适合直接操控的情况

00:27:11.265 --> 00:27:12.132
如果你想要那样做

00:27:12.199 --> 00:27:14.201
你没必要去写你自己的
手势处理代码

00:27:14.268 --> 00:27:17.104
你可以复用早已存在
于ScrollView的拖动手势

00:27:17.604 --> 00:27:20.040
这个技巧是
滚动视图是被配置成

00:27:20.107 --> 00:27:22.809
直接触摸的唯一监听

00:27:23.277 --> 00:27:25.946
Siri Remote
正生成间接触摸

00:27:26.280 --> 00:27:27.881
你只需获得这个拖动手势识别器

00:27:27.948 --> 00:27:30.017
确认它监听间接触摸

00:27:31.318 --> 00:27:33.754
我们也有定向按下手势识别器

00:27:33.820 --> 00:27:35.422
只有tvOS的
ScrollView上才有

00:27:35.489 --> 00:27:37.791
它是监听这些箭头按钮按下事件

00:27:37.858 --> 00:27:40.227
用户不使用设备的情况下

00:27:40.294 --> 00:27:42.896
可以触摸输入
也可以滚动ScrollView

00:27:43.063 --> 00:27:44.798
这个手势默认是禁用的

00:27:44.865 --> 00:27:47.334
因为我们更倾向于
让这些箭头按下操控焦点

00:27:47.401 --> 00:27:48.769
而非操控ScrollView偏移

00:27:48.836 --> 00:27:50.037
你需要启用它

00:27:50.504 --> 00:27:53.207
你可以使用这段代码去做这两个事情

00:27:53.273 --> 00:27:56.176
我们从ScrollView中得到
panGestureRecognizer

00:27:56.243 --> 00:27:59.046
我们告诉它我们想监听间接触摸事件

00:27:59.580 --> 00:28:01.481
我们得到
directionalPressGestureRecognizer

00:28:01.548 --> 00:28:02.850
告诉它应该是打开的

00:28:03.283 --> 00:28:06.887
如果你这样做 所有进入
ScrollView的这些事件

00:28:06.954 --> 00:28:09.523
会直接操控ScrollView偏移

00:28:10.724 --> 00:28:13.861
其实 合并直接操控技术

00:28:13.927 --> 00:28:15.562
和焦点交互技术是可能的

00:28:15.629 --> 00:28:16.663
为了展示如何去做

00:28:16.730 --> 00:28:18.866
我想邀请Kevin上台演示

00:28:18.932 --> 00:28:19.766
Kevin

00:28:22.169 --> 00:28:23.036
谢谢 Justin

00:28:24.771 --> 00:28:27.841
嗨 我是Kevin Hiscott
我是tvOS工程师

00:28:28.308 --> 00:28:30.544
我们将看一个关于视图控制器的例子

00:28:30.878 --> 00:28:33.914
在文本视图中展现条款和条件文本

00:28:34.815 --> 00:28:36.984
TextView是
ScrollView的子类

00:28:37.050 --> 00:28:40.754
我们可以看到怎么样向它添加直接操控

00:28:44.458 --> 00:28:47.194
我们去看下我的ZIB
看看我目前为止设置了什么

00:28:47.728 --> 00:28:51.398
我有个文本视图带有冗长的
Lorem Ipsum粘贴在里面

00:28:52.599 --> 00:28:55.102
如果我们进入应用程序

00:28:55.169 --> 00:28:57.538
我们可在应用的上下文中看到它的样子

00:28:59.206 --> 00:29:00.707
展现ViewController时

00:29:00.774 --> 00:29:03.944
我们可以沿着底部的边缘文本
看到其实文本已被裁剪

00:29:04.344 --> 00:29:07.848
若我努力擦碰Siri Remote
文本不会滚动

00:29:08.415 --> 00:29:09.850
让我们来改进它

00:29:11.718 --> 00:29:13.253
让我们进入
ViewController

00:29:13.320 --> 00:29:17.424
在viewDidLoad里抓取
我为UITextView创建的轮廓

00:29:17.958 --> 00:29:19.893
我称它为
messageTextView

00:29:20.827 --> 00:29:24.498
在messageTextView和任何ScrollView上
有一个panGestureRecognizer

00:29:24.698 --> 00:29:26.633
我们将改变它允许的触摸类型

00:29:26.700 --> 00:29:28.569
包括间接触摸的类型

00:29:29.203 --> 00:29:30.270
如Justin所说

00:29:30.337 --> 00:29:32.506
这些触摸
由Siri Remote创建

00:29:34.074 --> 00:29:37.010
我们还将把isSelectable
的值设置为真

00:29:37.511 --> 00:29:40.948
这将允许文本视图获得聚焦

00:29:41.014 --> 00:29:42.249
和接收这些事件

00:29:42.482 --> 00:29:44.351
让我们构建和运行看看它们怎样运作

00:29:52.259 --> 00:29:53.961
呈现ViewController时

00:29:54.528 --> 00:29:56.597
其实我能够直接擦碰

00:29:56.663 --> 00:29:58.966
通过Siri Remote
使文本上下滚动

00:29:59.399 --> 00:30:01.001
很好 直接操控

00:30:01.935 --> 00:30:05.105
另一个ViewController
所需的好条款和条件

00:30:05.472 --> 00:30:09.376
是让用户接受或拒绝你条件的方法

00:30:10.043 --> 00:30:12.079
为此 让我们看看我的ZIB

00:30:13.380 --> 00:30:14.748
拖入几个按钮

00:30:16.617 --> 00:30:18.485
我将一个标识为不同意

00:30:20.821 --> 00:30:21.955
另一个标识为同意

00:30:23.924 --> 00:30:25.726
让我们构建和运行看看将发生什么

00:30:25.859 --> 00:30:28.529
我期待发生的是我们的焦点

00:30:28.595 --> 00:30:31.431
伴随着水平擦碰而作水平移动

00:30:31.498 --> 00:30:34.101
对于垂直擦碰却始终滚动文本视图

00:30:34.935 --> 00:30:37.004
但当我呈现
ViewController

00:30:37.204 --> 00:30:41.475
我可以看到那些垂直擦碰确有移动文本

00:30:41.542 --> 00:30:43.243
但是 如果我擦碰得太低

00:30:43.310 --> 00:30:45.312
焦点实际移动到按钮上

00:30:45.579 --> 00:30:47.181
我就不能滚动文本了

00:30:47.247 --> 00:30:49.316
直到焦点回到文本视图

00:30:50.083 --> 00:30:52.553
这并非我想要的行为

00:30:53.987 --> 00:30:55.889
让我们回到
我的ViewController

00:30:55.956 --> 00:30:57.858
我们将禁用isSelectable

00:30:58.225 --> 00:31:02.696
我们实际上不是想让TextView
成为一个可获聚焦的屏幕元素

00:31:03.463 --> 00:31:05.265
取而代之 我将展示一个小技巧

00:31:06.066 --> 00:31:08.135
我们将抓取panGestureRecognizer

00:31:08.202 --> 00:31:11.972
实际上把它添加到我们的
ViewController视图

00:31:12.573 --> 00:31:14.575
这将允许消息TextView

00:31:14.641 --> 00:31:17.244
本身不获聚焦的情况下 接收事件

00:31:18.412 --> 00:31:20.314
让我们构建和运行看看它的表现

00:31:25.752 --> 00:31:27.521
呈现ViewController时

00:31:28.789 --> 00:31:31.992
我们可以看到不同意按钮立刻获得聚焦

00:31:32.259 --> 00:31:34.828
这是因为文本视图已经不可获聚焦了

00:31:35.295 --> 00:31:38.198
我可左右擦碰Siri Remote
去移动焦点

00:31:38.265 --> 00:31:41.602
但任何时候
我可以上下擦碰去移动文本

00:31:42.269 --> 00:31:44.004
很好 这样看起来不错

00:31:44.638 --> 00:31:47.274
在tvOS上 我们最后一个要考虑的

00:31:47.541 --> 00:31:51.078
是由其他输入方法产生的
定向按下类型事件

00:31:51.144 --> 00:31:54.448
像游戏控制器
键盘 或者IR遥控器

00:31:55.148 --> 00:31:57.718
我们让tvOS很容易支持这些

00:31:57.918 --> 00:31:59.620
让我们回头看看我的视图控制器

00:32:00.087 --> 00:32:03.090
我们将抓取directionalPressGestureRecognizer

00:32:03.156 --> 00:32:05.692
从我们的messageTextView中
并且启用它

00:32:05.759 --> 00:32:09.062
伴随着这些类型而允许滚动发生

00:32:09.129 --> 00:32:10.664
由其他设备生成

00:32:11.899 --> 00:32:13.567
我们将要做的最后一件事是

00:32:13.634 --> 00:32:15.969
把GestureRecognizer移动到
我们自己的视图中

00:32:16.036 --> 00:32:17.137
如我们之前做的

00:32:19.673 --> 00:32:22.109
让我们构建和运行看看
整体运行情况

00:32:25.612 --> 00:32:27.514
现在当我呈现
条款和条件的时候

00:32:27.714 --> 00:32:30.617
我能够左右擦碰去移动焦点

00:32:30.717 --> 00:32:34.221
我也能够左右拍击去移动焦点

00:32:34.555 --> 00:32:37.925
通过定向按下类型事件
由Siri Remote

00:32:37.991 --> 00:32:39.193
和其他设备生成

00:32:39.760 --> 00:32:43.664
我可以上下擦碰去改变内容偏移

00:32:43.730 --> 00:32:46.633
但是我也可以上下拍击去增量滚动

00:32:47.367 --> 00:32:50.904
很好！这是一个全功能条款和条件的
ViewController

00:32:50.971 --> 00:32:51.805
在tvOS中

00:32:52.406 --> 00:32:53.440
谢谢你们

00:32:53.507 --> 00:32:56.476
我已迫不及待接受你们应用里的
所有条款和条件

00:32:56.743 --> 00:32:57.711
交还给Justin

00:32:59.947 --> 00:33:02.349
让我们来继续最后一个话题 文本输入

00:33:03.383 --> 00:33:05.752
我们在tvOS上有很棒的系统键盘

00:33:06.186 --> 00:33:08.655
有很多特性只可用在

00:33:08.722 --> 00:33:10.324
系统键盘上

00:33:10.390 --> 00:33:12.125
我想和你们介绍一下几个特性

00:33:12.526 --> 00:33:14.094
其中一个功能是听写

00:33:14.228 --> 00:33:16.563
用户可对Siri Remote说话

00:33:16.630 --> 00:33:18.465
文字会显示在屏幕上

00:33:19.233 --> 00:33:20.467
我们还支持Bluetooth键盘

00:33:20.534 --> 00:33:23.070
若将其和Bluetooth键盘配对
你就可以直接在那里打字

00:33:24.071 --> 00:33:25.472
我们有新的Apple
TV Remote应用

00:33:25.539 --> 00:33:27.774
因此用户可以把电话与TV配对

00:33:27.841 --> 00:33:29.610
他们可以在电话键盘上打字

00:33:29.743 --> 00:33:30.944
发送文字到TV

00:33:32.012 --> 00:33:33.747
这里还有很多本地化的细节

00:33:33.814 --> 00:33:35.682
系统键盘会为你处理好

00:33:36.750 --> 00:33:38.552
它能够自动改变自己的布局

00:33:38.619 --> 00:33:40.521
根据用户正使用的输入设备

00:33:40.888 --> 00:33:43.557
这里有一个你可能最熟悉的线性布局

00:33:43.624 --> 00:33:45.292
但还有我们将会用到的网格布局

00:33:45.359 --> 00:33:47.327
如果没和TV配对的
Siri Remote

00:33:48.262 --> 00:33:49.196
有很多很棒的功能

00:33:49.263 --> 00:33:51.098
它们只有在系统键盘里是可用的

00:33:51.164 --> 00:33:53.033
如果你使用的不是系统键盘

00:33:53.100 --> 00:33:55.802
用户将不能够使用这些功能

00:33:56.103 --> 00:33:59.072
我们不鼓励你推出自己的键盘

00:33:59.139 --> 00:34:00.374
坚持用系统键盘

00:34:00.440 --> 00:34:02.342
用户可以使用所有这些功能

00:34:02.409 --> 00:34:03.944
它们全部只对系统可用

00:34:05.212 --> 00:34:06.547
这里有些方法你可以自定义

00:34:06.613 --> 00:34:07.981
内置的系统键盘

00:34:08.248 --> 00:34:10.817
其中一个方法是添加
一个你自己的视图

00:34:10.884 --> 00:34:13.053
到键盘上
会呈现在它旁边

00:34:13.187 --> 00:34:15.589
你可使用UIResponder上的
一些API

00:34:15.656 --> 00:34:17.257
那些你有可能从iOS中识别

00:34:17.456 --> 00:34:18.992
这里有inputAccessoryView

00:34:19.126 --> 00:34:21.027
和inputAccessoryViewController

00:34:21.161 --> 00:34:23.230
如果你在文本框上指派这些属性

00:34:23.330 --> 00:34:24.998
你想去编辑文本的文本框

00:34:25.264 --> 00:34:26.699
当键盘出现

00:34:26.766 --> 00:34:29.101
在键盘的旁边展现你自己的视图

00:34:29.168 --> 00:34:31.471
一秒后 我将展现刚才那一幕的截屏

00:34:32.706 --> 00:34:34.574
最后 我想指出行为的一个变化

00:34:34.641 --> 00:34:37.010
出现在tvOS 9
和tvOS 10间

00:34:37.444 --> 00:34:40.313
UITextField有一个属性叫
keyboardAppearance

00:34:40.414 --> 00:34:42.449
你可以设置它为不指定亮和暗

00:34:42.850 --> 00:34:45.619
在tvOS 9上 如果你设置它
比如 暗

00:34:45.918 --> 00:34:48.856
然后键盘呈现时 不仅自身变暗

00:34:48.922 --> 00:34:52.092
屏幕上的文本框同样会变暗

00:34:52.559 --> 00:34:55.161
现在tvOS 10里
我们有新外观API

00:34:55.228 --> 00:34:57.664
所以整个系统能够对应的变亮或变暗

00:34:57.865 --> 00:35:00.000
现在我们在tvOS 10上做的

00:35:00.067 --> 00:35:03.337
是这个键盘外观属性只影响键盘

00:35:03.403 --> 00:35:05.005
和文本框外观

00:35:05.072 --> 00:35:08.175
它将被更大的
UPI Tray Collection所制定

00:35:09.576 --> 00:35:11.078
这是我答应展示给你们的屏幕截图

00:35:11.144 --> 00:35:13.914
这种情况下
我已经创建了一个常规文本框

00:35:13.981 --> 00:35:15.516
我给它一个inputAccessoryView

00:35:15.582 --> 00:35:17.885
我放了一个红色边控在上面 所以
你可以看到它在哪里

00:35:18.151 --> 00:35:19.853
这些UI标签全部都是定制的

00:35:19.920 --> 00:35:23.257
我只是把它们放在那里
所以你可以添加任何种类的附件视图

00:35:23.323 --> 00:35:24.992
那些你想让它们出现在键盘上方的

00:35:27.327 --> 00:35:29.096
另一个你可在键盘上获得UI方法

00:35:29.162 --> 00:35:31.598
同时当键盘正使用
SearchController

00:35:31.865 --> 00:35:33.934
你使用一些从iOS中能识别的API

00:35:34.001 --> 00:35:35.769
这就是UISearchController

00:35:37.471 --> 00:35:40.207
我们有键盘并且搜索结果呈现在其下方

00:35:41.208 --> 00:35:42.809
这也是自动适配的

00:35:42.876 --> 00:35:44.778
这里有基于网格和基于线性的布局

00:35:44.845 --> 00:35:46.847
取决于用户正在使用的输入设备

00:35:47.314 --> 00:35:49.383
你可以把它嵌入到其他视图类型的内部

00:35:49.516 --> 00:35:51.418
SearchController
通常要模态展现

00:35:51.485 --> 00:35:52.553
并接管整个屏幕

00:35:52.920 --> 00:35:56.190
但你可把它嵌入到另一个视图控制器中

00:35:56.256 --> 00:35:57.858
通过使用UISearchContainerViewController

00:35:57.925 --> 00:36:00.227
我将在几页幻灯片里展现一段样本代码

00:36:01.995 --> 00:36:04.131
你提供了为搜索结果定制的视图控制器

00:36:04.198 --> 00:36:06.466
搜索结果的视觉外观

00:36:06.533 --> 00:36:07.968
和交互完全取决于你

00:36:08.035 --> 00:36:09.069
你可以做任何你想做的

00:36:09.136 --> 00:36:11.405
你可能使用一个视图集合
或可能使用一个分开视图

00:36:11.471 --> 00:36:13.073
它有一个表视图和集合视图

00:36:13.207 --> 00:36:14.041
其他你想要的

00:36:14.107 --> 00:36:15.642
取决于你来定制视图控制器

00:36:17.945 --> 00:36:21.048
很快地展示一下如何在其他东西内部
嵌入一个搜索控制器

00:36:21.114 --> 00:36:22.950
比如 一个标签栏控制器

00:36:23.016 --> 00:36:25.552
我获取到我的定制类
ViewController

00:36:25.986 --> 00:36:29.056
在viewDidAppear里
我将创建一个searchController

00:36:29.156 --> 00:36:30.257
我想确保不做第二回

00:36:30.324 --> 00:36:32.025
所以我检查确保
我之前没有做过

00:36:33.694 --> 00:36:35.195
然后我创建了UISearchController

00:36:35.262 --> 00:36:37.664
告诉它我的结果使用何种视图控制器

00:36:37.731 --> 00:36:39.800
当搜索查询变更时 与谁联系

00:36:41.034 --> 00:36:42.269
然后我要去包裹那些

00:36:42.336 --> 00:36:44.104
UISearchContainerViewController内部的东西

00:36:44.171 --> 00:36:46.240
现允许我拿这个container

00:36:46.306 --> 00:36:48.742
我可以在其上面做常规的
ViewController containment

00:36:49.076 --> 00:36:51.011
我将它作为一个ChildViewController添加

00:36:51.445 --> 00:36:52.412
如果你想这样做

00:36:52.479 --> 00:36:55.649
你将会很容易在标签栏内部
使用搜索控制器

00:36:55.716 --> 00:36:57.518
如在tvOS上的一些系统应用程序

00:36:59.820 --> 00:37:01.188
这就是文本输入

00:37:01.688 --> 00:37:02.523
总的来说

00:37:02.589 --> 00:37:04.591
我们希望你们能从本次演讲中
得到的东西之一

00:37:04.791 --> 00:37:08.195
首先是当你正处理菜单按钮 小心

00:37:08.295 --> 00:37:11.465
记住你不想去干扰系统手势

00:37:12.933 --> 00:37:13.934
当你正使用分层图像时

00:37:14.001 --> 00:37:16.603
利用我们提供给你的布局指引

00:37:16.670 --> 00:37:18.238
和协调动画API

00:37:18.305 --> 00:37:20.307
确保你的视图能够移动

00:37:20.374 --> 00:37:22.142
与系统动画协同运作

00:37:23.877 --> 00:37:25.679
若你想在ScrollViews上
直接操控

00:37:25.746 --> 00:37:27.581
你无需自己做任何处理代码的事情

00:37:27.648 --> 00:37:30.150
只要复用已经内置的拖动手势

00:37:31.585 --> 00:37:33.320
最后 使用系统键盘去确保

00:37:33.387 --> 00:37:34.621
你的用户能获得使用

00:37:34.688 --> 00:37:37.024
所有的功能 当他们输入文本的时候

00:37:37.758 --> 00:37:39.993
想获取本次演讲更多的信息
你可以访问这个URL

00:37:40.060 --> 00:37:41.762
这里你会找到文档的链接

00:37:42.029 --> 00:37:44.665
本周接下来还会有其他演讲

00:37:44.731 --> 00:37:46.099
我想特别推荐两个

00:37:46.166 --> 00:37:48.235
都是关于tvOS上的UIKit

00:37:48.569 --> 00:37:50.204
希望大家在余下的会议中过得愉快 谢谢