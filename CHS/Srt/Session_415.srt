00:00:19.987 --> 00:00:23.590
在服务器端使用开源Swift

00:00:28.795 --> 00:00:32.499
欢迎大家 我是Philippe Hausler
我在Apple Foundation工作

00:00:32.566 --> 00:00:35.602
今天我们将谈论服务器上的Swift

00:00:36.003 --> 00:00:38.572
我们看看为什么服务器端的Swift
是引人注目的

00:00:38.639 --> 00:00:42.476
各个部分是怎么一起工作的
有哪些是可以开箱即用的

00:00:42.743 --> 00:00:46.780
哪些不是 一些现实世界中的
Swift运行在服务器上的例子

00:00:46.847 --> 00:00:48.749
最关键的

00:00:48.815 --> 00:00:51.818
你可以怎么贡献来使服务器端的
Swift更好

00:00:53.520 --> 00:00:57.124
现代应用开发不仅仅是为一个
平台开发

00:00:57.591 --> 00:00:58.825
它是一个生态系统

00:00:59.126 --> 00:01:01.361
你很难找到一个应用

00:01:01.428 --> 00:01:03.830
没有任何服务器端的部分

00:01:04.230 --> 00:01:06.767
来自分析 实时通讯

00:01:07.067 --> 00:01:09.203
或者云上储存的共享的状态

00:01:09.269 --> 00:01:12.906
服务器是构建一个丰富并吸引人
的应用必须的一部分

00:01:14.041 --> 00:01:16.276
现在构建下一个伟大的事

00:01:16.343 --> 00:01:19.313
通常有接触开关需要制造

00:01:20.647 --> 00:01:23.884
你最后嗡嗡地响
写你的应用

00:01:24.251 --> 00:01:27.321
然后你知道你要写的下一个东西
是用不同的语言

00:01:27.387 --> 00:01:30.490
这会造成停机时间和重复实现

00:01:30.557 --> 00:01:34.361
我们都知道我们有多不喜欢重复
代码

00:01:35.362 --> 00:01:37.564
但是运行在服务器上的Swift
有潜力

00:01:37.631 --> 00:01:40.801
不仅仅提供无缝开发体验

00:01:40.868 --> 00:01:44.137
还提供更丰富更吸引人的用户体验

00:01:44.338 --> 00:01:46.406
通过分享你的代码库合适的部分

00:01:46.740 --> 00:01:50.878
可以节省开发以及测试的时间

00:01:51.745 --> 00:01:53.146
但这不仅是语言

00:01:53.413 --> 00:01:54.781
这是API

00:01:55.115 --> 00:01:58.585
通常难以剥离API的架构

00:01:58.652 --> 00:02:01.121
从语言的构造中剥离

00:02:01.188 --> 00:02:04.424
比如字符串 数组 字典 并发

00:02:04.858 --> 00:02:08.794
它们通常成为表达那个语言的库的
核心部分

00:02:09.128 --> 00:02:11.999
有了这些 让我们来到Swift的
架构

00:02:12.065 --> 00:02:16.403
不仅仅是在服务器上
还包括Swift怎么适用于其他平台

00:02:17.838 --> 00:02:19.773
在早期的设计考虑中

00:02:20.174 --> 00:02:23.610
Swift不是只能运行
在Darwin系统上的语言

00:02:23.677 --> 00:02:27.514
它本质上可以运行在多种平台上

00:02:27.581 --> 00:02:31.351
有了社区的帮助 这个目标开始
成为现实

00:02:31.418 --> 00:02:36.456
对平台 平台支持比如FreeBSD
目标比如Raspberry Pi

00:02:36.523 --> 00:02:38.892
甚至Windows和Android

00:02:38.959 --> 00:02:41.128
一些很令人兴奋的事

00:02:42.095 --> 00:02:45.566
在所有这些平台
Swift依赖系统库

00:02:45.632 --> 00:02:48.468
构建在其上的
你有标准库

00:02:48.535 --> 00:02:53.507
它提供一些根本性的基本构建块
和数据结构

00:02:55.342 --> 00:02:58.412
在Darwin上我们有被称为覆盖的
附件

00:02:58.478 --> 00:03:01.448
这帮助系统框架更好的通过接口
连接Swift

00:03:01.915 --> 00:03:06.253
但因为Linux中
没有Foundation或Dispatch

00:03:06.320 --> 00:03:10.324
一个可移植的接口被创建做为
那些基本的部分

00:03:10.858 --> 00:03:13.794
我们从一个那里应该有什么的大纲
开始

00:03:13.861 --> 00:03:16.163
和一些初步的实现

00:03:16.230 --> 00:03:19.800
和社区一起 我们添加了很多
基本功能

00:03:19.867 --> 00:03:22.102
任何现代的开发工作都会需要的

00:03:23.203 --> 00:03:25.339
当你的应用进行混合时

00:03:25.405 --> 00:03:30.277
你可以看到这些部分在一起工作
用在两个平台上相同的方式

00:03:30.677 --> 00:03:32.779
有了以这种方式创造的Swift

00:03:32.846 --> 00:03:36.984
作为开发者你可以从你的应用中
选出合适的部分

00:03:37.050 --> 00:03:41.321
来为服务器开发
使用你一直在用的熟悉的概念

00:03:42.689 --> 00:03:47.661
Swift.org是获得
最新版本的Swift的中心地带

00:03:47.728 --> 00:03:51.265
注册邮件列表
得到GitHub仓库的链接

00:03:51.331 --> 00:03:53.233
或者持续集成构建

00:03:53.734 --> 00:03:58.038
或者一个阅读资料支持的好地方
关于Swift的最新开发进展

00:03:58.105 --> 00:04:00.674
这是一个针对Swift工具链的地方

00:04:01.542 --> 00:04:04.278
工具箱里都有什么？

00:04:05.245 --> 00:04:09.283
工具箱提供在Linux和
Mac上构建的支持

00:04:09.783 --> 00:04:13.487
你可以在Mac上开发
然后部署到Linux服务器

00:04:13.554 --> 00:04:16.356
有持续集成服务器来确保

00:04:16.423 --> 00:04:20.394
对语言和API的改变

00:04:20.494 --> 00:04:26.133
发生并持续集成
这样所有东西都像预期的一样运行

00:04:27.134 --> 00:04:28.602
你有标准库

00:04:28.669 --> 00:04:33.173
给你基本的构建块 协议 结构 类型

00:04:33.240 --> 00:04:36.043
你在构建任何Swift应用时都需要
用到的

00:04:36.844 --> 00:04:40.080
还获得Foundation、
Dispatch、XCTest

00:04:40.147 --> 00:04:43.016
作为Swift工具链中的项目

00:04:43.517 --> 00:04:46.286
这给你可移植API的横截面

00:04:46.353 --> 00:04:51.058
这使你为不同平台开发时
能保持代码几乎是一样的

00:04:51.959 --> 00:04:53.427
但是你得到一系列工具

00:04:53.493 --> 00:04:56.864
用来编译 打包
和调试Swift应用

00:04:56.930 --> 00:05:01.301
以及Swift仓库来完成
尝试那些新特性

00:05:01.368 --> 00:05:05.072
你在两个平台上都可以得到所有这些

00:05:06.840 --> 00:05:09.910
现在有一些东西没有被包括

00:05:10.644 --> 00:05:12.679
我们做了一个设计决定

00:05:12.746 --> 00:05:17.251
有些东西对跨平台没意义

00:05:17.317 --> 00:05:21.822
或者让开发者开发自己的方案更好

00:05:21.889 --> 00:05:23.590
因为他们是高度特殊化的

00:05:24.591 --> 00:05:26.960
新平台不仅仅是代码

00:05:27.494 --> 00:05:31.899
它们是持续集成和验证
而且移植到新平台的冠军

00:05:31.965 --> 00:05:36.570
通常最了解实现那些

00:05:37.404 --> 00:05:38.372
你的代码来到这里
开发者机会

00:05:38.438 --> 00:05:42.042
用户界面是一个非常特定于平台
的东西

00:05:42.576 --> 00:05:44.378
在iOS上你有UIKit

00:05:44.845 --> 00:05:51.018
在Mac上你有AppKit
虽然它们有很多相似之处

00:05:51.218 --> 00:05:53.487
他们是两个不同的东西

00:05:53.554 --> 00:05:55.722
因为他们解决不同的问题

00:05:56.356 --> 00:06:00.060
关于这点
UI可以是网络模板

00:06:00.127 --> 00:06:04.431
有时用户界面中的用户不一定是人

00:06:04.498 --> 00:06:09.002
有可能是另一个服务连接在发送
服务协议

00:06:09.503 --> 00:06:12.940
这很明显是一些相当专门化的东西

00:06:13.774 --> 00:06:16.076
现在把你的应用部署到服务器中

00:06:16.143 --> 00:06:18.111
这是一个专门化的任务

00:06:18.545 --> 00:06:21.548
这样你可以选择合适的服务

00:06:21.615 --> 00:06:27.788
适合你的要求 预算 规模 当然还有
你的应用的服务

00:06:28.522 --> 00:06:31.558
这不应绑定到特定的Swift轨道上

00:06:31.859 --> 00:06:34.361
在服务器上运行
你可以有多个应用

00:06:34.428 --> 00:06:36.597
运行在多个Swift版本上

00:06:37.764 --> 00:06:42.603
很高兴看到热爱者创建一个开放
和分享的社区

00:06:42.669 --> 00:06:46.139
有一些很好的机会

00:06:46.206 --> 00:06:47.875
来丰富Swift生态环境

00:06:48.342 --> 00:06:55.082
总有很多努力被投入到了这个领域

00:06:55.148 --> 00:06:57.484
我们在IBM的合作贡献者做出了

00:06:57.551 --> 00:06:59.786
一些相当优雅的东西

00:07:00.354 --> 00:07:02.723
我们会看一些抽象的概述

00:07:02.789 --> 00:07:04.725
让我们深入一些

00:07:04.791 --> 00:07:07.361
现在看一些现实世界的例子

00:07:07.427 --> 00:07:12.633
关于他们在IBM是怎么参与到Swift中的
John Ponzo和Patrick Bohrer

00:07:20.774 --> 00:07:21.775
谢谢Philippe

00:07:22.009 --> 00:07:23.510
嘿 我是John Ponzo

00:07:23.577 --> 00:07:26.780
我是IBM移动云开发的技术领导

00:07:26.847 --> 00:07:30.817
我很激动今天能做为WWDC的一部分

00:07:30.884 --> 00:07:34.054
我们在IBM
对Swift社区感到兴奋

00:07:34.121 --> 00:07:37.658
做为开源的一部分
我们看到了这个语言的极大潜力

00:07:39.359 --> 00:07:42.196
对不熟悉的人 让我稍微介绍一下
关于IBM的一些事

00:07:42.262 --> 00:07:43.830
及我们怎么参与到Swift中

00:07:44.364 --> 00:07:46.900
2014年Apple和IBM宣布了
我们的合作 聚焦在

00:07:46.967 --> 00:07:50.370
企业应用和解决方案

00:07:51.038 --> 00:07:55.242
接下来IBM成为Swift的
早期使用者之一

00:07:55.309 --> 00:07:58.879
当它两年前在WWDC上被宣布时

00:07:59.479 --> 00:08:03.851
从那以后我们开发了超过100个
企业应用

00:08:04.685 --> 00:08:08.021
完全用Swift开发那些应用和解决
方案

00:08:08.522 --> 00:08:11.892
而且我们有最高的集中程度之一

00:08:11.959 --> 00:08:15.229
在IBM开发这些应用的Swift
开发者的集中程度

00:08:16.230 --> 00:08:19.499
我们开发这些企业应用和解决方案
的经验

00:08:19.566 --> 00:08:25.005
持续地指出后台允许一个优秀
的体验的重要性

00:08:26.106 --> 00:08:29.176
做为开发者我们知道它有多重要

00:08:29.476 --> 00:08:33.614
有一个后台 带来优秀的
移动体验

00:08:34.914 --> 00:08:37.918
我们还知道一个重要的事是我们
快速安全地

00:08:37.985 --> 00:08:40.587
部署适合的代码到适合的地方

00:08:41.188 --> 00:08:44.491
这就是为什么我们对帮助把Swift
带到服务器来如此兴奋

00:08:46.894 --> 00:08:50.664
我们感谢Swift.org
社区的资源和活动

00:08:50.731 --> 00:08:52.666
从邮件列表

00:08:52.733 --> 00:08:56.370
到代码贡献和新形成的开源项目

00:08:57.337 --> 00:09:00.407
我想强调我们在IBM做的一些事情

00:09:00.474 --> 00:09:03.477
来帮助开源社区
把Swift带到服务器

00:09:04.645 --> 00:09:07.080
首先我会告诉你社区实现

00:09:07.181 --> 00:09:11.618
然后告诉你Swift沙盒
和Swift程序包目录服务

00:09:11.685 --> 00:09:13.854
我们开发了这些来帮助开发者

00:09:13.921 --> 00:09:18.292
更容易学习、发现、
分享Swift资源

00:09:19.793 --> 00:09:23.664
接下来我们受到一致的开发者体验
的激励

00:09:24.031 --> 00:09:25.933
连接客户和服务器的体验

00:09:25.999 --> 00:09:29.369
最后我们开发了Kitura网络框架

00:09:29.436 --> 00:09:32.906
用来帮助促进和优先我们的贡献

00:09:32.973 --> 00:09:36.476
进入libdispatch和
foundation的核心库中

00:09:38.512 --> 00:09:43.283
接下来云实现是开发过程中的
重要部分

00:09:43.350 --> 00:09:48.655
我们受到了使把Swift部署到云上
更容易更有趣的动力

00:09:48.722 --> 00:09:52.426
通过IBM Cloud
对Swift运行时的早期支持

00:09:52.492 --> 00:09:56.830
和Xcode附加应用

00:09:56.897 --> 00:09:59.366
来帮助部署代码到云上
社区实现

00:10:01.835 --> 00:10:04.171
当Swift.org 12月发布时

00:10:04.238 --> 00:10:06.373
我们想做的第一件事之一

00:10:06.440 --> 00:10:08.775
就是帮助增长开发者生态环境

00:10:09.409 --> 00:10:10.878
我们看到了这个语言的价值

00:10:10.944 --> 00:10:13.981
我们想快速地把它介绍给其他
开发者

00:10:14.515 --> 00:10:16.183
我们创造了沙盒

00:10:16.250 --> 00:10:21.588
这允许开发者更容易在Linux上
运行和测试代码

00:10:22.256 --> 00:10:25.225
沙盒在浏览器中运行
有了这

00:10:25.292 --> 00:10:28.862
你可以轻易地编写Swift代码
保存代码

00:10:28.929 --> 00:10:30.764
并看到在服务器上的运行

00:10:31.565 --> 00:10:33.600
自从我们发布了沙盒

00:10:33.667 --> 00:10:37.471
我们根据社区的反馈和要求做出
了很多改进

00:10:38.071 --> 00:10:42.843
沙盒现在支持移动UI
多种UI主题

00:10:43.977 --> 00:10:48.515
自动保存代码
允许选择多个Swift运行时

00:10:49.216 --> 00:10:53.787
为了帮助开发者分享关于Swift
的问题和解决方案

00:10:53.854 --> 00:10:58.125
我们增加了代码快照的支持
依靠一个永久的URL

00:10:58.458 --> 00:11:02.129
你可以用这在邮件列表中分享代码

00:11:02.196 --> 00:11:04.665
还可以在开发者论坛中分享 比如
stackoverflow.com

00:11:06.166 --> 00:11:09.469
从2105年12月4日起
运行了多于150万的代码

00:11:11.104 --> 00:11:15.642
谢谢 我们看到了超过150万次
在沙盒中的运行

00:11:15.709 --> 00:11:17.611
从我们12月发布它起

00:11:17.678 --> 00:11:22.783
从2月起增长了超过200%

00:11:23.951 --> 00:11:28.922
沙盒解锁了从其他平台访问Swift

00:11:29.656 --> 00:11:33.493
实际上我们看到了稳定的增长
和兴趣

00:11:33.560 --> 00:11:37.631
关于来自其他操作系统
的运行和会话

00:11:37.965 --> 00:11:42.503
我们很高兴见到这些
我们希望继续看到Swift的增长

00:11:43.670 --> 00:11:46.306
我们还看到了来自全球的使用

00:11:46.707 --> 00:11:50.677
开发者使用沙盒学习Swift并合作

00:11:51.411 --> 00:11:56.483
我们的目的是继续支持沙盒来帮助
社区的成长

00:11:58.952 --> 00:12:03.323
一个有活力的程序包生态系统对
任何语言都至关重要

00:12:04.157 --> 00:12:08.629
尽管Swift的程序包管理器规格
还是早期技术

00:12:09.029 --> 00:12:10.631
我们在服务器上做的所有事

00:12:10.697 --> 00:12:14.468
都是基于创建和构成基于Swift
的程序包

00:12:15.435 --> 00:12:20.507
因为这 我们发现了关于发现和发布
我们自己的程序包的需求

00:12:21.008 --> 00:12:24.011
所以我们开发了Swift程序包目录
帮助实现这个目标

00:12:24.478 --> 00:12:26.980
我们继续更新程序包目录

00:12:27.047 --> 00:12:30.517
随着Swift程序包管理器
规格的进化

00:12:31.552 --> 00:12:38.025
今天我们的目录中有1500个
和Swift程序包管理器兼容的程序包

00:12:38.559 --> 00:12:41.461
从2月以来增长了400%

00:12:44.198 --> 00:12:47.234
接下来当我们开始思考服务器

00:12:47.301 --> 00:12:50.437
任何服务器语言的一个基本要求

00:12:50.504 --> 00:12:52.906
是能够支持网络接口

00:12:53.907 --> 00:12:57.611
网络框架负责监听端口

00:12:57.678 --> 00:13:00.180
路由代码到合适的逻辑

00:13:00.981 --> 00:13:05.052
我们认为很重要的一点是那个
逻辑尽可能一致

00:13:05.118 --> 00:13:06.987
和客户端的编程模型

00:13:07.621 --> 00:13:10.023
为此目的我们开发了Kitura框架

00:13:10.891 --> 00:13:13.293
我们在2月开源了Kitura

00:13:13.760 --> 00:13:16.730
这是一个基于模块化程序包的
网络框架

00:13:17.731 --> 00:13:21.401
它利用libdispatch和
Foundation实现并行

00:13:21.468 --> 00:13:22.970
和实用程序库的支持

00:13:23.036 --> 00:13:25.138
一致的开发者体验

00:13:25.205 --> 00:13:28.976
这也驱使IBM
对Swift.org的贡献

00:13:30.043 --> 00:13:33.547
我们用Kitura来开发我们
服务器端的应用

00:13:34.848 --> 00:13:36.083
我们和社区一起工作

00:13:36.149 --> 00:13:40.254
有很多IBM以外的
Kitura活跃贡献者

00:13:40.954 --> 00:13:44.591
这是我们把Swift带到服务器的
很重要的一部分

00:13:46.860 --> 00:13:50.998
我们还为基于Swift的工作优化了
我们的云

00:13:52.065 --> 00:13:54.501
我很荣幸地宣布我们最新的更新

00:13:54.601 --> 00:13:57.538
我们基于Cloud Foundry
针对Bluemix的构建包

00:13:58.105 --> 00:14:00.007
包括所有你需要的

00:14:00.073 --> 00:14:04.478
来快速部署你的基于Kitura
的应用到IBM Cloud

00:14:05.345 --> 00:14:08.549
这个构建包
包括最新的Swift运行时

00:14:08.615 --> 00:14:12.052
核心库 依赖的C库

00:14:12.119 --> 00:14:14.555
部署Kitura到云需要它们

00:14:16.423 --> 00:14:19.193
此外开发是关键

00:14:19.826 --> 00:14:23.197
我们很高兴宣布
IBM Cloud Tools for Swift

00:14:23.263 --> 00:14:25.766
一个Mac应用允许你

00:14:25.832 --> 00:14:28.735
容易地用Swift开发端对端应用

00:14:29.736 --> 00:14:35.008
这个工具帮助你快速和容易地
连接客户端应用

00:14:35.075 --> 00:14:37.878
和运行在IBM云上的
服务器端Swift

00:14:38.579 --> 00:14:40.781
继续开发你的工程

00:14:40.848 --> 00:14:44.585
你的客户和服务器端工程
在Xcode中

00:14:44.651 --> 00:14:49.756
用这个工具来连接那些工程
并且部署你的代码到服务器

00:14:50.691 --> 00:14:52.025
有了这些介绍

00:14:52.092 --> 00:14:55.262
我想欢迎我的同事
Patrick Bohrer上台

00:14:55.329 --> 00:14:57.631
他会展示正在运行的服务器端Swift

00:15:05.572 --> 00:15:07.341
谢谢John
我是Pat Bohrer

00:15:07.407 --> 00:15:10.811
是IBM围绕Swift进行
很多有趣事的技术领导

00:15:11.278 --> 00:15:14.181
很激动来到WWDC

00:15:14.248 --> 00:15:17.885
我会进行我认为本场演讲中
有趣且令人兴奋的部分

00:15:18.285 --> 00:15:21.855
它有趣因为我会在服务器上进行
一些Swift的实时编程

00:15:21.922 --> 00:15:23.924
它令人兴奋是因为我的2个演示

00:15:23.991 --> 00:15:25.759
依赖到云的一个工作的网络

00:15:25.826 --> 00:15:27.928
希望我好运

00:15:30.764 --> 00:15:32.566
我们已经谈了服务器端的Swift

00:15:33.667 --> 00:15:35.335
这对很多人意味着很多

00:15:35.402 --> 00:15:37.337
但是对本场观众
对本次演讲

00:15:37.404 --> 00:15:39.439
我们想谈论的是网络服务

00:15:41.175 --> 00:15:42.743
什么是网络服务？

00:15:43.210 --> 00:15:46.847
简单地说 它们是运行在电脑上的
程序

00:15:47.848 --> 00:15:48.849
它们监听

00:15:48.916 --> 00:15:50.651
它们监听进来的请求

00:15:51.285 --> 00:15:52.920
它们负责路由这些请求

00:15:52.986 --> 00:15:56.156
到一些服务器端逻辑并返回回应

00:15:56.857 --> 00:15:59.059
现在外面的
可以是一个浏览器

00:15:59.126 --> 00:16:00.727
可以是另一个应用

00:16:01.395 --> 00:16:03.130
谁知道呢？
可以是另一个服务

00:16:03.397 --> 00:16:05.265
但简单的说
它就是这样

00:16:05.532 --> 00:16:07.768
要开始 这听起来足够简单

00:16:08.702 --> 00:16:11.271
让我们继续深入
做一个现场演示

00:16:15.008 --> 00:16:16.210
我已经提到过

00:16:17.044 --> 00:16:19.346
通常这些网络服务运行在Linux上

00:16:19.413 --> 00:16:21.849
我们听说了
Swift运行在Linux上

00:16:22.182 --> 00:16:25.285
让我们继续 为第一个在Linux上
的演示工作

00:16:26.653 --> 00:16:27.888
让我们那么做

00:16:28.488 --> 00:16:31.458
这里我们有Linux在运行
确保我不是在撒谎

00:16:32.826 --> 00:16:35.762
让我们新建一个目录来做一些
来玩一玩

00:16:35.829 --> 00:16:38.398
所以我们非常有创造性地创造了
一个用来玩的目录

00:16:39.399 --> 00:16:40.701
你可以看到里面没有东西

00:16:41.568 --> 00:16:43.303
我们会用Swift程序包管理器

00:16:43.370 --> 00:16:49.076
如John提到的 我们在服务器
上做的任何事都是基于程序包的

00:16:49.443 --> 00:16:52.880
我们要用 这是一个版本的
Swift程序包管理器

00:16:52.946 --> 00:16:56.149
对晚些时候观看的人来说
这些语法会改变

00:16:56.216 --> 00:17:00.387
但是对我们今天用的这个版本
它有一个初始化步骤

00:17:01.154 --> 00:17:04.758
所以如果我们使用这个命令
可以看到它创建了一些文件

00:17:05.659 --> 00:17:10.130
根据结构和
package.swift文件

00:17:10.964 --> 00:17:13.800
Swift程序包管理器知道怎么构建
你的应用

00:17:13.867 --> 00:17:17.905
如你在这里所见
我们有package.swift

00:17:18.438 --> 00:17:20.641
它创建了
一个Sources.main

00:17:20.707 --> 00:17:24.077
这就是用来构建一Swift
一个简单Swift程序包所需的全部

00:17:24.744 --> 00:17:26.847
说过这些
让我们继续

00:17:27.146 --> 00:17:30.517
我们可以开始Swift构建
这很容易

00:17:30.984 --> 00:17:35.255
它创建了一个.build/debug/play
可执行程序

00:17:35.322 --> 00:17:36.423
让我们运行它

00:17:37.991 --> 00:17:39.326
你好世界

00:17:44.898 --> 00:17:47.134
但我们在开发网络服务
让我们做一些真实东西

00:17:49.903 --> 00:17:54.141
这是Swift程序包管理器
为我们创建的东西

00:17:54.208 --> 00:17:59.179
我们最好有一个程序包
它是基于我们的称为Play的目录

00:17:59.246 --> 00:18:01.982
它给我们的可执行程序命名为play
这是得名的原因

00:18:02.583 --> 00:18:04.418
我们想要增加一部分

00:18:04.484 --> 00:18:08.555
那是对Kitura的依赖
我们只需要指出这

00:18:10.757 --> 00:18:15.329
现在我们来到主文件

00:18:15.796 --> 00:18:17.497
让我们删除旧的你好世界

00:18:19.032 --> 00:18:20.467
让我们在这加一些代码

00:18:20.901 --> 00:18:23.737
这个代码所做的是 忠实的支持者

00:18:23.804 --> 00:18:25.205
我们获得Foundation

00:18:25.739 --> 00:18:30.043
我们导入Kitura和
一些Kitura支持程序包

00:18:31.345 --> 00:18:34.548
我们定义了一个路由
我提到过的 为了进入的请求

00:18:34.615 --> 00:18:36.316
我们需要把这些请求导到一些地方

00:18:36.850 --> 00:18:40.821
我们要定义一个路由
在这 那是/hello

00:18:41.421 --> 00:18:45.659
如果任何请求进入 我们会运行
这些代码

00:18:45.993 --> 00:18:46.827
很简单

00:18:47.461 --> 00:18:49.363
我们会指定一些回应头

00:18:50.063 --> 00:18:53.033
我们会发送回一个字符串说你好
世界

00:18:53.767 --> 00:18:57.771
往下到这我们指定我们监听的端口
是8095

00:18:58.238 --> 00:19:01.842
我们开始监听这个端口
我们指定我们的路由是一个委托

00:19:01.909 --> 00:19:03.343
然后我们启动服务器

00:19:03.944 --> 00:19:04.978
这很简单

00:19:08.882 --> 00:19:10.417
让我们保存它

00:19:13.153 --> 00:19:15.656
现在我们要第一次构建Kitura

00:19:15.789 --> 00:19:17.224
因此我们在这加了一些东西

00:19:17.291 --> 00:19:20.627
John提到过 我们利用
libdispatch和Foundation

00:19:21.028 --> 00:19:22.529
所以它在做的是获取

00:19:22.596 --> 00:19:25.232
Swift程序包管理器正在获取我们
需要的东西

00:19:25.299 --> 00:19:26.867
我们写我们关心的代码

00:19:27.334 --> 00:19:29.837
Swift程序包管理器
获得Kitura

00:19:29.903 --> 00:19:33.674
它在获取我们的网络
它在获取一些系统支持

00:19:33.740 --> 00:19:38.378
一个记录器 所有你在网络服务
中需要的东西

00:19:38.512 --> 00:19:41.448
以及监听套接字和其他的功能

00:19:41.515 --> 00:19:43.584
这些都是独立的程序包

00:19:43.650 --> 00:19:46.186
在GitHub上
你可以获取

00:19:50.190 --> 00:19:51.525
它被编译和构建

00:19:54.761 --> 00:19:56.897
现在让我们运行可执行文件

00:19:56.964 --> 00:20:02.069
我们现在可以看到
它说它在监听8095端口

00:20:02.736 --> 00:20:04.938
让我们看一看

00:20:07.975 --> 00:20:12.846
打开本地主机8095端口
因程序运行在本地Mac和Linux

00:20:13.180 --> 00:20:14.715
你看到我们看到一个Kitura页面

00:20:14.781 --> 00:20:17.417
如果我们没有定义默认路由

00:20:17.651 --> 00:20:21.088
它会显示这个页面并说明其他
开始的方式

00:20:21.154 --> 00:20:25.592
你可以覆盖这些
但是对我们来说想要定义的是一个你好

00:20:33.967 --> 00:20:37.504
所以你要做的第一件事是说你好
世界

00:20:37.571 --> 00:20:40.841
第一步
当你思考它时

00:20:40.908 --> 00:20:42.743
让我们返回
我们会在这做更多

00:20:45.012 --> 00:20:47.080
让我们返回并编辑主文件

00:20:47.314 --> 00:20:49.783
这里有很多东西是我们可以用的

00:20:49.850 --> 00:20:50.918
我们有Foundation

00:20:52.119 --> 00:20:54.054
我们可以生成JSON

00:20:54.488 --> 00:21:00.060
让我们添加一个小助手代码来
帮助我们生成JSON字符串

00:21:00.494 --> 00:21:03.497
我们会添加一个叫做今天的路由

00:21:06.233 --> 00:21:10.470
这是一个新路由 如果有东西进入
/today

00:21:10.537 --> 00:21:13.974
它会利用Foundation
获得当前日期

00:21:14.741 --> 00:21:16.577
我们会新建
一个NSDateFormatter

00:21:16.643 --> 00:21:18.111
就像我们在客户端会做的一样

00:21:18.512 --> 00:21:22.382
我们用这DateFormatter
来创建日期和时间字符串

00:21:22.449 --> 00:21:25.052
然后我们来到我们的回应

00:21:25.118 --> 00:21:27.754
在这我们创建一个负载是一个字典

00:21:28.255 --> 00:21:31.458
现在在互联网上 你们都知道的
这都是JSON

00:21:31.925 --> 00:21:36.530
我们指定消息是你好世界
日期和时间是当前的

00:21:36.597 --> 00:21:40.033
我们把它转化成字符串
这是我们这次返回的

00:21:40.133 --> 00:21:41.668
让我们看看它是怎么工作的

00:21:44.605 --> 00:21:45.973
让我们重新构建

00:21:46.673 --> 00:21:48.308
快多了 所有程序包都在本地

00:21:48.375 --> 00:21:49.409
这很好

00:21:50.844 --> 00:21:54.248
我们会再次运行它
你可以看到我们在监听8095

00:21:55.949 --> 00:22:00.053
我们会刷新并看到我们仍然在
你好上返回你好世界

00:22:00.721 --> 00:22:02.022
让我们看看今天

00:22:03.924 --> 00:22:05.726
这就是了
我们有JSON负载

00:22:11.398 --> 00:22:13.567
每次有人来这

00:22:13.634 --> 00:22:16.003
这些代码会被运行
返回一个回应

00:22:16.069 --> 00:22:18.805
这是一个很简单的如何开始

00:22:26.713 --> 00:22:28.448
我妻子要我取下眼镜

00:22:30.784 --> 00:22:33.754
这很有趣但是现在让我们让它更
有趣

00:22:34.755 --> 00:22:36.790
在我们讨论时我想首先介绍给你们

00:22:36.857 --> 00:22:39.826
一个有趣的例子
我们提供给社区的

00:22:39.893 --> 00:22:41.094
它叫做BluePic

00:22:41.161 --> 00:22:42.162
端对端Swift BluePic

00:22:42.229 --> 00:22:46.200
BluePic是一个
社交相片分享应用示例

00:22:47.968 --> 00:22:51.205
它有富客户端界面
一个很漂亮的界面

00:22:51.271 --> 00:22:54.341
我们开发并提供它做为示例的
一部分

00:22:55.108 --> 00:22:59.746
它还有个很有趣的后端

00:22:59.813 --> 00:23:02.783
是一个Swift服务器后端
纯Swift

00:23:02.850 --> 00:23:05.419
使用Kitura
运行在IBM Cloud

00:23:05.485 --> 00:23:08.021
它还使用一些有趣的服务

00:23:08.088 --> 00:23:10.824
我会提到 如Watson和
ObjectStore

00:23:10.891 --> 00:23:12.826
SQL数据库 这些好东西

00:23:13.493 --> 00:23:15.929
如果你准备好深入

00:23:18.932 --> 00:23:22.870
它还使用IBM全新的事件驱动的
编程模型

00:23:22.936 --> 00:23:25.339
叫做OpenWhisk
它也支持Swift

00:23:25.739 --> 00:23:28.909
这个程序包还有很多事在发生

00:23:28.976 --> 00:23:32.045
它现在在GitHub上
为那些想开始的人

00:23:33.614 --> 00:23:35.949
在我们进入演示模式前

00:23:36.016 --> 00:23:38.652
我想花一点时间谈谈设计模式

00:23:39.486 --> 00:23:42.890
不像以前我们有网络浏览器做为
客户端

00:23:43.724 --> 00:23:45.926
我们当然有iOS应用

00:23:45.993 --> 00:23:47.761
它有我们的MVC设计模式

00:23:47.828 --> 00:23:49.596
你看到它还有一个网络接口

00:23:49.663 --> 00:23:51.231
有请求和回应

00:23:51.765 --> 00:23:55.169
它和我们的Swift中间层联系
和我们刚刚做的类似

00:23:55.235 --> 00:23:57.004
这只是更有趣

00:23:57.070 --> 00:24:01.475
接收一个进入的路由请求 把它们
路由到一些逻辑

00:24:02.075 --> 00:24:04.811
然后 最后 我们还有一部分

00:24:04.878 --> 00:24:07.714
我们有一些有趣的服务
我们会讨论一下

00:24:07.781 --> 00:24:10.317
用来保存我们应用的所有数据

00:24:12.419 --> 00:24:14.488
再深入一点

00:24:14.555 --> 00:24:15.789
我们有客户端

00:24:16.490 --> 00:24:19.459
它有响应性
它是非常用户特定的和视图驱动的

00:24:19.526 --> 00:24:24.965
用来渲染一些漂亮的界面
和应用的用户互动

00:24:25.032 --> 00:24:26.366
然后我们有中间层

00:24:26.433 --> 00:24:29.670
中间层响应用户有的所有东西

00:24:29.736 --> 00:24:31.772
但是它还做一些很有趣的事

00:24:31.839 --> 00:24:35.709
当相片被递交给中间层

00:24:35.776 --> 00:24:39.146
它会接受那些相片并储存到
ObjectStore中

00:24:39.246 --> 00:24:41.381
会围绕它们创建一些元数据

00:24:41.448 --> 00:24:43.383
但还会做些有趣的事

00:24:43.450 --> 00:24:48.622
它会把相片递交给Watson的
Vision Insights

00:24:49.056 --> 00:24:51.225
提取相片的标签

00:24:51.291 --> 00:24:53.694
山 湖和类似的东西

00:24:53.760 --> 00:24:57.164
这像是从中间层给我们的应用
添加一些特殊酱汁

00:24:57.598 --> 00:24:59.666
它还会注意到相片是在哪拍摄的

00:25:00.367 --> 00:25:03.637
调用Watson的Weather
Insights获取信息

00:25:03.704 --> 00:25:05.305
当地的天气是怎样的？

00:25:05.405 --> 00:25:06.440
我们添加所有这些

00:25:06.507 --> 00:25:09.610
不是把这些双程通信放在客户端

00:25:09.676 --> 00:25:12.946
我们把它放在服务器端
它总是可用

00:25:13.013 --> 00:25:15.182
构成我们的服务

00:25:15.549 --> 00:25:18.018
实际上这是端对端Swift

00:25:18.218 --> 00:25:20.988
让我们部署合适的代码到合适的
地方

00:25:23.023 --> 00:25:25.359
这是在野外运行的BluePic

00:25:26.193 --> 00:25:27.394
它运行在设备上

00:25:27.461 --> 00:25:29.796
它连接了云

00:25:29.863 --> 00:25:31.832
应用服务器接下来联系

00:25:31.899 --> 00:25:34.701
各种不同的服务
我提到过的 这很好

00:25:35.369 --> 00:25:39.373
现在如果出现一些问题 我们需要
调试或进一步开发应用

00:25:39.439 --> 00:25:40.274
我们要怎么做？

00:25:40.674 --> 00:25:43.310
做为一个iOS开发者我们知道该
怎么做

00:25:43.911 --> 00:25:46.547
我们获取应用的源代码放到我们
的Mac中

00:25:46.780 --> 00:25:49.716
我们把它载入Xcode
然后我们准备好了 对吗？

00:25:49.783 --> 00:25:50.884
我们可以调试它

00:25:51.552 --> 00:25:52.753
我们可以调试应用

00:25:52.819 --> 00:25:55.756
你可以向云发送请求

00:25:56.056 --> 00:25:58.025
我们现在知道做这些

00:25:58.292 --> 00:26:00.694
但是现在中间层也在运行Swift

00:26:00.761 --> 00:26:01.595
我们要怎么做？

00:26:02.062 --> 00:26:05.666
对的 你可能不想
像我一样在Linux上使用VI

00:26:07.534 --> 00:26:09.303
但是我们能做相同的事

00:26:09.369 --> 00:26:14.107
我们可以获取服务器端源代码到
Mac中

00:26:14.341 --> 00:26:18.111
把它载入Xcode 然后我们就可以
进行正常的开发

00:26:18.178 --> 00:26:20.781
并且在Mac上本地调试
我们在调试和开发

00:26:23.784 --> 00:26:24.751
这令人兴奋

00:26:27.187 --> 00:26:30.324
现在我们的开发世界变得更大了

00:26:30.424 --> 00:26:32.659
我们实际上控制端到端的所有事

00:26:32.726 --> 00:26:36.096
从客户端到中间层
甚至到我们接触的服务

00:26:36.463 --> 00:26:38.632
我们真的对此感到兴奋

00:26:38.699 --> 00:26:41.535
因为我们认为它降低了开发周期

00:26:41.635 --> 00:26:43.203
因为你在客户端上工作

00:26:43.270 --> 00:26:45.606
而且你想在后端增加功能

00:26:45.672 --> 00:26:47.441
是在一个你了解的世界中

00:26:48.976 --> 00:26:53.013
到那一端 我们做为开发者
我们认为我们可以再深入一些

00:26:53.614 --> 00:26:56.617
就像我们对程序包目录
和Swift沙盒所做的

00:26:56.683 --> 00:26:59.653
我们开发了叫做
IBM Cloud Tools for Swift应用

00:27:00.287 --> 00:27:04.224
作为一个Mac应用来帮助我们管理
这个更大的开发世界

00:27:04.725 --> 00:27:06.593
我们对此感到兴奋

00:27:08.161 --> 00:27:11.198
这个应用实际上使我们能够

00:27:11.265 --> 00:27:13.800
管理端到端的整个栈

00:27:14.835 --> 00:27:17.905
有很多事是我们能手动做的

00:27:18.639 --> 00:27:20.707
但是为什么不用一些工具来帮助
你呢？

00:27:20.774 --> 00:27:22.009
IBM Cloud Tools for Swift

00:27:22.075 --> 00:27:24.278
我们期待听到你们对此的反馈

00:27:24.344 --> 00:27:26.280
像我们的沙盒和目录

00:27:26.914 --> 00:27:30.250
我们会继续 你们知道
我们的这些应用刚开始

00:27:30.317 --> 00:27:33.654
做为开发者我们知道我们想要它
做的

00:27:33.954 --> 00:27:36.623
我们会继续增加功能并聆听社区

00:27:36.690 --> 00:27:38.592
但是我们对它的可能性感到兴奋

00:27:39.359 --> 00:27:42.129
我们的目标是允许社区

00:27:42.196 --> 00:27:46.600
继续开发优秀的应用
现在由服务器上的Swift驱动

00:27:48.235 --> 00:27:50.204
有了这些背景

00:27:50.270 --> 00:27:52.306
让我们再看看一些演示

00:27:53.407 --> 00:27:56.076
会向你展示和Swift一起的未来
有多光明

00:28:01.748 --> 00:28:05.819
首先这是
IBM Cloud Tools for Swift

00:28:06.253 --> 00:28:07.888
如果你想要开始

00:28:08.222 --> 00:28:11.925
它显示给你一个界面
是一个漂亮的富界面

00:28:12.092 --> 00:28:14.828
对那些想要
开始使用BluePic的人

00:28:15.095 --> 00:28:18.065
它还允许创建一个BluePic工程

00:28:18.866 --> 00:28:21.935
创建Kitura工程或一个空工程

00:28:22.436 --> 00:28:23.904
关于这有趣的部分

00:28:23.971 --> 00:28:27.307
不仅是克隆那些工程

00:28:27.374 --> 00:28:31.044
还提供来自IBM Cloud的资源

00:28:31.111 --> 00:28:34.181
当你准备好部署工程
它会

00:28:34.248 --> 00:28:37.251
实际上 当你创建这些
它会部署它

00:28:37.317 --> 00:28:39.453
因为它知道这是一个工作的例子

00:28:40.053 --> 00:28:43.490
要准备好并快速运行
这是开始的一个好方式

00:28:45.626 --> 00:28:48.662
对我们 我们已经创建了一个
BluePic应用

00:28:49.930 --> 00:28:52.399
你可以看到
我们有一个BluePic演示

00:28:53.267 --> 00:28:54.234
非常聪明的命名

00:28:55.035 --> 00:28:57.204
在这你可以看到我们有一个客户端
应用

00:28:57.271 --> 00:29:00.140
一个客户端应用和云运行时之间
的捆绑

00:29:00.240 --> 00:29:01.408
它们都用Swift写

00:29:01.975 --> 00:29:06.280
此外如果我们深入
这里是服务器端代码

00:29:06.580 --> 00:29:10.684
你可以看到它有代码在我的电脑
本地位置的引用

00:29:10.751 --> 00:29:13.854
以及绑定到它在云上的位置

00:29:13.921 --> 00:29:18.192
以及为了应用提供的所有服务

00:29:18.559 --> 00:29:21.895
我可以在Mac本地管理所有这些

00:29:23.830 --> 00:29:26.500
并且我可以启动

00:29:26.567 --> 00:29:30.003
在界面中点击一下
来查看我的客户端

00:29:30.904 --> 00:29:32.973
这就是BluePic的客户端应用

00:29:35.542 --> 00:29:40.080
它也被创建了 让我放大一下
这个文件

00:29:40.147 --> 00:29:41.648
Bluemix.plist

00:29:42.049 --> 00:29:44.551
知道开发周期 可以运行

00:29:44.618 --> 00:29:48.121
你的云服务 在本地而不是远程

00:29:48.188 --> 00:29:50.157
很容易控制这些

00:29:50.357 --> 00:29:55.262
它会监听本地8090或者远程的
在Bluemix里

00:29:55.329 --> 00:29:57.130
并传递授权

00:29:58.165 --> 00:30:00.367
这里的想法是使这些简单

00:30:01.268 --> 00:30:03.770
在这我们继续运行
让我们想像

00:30:03.837 --> 00:30:10.310
有人提交了一个关于这个应用的
错误报告

00:30:10.477 --> 00:30:11.745
这是我们的应用

00:30:12.045 --> 00:30:14.481
它有漂亮的界面

00:30:15.048 --> 00:30:17.384
我们可以滚动
我们可以看更多图片

00:30:17.451 --> 00:30:21.188
如果我们点击这些图片
我们可以看到有更多信息

00:30:21.255 --> 00:30:24.024
这一张的名字是自然
我们可以看看是谁拍摄的

00:30:24.391 --> 00:30:26.393
可以看到 是在德克萨斯州
奥斯汀拍摄的

00:30:26.460 --> 00:30:27.794
在那没有山

00:30:29.263 --> 00:30:31.265
我们还可以看到当时的天气

00:30:31.365 --> 00:30:35.602
多亏Watson Insight
我们看到一些标签

00:30:35.669 --> 00:30:38.005
这很有趣
如果我点击标签可以看到

00:30:38.071 --> 00:30:40.307
我们有一个相片有湖

00:30:41.375 --> 00:30:42.943
如果我返回 让我们点击山

00:30:43.577 --> 00:30:45.612
我们看到有一些相片有山

00:30:45.679 --> 00:30:48.649
所有这些都是通过后端集成完成的

00:30:48.715 --> 00:30:51.718
用户不需要加标签
这是自动提取的

00:30:52.686 --> 00:30:55.422
但是我们听说有一些抱怨关于
当我点击多云的天时

00:30:55.489 --> 00:30:56.590
所以让我们看看

00:30:57.624 --> 00:30:59.660
我们点击多云的天
我们看不到任何东西

00:31:00.060 --> 00:31:02.796
我们知道这发生了什么

00:31:02.863 --> 00:31:05.732
不知道为什么服务器没有返回正确
结果

00:31:06.433 --> 00:31:07.534
让我们切换一下

00:31:08.368 --> 00:31:10.704
我们想找出原因 弄清真相

00:31:11.271 --> 00:31:15.108
所以我们来到这 点击服务器端
代码

00:31:16.476 --> 00:31:20.113
它会启动并显示服务器端代码
所在的目录

00:31:21.348 --> 00:31:23.250
如果我把这些载入一个终端

00:31:25.986 --> 00:31:28.288
你可以看到有很多相同文件
我提到过的

00:31:28.355 --> 00:31:30.357
我们在服务器上
使用Swift 3.0

00:31:30.724 --> 00:31:33.260
我们有Package.Swift
我们有资源

00:31:33.660 --> 00:31:35.295
我继续

00:31:35.362 --> 00:31:37.798
并创建了一个服务器端代码的
Xcode工程

00:31:39.066 --> 00:31:40.067
让我们打开它

00:31:42.236 --> 00:31:45.172
这就是代码
这是一个图像的获取处理器

00:31:45.305 --> 00:31:47.875
我们知道当我们想要图像
我们的图像供给

00:31:47.941 --> 00:31:51.078
我们会调用获取函数 在服务器
的/images目录

00:31:51.745 --> 00:31:53.614
若我们看看这 我们想要深入它并说

00:31:53.680 --> 00:31:57.818
不知道为什么当我传入一个标签
我们没有返回正确结果

00:31:58.018 --> 00:32:01.355
让我们在这加一个断点
我们会运行服务器

00:32:05.158 --> 00:32:08.195
现在我们可以看到服务器在监听
本地的8090端口

00:32:09.129 --> 00:32:10.597
让我们切回去

00:32:14.968 --> 00:32:19.706
在这我们要客户端的本地选择是

00:32:19.773 --> 00:32:22.075
这样它就会连接到我们的本地服务器

00:32:22.142 --> 00:32:23.911
让我们重新运行模拟器

00:32:27.548 --> 00:32:30.817
顺便说一下 我在网络连接这方面
真是很幸运

00:32:31.151 --> 00:32:32.486
请继续保持你们所做的

00:32:34.021 --> 00:32:37.658
让我们向下滚动到我们有问题的
文件

00:32:37.724 --> 00:32:38.859
让我们在这点击

00:32:39.293 --> 00:32:41.061
让我们点击多云的天

00:32:41.261 --> 00:32:42.262
好的

00:32:43.163 --> 00:32:45.098
在这我们在服务器来到了断点

00:32:51.705 --> 00:32:54.274
如果我们想知道发生了什么

00:32:54.341 --> 00:32:55.509
比如我们想要打印标签

00:32:58.045 --> 00:33:01.315
我们可以看到
有点难看到那个

00:33:01.815 --> 00:33:05.319
我们可以看到进入的字符串
是cloudy%20sky

00:33:05.819 --> 00:33:07.187
这不好
我们不想要这样

00:33:08.388 --> 00:33:09.957
让我们看看

00:33:10.023 --> 00:33:11.959
我们还知道
有Foundation

00:33:12.659 --> 00:33:17.030
若我们用Foundation清理它

00:33:18.732 --> 00:33:20.501
我们会移除百分号

00:33:21.635 --> 00:33:24.571
现在这是一个变量而不是一个let

00:33:25.572 --> 00:33:26.940
让我们构建它

00:33:30.511 --> 00:33:31.712
我们会再运行它

00:33:32.546 --> 00:33:33.547
重新运行服务器

00:33:36.016 --> 00:33:38.318
让我们返回应用

00:33:39.052 --> 00:33:41.822
好了

00:33:42.489 --> 00:33:43.624
等待我们的时候超时了

00:33:44.625 --> 00:33:47.361
让我们返回
让我们再点击一次多云的天

00:33:48.395 --> 00:33:50.063
看看我们是不是改正了我们的问题

00:33:51.498 --> 00:33:52.332
打印标签

00:33:53.033 --> 00:33:54.868
好多了
这是我们想要的

00:33:56.336 --> 00:34:00.974
让我们关闭这个断点并继续

00:34:06.914 --> 00:34:08.514
我们看到我们得到了结果

00:34:14.755 --> 00:34:17.257
此外 因为我改正了错误

00:34:17.991 --> 00:34:21.395
我可以返回到Swift云工具

00:34:21.460 --> 00:34:25.132
我可以进行重新部署
把这些代码部署到服务器上

00:34:25.364 --> 00:34:27.701
它会马上开始部署代码

00:34:28.068 --> 00:34:30.536
和你的客户端一起工作就是这么简单

00:34:30.603 --> 00:34:33.440
和你的服务器端
以及重新部署到云

00:34:40.746 --> 00:34:43.016
我希望你们喜欢这些演示

00:34:43.083 --> 00:34:46.687
我需要告诉你因为每件事都进展顺利
我觉得放松了很多

00:34:48.922 --> 00:34:53.493
代表IBM
我和John谢谢所有抽空前来的人

00:34:54.061 --> 00:34:56.530
做为一个Swift开发者这是令人
兴奋的时候

00:34:57.097 --> 00:35:01.902
我们邀请你加入我们
加入更广泛的社区

00:35:01.969 --> 00:35:05.539
把Swift的能力带到服务器

00:35:06.139 --> 00:35:08.475
更多信息 关于你在这听到的任何
事

00:35:08.842 --> 00:35:10.577
关于我们是什么 IBM在做什么

00:35:11.178 --> 00:35:15.549
我们有developer.IBM.com/Swift
你们可以来我们的开发中心

00:35:16.016 --> 00:35:17.451
就这些了 再次感谢

00:35:17.518 --> 00:35:18.585
我会交回给Philippe

00:35:27.828 --> 00:35:31.865
如你们见 IBM对Swift
进行了很多很棒的工作

00:35:31.932 --> 00:35:34.535
他们不仅仅贡献优秀的代码

00:35:34.868 --> 00:35:36.603
他们还丰富社区

00:35:36.670 --> 00:35:38.605
和他们开发服务的各种经验

00:35:38.672 --> 00:35:40.307
和流水线化开发流程

00:35:40.841 --> 00:35:44.645
他们的一些工作对使服务器端
Swift成为可能相当重要

00:35:45.946 --> 00:35:49.049
但是你们也可以帮助
使服务器端Swift成为现实

00:35:49.750 --> 00:35:53.086
有一些事是你们可以贡献的

00:35:54.288 --> 00:35:56.723
Swift的一些部分还没有完成

00:35:56.790 --> 00:35:58.425
有很多工作要做

00:35:58.659 --> 00:36:01.361
有一些功能还没有实现

00:36:01.662 --> 00:36:05.032
没有实现表明有贡献的机会

00:36:05.499 --> 00:36:08.168
有很多容易的方式让你做出贡献

00:36:08.235 --> 00:36:13.774
缺陷追踪系统有一类问题被加上
了初学者缺陷的标签

00:36:13.841 --> 00:36:15.776
但是代码不仅仅是实现

00:36:16.310 --> 00:36:19.880
设计可以和Swift一起工作的
新API和指南

00:36:19.947 --> 00:36:23.851
是邮件列表上的日常工作

00:36:24.084 --> 00:36:27.454
很多讨论是关于语言本身的工作

00:36:27.521 --> 00:36:29.690
并且是来自像你这样的贡献者

00:36:30.657 --> 00:36:34.228
当然 你的程序包 你的应用

00:36:34.294 --> 00:36:36.563
会使得服务器上的Swift了不起

00:36:38.365 --> 00:36:41.935
如果你有任何问题
关于资源或链接

00:36:42.002 --> 00:36:44.371
关于我们今天讨论的内容的

00:36:44.438 --> 00:36:48.242
我们有本场演讲 我们有一切
集合在一起

00:36:48.909 --> 00:36:52.613
还有一些很好的相关演讲

00:36:52.679 --> 00:36:54.548
我强烈建议观看

00:36:54.915 --> 00:36:59.887
API设计指南讨论了我们的一些
设计上的想法

00:36:59.953 --> 00:37:03.123
在Swift 3新命名的背后

00:37:03.724 --> 00:37:07.294
我强烈建议你们看一下

00:37:07.361 --> 00:37:09.429
“Swift Foundation
的新特性”

00:37:09.496 --> 00:37:12.533
所有新添加的值的类型和特性

00:37:12.599 --> 00:37:16.103
都会在服务器上可用

00:37:16.703 --> 00:37:20.140
当然性能不仅仅是在本地应用上
必要的

00:37:20.908 --> 00:37:23.577
我们也需要确保服务器

00:37:23.644 --> 00:37:25.379
的响应性好而且快

00:37:25.445 --> 00:37:29.550
所以性能 在所有平台上
Linux和Mac上都有

00:37:29.883 --> 00:37:31.351
是需要关注的

00:37:31.418 --> 00:37:36.757
我强烈建议看一看GCD中的新特性

00:37:36.823 --> 00:37:38.892
会和Swift 3一起发布

00:37:40.427 --> 00:37:42.196
就是这些了 非常谢谢