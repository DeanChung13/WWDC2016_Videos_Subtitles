00:00:20.153 --> 00:00:23.023 
采用METAL 第一部分

00:00:26.393 --> 00:00:29.296 
下午好 欢迎来到
“采用Metal 第一部分”

00:00:29.696 --> 00:00:32.165 
我是GPU软件团队的
Warren Moore

00:00:32.499 --> 00:00:36.203 
我和同事Matt Collins
一起 他主要负责做展示

00:00:36.904 --> 00:00:38.338 
我想问一个

00:00:38.405 --> 00:00:41.542 
看似简单的问题 什么是Metal

00:00:42.209 --> 00:00:45.345 
你可能已听说过Metal是
Apple的偏底层的API

00:00:45.412 --> 00:00:48.882 
面向GPU的
它是一个统一的图形计算语言

00:00:49.216 --> 00:00:51.652 
并且面向多线程做了优化

00:00:51.952 --> 00:00:53.720 
专门为我们的平台所设计

00:00:53.954 --> 00:00:55.255 
这些都是正确的

00:00:55.589 --> 00:00:58.825 
但是Metal不仅有
Metal.framework

00:00:59.193 --> 00:01:04.864 
Metal同时也被
其他的框架和工具支持

00:01:05.699 --> 00:01:08.869 
它们提供了比metal框架
API多很多的东西

00:01:09.269 --> 00:01:11.939 
尤其是去年我们引入MetalKit

00:01:12.339 --> 00:01:14.775 
它包括了用来一些处理常见任务的工具

00:01:14.842 --> 00:01:18.478 
像与UIKit和AppKit交互
加载纹理

00:01:20.113 --> 00:01:21.748 
还有Metal性能着色器

00:01:21.949 --> 00:01:25.419 
能帮你做图片处理

00:01:25.485 --> 00:01:28.789 
可以手动调优 高度优化的着色器

00:01:29.189 --> 00:01:32.159 
可以直接放到你的应用里
来处理这些任务

00:01:33.227 --> 00:01:36.263 
Metal同时还紧密
与我们的开发工具结合

00:01:36.496 --> 00:01:37.998 
像Xcode与
Instruments

00:01:40.167 --> 00:01:41.902 
当你的应用里面有着色器

00:01:42.336 --> 00:01:44.471 
它们会同你的应用一起编译

00:01:44.571 --> 00:01:48.809 
通过Xcode集成到你的应用包里

00:01:49.376 --> 00:01:52.279 
还有GPU框架调试器
可以做一个快照

00:01:52.579 --> 00:01:55.916 
在程序运行的任何一个点
来看看程序现在是什么情况

00:01:56.717 --> 00:01:59.086 
Instruments中
Metal系统跟踪

00:01:59.553 --> 00:02:01.955 
可以让你在运行是查看应用的性能

00:02:02.022 --> 00:02:03.857 
和行为

00:02:05.359 --> 00:02:07.794 
两年前我们把Metal引入了iOS

00:02:08.027 --> 00:02:13.100 
然后我们又把它带到了
Mac OS和tvOS

00:02:13.800 --> 00:02:16.436 
所以现在在我们平台上
受到了广泛的支持

00:02:17.004 --> 00:02:19.540 
同时我们的大部分硬件也支持它

00:02:19.907 --> 00:02:24.044 
包括桌面架构和移动架构

00:02:24.111 --> 00:02:27.114 
像Apple AMD Intel
和NVIDIA

00:02:27.447 --> 00:02:30.884 
所有的2012年后的Mac

00:02:31.185 --> 00:02:34.655 
2013年以后的所有iOS设备
还有新的Apple TV

00:02:35.389 --> 00:02:38.725 
Metal可以让应用程序充分利用
GPU的性能

00:02:38.792 --> 00:02:42.162 
在我们的海量的产品上

00:02:44.898 --> 00:02:47.701 
在这些平台上Metal属于基础技术

00:02:48.235 --> 00:02:52.406 
它支持核心图像 核心动画

00:02:52.773 --> 00:02:56.710 
游戏和图形库比如SpriteKit
SceneKit和Model I/O

00:02:57.211 --> 00:02:58.912 
也是我们关键系统软件的重要部分

00:02:58.979 --> 00:03:02.716 
像Preview和Safari

00:03:04.384 --> 00:03:06.587 
各种各样开发者们
已广泛使用了Metal

00:03:06.653 --> 00:03:10.591 
从AAA工作室 游戏引擎提供商

00:03:11.024 --> 00:03:14.294 
到独立开发者和专业工具开发者

00:03:14.428 --> 00:03:17.831 
他们开发了非常好的应用和游戏

00:03:18.398 --> 00:03:21.502 
这只是一部分
我想着重说几个

00:03:22.469 --> 00:03:26.073 
比如 Fancy Guo用
Metal显著的提升了性能

00:03:26.273 --> 00:03:27.741 
带来了惊人的视觉效果

00:03:27.808 --> 00:03:31.512 
在他们广受欢迎的MORPG游戏
Furious Wings

00:03:33.180 --> 00:03:36.817 
Metal也被用在
专业的内容创造工具

00:03:36.884 --> 00:03:39.419 
像iPad上即将发布的
Affinity Photos

00:03:40.487 --> 00:03:44.691 
我带大家快速预览下都有什么

00:03:46.026 --> 00:03:48.595 
这个是Serif Labs的
Affinity Photos

00:03:49.196 --> 00:03:51.198 
这是个全功能的图片编辑应用

00:03:51.265 --> 00:03:54.501 
在iPad pro上
Metal可让其获得令人惊叹的效果

00:03:57.938 --> 00:04:00.874 
今年的 WWDC
我们会给你一些工具

00:04:01.241 --> 00:04:02.743 
让你们开始使用Metal

00:04:02.809 --> 00:04:05.812 
来制作体验非常棒的应用

00:04:06.780 --> 00:04:10.551 
今年的 WWDC 有很多很棒的内容

00:04:10.751 --> 00:04:12.619 
有五场讲座专门介绍Metal

00:04:13.253 --> 00:04:16.390 
当然这是第一场会话
采用Metal 第一部分

00:04:16.990 --> 00:04:19.159 
在这节中我们会讨论

00:04:19.226 --> 00:04:23.263 
Metal里的一些基本概念

00:04:23.864 --> 00:04:26.600 
接着会介绍2D绘图添加光照

00:04:26.667 --> 00:04:29.903 
纹理和动画 我们还会介绍3D

00:04:30.637 --> 00:04:34.074 
这节课的第二部分
也是在这个教室 紧接着这节课

00:04:34.474 --> 00:04:36.176 
我们会介绍动态数据管理

00:04:36.243 --> 00:04:38.445 
接着会介绍一些高级的

00:04:38.545 --> 00:04:40.414 
关于GPU和CPU的同步

00:04:40.614 --> 00:04:43.016 
会让你性能达到新高度

00:04:43.116 --> 00:04:44.885 
通过使用多线程编码

00:04:47.421 --> 00:04:49.723 
我们会介绍下
Metal里有什么新东西

00:04:49.790 --> 00:04:52.893 
确实有很多新特性

00:04:52.960 --> 00:04:56.063 
在昨天的统一介绍中
相信你们也看到了一些

00:04:57.831 --> 00:04:59.266 
我不会详细介绍全部的东西

00:04:59.333 --> 00:05:01.768 
如果你想在你的应用中使用

00:05:01.835 --> 00:05:03.837 
你应该看一下那个最新课程

00:05:05.572 --> 00:05:08.709 
最后 我们会有个很棒的
高级着色器优化的课程

00:05:09.176 --> 00:05:12.312 
对于那些想要

00:05:12.379 --> 00:05:14.781 
更好的使用着色器的人来说
这些绝对是干货

00:05:14.848 --> 00:05:17.284 
我们会详细的讨论硬件如何工作

00:05:17.351 --> 00:05:20.587 
你该怎样使用Metal来更好的
发挥它的性能

00:05:21.622 --> 00:05:23.056 
还有调优你的着色器代码

00:05:24.157 --> 00:05:26.827 
在这些课程中 我们会创建样例工程

00:05:26.894 --> 00:05:30.030 
由简单的
Hello Triangle开始

00:05:30.097 --> 00:05:31.798 
图形编程领域的
Hello world

00:05:32.232 --> 00:05:35.402 
然后 我们会研究动画和纹理贴图

00:05:35.702 --> 00:05:38.305 
第二部分 我们会进入到下一层级

00:05:38.906 --> 00:05:41.341 
讨论下实时更新对象数据

00:05:41.675 --> 00:05:44.578 
同时还有 通过多线程
来优化绘制调用

00:05:45.913 --> 00:05:48.515 
现在我们假设

00:05:49.283 --> 00:05:50.651 
你们已经熟悉

00:05:50.717 --> 00:05:53.086 
基本的图形编程 最好是

00:05:54.288 --> 00:05:58.525 
知道可编程管线
熟悉着色器等

00:05:58.592 --> 00:06:01.895 
同时你想知道怎么能用Metal来

00:06:01.962 --> 00:06:03.964 
让你的程序和游戏变得更棒

00:06:04.164 --> 00:06:07.000 
我假设大家都是这样

00:06:07.067 --> 00:06:08.468 
这也是你们为啥在此 对吧

00:06:09.970 --> 00:06:11.705 
我先过一遍议题

00:06:12.039 --> 00:06:14.241 
我们会先大体介绍下

00:06:14.308 --> 00:06:16.476 
Metal的理念

00:06:16.543 --> 00:06:18.312 
和为何Metal会是现在的样子

00:06:18.378 --> 00:06:20.147 
接着我们会详细的

00:06:20.214 --> 00:06:22.049 
介绍创建一个Metal实例

00:06:22.482 --> 00:06:24.218 
接下来会介绍加载数据

00:06:24.551 --> 00:06:26.687 
到内存来供GPU使用

00:06:26.753 --> 00:06:29.389 
我们会简要介绍下Metal着色语言

00:06:29.456 --> 00:06:32.326 
我们会介绍创建预验证管线状态

00:06:33.026 --> 00:06:36.096 
和GPU调用 包括绘制调用

00:06:36.830 --> 00:06:39.132 
我们会用一个讨论结束

00:06:39.199 --> 00:06:42.970 
如何在Metal中处理
动画和纹理贴图

00:06:43.737 --> 00:06:45.672 
第二部分我们会介绍的更深一些

00:06:45.739 --> 00:06:47.508 
刚才我已经提到了

00:06:47.574 --> 00:06:49.009 
现在我们开始

00:06:49.543 --> 00:06:51.345 
从理念概览开始

00:06:51.411 --> 00:06:53.981 
只有几点需要强调

00:06:55.415 --> 00:06:57.851 
使用和硬件驱动相匹配的API

00:06:58.652 --> 00:07:00.654 
尽量明确一些

00:07:01.021 --> 00:07:03.790 
尽量不做耗时操作

00:07:04.658 --> 00:07:07.160 
先说说使用和硬件驱动相匹配的API

00:07:08.295 --> 00:07:10.230 
Metal是一个完全现代化的API

00:07:10.430 --> 00:07:13.967 
也可以说它使用了最新的硬件特性

00:07:15.269 --> 00:07:18.338 
和硬件的工作流程息息相关

00:07:18.805 --> 00:07:22.476 
作为一个全新的API
它非常轻量级

00:07:22.543 --> 00:07:25.679 
并且没有历史包袱

00:07:26.446 --> 00:07:29.616 
对的开销的操作没有花哨的技巧

00:07:29.816 --> 00:07:33.120 
它和Metal契合

00:07:33.187 --> 00:07:34.755 
并且都是在最基础的层级操作

00:07:34.821 --> 00:07:37.191 
幸运的是 它是统一的

00:07:37.591 --> 00:07:39.226 
在我们的所有平台上

00:07:41.328 --> 00:07:42.930 
当我们说我们更倾向明确的操作

00:07:42.996 --> 00:07:45.866 
意思是我们想让你

00:07:45.933 --> 00:07:49.770 
负责操作GPU

00:07:49.837 --> 00:07:51.805 
而不是让其默认的操作

00:07:52.105 --> 00:07:54.508 
同时还包括数据的管理和同步

00:07:55.342 --> 00:07:57.578 
这让你有更多的责任

00:07:57.644 --> 00:08:00.480 
同时能有更好的性能

00:08:02.082 --> 00:08:04.284 
再来解释下

00:08:04.351 --> 00:08:06.453 
不要经常做耗费大的工作

00:08:07.754 --> 00:08:12.626 
有三个地方

00:08:12.759 --> 00:08:14.194 
程序创建时

00:08:14.695 --> 00:08:16.496 
程序加载时

00:08:16.630 --> 00:08:18.165 
加载资源的时候

00:08:18.465 --> 00:08:21.869 
然后就是绘制时 每秒会调用60次

00:08:23.537 --> 00:08:25.672 
如果是历史API 如OpenGL

00:08:25.973 --> 00:08:27.074 
你大部分时间会花在

00:08:27.140 --> 00:08:29.810 
状态检查上
每次调用绘制的时候

00:08:30.143 --> 00:08:33.246 
最坏的时候你需要在运行时重新编译

00:08:33.746 --> 00:08:36.683 
这些都会给GPU的必要工作上

00:08:37.484 --> 00:08:40.254 
添加负担 在调用绘制函数的时候

00:08:41.688 --> 00:08:44.525 
在Metal中我们把这些工作提前

00:08:44.958 --> 00:08:46.693 
像我开始说的

00:08:47.094 --> 00:08:48.896 
着色器的编译可以在

00:08:48.962 --> 00:08:50.931 
程序编译的时候同时进行

00:08:52.366 --> 00:08:54.701 
同时 我们也允许你验证状态

00:08:54.768 --> 00:08:57.538 
在调用绘制的时候提前验证

00:08:57.838 --> 00:09:01.208 
这样就不用在每次
调用绘制的时候验证了

00:09:01.642 --> 00:09:04.545 
这样你需要做的唯一工作

00:09:04.611 --> 00:09:07.581 
就是只有绘制调用了

00:09:10.083 --> 00:09:11.485 
通过这些理念介绍

00:09:11.552 --> 00:09:13.487 
我们看看实际情况中的

00:09:13.554 --> 00:09:14.888 
Metal设备

00:09:16.123 --> 00:09:17.724 
这里有个类MTL设备

00:09:18.425 --> 00:09:21.061 
它表示抽象的GPU

00:09:21.528 --> 00:09:24.865 
它是你Metal应用中的最基本对象

00:09:25.265 --> 00:09:27.301 
你将会用它来创建

00:09:27.367 --> 00:09:30.904 
像指令队列 资源和管线状态对象

00:09:30.971 --> 00:09:33.006 
和其他你需要用的对象

00:09:35.709 --> 00:09:37.845 
创建Metal设备很简单

00:09:37.911 --> 00:09:41.114 
只需调用
MTLCreateSystemDefaultDevice

00:09:41.715 --> 00:09:43.951 
现在设备代表对象

00:09:44.017 --> 00:09:46.553 
你需要在程序开始时创建一个

00:09:46.720 --> 00:09:50.557 
并保持引用
因为会在整个程序的生命周期使用

00:09:51.391 --> 00:09:52.759 
就这么简单

00:09:53.927 --> 00:09:56.129 
现在说说怎么把数据

00:09:56.430 --> 00:09:58.265 
放到GPU可以读取的位置

00:09:58.565 --> 00:10:00.267 
然后你可以触发绘制调用

00:10:00.968 --> 00:10:04.037 
在Metal中
我们把数据存到缓冲中

00:10:04.338 --> 00:10:07.808 
缓冲就是一块内存用来存数据

00:10:07.875 --> 00:10:09.309 
你可以用任何格式

00:10:10.043 --> 00:10:14.348 
可能是顶点数据 索引数据 常量

00:10:15.449 --> 00:10:17.084 
你把数据写到缓存中

00:10:17.150 --> 00:10:18.752 
随后在

00:10:19.052 --> 00:10:20.988 
顶点和片段函数中访问

00:10:22.222 --> 00:10:23.957 
我们看看大体是个什么样子

00:10:24.024 --> 00:10:26.059 
这里有个包含几个缓存的例子

00:10:26.360 --> 00:10:28.795 
你加载数据的时候可能会创建

00:10:28.862 --> 00:10:31.565 
我们有个vertexBuffer
包含一些顶点数据

00:10:31.665 --> 00:10:34.434 
一个indexBuffer
包含一些连续的索引

00:10:35.702 --> 00:10:37.171 
更具体写来说

00:10:37.671 --> 00:10:42.042 
每个顶点类型的实例
可能是一个Swift结构

00:10:42.376 --> 00:10:44.845 
用向量表示顶点的位置

00:10:45.579 --> 00:10:47.548 
同样还有点的颜色

00:10:47.848 --> 00:10:50.050 
你可以让它们在内存你连续保存

00:10:51.285 --> 00:10:53.387 
说下如何创建缓存

00:10:55.088 --> 00:10:58.292 
这个API在你已经创建的设备里

00:10:58.692 --> 00:11:00.894 
简单调用newBufferWithLength

00:11:00.961 --> 00:11:02.729 
来获得一个指定大小的缓存

00:11:02.996 --> 00:11:04.998 
里面默认没有数据

00:11:05.432 --> 00:11:07.734 
或调用newBufferWithBytes

00:11:07.801 --> 00:11:10.237 
传一个已经在内存中有数据的指针

00:11:10.637 --> 00:11:12.339 
Metal会把数据拷贝

00:11:12.573 --> 00:11:14.308 
到新创建的缓存

00:11:14.441 --> 00:11:16.109 
你可以马上使用

00:11:17.244 --> 00:11:20.781 
你也可以用memcpy
把内容指针拷贝到缓存里

00:11:23.717 --> 00:11:26.587 
既然我们要展示一个2D的三角

00:11:26.720 --> 00:11:27.988 
作为我们第一部分的展示

00:11:28.589 --> 00:11:31.825 
我们先说下三角的几何坐标

00:11:33.126 --> 00:11:35.162 
既然我们想让顶点着色器

00:11:35.229 --> 00:11:37.164 
和片段着色器尽可能的简单

00:11:37.731 --> 00:11:40.901 
我们在裁减的空间里提供坐标

00:11:41.668 --> 00:11:44.705 
Metal的裁剪空间很有趣

00:11:44.771 --> 00:11:47.674 
它和其他类似的API有些不同

00:11:47.741 --> 00:11:49.343 
有点像DirectX裁剪空间

00:11:49.776 --> 00:11:53.013 
X从负1到1 Y轴从负1到1

00:11:53.080 --> 00:11:55.883 
Z轴从0到1

00:11:56.617 --> 00:11:59.753 
这个是我们要用的坐标空间

00:11:59.953 --> 00:12:01.855 
代码中是这样的

00:12:02.723 --> 00:12:04.992 
我们创建了个Swift的顶点数组

00:12:05.292 --> 00:12:07.127 
我们依次添加顶点

00:12:07.194 --> 00:12:09.196 
同时包括位置和颜色值

00:12:12.766 --> 00:12:15.302 
现在 我们不用严格的使用索引绘制

00:12:15.402 --> 00:12:18.438 
在这个简单的用例中

00:12:18.672 --> 00:12:22.609 
接着创建一个indexBuffer
并向其中添加0 1 2

00:12:22.876 --> 00:12:24.978 
代表三角形的第一个 第二个

00:12:25.045 --> 00:12:27.047 
和第三个点

00:12:27.114 --> 00:12:29.449 
然后用我们的设备创建接个缓存

00:12:29.550 --> 00:12:32.019 
我们会用newBuffer(withBytes
创建vertexBuffer

00:12:32.085 --> 00:12:34.721 
把顶点数据加载到Metal缓存中

00:12:35.122 --> 00:12:37.024 
我们再调用一次newBuffer(withBytes

00:12:37.090 --> 00:12:40.360 
把索引数据穿进去
得到indexBuffer

00:12:42.229 --> 00:12:44.398 
现在我们有了数据和内存

00:12:44.531 --> 00:12:47.634 
下面说说统一着色语言

00:12:48.202 --> 00:12:51.972 
Metal的着色语言是
C++ 14的扩展子集

00:12:52.339 --> 00:12:54.908 
他是图形和计算的统一语言

00:12:55.275 --> 00:12:56.810 
代表你还可以做很多事

00:12:56.877 --> 00:12:58.645 
不仅是3D图形

00:12:58.979 --> 00:13:01.481 
它可以让你写程序给GPU

00:13:02.816 --> 00:13:06.153 
这里有个管线各个阶段的图表

00:13:06.253 --> 00:13:08.689 
现在我们是在顶点

00:13:08.755 --> 00:13:10.524 
和片段处理阶段

00:13:10.591 --> 00:13:13.393 
每个阶段都有相应的函数要写

00:13:13.627 --> 00:13:16.930 
要么是处理顶点要么是片段

00:13:16.997 --> 00:13:18.632 
将会刷到屏幕上

00:13:19.266 --> 00:13:21.335 
语法上 它看起来像这样

00:13:21.902 --> 00:13:25.672 
我们不会详细介绍

00:13:25.739 --> 00:13:30.244 
希望你们注意这些函数修饰符：
顶点和片段

00:13:30.544 --> 00:13:33.280 
你会注意到右面函数的前面

00:13:33.347 --> 00:13:36.083 
不像普通的C++程序

00:13:36.183 --> 00:13:38.418 
我们相用这些修饰符来表示

00:13:38.552 --> 00:13:40.854 
这些函数和哪个阶段相关

00:13:41.321 --> 00:13:42.856 
我们有一个顶点函数在上面

00:13:42.923 --> 00:13:44.591 
和一个片段函数在下面

00:13:46.026 --> 00:13:48.795 
我将简单展示怎么实际把这些

00:13:49.429 --> 00:13:51.865 
和你的管线结合在绘制的时候

00:13:52.266 --> 00:13:55.035 
我们还会看看这些函数的内部实现

00:13:55.269 --> 00:13:58.105 
在以后的2D和3D展示中

00:13:59.006 --> 00:14:01.074 
我提过好几次Metal可以

00:14:01.141 --> 00:14:03.644 
直接把着色器编译到程序包里

00:14:03.710 --> 00:14:07.915 
方法是即使你有一个.Metal文件

00:14:08.282 --> 00:14:11.318 
在你的工程中的编译源码层

00:14:11.385 --> 00:14:13.720 
Metal会自动生成

00:14:13.787 --> 00:14:16.390 
一个Metal库文件
default.Metallib

00:14:16.657 --> 00:14:17.958 
同时会拷贝到你的包中

00:14:18.158 --> 00:14:19.860 
在你的程序编译的时候

00:14:19.927 --> 00:14:21.562 
除此之外不会再编译

00:14:22.763 --> 00:14:24.831 
所以它会在你程序包中

00:14:25.732 --> 00:14:27.301 
这是
default.Metallib

00:14:28.502 --> 00:14:29.436 
简单说

00:14:31.438 --> 00:14:33.273 
你可在运行时编译Metal着色器

00:14:33.540 --> 00:14:36.176 
如果你程序里有一个.Metal文件

00:14:36.243 --> 00:14:37.845 
它会被Xcode用
Metal工具链编译

00:14:38.111 --> 00:14:41.248 
生成一个default.Metallib
打到你的应用包中

00:14:42.115 --> 00:14:44.051 
这里很自然会有个问题

00:14:44.117 --> 00:14:47.955 
运行时怎么使用这些函数

00:14:48.021 --> 00:14:49.389 
答案是你会用一个叫做

00:14:49.456 --> 00:14:51.058 
Metal Library的类

00:14:51.124 --> 00:14:52.693 
Metal Library
是一个集合

00:14:52.759 --> 00:14:55.596 
编译器编译的函数对象

00:14:55.996 --> 00:14:57.598 
有几种方法创建

00:14:57.664 --> 00:14:59.466 
你可以通过我们讨论的流程

00:14:59.800 --> 00:15:02.503 
创建一个
default.Metallib

00:15:02.569 --> 00:15:04.872 
到你的应用包
然后在运行时加载

00:15:04.938 --> 00:15:09.576 
你还可以用我们的命令行工具链
编译一个.metallibs

00:15:10.344 --> 00:15:13.347 
运行时你还可以用代码串创建一个目录

00:15:13.413 --> 00:15:16.750 
例如 通过字符串来编译一个渲染器

00:15:18.085 --> 00:15:19.853 
在代码里看起来像这样

00:15:20.020 --> 00:15:22.022 
为了加载
default.Metallib

00:15:22.089 --> 00:15:24.491 
调用
newDefaultLibrary

00:15:24.992 --> 00:15:26.627 
用你已经创建的Metal设备

00:15:27.361 --> 00:15:30.297 
还有其他的API加载 例如

00:15:30.364 --> 00:15:32.799 
从编译好的.Metallib
或者从源代码

00:15:32.866 --> 00:15:35.002 
你可以详细查看文档
来了解这些API

00:15:37.671 --> 00:15:40.107 
现你已有Metal Library

00:15:40.207 --> 00:15:42.876 
能从中得到什么
可以得到Metal函数

00:15:42.943 --> 00:15:46.380 
现在Metal函数是一个简单对象
代表一个函数

00:15:46.880 --> 00:15:49.183 
它和一个特定的管线阶段关联

00:15:49.249 --> 00:15:50.884 
记得我们刚才看过的图么

00:15:50.951 --> 00:15:52.519 
顶点或片段阶段

00:15:52.853 --> 00:15:55.856 
我们还有一个额外的
描述符叫“kernel”

00:15:55.923 --> 00:15:58.825 
表示并行处理数据的函数

00:16:01.795 --> 00:16:04.498 
这里有段代码 你可以看到

00:16:04.565 --> 00:16:07.768 
函数名是
vertex transform

00:16:08.001 --> 00:16:11.405 
fragmentFunction名是fragment lighting

00:16:11.738 --> 00:16:14.641 
我重改下以便我能给你展示API

00:16:14.708 --> 00:16:16.743 
如何在你的库中加载函数

00:16:16.810 --> 00:16:17.945 
像这样

00:16:18.011 --> 00:16:19.780 
我们先调用
NewFunctionWithName

00:16:19.847 --> 00:16:22.249 
传一个代表函数名的字符串

00:16:22.616 --> 00:16:26.520 
获得一个Metal函数 引用它

00:16:27.588 --> 00:16:30.457 
稍后将展示实际中如何使用这些对象

00:16:30.724 --> 00:16:33.794 
但也只是简要介绍Metal着色语言

00:16:34.695 --> 00:16:38.232 
让我们介绍下创建预验证的管线状态

00:16:40.701 --> 00:16:42.769 
但首先 我们先预热下

00:16:42.970 --> 00:16:45.439 
像OpenGL中的API

00:16:45.706 --> 00:16:48.008 
你经常需要设置许多状态

00:16:48.375 --> 00:16:50.043 
然后触发绘制调用

00:16:50.110 --> 00:16:53.280 
在这之间驱动负责验证

00:16:53.347 --> 00:16:56.250 
你设置的状态是有效的

00:16:56.650 --> 00:16:59.052 
然后 最坏的情况

00:16:59.219 --> 00:17:01.255 
你还得付出运行时
重新编译着色器的代价

00:17:01.922 --> 00:17:03.724 
我们想要避免这些

00:17:04.590 --> 00:17:07.261 
在Metal中 它看起来像这样

00:17:08.228 --> 00:17:10.564 
你设置一个预验证的管线状态对象

00:17:10.631 --> 00:17:12.933 
可能还有其他少数辅助状态

00:17:12.999 --> 00:17:14.468 
然后触发绘制调用

00:17:14.867 --> 00:17:17.604 
我们这里想要减少绘制调用的负担

00:17:17.671 --> 00:17:20.374 
把更多工作提前进行

00:17:21.375 --> 00:17:27.146 
这里有几个你可以在管线状态对象中
设置的样例状态

00:17:27.214 --> 00:17:30.384 
这些状态绘制时你可以在任何时间设置

00:17:30.617 --> 00:17:32.085 
你看到左面这栏

00:17:32.152 --> 00:17:33.987 
你可能设置的管线状态

00:17:34.054 --> 00:17:37.157 
有顶点和片段函数用来绘制的

00:17:37.391 --> 00:17:40.127 
还有透明渲染状态

00:17:42.162 --> 00:17:44.364 
右面 我们看到的状态是

00:17:44.431 --> 00:17:46.700 
你可以在触发绘制函数前设置

00:17:46.767 --> 00:17:49.603 
包括front face winding
和cull mode

00:17:50.971 --> 00:17:53.173 
来讲一下如何创建对象

00:17:53.240 --> 00:17:55.242 
包括这些预验证的状态

00:17:56.276 --> 00:17:59.179 
主要对象是
Metal RenderPipelineState

00:17:59.880 --> 00:18:02.983 
它代表一类GPU的管线配置

00:18:03.217 --> 00:18:06.820 
它包括你会在加载时创建的
一个预验证集合

00:18:08.055 --> 00:18:09.423 
像设备

00:18:09.489 --> 00:18:11.992 
RenderPipelineStates
是持久对象

00:18:12.059 --> 00:18:16.063 
你想让它在你的整个程序
生命周期都存在

00:18:16.597 --> 00:18:18.365 
如果你有很多不同的函数

00:18:18.432 --> 00:18:20.033 
你可以异步创建管线状态对象

00:18:20.100 --> 00:18:22.269 
在程序运行的时候

00:18:23.270 --> 00:18:25.372 
实际上在创建
RenderPipelineState时

00:18:25.439 --> 00:18:26.673 
我们不会直接创建

00:18:26.740 --> 00:18:29.443 
反而 我们会用一个叫做
Descriptor的对象

00:18:30.577 --> 00:18:34.014 
它打包了所有参数用来创建
RenderPipelineState

00:18:34.515 --> 00:18:37.551 
通常在Metal中
我们创建Descriptor对象

00:18:37.618 --> 00:18:40.354 
它会把所有不同的参数弄在一起

00:18:40.420 --> 00:18:42.623 
我们在创建其他对象时也会使用

00:18:42.689 --> 00:18:45.158 
对于RenderPipelineState对象

00:18:45.225 --> 00:18:47.227 
它被叫做渲染管线描述符

00:18:47.294 --> 00:18:50.230 
你会发现它包含指向顶点函数

00:18:50.297 --> 00:18:52.232 
和片段函数的指针
我早先曾介绍过

00:18:52.299 --> 00:18:55.202 
它还包含一个附件集合

00:18:55.569 --> 00:18:59.506 
附件是一些纹理我们会在

00:18:59.573 --> 00:19:01.341 
实际渲染中用到

00:19:01.708 --> 00:19:04.344 
现在在Metal中
所有的渲染都会被渲染到纹理中

00:19:04.678 --> 00:19:08.081 
但我们不需要提前指向
那些纹理的指针

00:19:08.348 --> 00:19:11.552 
我们只需要提供你要渲染的像素格式

00:19:11.618 --> 00:19:15.255 
这样我们对它们的管线状态优化

00:19:15.689 --> 00:19:18.258 
若你使用了深度
或者Stencil Buffer

00:19:18.325 --> 00:19:21.361 
你也可以指定它们的像素格式

00:19:22.229 --> 00:19:24.831 
你一旦创建了一个管线描述符

00:19:25.199 --> 00:19:27.201 
你可以传递给你的Metal设备

00:19:27.267 --> 00:19:29.937 
然后得到一个
MTLRenderPipelineState对象

00:19:30.504 --> 00:19:32.039 
让我们在代码中看一下

00:19:32.673 --> 00:19:35.375 
这是一个RenderPipelineState
的最小化配置

00:19:35.442 --> 00:19:37.611 
你会发现我们设置了顶点函数

00:19:37.678 --> 00:19:39.780 
和片段函数属性给

00:19:39.847 --> 00:19:43.116 
我们先前从我们库中创建的
顶点和片段对象

00:19:44.284 --> 00:19:46.453 
同时我们也创建了

00:19:46.520 --> 00:19:49.857 
主要颜色附件的像素格式
为.bgra8Unorm

00:19:49.923 --> 00:19:53.560 
它是一个可显示和渲染的像素格式

00:19:55.429 --> 00:19:57.331 
这代表我们最终要

00:19:57.397 --> 00:19:59.666 
在绘制的时候绘制的纹理

00:20:00.367 --> 00:20:03.270 
最后 一旦我们创建了管线描述符

00:20:03.737 --> 00:20:06.540 
我们可以用设备新的
RenderPipelineState函数

00:20:06.607 --> 00:20:10.077 
来获得实际的预验证对象

00:20:11.945 --> 00:20:14.715 
我还行强调下PipelineStates
是持久的对象

00:20:14.781 --> 00:20:16.450 
你应该在加载时创建

00:20:16.517 --> 00:20:19.086 
在使用设备和资源的时候需要保持

00:20:19.186 --> 00:20:20.921 
你可以在绘制时在它们之间切换

00:20:20.988 --> 00:20:22.489 
来达到不同的效果

00:20:22.789 --> 00:20:26.693 
通常会有一对顶点和片段函数

00:20:28.862 --> 00:20:31.765 
现在我们已经讨论了
如何创建预验证的状态

00:20:32.132 --> 00:20:34.535 
和如何加载资源到内存中

00:20:34.601 --> 00:20:37.905 
接下来我们说下触发GPU指令
包括绘制调用

00:20:39.640 --> 00:20:41.341 
我们通过几个阶段介绍

00:20:41.408 --> 00:20:43.877 
我们还会讨论和
UIKit AppKit交互

00:20:44.378 --> 00:20:47.314 
稍微讨论下Metal指令提交模型

00:20:47.414 --> 00:20:49.950 
然后到渲染和绘制调用 最终

00:20:50.017 --> 00:20:52.052 
如何展现你的内容到屏幕上

00:20:53.153 --> 00:20:55.322 
就与UIKit和AppKit
交互而言

00:20:55.389 --> 00:20:59.092 
我们用MetalKit里的
一个工具MTKView

00:20:59.660 --> 00:21:02.729 
MTKView是一个跨平台的视图类

00:21:02.796 --> 00:21:05.265 
继承自Mac OS的NSView

00:21:05.799 --> 00:21:08.068 
iOS和tvOS中的UIView

00:21:09.269 --> 00:21:11.405 
它可以减少你要写的代码

00:21:11.471 --> 00:21:13.173 
为了让它在Metal中运行起来

00:21:13.473 --> 00:21:17.010 
例如 它会创建和管理一个
CA Metal Layer

00:21:17.077 --> 00:21:20.147 
是CALayer的一个特殊子类

00:21:20.214 --> 00:21:23.784 
可以和窗口服务或者显示循环交互

00:21:23.851 --> 00:21:25.352 
来让你的内容显示到屏幕上

00:21:25.419 --> 00:21:29.256 
通过CV或CA显示链

00:21:29.456 --> 00:21:31.892 
可管理绘制回调循环

00:21:31.992 --> 00:21:33.627 
通过循环触发回调

00:21:34.027 --> 00:21:35.729 
来完成你的绘制

00:21:35.796 --> 00:21:38.765 
同时它还可以管理要渲染的纹理

00:21:39.766 --> 00:21:41.835 
具体的方面我想强调

00:21:42.135 --> 00:21:45.439 
它可以做什么和那些绘图资源

00:21:46.306 --> 00:21:50.944 
在CA Metal Layer中
由MTKView管理

00:21:51.011 --> 00:21:52.913 
有一个可绘制资源集合

00:21:53.013 --> 00:21:54.848 
可绘制资源包含一个纹理

00:21:54.915 --> 00:21:56.717 
将要显示到屏幕上

00:21:57.084 --> 00:21:59.486 
这些在一个内部的队列中保存
会在帧间复用

00:21:59.553 --> 00:22:02.155 
因为它们相对来说要耗费资源

00:22:02.489 --> 00:22:05.058 
它们需要由系统管理

00:22:05.125 --> 00:22:07.661 
因为它们和东西

00:22:07.728 --> 00:22:09.663 
如何在屏幕上显示息息相关

00:22:09.730 --> 00:22:12.966 
我们替你管理并给你

00:22:13.033 --> 00:22:15.636 
包含纹理的可绘制对象
让你来绘制

00:22:16.470 --> 00:22:18.272 
这里有几个属性

00:22:18.338 --> 00:22:20.340 
你可以给MTKView设置

00:22:20.407 --> 00:22:24.044 
来定义如何管理纹理并往里面绘制

00:22:24.111 --> 00:22:26.914 
特别是 你还可以设置一个纯色

00:22:26.980 --> 00:22:29.483 
让主色更清楚

00:22:29.950 --> 00:22:32.753 
可以指定颜色像素格式

00:22:33.120 --> 00:22:36.123 
需要匹配你指定的

00:22:36.190 --> 00:22:37.791 
固定管线的状态对象的颜色格式

00:22:37.858 --> 00:22:41.161 
同时制定深度或模板颜色格式

00:22:41.562 --> 00:22:43.630 
最后一个属性可能是最重要的一个了

00:22:43.697 --> 00:22:45.699 
我们在这里设置代理

00:22:45.832 --> 00:22:49.603 
MTKView实际上不会做任何绘制

00:22:49.670 --> 00:22:51.071 
你可以将它归为一个子类别

00:22:51.205 --> 00:22:54.341 
或者你实现一个代理负责绘制

00:22:54.708 --> 00:22:56.577 
我们通过接下来的例子来介绍

00:22:56.844 --> 00:22:59.346 
我们看看你需要怎么做

00:22:59.413 --> 00:23:02.382 
才能实现一个MTKView代理

00:23:03.584 --> 00:23:06.119 
可归结需要实现两个方法

00:23:06.353 --> 00:23:09.423 
绘制大小变化和绘制

00:23:10.023 --> 00:23:13.126 
在绘制大小变化里你负责

00:23:13.193 --> 00:23:18.031 
响应如窗口大小发生变化
或者设备旋转

00:23:18.098 --> 00:23:20.667 
比如 如果你的投影矩阵依赖

00:23:20.734 --> 00:23:23.604 
窗口大小 那么它可以让你

00:23:23.670 --> 00:23:26.240 
响应来替代重建所有帧

00:23:27.140 --> 00:23:30.511 
绘制方法会固定的被调用

00:23:30.611 --> 00:23:33.514 
可以让你编码你想的执行指令

00:23:33.580 --> 00:23:36.116 
包括绘制调用

00:23:36.183 --> 00:23:39.920 
我们没有展示这个方法的
完整的内部内容

00:23:41.255 --> 00:23:44.324 
但是这是对指令提交的简单介绍

00:23:44.558 --> 00:23:48.529 
你要创建commandBuffer
做些事情 然后提交

00:23:48.829 --> 00:23:50.964 
稍后我们会做更多介绍

00:23:51.031 --> 00:23:55.068 
但是这是一种使用MTKView
的绘制功能的hook函数

00:23:55.903 --> 00:23:58.238 
我们推荐使用MTKView
尤其是在开始时

00:23:58.305 --> 00:24:00.507 
因为它已经为你做了不少其他的东西

00:24:01.408 --> 00:24:03.810 
我们说下Metal的指令提交模型

00:24:04.244 --> 00:24:06.079 
这里有张我们要做的图

00:24:06.146 --> 00:24:07.714 
在接下来几张幻灯片中

00:24:08.682 --> 00:24:12.052 
你不需要记住所有的东西

00:24:12.119 --> 00:24:14.188 
我们将要把这个图绘出来

00:24:14.288 --> 00:24:15.756 
这仅是个大体介绍

00:24:15.822 --> 00:24:19.359 
我们会创建这个对象

00:24:20.627 --> 00:24:24.464 
Metal的指令提交模型非常明确

00:24:24.698 --> 00:24:26.934 
表示你需要自己构造

00:24:27.000 --> 00:24:28.969 
和提交commandBuffers

00:24:29.336 --> 00:24:32.005 
可把commandBuffer当作

00:24:32.072 --> 00:24:34.007 
一个打包的工作交给GPU执行

00:24:34.208 --> 00:24:37.744 
不同于我们存数据的Metal缓存

00:24:38.078 --> 00:24:40.380 
指令缓冲存了GPU需要完成的工作

00:24:40.848 --> 00:24:43.817 
同时commandBuffer的
提交完全由你控制

00:24:43.884 --> 00:24:46.019 
就是当你构造了一个
commandBuffer

00:24:46.086 --> 00:24:49.289 
你负责告诉GPU何时执行

00:24:49.590 --> 00:24:51.258 
稍后会详细介绍

00:24:51.491 --> 00:24:53.594 
我们先说说指令编码器

00:24:53.660 --> 00:24:56.363 
把对象的API调用翻译成

00:24:56.763 --> 00:24:58.432 
GPU需要做的工作

00:24:58.498 --> 00:24:59.399 
你要明白这很重要

00:24:59.466 --> 00:25:02.603 
这些指令编码器不会有状态验证延时

00:25:02.669 --> 00:25:05.305 
所以所有预验证状态捆绑到

00:25:05.372 --> 00:25:07.140 
管线的状态对象里了

00:25:07.908 --> 00:25:10.878 
我们假设它是合法的
因为我们已经提前验证了

00:25:11.144 --> 00:25:13.981 
所以这里没有额外的工作要做

00:25:14.047 --> 00:25:17.117 
在你的编码器或驱动
调用渲染指令的时候

00:25:19.920 --> 00:25:22.856 
还有 Metal的指令提交模型
是多线程的

00:25:22.923 --> 00:25:26.326 
你可以并行的创建多个指令缓存

00:25:26.493 --> 00:25:28.896 
让应用决定执行顺序

00:25:29.162 --> 00:25:33.534 
这可以让你的每一帧的绘制
执行上万次调用

00:25:33.934 --> 00:25:36.370 
使用Metal 第二部分会深入探讨

00:25:36.470 --> 00:25:40.374 
但这里因为提到了所以说一下

00:25:41.775 --> 00:25:44.211 
让我们深入了解下这些对象

00:25:44.978 --> 00:25:47.548 
首先是指令队列

00:25:48.081 --> 00:25:50.317 
指令队列这里是说

00:25:50.384 --> 00:25:52.519 
一个叫做
MTLCommandQueue的类

00:25:52.586 --> 00:25:55.822 
它把设备需要执行的指令
都放在队列里执行

00:25:56.924 --> 00:25:59.493 
像设备和资源和管线状态

00:25:59.826 --> 00:26:02.796 
队列是一直存在的对象

00:26:02.963 --> 00:26:06.200 
在程序的整个生命周期会保持引用

00:26:06.266 --> 00:26:07.935 
通常你只需要创建一个

00:26:08.502 --> 00:26:12.072 
这样可以保证Metal API
是线程安全的

00:26:12.239 --> 00:26:16.310 
你可以创建指令缓冲渲染

00:26:16.376 --> 00:26:18.445 
并在多线程中使用它

00:26:18.745 --> 00:26:22.349 
队列可以让你创建和提交它们

00:26:22.583 --> 00:26:25.752 
并在自己不加锁的情况下
保证是线程安全的

00:26:27.354 --> 00:26:29.323 
创建一个指令队列很简单

00:26:29.790 --> 00:26:32.159 
用设备调用
newCommandQueue()

00:26:32.459 --> 00:26:34.328 
你将会得到一个Metal指令队列

00:26:36.463 --> 00:26:39.466 
当然只有你往里放入
指令的时候它才会工作

00:26:39.666 --> 00:26:41.101 
我们说一下

00:26:44.137 --> 00:26:45.405 
我已经提过指令缓冲了

00:26:45.472 --> 00:26:48.809 
指令缓冲是GPU要执行的打包的工作

00:26:48.876 --> 00:26:51.512 
在Metal中 它们用

00:26:51.578 --> 00:26:53.680 
一个叫做MTLCommandBuffer的类表示

00:26:54.014 --> 00:26:55.983 
MTLCommandBuffer
包含一系列指令

00:26:56.049 --> 00:26:59.920 
由GPU来执行 它们被放进

00:26:59.987 --> 00:27:02.322 
一个指令队列等待驱动来调度

00:27:02.789 --> 00:27:04.858 
根据我们目前讲的这些

00:27:04.925 --> 00:27:07.060 
它是临时对象

00:27:07.127 --> 00:27:09.630 
就是说每一帧你都要
创建一个或多个

00:27:10.230 --> 00:27:12.466 
然后往里给它编码指令

00:27:12.533 --> 00:27:15.135 
然后让让它们脱离GPU

00:27:15.202 --> 00:27:17.905 
你不会重用它们 不用引用它们

00:27:18.272 --> 00:27:19.640 
它们会自己消失

00:27:20.774 --> 00:27:22.376 
创建一个commandBuffer

00:27:22.442 --> 00:27:25.078 
调用commandQueue.commandBuffer()

00:27:28.182 --> 00:27:31.385 
我们已经说了缓冲和队列

00:27:31.451 --> 00:27:33.187 
我们讨论下如何把数据和指令

00:27:33.654 --> 00:27:36.089 
放到指令缓冲中

00:27:36.156 --> 00:27:38.825 
通过一个叫做指令编码器的类

00:27:39.026 --> 00:27:40.861 
这里有几种类型的指令编码器

00:27:40.961 --> 00:27:43.163 
包括渲染 位传输和计算

00:27:43.597 --> 00:27:45.766 
这些分别实现不同的功能

00:27:45.832 --> 00:27:49.002 
它们都差不多 都可以把你的

00:27:49.069 --> 00:27:51.638 
工作编码到指令缓存中

00:27:51.905 --> 00:27:55.576 
比如 一个渲染指令编码器

00:27:55.642 --> 00:27:57.644 
可以设置状态和执行绘制调用

00:27:57.911 --> 00:28:00.514 
一个计算指令编码器可以

00:28:00.848 --> 00:28:05.319 
把工作添加到队列中
并像数据一样并行计算 不像渲染工作

00:28:05.385 --> 00:28:07.955 
它像GP GPU或者类似的东西

00:28:08.655 --> 00:28:11.058 
位传输指令编码器用来

00:28:11.124 --> 00:28:13.927 
在缓存和纹理之间相互拷贝数据

00:28:16.330 --> 00:28:19.766 
这节课中我们会详细
看看渲染指令编码器

00:28:20.467 --> 00:28:24.605 
我刚才提到 它负责编码指令

00:28:24.671 --> 00:28:26.673 
每一个渲染指令编码器

00:28:27.040 --> 00:28:30.210 
单独编码每个工作

00:28:30.544 --> 00:28:32.579 
如果你触发状态变化

00:28:32.946 --> 00:28:35.916 
然后触发绘制

00:28:36.149 --> 00:28:39.887 
然后管理一个渲染附件集合 代表

00:28:39.953 --> 00:28:42.923 
将要绘制的纹理

00:28:43.924 --> 00:28:48.028 
概要来说 我们说的是最后这个阶段

00:28:48.095 --> 00:28:50.364 
你能看到我们有这些附件

00:28:50.430 --> 00:28:55.169 
被挂到管线的帧缓存合适的阶段

00:28:55.802 --> 00:28:58.972 
如果我们做多通道渲染

00:28:59.039 --> 00:29:02.643 
那么一个或多个渲染目标可能
会变为接下来的输入

00:29:02.709 --> 00:29:05.846 
这里只有一个通道 比较简单

00:29:06.780 --> 00:29:09.816 
附件表示纹理贴图

00:29:09.883 --> 00:29:13.320 
我们将要这个阶段的最后绘制

00:29:14.521 --> 00:29:17.157 
就是说 实际上创建一个
渲染指令编码器

00:29:17.224 --> 00:29:20.561 
使用另一种类型描述对象
一个RenderPassDescriptor

00:29:21.028 --> 00:29:24.031 
一个RenderPassDescriptor
包含一系列的附件

00:29:24.331 --> 00:29:28.602 
每一个都有加载存储操作 纯色和值

00:29:28.669 --> 00:29:31.205 
和将要被渲染的Metal纹理

00:29:31.939 --> 00:29:35.442 
我们用几页讲一下加载和存储操作

00:29:35.776 --> 00:29:37.945 
这里有很重要的一点需要明白

00:29:38.145 --> 00:29:41.815 
你需要构造一个
RenderPassDescriptor

00:29:42.115 --> 00:29:45.352 
在帧开始的时候并且把需要它

00:29:45.419 --> 00:29:47.454 
和将要绘制的纹理相关联

00:29:47.688 --> 00:29:53.527 
相比只需要知道像素格式
的renderPipelineState

00:29:53.694 --> 00:29:55.295 
这是最重要的部分

00:29:55.362 --> 00:29:58.799 
而你必须有我们将在
其中进行绘制的纹理

00:30:01.235 --> 00:30:03.637 
RenderPassDescriptor包含

00:30:03.704 --> 00:30:06.406 
渲染通道附件
每一个可能是一个颜色

00:30:06.473 --> 00:30:07.774 
深度或者模型目标

00:30:08.041 --> 00:30:09.943 
或者指向需要渲染的纹理

00:30:10.577 --> 00:30:13.380 
指定这些东西叫做加载和存储操作

00:30:13.680 --> 00:30:16.383 
我们更深入的说下是什么意思

00:30:16.950 --> 00:30:19.987 
开始的通道中你有颜色缓存

00:30:20.053 --> 00:30:23.590 
有深度缓存它们包含未知的内容

00:30:24.258 --> 00:30:27.995 
为了做些真正的工作
我们先清空它

00:30:28.295 --> 00:30:30.898 
我们通过设置和其相关的加载动作

00:30:31.231 --> 00:30:33.033 
在RenderPassDescriptor中

00:30:34.101 --> 00:30:37.638 
我们颜色和深度目标
设置一个清空加载动作

00:30:38.105 --> 00:30:40.807 
那它会把相应的颜色设置为清空色

00:30:40.874 --> 00:30:42.643 
或者值 根据实际情况

00:30:43.410 --> 00:30:44.711 
然后我们开始绘制

00:30:44.845 --> 00:30:46.113 
会把我们作用的结果

00:30:46.180 --> 00:30:48.048 
绘制到纹理上

00:30:48.582 --> 00:30:50.984 
然后存储操作会触发

00:30:51.251 --> 00:30:53.820 
存储操作包含两部分

00:30:54.188 --> 00:30:57.424 
存储操作的存储

00:30:57.491 --> 00:30:59.193 
渲染的结果应该被写会

00:30:59.259 --> 00:31:00.894 
内存并且存储

00:31:00.961 --> 00:31:03.263 
对于颜色缓存

00:31:03.330 --> 00:31:05.032 
我们尽可能的在屏幕上展现

00:31:05.199 --> 00:31:07.968 
对于深度缓存 我们只在

00:31:08.035 --> 00:31:11.438 
实际绘制和渲染时用到

00:31:11.638 --> 00:31:15.209 
所以我们在最后的通道中
不关心它的结果

00:31:15.409 --> 00:31:18.779 
我们可以设置一个存储动作为不关心
为了节省些带宽

00:31:19.112 --> 00:31:21.014 
这也是你可以做的优化

00:31:21.081 --> 00:31:23.450 
如果你并不需要

00:31:23.517 --> 00:31:25.152 
渲染的结果写会渲染对象

00:31:27.087 --> 00:31:29.556 
再深入说下加载和存储操作

00:31:29.623 --> 00:31:31.391 
它决定了纹理内容如何被处理

00:31:31.458 --> 00:31:32.960 
在开始和结束的时候

00:31:33.293 --> 00:31:36.597 
另外对清空操作

00:31:36.730 --> 00:31:39.366 
也有加载操作让你

00:31:39.433 --> 00:31:43.136 
加载纹理的像素内容

00:31:43.370 --> 00:31:44.972 
用之前的处理结果

00:31:45.072 --> 00:31:46.373 
它也不用关心

00:31:46.573 --> 00:31:49.843 
比如 你想从头到尾渲染一个目标

00:31:49.910 --> 00:31:53.180 
所有的像素 那么你不用关心

00:31:53.247 --> 00:31:56.583 
之前的纹理 你也不用清空它

00:31:57.017 --> 00:31:58.619 
因为你知道你将会设置

00:31:58.685 --> 00:32:00.954 
每一个像素为一些值

00:32:01.255 --> 00:32:02.823 
还一种你可以做的优化

00:32:02.890 --> 00:32:04.458 
如果你知道你会

00:32:04.525 --> 00:32:07.261 
在这个阶段处理每个像素

00:32:10.063 --> 00:32:13.534 
我会告诉你 如何创建
RenderPassDescriptor

00:32:13.734 --> 00:32:16.370 
然后创建一个渲染器指令编码器
幸运的是

00:32:16.603 --> 00:32:18.872 
MTKView使这些变得很简单

00:32:19.273 --> 00:32:21.708 
之前我们配置MTKView

00:32:21.942 --> 00:32:23.076 
用几个属性

00:32:23.143 --> 00:32:25.612 
我希望你们熟悉它
像清空色

00:32:25.679 --> 00:32:27.948 
还有渲染目标的纹理格式

00:32:28.248 --> 00:32:30.317 
实际上你可以通过请求视图得到

00:32:30.417 --> 00:32:32.319 
当前的RenderPassDescriptor

00:32:32.386 --> 00:32:35.122 
你会获得一个设置的
RenderPassDescriptor

00:32:35.422 --> 00:32:36.890 
接下来你就可以使用它

00:32:36.957 --> 00:32:39.960 
创建渲染指令编码器了

00:32:41.929 --> 00:32:44.364 
你该这么做 调用渲染指令编码器

00:32:44.431 --> 00:32:46.033 
在你的指令缓存上

00:32:46.099 --> 00:32:49.269 
你需要重点关注当前的
RenderPassDescriptor是

00:32:49.336 --> 00:32:50.804 
一个潜在的块调用

00:32:51.038 --> 00:32:53.540 
这样的原因是 实际上它会调用

00:32:53.607 --> 00:32:57.144 
CA Metal Layers的
下一个可绘制函数

00:32:57.444 --> 00:33:00.280 
我们不会详细介绍
但它是用来

00:33:00.347 --> 00:33:02.516 
获取包含纹理的可绘制对象

00:33:02.583 --> 00:33:04.184 
来展示到屏幕上

00:33:04.318 --> 00:33:06.620 
因为那是个有限的资源

00:33:06.854 --> 00:33:09.756 
如果当前没有可绘制的对象

00:33:09.823 --> 00:33:12.993 
如果他们所有的在运行
然后这个调用会阻塞

00:33:13.293 --> 00:33:14.995 
所以这里需要注意

00:33:16.597 --> 00:33:18.866 
我们已经说了加载资源到内存

00:33:18.932 --> 00:33:21.034 
我们说了创建预验证状态

00:33:21.101 --> 00:33:24.137 
和创建渲染通道

00:33:24.304 --> 00:33:25.739 
和渲染指令编码器

00:33:25.806 --> 00:33:28.141 
如何把数据弄到着色器中

00:33:29.376 --> 00:33:32.212 
第一我们需要说下参数表

00:33:33.146 --> 00:33:36.617 
参数表是Metal资源到

00:33:37.484 --> 00:33:38.819 
着色器参数的映射

00:33:39.152 --> 00:33:41.755 
你用的每一种资源

00:33:41.822 --> 00:33:43.323 
如缓存或者纹理

00:33:43.390 --> 00:33:45.459 
都有他们自己的缓存参数表

00:33:45.726 --> 00:33:46.994 
在右面你能看到

00:33:47.060 --> 00:33:49.396 
我们有缓存参数表

00:33:49.463 --> 00:33:52.466 
和纹理参数表
它们中每个都包含几个

00:33:52.533 --> 00:33:56.837 
缓存对应着参数表中的索引

00:33:57.671 --> 00:33:59.473 
给定参数表的插槽的可用数量

00:33:59.540 --> 00:34:02.743 
根据设备决定

00:34:02.843 --> 00:34:04.378 
你需要先查询

00:34:05.579 --> 00:34:07.481 
我们具体说下

00:34:07.548 --> 00:34:10.150 
在渲染指令编码器有个函数

00:34:10.217 --> 00:34:11.918 
叫setVerTextBuffer

00:34:12.252 --> 00:34:14.188 
它有三个参数

00:34:14.254 --> 00:34:17.257 
一个buffer 一个offset
一个index

00:34:17.491 --> 00:34:19.893 
最后一个是我们最关心的

00:34:19.960 --> 00:34:23.297 
因为它是我们的参数表索引

00:34:25.264 --> 00:34:29.735 
这是主机端设置资源

00:34:29.803 --> 00:34:31.638 
在使用着色器的时候

00:34:31.839 --> 00:34:34.608 
也有个对应的着色器端

00:34:34.875 --> 00:34:36.243 
像这样

00:34:36.443 --> 00:34:38.645 
在着色器语言中间

00:34:38.745 --> 00:34:41.882 
在你的着色文件中 你指定

00:34:42.248 --> 00:34:46.453 
每一个给定的参数
对应一个你要访问的资源

00:34:46.520 --> 00:34:50.123 
有个属性像这样

00:34:50.591 --> 00:34:52.993 
这是第一个缓存索引

00:34:53.060 --> 00:34:54.995 
索引0在参数表中

00:34:55.161 --> 00:34:59.533 
代表我们刚才在渲染指令编码器的缓存

00:35:02.069 --> 00:35:04.538 
我们详细看下

00:35:04.605 --> 00:35:06.974 
当在2D绘制中

00:35:10.744 --> 00:35:12.212 
我们创建了renderPipelineState

00:35:12.279 --> 00:35:14.815 
我们需要告诉渲染指令编码器

00:35:14.882 --> 00:35:17.584 
在绘制前需要用哪个管线状态

00:35:17.718 --> 00:35:18.986 
这个API就是干这个的

00:35:19.419 --> 00:35:21.288 
我们调用setRenderPipelineState

00:35:21.355 --> 00:35:23.790 
用刚才创建的
PipelineState对象

00:35:23.957 --> 00:35:27.194 
用我们创建的着色器配置

00:35:27.261 --> 00:35:30.364 
我们用先前创建的来绘制

00:35:31.164 --> 00:35:32.666 
现在RenderPipelineState

00:35:32.733 --> 00:35:36.170 
有相关的顶点和片段函数了

00:35:36.403 --> 00:35:38.639 
我们看看顶点和片段函数

00:35:38.705 --> 00:35:40.941 
我们在2D绘图中主要用这个

00:35:41.975 --> 00:35:44.311 
回到Metal着色语言
看起来像这样

00:35:44.645 --> 00:35:48.482 
大体上是一个直接的顶点函数

00:35:48.549 --> 00:35:51.018 
没有复杂的数学操作

00:35:51.084 --> 00:35:53.954 
它会复制所有的属性 直接连接

00:35:54.555 --> 00:35:59.860 
函数的第一个参数是一个顶点列表

00:35:59.927 --> 00:36:02.162 
我们刚才创建的缓存

00:36:02.629 --> 00:36:05.165 
第二个参数是属于

00:36:05.232 --> 00:36:08.202 
顶点ID的属性

00:36:08.268 --> 00:36:11.638 
表示正Metal在处理的定点的

00:36:11.705 --> 00:36:13.073 
索引

00:36:13.473 --> 00:36:15.342 
它比较重要的原因

00:36:15.409 --> 00:36:17.544 
vertexBuffer
包含所有的点

00:36:17.611 --> 00:36:19.046 
我们可以随机获得

00:36:19.479 --> 00:36:22.883 
实际上我们想在我们顶点函数

00:36:22.950 --> 00:36:24.985 
一次对一个点操作

00:36:25.052 --> 00:36:27.321 
这告诉我们正在操作哪一个

00:36:27.554 --> 00:36:30.691 
我们创建一个
VertexOut结构的实例

00:36:30.791 --> 00:36:34.294 
代表定顶点的各种属性

00:36:34.728 --> 00:36:36.964 
然后我们传给给光栅

00:36:37.097 --> 00:36:39.900 
我们创建一个实例 并设置位置

00:36:40.000 --> 00:36:44.371 
为向量位置vertexId的顶点

00:36:44.671 --> 00:36:46.039 
颜色也是类似

00:36:46.106 --> 00:36:48.909 
这里进传递了
vertexBuffer数据

00:36:49.243 --> 00:36:52.112 
给结构体供光栅来做插值

00:36:52.579 --> 00:36:55.816 
然后我们返回这个结构

00:36:57.384 --> 00:36:59.219 
让我们看看
fragmentFunction

00:36:59.286 --> 00:37:00.954 
它更简单

00:37:01.088 --> 00:37:05.759 
所以我们得到了插值结构

00:37:05.826 --> 00:37:07.761 
它表示

00:37:07.828 --> 00:37:10.464 
光栅化得来的数据

00:37:10.998 --> 00:37:12.466 
我们刚抽取了颜色

00:37:12.699 --> 00:37:15.702 
颜色来自结构

00:37:16.036 --> 00:37:17.304 
然后再传回去

00:37:17.604 --> 00:37:20.541 
这个过程中顶点发生了什么

00:37:20.607 --> 00:37:23.277 
在这个例子里截取空间指定的

00:37:23.710 --> 00:37:27.514 
被插值然后光栅化然后

00:37:27.581 --> 00:37:29.283 
被每个片段处理

00:37:29.349 --> 00:37:32.753 
我们返回由光栅创建的插值颜色

00:37:34.988 --> 00:37:37.558 
一旦我们指定RenderPipelineState

00:37:37.624 --> 00:37:39.693 
包含我们的顶点和片段函数

00:37:39.760 --> 00:37:42.930 
我们可以设置额外状态
就像我之前介绍的

00:37:42.996 --> 00:37:45.832 
包括front facing状态

00:37:46.066 --> 00:37:49.203 
如果你想指定不同的
front facing顺序

00:37:49.269 --> 00:37:52.005 
而不用Metal默认的

00:37:52.139 --> 00:37:53.240 
你可以在这里实现

00:37:54.808 --> 00:37:56.810 
这里有许多配置项
但我们只看

00:37:56.877 --> 00:37:58.478 
一些绘制调用

00:37:59.613 --> 00:38:00.547 
现在

00:38:00.647 --> 00:38:02.049 
Metal有很多函数

00:38:02.115 --> 00:38:05.152 
绘制几何图形包括indexed
instance和indirect

00:38:05.219 --> 00:38:07.287 
我们只看基本的索引绘制

00:38:07.654 --> 00:38:10.224 
这里我们想画一个三角形

00:38:10.757 --> 00:38:13.393 
我们调用drawIndexedPrimitives

00:38:13.760 --> 00:38:16.663 
我们指定原型为三角形

00:38:16.830 --> 00:38:18.365 
因为我们想画三角形

00:38:18.498 --> 00:38:21.201 
我们传递三个索引

00:38:21.268 --> 00:38:22.603 
来画一个三角形

00:38:23.203 --> 00:38:26.907 
我们同时需要制定索引的类型

00:38:26.974 --> 00:38:31.044 
我们之前声明了一个Swift
的数组集合

00:38:31.111 --> 00:38:32.746 
我们这里复制一下

00:38:32.813 --> 00:38:36.550 
我们还要把
indexBuffer传递下去

00:38:36.650 --> 00:38:38.285 
来表示哪些点应该绘制

00:38:38.385 --> 00:38:40.220 
我们把位移设置为0

00:38:40.621 --> 00:38:42.589 
这会画一个

00:38:42.656 --> 00:38:45.058 
三角形在屏幕上

00:38:46.693 --> 00:38:48.695 
我们可以添加些其他状态

00:38:48.762 --> 00:38:50.731 
触发一些其他绘制调用

00:38:50.797 --> 00:38:53.066 
但第一个演示我们就做这些

00:38:53.600 --> 00:38:55.402 
为了完成一个渲染过程

00:38:55.802 --> 00:38:59.606 
我们调用Render Command
Encoder的endEncoding

00:39:00.641 --> 00:39:03.977 
回顾一下
你需要创建一个请求

00:39:04.044 --> 00:39:06.680 
在开始时获得RenderPassDescriptor

00:39:07.614 --> 00:39:10.918 
用这个描述符创建
一个Render Command Encoder

00:39:11.752 --> 00:39:13.520 
设置RenderPipelineState

00:39:14.054 --> 00:39:15.589 
设置其他必要的状态

00:39:15.856 --> 00:39:18.559 
触发调用最后结束编码

00:39:19.359 --> 00:39:21.862 
这是我们看到的代码的一个概括

00:39:22.262 --> 00:39:23.263 
没有啥新东西

00:39:23.330 --> 00:39:26.099 
和刚才我说的一样

00:39:26.834 --> 00:39:31.738 
创建一个Render Command Encoder
设置状态 设置状态

00:39:33.006 --> 00:39:34.575 
绑定缓存 然后绘制

00:39:36.243 --> 00:39:38.212 
你已经渲染了这些内容

00:39:38.412 --> 00:39:40.147 
怎么样让它显示在屏幕上

00:39:40.214 --> 00:39:41.682 
非常简单

00:39:41.949 --> 00:39:44.585 
首先 渲染路径的颜色附件

00:39:44.651 --> 00:39:47.154 
通常是可绘制的纹理

00:39:47.287 --> 00:39:50.824 
你可从CA Metal Layer
或者MKTView获得

00:39:51.525 --> 00:39:54.862 
为了获得在实际上显示的纹理

00:39:55.662 --> 00:39:57.197 
你可调用commandBuffer
的present

00:39:57.264 --> 00:39:59.533 
并给它传递那个drawable

00:39:59.600 --> 00:40:01.535 
它将会显示到屏幕

00:40:01.602 --> 00:40:04.638 
一旦所有的处理路径完成

00:40:06.740 --> 00:40:08.642 
要向实际完成这一帧

00:40:08.709 --> 00:40:10.811 
由于我们把指令编码进
commandBuffer

00:40:10.878 --> 00:40:11.979 
我们要表明下我们完成了

00:40:12.045 --> 00:40:14.047 
通过调用commandBuffer.commit()

00:40:14.448 --> 00:40:16.483 
提交告诉驱动
commandBuffer

00:40:16.550 --> 00:40:18.085 
已经准备好给GPU运行了

00:40:19.853 --> 00:40:21.421 
总结一下

00:40:22.856 --> 00:40:24.391 
我们创建了一个指令队列开始

00:40:24.458 --> 00:40:27.861 
它是一个持久对象
我们需要引用它

00:40:28.462 --> 00:40:30.697 
每一帧我们创建一个
commandBuffer

00:40:30.764 --> 00:40:33.834 
使用渲染指令编码器编码
一个或多个渲染路径

00:40:34.935 --> 00:40:37.738 
通过提交commandBuffer
来在屏幕上显示

00:40:39.273 --> 00:40:41.508 
现在交给我同事Matt

00:40:41.575 --> 00:40:43.610 
带我们完成这个2D demo绘制

00:40:43.944 --> 00:40:45.012 
谢谢 Warren

00:40:53.120 --> 00:40:54.388 
这里是验证部分

00:40:54.454 --> 00:40:57.524 
一个2D的三角形
这是Metal三角形演示

00:40:57.591 --> 00:40:58.959 
从题目可以看出

00:40:59.459 --> 00:41:01.562 
非常简单 就是一个三角形
三种颜色

00:41:01.628 --> 00:41:03.931 
在边上被插值

00:41:05.165 --> 00:41:06.667 
我们看下代码

00:41:07.835 --> 00:41:11.171 
首先是MTKView的代理

00:41:11.538 --> 00:41:13.507 
Warren说我们需要实现个函数

00:41:13.607 --> 00:41:17.044 
这里是MTKView的drawable
和sizeable change

00:41:17.344 --> 00:41:19.112 
它将会在window变化时

00:41:19.179 --> 00:41:21.181 
响应

00:41:21.949 --> 00:41:24.318 
例子很简单我们不会实现它

00:41:24.384 --> 00:41:27.120 
你们在应用中自己实现

00:41:28.121 --> 00:41:29.890 
另一个是绘制

00:41:31.325 --> 00:41:33.327 
我们选择把它放到渲染函数

00:41:33.493 --> 00:41:34.928 
当我们的绘制被调用

00:41:35.929 --> 00:41:37.231 
我们进入渲染

00:41:39.333 --> 00:41:41.702 
渲染也很简单

00:41:43.270 --> 00:41:46.139 
当我们拿到MTKView的
当前RenderPassDescriptor

00:41:46.673 --> 00:41:48.642 
你把它弄出来 如Warren所说

00:41:48.876 --> 00:41:50.344 
然后你创建RenderPassDescriptor

00:41:50.410 --> 00:41:51.678 
然后用它编码

00:41:51.745 --> 00:41:53.380 
大家注意这里

00:41:53.447 --> 00:41:54.715 
“pushDebugGroup.”

00:41:55.015 --> 00:41:57.251 
这里你可以和Metal工具交互

00:41:57.351 --> 00:42:00.287 
当你做帧捕获

00:42:00.354 --> 00:42:02.623 
这里会列出调试组信息

00:42:02.689 --> 00:42:04.892 
这里 我们有一个绘制和
一个绘制三角形

00:42:06.760 --> 00:42:08.795 
绘制完我们会弹出调试组

00:42:08.862 --> 00:42:11.398 
所以绘制显示标签为
Draw Triangle

00:42:13.634 --> 00:42:15.169 
我们看下着色器

00:42:17.504 --> 00:42:18.939 
正如Warren说的

00:42:19.006 --> 00:42:21.041 
我们已经有了结构
有顶点结构

00:42:21.108 --> 00:42:23.143 
这是我们放入着色器的数据格式

00:42:23.210 --> 00:42:24.945 
只有位置和颜色

00:42:25.345 --> 00:42:26.947 
有vertex out结构

00:42:27.147 --> 00:42:29.249 
我们会传给光栅

00:42:29.316 --> 00:42:31.185 
你看到位置被

00:42:31.251 --> 00:42:32.786 
位置属性标记

00:42:32.920 --> 00:42:35.088 
这里代表截取空间位置

00:42:35.189 --> 00:42:37.758 
每个点着色器或点函数 抱歉

00:42:37.824 --> 00:42:39.059 
都需要有一个

00:42:40.327 --> 00:42:43.197 
看起来都很熟悉 都很简单

00:42:43.530 --> 00:42:45.632 
顶点进来 我们有个路径

00:42:46.266 --> 00:42:47.401 
同时你把它们写出去

00:42:47.568 --> 00:42:50.938 
在片段函数里我们拿到顶点

00:42:51.004 --> 00:42:54.474 
被光栅化后 我们读取颜色并且传下去

00:42:55.275 --> 00:42:56.910 
这个三角形演示很简单

00:42:56.977 --> 00:42:58.545 
下面由Warren继续

00:42:58.712 --> 00:42:59.913 
谢谢 Matt

00:43:03.817 --> 00:43:06.520 
我们已经展示了如何绘制2D内容

00:43:07.321 --> 00:43:10.090 
2D非常酷
什么更酷呢

00:43:12.025 --> 00:43:15.729 
3D 我么说说Metal中的
动画和纹理绘图

00:43:18.398 --> 00:43:19.933 
进入3D前

00:43:21.068 --> 00:43:22.936 
我们会经过几个阶段

00:43:23.003 --> 00:43:24.371 
我们讨论如何真正实现3D

00:43:24.905 --> 00:43:27.107 
我们用constant缓冲实现动画

00:43:27.174 --> 00:43:29.910 
我们还会介绍纹理绘图样例

00:43:30.611 --> 00:43:31.812 
为了进入3D

00:43:32.446 --> 00:43:34.948 
我们已经指定了我们的顶点在截图空间

00:43:35.015 --> 00:43:37.751 
我们现在需要在一个模型本地空间指定

00:43:38.185 --> 00:43:42.923 
然后用一个合适的模型视图做投影矩阵

00:43:43.190 --> 00:43:45.158 
为了回到截取空间

00:43:45.926 --> 00:43:48.929 
同时我们将给普通顶点添加属性

00:43:49.196 --> 00:43:51.665 
和纹理坐标 这样我们可以

00:43:51.732 --> 00:43:54.601 
在我们的fragmentFunction中
设置光照

00:43:54.735 --> 00:43:57.070 
和设置纹理映射

00:43:58.272 --> 00:44:00.641 
这里是我们扩展过的顶点

00:44:00.941 --> 00:44:05.012 
我们移去了颜色属性 添加进一个向量

00:44:05.345 --> 00:44:07.381 
和一组纹理坐标

00:44:08.549 --> 00:44:11.185 
和2D中的相似

00:44:11.585 --> 00:44:16.857 
我们会添加一个新的缓冲
存储所有需要的常量

00:44:17.224 --> 00:44:21.395 
引用我们的顶点和片段函数

00:44:21.828 --> 00:44:25.165 
用来合适的转换那些顶点

00:44:25.899 --> 00:44:27.167 
你会发现这个缓存的轮廓

00:44:27.234 --> 00:44:30.704 
是虚线 这是有原因的

00:44:31.805 --> 00:44:34.308 
因为我们不想创建另一个Metal缓存

00:44:34.775 --> 00:44:37.277 
仅仅是出于要管理这一小部分数据

00:44:37.344 --> 00:44:38.879 
只有几个矩阵

00:44:38.946 --> 00:44:41.648 
实际上Metal也有很棒的API

00:44:41.915 --> 00:44:45.452 
用来绑定和管理非常小缓存

00:44:47.387 --> 00:44:49.523 
所以 对于小数据

00:44:49.590 --> 00:44:51.258 
小于4K的

00:44:51.725 --> 00:44:54.261 
你可以用这些API设置顶点字节

00:44:54.628 --> 00:44:57.397 
直接把数据的指针传给他

00:44:57.731 --> 00:44:59.399 
当然需要告诉我们大小

00:44:59.900 --> 00:45:04.204 
Metal会创建和重用缓存

00:45:04.271 --> 00:45:05.472 
包含那些数据

00:45:06.039 --> 00:45:10.244 
你可以指定表的索引

00:45:10.911 --> 00:45:12.012 
这里设置为1

00:45:12.079 --> 00:45:14.781 
因为我们的顶点已经被
绑定在索引0

00:45:15.249 --> 00:45:18.018 
所以我们绑定在1
这样我能从其中读取

00:45:18.085 --> 00:45:20.087 
在我们的函数中

00:45:20.721 --> 00:45:24.458 
我们看看函数如何响应

00:45:25.158 --> 00:45:27.327 
开始之前 我们看一个例子

00:45:27.394 --> 00:45:29.997 
如何在应用中调用
setForTextBytes

00:45:30.664 --> 00:45:32.799 
我们创建了Constant结构

00:45:32.866 --> 00:45:34.034 
同时创建

00:45:34.101 --> 00:45:37.171 
包含两个矩阵相乘

00:45:37.237 --> 00:45:40.641 
通过模型视图投影和普通矩阵

00:45:40.707 --> 00:45:42.409 
这个矩阵会变换

00:45:42.476 --> 00:45:45.078 
本地空间为iSpace

00:45:45.546 --> 00:45:47.581 
我们用自己的矩阵工具构造

00:45:47.648 --> 00:45:50.284 
然后把它们相乘

00:45:50.450 --> 00:45:53.987 
最后用setVertexBytes
传递结构引用

00:45:54.054 --> 00:45:57.124 
然后Metal会拷贝

00:45:57.191 --> 00:46:00.194 
这个缓存用于绘制

00:46:00.327 --> 00:46:01.995 
在接下的绘制调用

00:46:03.830 --> 00:46:04.731 
现在

00:46:05.832 --> 00:46:09.803 
在去年的 WWDC
我们介绍了Model I/O框架

00:46:10.237 --> 00:46:13.574 
Model I/O包含许多工具

00:46:13.974 --> 00:46:16.043 
最棒的是Model I/O包含

00:46:16.109 --> 00:46:19.980 
可以让你生成常用图形的方法

00:46:20.581 --> 00:46:22.449 
由于MetalKit

00:46:22.516 --> 00:46:25.352 
和Metal集成非常紧密

00:46:25.419 --> 00:46:29.990 
你可以创建顶点数据Metal
可以直接渲染

00:46:30.991 --> 00:46:34.494 
我们可以不必手动指定所有顶点

00:46:34.561 --> 00:46:37.731 
我们可以这样
在一些内容创建包

00:46:38.065 --> 00:46:40.067 
里面绘制模型 导出

00:46:40.133 --> 00:46:41.368 
然后用Model I/O加载

00:46:41.435 --> 00:46:43.737 
或在这个例子中 用程序生成

00:46:44.938 --> 00:46:46.640 
我们看看代码

00:46:46.740 --> 00:46:49.843 
想生成些vertexBuffers
表示立方体

00:46:50.477 --> 00:46:53.547 
为了在Metal中
使用Model I/O

00:46:53.881 --> 00:46:56.450 
我会创建一个MeshBufferAllocator

00:46:57.384 --> 00:47:02.055 
MeshBufferAllocator作为
Model I/O和Metal间的胶水程序

00:47:02.923 --> 00:47:05.893 
传递一个设备给
MeshBufferAllocator

00:47:06.193 --> 00:47:09.263 
然后我们可以让Model I/O
直接创建Metal缓存

00:47:09.329 --> 00:47:10.898 
然后传回给我们

00:47:12.999 --> 00:47:16.136 
所以我们用工具方法创建了
MDLMesh

00:47:16.236 --> 00:47:20.174 
boxWithExtent等等
传进我们的分配器

00:47:20.240 --> 00:47:23.143 
这将会创建一个MDLMesh
一个Model I/O网

00:47:23.644 --> 00:47:26.346 
包含相关数据

00:47:26.780 --> 00:47:30.450 
我们然后用MetalKit的工具类
提取出来

00:47:31.051 --> 00:47:32.853 
就是为我们提供的

00:47:32.953 --> 00:47:34.154 
这看起来像这样

00:47:34.254 --> 00:47:36.523 
首先 我们生成了MTKMesh

00:47:36.590 --> 00:47:39.760 
包含我们刚才创建的MDLMesh
同时包含设备

00:47:42.162 --> 00:47:45.065 
为了得到vertexBuffer

00:47:45.132 --> 00:47:46.733 
把它放进mesh然后抽出来

00:47:47.267 --> 00:47:49.102 
对于indexBuffer
需要进行类似操作

00:47:49.670 --> 00:47:51.071 
这里还有几个参数

00:47:51.138 --> 00:47:52.139 
我们见过

00:47:52.206 --> 00:47:53.574 
绘制调用的时候用的

00:47:54.174 --> 00:47:56.910 
这里强调一下

00:47:57.077 --> 00:47:59.847 
用Model I/O
生成进程几何图形很容易

00:48:00.013 --> 00:48:03.717 
然后可以将缓冲提取出来
直接在Metal中应用

00:48:05.352 --> 00:48:07.287 
下面说说纹理

00:48:07.354 --> 00:48:08.455 
我们有了顶点数据

00:48:08.522 --> 00:48:11.792 
我们想用纹理映射上去 并添加些细节

00:48:11.992 --> 00:48:14.494 
像你知道的那样
纹理是一块内存

00:48:14.595 --> 00:48:16.830 
用特定的像素格式预先指定

00:48:16.997 --> 00:48:19.867 
主要用来存储图像数据

00:48:20.968 --> 00:48:24.671 
在Metal中 创建一个纹理

00:48:24.738 --> 00:48:25.973 
用描述符对象 很常见

00:48:26.240 --> 00:48:28.509 
特别是Metal纹理描述符

00:48:29.109 --> 00:48:31.245 
纹理描述符是参数对象

00:48:31.311 --> 00:48:34.381 
它把纹理属性弄在一起 比如高和宽

00:48:34.448 --> 00:48:37.918 
还有像素格式 设备会用

00:48:37.985 --> 00:48:41.588 
它们生成纹理对象：Metal纹理

00:48:42.155 --> 00:48:43.557 
我们看看

00:48:44.525 --> 00:48:46.059 
我们有这些方便的函数

00:48:46.126 --> 00:48:48.695 
在Metal Texture
Descriptor中

00:48:48.762 --> 00:48:51.398 
可以让你得到一个2D的描述符

00:48:51.932 --> 00:48:55.369 
仅提供必要的参数：高 宽

00:48:55.769 --> 00:48:58.605 
像素格式或者你是否想
mipmapped

00:49:00.641 --> 00:49:04.211 
你可调用设备的newTexture
创建一个新纹理

00:49:04.811 --> 00:49:07.714 
这是一个不包含实际图像的纹理

00:49:07.781 --> 00:49:11.218 
你需要使用替换区域或者相似的方法

00:49:11.618 --> 00:49:14.321 
你可以查查文档怎么做
这里我们用

00:49:14.388 --> 00:49:17.257 
另一个简单点的工具

00:49:17.591 --> 00:49:19.293 
叫做TKTextureLoader

00:49:19.359 --> 00:49:22.496 
这是MetalKit提供的工具
用来加载图像

00:49:22.563 --> 00:49:24.898 
从资源包中 包括资源目录

00:49:24.965 --> 00:49:27.768 
或者从一个文件URL 还有CG图像

00:49:27.835 --> 00:49:29.336 
内存中已经有了

00:49:29.403 --> 00:49:31.638 
以NSImage或UIImage
的形式

00:49:32.105 --> 00:49:34.541 
它们生成填充Metal纹理

00:49:34.608 --> 00:49:36.610 
用合适的大小和格式

00:49:36.677 --> 00:49:38.612 
与你已经有的的图像数据有关

00:49:39.513 --> 00:49:41.114 
我们看看代码

00:49:41.181 --> 00:49:43.684 
你可以创建一个
MTKTextureLoader

00:49:43.750 --> 00:49:45.252 
通过传入Metal设备

00:49:45.686 --> 00:49:47.354 
你会得到一个
TextureLoader

00:49:47.554 --> 00:49:50.958 
同时你可以接着或许一个数据集合

00:49:51.024 --> 00:49:52.559 
或你的集合目录中的其他东西

00:49:52.626 --> 00:49:54.127 
一旦你拿到了数据

00:49:54.194 --> 00:49:57.197 
你可调用textureLoader.newTexture

00:49:57.531 --> 00:50:00.434 
然后传递数据
那么将会返回一个Metal纹理

00:50:03.971 --> 00:50:07.508 
你可能熟悉取样的概念

00:50:07.574 --> 00:50:10.143 
Samplers和Metal
从纹理来说不同

00:50:10.210 --> 00:50:12.112 
他们没有绑定在一起

00:50:13.313 --> 00:50:16.550 
Samplers只包含
纹理相关的取样状态

00:50:16.617 --> 00:50:20.454 
一些如过滤模式 地址模式

00:50:20.521 --> 00:50:22.322 
还有层级详细的参数

00:50:22.489 --> 00:50:24.791 
这里展示的我们都支持

00:50:26.126 --> 00:50:28.996 
为了获得我们竟来要绑定
的Sampler状态

00:50:29.062 --> 00:50:31.765 
在Render Command
encoder中做纹理绘制

00:50:32.266 --> 00:50:34.668 
我们会创建一个
Metal Sampler Descriptor

00:50:34.735 --> 00:50:36.036 
像这样

00:50:36.436 --> 00:50:39.072 
我们创建了个空的Metal Sampler Descriptor

00:50:39.139 --> 00:50:40.707 
拥有默认的属性

00:50:40.774 --> 00:50:42.643 
我们可以设置想要的属性

00:50:42.709 --> 00:50:45.412 
这里我们让纹理在各个轴

00:50:45.479 --> 00:50:46.747 
上重复

00:50:47.314 --> 00:50:50.050 
当缩小的时候使用
nearest filtering

00:50:50.117 --> 00:50:52.219 
当放大时用
linear filtering

00:50:52.853 --> 00:50:54.988 
一旦我们创建了描述符对象

00:50:55.355 --> 00:50:56.523 
我们调用
newSamplerState

00:50:56.590 --> 00:50:59.193 
得到
Metal Sampler State对象

00:50:59.493 --> 00:51:03.630 
我们可以用来在纹理中绑定采样

00:51:04.765 --> 00:51:07.367 
在Render Command Encoder中
API看起来像这样

00:51:07.434 --> 00:51:11.338 
我们创建一个纹理 把它放在
插槽0

00:51:11.839 --> 00:51:13.774 
在片段纹理参数表中

00:51:14.808 --> 00:51:18.745 
然后我们绑定Sampler
State在索引0

00:51:18.912 --> 00:51:21.849 
在Sampler State
参数表中

00:51:23.750 --> 00:51:25.886 
我们看看这些函数

00:51:26.720 --> 00:51:29.122 
顶点函数这次会和

00:51:29.189 --> 00:51:32.893 
MVP矩阵相乘
矩阵从constant buffer中获得

00:51:33.360 --> 00:51:35.229 
它会变换顶点的位置

00:51:35.295 --> 00:51:37.197 
从本地空间到截取空间

00:51:37.497 --> 00:51:40.701 
我们会从顶点函数返回

00:51:40.767 --> 00:51:42.736 
同时它还会变换那些顶点

00:51:42.803 --> 00:51:44.505 
从Models Local
Space到Eye Space

00:51:44.571 --> 00:51:46.240 
然后我们做光照渲染

00:51:46.406 --> 00:51:47.975 
代码里看起来是这样

00:51:48.108 --> 00:51:51.612 
我们添加了一个参数属性通过缓存1

00:51:51.678 --> 00:51:54.815 
像我之前说的通过
constants缓存获得

00:51:54.882 --> 00:51:56.283 
我们已创建了一个结构类型

00:51:56.850 --> 00:51:58.752 
在我们的Metal着色代码中

00:51:58.819 --> 00:52:01.455 
和SWF代码中创建
constant结构关联起来

00:52:01.622 --> 00:52:04.958 
这样我们可得到
MVP通过普通的矩阵

00:52:05.192 --> 00:52:08.028 
再一次 这个绑定在索引1的参数表

00:52:08.328 --> 00:52:11.031 
和你看到的属性关联起来

00:52:12.199 --> 00:52:16.103 
为了进入截取空间

00:52:16.170 --> 00:52:18.605 
获取vertexBuffer
位于VertexID的索引

00:52:18.872 --> 00:52:20.107 
得到一个位置向量

00:52:20.207 --> 00:52:23.343 
和MVP矩阵相乘然后赋值给结构

00:52:23.944 --> 00:52:25.445 
对普通的 进行相同的操作

00:52:27.281 --> 00:52:29.283 
我们还拷贝纹理坐标

00:52:29.349 --> 00:52:31.051 
给传出结构

00:52:31.118 --> 00:52:33.954 
这些都会被光栅插值

00:52:34.021 --> 00:52:35.889 
我们接着进行返回结构

00:52:36.256 --> 00:52:39.359 
fragmentFunction
比之前更参与

00:52:39.760 --> 00:52:42.095 
我们想要计算些光照

00:52:42.162 --> 00:52:44.865 
我们引用两种环境光和漫反射

00:52:45.399 --> 00:52:48.001 
同时从纹理中采样

00:52:48.435 --> 00:52:50.838 
应用到表面纹理中

00:52:51.405 --> 00:52:52.439 
像这样

00:52:52.506 --> 00:52:55.142 
我们不会详细介绍

00:52:55.742 --> 00:52:57.244 
需要注意的是

00:52:57.311 --> 00:52:59.413 
我们添加了一个参数

00:52:59.479 --> 00:53:00.981 
我们创建和绑定的

00:53:01.181 --> 00:53:03.617 
我们给它一个访问标识符

00:53:03.717 --> 00:53:05.185 
我们用来采样

00:53:05.586 --> 00:53:07.788 
在Argument Table Index的0位置

00:53:07.855 --> 00:53:09.556 
我们创建的
Sampler State在

00:53:09.623 --> 00:53:13.827 
samplers的Argument
Slot Zero

00:53:13.894 --> 00:53:18.098 
想获得实际的文本

00:53:18.565 --> 00:53:20.601 
调用纹理的Sample

00:53:20.667 --> 00:53:24.004 
Text2D.Sample
有个采样状态

00:53:24.872 --> 00:53:28.442 
和纹理坐标给到颜色向量

00:53:30.344 --> 00:53:33.580 
我们接着做光照

00:53:33.647 --> 00:53:35.382 
我不会详细介绍

00:53:35.449 --> 00:53:39.119 
它根据正常和光照方向的积来得到

00:53:39.186 --> 00:53:41.922 
我们设置了一些常量

00:53:42.022 --> 00:53:45.559 
在我们之前的着色文件
演示中可以看到

00:53:46.126 --> 00:53:47.494 
这相当多

00:53:47.561 --> 00:53:52.165 
我们构造特定片段的颜色

00:53:52.366 --> 00:53:54.835 
通过乘以从纹理中采样的值

00:53:54.935 --> 00:54:00.340 
通过光照反映到动画纹理的立方体上

00:54:00.707 --> 00:54:03.510 
现在让Matt给大家展示下

00:54:05.379 --> 00:54:07.481 
好的 我们看看演示

00:54:07.881 --> 00:54:09.583 
这里有个Metal纹理网

00:54:09.683 --> 00:54:11.718 
你可以看到
它是个很复杂的立方体

00:54:11.952 --> 00:54:13.854 
一些简单的光照和纹理贴图

00:54:13.921 --> 00:54:15.923 
在一个设置好颜色的背景上

00:54:18.458 --> 00:54:19.860 
欣赏下它

00:54:19.927 --> 00:54:22.563 
我们看看着色器

00:54:23.297 --> 00:54:26.233 
比起上一次 你能看到一些新的东西

00:54:26.300 --> 00:54:28.869 
首先是Constants结构体

00:54:29.136 --> 00:54:30.704 
是Swift写的

00:54:30.771 --> 00:54:33.173 
有4 X 4的模型投影矩阵

00:54:33.473 --> 00:54:37.010 
和3 X 3的普通矩阵
它们是用来做变换的

00:54:37.744 --> 00:54:40.714 
如Warren所说
我们有些光照数据

00:54:41.215 --> 00:54:43.350 
环境光强度 这里很弱

00:54:43.417 --> 00:54:45.452 
但漫射光 却很高

00:54:45.519 --> 00:54:47.321 
光的方向

00:54:47.387 --> 00:54:49.256 
我们用来计算点积

00:54:51.158 --> 00:54:52.893 
输入和输出结构有点不同

00:54:52.960 --> 00:54:55.762 
我们现在有更多的信息需要向下传递

00:54:55.829 --> 00:54:56.697 
我们有position

00:54:56.763 --> 00:54:58.298 
有normal 用来光照

00:54:58.365 --> 00:55:01.368 
和纹理坐标 用来纹理贴图

00:55:01.435 --> 00:55:04.137 
相似的 当从顶点函数输出时

00:55:05.472 --> 00:55:06.640 
我们需要相似的数据

00:55:06.773 --> 00:55:08.575 
我们看下顶点函数

00:55:08.642 --> 00:55:09.476 
如Warren所说

00:55:10.010 --> 00:55:12.679 
就是些简单的矩阵 乘法运算

00:55:12.746 --> 00:55:15.315 
然后传给纹理坐标

00:55:16.083 --> 00:55:18.151 
快速的看下片段函数

00:55:18.218 --> 00:55:20.287 
就是刚才给你展示的

00:55:22.256 --> 00:55:24.291 
我们看看渲染器

00:55:26.326 --> 00:55:27.828 
接着往前

00:55:28.962 --> 00:55:30.097 
我们有个小动画

00:55:30.163 --> 00:55:33.867 
所以我们需要每段时间更新
我们需要知道立方体需要旋转多少

00:55:34.568 --> 00:55:36.069 
这里有个帮助函数

00:55:36.136 --> 00:55:38.305 
来更是时间间隔

00:55:41.308 --> 00:55:43.043 
这将修改Constants

00:55:43.777 --> 00:55:45.946 
像Warren说的
我们不想让很多数据通过GPU传递

00:55:46.013 --> 00:55:48.448 
所以当你设置顶点字节

00:55:48.849 --> 00:55:51.885 
传一个小的结构 之前的两个矩阵

00:55:52.519 --> 00:55:57.090 
我们用来计算变动的位置

00:55:58.325 --> 00:56:00.827 
放入纹理和采样 触发绘制

00:56:01.195 --> 00:56:02.763 
我建议你们记住

00:56:02.829 --> 00:56:04.631 
用你的调试组 这样你可以知道

00:56:04.865 --> 00:56:07.935 
现在在什么位置
如果你想稍后捕获帧的话

00:56:08.001 --> 00:56:11.104 
展示绘制内容 提交 然后就可以了

00:56:14.741 --> 00:56:15.909 
很棒 谢谢 Matt

00:56:19.847 --> 00:56:21.782 
通过这些使用Metal的课程

00:56:22.349 --> 00:56:25.586 
我们想充分利用我们这几年的

00:56:25.652 --> 00:56:27.087 
成果 教授Metal

00:56:27.454 --> 00:56:29.323 
同时介绍非常棒的新工具

00:56:29.590 --> 00:56:31.225 
让Metal更容易使用

00:56:31.325 --> 00:56:32.793 
我们希望

00:56:33.126 --> 00:56:35.395 
这两部分课程对此有帮助

00:56:35.696 --> 00:56:38.799 
你看到Metal是强大的低负载的

00:56:38.866 --> 00:56:42.369 
GPU编程技术 幸运的

00:56:42.436 --> 00:56:45.172 
你现在已经熟悉它

00:56:45.239 --> 00:56:46.707 
其中的一些API

00:56:48.242 --> 00:56:50.143 
Metal非常接近

00:56:50.210 --> 00:56:52.980 
和符合GPU的实际运转情况

00:56:53.347 --> 00:56:57.584 
概念上也是这样 我们想把

00:56:57.651 --> 00:57:00.654 
耗费资源的操作尽可能提前

00:57:00.754 --> 00:57:02.389 
你已经看到了几种方式

00:57:02.456 --> 00:57:04.892 
怎么安排这些API

00:57:05.325 --> 00:57:09.429 
这个课程不是强调一些限制和细节

00:57:09.496 --> 00:57:10.564 
主要是

00:57:10.631 --> 00:57:12.132 
想给你灌输些能力

00:57:12.533 --> 00:57:14.401 
你已经看到如何明确的
进行内存管理

00:57:14.468 --> 00:57:17.337 
和指令提交 可以让你的工作更智能些

00:57:17.404 --> 00:57:19.740 
如果你知道你的应用是怎么回事

00:57:19.806 --> 00:57:22.209 
你知道它在做什么 然后你可以

00:57:22.409 --> 00:57:25.479 
直接控制GPU

00:57:26.713 --> 00:57:30.117 
当然接下来的几节关于Metal课程

00:57:30.517 --> 00:57:33.420 
在今年的 WWDC
我们会给你展示更多

00:57:33.487 --> 00:57:34.821 
的Metal的内容

00:57:35.055 --> 00:57:38.492 
当然 它会让你创建有更好体验的应用

00:57:38.825 --> 00:57:41.328 
想要了解更多的关于602会话的信息

00:57:41.395 --> 00:57:44.998 
你可以访问这个URL
同时可以参考其他相关课程

00:57:45.332 --> 00:57:48.936 
第二部分还会在这个教室

00:57:49.736 --> 00:57:53.307 
明天我们会有
Metal的新东西Parts I和II

00:57:54.007 --> 00:57:57.377 
和高级Metal着色优化课程

00:57:57.711 --> 00:57:59.947 
谢谢
祝你们在 WWDC 中大有收获