00:00:19.419 --> 00:00:21.622
字体排版和字体

00:00:26.226 --> 00:00:27.060
早上好

00:00:28.395 --> 00:00:29.496
大家早上好

00:00:30.330 --> 00:00:31.999
我叫
Antonio Cavedoni

00:00:32.064 --> 00:00:34.868
我来到这里给大家讲讲字体排版和字体

00:00:34.935 --> 00:00:36.770
我是Apple的字体设计师

00:00:37.971 --> 00:00:41.375
所以在今天的日程上
将来看看San Francisco

00:00:41.808 --> 00:00:43.277
以及系统字体的升级

00:00:43.777 --> 00:00:45.913
我们会看到关于字体排版的一些术语

00:00:46.947 --> 00:00:48.982
我们会看看一些字体排版的概念

00:00:49.550 --> 00:00:52.419
以及在进行字体排版时
你可以使用的工具

00:00:53.220 --> 00:00:55.756
最后 我们会看看一些
你可能想要采用的细节

00:00:55.822 --> 00:00:57.291
当你在做应用的时候

00:00:59.426 --> 00:01:01.328
好了 San Francisco

00:01:01.929 --> 00:01:04.464
是我们系统字体的族类

00:01:04.697 --> 00:01:06.300
我们去年推出的

00:01:06.800 --> 00:01:09.369
你在这里看到的就是SF

00:01:09.436 --> 00:01:13.674
而且它是macOS
iOS和tvOS的系统字体

00:01:14.308 --> 00:01:18.378
我们在去年 WWDC 上
推出了这一族类

00:01:18.445 --> 00:01:23.050
这里有一个视频讲的
就是关于SF的理念和应用

00:01:24.985 --> 00:01:27.154
我们将SF应用到
我们的所有平台上

00:01:27.588 --> 00:01:32.259
有Apple TV 我们将San
Francisco应用到Mac

00:01:33.126 --> 00:01:36.230
不过我们还将它应用到
重新设计的音乐应用上

00:01:36.763 --> 00:01:40.767
若在Moscone Center里
你还没有看完所有字体

00:01:40.834 --> 00:01:45.639
SF族类确实新添加了
一位成员 叫做SF Mono

00:01:46.607 --> 00:01:52.646
SF Mono是一种用于编码的
新设计 而且有多种样式

00:01:52.713 --> 00:01:54.815
我们从细体开始

00:01:54.882 --> 00:01:56.350
升到正常

00:01:56.683 --> 00:01:57.518
中等

00:01:58.018 --> 00:01:59.219
半粗体

00:01:59.286 --> 00:02:02.723
然后我们有表现力更强
的样式 像是粗体和特粗

00:02:03.524 --> 00:02:06.927
所有这些都有斜体版本

00:02:08.529 --> 00:02:11.698
它们涵盖拉丁文
SL和拉丁字母

00:02:12.132 --> 00:02:15.469
不过还有西里尔字母
和希腊字母

00:02:15.536 --> 00:02:18.572
在所有样式和
所有带斜体的粗细中

00:02:19.206 --> 00:02:22.976
当然SF Mono是等宽设计

00:02:23.410 --> 00:02:26.547
而且在所有粗细中也是等宽的

00:02:28.348 --> 00:02:33.253
这意味着如果你改变字体粗细
文本是不会回流的

00:02:33.787 --> 00:02:34.855
当然 这有点困难

00:02:34.922 --> 00:02:36.423
当我们在设计
这个更粗的字体

00:02:36.490 --> 00:02:38.725
我们必须要将
所有这些字形挤压进来

00:02:39.560 --> 00:02:43.764
不过我们先设计出用于
编码的小号SF Mono

00:02:44.164 --> 00:02:45.899
我们微调了其中一些字形

00:02:45.966 --> 00:02:48.769
像是标点符号
或者括号 花括号

00:02:48.836 --> 00:02:52.439
一些用于编码的数字

00:02:53.507 --> 00:02:58.946
当然SF Mono是Swift
Playgrounds的新默认字体选择

00:02:59.713 --> 00:03:01.682
在Xcode中也是默认字体

00:03:02.149 --> 00:03:04.551
看看这个新的主题

00:03:05.953 --> 00:03:10.624
好了 我简短介绍了
San Francisco和新SF Mono族类

00:03:12.726 --> 00:03:15.896
接下来 我想给大家讲讲
一些关于字体的术语

00:03:15.963 --> 00:03:20.601
让我们在这些偶尔会
混淆的字体术语上达成一致

00:03:21.034 --> 00:03:23.103
在我开始之前
我想提前说一下

00:03:23.170 --> 00:03:27.608
这就是今天我们将看看
拉丁字母和希腊字母

00:03:28.108 --> 00:03:31.945
不过如果你对多语种字体排版
感兴趣 你也应该感兴趣

00:03:32.012 --> 00:03:35.782
昨天有两场演讲
你可以在视频上补看

00:03:36.049 --> 00:03:37.718
谈论的正是这个话题

00:03:38.619 --> 00:03:39.653
所以我们开始吧

00:03:40.454 --> 00:03:41.355
什么是文本？

00:03:42.556 --> 00:03:44.992
文本给语言编码
而且与含义有关

00:03:45.826 --> 00:03:48.262
文本就是打字的东西

00:03:48.662 --> 00:03:50.797
文本会得到
自动校正和分析

00:03:51.098 --> 00:03:52.399
并发送给你的朋友

00:03:53.300 --> 00:03:54.968
文本是由什么构成的？

00:03:55.235 --> 00:03:58.172
它是由字符构成

00:03:58.906 --> 00:04:05.646
字符是文本的抽象单位
可以说是由一个代码所代表

00:04:06.580 --> 00:04:11.285
在你看到这些字符之前
你需要有东西将它表达出来

00:04:11.351 --> 00:04:13.020
这叫做字形

00:04:13.687 --> 00:04:19.091
字形在你的设备上以轮廓
一连串的点而存储着

00:04:19.760 --> 00:04:21.995
并且存在于字体文件中

00:04:23.330 --> 00:04:26.466
在字体文件中
字符和字形之间

00:04:26.533 --> 00:04:27.935
通常是1对1的映射

00:04:28.001 --> 00:04:30.070
然而 事情并非
总是如此简单

00:04:30.671 --> 00:04:33.640
这里可能会出现叫做
字体排版功能的东西

00:04:33.707 --> 00:04:37.678
这一种机制会
改变这种1对1的映射

00:04:38.312 --> 00:04:41.315
并让事情变得更复杂一点

00:04:41.381 --> 00:04:43.417
例如 你可以有字体

00:04:43.483 --> 00:04:47.721
当你按下F或I的按键
这个字符就会生成

00:04:48.255 --> 00:04:50.924
你得到了一个字形
而并非两个

00:04:50.991 --> 00:04:53.727
因为它们组合到一起了
这叫做连字

00:04:54.094 --> 00:04:56.663
这个连字是通过
字体排版功能实现的

00:04:56.730 --> 00:04:58.832
这是自动的
并且取决于字体

00:04:58.932 --> 00:04:59.967
不是所有字体都这样

00:05:00.734 --> 00:05:04.404
一些字体有可选的功能
可以改变数字的形状

00:05:04.471 --> 00:05:08.842
例如San Francisco
有数字6的替换形状

00:05:09.243 --> 00:05:12.079
当我们想让它更加
易读时就会使用

00:05:13.881 --> 00:05:15.916
字体有多种样式

00:05:16.917 --> 00:05:18.252
当然 都看起来不同

00:05:18.318 --> 00:05:20.888
一些字体只有两种样式

00:05:21.188 --> 00:05:22.689
另一些字体则有非常多

00:05:22.756 --> 00:05:26.860
你可能听说过它们的名称
像是粗体 斜体 粗斜体 紧缩

00:05:26.927 --> 00:05:28.529
这些都是样式名称

00:05:29.029 --> 00:05:34.902
将它们维系在一起的是
这个名叫设计DNA的东西

00:05:35.202 --> 00:05:37.704
其想法就是一组形状

00:05:37.771 --> 00:05:38.972
那就是字型

00:05:40.340 --> 00:05:41.975
字型有很多种

00:05:42.042 --> 00:05:44.244
你可能见过或是认得这些

00:05:44.678 --> 00:05:48.215
你用字型做的事是字体排版

00:05:48.549 --> 00:05:53.820
字体排版是使用字型
来设置文本并给语言编码

00:05:54.354 --> 00:05:58.959
字体排版是图形设计
和UI设计的根基

00:06:00.527 --> 00:06:01.929
我们刚看了一些术语

00:06:01.995 --> 00:06:03.764
看过了文本

00:06:04.364 --> 00:06:05.699
文本是由字符构成

00:06:06.033 --> 00:06:08.836
字符是由字形所编码或表示

00:06:10.437 --> 00:06:11.905
在字符和字形之间

00:06:11.972 --> 00:06:16.510
是字体排版功能
这可以改变两者的映射

00:06:17.277 --> 00:06:19.580
它们存储于字体文件中

00:06:20.047 --> 00:06:22.683
这可以有常见的多种样式

00:06:24.051 --> 00:06:27.054
它们都归于同样的字型组群中

00:06:27.120 --> 00:06:29.556
这是所有这些样式背后的设计理念

00:06:30.057 --> 00:06:34.061
然后字体排版使用
所有这些东西来传递文本

00:06:35.696 --> 00:06:38.832
作家和编辑 那些书写文本的人

00:06:39.399 --> 00:06:41.368
他们的工作就是文本

00:06:42.836 --> 00:06:45.772
字符是由统一码联盟所定义的

00:06:45.839 --> 00:06:46.940
所以你不必考虑它们

00:06:48.208 --> 00:06:50.210
字体设计师和字体制造商

00:06:50.277 --> 00:06:54.281
是想出设计灵感的人群

00:06:54.348 --> 00:06:58.118
并设计字形 然后将其放入字体中

00:06:58.185 --> 00:07:02.890
之后创建字体排版功能供你进行更改

00:07:04.358 --> 00:07:08.095
字体排版者是那些进行字体排版的人

00:07:08.562 --> 00:07:12.332
我告诉大家一些好消息
那就是你们就是字体排版者

00:07:12.399 --> 00:07:14.268
事实上我们都是字体排版者

00:07:14.334 --> 00:07:16.603
无论我们什么时候更改字体 使其加粗

00:07:16.670 --> 00:07:18.005
我们改变磅值

00:07:18.071 --> 00:07:19.740
这都是字体排版的工作

00:07:20.707 --> 00:07:23.644
当然 作为字体排版者
你会给字体排版

00:07:24.311 --> 00:07:28.515
不过 当然你还可以
改变文本以及选取字体

00:07:28.582 --> 00:07:31.818
选择它们 组合样式
并改变字体排版的功能

00:07:31.885 --> 00:07:33.520
将可选的打开

00:07:35.956 --> 00:07:37.491
好了 我快说完了

00:07:37.558 --> 00:07:39.026
不过我还有几个术语

00:07:39.259 --> 00:07:41.094
它们实际上与某种东西的缺失有关

00:07:41.161 --> 00:07:44.164
内容周围的负空间

00:07:44.565 --> 00:07:46.366
我刚给你展示了什么是字形

00:07:46.433 --> 00:07:48.735
它是代表字符的轮廓

00:07:48.902 --> 00:07:51.271
而且在字体中 它作为轮廓存储着

00:07:51.338 --> 00:07:55.475
但它还有宽度 这基本上是间距属性

00:07:56.076 --> 00:08:01.415
如果我挑选出这样的间距
然后将它排版到字行上

00:08:01.481 --> 00:08:03.917
我会得到这样的节奏 这非常不均匀

00:08:03.984 --> 00:08:09.056
所以字体设计师会改变它
让字形之间的节奏变得平均

00:08:09.957 --> 00:08:12.926
间距是内置在字体中的
而且你无法去改变它

00:08:13.193 --> 00:08:14.928
不过 你可以改变字间距

00:08:15.429 --> 00:08:18.065
字间距可以对负间距进行调整

00:08:18.131 --> 00:08:19.766
它可以是零值

00:08:20.567 --> 00:08:21.668
或是负值

00:08:22.069 --> 00:08:23.070
或是正值

00:08:23.971 --> 00:08:26.874
这对字体中的所有字形通用

00:08:26.940 --> 00:08:29.877
要么将它们远离 要么让它们更近

00:08:29.943 --> 00:08:33.046
当你在进行小号字体排版时
这会非常有用

00:08:33.113 --> 00:08:35.148
你可能想将字母更加远离

00:08:35.215 --> 00:08:37.150
然后在大的时候靠在一起

00:08:38.085 --> 00:08:41.488
字间距可能会和字偶距相混淆

00:08:41.722 --> 00:08:45.526
字偶距就是一种用于
单个字形对的异常机制

00:08:45.592 --> 00:08:47.961
在这个案例中A和V太远了

00:08:48.028 --> 00:08:50.764
所以字体中的字偶距表格

00:08:50.831 --> 00:08:52.766
说将它们拉近一些

00:08:53.600 --> 00:08:57.137
字偶距表格也由有字体设计师
制作完成并放入字体内部

00:08:57.204 --> 00:08:59.606
而且你无法控制 这是自动发生的

00:09:00.507 --> 00:09:01.608
然而 行距

00:09:01.675 --> 00:09:05.312
行之间的间距 这是你可以控制的

00:09:06.647 --> 00:09:09.483
行距这个名称 源自与金属字体排印学

00:09:09.550 --> 00:09:13.554
将字行进一步分离开 抱歉

00:09:14.288 --> 00:09:17.057
你要在行之间插入金属片

00:09:18.292 --> 00:09:19.293
所以我们刚看了

00:09:20.360 --> 00:09:25.332
间距 字间距 字偶距和行距

00:09:26.033 --> 00:09:27.868
嵌入于字体中

00:09:27.935 --> 00:09:30.037
间距和字偶距是内置于字体中

00:09:30.737 --> 00:09:33.941
不过 字间距和行距是可以调整的

00:09:35.008 --> 00:09:37.110
在字体术语上 我就只说这些

00:09:37.177 --> 00:09:40.814
现在大家都清楚 这些字体排版术语了

00:09:41.715 --> 00:09:44.718
我们来看看一些字体排版的概念

00:09:46.420 --> 00:09:47.821
我们从易读性开始

00:09:48.322 --> 00:09:50.757
易读性指的是识别形状

00:09:51.124 --> 00:09:52.759
并将它们与彼此区分开

00:09:53.594 --> 00:09:55.095
你可能熟悉这个想法

00:09:55.162 --> 00:09:58.532
一些字型本身就易于阅读

00:10:00.033 --> 00:10:04.204
然而 在一种大小上难以看清的

00:10:04.271 --> 00:10:06.840
而在另一种大小上看得清清楚楚

00:10:08.041 --> 00:10:10.844
易读性与尺寸有关

00:10:12.279 --> 00:10:14.982
当你改变一段文本的尺寸

00:10:15.048 --> 00:10:18.919
之前看不见的细节就会显现出来

00:10:18.986 --> 00:10:21.188
所以受到影响的是所看内容的大小

00:10:22.356 --> 00:10:26.026
在这些情况下 UI字体排版

00:10:26.093 --> 00:10:29.496
会更像是路标

00:10:29.563 --> 00:10:30.697
你在马路上行驶

00:10:30.764 --> 00:10:34.801
你看到的标志很大 字体很大

00:10:35.068 --> 00:10:37.704
但离你很远

00:10:38.172 --> 00:10:40.307
尺寸不仅与磅值有关

00:10:40.374 --> 00:10:44.511
还与读者离阅读面的距离有关

00:10:45.946 --> 00:10:50.918
在这些情况下 在小尺寸字体
排版上应用的东西也是能适用的

00:10:50.984 --> 00:10:53.220
例如 将字母分离开

00:10:53.287 --> 00:10:56.089
或者让字体更粗可能会提高易读性

00:10:57.124 --> 00:10:59.293
但是易读性 不仅适用于文本

00:10:59.660 --> 00:11:01.395
它也适用于布局

00:11:03.197 --> 00:11:05.699
很明显的是 在一种尺寸上的布局

00:11:05.766 --> 00:11:10.237
层级清晰 易于阅读
而在另一种尺寸上会难以看清

00:11:10.604 --> 00:11:12.606
这里的问题是密集度会被破坏掉

00:11:12.673 --> 00:11:15.909
实际上增加了非常多

00:11:16.376 --> 00:11:17.911
所以解决密集度的方法是

00:11:17.978 --> 00:11:20.414
你可以将元素进一步分离

00:11:20.781 --> 00:11:22.382
不过常常更好的方法是

00:11:22.449 --> 00:11:26.286
重新考虑你的层级和
内容位置 你的布局

00:11:26.353 --> 00:11:28.689
用于不同尺寸

00:11:29.556 --> 00:11:32.426
如果你想知道更多关于布局的内容

00:11:32.492 --> 00:11:36.697
在周五有一场演讲
内容关于迭代UI设计

00:11:36.763 --> 00:11:38.599
那是获得想法的方法论

00:11:38.665 --> 00:11:41.301
而且他们还会有关于
如何评估那些想法的秘诀

00:11:41.368 --> 00:11:42.669
这是重要的部分

00:11:44.605 --> 00:11:50.377
尺寸和密集度也不是
只适用于文本和布局

00:11:50.444 --> 00:11:51.812
还可以是字形设计

00:11:52.145 --> 00:11:53.580
我们给大家一个例子

00:11:54.147 --> 00:11:55.048
这是什么字形？

00:11:55.315 --> 00:11:56.250
它叫什么？

00:11:56.950 --> 00:11:58.385
当然 这是at标志

00:11:58.852 --> 00:12:00.420
但在意大利 它的名字很奇怪

00:12:00.487 --> 00:12:03.056
我们叫它“chiocciola”
指的是蜗牛

00:12:03.891 --> 00:12:10.497
当我们在San Francisco中
抱歉 在SF Mono中设计这个蜗牛时

00:12:10.564 --> 00:12:12.032
我们从San Francisco
中的那个开始

00:12:12.099 --> 00:12:14.835
当然 我们是这样做的 让它变得等宽

00:12:15.269 --> 00:12:19.540
然而 当我们在合适的背景
和尺寸下验证这个形状时

00:12:19.606 --> 00:12:21.341
我们意识到密集度太高了

00:12:21.675 --> 00:12:24.144
变得模糊 很难看清

00:12:24.611 --> 00:12:27.447
所以我们想出了这样的解决方案

00:12:28.248 --> 00:12:29.349
我把它放大

00:12:30.584 --> 00:12:33.487
在这个例子中

00:12:33.554 --> 00:12:37.824
我们极大地改变了字形的密集度

00:12:38.225 --> 00:12:40.827
我们的做法是增加负空间

00:12:40.894 --> 00:12:42.963
这对易读性至关重要

00:12:44.298 --> 00:12:49.169
再考虑一下SF Mono
粗体中的H M和N字形

00:12:49.937 --> 00:12:53.540
如果我们把它们放得非常大

00:12:53.607 --> 00:12:57.110
你可能会看出笔画的厚度并不是相同的

00:12:57.377 --> 00:13:00.447
这是因为在它们大的时候能看出来

00:13:00.514 --> 00:13:01.648
但小的时候 你看不出

00:13:01.715 --> 00:13:05.118
所以我们稍微误导你
让你认为它们的密集度相同

00:13:06.320 --> 00:13:09.790
想象一下 你现进入到这个图片里了

00:13:10.290 --> 00:13:12.459
你要弄清身在何处以及你要去往哪里

00:13:13.193 --> 00:13:15.996
你可能要坐地铁去某个地方
可能是去教堂大道

00:13:16.063 --> 00:13:17.097
但你在哪里？

00:13:17.464 --> 00:13:18.365
我知道你在哪里

00:13:18.699 --> 00:13:21.101
你在纽约 我是通过字体得知的

00:13:21.802 --> 00:13:24.571
我还恰巧知道 我知道 不好意思

00:13:27.140 --> 00:13:29.409
我还恰巧知道他们使用的
不完全是Helvetica

00:13:29.476 --> 00:13:31.879
所以我用Helvetica Neue Bold
再现了那个标志

00:13:32.312 --> 00:13:35.849
不过我想表达的是
对于字体排版质感的认识

00:13:35.916 --> 00:13:40.654
如果你将字型变成另一种不同样式

00:13:40.721 --> 00:13:42.322
即使是同一族类之中

00:13:42.589 --> 00:13:45.325
不仅那个标志的效果会不同

00:13:45.526 --> 00:13:47.027
给人的感觉也会不同

00:13:47.194 --> 00:13:48.095
对吧

00:13:48.862 --> 00:13:52.132
所以字型有这种质感品质

00:13:52.199 --> 00:13:54.334
这个完全不像是纽约的感觉

00:13:54.968 --> 00:13:56.170
这个也不是

00:13:57.504 --> 00:14:02.276
这个质感属性不是次要的
实际上这有助于营造一种氛围

00:14:02.543 --> 00:14:06.580
例如 我在用SF字体阅读邮件
然后现在我在玩游戏

00:14:06.747 --> 00:14:08.949
可能在游戏不适合用SF字体

00:14:09.650 --> 00:14:12.819
字型真的能帮助你营造氛围

00:14:12.886 --> 00:14:15.222
并帮助你的用户清楚他们所在的位置

00:14:17.457 --> 00:14:19.126
好了 这是我们刚才看过的概念

00:14:19.193 --> 00:14:23.197
我们看了易读性 尺寸 密集度和质感

00:14:23.630 --> 00:14:26.166
现在我想给大家谈谈一些工具

00:14:32.339 --> 00:14:34.374
当我们在平台上进行字体排版时

00:14:34.842 --> 00:14:37.711
有三种基本工具供你使用

00:14:38.445 --> 00:14:40.247
第一个是系统字体

00:14:40.881 --> 00:14:42.482
第二个是动态类型

00:14:42.683 --> 00:14:45.219
然后第三个是我们的定制字体

00:14:46.620 --> 00:14:49.957
你看的那个系统字体是在平台上原生的

00:14:50.257 --> 00:14:52.793
而且作为字型 在平台上有原生的感觉

00:14:53.026 --> 00:14:56.830
获取系统字体API在

00:14:56.897 --> 00:15:01.268
iOS watchOS
tvOS和macOS之间都相同

00:15:01.668 --> 00:15:05.172
所以NSFont和UIFont
基本上有相同的API

00:15:05.772 --> 00:15:06.974
它们有很多的好处

00:15:07.040 --> 00:15:11.778
它们能让你获取全部9种
San Francisco的粗细

00:15:11.845 --> 00:15:13.814
还有特定大小的字间距

00:15:14.381 --> 00:15:19.253
基本上字母自动地靠近或者远离

00:15:19.319 --> 00:15:21.989
取决于你设定的系统字体磅值

00:15:22.623 --> 00:15:25.292
你还会自动得到特定大小的轮廓

00:15:26.226 --> 00:15:29.930
然后你会获得粗体字转换

00:15:29.997 --> 00:15:32.900
这是在iOS的设置中

00:15:33.333 --> 00:15:37.171
人们可以开启它 这让他们
所有设备上的文本都粗体显示

00:15:38.805 --> 00:15:42.776
第二个可用工具是动态类型

00:15:42.843 --> 00:15:43.677
这个工具极好

00:15:43.744 --> 00:15:45.479
在iOS和watchOS上提供

00:15:46.613 --> 00:15:48.382
动态类型就是指两件事

00:15:48.749 --> 00:15:53.687
第一个是文本样式API
preferredFont (forTextStyle)

00:15:54.321 --> 00:15:57.057
这会让你获得语义标识符

00:15:57.124 --> 00:16:00.160
会给你特定用于那个用途的字体

00:16:00.227 --> 00:16:03.664
你可请求用于大标题或正文等等的字体

00:16:03.730 --> 00:16:05.499
你会得和系统字体相似的字体

00:16:05.566 --> 00:16:07.634
但它们是专门为那个用途而调整的

00:16:09.203 --> 00:16:11.672
不过动态类型也是内容大小类别

00:16:12.005 --> 00:16:15.609
它就是这个滑动器上你所熟悉的刻痕

00:16:15.976 --> 00:16:19.880
人们可进入到设置中将滑动器上下移动

00:16:19.947 --> 00:16:22.516
他们可以改变设备的全局磅值

00:16:22.583 --> 00:16:23.984
这是一项非常棒的无障碍功能

00:16:27.955 --> 00:16:31.091
如果你使用动态类型
还使用文本样式API

00:16:31.358 --> 00:16:33.760
这上面的动态类型支持是自动的

00:16:34.094 --> 00:16:39.533
然而 如果你使用定制字体
或者直接调用系统字体

00:16:39.600 --> 00:16:42.336
那你必须要做一些工作来应用动态类型

00:16:42.402 --> 00:16:45.005
不过这很简单 我给大家展示如何去做

00:16:46.240 --> 00:16:48.075
首先你要选取或捆绑一种字体

00:16:48.942 --> 00:16:52.513
之后你可以有一个查找表
上面有内容大小类别

00:16:53.213 --> 00:16:55.916
然后你必须要覆盖
traitCollectionDidChange

00:16:55.983 --> 00:16:58.785
这是UIView和UI的方法

00:16:59.019 --> 00:17:00.420
你控制子类

00:17:01.655 --> 00:17:03.624
之后你更新你的字体以及段落样式

00:17:04.391 --> 00:17:06.126
然后你重新布局 这就完成了

00:17:06.527 --> 00:17:08.561
所以我们稍微深入地看看这些步骤

00:17:09.029 --> 00:17:11.632
到底如何将字体捆绑到应用中？

00:17:12.098 --> 00:17:12.933
这很简单

00:17:12.999 --> 00:17:14.468
只需把它拖到Xcode中

00:17:14.535 --> 00:17:17.570
然后你在info.plist列表中
声明字体的名称

00:17:17.637 --> 00:17:18.972
上面专门的键

00:17:20.674 --> 00:17:22.943
对于内容大小类别

00:17:23.010 --> 00:17:27.247
当然 你要有一个查找表
将它们映射到磅值中

00:17:27.314 --> 00:17:29.583
可能是粗细 字间距值或甚至是行距中

00:17:29.650 --> 00:17:31.952
取决于你选择的字型

00:17:32.786 --> 00:17:35.422
我有一个查找表 像这个样

00:17:35.656 --> 00:17:39.993
我有工具池 磅值
样式名称 行距和字间距

00:17:40.294 --> 00:17:44.431
你在这里看到的符号是内容大小类别

00:17:44.498 --> 00:17:47.601
你会发现这实际上
比滑动器上的刻痕要更多

00:17:47.668 --> 00:17:51.471
因为这里面有五个无障碍类别

00:17:52.172 --> 00:17:54.508
人们可以在无障碍设置中打开

00:17:54.808 --> 00:17:58.078
所以当你使用查找表时
你也要记住这几点

00:18:00.113 --> 00:18:04.384
一旦你做好了 你就覆盖
traitCollectionDidChange方法

00:18:05.319 --> 00:18:07.654
在内部你可以做什么都行

00:18:07.721 --> 00:18:11.592
你可以写上基于视图和显示效果的代码

00:18:11.658 --> 00:18:13.560
能够调整字体并重新布局

00:18:14.928 --> 00:18:15.896
所以

00:18:16.630 --> 00:18:19.466
当你在那个方法内部

00:18:19.533 --> 00:18:22.769
你应该询问当前对象的特征集合

00:18:23.103 --> 00:18:25.372
并查询优选的内容大小类别

00:18:26.440 --> 00:18:29.776
然后将其作为查找表的键 这就完成了

00:18:31.178 --> 00:18:32.713
第五步是重新布局

00:18:32.779 --> 00:18:35.616
但如果你用自动布局
这就不会有第五步了

00:18:35.983 --> 00:18:37.818
如果你感兴趣了解自动布局

00:18:37.885 --> 00:18:41.622
明天和周五有关于这些专题的演讲

00:18:43.657 --> 00:18:47.561
好了 我们刚刚看了如何
将动态类型用于定制字体

00:18:48.028 --> 00:18:50.497
不过假如你想开始着手去做

00:18:50.564 --> 00:18:51.932
到底应该如何下手？

00:18:52.366 --> 00:18:56.436
如果你一开始尝试使用定制字体

00:18:57.704 --> 00:19:00.140
我推荐一次从一个字型开始

00:19:01.208 --> 00:19:02.876
这样的话会更简单

00:19:03.110 --> 00:19:06.246
但重要的是
一旦你用上了你所考虑的字型

00:19:06.313 --> 00:19:08.348
试着去理解其设计意图

00:19:08.415 --> 00:19:09.850
因为在使用上会有很大帮助

00:19:10.117 --> 00:19:11.552
字型是工具

00:19:11.718 --> 00:19:13.954
它们是由人们设计而成用于特定用途的

00:19:14.121 --> 00:19:15.455
理解其用途

00:19:15.522 --> 00:19:18.759
会极大帮助到字体使用者和字体排版者

00:19:21.195 --> 00:19:23.397
你还要考虑可以调整的设置 对吧

00:19:23.797 --> 00:19:27.801
你无法在应用环境中轻易更改字偶距

00:19:28.101 --> 00:19:29.536
如果字体调不了字偶距

00:19:29.603 --> 00:19:31.672
你可能要考虑其它选择了

00:19:31.738 --> 00:19:35.442
然而如果字体行距太紧
你是可以改变的

00:19:35.742 --> 00:19:36.577
不要担心

00:19:38.545 --> 00:19:43.917
好了 我们刚看了系统字体
动态类型和定制字体

00:19:45.018 --> 00:19:47.487
接下来我想展示一些小细节

00:19:48.188 --> 00:19:51.358
你可能会考虑在自己的应用中使用

00:19:52.960 --> 00:19:55.729
我想展示的第一个是箭头

00:19:56.797 --> 00:19:58.232
箭头很了不起

00:19:58.298 --> 00:20:01.235
它们可以用于指向内容

00:20:01.535 --> 00:20:03.537
不过 它们也能用在
complications上

00:20:03.604 --> 00:20:05.172
那里信息的密集度十分高

00:20:05.239 --> 00:20:07.975
然后你想得到更多一点的信息

00:20:08.208 --> 00:20:12.246
箭头在SF中 实际上是
作为字符保存在字体中

00:20:12.312 --> 00:20:14.381
你可以将它们复制粘贴到你的字符串中

00:20:14.448 --> 00:20:16.783
例如在Xcode中
然后它们就会出现

00:20:17.284 --> 00:20:19.620
不过 更重要的是因为它们在字体之内

00:20:19.953 --> 00:20:22.022
它们与系统字体的粗细相匹配

00:20:22.189 --> 00:20:26.226
如果人们改变粗体字转换或用动态类型

00:20:26.293 --> 00:20:28.028
箭头会相应地改变大小

00:20:30.264 --> 00:20:34.401
我想说的第二点是高易读性替换

00:20:34.735 --> 00:20:38.138
我讲了在字体排版功能中的替换

00:20:38.672 --> 00:20:42.509
我们在San Francisco中
有一个新替换 有助于这种情况

00:20:42.943 --> 00:20:44.077
如果你给字符串排版

00:20:44.578 --> 00:20:47.948
没足够的语境来分辨出这都是哪些字形

00:20:48.015 --> 00:20:51.718
人们可能要将其传到别处
或者在其他地方输入

00:20:51.785 --> 00:20:55.122
人们必须要能读它而且必须要完全分清

00:20:55.189 --> 00:20:56.356
都有哪些字形

00:20:56.723 --> 00:20:58.258
这里有新的统计集

00:20:58.325 --> 00:21:02.129
这会将这些字形改变
成完全无歧义的形状

00:21:02.196 --> 00:21:04.965
I有了衬线
0有了一撇

00:21:05.365 --> 00:21:09.903
L有一个小尾巴
然后6不那么容易和8混淆

00:21:10.137 --> 00:21:12.706
我们不推荐一直启用这些形状

00:21:12.773 --> 00:21:15.475
因为如你所见 这是非常巨大的改变

00:21:15.542 --> 00:21:18.979
而且极大扰乱了文本整体的质地和外观

00:21:19.179 --> 00:21:20.581
以及文本的感觉

00:21:20.881 --> 00:21:23.617
所以尽可能谨慎使用

00:21:24.418 --> 00:21:27.120
不过 这是启用它们的代码

00:21:27.187 --> 00:21:30.057
顺便一提 这个代码在
UIFont和NSFont效果一样

00:21:30.123 --> 00:21:31.191
是完全相同

00:21:31.859 --> 00:21:36.296
你从UIFont或别的东西开始
你从中衍生出一个字体描述符

00:21:36.530 --> 00:21:40.934
然后你修改它 给它添加功能

00:21:41.001 --> 00:21:42.903
然后从中衍生出另一个字体

00:21:45.572 --> 00:21:47.407
接下来 小型大写字母

00:21:48.942 --> 00:21:53.680
我肯定大家都熟悉大写字母和小写字母

00:21:53.747 --> 00:21:58.719
不过这个组中还有第三个成员
那就是小型大写字母

00:22:00.287 --> 00:22:02.856
小型大写字母是大写字母的缩小版

00:22:02.923 --> 00:22:04.358
与小写字母对齐

00:22:04.725 --> 00:22:07.361
当我说对齐时 我指的是几乎对齐

00:22:07.661 --> 00:22:09.596
它们实际上应该稍大一点

00:22:11.031 --> 00:22:12.199
什么时候用上它们？

00:22:12.599 --> 00:22:15.302
例如 当你给首字母缩略词排版时

00:22:16.336 --> 00:22:19.640
首字母缩略词或者
当你想创建精妙的信息层级

00:22:19.706 --> 00:22:20.774
例如有数字

00:22:20.841 --> 00:22:25.112
然后你想弱化
它边下的另一条信息

00:22:25.712 --> 00:22:29.883
让我展示一个案例研究 关于如何在
Apple TV上使用小型大写字母

00:22:30.751 --> 00:22:32.219
上面有这个段落

00:22:33.287 --> 00:22:35.956
还有层级 列表是在左边

00:22:36.023 --> 00:22:37.457
然后段落在右边

00:22:37.524 --> 00:22:41.495
你想让左上角的文本成为
标头 并且稍微突出一点

00:22:42.029 --> 00:22:44.064
如果你将它看成线框图

00:22:44.464 --> 00:22:46.400
你差不多可以看出

00:22:46.466 --> 00:22:50.470
那全是大写的字符串在高度上碾压四方

00:22:50.537 --> 00:22:52.105
看起来有点太大了

00:22:53.073 --> 00:22:55.309
你可以修正它的一种方法是

00:22:55.375 --> 00:22:58.545
你可以改变磅值将它降下来

00:22:58.612 --> 00:23:02.449
不过如果你那样做
这还会使字母变得更细更紧凑

00:23:02.516 --> 00:23:05.819
所以密集度会与其他的文本不相配

00:23:06.086 --> 00:23:08.021
你怎么办 小型大写字母

00:23:08.522 --> 00:23:11.391
小型大写会保留全大写的设置

00:23:11.758 --> 00:23:14.461
且还保留你想要的密集度以及笔画厚度

00:23:15.429 --> 00:23:18.332
这里有两种基本方式 两种API

00:23:18.398 --> 00:23:20.400
将小型大写字母带到系统中

00:23:21.101 --> 00:23:24.037
而且它们与字体排版功能

00:23:24.104 --> 00:23:28.675
和基本文本之间的互动有关

00:23:28.909 --> 00:23:31.845
所以假想你有一段都是大写的文本

00:23:32.379 --> 00:23:35.182
你启用大写中的小型大写字母功能

00:23:35.549 --> 00:23:37.684
你会得到一段都是小型大写字母的文本

00:23:38.118 --> 00:23:39.086
看起来很好

00:23:39.920 --> 00:23:44.258
如果你的字符串混有大小写字母

00:23:44.324 --> 00:23:48.061
然后你启用大写中的小型
大写字母功能 结果是这样

00:23:48.595 --> 00:23:50.130
这看起来很糟

00:23:50.564 --> 00:23:52.966
这个的问题是这里的大写字母

00:23:53.033 --> 00:23:56.436
没有在强调任何内容而且几乎像是错误

00:23:56.503 --> 00:23:58.238
所以请你尽量不要这样做

00:23:59.306 --> 00:24:02.242
如果你有一个全是小写字母的字符串

00:24:02.309 --> 00:24:04.811
然后你启用大写中的小型大写字母功能

00:24:04.878 --> 00:24:07.748
你得到的全都是小写
这不是你所预料的

00:24:07.814 --> 00:24:09.249
但起码看起来还行

00:24:09.483 --> 00:24:10.551
所以没问题

00:24:11.318 --> 00:24:13.554
这个大写中的小型大写字母功能

00:24:13.654 --> 00:24:16.990
这个代码与我之前
展示的特性码是完全一样的

00:24:17.057 --> 00:24:19.026
用于高易读性替换

00:24:19.526 --> 00:24:22.462
你只需要更改功能标识符和选择符

00:24:24.398 --> 00:24:26.800
这里有另一种启用小型大写字母的方法

00:24:26.867 --> 00:24:29.203
是从一段小写文本开始

00:24:29.269 --> 00:24:30.771
抱歉

00:24:31.705 --> 00:24:33.373
如果你有全部都是大写的字符串

00:24:33.440 --> 00:24:38.278
然后你从小写启用
小型大写字母 得到全是大写

00:24:38.612 --> 00:24:40.314
这不是你所预料的

00:24:40.380 --> 00:24:41.748
但起码看起来还行

00:24:42.583 --> 00:24:46.887
当你在混有大小写的字符串上
从小写启用小型大写字母

00:24:46.954 --> 00:24:48.222
你会得到这个

00:24:48.455 --> 00:24:51.892
你会得到混有大写和
小型大写的字符串 这是可以的

00:24:52.159 --> 00:24:54.795
我们的确在地图中使用 比如在

00:24:54.928 --> 00:24:56.163
某些缩放级别上

00:24:57.130 --> 00:24:58.465
小型大写的重点在于精妙

00:24:58.532 --> 00:25:01.401
而且这是一种创建精妙层级的方法实例

00:25:02.069 --> 00:25:03.470
所以没问题

00:25:04.438 --> 00:25:06.673
如果你的字符串都是小写的

00:25:06.740 --> 00:25:08.475
然后你从小写启用小型大写字母

00:25:08.542 --> 00:25:11.345
你得到的都是小型大写 这没问题的

00:25:12.412 --> 00:25:14.948
这个的代码是完全一样的

00:25:15.015 --> 00:25:17.317
我只改了那一段代码

00:25:18.519 --> 00:25:21.922
你可以用功能做的一件事是
你可以同时启用多个

00:25:22.122 --> 00:25:24.525
所以这取决于你获取那段文本的位置

00:25:24.591 --> 00:25:27.227
如果是你控制 如果用户可以编辑

00:25:27.294 --> 00:25:30.297
比如 你可能想要同时将它们启用

00:25:32.533 --> 00:25:34.568
关于小型大写字母有一个精妙之处

00:25:34.902 --> 00:25:36.637
这就是它们的重点就是精妙

00:25:36.703 --> 00:25:38.272
不过还有一点精妙之处

00:25:38.605 --> 00:25:44.211
这就是它们不仅适用于大写字母

00:25:44.378 --> 00:25:46.013
在数字和标点符号上也行

00:25:46.647 --> 00:25:48.282
你可能会想这是为什么

00:25:48.916 --> 00:25:51.451
原因是你可能会有像这样的字符串

00:25:51.518 --> 00:25:53.654
你想将它们全都变成小型大写

00:25:53.720 --> 00:25:56.089
所以我们支持小型大写数字
小型大写标点符号

00:25:56.156 --> 00:25:58.258
在所有这些在系统字体中

00:25:59.793 --> 00:26:03.964
好了 我们刚刚看了一些
字体排版的细节 例如箭头

00:26:04.131 --> 00:26:06.533
高易读性替换和小型大写字母

00:26:08.435 --> 00:26:10.270
我们今天要讲的就是这些

00:26:11.305 --> 00:26:13.540
我们刚才看了
San Francisco字体

00:26:13.607 --> 00:26:16.510
以及用于编码的
新SF Mono族类更新

00:26:16.577 --> 00:26:17.477
希望大家喜欢

00:26:18.412 --> 00:26:19.479
我们看了一些术语

00:26:19.947 --> 00:26:24.251
我们看了一些字体排版概念
设计方面的 没错 是设计理念

00:26:24.484 --> 00:26:25.552
然后我们看了些工具

00:26:26.253 --> 00:26:27.855
最后我们看了一些细节

00:26:27.921 --> 00:26:30.824
一些新的小功能
你可能会采用到你应用中

00:26:31.592 --> 00:26:36.263
欲了解更多信息 你可以在
这个URL上找到本次演讲的视频

00:26:36.330 --> 00:26:39.967
不过你还会找到一本
文献和一些可供参考的

00:26:40.033 --> 00:26:43.270
网站 让你以字体排版者的
身份踏上的新路程

00:26:44.571 --> 00:26:46.773
这里还有相关演讲

00:26:47.107 --> 00:26:50.310
这些还没有开始
整个周都有

00:26:51.044 --> 00:26:53.547
第一场演讲实际上是介绍一个工具

00:26:53.614 --> 00:26:55.249
这在动态类型上面给你极大帮助

00:26:55.349 --> 00:26:56.550
不过我就不剧透了

00:26:58.118 --> 00:27:00.854
其他两场演讲与打造适应性应用有关

00:27:00.921 --> 00:27:03.423
自动布局的话题

00:27:04.358 --> 00:27:07.528
迭代设计会给你一些设计元素

00:27:07.594 --> 00:27:09.730
以及相应评估方法

00:27:10.430 --> 00:27:13.200
然后 “自动布局的新特性”
的演讲是在周五

00:27:13.267 --> 00:27:14.134
也会非常精彩

00:27:14.868 --> 00:27:16.537
就是这些了 非常感谢大家