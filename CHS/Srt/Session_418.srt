00:00:19.386 --> 00:00:22.055
在Instruments中
使用时间分析器

00:00:22.122 --> 00:00:24.925
早点分析 经常分析

00:00:26.627 --> 00:00:27.794
下午好

00:00:28.762 --> 00:00:29.963
我叫Kris Markel

00:00:30.030 --> 00:00:32.198
我是Apple性能工具团队的工程师

00:00:32.266 --> 00:00:35.903
今天我们谈谈
在Instruments中使用时间分析器

00:00:36.803 --> 00:00:37.938
这是我们的议题

00:00:38.005 --> 00:00:40.507
我们要从分析开始讲

00:00:40.574 --> 00:00:41.875
分析是什么及如何使用它

00:00:41.942 --> 00:00:43.177
然后我要演示一个示例

00:00:43.243 --> 00:00:46.647
使应用的速度更快 工作量更少

00:00:46.713 --> 00:00:51.919
最后 确保应用有非常棒的用户响应

00:00:52.452 --> 00:00:55.822
在我们开始讲正题之前
让我们谈谈为什么要这样做

00:00:56.089 --> 00:01:01.261
原因就是我们想提供一种
优秀的用户体验

00:01:01.562 --> 00:01:04.598
我们想让用户喜欢用我们的应用

00:01:04.932 --> 00:01:08.435
我们想让他们喜欢用我们应用
是因为应用的速度很快

00:01:08.735 --> 00:01:09.803
速度像猎豹一样快

00:01:10.370 --> 00:01:12.606
可以节省他们的时间来做更多的事

00:01:13.173 --> 00:01:16.143
我们想确保用户的设备
一整天都有电

00:01:16.810 --> 00:01:19.513
这样他们一整天都能使用设备

00:01:19.580 --> 00:01:21.448
而你的应用一定不想成为那个

00:01:21.515 --> 00:01:23.750
在电量消耗表上排名第一的应用

00:01:24.551 --> 00:01:27.721
最后 我们想确保流畅的滚动

00:01:28.021 --> 00:01:33.026
在我们的应用中有迅速响应的UI
这样用户就会喜欢用它

00:01:33.794 --> 00:01:35.162
我们该如何实现呢？

00:01:35.229 --> 00:01:37.130
我们要用一种叫做分析的技术

00:01:37.664 --> 00:01:40.567
这种分析技术回答了
关于应用的两个问题

00:01:40.801 --> 00:01:42.236
做了多少工作？

00:01:42.603 --> 00:01:44.304
做了什么工作？

00:01:44.838 --> 00:01:46.907
若你尚未注意到标题

00:01:46.974 --> 00:01:50.310
我们要使用一种叫做
时间分析器的工具来实现

00:01:50.611 --> 00:01:53.113
时间分析器回答了另一个问题

00:01:53.347 --> 00:01:55.415
应用什么时候做那个工作？

00:01:56.617 --> 00:01:59.586
时间分析器是应用中
Instruments的一部分

00:01:59.786 --> 00:02:02.523
Instruments
是很多工具的集合

00:02:02.756 --> 00:02:05.759
这些工具都是用来
测定应用的各个方面的

00:02:06.660 --> 00:02:07.861
怎么用呢？

00:02:07.928 --> 00:02:09.029
嗯 非常简单

00:02:09.096 --> 00:02:12.533
从Xcode产品菜单中
选择Profile

00:02:13.333 --> 00:02:14.902
让我们现在来操作一下

00:02:16.270 --> 00:02:19.106
好的 首先 我要给你们
演示一下我的应用

00:02:19.473 --> 00:02:20.974
让你们了解它的功能

00:02:21.675 --> 00:02:24.945
我的应用使用了照片框架来查找

00:02:25.012 --> 00:02:27.714
用户的图库
检测是否有图片副本

00:02:28.515 --> 00:02:30.117
我现在要操作一下

00:02:30.484 --> 00:02:34.321
如果我的测试数据中有很多副本
就得等一会儿了

00:02:34.388 --> 00:02:36.256
那么 它给出了一个很大的数

00:02:36.423 --> 00:02:37.257
好的 完成了

00:02:37.925 --> 00:02:40.027
现在 我要选择一些照片

00:02:41.795 --> 00:02:44.298
找一张好点儿的图 这张吧

00:02:44.531 --> 00:02:47.134
然后应用就会使用核心图像
面部识别功能

00:02:47.201 --> 00:02:49.469
这样我可以给人脸上添加
一双金鱼眼

00:02:49.870 --> 00:02:52.873
然后应用就使用
CoreMotion中的力学UI

00:02:53.407 --> 00:02:56.577
当你摇动设备时
金鱼眼会跟着一起晃动

00:02:57.544 --> 00:03:00.113
好的 这就是应用

00:03:01.148 --> 00:03:03.350
让我们继续分析它正在做什么

00:03:04.117 --> 00:03:09.690
那么从Xcode产品菜单中
正如我刚说过的 选择Profile

00:03:10.524 --> 00:03:13.093
这将生成应用的一个发布版本

00:03:13.427 --> 00:03:17.297
然后开启Instruments
开始测定

00:03:17.865 --> 00:03:20.234
生成分析用的一个
发布版本很重要

00:03:20.300 --> 00:03:23.504
因为你希望能从编译器中
获得最优结果

00:03:24.905 --> 00:03:26.306
这得等会儿

00:03:26.573 --> 00:03:29.209
它正在把应用复制到设备上

00:03:33.981 --> 00:03:34.882
好了

00:03:35.816 --> 00:03:37.351
现在 Instruments开启了

00:03:37.551 --> 00:03:40.120
它会显示模板选择器

00:03:40.854 --> 00:03:45.492
你可以了解Instruments
都提供了哪些工具

00:03:45.926 --> 00:03:47.928
今天 当然了
我们要用时间分析器

00:03:48.095 --> 00:03:49.897
我要点击选择按钮

00:03:52.032 --> 00:03:54.501
若你从未用过Instruments

00:03:54.568 --> 00:03:56.803
这个用户界面看起来
可能有点儿吓人

00:03:57.137 --> 00:03:59.106
但是很容易上手

00:04:00.374 --> 00:04:04.444
我要做的就是点击
左上角的这个记录按钮

00:04:05.245 --> 00:04:08.215
开启应用 并开始测定

00:04:08.482 --> 00:04:10.017
让我们实际操作一下

00:04:10.884 --> 00:04:13.120
好的 那么现在 应用开启了

00:04:15.656 --> 00:04:17.491
正在启动 好了

00:04:17.891 --> 00:04:19.959
对吧？我要做副本检测

00:04:21.595 --> 00:04:22.462
等一下

00:04:25.065 --> 00:04:25.899
好的

00:04:26.233 --> 00:04:28.936
然后 我要做副本检测了

00:04:29.870 --> 00:04:31.438
让我们看看是否开始获得数据了

00:04:32.206 --> 00:04:33.273
好了

00:04:35.242 --> 00:04:36.243
好的 完成了

00:04:36.844 --> 00:04:38.579
现在 我要选择照片

00:04:40.747 --> 00:04:42.749
然后我要挑出一张照片

00:04:43.417 --> 00:04:44.918
添加一双金鱼眼

00:04:45.886 --> 00:04:47.287
摇动一下

00:04:48.055 --> 00:04:49.923
现在不管那张图了

00:04:51.258 --> 00:04:55.596
然后停止记录

00:04:55.863 --> 00:04:57.164
点击停止按钮

00:04:59.566 --> 00:05:01.068
现在我们可以看到

00:05:01.134 --> 00:05:06.406
有一个应用正在做什么的高级概览

00:05:06.807 --> 00:05:08.509
时间分析器给出了两张图表

00:05:08.575 --> 00:05:11.178
Instruments
的顶部是时间线视图

00:05:12.246 --> 00:05:14.715
第一张图表是CPU的使用情况

00:05:14.781 --> 00:05:16.450
就是应用使用了多少CPU

00:05:17.184 --> 00:05:19.887
我可以把鼠标悬停在图表上
查看精确数值

00:05:20.454 --> 00:05:25.993
第二张图表
是应用所处的生命周期

00:05:26.059 --> 00:05:28.061
以及所延续的时间

00:05:31.265 --> 00:05:35.736
这让我有了一个很好的概念
关于应用做了多少工作

00:05:36.003 --> 00:05:37.137
以及是什么时候做的

00:05:37.771 --> 00:05:40.340
但是 我如何了解应用
正在做什么呢？

00:05:40.874 --> 00:05:44.077
要了解该信息 我们要往下看
Instruments的调用树视图

00:05:44.244 --> 00:05:46.013
就是这个详细视图中的一部分

00:05:46.713 --> 00:05:51.151
调用树视图呈现了所收集的
通过比重合计的

00:05:51.218 --> 00:05:55.889
调用栈样本
并显示在详细视图中

00:05:56.523 --> 00:05:58.625
这是什么意思呢？

00:05:59.126 --> 00:06:03.797
嗯 以图形显示比文字说明
更显而易见

00:06:03.864 --> 00:06:05.599
让我们来看一个图表

00:06:06.500 --> 00:06:09.203
在这里 时间向右运动

00:06:09.269 --> 00:06:11.271
这是我们那个非常简单的应用

00:06:11.772 --> 00:06:14.308
我们有一个主方法
这是调用method1

00:06:14.641 --> 00:06:15.943
这是调用method2

00:06:16.643 --> 00:06:17.611
在这个时间点

00:06:17.678 --> 00:06:20.914
时间分析器要从应用中
获得一个调用栈

00:06:21.415 --> 00:06:22.449
看起来是这样的

00:06:23.016 --> 00:06:26.687
就跟你在Xcode中的调试器中
看到的调用栈是一样的

00:06:27.187 --> 00:06:30.858
但在Instruments或
时间分析器中 后续的每一行都会缩进

00:06:30.924 --> 00:06:33.994
正因为如此 才能创建一个树结构
我们一会儿就会看到了

00:06:34.962 --> 00:06:36.330
时间在继续

00:06:36.396 --> 00:06:38.465
哦 然后它记录了那个调用栈

00:06:38.765 --> 00:06:42.336
然后记录了
在那个调用栈内

00:06:42.402 --> 00:06:43.570
出现每个方法或函数的次数

00:06:44.671 --> 00:06:47.374
时间继续
我们可以看到method2结束了

00:06:47.441 --> 00:06:50.544
method1调用结束了的method3
然后又调用了method2

00:06:51.211 --> 00:06:53.480
然后我们继续 已经过了一毫秒

00:06:53.947 --> 00:06:56.049
时间分析器要取第二个样本

00:06:56.116 --> 00:06:58.785
在这个示例中 第二个样本看起来
跟第一个样本一样

00:06:58.852 --> 00:07:00.587
我们要继续 更新表

00:07:00.854 --> 00:07:03.056
只是为每个数增加了增量

00:07:04.124 --> 00:07:06.226
时间还在继续

00:07:06.293 --> 00:07:08.896
现在我们看到应用正在做不同的事

00:07:09.429 --> 00:07:12.733
主方法直接调用了method2
然后调用了method3

00:07:13.367 --> 00:07:16.069
时间分析器就在这儿
取了另一个样本

00:07:16.136 --> 00:07:18.038
现在 我们看到了一个
不同的调用栈

00:07:18.672 --> 00:07:20.841
在这个示例中 只有两个方法

00:07:21.375 --> 00:07:24.811
然后 我们更新表
这是一个树的分支

00:07:24.878 --> 00:07:30.083
现在我们了解了 主方法有时调用
method1 有时调用method2

00:07:30.417 --> 00:07:33.353
我们知道每种方法被调用了多少次

00:07:34.655 --> 00:07:37.891
那么 时间继续 我们收集更多的样本

00:07:37.958 --> 00:07:40.260
这些样本恰巧跟第一次的样本
完全一样

00:07:40.561 --> 00:07:42.996
我们要适当地更新表

00:07:43.730 --> 00:07:47.301
现在 让我们看看这个表说明了什么

00:07:48.635 --> 00:07:53.006
要注意一点 时间分析器实际上
并不是在测定持续的时间

00:07:53.273 --> 00:07:55.342
它并不是记录哪个方法
什么时候开始

00:07:55.609 --> 00:07:58.312
什么时候结束 然后做个减法

00:07:58.612 --> 00:08:02.049
而是把这些样本集合到一个
有用的汇总中

00:08:02.382 --> 00:08:05.052
当你在时间分析器中查看时间值时

00:08:05.118 --> 00:08:07.187
实际上不是一个持续时间的测定

00:08:07.454 --> 00:08:12.125
而是样本时间乘以样本个数

00:08:12.192 --> 00:08:14.161
在绝大部分情况下 是1毫秒

00:08:14.828 --> 00:08:17.197
这的确有一些副作用

00:08:17.464 --> 00:08:20.067
其中一个就是时间分析器
并不会区分

00:08:20.133 --> 00:08:23.904
被重复调用的
是连续运行的方法

00:08:23.971 --> 00:08:25.439
还是稍纵即逝的方法

00:08:25.739 --> 00:08:28.442
我们实际上可以看到在调用树中

00:08:28.509 --> 00:08:32.111
method1和method2
出现的样本个数相同

00:08:32.179 --> 00:08:37.618
从时间分析器的角度来说
它们做了同样多的工作

00:08:38.118 --> 00:08:41.955
但我们知道 实际上method1
被调用了两次 运行时间很长

00:08:42.022 --> 00:08:45.125
而method2被调用了四次
运行时间很短

00:08:46.226 --> 00:08:49.630
时间分析器还集中分析
CPU的使用情况 对吧？

00:08:49.696 --> 00:08:53.567
它回答了这个问题
应用正在做什么工作？

00:08:53.867 --> 00:08:57.471
另一个结果是
它不一定会捕捉一切

00:08:57.871 --> 00:09:00.240
事实上 表中遗失了什么？

00:09:01.942 --> 00:09:03.677
没有method3 对吗？

00:09:03.977 --> 00:09:05.812
如果你有执行起来非常快的函数

00:09:05.879 --> 00:09:08.415
或执行起来很快而且非常
频繁地调用的方法

00:09:08.782 --> 00:09:10.317
这些方法将不会
出现在调用树中

00:09:10.918 --> 00:09:12.619
实际上没问题
这就是我们想要的

00:09:12.686 --> 00:09:14.488
因为那并不会影响

00:09:14.555 --> 00:09:16.857
所产生的工作量

00:09:18.192 --> 00:09:20.260
那么现在 我们对调用树
有了更好的理解

00:09:20.360 --> 00:09:23.430
让我们看看如何通过它使应用的
速度更快 工作量更少

00:09:31.572 --> 00:09:34.875
好的 让我们回去看时间线

00:09:36.410 --> 00:09:40.714
我想看一下第一大块
CPU的使用情况

00:09:40.781 --> 00:09:45.385
可以看到 在大量时间内
CPU的占用是100%

00:09:46.753 --> 00:09:49.489
那么 我想确切了解那时
应用正在做什么

00:09:49.556 --> 00:09:52.159
我恰巧知道
那时我正在做副本检测

00:09:52.459 --> 00:09:55.896
预计那个工作量会很大
所以我一点儿都不吃惊

00:09:56.196 --> 00:09:57.831
但无论在哪儿
你占用了大量CPU资源

00:09:57.898 --> 00:10:00.567
通常总是能让它更快一些

00:10:01.668 --> 00:10:04.104
所以 为了更好地了解
这里正在发生什么

00:10:04.371 --> 00:10:10.511
我要用触控板 放大 然后松开

00:10:10.911 --> 00:10:15.916
我可以更好地了解在这个时间段
到底发生了什么

00:10:16.650 --> 00:10:21.021
然后我要点击并拖拽时间线视图

00:10:22.089 --> 00:10:23.957
这样可以应用一个筛选器

00:10:24.024 --> 00:10:27.361
现在调用树只能显示在那个

00:10:27.427 --> 00:10:30.130
时间框架内所收集样本的数据

00:10:30.330 --> 00:10:32.065
如果你注意看 你会看到

00:10:32.132 --> 00:10:34.868
调用树实际上显示的数据变少了

00:10:34.935 --> 00:10:37.371
只显示了这个时间段的数据

00:10:38.505 --> 00:10:40.841
现在 让我们更详细地
看一下调用树

00:10:42.342 --> 00:10:43.677
你将在这儿看到几个栏

00:10:43.744 --> 00:10:46.580
有比重和自比重 然后是标识名

00:10:47.414 --> 00:10:50.784
比重代表调用树出现的

00:10:51.084 --> 00:10:53.854
指定部分的样本百分比

00:10:54.221 --> 00:10:56.390
你将看到比重旁边还有个时间

00:10:56.456 --> 00:10:58.792
正如我之前讲过的
那不是持续时间

00:10:59.059 --> 00:11:03.497
而是样本时间乘以样本个数

00:11:04.131 --> 00:11:05.866
然后还有自比重

00:11:06.300 --> 00:11:10.904
实际上是在那个方法内
所花费的时间

00:11:10.971 --> 00:11:12.906
而非在它调用的其他方法内
所花费的时间

00:11:13.273 --> 00:11:15.475
你在这里可以看到 这些是0

00:11:15.542 --> 00:11:18.679
如果你关闭这个 还是0

00:11:18.779 --> 00:11:19.780
仍然是0

00:11:20.113 --> 00:11:24.651
这就告诉我们 你知道的
在样本中主方法的比重是99%

00:11:25.752 --> 00:11:29.289
但其实这些全部也是在
UIApplication主方法中

00:11:29.590 --> 00:11:33.227
无论是什么方法都要调用
UIApplication的主方法

00:11:33.493 --> 00:11:35.329
我们不会一个接一个地显示这些

00:11:35.395 --> 00:11:37.965
我要使用Instruments 8
中的新功能

00:11:38.632 --> 00:11:41.702
我按下选项键
并点击显示三角按钮

00:11:41.969 --> 00:11:44.104
这样能得到一个更好的显示

00:11:44.238 --> 00:11:46.206
这将会关闭调用树

00:11:46.273 --> 00:11:48.141
除非调用树中有真正令人
关注的数据

00:11:49.443 --> 00:11:51.578
如果我们继续往下滚动

00:11:51.645 --> 00:11:54.014
我们可以看到
我们实际上有一些方法

00:11:54.281 --> 00:11:55.916
有自比重

00:11:56.216 --> 00:11:58.585
其实若我查看这个
特定的release调用

00:11:58.652 --> 00:12:03.757
我可以看到 它的比重是117毫秒
跟它的自比重一样

00:12:04.024 --> 00:12:05.759
那么它所有的时间都花在它自己身上了

00:12:05.826 --> 00:12:09.162
没有调用任何后续的函数或方法

00:12:09.863 --> 00:12:11.265
其实 你知道的 通过查看这些

00:12:11.331 --> 00:12:14.601
我看到这里调用了很多
Objective-C执行时间

00:12:14.935 --> 00:12:18.372
实际上它们的自重都很大

00:12:19.673 --> 00:12:23.844
这些运行时间方法已经被无限
高度优化 运行起来非常快

00:12:24.211 --> 00:12:27.581
通常是时间分析器不会
捕捉的那类东西

00:12:27.648 --> 00:12:29.016
因为运行速度太快了

00:12:29.950 --> 00:12:34.621
但是它们已经被显示出来了
于是我知道通常它们会被频繁调用

00:12:35.055 --> 00:12:36.523
所以才在样本中出现

00:12:36.823 --> 00:12:40.694
这通常是循环很多
Objective-C对象的情况

00:12:40.761 --> 00:12:42.462
你将看到这会在轨迹中显示出来

00:12:42.963 --> 00:12:46.767
调用树体现的第二点是
看右边

00:12:47.067 --> 00:12:52.105
我们可以看到调用树的哪部分
来自哪个库

00:12:52.172 --> 00:12:53.273
特定的方法调用

00:12:53.340 --> 00:12:55.843
并且在这里 我们能看到这是
随着照片框架出现的

00:12:56.109 --> 00:12:57.444
实际上是按照层级排列的

00:12:58.011 --> 00:12:59.346
滚动到右边

00:12:59.646 --> 00:13:03.450
我们可以看到
这里有一行来自应用的代码

00:13:03.517 --> 00:13:05.819
这行代码导致了工作量的产生

00:13:08.021 --> 00:13:11.592
你知道的 这行的比重是0

00:13:11.658 --> 00:13:13.460
它自己没做任何工作

00:13:13.527 --> 00:13:15.696
但是它却触发了所有工作

00:13:16.196 --> 00:13:19.700
我不能再加快Objective-C
发布调用的速度了

00:13:19.766 --> 00:13:23.937
但我能看到是否可以少调用几次

00:13:24.505 --> 00:13:26.240
所以 我要双击这行

00:13:26.507 --> 00:13:28.041
把我带入代码中

00:13:29.109 --> 00:13:33.180
Instruments给每行
添加了一个样本个数的注释

00:13:33.247 --> 00:13:36.416
那么 看这个方法
我能看到大部分时间

00:13:36.483 --> 00:13:38.151
都花在红色背景行那儿

00:13:38.986 --> 00:13:41.955
但是如果我再仔细看一下
我实际上能看到其他东西

00:13:42.022 --> 00:13:43.657
我嵌套了四个循环

00:13:44.157 --> 00:13:50.831
事实上 每个循环重复整个
照片采集的过程

00:13:51.431 --> 00:13:53.500
这是很典型的一个

00:13:53.567 --> 00:13:55.502
叫做N次方行为的例子

00:13:55.936 --> 00:13:58.572
如果我向这行代码中代入
更多数据

00:13:58.639 --> 00:14:01.341
速度会变慢 越来越慢

00:14:01.408 --> 00:14:05.712
因为我知道会运行大量数据
这很不好

00:14:06.346 --> 00:14:08.215
所以我想改变这种情况

00:14:08.649 --> 00:14:09.850
我要进入Xcode

00:14:10.450 --> 00:14:11.585
这是我的代码

00:14:12.619 --> 00:14:17.891
避免嵌套四个循环的典型方法是
使用基于集合的实现

00:14:18.358 --> 00:14:21.195
我不再赘述了 我要继续

00:14:22.362 --> 00:14:28.702
创建一个新算法
用来执行副本检测 使用...

00:14:33.440 --> 00:14:35.709
使用一个计数集合和另一个
查找副本的

00:14:40.514 --> 00:14:41.748
集合

00:14:42.416 --> 00:14:45.319
现在 让我们看看
我实际上做了点儿改变

00:14:45.452 --> 00:14:47.287
再一次 我要进入产品菜单

00:14:47.988 --> 00:14:49.456
我要选择分析

00:14:50.190 --> 00:14:54.061
它会重新创建我的应用
并把它安装在设备上

00:14:55.729 --> 00:14:57.831
因为Instruments已运行了

00:14:57.998 --> 00:15:00.434
它会立即开始记录

00:15:01.268 --> 00:15:04.905
那么 当它把应用复制到设备上时
让我们看一下 已经开始分析了

00:15:07.941 --> 00:15:09.009
这是Instruments

00:15:10.711 --> 00:15:12.346
我的应用已经开启了

00:15:14.581 --> 00:15:17.251
好的 它开始记录了 我要缩小

00:15:19.219 --> 00:15:21.588
好的 我要缩小
这样我们就能看到数据了

00:15:23.156 --> 00:15:25.392
我要执行副本检测

00:15:27.528 --> 00:15:29.530
副本 所有照片

00:15:30.998 --> 00:15:32.399
我可以看到数据进来了

00:15:32.599 --> 00:15:34.668
实际上是以分钟为单位记录的
我还以为是秒

00:15:35.269 --> 00:15:38.705
好的 那么副本检测
实际上速度更快了

00:15:39.339 --> 00:15:44.545
事实上 我们再也不会看到贯穿
时间线的那个长条了

00:15:44.611 --> 00:15:45.712
这是个不错的变化

00:15:46.079 --> 00:15:49.116
我想继续
重新测定应用剩余的部分

00:15:49.183 --> 00:15:50.551
选择一些照片

00:15:51.185 --> 00:15:52.886
添加一双金鱼眼

00:15:53.420 --> 00:15:54.621
摇动一下

00:15:55.189 --> 00:15:56.790
然后就不用管那张照片了

00:15:56.857 --> 00:16:00.827
现在应用是静态的
不应该做任何工作

00:16:01.295 --> 00:16:05.132
但是让我们看看
时间分析器怎么说

00:16:05.232 --> 00:16:06.533
停止记录

00:16:09.703 --> 00:16:11.205
加载一分钟才有数据

00:16:11.305 --> 00:16:12.139
哇哦

00:16:14.174 --> 00:16:19.580
好的 我可以看到在调用的末端

00:16:19.646 --> 00:16:21.415
占用了一些CPU资源

00:16:21.982 --> 00:16:24.651
并不多 但我希望是0

00:16:25.052 --> 00:16:26.954
所以我要继续 看看它做了什么

00:16:27.721 --> 00:16:30.591
我再次通过触摸板进行放大

00:16:32.192 --> 00:16:36.129
拖拽并选择
看看这里发生了什么

00:16:37.264 --> 00:16:43.003
然后继续
点开查看正在发生什么

00:16:43.470 --> 00:16:45.539
查看调用树

00:16:45.806 --> 00:16:48.775
这次我看到在CoreMotion中
有大量的调用 对吧？

00:16:48.842 --> 00:16:50.344
且我知道我的应用正在此做什么

00:16:50.410 --> 00:16:54.381
它正在使用CoreMotion进行
检测并移动眼睛

00:16:54.982 --> 00:16:57.518
但如果查看上边的调用树

00:16:57.584 --> 00:17:01.421
实际上这个调用树中没有
我的任何代码

00:17:01.989 --> 00:17:04.825
我并没有执行任何可以直接引起
使用CPU的操作

00:17:05.092 --> 00:17:08.328
但我应用中的某些东西使
CoreMotion做了不该做的

00:17:08.729 --> 00:17:10.097
关于应用 我知道的是

00:17:10.163 --> 00:17:14.034
我发现
当不看屏幕的时候

00:17:14.101 --> 00:17:16.002
我不能关闭CoreMotion监控

00:17:16.603 --> 00:17:18.438
让我们继续改一下

00:17:19.406 --> 00:17:20.540
返回Xcode

00:17:21.942 --> 00:17:26.847
实际上我已经写好了所有方法

00:17:27.047 --> 00:17:30.184
只需要调用即可
让我们把它们添加到这里来

00:17:32.186 --> 00:17:35.055
然后我们停止观察这儿

00:17:39.626 --> 00:17:41.195
好的 现在让我们测定这个

00:17:41.261 --> 00:17:44.464
并确保会发生我们所期待的改变

00:17:45.399 --> 00:17:48.769
再次
Instruments会重建应用

00:17:49.036 --> 00:17:50.103
并把它放在设备上

00:17:50.971 --> 00:17:55.042
因为Instruments已经开启
并正在运行 它会再次开始记录

00:17:55.475 --> 00:17:58.312
这一次 我要提前放大

00:17:58.712 --> 00:18:02.616
我点击筛选器外面 移除它

00:18:04.518 --> 00:18:07.120
好的 一旦应用在设备上安装

00:18:08.322 --> 00:18:10.390
Instruments就会再次
开启对它的记录

00:18:18.065 --> 00:18:19.399
好的 就是这样

00:18:23.704 --> 00:18:29.109
好的 这一次 我要继续
只添加照片

00:18:33.113 --> 00:18:35.048
然后我要滚动到一张照片那儿

00:18:35.816 --> 00:18:36.783
选择它

00:18:37.084 --> 00:18:38.118
添加眼睛

00:18:39.553 --> 00:18:40.821
摇动一下

00:18:40.888 --> 00:18:42.456
让我们再稍微放大点儿

00:18:45.192 --> 00:18:48.328
选择一张新照片
这样屏幕上就没有眼睛了

00:18:49.196 --> 00:18:51.498
然后停止记录

00:18:51.565 --> 00:18:53.400
看看是否发生了我们
所期待的变化

00:18:54.034 --> 00:18:59.306
一旦Instruments
完成数据处理 我就放大这个末端部分

00:18:59.373 --> 00:19:03.177
我可以看到在末端
CPU的占用率为0

00:19:03.577 --> 00:19:07.281
所以应用不再做它不需要做
的工作了

00:19:08.782 --> 00:19:10.918
那么 让我们回顾一下
我们做了什么

00:19:11.885 --> 00:19:15.355
第一件事是用轨迹面板计算

00:19:15.422 --> 00:19:17.958
应用做了多少工作
以及什么时候做的

00:19:18.025 --> 00:19:21.361
这样就很容易找到想要关注的区域

00:19:21.762 --> 00:19:25.132
并且触控板很容易操作
轨迹面板或时间线

00:19:25.199 --> 00:19:27.067
但用鼠标控制也不错

00:19:27.134 --> 00:19:30.537
使用option键-拖拽
和control键-拖拽放大和缩小

00:19:31.705 --> 00:19:35.642
我们在轨迹视图上找到了一个
占用许多CPU资源的区域

00:19:35.709 --> 00:19:37.177
我们想让它速度更快

00:19:37.344 --> 00:19:42.149
所以我们继续 放大
对那个区域进行筛选

00:19:43.250 --> 00:19:45.452
我们查看了调用树 我们发现

00:19:45.519 --> 00:19:48.488
产生工作量的地方
是应用中的那个部分

00:19:49.323 --> 00:19:53.794
然后我们往回看调用树
直到看到我们的代码

00:19:53.861 --> 00:19:57.097
应用中的哪个部分产生了
这样的工作量

00:19:57.397 --> 00:19:59.433
即使不是应用自己产生的？

00:20:00.734 --> 00:20:03.504
我们看一下代码 考虑一下

00:20:03.570 --> 00:20:05.606
挠挠头 吃一个三明治

00:20:05.672 --> 00:20:07.441
我们发现了可使它速度更快的方式

00:20:07.941 --> 00:20:10.677
所以我们实现了那些变更

00:20:10.744 --> 00:20:13.914
并证实了实际上会让它的速度变得更快

00:20:13.981 --> 00:20:16.083
在这个例子中
这是个意义重大的改进

00:20:16.149 --> 00:20:19.253
结果是我们节省了用户的时间

00:20:19.419 --> 00:20:21.355
当用户使用我的应用
来查找副本时

00:20:21.421 --> 00:20:23.524
他们再也不用看那个
旋转的加载图标了

00:20:24.324 --> 00:20:25.792
会很快地完成

00:20:27.160 --> 00:20:29.329
关于减少工作量
我们能做什么呢？

00:20:29.696 --> 00:20:32.833
我们再关注一下轨道视图
上的一个区域

00:20:33.901 --> 00:20:35.936
这一次并没有占用
很多CPU资源

00:20:36.003 --> 00:20:38.639
而CPU的占用量
出人意料

00:20:39.139 --> 00:20:41.308
我们放大 加上一个筛选器

00:20:41.909 --> 00:20:43.577
我们看一下调用树

00:20:43.644 --> 00:20:47.714
这一次 我们再看一下框架
我们看到的是CoreMotion

00:20:47.781 --> 00:20:49.917
但没有诱发我们的代码

00:20:50.551 --> 00:20:53.020
所以这次 我们得用另一种方式
来思考我们的应用

00:20:53.086 --> 00:20:56.123
是应用的哪个部分
导致了这个工作量？

00:20:56.857 --> 00:21:01.662
我们又一次 也许休息一小会儿
再吃个三明治

00:21:01.895 --> 00:21:04.631
想想如何使应用停止产生
那个工作量

00:21:05.199 --> 00:21:06.700
让它不再出现

00:21:07.334 --> 00:21:09.436
我们继续 重新分析应用

00:21:09.503 --> 00:21:12.906
验证了我们所期望的修改

00:21:13.473 --> 00:21:17.778
事实上 结果是
我们显著提高了

00:21:18.579 --> 00:21:21.114
应用运行时的电池续航能力

00:21:21.181 --> 00:21:24.284
无论任何时候 CPU都可以归0
并进入休眠

00:21:24.585 --> 00:21:26.520
这就意味着有效地节省了用电量

00:21:26.753 --> 00:21:31.825
即使我们的CPU占用量很低
仍然会有电量消耗

00:21:32.759 --> 00:21:35.929
那么现在 我们变快了
工作量变少了

00:21:36.263 --> 00:21:38.732
让我们使应用的响应
更积极一些吧

00:21:40.934 --> 00:21:43.403
应用的工作方式

00:21:43.470 --> 00:21:46.340
是主线程完成所有
用户界面的工作

00:21:46.406 --> 00:21:51.178
承担了响应用户输入并更新
视图的任务

00:21:51.545 --> 00:21:56.116
无论如何处理用户输入
都有一个主线程

00:21:56.183 --> 00:22:00.420
主线程有一个运行循环
只是监听一个队列

00:22:00.487 --> 00:22:01.855
叫做事件队列

00:22:01.922 --> 00:22:04.157
并等待事件在事件队列中出现

00:22:04.758 --> 00:22:10.764
事件出现时 它把事件发送到
UIApplication或NS应用实例

00:22:11.164 --> 00:22:15.169
然后把事件传递到
应用的响应链中

00:22:15.802 --> 00:22:18.739
如果应用想响应那个事件

00:22:19.039 --> 00:22:21.208
那么它会继续并诱发你的代码

00:22:21.775 --> 00:22:25.012
然后你可以在这里的调用栈中
看到这个

00:22:25.345 --> 00:22:27.281
这是我应用中的调用栈

00:22:27.781 --> 00:22:30.050
我们可以看到 有主线程

00:22:30.817 --> 00:22:35.389
所有应用的主线程都是
以调用主函数开始的

00:22:35.923 --> 00:22:38.759
在这里 我不清楚这些函数
具体有什么作用

00:22:38.825 --> 00:22:41.161
但是显而易见
都跟运行循环相关

00:22:41.995 --> 00:22:44.631
我看到有函数
handleEventQueue

00:22:44.698 --> 00:22:47.968
很显然 这个函数是从事件队列中
把一个事件取出来 并进行处理

00:22:48.468 --> 00:22:51.572
我可以看到它把事件
传给了UIApplication

00:22:51.638 --> 00:22:55.008
然后传到响应链
最后传给了我的代码

00:22:55.242 --> 00:22:58.512
在这个例子中
这是一个按钮的IB动作

00:22:59.479 --> 00:23:01.215
然后我的代码就执行了操作

00:23:02.249 --> 00:23:05.185
那么 这对于保持应用积极响应
来说有什么意义呢？

00:23:05.786 --> 00:23:10.224
嗯 忙时 主线程不能处理队列

00:23:10.624 --> 00:23:13.627
因为它会开始备份
备份你的用户事件

00:23:14.094 --> 00:23:17.664
然后结果是 变得磕磕绊绊
不顺畅

00:23:18.031 --> 00:23:21.301
最糟糕的情况是
你的应用变得完全没有响应

00:23:21.635 --> 00:23:24.571
此时用户会关闭应用
也许会从设备上删除应用

00:23:25.506 --> 00:23:29.109
因此 释放主线程很重要

00:23:29.877 --> 00:23:35.716
这样就能很快地响应用户输入

00:23:36.984 --> 00:23:38.519
现在 有了这种方案

00:23:38.585 --> 00:23:42.155
让我们看看可以对应用做出哪些改进
使它能更积极地做出响应

00:23:43.624 --> 00:23:46.960
好了 这次我要缩小轨迹视图

00:23:47.528 --> 00:23:50.898
现在我想要关注的是这个
CPU占用比较多的区域

00:23:51.164 --> 00:23:53.934
在这里 我看到CPU的占用率
远远超过100%

00:23:54.168 --> 00:23:56.870
也许可以对这里进行优化

00:23:57.404 --> 00:24:00.908
而我恰巧知道 这是我给图片
添加眼睛的时候

00:24:01.441 --> 00:24:04.611
那么我再一次使用触控板
进行放大

00:24:05.412 --> 00:24:08.315
点击并拖拽 加上一个过滤器

00:24:09.483 --> 00:24:11.251
现在看一下调用树

00:24:12.519 --> 00:24:15.989
这次 我想特别关注
主线程做了什么

00:24:16.456 --> 00:24:19.259
我可以看到 实际上主线程

00:24:19.326 --> 00:24:22.663
在样本中的出现频率为
63% 64%

00:24:23.931 --> 00:24:28.101
因此我就明白了 在这个时间段
正在进行一些工作

00:24:28.502 --> 00:24:30.771
但我想确切地知道做了多少工作

00:24:31.572 --> 00:24:35.709
为此 我要继续 看右上角

00:24:35.976 --> 00:24:38.779
我们可以使用不同的
策略和Instruments

00:24:38.846 --> 00:24:42.316
因此 你可以按照CPU
或线程浏览数据

00:24:42.683 --> 00:24:44.418
这一次 我想按照线程来看数据

00:24:44.885 --> 00:24:47.521
实际上我可以让它变大点儿
以便查看

00:24:48.088 --> 00:24:52.125
在左侧的这里 你可以看到
应用中的所有线程

00:24:52.559 --> 00:24:54.094
主线程在顶部

00:24:54.595 --> 00:24:58.632
所以我可以看到主线程的CPU
使用情况

00:24:58.866 --> 00:25:01.902
在这里 很明显 达到了100%

00:25:02.302 --> 00:25:05.906
在这种状态下
它绝不会响应用户事件了

00:25:05.973 --> 00:25:09.142
也不能处理队列了

00:25:09.209 --> 00:25:11.044
如果它正忙于处理应用中的工作

00:25:11.745 --> 00:25:14.381
那么 主线程到底在做什么？

00:25:14.915 --> 00:25:19.386
这一次 我要点击右侧的扩展
详细视图

00:25:19.753 --> 00:25:24.258
这将显示在主线程上做了
大部分工作的调用栈

00:25:24.391 --> 00:25:26.960
因为我的主线程是从左侧
选出来的

00:25:27.294 --> 00:25:30.898
所以我在这里滚动
我可以看到这是运行循环

00:25:30.964 --> 00:25:32.733
然后在这里
我看到了我的代码

00:25:33.066 --> 00:25:35.369
这是添加眼睛的代码

00:25:35.769 --> 00:25:38.172
然后正在做更多的添加
眼睛的工作

00:25:38.238 --> 00:25:39.940
然后这里
正在调用查找面部

00:25:40.007 --> 00:25:42.676
所以这是应用中的
面部检测代码

00:25:42.743 --> 00:25:46.113
然后我们可以看到下一行
调用了图形核心

00:25:46.180 --> 00:25:52.019
如果我在详细视图中点击这个
它将展开那行的调用树

00:25:53.220 --> 00:25:55.489
再一次推导出我的代码

00:25:55.556 --> 00:26:00.294
我没必要在主线程上做面部检测

00:26:00.360 --> 00:26:04.731
这并不是响应用户输入
也不是更新视图

00:26:05.065 --> 00:26:07.167
因此可以挪到后台线程上去实现

00:26:07.601 --> 00:26:11.572
那么 这是执行面部检测的代码

00:26:11.638 --> 00:26:14.007
我可以看到面部检测完成后

00:26:14.208 --> 00:26:16.443
它会继续调用
displayEyes方法

00:26:16.877 --> 00:26:21.548
这里要注意一个重点
displayEyes会更新UI

00:26:21.615 --> 00:26:24.218
因此这是主线程上的工作

00:26:24.751 --> 00:26:28.655
所以 我需要做的是在后台
线程上执行面部检测

00:26:28.989 --> 00:26:33.794
切回主线程 更新UI

00:26:35.028 --> 00:26:36.630
哦 好了

00:26:36.697 --> 00:26:38.832
好的 谢谢

00:26:41.101 --> 00:26:43.604
此处不应有掌声

00:26:43.871 --> 00:26:44.905
但我接受你们的夸奖

00:26:45.839 --> 00:26:48.375
好了 这是在后台实现这个
功能的代码

00:26:48.442 --> 00:26:51.178
我要快速讲一下

00:26:51.612 --> 00:26:54.147
进入后台的一个队列

00:26:54.214 --> 00:26:57.117
然后调度查找面部代码

00:26:57.451 --> 00:27:00.654
正如我刚说过的
我们要调回主队列

00:27:00.721 --> 00:27:02.222
更新我们的UI

00:27:02.589 --> 00:27:04.424
这一次在做分析时

00:27:04.491 --> 00:27:08.395
我会按住运行按钮 选择分析

00:27:09.062 --> 00:27:10.397
可以实现同样的功能

00:27:10.731 --> 00:27:13.100
很可能会相当快

00:27:13.200 --> 00:27:15.102
哦 我删除了代码

00:27:16.069 --> 00:27:17.304
让我们再做一次

00:27:17.571 --> 00:27:19.907
那么因为我已经实现了
我只需要继续并...

00:27:20.774 --> 00:27:22.142
这个结果满意吗...

00:27:22.209 --> 00:27:24.845
点击分析按钮 好了

00:27:25.112 --> 00:27:26.780
它会创建我的应用

00:27:28.081 --> 00:27:29.550
并在设备上安装应用

00:27:30.417 --> 00:27:33.187
好的 Instruments应显示

00:27:33.587 --> 00:27:38.992
并开始记录我的应用了

00:27:41.195 --> 00:27:44.298
哦 我要切回
Instruments视图

00:27:48.435 --> 00:27:52.339
然后 让我们缩小一下
看看进来的数据

00:27:53.974 --> 00:27:58.946
好的 很快
让我们给应用添加一些照片

00:28:02.049 --> 00:28:04.184
然后执行眼睛检测

00:28:04.585 --> 00:28:07.354
好了 那么在这里
我们能看到那个大的CPU峰值

00:28:08.055 --> 00:28:09.857
停止记录

00:28:10.657 --> 00:28:13.026
现在 让我们看看是否实现了
我们所期待的变更

00:28:13.293 --> 00:28:19.032
我要再次使用触控板放大
图表的这个区域

00:28:19.900 --> 00:28:24.404
点击并拖拽时间线视图
加一个过滤器

00:28:25.272 --> 00:28:27.674
现在 如果我们查看一下调用树

00:28:27.741 --> 00:28:32.679
实际上我在这里看到主线程
在样本中的比重只有4.8%

00:28:32.746 --> 00:28:33.747
这是个好迹象

00:28:33.814 --> 00:28:35.983
我已经知道主线程的工作量
正在减少

00:28:36.049 --> 00:28:38.418
两个辅助线程分担了
更多的工作量

00:28:39.319 --> 00:28:41.855
那么让我们切到线程策略

00:28:42.322 --> 00:28:43.357
在这里 我可以看到

00:28:43.423 --> 00:28:48.395
实际上 主线程在绝大部分
时间里是完全被释放的

00:28:50.998 --> 00:28:51.865
谢谢大家

00:28:55.702 --> 00:28:57.604
让我们返回幻灯片

00:28:58.705 --> 00:29:00.374
谈谈我们刚才做了什么

00:29:01.241 --> 00:29:03.977
为了使应用更积极地做出响应

00:29:04.678 --> 00:29:08.649
我们发现了一个区域
在这个区域中CPU占用率很高

00:29:08.715 --> 00:29:12.419
我就放大那个区域 添加了一个
过滤器 这是很常见的操作

00:29:12.486 --> 00:29:14.154
我们做的就是

00:29:14.221 --> 00:29:16.123
关注主线程

00:29:16.190 --> 00:29:21.228
因为我想确保我的应用
持续地做出积极响应

00:29:21.762 --> 00:29:25.933
我摘出主线程上的一些
非UI类的工作

00:29:26.166 --> 00:29:28.802
然后把那些工作挪到
后台线程上去实现

00:29:29.536 --> 00:29:31.638
你很可能猜到了下一个步骤

00:29:31.939 --> 00:29:33.540
我验证了我所做的变更

00:29:33.941 --> 00:29:37.945
确保应用正如我所期待的那样

00:29:38.645 --> 00:29:41.715
结果是我得到了更好的用户体验

00:29:41.782 --> 00:29:45.819
当执行面部检测时
我的用户界面将持续做出响应

00:29:46.220 --> 00:29:47.354
这很棒

00:29:48.322 --> 00:29:50.624
关于优化 有几点建议

00:29:50.824 --> 00:29:53.126
我们今天所做的修改相对简单

00:29:53.193 --> 00:29:55.162
但确实增加了应用的复杂程度

00:29:55.629 --> 00:29:56.864
一般来说

00:29:56.930 --> 00:30:01.268
优化范例是用简化换取性能

00:30:01.335 --> 00:30:03.136
关于优化

00:30:03.203 --> 00:30:07.941
但很幸运 因为我早在开发阶段
就做了分析

00:30:08.008 --> 00:30:09.209
我并没有等到最后才做

00:30:09.276 --> 00:30:14.781
我现在有时间验证
应用是否运转正常

00:30:15.215 --> 00:30:18.852
如果我觉得必要 我可以添加
额外的单元测试或UI测试

00:30:19.152 --> 00:30:22.356
关注比较复杂的地方
仍然能正常运行

00:30:23.490 --> 00:30:25.726
在你发布应用之前

00:30:25.792 --> 00:30:29.263
是你能做出修改的最后机会

00:30:29.730 --> 00:30:34.535
所以真正的收获是它会
持续地分析你的应用

00:30:34.601 --> 00:30:36.870
尤其在你添加新功能之后

00:30:37.137 --> 00:30:38.839
要早做分析

00:30:38.906 --> 00:30:41.608
要不间断地做分析

00:30:42.142 --> 00:30:45.112
有时候可以只分析运行时间
看能发现什么

00:30:45.179 --> 00:30:47.347
你很快就会取得重大进展

00:30:48.182 --> 00:30:51.652
因此运行分析还是有好处的
可以了解是否正在发生有趣的事

00:30:52.619 --> 00:30:55.422
关于时间分析器的一些最佳范例

00:30:55.656 --> 00:30:59.326
总的来说 你的分析

00:30:59.393 --> 00:31:02.162
要尽可能地接近客户
要运行的东西

00:31:02.563 --> 00:31:05.199
因此你要一直分析发布版本

00:31:05.265 --> 00:31:06.500
最佳范例

00:31:06.567 --> 00:31:09.036
你不仅需要在编译阶段进行优化

00:31:09.102 --> 00:31:11.371
还需要在你客户要使用的发布
版本上进行优化

00:31:12.239 --> 00:31:14.608
你要一直在设备上做分析

00:31:14.675 --> 00:31:18.245
模拟器不能给你提供有用的数据

00:31:20.447 --> 00:31:24.785
要在能支持的最老、
最慢的设备上做分析

00:31:25.185 --> 00:31:26.553
有一条很好的规则

00:31:26.620 --> 00:31:29.022
如果能在较慢的设备上
很好地运行

00:31:29.089 --> 00:31:31.491
那么 在较快的设备上一定
能更好地运行

00:31:31.892 --> 00:31:35.395
你想让所有用户在使用你的
应用时都有非常棒的体验

00:31:35.696 --> 00:31:37.297
就算用的是较慢的设备也一样

00:31:38.131 --> 00:31:40.801
要尽可能使用大数据集合

00:31:40.934 --> 00:31:46.773
在我的示例中 有时候用户的相册中
有成百上千

00:31:46.840 --> 00:31:48.141
或成千上万张照片

00:31:48.375 --> 00:31:52.312
分析应用如何在那种环境下
运行非常重要

00:31:52.746 --> 00:31:56.483
因此我可以确保客户在打开
应用时应用能顺畅运行

00:31:58.018 --> 00:32:00.287
那么 总结一下

00:32:00.821 --> 00:32:06.426
如果你希望客户因为应用能节约
时间而爱上你的应用

00:32:07.294 --> 00:32:09.863
有助于他们实现全天电量充沛

00:32:10.264 --> 00:32:13.333
并且你的UI响应顺畅

00:32:13.400 --> 00:32:18.539
然后 你要做的是早做分析
并经常分析

00:32:20.274 --> 00:32:23.310
如果你想了解更多信息
请看这个URL

00:32:24.111 --> 00:32:27.247
这里有一些相关的演讲

00:32:27.514 --> 00:32:29.917
去年我们做了一场
“深度分析”的演讲

00:32:29.983 --> 00:32:33.353
有关于时间分析器的更多
详细信息 你可以了解一下

00:32:33.420 --> 00:32:36.256
今年 我们做了一个名为深度解析
系统跟踪的系列演讲

00:32:36.323 --> 00:32:38.225
讲的是当时间分析器力不从心时

00:32:38.292 --> 00:32:41.361
如何使用系统跟踪工具

00:32:41.628 --> 00:32:43.664
谢谢大家
祝你们度过一个美好的下午