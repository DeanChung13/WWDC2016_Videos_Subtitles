00:00:19.853 --> 00:00:24.424
iMessage应用和贴图 第二部分
互动信息

00:00:39.673 --> 00:00:40.707
下午好

00:00:40.774 --> 00:00:43.510
欢迎来到“iMessage应用
和贴图 第二部分”

00:00:43.977 --> 00:00:46.713
我叫Alex
今天协助我的是Stephen

00:00:46.780 --> 00:00:48.081
他将负责演示

00:00:49.183 --> 00:00:51.451
在演讲的第一部分 Bhaskar

00:00:51.518 --> 00:00:54.855
和Lily介绍了贴图 贴图包

00:00:54.922 --> 00:00:56.823
和简单的iMessage应用

00:00:56.890 --> 00:00:59.626
专注于为信息提供贴图数据

00:01:01.929 --> 00:01:05.032
今天我们将要来讲解互动信息

00:01:05.098 --> 00:01:07.301
我们将更深入
分析iMessage应用

00:01:07.367 --> 00:01:08.669
及Messages框架

00:01:11.071 --> 00:01:12.806
什么是互动信息？

00:01:13.740 --> 00:01:17.411
在我背后的信息文本里
可以看见高亮显示的一条

00:01:19.179 --> 00:01:23.984
这是Messages扩展提供的
一种特殊类型的信息泡泡框

00:01:24.484 --> 00:01:27.487
可以看见它在截屏里被高亮显示

00:01:32.392 --> 00:01:36.997
Messages扩展可以
让用户新建互动信息

00:01:37.865 --> 00:01:41.768
并可以把它们插入输入框
如这里所示

00:01:44.738 --> 00:01:48.141
还可以让用户回复一条互动信息

00:01:48.208 --> 00:01:51.245
只需点击文本里的该互动信息即可

00:01:51.311 --> 00:01:55.082
此时扩展将会全屏显示 如这里所示

00:01:56.083 --> 00:02:01.221
用户可以和该扩展进行互动
编写一个答复

00:02:02.155 --> 00:02:07.427
然后扩展可以把新内容插入信息中

00:02:07.494 --> 00:02:10.264
它会显示在输入框 用户可以发送

00:02:11.999 --> 00:02:14.268
我们现在欢迎Stephen上台

00:02:14.334 --> 00:02:17.271
他将在模拟器上演示一个应用实例

00:02:26.213 --> 00:02:29.183
我将演示一个完整的
iMessage应用

00:02:29.249 --> 00:02:30.651
是我编写的

00:02:30.717 --> 00:02:33.187
其中所有的API都会在
今天的演讲中学到

00:02:33.554 --> 00:02:35.856
如果看向模拟器这里
可以看到一个图标

00:02:35.923 --> 00:02:38.125
来自我的iMessage应用
叫“冰淇凌”

00:02:38.792 --> 00:02:41.995
点击它
iMessage应用将开始运行

00:02:42.062 --> 00:02:43.830
在Message范围里

00:02:44.431 --> 00:02:47.534
所有粉色背景的UI

00:02:47.601 --> 00:02:49.670
都是扩展提供的

00:02:50.637 --> 00:02:54.775
iMessage应用是一个合作的
冰淇凌贴纸制作应用

00:02:54.975 --> 00:02:58.412
可在此看到
我过去做好的冰淇凌贴纸

00:02:59.246 --> 00:03:01.582
点击“添加”按钮

00:03:02.282 --> 00:03:05.118
iMessage应用将会全屏显示

00:03:05.185 --> 00:03:08.822
这里会提供良好的制作贴纸用户体验

00:03:09.857 --> 00:03:13.460
选择一个冰淇凌蛋卷
iMessage应用会退出

00:03:13.527 --> 00:03:16.930
显示一条互动信息到输入框
供用户发送

00:03:19.166 --> 00:03:23.403
在iOS 10 我们添加了支持

00:03:23.504 --> 00:03:25.873
让用户自己编写和
测试iMessage应用

00:03:25.939 --> 00:03:27.241
就在模拟器里面

00:03:27.841 --> 00:03:30.210
回到对话列表

00:03:30.577 --> 00:03:33.814
可以看到模拟对话的两个终端

00:03:35.115 --> 00:03:38.752
点击第二个 显示接受信息的模拟器

00:03:40.220 --> 00:03:43.924
点击 iMessage应用运行进入

00:03:43.991 --> 00:03:45.692
冰淇淋制作过程的下一步

00:03:46.093 --> 00:03:48.328
我选择自己最爱的口味 薄荷脆皮

00:03:49.530 --> 00:03:52.332
显示该信息 发送

00:03:53.934 --> 00:03:56.436
现在 如果回到第一个对话

00:03:56.503 --> 00:03:58.205
或者第一个对话的最后

00:03:58.639 --> 00:04:00.140
点击该信息

00:04:00.941 --> 00:04:03.577
选择冰淇淋的最后一个部分 撒料

00:04:05.412 --> 00:04:06.346
发送

00:04:07.247 --> 00:04:10.150
现在我有了一个制作完整的冰淇凌

00:04:10.484 --> 00:04:13.754
事实上 若回到iMessage应用

00:04:14.621 --> 00:04:17.658
可以在冰淇淋历史清单中看到

00:04:17.724 --> 00:04:21.261
作为一个贴图 可以应用到任何地方

00:04:22.196 --> 00:04:25.098
这就是互动信息的一个简单例子

00:04:25.165 --> 00:04:26.466
请Alex回来继续讲

00:04:29.870 --> 00:04:30.904
谢谢你 Stephen

00:04:32.472 --> 00:04:36.243
这是关于iMessage应用
部分功能的一个很棒的快速演示

00:04:37.277 --> 00:04:41.215
我们来讲讲如何用API实现

00:04:41.915 --> 00:04:43.584
我将讲解四点

00:04:44.384 --> 00:04:47.821
首先 我将会概括浏览API

00:04:48.222 --> 00:04:51.959
然后第二点
稍微讲解一下扩展生命周期

00:04:52.626 --> 00:04:55.762
第三点 我们将会讲解

00:04:56.330 --> 00:04:58.966
如何用API编写信息

00:04:59.199 --> 00:05:00.400
第四点

00:05:00.467 --> 00:05:03.203
稍微讲讲信息是如何被发送的

00:05:05.072 --> 00:05:06.840
首先概括浏览API

00:05:08.742 --> 00:05:10.711
iMessage应用正在运行

00:05:10.777 --> 00:05:15.415
以简洁显示模式 这是一个扩展

00:05:15.649 --> 00:05:17.351
扩展有一个主类

00:05:17.417 --> 00:05:19.786
对于iMessage应用来说
这将是

00:05:19.853 --> 00:05:22.890
MSMessagesAppViewController的一个子类

00:05:22.956 --> 00:05:24.091
总而言之

00:05:24.157 --> 00:05:26.360
MSMessagesAppViewController是

00:05:26.426 --> 00:05:29.863
UIViewController
的一个子类 为扩展提供UI

00:05:31.331 --> 00:05:34.701
在扩展上面 有一个对话

00:05:35.002 --> 00:05:37.638
更确切地说 是对话文本

00:05:38.405 --> 00:05:42.409
它通过MSConversation
对象表示在API中

00:05:43.644 --> 00:05:45.779
最后是信息本身

00:05:45.846 --> 00:05:47.948
在文本里有这个泡泡框

00:05:48.048 --> 00:05:51.485
通过MSMessage类表示

00:05:52.052 --> 00:05:55.489
可以看到在本幻灯片中 还有两个类

00:05:55.556 --> 00:05:58.725
MSSession类
和MSMessageTemplateLayout类

00:05:58.792 --> 00:06:01.595
它们为如何发送信息提供相关控制

00:06:01.662 --> 00:06:03.997
以及信息该如何在文本里显示

00:06:05.966 --> 00:06:10.737
继续讲解iMessage
扩展生命周期

00:06:12.139 --> 00:06:17.344
在这里有一个时间线
如果一个扩展启动

00:06:18.078 --> 00:06:22.816
可能从应用抽屉里 将会启动一个进程

00:06:25.285 --> 00:06:29.289
此后不久 调用
didBecomeActive(with conversation)

00:06:29.356 --> 00:06:31.158
传入一个对话对象

00:06:31.225 --> 00:06:34.127
代表应用运行时的对话

00:06:35.128 --> 00:06:37.431
因为这是UIViewController的子类

00:06:37.497 --> 00:06:41.068
我们也调用了
viewWillAppear和viewDidAppear

00:06:41.835 --> 00:06:44.037
当扩展出现在屏幕上时

00:06:45.706 --> 00:06:48.976
如果应用从屏幕消失 会发生什么呢？

00:06:49.209 --> 00:06:51.378
我们把它称为“退出活跃”

00:06:51.578 --> 00:06:55.015
将会发生的事是 首先会收到
viewWillDisappear

00:06:55.215 --> 00:06:57.885
和在主类的
viewDidDisappear调用

00:06:58.785 --> 00:07:01.188
然后将会 抱歉

00:07:01.255 --> 00:07:05.058
然后将会调用
willResignActive(with conversation)

00:07:05.125 --> 00:07:07.928
此时 我们马上就要切断

00:07:07.995 --> 00:07:10.464
Messages和扩展的连接

00:07:11.265 --> 00:07:14.201
此时是可以进行对话操作的最后时间

00:07:15.035 --> 00:07:17.704
之后某个时间点 进程会被终止

00:07:17.771 --> 00:07:20.707
强调一下 这是因为进程

00:07:20.774 --> 00:07:23.477
建立在扩展上 而扩展是短暂的进程

00:07:23.544 --> 00:07:25.512
它们会迅速终止

00:07:27.281 --> 00:07:28.248
来看一下

00:07:28.315 --> 00:07:33.820
现在有一个进程在运行
在信息中显示UI

00:07:34.321 --> 00:07:36.723
用户将会和该UI进行互动

00:07:36.790 --> 00:07:40.694
编写一个信息 看看API如何处理

00:07:40.994 --> 00:07:44.331
首先创建一个MSMessage对象

00:07:44.531 --> 00:07:46.867
为该对象设置一些属性

00:07:48.135 --> 00:07:50.737
在本例中
设置一个Https URL

00:07:50.804 --> 00:07:52.873
所以信息有一个URL属性

00:07:53.106 --> 00:07:56.109
然后编写一些关于冰淇淋的细节

00:07:56.176 --> 00:07:58.078
在该URL的查询字符串中

00:07:58.245 --> 00:08:00.814
唯一可以产生

00:08:00.881 --> 00:08:02.716
这些信息的平台是iOS

00:08:02.783 --> 00:08:06.620
但这些信息将要发送给
macOS和watchOS

00:08:07.955 --> 00:08:09.189
当信息发送给macOS时

00:08:09.256 --> 00:08:12.259
它们会在对话文本里全保真显示

00:08:12.326 --> 00:08:15.996
点击文本中的一个信息

00:08:16.063 --> 00:08:18.565
将会试图在浏览器中打开该URL

00:08:18.665 --> 00:08:21.435
所以如果在这里提供了一个
https URL

00:08:22.336 --> 00:08:24.304
浏览器将会为用户

00:08:24.371 --> 00:08:29.476
在macOS上显示该信息

00:08:30.644 --> 00:08:33.746
继续 这里还有一个accessibilityLabel属性

00:08:33.914 --> 00:08:36.950
屏幕阅读器读取文本时将会使用

00:08:37.317 --> 00:08:40.153
所以 为它设置一个信息泡泡框的描述

00:08:40.220 --> 00:08:43.724
用屏幕阅读器的用户会看到

00:08:43.789 --> 00:08:47.094
关于泡泡框丰富的描述 显示在文本中

00:08:48.462 --> 00:08:51.098
最后我们来讲布局

00:08:51.331 --> 00:08:54.201
后面会多讲一些相关细节

00:08:55.869 --> 00:08:59.873
我们用布局对象指定

00:09:00.073 --> 00:09:01.708
文本中一条信息的外观

00:09:01.909 --> 00:09:05.913
现在只有一个布局
MSMessageTemplateLayout

00:09:06.747 --> 00:09:10.517
可以为它设置一些属性
将会影响制作泡泡框

00:09:11.718 --> 00:09:15.122
这里有一个图形属性 取一幅UI图片

00:09:15.489 --> 00:09:18.292
为屏幕上高亮显示区提供内容

00:09:19.560 --> 00:09:21.995
还有一个
mediaFileURL属性

00:09:22.296 --> 00:09:27.301
mediaFileURL
和image一样的区域提供内容

00:09:27.401 --> 00:09:30.938
但在这里
可以提供UI图片不支持的内容

00:09:31.004 --> 00:09:34.074
比如
可提供一个指向本地视频文件的URL

00:09:34.141 --> 00:09:36.276
一个短视频就会循环播放

00:09:36.343 --> 00:09:38.378
在文本里信息泡泡框的背景中

00:09:39.146 --> 00:09:42.316
让我们再多关注一下这两个属性

00:09:44.117 --> 00:09:48.222
首先注意到
如果图片和URL都被提供

00:09:48.288 --> 00:09:51.525
图片的优先级将会高于URL

00:09:53.660 --> 00:09:56.196
我们对尺寸有一些建议

00:09:56.263 --> 00:09:58.732
这些属性提供的资产的尺寸

00:09:59.099 --> 00:10:01.134
我们建议为资产提供的尺寸

00:10:01.201 --> 00:10:03.937
大约是300x300pt

00:10:04.037 --> 00:10:07.441
可以提供稍大或稍小的资产

00:10:07.508 --> 00:10:11.144
我强烈建议在这里多多测试资产大小

00:10:11.578 --> 00:10:15.249
为了找到最适合应用的尺寸

00:10:15.983 --> 00:10:19.753
所有这些资产和贴图一样
都三倍显示

00:10:19.820 --> 00:10:23.257
iMessages将会对
这些图片进行缩放

00:10:23.323 --> 00:10:25.492
当别的设备接收时显示合适大小

00:10:25.559 --> 00:10:28.695
根据接收设备屏幕分辨率

00:10:31.598 --> 00:10:35.702
mediaFileURL支持格式有
PNG JPEG GIF和视频文件

00:10:35.769 --> 00:10:39.106
视频文件是指 支持任何

00:10:39.173 --> 00:10:41.341
可在Media Player
框架里播放的视频

00:10:41.408 --> 00:10:44.244
建议参考
Media Player框架文档

00:10:44.311 --> 00:10:45.846
获取更详细信息

00:10:48.148 --> 00:10:50.350
关于该媒体文件还要做一点

00:10:50.417 --> 00:10:52.819
当发送时 我们会对资产进行转码

00:10:52.886 --> 00:10:56.089
这是为了对其在网络中传送进行优化

00:10:58.358 --> 00:11:03.230
最后我建议在该图片中不要加入文字

00:11:04.298 --> 00:11:06.533
我说过 这些图片都会按比例缩小

00:11:06.600 --> 00:11:09.703
显示在屏幕为1倍或2倍的设备上

00:11:09.770 --> 00:11:12.406
但我们要求按照3倍提供

00:11:12.506 --> 00:11:16.043
如果在该图片上添加文字
尤其是字体小的文字

00:11:16.143 --> 00:11:19.713
当这些图片缩小时 文字将看不清楚

00:11:20.848 --> 00:11:23.550
但是注意到我们在例子里确实这样做了

00:11:23.617 --> 00:11:25.519
图片上方有一些文字

00:11:26.186 --> 00:11:29.756
我们来讲解
如何在不降低质量的条件下实现这点

00:11:32.125 --> 00:11:34.528
布局对图片有一些额外的属性

00:11:34.595 --> 00:11:37.831
都是文本属性

00:11:38.732 --> 00:11:41.535
它们在信息里被转换

00:11:41.802 --> 00:11:44.137
然后在接收设备上绘制

00:11:44.204 --> 00:11:47.474
这样就可以把文本在接收设备上

00:11:47.541 --> 00:11:50.043
尽可能显示得非常清晰

00:11:51.178 --> 00:11:53.247
这里显示了图片标题

00:11:53.714 --> 00:11:56.016
这是画在图片上方的文字

00:11:56.316 --> 00:11:57.851
在左下角

00:11:58.952 --> 00:12:02.456
我们还有副标题 也是画在图片上的

00:12:02.523 --> 00:12:04.825
就在图片标题下面

00:12:05.092 --> 00:12:06.460
还有这些字幕属性

00:12:06.527 --> 00:12:09.363
都是在图片标题下方的标题栏绘制

00:12:09.429 --> 00:12:11.131
就是屏幕上的灰色区域

00:12:11.365 --> 00:12:14.601
所以 有了字幕 跟踪字幕

00:12:16.170 --> 00:12:20.474
第二字幕 跟踪第二字幕

00:12:25.212 --> 00:12:28.815
如果来看字幕属性

00:12:28.882 --> 00:12:31.251
有可能忽略所有

00:12:32.553 --> 00:12:33.854
或都设置为空

00:12:34.388 --> 00:12:35.455
如果这么做了

00:12:35.756 --> 00:12:38.992
就会有一个底部没有字幕栏的泡泡框

00:12:39.059 --> 00:12:40.861
就会看上去这个样子

00:12:42.162 --> 00:12:44.164
最后要说明的一点

00:12:44.665 --> 00:12:47.568
泡泡框左上角有一个图标

00:12:47.935 --> 00:12:51.872
该图表是Messages
在内容上方提供和绘制的

00:12:52.005 --> 00:12:55.576
通常都会是iMessage应用图标

00:12:56.310 --> 00:12:58.212
就是发送信息的应用的图标

00:13:00.447 --> 00:13:01.982
我们继续讲解

00:13:02.049 --> 00:13:04.318
如何发送编写的信息

00:13:07.221 --> 00:13:10.624
为了实现这点 需要一个
MSConversation的实例

00:13:10.791 --> 00:13:14.294
可以通过主类的activeConversation

00:13:15.229 --> 00:13:18.932
有了一个对话后
调用insert(message)

00:13:18.999 --> 00:13:20.801
传入编写完成的信息

00:13:21.401 --> 00:13:23.770
确保处理好任何返回错误

00:13:24.705 --> 00:13:27.774
这样做可以让信息显示在输入框

00:13:31.311 --> 00:13:32.880
当然 如演讲第一部分所提到的

00:13:32.946 --> 00:13:34.915
也可以发送其它类型的数据

00:13:34.982 --> 00:13:39.319
我们支持发送文本 附件

00:13:42.022 --> 00:13:43.457
当然还有贴图

00:13:45.993 --> 00:13:48.896
当输入框的内容完成

00:13:48.962 --> 00:13:52.332
用户可以通过点击
蓝色的“发送”按钮发送

00:13:52.399 --> 00:13:54.535
这里我要说明 扩展没有办法

00:13:54.601 --> 00:13:56.703
真正自动发送一条信息

00:13:56.770 --> 00:13:59.473
我们总是想让用户来决定

00:13:59.673 --> 00:14:01.775
把什么样的信息发送给朋友

00:14:04.111 --> 00:14:06.079
现在我把讲台交还给Stephen

00:14:06.146 --> 00:14:09.683
他将讲解该如何在示例项目中实现

00:14:17.558 --> 00:14:18.458
再次感谢 Alex

00:14:19.459 --> 00:14:23.463
我把之前用的示例
iMessage应用拿出来

00:14:23.530 --> 00:14:26.867
然后把它剥离到最基本的结构开始

00:14:27.367 --> 00:14:29.269
冰淇淋贴图之前制作的

00:14:29.336 --> 00:14:30.437
历史列表都还在

00:14:30.504 --> 00:14:33.841
但你会发现点击“添加”按钮时
没有反应

00:14:35.609 --> 00:14:36.710
在Xcode里

00:14:36.777 --> 00:14:40.280
显示了MSMessagesAppViewController子类

00:14:40.514 --> 00:14:43.884
我覆盖了周期方法
didBecomeActive(with conversation)

00:14:43.951 --> 00:14:46.887
调用super 然后调用
presentChildViewController

00:14:46.954 --> 00:14:48.589
它是我写的一个帮助方法

00:14:49.022 --> 00:14:52.559
将会初始化一个
IceCreamHistoryController

00:14:52.793 --> 00:14:55.229
并加入ChildViewController

00:14:55.429 --> 00:14:56.830
这就是目前的代码

00:14:58.298 --> 00:14:59.533
我现在想要做的是

00:14:59.600 --> 00:15:01.735
当点击“添加”按钮时

00:15:01.802 --> 00:15:04.338
就会开始制作贴图的进程

00:15:04.938 --> 00:15:08.408
该IceCreamHistoryViewController
有一个委托协议

00:15:08.475 --> 00:15:11.111
我有一个MessagesViewController扩展

00:15:11.178 --> 00:15:12.279
将符合该委托协议

00:15:12.346 --> 00:15:14.414
通过调用historyViewController

00:15:14.481 --> 00:15:16.116
AddButtonTapped

00:15:17.351 --> 00:15:20.420
在这里我将要触发功能

00:15:21.488 --> 00:15:25.092
还要添加一个帮助方法

00:15:25.158 --> 00:15:29.129
叫作composeMessage(for iceCream)
将会接受一个IceCream对象参数

00:15:29.196 --> 00:15:33.033
然后返回到一个MSMessage
可以用于对话中

00:15:34.101 --> 00:15:38.005
要实现这一点 新建一个
URLComponents实例

00:15:38.105 --> 00:15:40.407
再把该URLComponents的
QueryItems属性设置为

00:15:40.474 --> 00:15:42.709
模块的queryItems属性

00:15:44.178 --> 00:15:45.612
下一步是

00:15:45.712 --> 00:15:48.749
新建一个MSMessageTemplateLayout实例

00:15:48.815 --> 00:15:52.052
并把该布局的image属性设置为
模块的渲染模式

00:15:53.253 --> 00:15:55.589
我还想为信息设置字幕

00:15:55.989 --> 00:15:57.724
我会在上面这里声明

00:16:02.396 --> 00:16:04.765
现在我准备好
新建MSMessage对象

00:16:07.334 --> 00:16:10.037
声明一个MSMessage实例

00:16:10.137 --> 00:16:13.974
把URL属性设置为我的
components的URL属性

00:16:14.474 --> 00:16:17.144
然后设置布局
和accessibilityLabel属性

00:16:17.211 --> 00:16:19.479
为了演示简单 我重新使用了messageCaption

00:16:19.546 --> 00:16:22.082
作为accessibilityLabel属性

00:16:23.884 --> 00:16:26.453
现在信息已经建立完成
要发送到对话中

00:16:27.120 --> 00:16:29.323
我要引用activeConversation

00:16:30.524 --> 00:16:33.227
然后调用conversation.insert

00:16:34.494 --> 00:16:37.097
把信息插入 写好了

00:16:38.232 --> 00:16:40.367
已写好
composeMessage函数

00:16:41.001 --> 00:16:41.969
这里我要调用它

00:16:42.035 --> 00:16:44.538
通过HistoryViewController
AddButtonTapped方法

00:16:47.474 --> 00:16:52.579
我总会从添加或传递一个
新的IceCream实例开始

00:16:54.815 --> 00:16:56.850
现在在iOS模拟器中运行

00:16:57.851 --> 00:16:59.753
启动iMessage应用

00:17:01.755 --> 00:17:05.692
等待调试器载入 点击加号按钮

00:17:06.193 --> 00:17:08.127
信息显示给用户可以发送

00:17:08.729 --> 00:17:10.763
因为我并没有真正选择冰淇凌的部分

00:17:10.830 --> 00:17:13.767
我只是有一个冰淇淋的图片框

00:17:13.934 --> 00:17:15.969
可以看到信息下面的字幕

00:17:17.037 --> 00:17:18.539
开头开得不错

00:17:18.805 --> 00:17:22.041
但是我想离开始时的那个演示更近一步

00:17:22.809 --> 00:17:24.243
当我点击加号按钮时

00:17:24.310 --> 00:17:27.047
我想马上进入贴图制作UI体验

00:17:28.015 --> 00:17:30.851
为了实现 需要介绍一个新概念

00:17:31.685 --> 00:17:35.255
在这里iMessage应用
正显示为简洁显示风格

00:17:36.089 --> 00:17:38.091
我可以选择让iMessage应用

00:17:38.158 --> 00:17:40.994
显示为展开显示风格 通过添加代码

00:17:42.663 --> 00:17:45.199
在这里不再调用
composeMessage(for:iceCream())

00:17:45.599 --> 00:17:47.634
而是在父类上调用

00:17:47.968 --> 00:17:51.271
requestPresentationStyle方法
参数为枚举expanded

00:17:52.339 --> 00:17:55.576
这将触发一个生命周期回调方法 叫作

00:17:55.642 --> 00:17:58.512
willTransition(to presentationStyle)

00:17:59.780 --> 00:18:01.949
调入super实现

00:18:05.619 --> 00:18:07.120
然后调用帮助方法

00:18:07.187 --> 00:18:10.524
为该显示风格显示其
正确的子视图控制器

00:18:12.359 --> 00:18:13.727
现在我的presentChildViewController

00:18:13.794 --> 00:18:16.730
总是显示当前的
IceCreamHistoryViewController

00:18:16.897 --> 00:18:20.133
所以我需要改变显示风格改变的逻辑

00:18:20.200 --> 00:18:22.169
这样才可以显示正确的视图控制器

00:18:23.070 --> 00:18:25.239
首先要添加一个参数 这样我才知道

00:18:25.305 --> 00:18:27.174
正在处理哪个显示风格

00:18:28.208 --> 00:18:29.676
然后我要把这段代码改为

00:18:31.478 --> 00:18:33.514
只显示historyViewController

00:18:33.580 --> 00:18:35.315
当处于简洁显示风格时

00:18:36.517 --> 00:18:39.319
如果正处于展开显示风格

00:18:39.386 --> 00:18:42.155
将声明一个新的IceCream实例

00:18:42.789 --> 00:18:48.762
让我的controller成为
IceCreamBuilderController的一个实例

00:18:49.129 --> 00:18:50.898
传入刚刚声明的iceCream

00:18:52.666 --> 00:18:56.170
最后 在我把它添加为
子视图控制器以前

00:18:56.236 --> 00:19:00.007
需要移除所有之前的子视图控制器

00:19:00.073 --> 00:19:01.508
清理视图层次结构

00:19:04.077 --> 00:19:06.880
现在我需要更新帮助方法的调用地点

00:19:08.749 --> 00:19:14.121
这里我将把正在等待的
显示风格传递给方法

00:19:15.122 --> 00:19:17.624
在didBecomeActive(with conversation)方法中

00:19:17.891 --> 00:19:20.627
为它传递当前的显示风格

00:19:20.694 --> 00:19:24.331
可以把它作为父视图控制器的一个属性

00:19:28.902 --> 00:19:29.770
应该没错

00:19:31.038 --> 00:19:34.274
最后——事实上让我们

00:19:34.341 --> 00:19:37.678
先看看这样能不能实现

00:19:46.653 --> 00:19:48.188
点击加号按钮

00:19:48.755 --> 00:19:51.325
我的iMessage应用
进入展开状态

00:19:51.391 --> 00:19:54.361
正在显示冰淇淋制作体验

00:19:55.162 --> 00:19:57.865
然而 你会发现点击“选择”
什么都没发生

00:19:58.232 --> 00:20:00.567
这是因为我的iceCreambuilderviewcontroller

00:20:00.634 --> 00:20:03.937
也有一个委托协议 也有一个扩展

00:20:04.238 --> 00:20:08.275
在这里的视图控制器上
抱歉有点太快了

00:20:10.177 --> 00:20:12.312
该委托协议

00:20:12.379 --> 00:20:14.615
通过
iceCreamBuilderViewController方法实现

00:20:14.681 --> 00:20:16.550
didSelect iceCreamPart,for iceCream

00:20:17.618 --> 00:20:20.254
只要点击选择按钮 该方法就会被调用

00:20:21.421 --> 00:20:24.525
这里正好可以调用我写的帮助方法

00:20:24.591 --> 00:20:26.627
composeMessage
我将传递

00:20:26.693 --> 00:20:28.729
更新过的iceCream给它

00:20:29.730 --> 00:20:32.499
我还要做的一件事是
调用dismiss方法

00:20:32.933 --> 00:20:36.803
因为iMessage应用
已经完成内容准备

00:20:36.904 --> 00:20:38.605
我想要iMessage应用退出

00:20:38.672 --> 00:20:40.841
为用户显示完成消息

00:20:50.784 --> 00:20:54.521
启动应用 点击加号按钮

00:20:55.155 --> 00:20:56.423
选中一个冰淇凌蛋卷

00:20:57.591 --> 00:20:59.626
退出iMessage应用

00:20:59.693 --> 00:21:03.363
互动消息准确地显示 用户可以发送

00:21:03.630 --> 00:21:05.566
这就是如何发送互动信息

00:21:05.632 --> 00:21:07.201
的一个快速演示

00:21:07.267 --> 00:21:08.302
交回给Alex

00:21:15.676 --> 00:21:17.311
谢谢你 Alex 非常棒

00:21:19.613 --> 00:21:20.447
所以

00:21:22.883 --> 00:21:26.787
Stephen为大家介绍
和演示了如何使用API

00:21:27.254 --> 00:21:30.257
添加内容到一个对话并发送

00:21:30.958 --> 00:21:33.560
Stephen还介绍了显示风格

00:21:33.827 --> 00:21:36.563
我们将进一步讲解其更多细节

00:21:37.898 --> 00:21:41.401
我们有两种显示风格 简洁和展开

00:21:42.336 --> 00:21:46.373
左边是简洁风格 右边是展开风格

00:21:48.675 --> 00:21:52.346
这两种风格之间有一些不同

00:21:52.913 --> 00:21:55.649
在简洁模式 无法访问键盘

00:21:56.416 --> 00:21:57.684
而且也

00:21:57.885 --> 00:22:02.122
无法横向滚动 以及无法辨识滑动手势

00:22:02.656 --> 00:22:06.426
这是因为在简洁模式
用户可以向左或向右滑动

00:22:07.294 --> 00:22:09.596
在iMessage应用之间快速切换

00:22:11.498 --> 00:22:14.434
然而 还是可以访问输入框

00:22:14.501 --> 00:22:18.639
不论何时
在简洁显示风格里调用插入信息

00:22:18.972 --> 00:22:21.942
信息都会马上插入到输入框里

00:22:22.342 --> 00:22:24.311
用户可以立即看到

00:22:24.811 --> 00:22:27.047
后续调用插入信息

00:22:27.114 --> 00:22:30.050
将会用新的信息取代当前信息

00:22:30.117 --> 00:22:34.555
这里你可以允许用户反复编写信息

00:22:34.621 --> 00:22:36.890
看到它在输入框里的进展

00:22:36.957 --> 00:22:39.059
直到满意后 就可以发送

00:22:41.562 --> 00:22:44.498
与此相对的 在展开显示风格里

00:22:44.565 --> 00:22:47.167
显然无法访问输入框

00:22:47.334 --> 00:22:51.839
但却可以访问横向滑动手势辨识和滚动

00:22:52.206 --> 00:22:53.974
也可以使用键盘

00:22:58.612 --> 00:23:01.582
用户随时可以在扩展中进行转换

00:23:01.648 --> 00:23:06.119
在两种风格间转换 只需点击上方的图标
从展开转换到折叠

00:23:06.320 --> 00:23:08.589
从而转换到简洁风格

00:23:08.722 --> 00:23:12.526
在简洁风格下
可以点击屏幕下方的图标

00:23:12.593 --> 00:23:15.596
把应用展开成展开显示风格

00:23:15.762 --> 00:23:19.499
当在使用iMessage应用时
响应需要非常及时

00:23:19.600 --> 00:23:24.004
在应用显示的的区域

00:23:26.673 --> 00:23:28.475
任何时候转换发生时

00:23:28.542 --> 00:23:31.478
都会出现主类的回调

00:23:32.279 --> 00:23:36.850
转换开始后 将会调用
willTransition(to:presentationStyle)

00:23:37.718 --> 00:23:40.654
最后 当转换结束时

00:23:40.721 --> 00:23:43.290
将会调用
didTransition(to:presentationStyle)

00:23:45.192 --> 00:23:49.029
如Stephen所演示的
你可以要求显示风格为展开

00:23:49.463 --> 00:23:53.267
或简洁 只需调用
requestPresentationStyle方法

00:23:53.333 --> 00:23:54.868
在主类中

00:23:55.435 --> 00:23:57.838
如演示里所提到的
可以调用dismiss

00:23:57.905 --> 00:24:00.874
iMessage应用将退出
并显示键盘

00:24:03.443 --> 00:24:06.413
我们继续讨论如何回复信息

00:24:08.482 --> 00:24:10.484
这里介绍两种情况

00:24:11.318 --> 00:24:12.986
一种情况是扩展处于非活动状态

00:24:13.053 --> 00:24:15.956
文本里有一个用户点击的泡泡框

00:24:16.023 --> 00:24:17.758
我们首先来看这种情况

00:24:18.559 --> 00:24:20.260
之后回来看第二种

00:24:22.729 --> 00:24:26.166
再看看时间线 应该看上去很熟悉

00:24:27.801 --> 00:24:29.903
用户点击泡泡框

00:24:30.671 --> 00:24:32.606
进程启动

00:24:33.907 --> 00:24:36.076
经过完全相同的步骤

00:24:36.143 --> 00:24:38.879
和应用从应用抽屉启动的过程一样

00:24:39.613 --> 00:24:42.249
将会调用
didBecomeActive(with conversation)

00:24:42.449 --> 00:24:45.886
然后是viewWillAppear
和viewDidAppear

00:24:45.986 --> 00:24:47.588
这些步骤完成后

00:24:47.654 --> 00:24:50.924
应用将会显示成展开显示风格

00:24:52.392 --> 00:24:56.396
我们总以展开显示风格展示应用

00:24:56.463 --> 00:24:58.799
当用户点击一个按钮启动 抱歉

00:24:58.866 --> 00:25:01.235
是点击文本里的泡泡框来启动

00:25:02.870 --> 00:25:07.541
现在来看第二种情况
扩展已经处于活跃

00:25:07.608 --> 00:25:11.578
本例中 正处于简洁显示风格

00:25:13.814 --> 00:25:15.582
再看一次时间线

00:25:15.649 --> 00:25:19.086
这次 点击泡泡框 应用处于活跃

00:25:19.419 --> 00:25:23.590
所以 不会调用willBecomeActive
或者didBecomeActive

00:25:23.657 --> 00:25:26.326
将会调用willTransition

00:25:26.393 --> 00:25:28.929
(to presentationStyle)方法

00:25:29.263 --> 00:25:32.866
然后调用didSelect方法
带有message和conversation参数

00:25:33.834 --> 00:25:35.536
在主类上进行调用

00:25:35.602 --> 00:25:38.172
让你知道用户点击了文本里的泡泡框

00:25:38.238 --> 00:25:40.174
并选中一条信息

00:25:41.041 --> 00:25:44.645
最后当展开显示风格转换完成

00:25:44.711 --> 00:25:47.447
将会调用didTransition(to presentationStyle)

00:25:50.050 --> 00:25:52.719
在两个时间线的最后

00:25:53.020 --> 00:25:56.757
应用的UI显示展开显示风格

00:25:56.823 --> 00:25:59.626
而你想访问被点击的信息

00:26:00.127 --> 00:26:04.765
实现方法是用MSConversation的
selectedMessage属性

00:26:04.831 --> 00:26:07.201
可以从当前活跃的对话中获得

00:26:07.267 --> 00:26:08.769
在主类上

00:26:10.537 --> 00:26:14.074
你会想要把选中的信息显示在UI上

00:26:14.274 --> 00:26:16.610
并允许用户编写回复

00:26:18.312 --> 00:26:20.047
再次请Stephen上台

00:26:20.113 --> 00:26:24.084
他将做最后一个演示
如何在示例应用中实现回复

00:26:31.024 --> 00:26:34.628
好的 刚才离开时
正有一个准备发的信息

00:26:34.695 --> 00:26:36.063
我会把它发出去

00:26:37.331 --> 00:26:39.399
回到对话表

00:26:39.933 --> 00:26:41.935
打开对话的另一端

00:26:42.402 --> 00:26:44.004
可以看到收到的信息

00:26:44.838 --> 00:26:48.375
点击该信息
iMessage应用正常启动

00:26:48.475 --> 00:26:50.611
然而 冰淇凌制作体验

00:26:50.677 --> 00:26:52.880
并没有显示冰淇凌制作过程的下一步骤

00:26:52.946 --> 00:26:54.915
我还没办法选择冰淇凌球

00:26:55.716 --> 00:26:59.152
这是因为每次显示当前的视图控制器

00:26:59.219 --> 00:27:01.522
总是传入一个新的冰淇凌模块对象

00:27:02.122 --> 00:27:05.292
我需要做的是 找到对话中的选中信息

00:27:05.359 --> 00:27:08.795
如果信息中存在冰淇凌模块对象
就要使用

00:27:10.063 --> 00:27:11.798
回到上面这里

00:27:13.467 --> 00:27:16.170
到新建IceCreamBuilderController实例的地方

00:27:17.070 --> 00:27:19.873
引用activeConversation

00:27:22.876 --> 00:27:25.312
使用一个可失败构造器

00:27:26.079 --> 00:27:28.982
查看对话中的信息

00:27:29.850 --> 00:27:33.353
如果构造失败 就意味着没有进展

00:27:33.420 --> 00:27:35.556
我就会新建一个冰淇凌模块

00:27:35.622 --> 00:27:38.959
如果存在 则传入进展中的冰淇凌

00:27:40.327 --> 00:27:44.531
还要确认的一件事是
要传入正确的字幕文本

00:27:44.631 --> 00:27:48.168
根据选中的冰淇凌零件

00:27:49.970 --> 00:27:55.242
为了实现 需要传入一个新参数给方法

00:27:55.309 --> 00:27:56.977
就是selectedIceCreamPart

00:28:00.013 --> 00:28:02.850
这个messageCaption
我要变成一个声明

00:28:03.183 --> 00:28:07.487
为字符串类型
然后使用switch方法

00:28:08.555 --> 00:28:11.959
在selectedIceCreamPart上
来选择合适的messageCaption

00:28:16.630 --> 00:28:19.399
我还要需要更新调用该方法的地址

00:28:19.733 --> 00:28:21.802
这里 传入新的参数

00:28:34.481 --> 00:28:36.216
当启动iMessage应用时

00:28:37.351 --> 00:28:40.654
点击加号按钮 发出第一条信息

00:28:42.189 --> 00:28:46.026
回到对话表 进入对话另一端

00:28:47.294 --> 00:28:48.929
点击接收到的信息

00:28:48.996 --> 00:28:52.566
现在冰淇凌制作视图控制器显示正常

00:28:52.633 --> 00:28:53.934
可以选择冰淇凌球

00:28:55.903 --> 00:28:57.404
我可以选择薄荷脆皮

00:28:59.206 --> 00:29:00.073
发送

00:29:01.708 --> 00:29:03.710
再回到对话的另一端

00:29:05.145 --> 00:29:06.446
选择撒料

00:29:09.416 --> 00:29:13.020
这就是发送和接收互动信息的情况

00:29:13.086 --> 00:29:15.255
以及如何合作完成一个任务

00:29:16.723 --> 00:29:18.892
然而 可以看到在对话界面里

00:29:18.959 --> 00:29:22.129
那些未完成的冰淇凌
让对话看起来有点乱

00:29:23.230 --> 00:29:25.199
我并不想看未完成冰淇凌

00:29:25.265 --> 00:29:27.467
我只想看冰淇凌成品

00:29:28.802 --> 00:29:31.839
我想折叠所有之前的信息

00:29:31.905 --> 00:29:35.442
也许可以留下那些信息的简明总结

00:29:35.943 --> 00:29:38.846
为了实现 我将使用一个
新的对象MSSession

00:29:39.012 --> 00:29:40.380
把信息合到一组

00:29:43.350 --> 00:29:45.319
这里当编写信息时

00:29:47.054 --> 00:29:50.123
移动activeConversation引用

00:29:52.059 --> 00:29:54.194
当声明session对象时

00:29:56.363 --> 00:30:00.901
查看selectedMessage
是否存在于会话中

00:30:01.235 --> 00:30:04.404
如果是 则选择该信息
将会在同个分组中继续

00:30:05.138 --> 00:30:07.474
否则 新建一个
MSSession对象

00:30:09.343 --> 00:30:11.044
然后把该session传入这里

00:30:12.346 --> 00:30:14.715
到MSMessage构造器

00:30:17.484 --> 00:30:18.585
另一件事是

00:30:18.652 --> 00:30:21.555
当信息折叠时提供一个很好的信息总结

00:30:23.891 --> 00:30:28.095
这里声明一个变量
叫summaryText

00:30:29.863 --> 00:30:32.799
这里我会选择显示不同的
summaryText

00:30:32.866 --> 00:30:36.603
根据不同的selectedIceCreamPart

00:30:39.706 --> 00:30:44.211
我可以把summaryText变量
传给MSMessage对象

00:30:47.281 --> 00:30:48.582
好了

00:30:50.250 --> 00:30:51.652
哦 可能需要指定

00:30:54.588 --> 00:30:55.489
这下完成了

00:31:01.628 --> 00:31:03.363
现在启动iMessage应用

00:31:05.299 --> 00:31:08.135
进行制作冰淇淋的过程

00:31:12.339 --> 00:31:13.941
冰淇凌看上去不错吧

00:31:16.510 --> 00:31:19.279
选择冰淇凌口味

00:31:20.080 --> 00:31:23.650
可以看到折叠起来的摘要文本

00:31:23.917 --> 00:31:26.820
当发送信息时可以看到

00:31:28.889 --> 00:31:33.393
如果我回到对话的第一部分

00:31:34.661 --> 00:31:36.129
再次点击信息

00:31:36.897 --> 00:31:39.032
现在我觉得巧克力撒料不错

00:31:42.102 --> 00:31:44.605
发送后 冰淇凌信息完整了

00:31:44.705 --> 00:31:49.209
但是只显示了一张图片

00:31:49.276 --> 00:31:52.179
整个文本中都有很好的摘要说明

00:31:53.747 --> 00:31:57.217
并且 当进入冰淇凌应用之后

00:31:57.851 --> 00:32:00.120
可以看到全新完成的冰淇凌贴图

00:32:00.187 --> 00:32:02.189
可以任我所用

00:32:03.123 --> 00:32:05.459
完成了 这就是完整的示例应用

00:32:06.093 --> 00:32:08.328
这个例子展示了如何编写

00:32:08.862 --> 00:32:11.298
一个互动贴图制作应用

00:32:11.365 --> 00:32:13.166
但是可以用这种方法做任何事

00:32:13.233 --> 00:32:16.036
可以集合各种优质服务

00:32:16.503 --> 00:32:19.673
编写优秀的合作游戏
我迫不及待想看看你们的成果

00:32:19.973 --> 00:32:21.074
交回给Alex

00:32:24.411 --> 00:32:26.346
谢谢你 Stephen
另一个非常棒的演示

00:32:26.413 --> 00:32:28.982
Stephen实现了回复

00:32:29.216 --> 00:32:32.719
并引入了新的对象MSSession

00:32:33.020 --> 00:32:35.255
来看一下MSSession

00:32:38.759 --> 00:32:39.760
之前在演示里看到的

00:32:39.826 --> 00:32:43.697
是含有很多未完成冰淇凌的
乱糟糟的文本

00:32:44.064 --> 00:32:45.866
我们看到如何用MSSession

00:32:45.966 --> 00:32:49.002
把它进程处理 变成

00:32:49.069 --> 00:32:53.173
像这样的 更为干净整洁 非常好

00:32:55.209 --> 00:32:58.445
实现它我们用了
MSSession对象

00:32:58.512 --> 00:33:00.414
新建一个MSSession

00:33:01.582 --> 00:33:02.916
对第一条信息

00:33:02.983 --> 00:33:05.719
是对话的一部分 我们传入新建的会话

00:33:05.786 --> 00:33:08.889
进入该构造器 有了这个会话信息

00:33:10.123 --> 00:33:12.593
还可以设置摘要文本

00:33:14.595 --> 00:33:17.297
我们利用对话的
insert(message)发送

00:33:17.364 --> 00:33:18.665
如之前所见

00:33:21.869 --> 00:33:23.871
当回复一条会话信息时

00:33:23.937 --> 00:33:27.674
我们不想新建一个会话
而是再次使用已有的会话

00:33:27.941 --> 00:33:30.010
我们可以获取当前会话

00:33:30.310 --> 00:33:31.712
从当前对话中

00:33:31.778 --> 00:33:34.181
activeConversation.selectedMessage

00:33:34.248 --> 00:33:36.984
selectedMessage
将有一个session属性

00:33:37.050 --> 00:33:38.619
如果它是一个会话信息

00:33:41.889 --> 00:33:44.791
然后我们取出该session属性

00:33:44.858 --> 00:33:47.494
传入信息构造器 如之前所见

00:33:50.230 --> 00:33:52.999
在这里summaryText
提供了文本

00:33:53.066 --> 00:33:55.903
在对话文本中对信息进行总结

00:33:56.770 --> 00:34:00.374
现在也可以忽略该属性 把它设为空

00:34:00.807 --> 00:34:02.109
如果这么做的话

00:34:02.276 --> 00:34:05.913
在文本中就没有
summaryText的入口

00:34:05.979 --> 00:34:09.516
但是信息还是会参与到会话行为

00:34:09.583 --> 00:34:11.518
我们讲解了API的基本要点

00:34:11.585 --> 00:34:14.388
也看到该如何编写一个
非常简单的iMessage应用

00:34:14.755 --> 00:34:18.824
可以在朋友间发送互动信息

00:34:20.527 --> 00:34:24.797
我们将继续讨论API的一些高级特性

00:34:28.835 --> 00:34:32.906
我们将从主类上更多覆盖方法开始

00:34:34.041 --> 00:34:36.877
然后继续讨论分组对话

00:34:38.178 --> 00:34:42.014
最后讨论如何辨别
某一特定信息的发送者

00:34:45.485 --> 00:34:48.288
首先 当用户发送一条信息时

00:34:48.355 --> 00:34:51.859
我们意识到
也许应用想知道发生了什么

00:34:52.693 --> 00:34:55.529
比如 若你是一个游戏 用户做出移动

00:34:55.896 --> 00:34:58.565
我们需要知道什么时候更新模块
记录这次移动

00:34:58.632 --> 00:35:02.035
这需要在信息缺失发送出去之后发生

00:35:03.837 --> 00:35:09.743
所以 我们有一个didStartSending(_message)方法

00:35:09.810 --> 00:35:14.214
在主类上
当用户点击发送按钮时会被调用

00:35:14.481 --> 00:35:15.616
这点很重要

00:35:15.682 --> 00:35:16.917
并不意味着

00:35:16.984 --> 00:35:20.254
信息已经真正被发送

00:35:20.320 --> 00:35:22.923
只是意味着用户点击了发送按钮

00:35:22.990 --> 00:35:26.860
然后它传递了发送消息的企图

00:35:29.029 --> 00:35:32.199
同样我们还有一个方法叫做
didCancelSending

00:35:32.833 --> 00:35:37.004
发生在当用户点击十字

00:35:37.070 --> 00:35:38.906
在信息泡泡框的右上角

00:35:39.473 --> 00:35:41.675
didCancelSending
可以清除

00:35:41.742 --> 00:35:45.612
任何编写该信息时 累积的的资源

00:35:47.748 --> 00:35:50.851
最后 我们还有
didReceive(_message)方法

00:35:52.252 --> 00:35:54.354
didReceive(_message)方法发生在

00:35:54.421 --> 00:35:57.925
被调用 当应用正在运行或处于活跃

00:35:57.991 --> 00:36:01.428
一条信息来自一个接收者

00:36:01.495 --> 00:36:03.597
对话的某一个参与者

00:36:04.198 --> 00:36:06.567
这非常有用 比如

00:36:06.633 --> 00:36:08.235
如果应用有

00:36:08.302 --> 00:36:10.871
如果用户正在编辑一条会话信息

00:36:10.938 --> 00:36:13.307
在同一个会话中另一条信息进来

00:36:13.373 --> 00:36:18.579
这是状态更新 你需要更新
显示该状态的UI

00:36:20.013 --> 00:36:22.482
让我们继续讲解分组对话

00:36:22.616 --> 00:36:25.452
iMessage应用
可应用到分组对话中

00:36:25.519 --> 00:36:28.155
当建立分组对话时需要考虑这些问题

00:36:29.790 --> 00:36:31.124
我们在这里

00:36:31.191 --> 00:36:35.696
有一个示例对话 来自三个朋友
Amber Ben和Chris

00:36:37.831 --> 00:36:39.666
Ben给每个人发送了冰淇凌

00:36:40.868 --> 00:36:43.637
然后他发送了一个问题
给Amber和Chris

00:36:43.704 --> 00:36:45.973
你们想要在冰淇凌上面加什么撒料

00:36:46.039 --> 00:36:48.041
巧克力酱还是彩粉？

00:36:51.512 --> 00:36:54.014
Amber将要回复巧克力酱

00:36:54.648 --> 00:36:57.684
Chris将要回复彩粉

00:36:58.986 --> 00:37:02.222
这两个用户将在完全相同的时间回复

00:37:04.591 --> 00:37:07.127
现在关注一下Ben

00:37:08.362 --> 00:37:11.265
看看他的设备
对收到的信息会做何种处理

00:37:12.466 --> 00:37:17.404
首先 Amber的回复
先到达Ben的设备

00:37:17.471 --> 00:37:20.841
不久以后 就是来自Chris的回复

00:37:21.375 --> 00:37:26.747
你可以发现
Amber的回复变成了摘要信息

00:37:26.813 --> 00:37:30.417
Chris的回复显示在对话
最后的泡泡框里

00:37:32.619 --> 00:37:35.322
另一种情况也是如此

00:37:37.357 --> 00:37:38.525
需要注意的是

00:37:38.592 --> 00:37:42.062
只有点击的信息
在iMessage应用里可用

00:37:43.063 --> 00:37:47.734
所以例子里
我们无法访问Amber的回复

00:37:48.135 --> 00:37:49.203
这该如何处理？

00:37:49.803 --> 00:37:53.273
现在 我们建议把状态储存在云端

00:37:54.041 --> 00:37:57.077
也就是说MSMessage的

00:37:57.144 --> 00:38:01.982
来自和发给对话参与者的URL属性

00:38:02.049 --> 00:38:06.119
只需要作出表示会话的标记

00:38:07.888 --> 00:38:10.490
然后你会接收到会话当前状态

00:38:10.724 --> 00:38:13.327
当用户点击一条信息

00:38:13.660 --> 00:38:15.028
以及当用户发送一条信息时

00:38:15.095 --> 00:38:18.165
你应该把当前会话状态存入云端

00:38:20.667 --> 00:38:23.203
继续 我们讨论发送者标识符

00:38:27.741 --> 00:38:31.411
回到Amber Ben
和Chris的对话

00:38:32.946 --> 00:38:38.619
在这个情境
Amber回复了想要巧克力酱

00:38:38.785 --> 00:38:40.320
Chris还没有回复

00:38:42.389 --> 00:38:44.558
再次关注Ben的设备

00:38:45.692 --> 00:38:48.762
这里有一条信息 但不知道是谁发的

00:38:51.365 --> 00:38:54.168
但是我们可以找出相关信息

00:38:54.668 --> 00:38:59.873
这里有发送者参与者标识符

00:38:59.940 --> 00:39:02.109
抱歉 重说一遍

00:39:02.476 --> 00:39:05.045
这里有参与者标识符

00:39:05.579 --> 00:39:08.782
Apple对用户隐私非常非常重视

00:39:08.916 --> 00:39:12.352
我们非常尊重客户的隐私

00:39:12.419 --> 00:39:16.690
我们完全不对iMessage应用
显示任何联系人信息

00:39:18.258 --> 00:39:21.195
取而代之
我们提供了这些参与者标识符

00:39:22.429 --> 00:39:25.766
在Ben的设备上
他有一个本地参与者标识符

00:39:25.832 --> 00:39:30.170
这是一个UUID
在该设备上代表Ben

00:39:31.038 --> 00:39:35.042
他还有两个远程参与者标识符

00:39:35.709 --> 00:39:40.214
代表了对话中的其余参与者

00:39:40.280 --> 00:39:43.217
本例中 有两个
Amber和Chris

00:39:45.085 --> 00:39:46.587
看一下进来的信息

00:39:46.653 --> 00:39:49.256
我们看见该信息有一个发送者标识符

00:39:49.756 --> 00:39:54.728
它将映射一个Ben的列表中的
本地参与者标识符

00:39:55.963 --> 00:40:00.734
回到大图
来看Amber和Chris的设备

00:40:00.801 --> 00:40:06.540
正在发送的信息有发送者标识符

00:40:07.741 --> 00:40:14.515
它们映射到每一个发送信息的
设备本地标识符

00:40:18.752 --> 00:40:20.954
可以利用这些标识符

00:40:21.021 --> 00:40:23.924
获取对话中参与者的数量

00:40:24.992 --> 00:40:28.495
可以把信息归属于一个发送者
所以一旦接收了某条信息

00:40:28.562 --> 00:40:30.297
带有特定的发送者标识符

00:40:30.364 --> 00:40:32.866
然后接收了第二条
有着相同标识符的信息

00:40:32.933 --> 00:40:34.801
你知道它们都来自同一个用户

00:40:35.936 --> 00:40:40.874
还可以和网络服务相结合

00:40:41.074 --> 00:40:44.545
可以用于帮助确定身份

00:40:45.546 --> 00:40:46.847
还有一点

00:40:48.415 --> 00:40:51.084
可以在这些标识符或标识符字符串

00:40:51.151 --> 00:40:56.390
前面加上一个$符号 写在任何传递给

00:40:56.456 --> 00:40:59.326
MessageTemplateLayout
文本属性的文本中

00:40:59.393 --> 00:41:02.663
同样 你还可以把这些标识符写入

00:41:02.729 --> 00:41:06.567
要传递给summaryText
属性的文本中

00:41:07.601 --> 00:41:09.469
当信息显示UI

00:41:09.536 --> 00:41:12.606
在泡泡框里的文本带有这种类型格式时

00:41:12.906 --> 00:41:16.143
它将会把标识符替换为

00:41:16.643 --> 00:41:19.379
其标识符映射的联系人姓名

00:41:27.521 --> 00:41:31.158
每一个设备的标识符都是唯一的

00:41:31.225 --> 00:41:32.492
若你留意之前的幻灯片里

00:41:32.559 --> 00:41:35.696
每台设备的每个人的标识符都是不同的

00:41:37.297 --> 00:41:40.968
它们的范围局限在iMessage
应用的安装里

00:41:41.134 --> 00:41:42.469
这指的是

00:41:42.536 --> 00:41:46.240
这些标识符本身将在
一定时间内保持恒定

00:41:47.508 --> 00:41:52.479
但若用户删除了iMessage应用
之后重装

00:41:52.846 --> 00:41:54.381
就会有一个完全不同的

00:41:54.548 --> 00:41:57.985
标识符集合 在同样的对话里

00:42:00.654 --> 00:42:02.723
你可以取得发送者参与者标识符

00:42:02.789 --> 00:42:07.094
在MSMessage使用
senderParticipantIdentifier属性

00:42:07.594 --> 00:42:11.832
还可以通过对话取得本地参与者标识符

00:42:12.299 --> 00:42:15.302
利用
localParticipantIdentifier属性

00:42:16.336 --> 00:42:19.973
还可以取得远程参与者标识符列表

00:42:20.040 --> 00:42:23.343
从remoteParticipantIdentifier属性

00:42:29.850 --> 00:42:34.855
这就是我们要讲的API的高级主题

00:42:35.055 --> 00:42:38.158
再讲一下支持平台

00:42:39.293 --> 00:42:43.897
互动型信息将会在这些平台上提供

00:42:43.964 --> 00:42:47.401
watchOS 3、 macOS
Sierra和iOS 10

00:42:47.901 --> 00:42:51.939
在这些平台中 只有iOS 10
会真正产生信息

00:42:52.973 --> 00:42:57.544
在macOS Sierra
用户可以点击对话文本中的泡泡框

00:42:57.945 --> 00:43:01.982
传递给信息URL属性的URL

00:43:02.850 --> 00:43:04.585
将会在Safari里打开

00:43:04.651 --> 00:43:08.922
只有https或
http URL才行

00:43:09.890 --> 00:43:12.693
在watch上 可以把互动信息传给

00:43:12.759 --> 00:43:16.063
可以写回复的设备

00:43:24.671 --> 00:43:28.575
我们也支持旧平台备用

00:43:28.742 --> 00:43:32.679
这些消息也可以在
watchOS 2、 iOS 10

00:43:32.746 --> 00:43:35.449
iOS 9和OS 10.11上发送

00:43:35.649 --> 00:43:37.518
但是会以备用格式发送

00:43:37.584 --> 00:43:39.353
有两条分开的信息

00:43:39.920 --> 00:43:43.624
第一条是模版布局提供的图片

00:43:44.558 --> 00:43:49.263
第二条是信息提供的URL

00:43:49.796 --> 00:43:53.467
再次强调 如果是https URL
将会发送

00:43:53.534 --> 00:43:55.469
如果是数据URL 则不会发送

00:43:55.969 --> 00:44:01.542
我们在备用消息中只发送
https或http URL

00:44:04.511 --> 00:44:05.979
这就是本次演讲的全部内容

00:44:06.547 --> 00:44:08.348
总结一下

00:44:08.415 --> 00:44:12.419
本周我们介绍了Messages框架
iMessage应用

00:44:14.655 --> 00:44:18.125
在本演讲的第一部分Bhaskar
和Lily为我们介绍了

00:44:18.192 --> 00:44:20.060
贴图集 并演示了

00:44:20.127 --> 00:44:23.730
如何编写可以建立
贴图内容的iMessage应用

00:44:24.831 --> 00:44:28.836
今天 我们一起编写了
发送互动内容的iMessage应用

00:44:30.270 --> 00:44:33.607
还讲了如何在分组对话中实现等

00:44:35.943 --> 00:44:38.745
我十分期待看到你们大家

00:44:38.812 --> 00:44:40.414
走出去利用该API所做的成绩

00:44:41.081 --> 00:44:45.552
迫不及待想看到大家的产品 就这样

00:44:53.493 --> 00:44:56.296
其它详细信息
可以浏览本次演讲的网页

00:44:56.363 --> 00:44:58.565
在developer.apple.com

00:44:59.333 --> 00:45:00.467
我们还有一个相关演讲

00:45:00.534 --> 00:45:04.571
如果你还没有看过“iMessage
应用和贴图 第一部分”

00:45:04.638 --> 00:45:06.440
请到网站上观看

00:45:07.441 --> 00:45:09.309
演讲到此结束

00:45:09.376 --> 00:45:11.678
感谢Stephen的演示

00:45:11.745 --> 00:45:13.213
谢谢你们大家的到来