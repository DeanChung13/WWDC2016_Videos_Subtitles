00:00:22.823 --> 00:00:26.493
哇 大家下午好

00:00:28.362 --> 00:00:30.564
大家想要创建一个超棒的应用

00:00:30.998 --> 00:00:34.334
那么一个很赞的布局
将是不可或缺的一部分

00:00:34.868 --> 00:00:38.038
自动布局功能可便于
大家创建自己的布局

00:00:38.338 --> 00:00:42.109
针对不同的设备 定位和适配性

00:00:42.176 --> 00:00:44.111
以及针对不同语言的布局

00:00:44.511 --> 00:00:47.414
我们今天将要探讨自动布局的新玩法

00:00:47.881 --> 00:00:50.250
本场演讲共有三个部分

00:00:50.651 --> 00:00:51.885
第一部分由我为大家讲解

00:00:52.386 --> 00:00:55.389
我叫Jason Yao
是Interface Builder工程师

00:00:55.856 --> 00:00:58.258
我将告诉各位有关Interface Builder
的新特性

00:00:58.392 --> 00:01:02.496
接下来将由AppKit部门的Jesse
Donaldson 为大家讲解Cocoa的功能

00:01:02.796 --> 00:01:07.901
最后 UIKit的Marian Goldeen
将告诉诸位最新的调试技术

00:01:08.168 --> 00:01:13.173
这些工具和技术将
为各位节省开发时间与精力

00:01:13.240 --> 00:01:16.276
当大家在工作中使用它们时
好了 我们现在开始吧

00:01:17.511 --> 00:01:19.913
首先来说说

00:01:20.347 --> 00:01:23.517
如何渐进式地运用自动布局

00:01:24.218 --> 00:01:25.986
自动布局的增量式运用

00:01:26.053 --> 00:01:27.221
这是什么意思呢？

00:01:28.155 --> 00:01:31.425
在进行布局设计时
Interface Builder里的视图

00:01:31.491 --> 00:01:33.560
不会立即限制所有东西

00:01:33.627 --> 00:01:37.164
大家可以逐步进行操作 以节省时间

00:01:37.464 --> 00:01:41.101
简化各位的设置
并更具灵活性

00:01:41.568 --> 00:01:43.604
但在我向大家演示之前

00:01:44.037 --> 00:01:46.573
让我们先来看一个背景设置的例子

00:01:47.774 --> 00:01:50.077
首先找到视图

00:01:50.143 --> 00:01:52.446
然后拖拽到Interface
Builder画布上

00:01:53.614 --> 00:01:56.984
然后设定它的尺寸和位置
之后进行一定编译并运行

00:01:57.684 --> 00:02:01.989
这样就能在设备上获得既定尺寸的视图

00:02:02.623 --> 00:02:06.159
然后对其进行旋转 你会发现

00:02:07.494 --> 00:02:09.795
视图尺寸与既定标准一致

00:02:09.863 --> 00:02:11.798
但还有一些操作要进行

00:02:12.032 --> 00:02:13.300
那么接下来会怎样呢？

00:02:14.668 --> 00:02:18.405
接下来 我们仅需简单地
按照既定的宽高水平

00:02:18.472 --> 00:02:20.240
将其固定在界面顶端及左边

00:02:20.541 --> 00:02:25.012
事实上 我们只是以隐式的方式
创建了约束条件

00:02:25.078 --> 00:02:28.916
在进行编译时

00:02:28.982 --> 00:02:30.284
通过使用自动布局引擎
来使视图尺寸与既定水平一致

00:02:31.485 --> 00:02:33.954
如果各位需要进行更多的动态调整

00:02:34.454 --> 00:02:37.291
那么各位就需要打开
Interface Builder画布

00:02:37.591 --> 00:02:39.059
添加个性化约束条件

00:02:39.793 --> 00:02:42.663
那么问题来了 有没有一种更好的办法

00:02:42.729 --> 00:02:46.466
或许可以不需要设置约束条件
就能简单地进行尺寸调整呢？

00:02:47.367 --> 00:02:48.235
答案是肯定的

00:02:48.602 --> 00:02:53.740
Xcode 8的新功能
可在自动布局文件上

00:02:54.141 --> 00:02:56.543
对视图的
autoresizingMask属性进行规定

00:02:56.610 --> 00:02:58.712
而无需设置约束条件

00:03:00.080 --> 00:03:03.350
这意味着 大家可以很简单地
对视图尺寸进行调整

00:03:04.184 --> 00:03:07.221
通过规定autoresizingMask属性

00:03:07.387 --> 00:03:09.823
若在场有人还对自动布局出现前
的时代存在记忆

00:03:09.890 --> 00:03:11.291
那您可能还认识这个UI

00:03:16.196 --> 00:03:18.165
这是Springs &amp; Struts UI

00:03:18.365 --> 00:03:20.868
大家可将视图固定在边缘并决定/b&gt;

00:03:20.934 --> 00:03:23.237
它的尺寸是否可调整

00:03:23.837 --> 00:03:27.641
那么这些视图就能
和各位的约束视图一同进行良好的工作

00:03:28.375 --> 00:03:31.512
事实上 我们要对这些
autoresizingMask属性进行设置

00:03:31.578 --> 00:03:33.814
并把它们转换成约束条件

00:03:34.615 --> 00:03:37.885
但实际是在运行期间
将其转换成约束条件

00:03:38.085 --> 00:03:39.720
这里存在一个主要区别

00:03:39.920 --> 00:03:42.890
实际上 它们是在运行时间内
而非在建立时间内生成的

00:03:43.757 --> 00:03:48.128
因为这样更具灵活性 且更清晰

00:03:48.295 --> 00:03:52.366
若各位希望对视图进行编程操作
那它能为您带来良好的控制

00:03:52.900 --> 00:03:56.136
因为对于专业的自动布局用户

00:03:56.203 --> 00:03:57.671
可能还认识这个标志

00:03:58.172 --> 00:03:59.873
对于视图 我们简单地将

00:03:59.940 --> 00:04:03.143
translatesAutoresizingMask
intoConstraints设定为真

00:04:04.745 --> 00:04:06.180
那么对于视图来说

00:04:06.246 --> 00:04:08.949
若在Interface Builder
内添加了约束条件 它会怎样呢？

00:04:09.550 --> 00:04:11.251
答案是 没有变化

00:04:11.552 --> 00:04:14.955
各位仅需点击一下视图
就能获得所有影响该视图的约束条件

00:04:15.622 --> 00:04:19.959
AutoresizingMask
即可被忽略

00:04:21.461 --> 00:04:24.631
并且这些视图的translates
AutoresizingMask 属性都将变成假

00:04:26.066 --> 00:04:29.503
那么将它们和最初的问题放到一起

00:04:29.837 --> 00:04:32.072
这样 我们就能逐步地使用自动布局了

00:04:32.472 --> 00:04:36.844
首先通过autoresizingMasks
对视图尺寸进行简单的调试

00:04:36.977 --> 00:04:40.047
然后添加相应约束条件
以进行更为复杂的操作

00:04:41.148 --> 00:04:43.684
这会给大家带来更好的灵活性

00:04:44.017 --> 00:04:45.819
当各位准备好添加约束条件时

00:04:46.653 --> 00:04:49.489
选择你想要添加约束条件的子树目录

00:04:49.556 --> 00:04:52.125
先从父级开始
然后再按各自的方式进行

00:04:54.194 --> 00:04:58.031
这样可按照各位的意愿来
进行自动布局操作

00:04:58.298 --> 00:05:00.934
并且有益于大家准备构建的新布局

00:05:01.235 --> 00:05:03.770
方便大家进行尺寸调整

00:05:03.837 --> 00:05:08.041
且对于各位一直想进行布局的文件而言
也是很棒的

00:05:08.509 --> 00:05:11.278
并且 你还可以在保留
现有行为的情况下进行该操作

00:05:13.447 --> 00:05:15.382
我来给大家演示一下这个操作

00:05:15.983 --> 00:05:18.252
那么 让我们来看看
它究竟是什么玩意儿

00:05:29.296 --> 00:05:32.065
我已用Interface Builder
打开了Xcode 8

00:05:32.132 --> 00:05:33.634
我要创建一个关于天气的应用

00:05:34.668 --> 00:05:38.138
我找到了我的视图
并已经拖拽到了视图控制器

00:05:38.205 --> 00:05:40.841
它适用于iPad的竖屏模式

00:05:41.508 --> 00:05:44.444
我们来看看横屏模式下它将是怎样的

00:05:44.511 --> 00:05:47.414
在全新的设备结构配置栏内

00:05:47.614 --> 00:05:49.049
把竖屏模式更改为横屏模式

00:05:49.850 --> 00:05:52.085
点击一下即可

00:05:52.219 --> 00:05:56.557
那么 让我们继续 从顶部的图标开始

00:05:56.623 --> 00:05:59.459
我们希望能将它放大 并横跨父视图

00:06:00.928 --> 00:06:02.396
不需要添加任何约束条件

00:06:02.963 --> 00:06:06.200
我并没有添加约束条件
我找到尺寸查看器

00:06:06.366 --> 00:06:11.572
当然 这是AutoresizingMask查看器

00:06:11.638 --> 00:06:15.642
我说需要做的只是改变其宽度
并延展到另一边

00:06:17.778 --> 00:06:19.413
现在 做点对小孩感兴趣的事

00:06:19.479 --> 00:06:23.917
我先选中月亮
然后把它的未知属性默认为顶端

00:06:23.984 --> 00:06:25.586
然后我希望设置为靠左

00:06:25.652 --> 00:06:28.188
接下来是云朵 我把它设置为靠右

00:06:28.956 --> 00:06:31.325
取消掉靠左的属性

00:06:31.592 --> 00:06:34.895
接下来是标签 我希望能按比例调整它

00:06:34.962 --> 00:06:36.663
比例精确

00:06:36.864 --> 00:06:38.565
我取消掉靠左的属性

00:06:38.799 --> 00:06:40.300
调整它的宽度

00:06:40.367 --> 00:06:43.570
这里有个小的动画窗口
可让我们对其进行预览

00:06:43.637 --> 00:06:45.672
之后点击上下两端 使其固定

00:06:45.739 --> 00:06:47.407
然后同样方法调整高度

00:06:47.975 --> 00:06:49.610
最后我们想要观看其效果

00:06:50.444 --> 00:06:53.180
点击横屏模式 大功告成

00:06:53.580 --> 00:06:55.249
现在我们来试试2/3分屏模式

00:06:58.185 --> 00:07:00.254
大家看 标签被截断了

00:07:00.454 --> 00:07:01.522
这是怎么回事呢？

00:07:02.089 --> 00:07:05.359
如你所见 标签没有是什么问题

00:07:05.425 --> 00:07:06.793
它调用了
autoresizingMask

00:07:06.860 --> 00:07:09.763
然后根据自身的父视图进行比例调整

00:07:10.731 --> 00:07:16.236
AutoresizingMask
不会对视图的内容尺寸进行考虑

00:07:17.171 --> 00:07:19.339
但我可以通过约束条件来修正它

00:07:19.973 --> 00:07:23.977
不过对于这个特别的UI标签
我还没有别的技巧来解决它

00:07:24.278 --> 00:07:26.613
我只能通过属性检查器

00:07:27.014 --> 00:07:30.551
将它从固定文字尺寸
转换为最小文字尺寸

00:07:30.751 --> 00:07:32.586
这样 就能完整地显示出来

00:07:33.520 --> 00:07:37.057
于是 当我们返回全横屏模式

00:07:37.124 --> 00:07:39.726
它也能很好地显示出来 竖屏也一样

00:07:40.627 --> 00:07:43.730
接下来 我们来处理一下
中间的温度控制图标

00:07:44.565 --> 00:07:46.934
我希望它能更精准地排列

00:07:47.000 --> 00:07:48.468
因此 我准备采用约束条件

00:07:49.102 --> 00:07:51.205
我先选中它...

00:07:51.271 --> 00:07:53.207
我想对这个75摄氏度的图标
进行关于父视图约束设置

00:07:53.273 --> 00:07:55.342
需要通过键盘操作

00:07:55.409 --> 00:07:57.845
调出关于父视图连接

00:07:58.111 --> 00:07:59.713
即可调出约束条件菜单

00:08:00.380 --> 00:08:04.017
在该菜单内 可以通过按住shift
同时选择多项约束条件

00:08:04.084 --> 00:08:07.321
我希望它处于水平及
垂直中心 点击即可完成

00:08:08.121 --> 00:08:09.857
相似地 我想做同样的调整

00:08:10.691 --> 00:08:13.193
按住Ctrl键拖拽到sunny图标
按住Shift键

00:08:13.260 --> 00:08:17.130
我想添加Horizontally Space
及Baseline两个约束条件

00:08:18.365 --> 00:08:19.766
然后对太阳图标也一样

00:08:19.833 --> 00:08:23.670
按住Ctrl键拖拽 按住Shift键
添加horizontal spacing

00:08:23.837 --> 00:08:25.372
以及center vertically两个约束条件

00:08:27.174 --> 00:08:29.443
现在 我对视图添加完了约束条件

00:08:29.510 --> 00:08:32.412
现在 我们仅需对框架进行更新即可

00:08:32.578 --> 00:08:35.982
现在 我们前往
“解决自动布局问题”菜单

00:08:36.850 --> 00:08:38.919
对选中的视图进行框架更新

00:08:40.821 --> 00:08:43.390
接下来
我想将温度控制图标再变大一点

00:08:43.957 --> 00:08:47.194
首先选中它 然后增加它的字体尺寸

00:08:47.261 --> 00:08:50.230
各位可能会注意到
当我在增加字体尺寸的时候/b&gt;

00:08:50.964 --> 00:08:52.633
因为一切都准备就绪

00:08:52.699 --> 00:08:55.435
所以自动布局
便自动为我的框架进行了更新

00:08:55.802 --> 00:08:59.439
在Xcode 8中 我们为各位做了
大量的框架自动更新的工作

00:09:01.041 --> 00:09:04.811
那么接下来
我们希望能有个不错的背景

00:09:05.779 --> 00:09:07.748
这是阳光明媚的一天

00:09:07.848 --> 00:09:10.317
因此 我们继续添加一个图片视图

00:09:12.653 --> 00:09:15.422
从目标库中 我拖拽出了一张图

00:09:15.489 --> 00:09:16.823
把它放大到全视图尺寸

00:09:24.198 --> 00:09:25.532
然后设置为图像属性

00:09:28.635 --> 00:09:30.537
并选择填充模式

00:09:30.604 --> 00:09:33.140
就该案例
我们可能会选择AspectFill

00:09:33.941 --> 00:09:36.643
现在我们要确定
它的尺寸符合其父视图模式

00:09:36.710 --> 00:09:40.147
我们可以对各边添加共四个约束条件

00:09:40.514 --> 00:09:43.684
但对于这种简单的尺寸调整
我们并不需要添加任何约束条件

00:09:43.750 --> 00:09:47.221
因为我们可以调用尺寸查看器

00:09:47.287 --> 00:09:50.424
然后调用AutoresizingMasks
对四边进行一定延展

00:09:50.490 --> 00:09:52.326
这样就能改变其宽高水平

00:09:53.994 --> 00:09:57.598
最后同样重要的是
我们需要把它放到文件的上方

00:09:57.664 --> 00:09:58.498
看它就又出现了

00:09:59.032 --> 00:10:02.402
然后需要确认
我这个banner的背景

00:10:02.603 --> 00:10:06.206
介于这属于视觉艺术
看 现在就得到了很棒的半透明效果

00:10:06.673 --> 00:10:07.875
然后我们测试一下

00:10:07.941 --> 00:10:10.911
它现在看起来很棒

00:10:11.979 --> 00:10:15.616
在横屏模式2/3模式

00:10:16.717 --> 00:10:18.452
及竖屏模式下都很棒

00:10:19.520 --> 00:10:21.655
同样在iPhone 6s Plus
模式下也一样

00:10:22.422 --> 00:10:25.993
以上内容既是关于
如何逐步使用自动布局的内容

00:10:33.267 --> 00:10:36.203
接下来我想讲些比较高级的主题

00:10:36.603 --> 00:10:39.506
混合设计与运行时间约束

00:10:40.307 --> 00:10:43.510
有些时候大家会陷入这样一种窘境

00:10:43.577 --> 00:10:46.180
你在Interface
Builder内部进行视图布局

00:10:46.246 --> 00:10:47.781
并添加个人约束

00:10:47.848 --> 00:10:51.051
但是确实不知道该添加哪些约束条件

00:10:51.118 --> 00:10:55.022
直到运行时才有眉目 这可能是因为
约束条件的确定是根据诸如

00:10:55.088 --> 00:10:57.991
一天中某时刻或只有应用才了解的
一些大家正在载入的数据

00:10:58.859 --> 00:11:02.362
我想给大家展示三种工具和三个例子

00:11:02.429 --> 00:11:04.431
来解决这类问题

00:11:05.332 --> 00:11:08.635
首先是调用占位符约束

00:11:09.670 --> 00:11:11.872
在这一情况下我选中一张图

00:11:11.939 --> 00:11:17.744
我希望它在我的设备中处于
垂直与水平居中位置

00:11:17.811 --> 00:11:21.014
并处于边缘白线以内

00:11:21.215 --> 00:11:23.684
而且我还希望它保持自身的长宽比例

00:11:24.218 --> 00:11:26.887
然而我并不知道
这幅图最终会成为什么样

00:11:27.621 --> 00:11:28.655
只有在运行时才能看到

00:11:29.022 --> 00:11:33.160
因此为了充分了解近似尺寸与布局

00:11:33.227 --> 00:11:37.531
可以查看Interface Builder
然后添加一个4:3的高宽比

00:11:37.931 --> 00:11:42.569
当然这一比例是我估计的
之后将其标记为占位符约束

00:11:43.003 --> 00:11:45.272
这样就能在构建时间内对其进行移除

00:11:46.707 --> 00:11:50.177
当在运行时间内
确实需要对图像进行设置时

00:11:50.377 --> 00:11:54.348
我会创建实际的长宽比例约束并运行

00:11:56.183 --> 00:12:00.420
第二个例子
假使你正在创建一项自定义控件

00:12:01.989 --> 00:12:06.059
你的自定义控件将清除
诸如UIView类或NSview类

00:12:06.126 --> 00:12:07.561
它会提供自己的图像

00:12:07.628 --> 00:12:09.997
并管理其相关内容

00:12:10.163 --> 00:12:11.999
或许它甚至还能确定自己的尺寸

00:12:12.499 --> 00:12:15.502
它可以向自动布局系统提供该尺寸

00:12:15.769 --> 00:12:18.372
通过指定其固有内容尺寸来进行

00:12:20.741 --> 00:12:22.843
Interface Builder
并不执行该代码

00:12:22.910 --> 00:12:26.813
因此它并不知道
固有内容的尺寸该是多少

00:12:26.880 --> 00:12:28.782
但各位可以模拟其近似尺寸

00:12:28.849 --> 00:12:32.119
通过使用固有尺寸占位符
来对其设定合理值

00:12:32.619 --> 00:12:35.689
因此你就可以得知
它在布局中究竟是怎样的

00:12:36.790 --> 00:12:38.492
记住你的自定义控件

00:12:38.559 --> 00:12:42.763
如果各位要这样操作
务必提供它的实际固有内容尺寸

00:12:42.829 --> 00:12:46.400
你可以通过重写
固有内容尺寸属性来进行

00:12:46.466 --> 00:12:47.568
在自定义控件上进行

00:12:49.570 --> 00:12:52.306
最后一例是关于Xcode的新特性

00:12:53.207 --> 00:12:57.311
之所以把它放到最后来讲是因为
这可能是各位最后的一项应急选择

00:12:57.544 --> 00:13:02.783
在大家对占位符约束及设计

00:13:02.850 --> 00:13:04.918
还有固有内容尺寸占位符黔驴技穷时

00:13:05.152 --> 00:13:07.888
因此我们为各位设计了一项功能

00:13:08.055 --> 00:13:12.426
基于各视图来调整模糊警告级别

00:13:13.126 --> 00:13:15.829
意思是说对于该视图

00:13:15.896 --> 00:13:19.733
我希望它处于屏幕中央
但我只确定垂直位置

00:13:19.800 --> 00:13:23.904
而不知道水平位置也不知道尺寸大小

00:13:24.605 --> 00:13:27.140
Interface Builder
其实会为此给出红线

00:13:27.207 --> 00:13:31.111
以提醒我此时缺少足够的约束条件

00:13:31.411 --> 00:13:34.281
来进行定位 所以它是模糊的

00:13:35.749 --> 00:13:37.918
这样我就知道
我得在之后运行时间里添加约束条件

00:13:37.985 --> 00:13:40.621
当我获得所有需要的信息时

00:13:40.888 --> 00:13:44.992
如此 我就可以继续操作

00:13:45.058 --> 00:13:48.228
并通过进行模糊属性设定
来将作业区的无用信息移除

00:13:48.662 --> 00:13:53.500
并将该属性由“总是确认”改为

00:13:53.567 --> 00:13:55.235
“位置确认”或“绝不确认”

00:13:55.636 --> 00:13:58.906
然后我向自己保证
之后我得添加那些约束条件

00:13:58.972 --> 00:14:02.509
如此这般
第一次布局通过前 会一直处于该尺寸下

00:14:04.578 --> 00:14:07.548
这些工具让各位通过
设计师/运行时间约束来进行作业

00:14:07.614 --> 00:14:09.583
当大家已尝试完各种

00:14:09.650 --> 00:14:12.586
Interface Builder
可添加约束条件的情况下

00:14:13.320 --> 00:14:16.723
那么以上内容
既是如何逐步使用自动布局

00:14:17.057 --> 00:14:21.094
及如何进行设计师/运行时间约束设置
那么现在我们将开始第二部分内容

00:14:21.295 --> 00:14:24.231
欢迎我的同事
Jesse Donaldson

00:14:24.398 --> 00:14:26.300
来给大家讲解新的Cocoa

00:14:26.767 --> 00:14:27.634
该你了Jesse

00:14:38.645 --> 00:14:41.381
大家好 今天由我给大家讲解
NSGridView

00:14:41.448 --> 00:14:45.219
它是一种新的布局容器
我们在macOS上有提供

00:14:48.188 --> 00:14:51.391
大家知道维护约束条件是件很难的事

00:14:51.458 --> 00:14:55.062
纵使你有如同该复选框一样简单的工具

00:14:55.128 --> 00:14:58.465
我们创建了StackView
来让这件事变的简单

00:14:58.532 --> 00:15:02.636
并且你还可以在任何时候
将一些视图在工作区间内进行伸展

00:15:03.437 --> 00:15:05.172
有些布局依然

00:15:05.772 --> 00:15:08.775
很难实现 比如

00:15:08.842 --> 00:15:10.544
你可以通过stacks创建它

00:15:10.978 --> 00:15:13.380
而NSStackView
则不能对内容进行

00:15:13.447 --> 00:15:15.749
跨行与列的排列

00:15:16.250 --> 00:15:18.051
这就是我们设计
NSGridView的原因

00:15:18.118 --> 00:15:21.955
它能轻松地将内容放在确切的网格上

00:15:22.022 --> 00:15:25.125
并能完成跨坐标的排列方式

00:15:25.826 --> 00:15:27.227
那么我们放大一点来看

00:15:28.428 --> 00:15:30.664
我从Voiceover设置的
UI上截取了这幅图

00:15:30.731 --> 00:15:34.835
我在其中添加了紫色线条以便
让大家知道它是如何适应网格的

00:15:35.669 --> 00:15:38.238
NSGridView调用多种辅助类

00:15:38.305 --> 00:15:42.042
NSGridRow和
NSGridColumn表示行与列

00:15:42.409 --> 00:15:45.679
并通过内容默认设置为自动尺寸调整

00:15:47.314 --> 00:15:50.350
如果各位有需求还可以指明具体的尺寸

00:15:51.418 --> 00:15:53.720
还可以让你添加一些额外的填充

00:15:53.787 --> 00:15:56.290
如果你的网格需要一些额外空间的话

00:15:56.356 --> 00:16:00.394
若你有些不适用于当前硬件构造的UI

00:16:00.794 --> 00:16:03.163
那么这些UI将通过动态图表示出来
并被隐藏

00:16:04.831 --> 00:16:08.769
NSGridView调用
独立的NSGridCell

00:16:09.002 --> 00:16:10.604
以代表独立的单元格

00:16:10.671 --> 00:16:14.341
并且单元格的作用既是

00:16:14.408 --> 00:16:16.210
对特定的内容视图进行布局管理

00:16:17.878 --> 00:16:20.447
单元格还可让各位控制内容的位置

00:16:20.514 --> 00:16:22.816
如果单元格具有一定额外空间

00:16:24.017 --> 00:16:27.688
并且如果某些内容需要跨越多个单元格

00:16:27.754 --> 00:16:28.989
还可以对它们进行融合

00:16:29.056 --> 00:16:31.425
这就像各位熟悉的
电子数据表格程序一样

00:16:32.459 --> 00:16:37.664
我已经创建了一个较小的UI
并且还有一些有趣的事可做

00:16:37.731 --> 00:16:41.034
我先展示这一小部分内容
并展示它是如何创建的

00:16:43.937 --> 00:16:47.140
我们打算在Interface Builder中
为NSGridView提供支持

00:16:47.207 --> 00:16:49.843
但直到完成它之前我们还是得通过
代码进行作业

00:16:49.910 --> 00:16:53.013
我把outlet放进了nib文件

00:16:53.080 --> 00:16:55.382
针对所有我想放入网格的控制组件

00:16:55.916 --> 00:16:59.520
之后无论何时大家对NSGridView
注明ContentView属性

00:17:00.153 --> 00:17:03.657
在需要的情况下它都能考虑到
网格子视图的可移动属性

00:17:04.156 --> 00:17:07.294
这让各位在运行期间可以轻松地
对网格视图进行分配

00:17:07.361 --> 00:17:09.829
之后融入到现有视图层次体系中

00:17:11.365 --> 00:17:14.134
可以通过多种方法构建网格视图

00:17:14.201 --> 00:17:15.769
但我认为这是最简单的一种

00:17:15.836 --> 00:17:19.673
大家所要做的仅是

00:17:19.740 --> 00:17:21.241
为每行注明一个内容视图列表

00:17:21.842 --> 00:17:23.377
接下来我们来讨论几件事

00:17:23.443 --> 00:17:25.979
首先各位不必担心网格的尺寸

00:17:26.346 --> 00:17:29.016
无论需要多少行与列它都能

00:17:29.082 --> 00:17:30.851
针对大家指定的内容进行处理

00:17:31.418 --> 00:17:36.390
其次各位从头到尾使用的代码
既具有近似网格状的属性

00:17:36.456 --> 00:17:40.227
而且至少与指定的UI是高度相关的

00:17:40.460 --> 00:17:43.864
这便于之后各位或他人返回

00:17:43.931 --> 00:17:45.632
并了解该代码

00:17:46.366 --> 00:17:49.736
因此如果我们现在运行
它会出现这样的结果

00:17:50.103 --> 00:17:52.539
仅对于调用构造函数来说这不算坏

00:17:52.906 --> 00:17:55.175
但显然这并不符合设计

00:17:55.843 --> 00:17:59.079
最突出的问题是UI伸展幅度过大

00:17:59.146 --> 00:18:00.914
造成过多空白比如这个

00:18:01.548 --> 00:18:05.953
这是因为表格视图被限定到了窗口边缘

00:18:06.086 --> 00:18:10.257
现在我要做的是将窗口的尺寸
调整到与网格一致

00:18:10.490 --> 00:18:14.061
但实际上这样会使网格填满整个窗口

00:18:14.828 --> 00:18:17.164
如果各位之前使用自动布局比较频繁

00:18:17.231 --> 00:18:21.435
那么在使用文本文件或其他控制组件时
可能遇到过类似的问题

00:18:21.702 --> 00:18:23.704
我们准备用同样的方式来解决这个问题

00:18:23.770 --> 00:18:26.540
通过调整网格视图的
ContentHuggingPriority属性

00:18:27.908 --> 00:18:31.645
这样该窗口内的其它控制组件

00:18:31.712 --> 00:18:32.679
就能从nib文件中获得较高的
ContentHugging值

00:18:33.580 --> 00:18:37.384
但直到我们在表格视图中
增大ContentHugging值

00:18:37.751 --> 00:18:41.255
之后窗口可能将内容视图的边缘

00:18:41.321 --> 00:18:43.390
偏离行与列的边缘

00:18:44.424 --> 00:18:48.962
一旦我们增加该值
反而能拉小窗口的边缘

00:18:49.029 --> 00:18:50.564
空白间隔即消失了

00:18:52.065 --> 00:18:55.536
接下来我希望讨论的是这些标签

00:18:56.003 --> 00:18:58.972
显然它们的布局存在一些问题

00:18:59.106 --> 00:19:00.841
需要进行调整

00:19:00.908 --> 00:19:03.844
因此需要对它们进行标签属性的控制

00:19:05.112 --> 00:19:09.583
通过对单元格调整坐标参数
会很容易地将它纠正过来

00:19:10.751 --> 00:19:16.423
X与Y坐标属性适用于行列

00:19:16.490 --> 00:19:18.158
单元格以及网格视图

00:19:18.625 --> 00:19:23.063
方法就是
如果没在单元格上指定具体数值

00:19:23.130 --> 00:19:26.233
那么可调用关于行与列的数值

00:19:26.300 --> 00:19:28.235
或者网格视图的数值如果必要的话

00:19:28.502 --> 00:19:31.271
这样在一个位置进行数值设定
将让整个过程变得很简单

00:19:31.338 --> 00:19:34.208
并且能对各种单元格进行调整

00:19:34.608 --> 00:19:37.544
就这个案例我们可以从网格视图中
得到处于零引索位置的列

00:19:37.644 --> 00:19:40.647
并对该列设置x坐标

00:19:41.014 --> 00:19:44.318
如此就能将这俩标签调整到正确位置

00:19:45.219 --> 00:19:49.389
接下来我想讨论的是基线对齐

00:19:49.690 --> 00:19:53.093
该文本的标签明显没有与

00:19:53.160 --> 00:19:54.695
处于控制状态下的文本对齐

00:19:54.761 --> 00:19:57.197
在幻灯片上可能不是很明显

00:19:57.264 --> 00:19:59.967
调整rowAlignment属性
即可很容易对其进行校正

00:20:00.100 --> 00:20:03.370
与安置一样
rowAlignment具有继承性

00:20:03.704 --> 00:20:05.305
对于这种特别的设计

00:20:05.372 --> 00:20:09.510
通过基线来处理所有网格对齐的问题
是一件很棒的事

00:20:09.610 --> 00:20:12.279
因此我们可以在网格视图中的一个地方
进行数值设定

00:20:12.346 --> 00:20:13.847
且该设定可影响一切

00:20:14.748 --> 00:20:18.552
如果大家够仔细
能发现文本已经调整到了正确位置

00:20:19.720 --> 00:20:22.456
现在还有一件关于行对齐的问题是

00:20:22.523 --> 00:20:25.659
可能有许多处于行位置的视图
处于行对齐状态

00:20:26.260 --> 00:20:29.029
之后各位或许会对那些单元格注明安置

00:20:29.296 --> 00:20:33.800
所以 在这样的情况下
网格视图可能无法满足所有的要求

00:20:34.134 --> 00:20:37.804
重要的是要理解行对齐

00:20:37.871 --> 00:20:40.073
总是比安置优先

00:20:40.340 --> 00:20:43.810
它起作用后
我们将得到整组的对齐内容视图

00:20:43.877 --> 00:20:47.114
然后我们会使用安置功能
从第一个单元格开始进行安置

00:20:49.950 --> 00:20:53.687
接下来
我要给大家讲的是这个弹出按钮

00:20:53.754 --> 00:20:58.158
设计图在弹出按钮的
上、下均留有一点额外的间隔

00:20:58.225 --> 00:21:02.462
我们可以在该行中添加一些填充
使布局也有这样的间隔

00:21:05.666 --> 00:21:07.768
因此 我们要做的第一件事就是获取行

00:21:08.035 --> 00:21:11.205
我们其实可以用之前
获取列的相同方式进行

00:21:11.271 --> 00:21:14.975
通过指定索引获取
但这种方式更好一点

00:21:15.609 --> 00:21:19.880
相反 我们从网格视图
找到包含该弹出按钮的单元格

00:21:19.947 --> 00:21:21.782
然后从该单元格获取行

00:21:22.716 --> 00:21:24.985
这样更好 因为如果之后有人参与进来

00:21:25.352 --> 00:21:28.355
并更改网格视图的配置
以添加一个复选框

00:21:28.422 --> 00:21:31.091
或其它类似的东西
这段代码仍将有效

00:21:31.358 --> 00:21:34.228
如果你在代码中
塞入了大量硬编码的索引值

00:21:34.294 --> 00:21:37.998
那么一旦有人添加一个复选框
你就得检查所有的代码

00:21:38.065 --> 00:21:40.300
以查看哪个索引值需要进行更新

00:21:41.902 --> 00:21:45.405
在任何情况下 只要我们获取了行

00:21:45.472 --> 00:21:48.242
我们就可以继续 并设置填充值

00:21:48.308 --> 00:21:50.777
我们会发现得到了一点点额外的间隔

00:21:50.844 --> 00:21:52.179
在弹出按钮的上方和下方

00:21:53.146 --> 00:21:55.949
我们还需要在状态单元格标签上
留一点间隔

00:21:56.950 --> 00:21:59.119
我们可以通过同样的办法实现

00:22:02.689 --> 00:22:04.091
下面 我想在此处花点时间

00:22:04.157 --> 00:22:06.793
谈谈填充与间隔之间的不同

00:22:06.860 --> 00:22:08.929
我们还没怎么正经地讨论过间隔

00:22:09.229 --> 00:22:11.832
填充值在行和列上都有

00:22:11.899 --> 00:22:14.835
它们仅用于在各处添加额外的间隔

00:22:14.902 --> 00:22:16.336
在网格需要添加间隔的地方

00:22:16.737 --> 00:22:19.606
网格视图本身就可以设置间隔值

00:22:19.673 --> 00:22:23.477
它们适用于所有行或所有列之间的间隔

00:22:24.077 --> 00:22:30.184
因此 如果我们拷贝一份设计
并清除上面所有填充

00:22:30.584 --> 00:22:33.754
那我们就会看到这样的结果
UI仍适当地间隔开

00:22:33.820 --> 00:22:37.291
但我们已无法分辨出
不同控制群簇之间的区别

00:22:38.125 --> 00:22:42.829
如果我们保留填充
但去掉所有间隔 就会变成这样

00:22:43.197 --> 00:22:47.668
我们仍能看到控制群
但UI就很紧巴地挤在一起

00:22:48.202 --> 00:22:50.938
当然如果你把两个都去掉了
那就会变成这样

00:22:51.004 --> 00:22:53.640
整体都会被压缩得很紧实

00:22:54.541 --> 00:22:58.612
此处需要记住的是
填充属性默认为零

00:22:58.846 --> 00:23:02.683
除非你特别设置它
否则在网格中不会有任何填充

00:23:02.749 --> 00:23:05.719
但是大家通常希望
在内容视图之间留一些间隔

00:23:05.786 --> 00:23:10.657
所以网格视图的间隔默认值默认不为0

00:23:10.724 --> 00:23:15.095
如果你的用例要求视图
都是彼此之间紧贴布局

00:23:15.162 --> 00:23:18.866
那么就需要在网格视图中
将这些间隔属性设置为零

00:23:19.399 --> 00:23:23.871
此处最后一个确实不协调的地方
是这个复选框

00:23:23.937 --> 00:23:26.707
这是一个有趣的情况
因为它需要跨边界

00:23:26.773 --> 00:23:28.542
在底部的两个单元格之间

00:23:28.609 --> 00:23:30.544
但我们可以通过合并单元格实现

00:23:30.611 --> 00:23:32.346
正如我在介绍中提到的

00:23:33.380 --> 00:23:35.749
这有几种方法实现
但在这种情况下

00:23:35.816 --> 00:23:38.418
我们可以告诉该行
合并它的头两个单元格

00:23:38.785 --> 00:23:40.053
当你这样做时

00:23:40.621 --> 00:23:44.625
它具有扩展
顶部前导单元格边界的作用

00:23:44.691 --> 00:23:46.527
覆盖整个合并范围

00:23:48.362 --> 00:23:52.566
因此这个代码一旦生效
我们看到复选框滑动

00:23:52.633 --> 00:23:55.402
现在这个内容视图
已经在两个单元格中展开布局了

00:23:55.469 --> 00:23:56.670
就好像它们是同一个

00:23:56.737 --> 00:23:59.907
实际上 你可以看到
它只是沿袭了拖尾放置

00:23:59.973 --> 00:24:01.041
从第一列沿袭过来

00:24:02.809 --> 00:24:05.345
我们真的不希望有拖尾放置

00:24:05.679 --> 00:24:08.048
但是我们也不想有引导放置

00:24:08.348 --> 00:24:11.518
这个复选框实际上应该置于边界中心

00:24:11.585 --> 00:24:13.086
介于两列之间

00:24:13.654 --> 00:24:17.124
因为列与列大小不一

00:24:17.191 --> 00:24:20.260
这不是网格视图真正想为你做的事情

00:24:20.460 --> 00:24:22.996
但是它却为你自己实现
这一目标留出了空间

00:24:24.264 --> 00:24:27.701
开始需要把该单元格的安放设置为空

00:24:28.135 --> 00:24:30.671
当你将这些安置值设置为空时

00:24:31.338 --> 00:24:33.674
它会导致网格视图

00:24:33.740 --> 00:24:36.109
停止维护该布局的这一属性

00:24:37.110 --> 00:24:40.147
其结果是网格视图
将不会应用任何约束条件

00:24:40.214 --> 00:24:42.216
这可能与我们的约束条件相悖

00:24:42.482 --> 00:24:45.285
所以一旦完成了这个
就可以继续设置约束条件

00:24:45.352 --> 00:24:48.088
从复选框中心x锚点开始

00:24:48.155 --> 00:24:50.624
到它上面的复选框引导锚点

00:24:51.592 --> 00:24:52.960
一旦我们有了约束条件

00:24:53.026 --> 00:24:56.330
我们就可以像通常对待
约束条件那样真正激活它

00:24:56.797 --> 00:25:00.534
但在这种情况下
要把它设在自定义安置约束条件阵列中

00:25:02.069 --> 00:25:04.204
如果这样做就可以使网格视图

00:25:04.271 --> 00:25:07.140
保持任何自定义的安置约束条件

00:25:07.207 --> 00:25:10.344
它会进行诸如激活或停用
约束条件等类似操作

00:25:10.410 --> 00:25:12.646
取决于该单元格是否可见

00:25:14.181 --> 00:25:18.685
接下来 这个代码生效后
我们看到复选框移动到位置

00:25:18.986 --> 00:25:21.688
实现结果就与设计一致了

00:25:22.022 --> 00:25:22.856
这样我们就完成了

00:25:23.457 --> 00:25:27.094
此处 部分网格的配置有些复杂

00:25:27.160 --> 00:25:30.998
但是比起你需要构建这个UI来说
整个过程还是简单了很多

00:25:31.365 --> 00:25:33.867
从基本约束条件抑或是堆栈

00:25:34.401 --> 00:25:37.137
其实没有太多需要改变

00:25:37.204 --> 00:25:42.643
为了将这扩展到整个UI
我借鉴了VoiceOver参数选择

00:25:43.744 --> 00:25:46.313
所以 总而言之
NSGridView很棒

00:25:46.380 --> 00:25:50.684
如果你的应用程序
有一个静态网格式UI需要管理

00:25:51.318 --> 00:25:54.588
要处理它的一个好办法是
获取你的所有内容视图

00:25:54.655 --> 00:25:56.723
并将它们放入一个网格
看看会发生什么

00:25:57.057 --> 00:26:00.561
此时 你还可以对网格的配置
进行迭代重复

00:26:00.627 --> 00:26:03.530
直到实现你预期的布局设计

00:26:03.630 --> 00:26:04.932
我希望大家觉得这个有所帮助

00:26:05.766 --> 00:26:08.302
接下来 有请同事
Marian Goldeen

00:26:08.368 --> 00:26:11.705
她将给大家讲讲
她开发的一些新的调试工具

00:26:12.105 --> 00:26:13.006
谢谢

00:26:19.613 --> 00:26:22.449
虽然不经常发生
但它一旦发生 就很要命

00:26:22.683 --> 00:26:26.653
然后就造成了故障 很难调试

00:26:26.820 --> 00:26:28.555
这是一个布局的反馈环路

00:26:29.556 --> 00:26:31.525
当你遇到一个布局的反馈回路时

00:26:31.825 --> 00:26:33.894
你往往正在开始或者结束一个切换

00:26:34.094 --> 00:26:35.829
它可能是这样的

00:26:35.896 --> 00:26:38.932
你点击按钮开始切换

00:26:39.333 --> 00:26:43.337
按钮响应了 但其它都没有响应

00:26:44.238 --> 00:26:48.008
这样 你得马上运行Xcode
在调试导航器中查看

00:26:48.075 --> 00:26:51.512
你会发现CPU卡住了

00:26:52.012 --> 00:26:55.916
内存占用正在增加 可能你会中断

00:26:55.983 --> 00:26:59.052
你继续查看就会发现
一堆布局正在回溯中

00:26:59.586 --> 00:27:04.091
现在出现的情况是 某种视图集合

00:27:04.157 --> 00:27:07.794
正在运行布局
不断重复 形成了死循环

00:27:08.128 --> 00:27:09.596
运行循环永不停止

00:27:09.997 --> 00:27:13.066
此时出现的消息
都在收集自动释放对象

00:27:13.133 --> 00:27:16.203
全部都在收集信息
这就是为什么内存占用得越来越多

00:27:16.937 --> 00:27:21.241
造成这种情况的原因是
一种上行数据流setNeedsLayout

00:27:21.508 --> 00:27:24.945
我的意思是
在它布局中leafword视图之一

00:27:25.012 --> 00:27:28.982
正在做些事情
使得更趋于根定向的视图

00:27:29.049 --> 00:27:32.953
以得到setNeedsLayout
所以当布局完成其路径时

00:27:33.020 --> 00:27:35.255
它正好回到顶部 并重新开始

00:27:35.522 --> 00:27:39.660
你们想知道的是
这其中涉及到了什么视图

00:27:40.127 --> 00:27:44.731
因为这将帮你找出
setNeedsLayout的出处

00:27:44.798 --> 00:27:47.201
这是为何？你要对它做什么？

00:27:47.467 --> 00:27:50.671
这个信息其实收集起来有点难

00:27:50.904 --> 00:27:55.609
因此 这就是我们为什么
要介绍布局反馈环路调试器

00:27:55.676 --> 00:27:57.678
以此来应对这些特殊情况

00:27:58.445 --> 00:28:01.715
这是一个在Xcode中
添加的启动参数

00:28:01.782 --> 00:28:02.850
它叫做UIView

00:28:02.916 --> 00:28:07.221
或NSViewLayoutFeedbackLoop
DebuggingThreshold

00:28:07.754 --> 00:28:10.357
取决于你用的是macOS还是iOS

00:28:11.225 --> 00:28:14.194
你给它设置一个值 此处我设的100

00:28:14.394 --> 00:28:19.333
你可以设置任何值
但我们把它限制在50到1000之间

00:28:20.534 --> 00:28:22.703
现在当你对该启动参数设置之后

00:28:22.769 --> 00:28:26.673
布局反馈回路调试器
将会计算布局子视图

00:28:26.740 --> 00:28:28.375
为每个运行布局的视图进行计算

00:28:28.575 --> 00:28:32.012
如果它们其中任何一个运行超过阈值

00:28:32.079 --> 00:28:33.881
在同一个运行循环中

00:28:34.314 --> 00:28:38.285
在收集信息的同时
还会使循环运行一段时间

00:28:38.352 --> 00:28:42.990
然后它会引发异常
并把信息转存到日志中

00:28:43.624 --> 00:28:48.095
转存信息至com.apple.AppKit子系统

00:28:48.161 --> 00:28:50.364
或com.apple.UIKit
子系统

00:28:50.430 --> 00:28:52.432
这取决于你用的是
macOS还是iOS

00:28:52.699 --> 00:28:54.835
这两种情况有不同的布局循环目录

00:28:55.269 --> 00:28:58.839
如果你想了解更多
有关这一新日志子系统和目录的信息

00:28:58.906 --> 00:29:00.807
请参加今天五点钟的讲座

00:29:00.874 --> 00:29:03.677
在Knob Hill 举行
主题是统一的日志与活动跟踪

00:29:04.711 --> 00:29:07.948
另外 你可以在调试器中设置断点

00:29:08.015 --> 00:29:09.216
异常断点

00:29:09.550 --> 00:29:11.685
你可以在调试器中打印反馈回路

00:29:11.752 --> 00:29:13.987
或者它碰到断点也是挺好的

00:29:14.054 --> 00:29:16.823
也许还可以更多地
反思一下发生了什么事情

00:29:20.561 --> 00:29:23.830
所以我说的信息转存确实就是信息转存

00:29:24.131 --> 00:29:28.635
下面我们来看两个
真实的实时布局反馈环路的例子

00:29:28.702 --> 00:29:31.438
我用了布局反馈环路调试器进行调试

00:29:31.505 --> 00:29:33.874
现在我们要查看这些日志逐一细细查看

00:29:34.107 --> 00:29:37.411
很可能看到对你有所帮助的
两个不同日志记录

00:29:37.477 --> 00:29:40.013
我们准备要查看布局反馈环路

00:29:40.080 --> 00:29:42.616
这是由上行数据流
setNeedsLayout引起的

00:29:42.716 --> 00:29:45.052
这实际上与自动布局无关

00:29:45.319 --> 00:29:50.157
而另一个是由源自约束条件的
模糊布局导致的

00:29:50.224 --> 00:29:52.159
这对于自动布局是非常特殊的

00:29:53.360 --> 00:29:57.130
所以对于第一例子
当上行数据流结构发生变化

00:29:58.098 --> 00:30:03.937
这是一张视图树的图片
其中出现了反馈环路

00:30:04.371 --> 00:30:08.208
在这个视图树中
很多视图其实都是运行中的布局

00:30:10.978 --> 00:30:12.880
通常你会很幸运
因为其中没有太多视图

00:30:12.946 --> 00:30:14.882
但如果碰到这样的 你就会抓狂了

00:30:15.215 --> 00:30:18.719
但实际上 它们中
有10个仅仅是凑数的

00:30:18.819 --> 00:30:21.722
它们是实际问题的无辜受害者

00:30:21.788 --> 00:30:23.891
这出现在分层结构的较高层中

00:30:24.157 --> 00:30:26.793
接下来 可以看到第三层级视图

00:30:26.960 --> 00:30:30.497
在其布局中 正在改变它的子视图边界

00:30:31.131 --> 00:30:34.468
当一个视图边界发生变化
就会有一个明显的setNeedsLayout

00:30:34.735 --> 00:30:37.571
因为它需要为了新的边界
而重新设置其视图

00:30:37.838 --> 00:30:41.642
但若正接收边界的这个视图发生了变化

00:30:41.808 --> 00:30:44.978
而如果它的父视图实际不在布局中

00:30:45.112 --> 00:30:47.848
父视图也将收到一个
setNeedsLayout

00:30:47.915 --> 00:30:51.318
这样布局子视图
将会有对布局进行描述的字眼

00:30:51.919 --> 00:30:54.955
这样 当布局通过 执行到底并结束

00:30:55.022 --> 00:30:58.091
它会返回顶部并继续执行布局

00:30:58.158 --> 00:31:00.127
因为顶视图仍然需要布局

00:31:00.327 --> 00:31:03.297
这会重置中间视图的边界

00:31:03.463 --> 00:31:07.568
反馈环路是由两个视图所驱动的

00:31:07.634 --> 00:31:09.870
这两个视图对中间视图的边界存在分歧

00:31:11.104 --> 00:31:13.407
你可以想象 有很多视图正在运行中

00:31:13.807 --> 00:31:16.810
这样 在日志有很多信息
所以你大可放心使用

00:31:17.411 --> 00:31:20.781
日志大概就是这样的
或者说至少是顶层是这样的

00:31:20.848 --> 00:31:23.750
当你查看这些日志时
我希望你们也从这里开始

00:31:23.817 --> 00:31:27.387
第一个被调出来的就是顶层视图

00:31:27.788 --> 00:31:29.122
是布局反馈环路的顶层视图

00:31:29.189 --> 00:31:31.825
因此 在这个环路中
没有视图而更多的是根词语

00:31:31.892 --> 00:31:33.627
相对这个布局视图而言

00:31:34.161 --> 00:31:38.065
接下来是关于子树的递归循环描述

00:31:38.131 --> 00:31:39.666
在顶层视图之下

00:31:39.967 --> 00:31:44.872
在描述中 有些视图的旁边
你会看到一个数字

00:31:44.938 --> 00:31:47.608
你往往会在顶层视图的旁边
看到一个数字

00:31:47.674 --> 00:31:49.076
此处你看到的就是23

00:31:49.576 --> 00:31:52.112
这些数字表示的是数量

00:31:52.179 --> 00:31:55.582
即接收布局的视图数量
且数字都是顺序排列的

00:31:55.816 --> 00:31:58.218
当然 这是一个循环
我们可在任何地方放置一个

00:31:58.285 --> 00:32:01.255
但是我们这样做的话
最后一个就是顶层视图

00:32:01.321 --> 00:32:03.657
这样你就能知道涉及到多少视图

00:32:04.091 --> 00:32:07.861
所以总共是23个
但从这里往下只有10个

00:32:07.928 --> 00:32:10.964
这儿顶部还有三个
加起来还是不到23

00:32:11.031 --> 00:32:12.165
这是怎么回事呢？

00:32:12.699 --> 00:32:15.702
好了 让我们来看看日志的下一段

00:32:15.869 --> 00:32:18.539
这是按顺序接收布局的视图

00:32:19.006 --> 00:32:24.378
在本段中
你可以看到正因为有一个循环

00:32:24.444 --> 00:32:27.648
并不意味着罗列的每个视图只出现一次

00:32:27.848 --> 00:32:32.553
我们展现出了十个视图
后面还有两个其它视图

00:32:32.753 --> 00:32:34.988
接下来又是这十个相同的视图

00:32:35.389 --> 00:32:37.424
所以这些是更leafmost的视图

00:32:37.491 --> 00:32:40.494
当你看到这种情况
即一堆视图被罗列出来

00:32:41.295 --> 00:32:44.531
在循环中不止一次出现

00:32:44.598 --> 00:32:48.902
它们往往都是其它更重要视图的受害者

00:32:50.003 --> 00:32:54.341
所以就像我之前说的
我们真正感兴趣的是

00:32:54.408 --> 00:32:58.078
顶层视图从哪里获取
其setNeedsLayout

00:32:58.979 --> 00:33:04.685
因此 紧随这一段后面是很多详情

00:33:04.751 --> 00:33:06.820
关于在布局中实际发生了什么

00:33:06.887 --> 00:33:10.057
所以我们准备要直接滑动到日志底部

00:33:10.123 --> 00:33:15.429
这段顶层视图被称为
CallStacksSentTo

00:33:15.495 --> 00:33:17.965
所以在那儿 你只需要查找它就可以了

00:33:19.199 --> 00:33:24.872
现在 这样的顶层视图可以不止一个
大家知道通常只有一个

00:33:24.938 --> 00:33:28.976
这是个很复杂的情况
其中有几个顶层视图

00:33:29.209 --> 00:33:31.645
它们非常相似 我准备给大家展示一个

00:33:31.712 --> 00:33:35.315
在回溯的顶部是一些漏斗类函数

00:33:35.382 --> 00:33:38.986
用于反馈回路调试器
但非常接近你看到的顶部视图

00:33:39.052 --> 00:33:42.356
即在框架五中看到的
DropShadowViews

00:33:42.422 --> 00:33:43.757
接收一组边界

00:33:44.324 --> 00:33:47.528
如果你记得递归描述中

00:33:47.594 --> 00:33:51.098
DropShadowView是
TransitionView子视图

00:33:51.398 --> 00:33:54.668
DropShadowView
设置边界的唯一方式是

00:33:54.735 --> 00:33:56.537
在TransitionView上
调用setNeedsLayout

00:33:56.603 --> 00:33:58.906
因为TransitionView
不在布局中

00:33:59.273 --> 00:34:03.710
这样 在框架七中正在运行布局的视图

00:34:03.777 --> 00:34:05.979
不是TransitionView
而是其它东西

00:34:06.046 --> 00:34:08.649
但是在这个回溯中我们没有看到该信息

00:34:08.715 --> 00:34:11.418
我没有这个特定应用的符号

00:34:11.485 --> 00:34:15.589
所以 它们在这儿没有显示
此外 这可以是个视图

00:34:15.656 --> 00:34:18.058
此处我们很幸运
因它是DropShadowView

00:34:18.125 --> 00:34:20.194
接收设定界限 覆盖设定界限

00:34:20.260 --> 00:34:22.262
但它可能是一个不覆盖设定界限的视图

00:34:22.896 --> 00:34:26.366
但很可能在是回溯的信息中间

00:34:26.433 --> 00:34:28.001
与顶部信息之间

00:34:28.068 --> 00:34:31.071
这样你就可以具体了解
自己感兴趣的内容&lt;\b&gt;

00:34:31.138 --> 00:34:33.507
所以我们感兴趣的是框架的变化

00:34:33.574 --> 00:34:35.342
对于DropShadowView

00:34:36.109 --> 00:34:39.012
所以我们向上回滚会发现信息的所在

00:34:39.079 --> 00:34:41.849
这在一些结构变化信息之下

00:34:42.349 --> 00:34:47.588
我们看到实际上这些结构变化

00:34:47.654 --> 00:34:49.656
边界变化以及框架变化……

00:34:49.790 --> 00:34:51.757
变化一直在不停地重复中

00:34:52.025 --> 00:34:54.761
其中的两个变化出现在布局过程中

00:34:54.828 --> 00:34:57.698
在TransitionView上
合理的 也在预料中

00:34:57.998 --> 00:35:02.269
但其中一个来自
viewLayoutSubviews类函数

00:35:02.436 --> 00:35:05.873
即该视图的一个特定视图控制器

00:35:05.939 --> 00:35:08.041
即TransitionView
子视图

00:35:08.408 --> 00:35:10.511
所以我们已经定位了问题

00:35:10.811 --> 00:35:15.215
修复这个漏洞的方式是依靠程序员

00:35:15.282 --> 00:35:18.585
找出其它方式来实现他们的目的

00:35:18.652 --> 00:35:23.891
且不改变布局中子视图的边界

00:35:27.160 --> 00:35:31.365
好了 下面让我们休息一下
因为我们要转到示例二了

00:35:31.431 --> 00:35:35.002
这是一个完全不同种类的反馈环路

00:35:36.503 --> 00:35:39.173
对于那些一直在用自动布局的人来说

00:35:39.473 --> 00:35:40.941
如果要做很复杂的事情

00:35:41.008 --> 00:35:43.944
你可能会遇到模棱两可的布局问题

00:35:44.144 --> 00:35:47.447
而模棱两可的布局通常不是那么可怕

00:35:47.648 --> 00:35:50.918
通常你可能会碰到一堆大小为0的视图

00:35:50.984 --> 00:35:52.452
你就会想我的视图到哪里去了

00:35:52.519 --> 00:35:56.323
或者说可能该视图就是你所要的

00:35:56.390 --> 00:36:02.829
除了偶尔旋转设备会获得不同的布局外

00:36:04.131 --> 00:36:06.567
但是有时真的会很不幸

00:36:06.633 --> 00:36:09.536
在优化布局的更新限制通过时

00:36:09.603 --> 00:36:14.441
你可以训练这种歧义
而如果歧义被训练了

00:36:14.775 --> 00:36:18.178
则每一个都会发生变量变化

00:36:18.245 --> 00:36:20.914
每次它都将在某个地方扰乱布局

00:36:20.981 --> 00:36:22.349
这样你就明白了这个循环

00:36:23.584 --> 00:36:27.487
现在一个模棱两可的布局
作为布局反馈环路

00:36:27.554 --> 00:36:32.159
导致一些让你挠头的事情

00:36:32.226 --> 00:36:33.594
除非你能想到

00:36:33.827 --> 00:36:38.599
所以 这就是为什么我们总是
尽可能在日志顶部调用它

00:36:38.732 --> 00:36:40.534
这样它们已经在考虑它了

00:36:40.968 --> 00:36:44.304
所以这就是说模棱两可的布局被怀疑了

00:36:44.371 --> 00:36:46.740
然后当你查看递归描述时

00:36:46.940 --> 00:36:50.210
你看到模糊布局遍布到处都是
你也知道

00:36:50.277 --> 00:36:51.445
这很可疑

00:36:52.079 --> 00:36:54.248
我先说点题外话

00:36:54.448 --> 00:36:58.886
因为在这些日志中
我进行了一些缩略处理

00:36:58.952 --> 00:37:01.121
以便它们能在幻灯片上显示正常

00:37:01.421 --> 00:37:04.658
但是有个缩略语大家可能不认识

00:37:04.725 --> 00:37:08.161
实际上就在日志中 叫做tAMIC

00:37:08.295 --> 00:37:10.831
大家可以看到就在模棱两可的布局旁边

00:37:11.164 --> 00:37:11.999
tAMIC表示

00:37:12.065 --> 00:37:14.668
将Auto Resizing Mask
翻译成约束条件

00:37:14.735 --> 00:37:16.837
现在大家都可以这么称呼它

00:37:19.673 --> 00:37:24.411
无论如何
有歧义的布局肯定是我们的问题

00:37:24.878 --> 00:37:26.880
我们可以去看回溯

00:37:26.947 --> 00:37:29.883
对setNeedsLayout
设为顶层视图 但我没有

00:37:29.950 --> 00:37:33.053
这就是内部
Foundation和UIKit类函数

00:37:33.520 --> 00:37:34.988
这对我们没什么帮助

00:37:35.055 --> 00:37:36.790
我们得去看细节

00:37:36.857 --> 00:37:42.896
此处的详情
将会告诉我们变量发生变化的视图

00:37:42.963 --> 00:37:44.331
这些变化正触发布局

00:37:44.765 --> 00:37:51.205
关于模棱两可的布局
需要记住的一点是 它会蔓延

00:37:51.471 --> 00:37:53.907
所以你可能只是遗漏了几个约束条件

00:37:54.208 --> 00:37:55.909
但是一堆视图都是模棱两可的

00:37:55.976 --> 00:37:58.345
因为它们都是互相依赖的

00:37:58.579 --> 00:38:02.649
这样 你会发现很多这类视图
但只能从一个开始

00:38:02.716 --> 00:38:03.984
而一旦这个解决了

00:38:04.618 --> 00:38:07.054
剩下的即便无法全部解决
但也能解决大部分

00:38:07.588 --> 00:38:11.024
大家来看这儿
可以看到最小的x变量

00:38:11.091 --> 00:38:14.628
在-120到-160之间振荡

00:38:14.695 --> 00:38:16.697
不管怎样都是某个奇数

00:38:17.097 --> 00:38:20.200
因为它是模糊布局
我们列出了约束条件

00:38:20.567 --> 00:38:22.569
这些约束条件影响布局

00:38:22.703 --> 00:38:26.240
然后你很可能检查出来丢失了什么

00:38:26.640 --> 00:38:29.576
我准备现在就开始检查约束条件

00:38:29.910 --> 00:38:33.213
因为看到一系列约束条件可能会很吓人

00:38:33.814 --> 00:38:36.984
而画图描述是唯一的处理办法

00:38:37.284 --> 00:38:40.454
我想从一张视图层次结构的图片开始

00:38:40.521 --> 00:38:43.690
这些视图被列在了约束条件之中

00:38:43.757 --> 00:38:47.094
幸运的是 在这个例子中
所有的视图都属于不同的子类

00:38:47.160 --> 00:38:49.062
所以我可以把它们标记出来给大家看

00:38:49.530 --> 00:38:52.399
接下来我要做的是给自己画张图

00:38:52.566 --> 00:38:54.034
描述约束条件是什么

00:38:54.101 --> 00:38:58.071
所以约束条件是一个
最小的前导和尾随填充

00:38:58.138 --> 00:39:00.007
对于容器中的标签而言

00:39:00.440 --> 00:39:02.943
有一个定心的约束条件

00:39:03.010 --> 00:39:05.012
介于容器和操作视图之间

00:39:05.479 --> 00:39:08.382
然后操作视图中
有自动缩放的掩模约束条件

00:39:08.448 --> 00:39:11.018
将其安置在呈现视图之中

00:39:11.084 --> 00:39:12.553
某个奇怪的地方

00:39:12.619 --> 00:39:14.821
有些东西明显惧怕这些约束条件

00:39:15.355 --> 00:39:20.794
最终在呈现视图
及其同类视图之间将会进行对齐

00:39:21.261 --> 00:39:23.597
但是没有什么会真正坚持

00:39:23.664 --> 00:39:27.201
整个视图层次需要在任何特定的地方

00:39:27.601 --> 00:39:34.107
这就是我们为什么要介绍模糊视图
和布局反馈环路

00:39:35.275 --> 00:39:39.613
这就是布局反馈回路调试器
它是一个启动自变量

00:39:39.680 --> 00:39:43.350
你不会经常需要使用它
当你需要时 可节约大量时间

00:39:43.884 --> 00:39:47.087
简要回顾一下 我们看了...

00:39:47.154 --> 00:39:50.424
如何逐步使用自动布局和
Interface Builder

00:39:50.757 --> 00:39:53.794
在AppKit中
有类似网格布局NSGridView

00:39:53.861 --> 00:39:57.497
若你想很快在iOS中看到它
请到Apple Bug Reporter中投票

00:39:57.764 --> 00:40:00.934
最后 我们还谈到了反馈环路调试阈值

00:40:01.401 --> 00:40:04.071
若要了解更多详情
请访问Dub-Dub网站

00:40:04.137 --> 00:40:07.407
希望大家下午过得愉快
感谢你们的到来