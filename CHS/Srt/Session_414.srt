00:00:19.353 --> 00:00:24.992 
Xcode源代码编辑器的使用和扩展

00:00:28.262 --> 00:00:29.096 
大家好

00:00:29.530 --> 00:00:32.432 
欢迎来到“Xcode
源代码编辑器的使用与扩展”

00:00:32.933 --> 00:00:35.102 
我是Mike 是Xcode工程师

00:00:35.269 --> 00:00:37.471 
我是你们和beer bash
之间的必经之路

00:00:39.873 --> 00:00:41.575 
那我们今天要讲的是什么呢？

00:00:42.809 --> 00:00:44.011 
嗯我们马上开始

00:00:44.077 --> 00:00:46.947 
我将给大家展示XCode 8中
一些新增的很棒的功能

00:00:47.147 --> 00:00:48.315 
但这还不是全部

00:00:48.382 --> 00:00:50.551 
我还会给大家展示
一些非常有帮助的功能

00:00:50.617 --> 00:00:53.420 
这些都已经集成在
今天正运行的Xcode中

00:00:53.487 --> 00:00:55.422 
你可能对这些并不了解

00:00:55.489 --> 00:00:56.723 
但是我觉得它们非常酷

00:00:57.291 --> 00:01:01.228 
我每天都用它们来快速编辑
和操控Xcode的源代码库

00:01:01.895 --> 00:01:05.331 
需要说明的是我这里给大家
展示的所有东西

00:01:05.666 --> 00:01:07.534 
在Xcode中的都是标准集成的

00:01:08.135 --> 00:01:11.271 
然后我的同事Chris会到台上来

00:01:11.405 --> 00:01:14.141 
教大家如何拓展我们所提供的东西

00:01:14.474 --> 00:01:17.110 
并教大家如何进一步
扩展Xcode源代码编辑器

00:01:18.145 --> 00:01:20.147 
你可以编写扩展程序

00:01:20.214 --> 00:01:23.183 
让编辑器做一些你经常要它做的事情

00:01:23.283 --> 00:01:25.185 
然后你甚至还可以分享这些扩展程序

00:01:25.252 --> 00:01:28.222 
给你的朋友同事甚至全世界

00:01:28.288 --> 00:01:30.591 
在源代码编辑器中
你将会注意到的第一个东西

00:01:30.657 --> 00:01:34.194 
或者你只要在今天会场上
抬头环视一下就会看到

00:01:34.261 --> 00:01:37.698 
我们新的源代码字体SF mono

00:01:38.799 --> 00:01:42.069 
这是mono space对系统字体
San Francisco的致敬

00:01:42.669 --> 00:01:47.841 
我们的字体专家特意设计了适合显示屏
retina的SF mono字体

00:01:48.208 --> 00:01:49.543 
还精心设计了

00:01:49.610 --> 00:01:51.945 
程序代码符的各种符号字体

00:01:52.012 --> 00:01:54.882 
即便在很小的尺寸上都清晰可辨

00:01:55.782 --> 00:01:57.117 
大家将注意到的下一个是

00:01:57.184 --> 00:01:59.353 
看我正在编辑器中来回移动的地方

00:01:59.987 --> 00:02:03.156 
就是我们对当前编辑行会进行高亮显示

00:02:03.223 --> 00:02:05.492 
这样一目了然很快就可以
定位当前编辑的地方

00:02:06.326 --> 00:02:10.531 
每个内置的Xcode主题都有精细的

00:02:11.131 --> 00:02:14.401 
人工配置的高亮颜色但也可自定义

00:02:14.635 --> 00:02:16.937 
所以你可以按自己喜好
将它改得尽量醒目

00:02:17.004 --> 00:02:20.040 
或者如果你不喜欢这样的
也可将它设置为完全透明

00:02:21.542 --> 00:02:25.479 
你可能已经熟悉我们的注释
和取消注释的命令

00:02:25.546 --> 00:02:26.780 
也就是“/”命令对吧？

00:02:27.814 --> 00:02:29.850 
对了我们增加了一个新的命令

00:02:30.083 --> 00:02:34.354 
你可以点击选项键并
使用“/”命令把它调出来

00:02:34.788 --> 00:02:35.622 
这样就插入

00:02:36.123 --> 00:02:37.391 
一个资料注释

00:02:43.797 --> 00:02:44.631 
因此

00:02:44.865 --> 00:02:49.603 
这可以直接用于任何
类函数 类 结构体或它们之上

00:02:49.903 --> 00:02:53.073 
你也知道这些东西
是一种结构性的码位元素

00:02:53.574 --> 00:02:54.441 
此外

00:02:55.909 --> 00:02:58.078 
大家还会注意到此处这些小占位符

00:02:58.145 --> 00:03:00.781 
众所周知这些用来描述你的类函数

00:03:00.914 --> 00:03:02.482 
或讨论参数

00:03:04.017 --> 00:03:06.687 
throws描述或者大家都知道的

00:03:06.753 --> 00:03:08.989 
描述一些有关返回值的重要内容

00:03:09.323 --> 00:03:13.193 
真正有价值的是这些片段性的资料

00:03:13.293 --> 00:03:16.196 
你在代码中添加的会在快速帮助中出现

00:03:16.296 --> 00:03:19.499 
还会在代码完成窗口的底部出现

00:03:20.567 --> 00:03:23.070 
还有请注意我们提供了

00:03:23.136 --> 00:03:24.605 
新的SF mono字体

00:03:24.905 --> 00:03:27.574 
提供了更多选择
而不仅局限于常规和加粗

00:03:28.108 --> 00:03:31.311 
资料注释使用SF mono细体

00:03:31.411 --> 00:03:33.814 
而关键字使用SF mono中等

00:03:33.881 --> 00:03:36.283 
只是更亮更粗一点

00:03:36.350 --> 00:03:39.152 
相对于文件中其它内容都使用
的SF mono常规字体

00:03:40.153 --> 00:03:41.788 
不同于大多数
其它mono space字体

00:03:42.022 --> 00:03:44.658 
我们给SF mono
配置了完整的磅数表

00:03:44.925 --> 00:03:47.227 
从细体到半粗体再到黑体

00:03:47.561 --> 00:03:49.429 
我们还引入了斜体差异配置项

00:03:50.097 --> 00:03:52.165 
这可以保持每个字符之间的间距

00:03:52.232 --> 00:03:55.669 
即便是对需要强调的内容
进行精准自定义也可胜任

00:03:57.771 --> 00:04:00.741 
下面讲下一功能我将展示
如何跳转到另一个文件

00:04:00.807 --> 00:04:04.711 
我通过按下Command
及Shift O实现快速打开

00:04:04.845 --> 00:04:08.549 
并输入几个字符转到
我的TimerViewController

00:04:10.984 --> 00:04:12.653 
大家可能之前见过这个

00:04:13.120 --> 00:04:15.055 
这是文档条目菜单

00:04:15.822 --> 00:04:18.659 
通过按Control 6
就可以打开这个菜单

00:04:20.060 --> 00:04:22.696 
它拥有所有的类、结构体、枚举、属性

00:04:22.896 --> 00:04:24.631 
该文件中所有的东西

00:04:25.566 --> 00:04:27.568 
但这并不是最有趣的部分

00:04:27.901 --> 00:04:30.838 
你知道吗当这个菜单
弹出只要你一开始输入

00:04:30.904 --> 00:04:33.440 
它就会对项目进行过滤？

00:04:34.408 --> 00:04:38.011 
然后你就会注意到此处

00:04:38.378 --> 00:04:40.447 
这个小小的“待修正”注释

00:04:40.547 --> 00:04:43.784 
实际上就有个小的创可贴图标在上面

00:04:44.218 --> 00:04:45.919 
我觉得这很可爱

00:04:47.754 --> 00:04:48.589 
接下来...

00:04:51.024 --> 00:04:53.193 
转到这儿进入
my load view 类函数

00:04:53.961 --> 00:04:56.496 
在这儿你可以看到
每个图片都有一种颜色

00:04:56.563 --> 00:04:59.099 
我们一直在等设计师为我们提供

00:04:59.733 --> 00:05:02.870 
其实我昨晚才弄了这些P&amp;G's

00:05:02.936 --> 00:05:05.239 
我把它们放进jogger资源目录

00:05:05.772 --> 00:05:07.174 
这样我们就能真正

00:05:07.274 --> 00:05:08.442 
在下面的库里看到它们

00:05:09.576 --> 00:05:10.978 
这个用于Timer Button

00:05:12.012 --> 00:05:15.616 
接下来我要从这儿选择当前行的末尾

00:05:15.716 --> 00:05:19.186 
通过按下Control E
并同时按住Shift键

00:05:20.153 --> 00:05:23.423 
我将按下Command
Space调用代码完成

00:05:24.725 --> 00:05:26.226 
现在仔细看

00:05:26.360 --> 00:05:29.363 
我要使用代码完成
窗口直接分配这张图片

00:05:30.297 --> 00:05:33.066 
我只需要输入t b就可以获取
我的Timer Button

00:05:34.535 --> 00:05:37.738 
你还会注意到和Xcode 7.3
一样的代码完成窗口

00:05:37.804 --> 00:05:39.940 
现在用了相同的模糊匹配算法

00:05:40.174 --> 00:05:42.976 
与快速打开、文档条目菜单

00:05:43.177 --> 00:05:45.512 
甚至在资料窗口的新搜索所用算法一样

00:05:46.613 --> 00:05:49.550 
在左边你还可以看到图片的预览

00:05:49.616 --> 00:05:52.019 
这样你就能知道所选择的是否正确

00:05:52.753 --> 00:05:53.587 
接下来...

00:05:54.288 --> 00:05:56.423 
在源代码中就在这儿Boom

00:05:56.924 --> 00:05:58.025 
这是图文并茂的

00:06:04.898 --> 00:06:06.733 
因此库里的的每一张图片

00:06:06.800 --> 00:06:09.203 
不管是来自资源目录

00:06:09.269 --> 00:06:11.071 
还是仅仅作为项目的参考

00:06:11.138 --> 00:06:13.207 
现在都可以从代码完成窗口中看到

00:06:13.273 --> 00:06:14.308 
在源代码编辑器中

00:06:15.576 --> 00:06:18.846 
接下来让这生效的方式
就是插入一个Swift特定实体

00:06:19.146 --> 00:06:21.548 
在源代码中这对
Swift编译器是已知的

00:06:21.915 --> 00:06:24.852 
而且它解除了对指定
UIImage图像的调用

00:06:25.319 --> 00:06:28.722 
这样你就可以看到所有图片都
放置有序而不仅仅是名称字符串

00:06:29.489 --> 00:06:31.024 
且对颜色也进行了同样处理

00:06:31.692 --> 00:06:33.994 
接下来我要从这儿选择当前行的末尾

00:06:34.728 --> 00:06:37.764 
并调用代码完成和类型颜色

00:06:39.266 --> 00:06:43.237 
当我在此处敲击Return
会发生什么呢

00:06:43.537 --> 00:06:46.573 
大家会注意到我把
非常整洁的颜色选取器调出来了

00:06:48.475 --> 00:06:50.410 
从这儿我只需用向下的方向键

00:06:50.677 --> 00:06:54.181 
选择一种颜色就像这样
就可以选择优雅的绿色

00:06:55.782 --> 00:06:58.819 
需要知道很重要的一点是
所有这些图像和彩色文字

00:06:58.886 --> 00:07:01.054 
都是全键盘导航的

00:07:01.588 --> 00:07:05.826 
若我在某个文本上按住Shift
和回退箭头并点击Return

00:07:05.893 --> 00:07:07.861 
就会把颜色选取器再次调出来

00:07:08.562 --> 00:07:10.964 
而且你知道我还是可以用方向键选择

00:07:11.532 --> 00:07:15.702 
但是如果这些弹出来的颜色
不是你正要找的

00:07:15.769 --> 00:07:17.938 
大家看如果这刚好不是我正要找的

00:07:18.705 --> 00:07:20.040 
你可以使用最近的颜色

00:07:20.107 --> 00:07:22.409 
这也是和Interface
Builder共享的

00:07:22.709 --> 00:07:25.078 
或者你可以点击这儿下面的其他按钮

00:07:25.145 --> 00:07:27.447 
它会调出标准的系统颜色面板

00:07:28.482 --> 00:07:34.121 
在这种情况中我其实只是想取样
这种非常优雅的海军蓝就从这个按钮

00:07:34.188 --> 00:07:37.357 
因为在我构建它时
这就和该按钮是绑定的

00:07:38.492 --> 00:07:41.061 
但我们此处还是有点小错误

00:07:41.662 --> 00:07:44.765 
此处的颜色文本是UIColor

00:07:44.831 --> 00:07:49.903 
但我们将其指定的层是cgLayer
所以应该需要cgColor

00:07:50.404 --> 00:07:53.106 
所以我可以很快解决这个问题就像这样

00:07:59.313 --> 00:08:02.216 
希望这样已经讲清楚了图像和颜色文本

00:08:02.282 --> 00:08:06.620 
实际上都是完整分类和检查的
在Swift中是实的对象

00:08:08.522 --> 00:08:10.490 
我下面想要给大家演示的

00:08:11.391 --> 00:08:15.262 
其实并不是一个新功能
它甚至不是Xcode的功能

00:08:16.029 --> 00:08:18.866 
它实际上属于标准的Cocoa
Text系统的一部分

00:08:18.932 --> 00:08:21.201 
从macOS 10.0之前就这样

00:08:22.603 --> 00:08:24.171 
这就是查找粘贴板

00:08:24.671 --> 00:08:26.373 
大家可能之前没有注意过

00:08:26.440 --> 00:08:29.543 
如果你进行了查找
可能通过选择一些文本

00:08:30.110 --> 00:08:35.749 
比如说此处Pause 然后使用
Command C将其复制到粘贴板

00:08:35.816 --> 00:08:38.418 
再使用Command F调出查找框

00:08:38.485 --> 00:08:40.687 
然后通过Command V
将它粘贴其中

00:08:41.321 --> 00:08:47.528 
相同的搜索过程
也会出现在其他应用程序中

00:08:48.562 --> 00:08:50.063 
这很奇怪不是吗？

00:08:51.031 --> 00:08:51.865 
嗯

00:08:53.433 --> 00:08:56.436 
这是因为查找粘贴板是...

00:08:56.904 --> 00:09:01.508 
它其实是跨应用程序工作的
就像众所周知的剪贴板

00:09:02.576 --> 00:09:05.979 
它与剪贴板是并存的
而且两者可以同时存在

00:09:06.280 --> 00:09:09.917 
所以实际上就有一个非常酷的技巧
如果你有一些东西

00:09:09.983 --> 00:09:12.853 
想要保留在剪贴板中而不被清除

00:09:13.754 --> 00:09:15.455 
但是如果你仍然想要搜索

00:09:16.757 --> 00:09:19.092 
比如从这儿开始搜索

00:09:19.593 --> 00:09:21.795 
你只需要按下Command E

00:09:22.196 --> 00:09:24.898 
就会把它直接推送到查找粘贴板中

00:09:25.666 --> 00:09:29.336 
然后这样就可以
让你点击Command G

00:09:29.403 --> 00:09:33.774 
并循环遍历该文件中所有匹配的内容

00:09:35.242 --> 00:09:39.279 
现在如果你只是
想在同一文件中快速查找和替换

00:09:39.546 --> 00:09:41.448 
我们也提供一条专门的命令

00:09:42.249 --> 00:09:46.019 
如果你按住
Command Control E

00:09:46.620 --> 00:09:48.856 
实际就会对整个范围内的
全部内容执行编辑

00:09:49.223 --> 00:09:51.859 
这样就修改了本文件中
所有该符号的实例

00:09:52.292 --> 00:09:54.895 
所以这里我可以给这个类函数加上ED

00:09:54.962 --> 00:09:56.964 
因为started听起来更好一点

00:09:57.898 --> 00:09:58.732 
而且...

00:10:00.868 --> 00:10:03.971 
这种方法可以大大节约时间
我自己就经常使用它

00:10:05.105 --> 00:10:08.041 
现在如果你想要做的是移动大约几行

00:10:08.275 --> 00:10:10.511 
你也不需要剪贴板来完成

00:10:10.577 --> 00:10:13.180 
实际上我们提供了
一条专门的命令来完成这个

00:10:13.914 --> 00:10:20.153 
若此处选择几行并按住Command
Option Bracket

00:10:20.687 --> 00:10:24.291 
你会注意到我其实可以移动整个区块

00:10:24.358 --> 00:10:27.561 
在if函数和其它类函数
的里面或外面移动

00:10:28.962 --> 00:10:32.566 
它们只是在你的代码里整体挪动

00:10:35.169 --> 00:10:36.837 
这确实很棒

00:10:36.904 --> 00:10:39.506 
如果你每次只在同一文件中操作

00:10:39.706 --> 00:10:42.543 
但若你想在其它文件中进行交叉查找

00:10:44.745 --> 00:10:48.115 
例如若我想找出所有的timer实例

00:10:49.483 --> 00:10:53.987 
你可以通过按住
Command F和Shift完成

00:10:54.054 --> 00:10:55.389 
实现在整个项目内查找

00:10:56.290 --> 00:10:58.091 
这里我就...

00:10:58.926 --> 00:11:02.996 
把timer加入到我的查找粘贴板中
进行搜索的

00:11:05.299 --> 00:11:08.802 
这实际上是我最近才被告知的一个特性

00:11:09.403 --> 00:11:13.574 
我不需要点击进入
查找导航框其实就可以开始

00:11:13.640 --> 00:11:15.309 
通过上下键选择这些结果

00:11:15.742 --> 00:11:17.678 
此处Command G也可以实现

00:11:17.945 --> 00:11:20.614 
唯一不同的是
我仅按住了Control键

00:11:20.681 --> 00:11:22.282 
同时按下了Command G

00:11:22.783 --> 00:11:25.552 
这样就可以遍历所有的结果

00:11:25.786 --> 00:11:27.321 
在所有不同的文件内遍历

00:11:28.455 --> 00:11:30.691 
包括Interface
Builder文档

00:11:30.824 --> 00:11:33.227 
以及其中所有的实例和匹配记录

00:11:34.995 --> 00:11:37.164 
通过按住Shift可逆向实施

00:11:37.264 --> 00:11:38.699 
与Command G效果一样

00:11:39.766 --> 00:11:42.870 
所以我不知道我知道有些人其实

00:11:43.003 --> 00:11:44.371 
把这些记下来

00:11:45.572 --> 00:11:49.877 
但是你真的不需要记
因为在Xcode中其实就有个地方

00:11:49.943 --> 00:11:52.312 
提供了所有这些命令的完整列表

00:11:52.579 --> 00:11:53.814 
及其相应的按键

00:11:54.281 --> 00:11:56.850 
这就在Xcode参数设置窗口中

00:11:58.585 --> 00:12:00.821 
在这儿在按键绑定设置窗格中

00:12:01.388 --> 00:12:03.257 
你其实可以进行搜索

00:12:03.323 --> 00:12:06.527 
搜索任何涉及到的东西

00:12:06.894 --> 00:12:08.629 
你可以查看所有的结果

00:12:09.463 --> 00:12:12.666 
还有如果你含糊地重新调用

00:12:12.733 --> 00:12:15.035 
可能会有某种显示命令

00:12:15.102 --> 00:12:20.140 
你可以按下Command J

00:12:20.974 --> 00:12:23.810 
这实际上也就是搜索键盘快捷键

00:12:23.944 --> 00:12:25.145 
这确实很强大

00:12:25.779 --> 00:12:29.616 
如果你不喜欢我们为Xcode
所有内置命令而设置的键盘快捷键

00:12:29.850 --> 00:12:31.485 
你可以从此处自行设置

00:12:33.153 --> 00:12:34.521 
此外……

00:12:35.289 --> 00:12:37.057 
如果我们的内置命令不够

00:12:37.124 --> 00:12:38.892 
且/或者刚好无法完成

00:12:38.959 --> 00:12:42.362 
你经常希望代码编辑器做的事情

00:12:42.629 --> 00:12:44.031 
我想邀请Chris上台

00:12:44.531 --> 00:12:47.467 
教大家如何添加自定义的命令
Chris

00:12:53.273 --> 00:12:54.107 
谢谢你Mike

00:12:57.244 --> 00:12:59.880 
如Mike所说我是Chris
今天我要向大家展示

00:12:59.947 --> 00:13:03.283 
如何通过源代码编辑器扩展Xcode

00:13:04.518 --> 00:13:07.955 
现在向大家展示
如何向源代码编辑器添加个人命令

00:13:08.155 --> 00:13:11.024 
使之成为编辑器菜单的一部分

00:13:12.025 --> 00:13:14.695 
你的命令可以修改用户的文本

00:13:15.195 --> 00:13:17.998 
以及该文本内的选项

00:13:18.098 --> 00:13:19.366 
说到运行导航

00:13:20.100 --> 00:13:22.669 
与一些其他类型的应用程序扩展不同

00:13:23.103 --> 00:13:29.009 
你可以将任何数量的命令作为
Xcode源代码编辑器的扩展来实现

00:13:31.111 --> 00:13:35.582 
我们将Xcode扩展建立在
应用程序扩展的基础上

00:13:35.682 --> 00:13:39.253 
这是我们所有操作系统扩展性的基础

00:13:40.554 --> 00:13:43.457 
既然Xcode拓展
即是应用程序拓展

00:13:43.891 --> 00:13:48.962 
各个run函数即在各自进程中
并能执行所有在该进程内接受的命令

00:13:49.029 --> 00:13:54.535 
且不会对Xcode或
其他扩展造成干扰

00:13:55.836 --> 00:14:00.941 
当然作为应用程序扩展
Xcode扩展也是沙箱型的

00:14:01.008 --> 00:14:05.179 
并通过各种权限来
完成脱离该沙箱所需做的事

00:14:06.713 --> 00:14:11.852 
Xcode只能访问Xcode扩展

00:14:11.919 --> 00:14:16.456 
以及在运行时所需的文本与元数据

00:14:17.224 --> 00:14:18.926 
以此来执行相关操作

00:14:19.826 --> 00:14:22.196 
它们无法访问项目结构

00:14:22.362 --> 00:14:25.832 
以及磁盘上的用户文件

00:14:27.568 --> 00:14:28.969 
为什么我们要这样设计呢？

00:14:29.670 --> 00:14:30.571 
当然...

00:14:31.004 --> 00:14:31.872 
为了稳定性

00:14:32.573 --> 00:14:35.642 
我们希望确保Xcode能尽量稳定

00:14:35.709 --> 00:14:37.044 
对我们所有的用户

00:14:38.378 --> 00:14:40.280 
以及安全性考虑

00:14:40.881 --> 00:14:43.951 
应用程序扩展是我们提供给大家来

00:14:44.017 --> 00:14:48.255 
增强操作系统及我们现有工具的方式

00:14:48.322 --> 00:14:51.491 
并同时能保持整个系统的完整性

00:14:52.559 --> 00:14:55.896 
当然还有运行速度方面的考虑

00:14:56.296 --> 00:15:00.534 
应用程序扩展是建立在
Mach信息与XPC之上的

00:15:00.934 --> 00:15:02.236 
并且是完全异步的

00:15:02.302 --> 00:15:06.740 
因此它们能快速运行且
不会降低用户的速度

00:15:07.641 --> 00:15:09.643 
还有另一个原因

00:15:09.710 --> 00:15:12.513 
我们决定将应用程序扩展

00:15:12.579 --> 00:15:14.448 
作为Xcode扩展的基础

00:15:15.983 --> 00:15:19.286 
这是为了将它们放到
Mac APP Store内

00:15:27.060 --> 00:15:29.830 
就像所有其他应用程序扩展一样

00:15:30.063 --> 00:15:34.168 
Xcode扩展被嵌入到了
一个主应用程序中

00:15:35.135 --> 00:15:37.538 
该主应用程序是一个理想的载体

00:15:37.804 --> 00:15:41.041 
来搭载你的扩展偏好或配置信息

00:15:41.308 --> 00:15:43.410 
例如为了控制

00:15:43.477 --> 00:15:46.580 
用户实际希望从你的拓展中
能够使用的命令

00:15:47.281 --> 00:15:50.551 
并且这也是一个搭载其他任何

00:15:50.617 --> 00:15:52.486 
你希望该拓展所提供的UI理想载体

00:15:52.786 --> 00:15:56.256 
因为Xcode所能做的是提供有关

00:15:56.557 --> 00:15:58.091 
你的各命令的菜单项

00:15:59.560 --> 00:16:04.831 
成为了应用程序便能进而实现
应用程序扩展

00:16:05.065 --> 00:16:09.369 
便能在Mac App Store上
找到Xcode扩展

00:16:09.803 --> 00:16:14.041 
当然你还可以登录
你的应用程序和你的Xcode扩展

00:16:14.107 --> 00:16:18.745 
通过你的developer ID
并对其按照你的意愿进行分配

00:16:26.320 --> 00:16:28.055 
现在我们来谈谈关于

00:16:28.155 --> 00:16:30.824 
Xcode是如何激活你的扩展的

00:16:32.025 --> 00:16:34.595 
为保证最佳性能

00:16:34.862 --> 00:16:38.799 
Xcode会查找你的扩展
并自动将其启动

00:16:38.866 --> 00:16:41.668 
在Xcode启动过程的早期

00:16:41.735 --> 00:16:43.036 
XCODE扩展生命周期

00:16:43.103 --> 00:16:45.272 
在你的用户使用扩展之前

00:16:45.939 --> 00:16:50.744 
源代码编辑器扩展并不像
一些其他类的应用程序扩展

00:16:51.011 --> 00:16:53.647 
只能使用一次之后便不能使用了

00:16:54.348 --> 00:16:57.184 
实际上Xcode会尽可能将你的扩展

00:16:57.251 --> 00:16:59.186 
维持为可用状态

00:16:59.253 --> 00:17:02.556 
因此它可以发送任何用户
想要调用的命令

00:17:04.657 --> 00:17:06.894 
现在当你的扩展启动时

00:17:07.327 --> 00:17:10.329 
如果它需要即刻进行任何工作

00:17:10.464 --> 00:17:14.034 
Xcode将向它发送
extensionDidFinishLaunching

00:17:14.701 --> 00:17:18.539 
对于启动来说只要够快
那就是一个好的地方

00:17:20.641 --> 00:17:24.511 
没错 你需要尽可能地让启动过程够快

00:17:24.877 --> 00:17:28.949 
这样一来你的用户就能

00:17:29.516 --> 00:17:31.051 
随时使用该扩展

00:17:32.886 --> 00:17:34.154 
为了帮你实现这一目标

00:17:34.421 --> 00:17:37.191 
Xcode将保证你的扩展与

00:17:37.257 --> 00:17:40.027 
其他扩展的启动是异步进行的

00:17:40.093 --> 00:17:41.795 
且与Xcode的启动也是异步的

00:17:43.931 --> 00:17:45.832 
现在当你的扩展启动时

00:17:46.333 --> 00:17:48.635 
Xcode会询问它的指令

00:17:48.702 --> 00:17:51.505 
指令可以来自两个地方中的一个

00:17:52.906 --> 00:17:55.209 
通过默认函数可以得到一个项

00:17:55.275 --> 00:18:00.781 
info.plist文件中
的NSExtensionAttributes字典类中

00:18:01.448 --> 00:18:04.618 
该文件指定了你的扩展中的所有指令

00:18:05.586 --> 00:18:07.921 
不过你还可以提供

00:18:08.455 --> 00:18:12.526 
关于你的扩展类中的
commandDefinitions的属性重写

00:18:12.826 --> 00:18:16.663 
重写info.plist文件返回值

00:18:16.997 --> 00:18:20.100 
因此 若你的扩展拥有指令动态列表

00:18:20.200 --> 00:18:22.402 
其中有描述
因为下载了新的JavaScript

00:18:22.469 --> 00:18:24.705 
这些JavaScript实际是用来
运行那些指令的

00:18:24.771 --> 00:18:27.741 
它能提供一个新的集合

00:18:31.245 --> 00:18:33.580 
现在一旦Xcode收到你的指令

00:18:34.615 --> 00:18:36.517 
它会给每个扩展分配

00:18:36.817 --> 00:18:41.755 
扩展所对应的编辑器菜单的子菜单
在用户编辑源代码时

00:18:43.457 --> 00:18:46.026 
并按字母顺序列出扩展名

00:18:46.093 --> 00:18:47.895 
就像在finder中一样

00:18:47.961 --> 00:18:50.531 
所以对用户而言
它们都在稳定的地方中

00:18:50.597 --> 00:18:51.865 
从自身运行到Xcode运行

00:18:52.733 --> 00:18:56.069 
然而因为指令的顺序通常很重要

00:18:56.136 --> 00:18:58.839 
而且通常传递大量语义

00:18:59.840 --> 00:19:04.411 
Xcode将保留你所发出指令的顺序

00:19:05.112 --> 00:19:08.248 
并将该顺序在菜单中排列出来

00:19:09.716 --> 00:19:10.984 
现在来谈谈指令调用

00:19:11.485 --> 00:19:15.189 
当然 用户可以从你的菜单项中
选择指令

00:19:16.190 --> 00:19:19.760 
也可以通过个人设置的快捷键来实现

00:19:21.328 --> 00:19:27.234 
你的指令对象将被实例化
并发送调用指令和回调指令

00:19:28.535 --> 00:19:32.206 
调用指令打包所有

00:19:32.773 --> 00:19:34.975 
这些命令执行所需的数据和元数据

00:19:36.643 --> 00:19:40.747 
当工作完成 指令将使用回调程序

00:19:41.114 --> 00:19:43.150 
来告诉Xcode 工作完成

00:19:43.517 --> 00:19:46.186 
让我们看看实际的API

00:19:47.754 --> 00:19:49.723 
我们有个简单的协议

00:19:49.790 --> 00:19:52.292 
你所有的命令类都需要符合它

00:19:53.427 --> 00:19:58.799 
如我所说它已进行了一次调用和
completionHandler回调

00:20:01.101 --> 00:20:04.571 
并且该调用仅携带一些简单的数据

00:20:05.372 --> 00:20:07.174 
且具有一个
commandIdentifier

00:20:07.674 --> 00:20:11.512 
该commandIdentifier在
info.plist文件内或命令定义数组内进行设置的

00:20:13.046 --> 00:20:15.549 
而且这能使你区分多个

00:20:15.816 --> 00:20:18.051 
受控于同一命令类的命令

00:20:18.785 --> 00:20:22.322 
毕竟其中涉及很多命令
特别是对于编辑源代码而言

00:20:22.389 --> 00:20:24.625 
而它们之间的区别却很小

00:20:24.892 --> 00:20:29.530 
大家可能希望通过
同一个命令类来执行多个任务

00:20:29.763 --> 00:20:32.766 
并仅处理各任务中的若干不同特定实例

00:20:33.100 --> 00:20:37.070 
该标识可让大家找出

00:20:37.237 --> 00:20:38.438 
用户调用的命令

00:20:40.374 --> 00:20:41.775 
我们还提供了一个属性

00:20:41.842 --> 00:20:46.446 
你可将cancellationHandler
设置为“开启”

00:20:47.014 --> 00:20:52.252 
若用户取消了你的命令 那么
cancellationHandler即被调用

00:20:53.420 --> 00:20:56.590 
并且如果你的指令
花费时间过长它也会被调用

00:20:56.790 --> 00:21:00.360 
我们将会在演示部分对其进行
略微深入的讲解

00:21:01.828 --> 00:21:05.532 
最后当然调用过程也包含

00:21:05.632 --> 00:21:07.601 
有关用户使用的文本缓存

00:21:09.236 --> 00:21:11.471 
该Source Text由

00:21:11.572 --> 00:21:14.842 
另一个目标实例一
XCSourceTextBuffer来表示

00:21:15.843 --> 00:21:19.379 
除文本之外　还有许多元数据

00:21:20.247 --> 00:21:22.449 
我们给大家一个统一的类型标识

00:21:22.916 --> 00:21:26.253 
让Xcode认为
文本包含的文件是对应的

00:21:26.653 --> 00:21:30.123 
如此大家就可以使用Swift源代码

00:21:31.225 --> 00:21:36.830 
XML数据ObjC++ 头文件等
各种文本格式进行编写

00:21:37.998 --> 00:21:42.936 
我们还为该文件提供了
Xcode的缩进设置

00:21:43.370 --> 00:21:46.440 
所以当你在文件内对文本进行变更时

00:21:46.773 --> 00:21:50.010 
你依然遵循用户期望Xcode做的事

00:21:50.077 --> 00:21:51.578 
当它缩进该文件时

00:21:52.513 --> 00:21:55.082 
因为tabWidth
indentationWidth

00:21:55.148 --> 00:21:58.752 
及是否使用TabsForIndentation间
存在微妙的相互作用关系

00:21:59.453 --> 00:22:02.856 
为此我们还提供了大量
有关它们如何协同工作的详细信息

00:22:03.223 --> 00:22:04.691 
大家可在头文件查阅该信息

00:22:06.059 --> 00:22:08.662 
因此我鼓励大家找出该头文件

00:22:08.729 --> 00:22:10.898 
并确切了解它们是如何相互协同的

00:22:14.368 --> 00:22:19.806 
现在我们提供用户通过两种不同方式
正在使用的文本

00:22:20.607 --> 00:22:24.111 
如果你需要将该文本处理为单数据流

00:22:24.611 --> 00:22:26.813 
即通过管道将其输送到一个命令行工具

00:22:27.481 --> 00:22:28.749 
你大概会希望使用

00:22:28.882 --> 00:22:30.250 
completeBuffer

00:22:30.517 --> 00:22:32.819 
该缓存代表用户正在使用的文本

00:22:32.986 --> 00:22:35.122 
代表作为单一字符串的整个文件

00:22:37.090 --> 00:22:42.062 
然而如果你仅需要对文本进行微小变更

00:22:42.429 --> 00:22:46.266 
那该方法的效率会很低
因为你的扩展需将

00:22:46.333 --> 00:22:48.635 
所有的缓存发回Xcode

00:22:49.970 --> 00:22:54.141 
因为我们为之提供了可变数组属性

00:22:55.375 --> 00:22:58.045 
其中包含文件中的文本行

00:22:58.178 --> 00:23:01.615 
我们发现当采用源代码编写工具时

00:23:01.982 --> 00:23:06.954 
实际上采用行与列抽象化要远优于

00:23:07.020 --> 00:23:11.091 
仅使用单一而庞大的文本缓冲区

00:23:12.092 --> 00:23:14.394 
并且通过成为可变数组

00:23:14.862 --> 00:23:19.633 
还可以让Xcode
实际追踪你进行的变更

00:23:19.833 --> 00:23:24.071 
所以我们只需要发回
个别你所进行的更改

00:23:24.171 --> 00:23:26.473 
不需要发回整个缓存

00:23:27.074 --> 00:23:31.578 
这确实能提高编辑扩展的性能

00:23:34.281 --> 00:23:38.051 
除了提供文件中的文本行

00:23:38.151 --> 00:23:43.056 
我们还为文件中的选项提供了可变数组

00:23:43.423 --> 00:23:45.559 
总会有至少一个选项

00:23:45.626 --> 00:23:48.395 
要么是用户的插入点要么是选项

00:23:48.862 --> 00:23:52.666 
因为Xcode编辑器是构建在
Cocoa Text系统之上的

00:23:53.133 --> 00:23:55.335 
所以我们同样支持多重选项

00:23:55.802 --> 00:23:57.804 
如果你想要改变选项

00:23:58.071 --> 00:24:00.707 
你要做的就是改变该可变数组

00:24:03.010 --> 00:24:07.214 
且该数组中存在的都是
SourceTextRange对象

00:24:07.681 --> 00:24:11.451 
调用SourceTextRange
替换NSRange

00:24:11.518 --> 00:24:13.887 
因为我们真的相信

00:24:14.021 --> 00:24:17.558 
我们提供的行与列抽象

00:24:18.158 --> 00:24:21.061 
对于大多数文本编辑来说是最好的方法

00:24:22.129 --> 00:24:26.600 
这就是为什么源区域能替代
一个位置和一段长度

00:24:27.000 --> 00:24:29.903 
成为实际起点与终点的原因

00:24:30.504 --> 00:24:34.942 
那些位置都在行抽象
与列抽象中得到表示

00:24:38.078 --> 00:24:41.081 
我将向大家演示如何创建

00:24:41.315 --> 00:24:43.917 
个人Xcode扩展

00:24:45.285 --> 00:24:46.653 
我先到演示机这边

00:24:47.855 --> 00:24:48.755 
然后...

00:24:49.523 --> 00:24:51.692 
我把笔记本放在这儿

00:24:52.559 --> 00:24:57.965 
给我留下深刻印象的
是刚才Mike关于

00:24:58.031 --> 00:25:01.268 
Swift文本 Swift色彩
和图像文字的描述

00:25:02.002 --> 00:25:04.705 
我真的很想在我自己的代码中使用它们

00:25:05.105 --> 00:25:06.640 
因此我觉得我该

00:25:06.707 --> 00:25:09.376 
创建一个新的源编辑器扩展

00:25:09.710 --> 00:25:15.115 
它可以自动将任何UIImage
或UIColor的使用方法转变为

00:25:15.315 --> 00:25:17.150 
相应的Swift文字

00:25:18.352 --> 00:25:20.487 
我只需创建一个新的Xcode项目

00:25:21.588 --> 00:25:24.157 
以及一个新的OS X应用程序

00:25:24.658 --> 00:25:26.593 
毕竟我的应用扩展

00:25:26.660 --> 00:25:30.163 
和Xcode扩展都得在
应用程序内部执行

00:25:30.898 --> 00:25:35.569 
然后创建这个
并把它命名为Chris文字

00:25:38.805 --> 00:25:44.411 
然后赋予一个叫做
com.example的组织标识符

00:25:45.812 --> 00:25:48.916 
点击“下一步”然后我把它放在桌面上

00:25:50.050 --> 00:25:51.818 
现在我已经创建了我的项目

00:25:52.619 --> 00:25:55.088 
我要向其添加一个新的目标

00:25:56.523 --> 00:26:00.327 
且添加一个OS X应用程序扩展目标

00:26:00.561 --> 00:26:02.196 
你可以看到

00:26:02.262 --> 00:26:06.500 
新的Xcode源代码编辑器扩展模板
就在该列表的末尾

00:26:09.970 --> 00:26:11.939 
然后我把它命名为...

00:26:13.907 --> 00:26:16.009 
Chris Convert to Literals...

00:26:17.110 --> 00:26:17.978 
搞定

00:26:18.912 --> 00:26:20.314 
当我点击Finish时

00:26:21.114 --> 00:26:24.518 
Xcode就会提出供激活目标的建议

00:26:24.585 --> 00:26:26.486 
就像其他应用扩展一样

00:26:26.687 --> 00:26:27.955 
然后点击接受

00:26:29.256 --> 00:26:32.593 
现在让我们来看看Xcode
为我生成的代码

00:26:35.229 --> 00:26:36.897 
在这个转换为文字的组别里

00:26:37.431 --> 00:26:41.702 
Xcode添加了一个类
这个类表示我的扩展本身

00:26:42.069 --> 00:26:45.973 
这只符合XCSourceEditor扩展协议

00:26:46.707 --> 00:26:51.678 
并且它还为类函数和属性添加了模板

00:26:52.112 --> 00:26:55.215 
如果我想重写的话我可以对其取消注释

00:26:55.415 --> 00:26:57.117 
并提供自己的实现

00:26:57.584 --> 00:26:58.752 
但现在我还不想这么做

00:26:58.819 --> 00:27:01.121 
我认为没必要让它来执行
这个特定的项目

00:27:02.489 --> 00:27:04.358 
我们来看下一个文件

00:27:05.659 --> 00:27:07.928 
在下一个文件SourceEditorCommand中

00:27:08.195 --> 00:27:10.864 
有我的第一个命令类

00:27:12.432 --> 00:27:15.769 
正如我向你们展示的那样
它符合XCSourceEditor命令

00:27:16.370 --> 00:27:20.274 
并且仅在vocation类函数
控制下单独执行

00:27:22.676 --> 00:27:26.313 
现在让我们看一看Xcode创建的
info.plist文件

00:27:27.981 --> 00:27:31.018 
你可以看到在我的扩展属性中

00:27:31.752 --> 00:27:36.190 
Xcode添加一组
XCSourceEditorCommandDefinitions

00:27:36.390 --> 00:27:38.258 
这是一个字典数组

00:27:40.027 --> 00:27:43.330 
该字典为命令指定了需要实例化的类

00:27:44.431 --> 00:27:46.667 
要使用的标识符

00:27:48.202 --> 00:27:51.505 
以及命令应具备的菜单项名称

00:27:53.073 --> 00:27:57.911 
我把它的名称改为
ConverttoSwiftLiterals

00:27:58.946 --> 00:27:59.947 
然后接受

00:28:01.415 --> 00:28:05.919 
将镜头缩小 返回到命令界面

00:28:09.656 --> 00:28:13.694 
现在我要作个小弊因为代码已经写好了

00:28:15.095 --> 00:28:18.432 
我使用代码片段把
已经写好的代码嵌进去了

00:28:21.034 --> 00:28:26.507 
我把这称为Chris Demon
大家可以看到实际上代码并不是很多

00:28:28.809 --> 00:28:32.980 
所以我只需循环文件中所有的行

00:28:34.815 --> 00:28:40.587 
如果该行中存在一个
UIColor或UIImage调用

00:28:41.288 --> 00:28:45.659 
我仅使用对应的
Swift字面语法去替代它

00:28:47.127 --> 00:28:50.464 
然后如果行已经改变了

00:28:51.298 --> 00:28:54.635 
那我就得替换行数组中的行了

00:28:54.968 --> 00:28:57.437 
我并不是替换数组中的每一个行

00:28:58.005 --> 00:29:00.374 
我当然不是修改整个缓存区

00:29:00.641 --> 00:29:04.478 
我只修改实际需要修改的行

00:29:05.412 --> 00:29:08.382 
而且我还对修改的行保持追踪

00:29:09.216 --> 00:29:13.120 
因此之后我还可以构造

00:29:13.187 --> 00:29:16.223 
一组选择来表示那些行

00:29:18.392 --> 00:29:19.626 
我设置了那些选项

00:29:20.394 --> 00:29:22.696 
之后仅需调用我的完成处理程序

00:29:22.763 --> 00:29:25.165 
让Xcode知道我的命令已完成

00:29:25.766 --> 00:29:29.102 
我在建议的程序列表中
见到了Xcode

00:29:31.805 --> 00:29:34.575 
如果我点击运行大家认为会发生什么

00:29:35.142 --> 00:29:37.511 
当然除了建立我的扩展程序之外

00:29:39.746 --> 00:29:40.581 
你可以看到

00:29:40.647 --> 00:29:46.220 
我们为大家开发了另一个
Xcode实例来测试大家的扩展程序

00:29:48.422 --> 00:29:52.693 
我们实际还提供一点视觉差别

00:29:52.759 --> 00:29:54.628 
我们在dock里将图标变得更黑

00:29:55.195 --> 00:29:58.532 
并且对“欢迎来到Xcode”
窗口内的图标也加黑

00:29:59.066 --> 00:30:00.868 
清晰明了

00:30:01.468 --> 00:30:05.939 
你会清楚地知道这个Xcode
正在对一个扩展进行测试

00:30:08.709 --> 00:30:10.978 
我现打开Mike的Jogger项目

00:30:11.078 --> 00:30:14.615 
因为我注意到有些
UIImage和UIColor

00:30:14.681 --> 00:30:15.949 
还没有转换

00:30:17.684 --> 00:30:20.387 
大家可以另外看到一种情况

00:30:20.988 --> 00:30:23.323 
我们在活动视图的顶部对UI进行修改

00:30:23.390 --> 00:30:24.925 
以此来特别说明

00:30:25.192 --> 00:30:28.996 
Xcode正在测试一个扩展

00:30:31.398 --> 00:30:35.669 
Mike给我留下了一些真正想要的
UIImage和UIColor实例

00:30:35.736 --> 00:30:38.005 
我认为作为字符会更好看

00:30:38.805 --> 00:30:41.275 
所以我查看一下编辑菜单

00:30:41.975 --> 00:30:44.244 
看到了Chris Convert
to Literals扩展

00:30:44.878 --> 00:30:47.381 
还看到了Convert to
Swift Literals命令

00:30:48.882 --> 00:30:50.751 
现在如果我返回我最初的Xcode

00:30:51.652 --> 00:30:54.521 
然后设置一个断点在这下面

00:30:57.090 --> 00:30:59.226 
如果我现在实际运行我的命令...

00:31:02.696 --> 00:31:04.164 
你会发现什么也没有

00:31:04.398 --> 00:31:06.967 
因为在断点处就停止了命令

00:31:07.034 --> 00:31:08.602 
在第一个Xcode调试程序中

00:31:09.336 --> 00:31:12.539 
所以你其实可以把Xcode调试器

00:31:12.773 --> 00:31:16.343 
和需承载的LLDB的所有资源
都用于调试你的扩展程序

00:31:18.212 --> 00:31:20.180 
我继续演示

00:31:22.916 --> 00:31:27.254 
我们把这里的断点删除

00:31:28.889 --> 00:31:31.124 
如果返回就可以看到

00:31:31.358 --> 00:31:35.329 
Xcode对所有我改变的行
都进行了强调正如我告诉它的一样

00:31:35.863 --> 00:31:38.966 
以上便是所有关于使用新
Swift字符格式进行转换的内容

00:31:47.608 --> 00:31:51.178 
现在来谈谈我实际希望
在非常常规的环境下进行的操作

00:31:52.279 --> 00:31:55.816 
这很容易　我可以很快完成

00:31:56.216 --> 00:31:59.786 
只需对我的新命令添加一个密钥绑定

00:32:00.621 --> 00:32:03.090 
在Key Bindings界面下的
Xcode偏好选择中进行操作

00:32:03.423 --> 00:32:07.194 
搜索我的命令名称
我记得是以Chris开头

00:32:07.995 --> 00:32:10.998 
这就是Xcode的
Key Binding

00:32:11.131 --> 00:32:15.302 
我把它命名为command
option control/

00:32:15.369 --> 00:32:16.770 
便于记住是吧？

00:32:21.642 --> 00:32:23.010 
现在我们来看幻灯片

00:32:24.978 --> 00:32:26.380 
来说说...

00:32:26.780 --> 00:32:28.715 
一些我很关心的事

00:32:28.782 --> 00:32:32.653 
当使用Xcode扩展时
你会感受其速度之快

00:32:34.054 --> 00:32:37.291 
那是因为文本编辑是用户同步进行的

00:32:37.925 --> 00:32:41.061 
用户们只想把他们的手放在键盘上

00:32:41.161 --> 00:32:43.263 
不停地操作

00:32:43.363 --> 00:32:46.066 
即使调用你的扩展

00:32:47.668 --> 00:32:50.671 
你的扩展也不应该阻止

00:32:50.771 --> 00:32:53.941 
用户操作的连续性

00:32:56.510 --> 00:32:58.979 
现在为了防止

00:32:59.046 --> 00:33:03.650 
在你的扩展和用户之间
发生竞态条件 Xcode会锁定那些

00:33:03.851 --> 00:33:05.853 
用户工作时产生的文件变化

00:33:05.986 --> 00:33:07.387 
在用户调用扩展时

00:33:10.958 --> 00:33:13.560 
幸运的是大家不必担心

00:33:13.627 --> 00:33:17.431 
如何协调大家所造成的
改变以及来自用户的改变

00:33:20.067 --> 00:33:21.935 
从另一方面讲这意味着...

00:33:22.803 --> 00:33:27.574 
如果你的扩展时间过长
我们认为几秒钟就算过长

00:33:27.841 --> 00:33:30.110 
从用户锁定到开始编辑文件这段时间

00:33:30.611 --> 00:33:31.478 
那么...

00:33:32.479 --> 00:33:33.313 
我们该怎么办？

00:33:34.481 --> 00:33:37.651 
我们允许用户取消该命令

00:33:38.719 --> 00:33:42.489 
我们会提供一个取消指令的按键标示

00:33:43.657 --> 00:33:45.759 
我想系统正在尝试告诉我

00:33:45.826 --> 00:33:47.761 
这张幻灯片在这的时间太长了

00:33:49.296 --> 00:33:51.732 
我们来关掉它然后继续

00:33:54.101 --> 00:33:57.137 
Xcode能为
我们的用户保证快速操作

00:33:57.638 --> 00:34:00.807 
通过早早地启动扩展并尽可能长时间地

00:34:01.108 --> 00:34:02.843 
使其保持激活状态

00:34:03.010 --> 00:34:05.479 
所以一旦调用它们就能发送命令

00:34:07.514 --> 00:34:11.485 
正如我们前面讨论过的
通过使用行数组

00:34:11.685 --> 00:34:16.889 
来确保各位的扩展数据传输
在性能方面得到优化

00:34:18.425 --> 00:34:21.195 
当用户需要取消一个命令

00:34:21.661 --> 00:34:24.931 
可以点击Xcode界面的取消符号

00:34:25.165 --> 00:34:27.067 
当用户点击取消

00:34:27.234 --> 00:34:28.435 
他们可以继续操作

00:34:29.503 --> 00:34:32.940 
现在...你的扩展任会接收

00:34:33.206 --> 00:34:35.708 
取消命令并仍然需要对它做出反应

00:34:36.409 --> 00:34:37.945 
但是用户不关心这点

00:34:39.813 --> 00:34:41.114 
当然有几个方法

00:34:41.181 --> 00:34:43.917 
你的扩展也可以对
Xcode的运行有所帮助

00:34:45.819 --> 00:34:48.922 
你的扩展可以尽可能快地启动

00:34:48.989 --> 00:34:51.692 
你的扩展得为用户

00:34:52.926 --> 00:34:54.594 
执行你的命令做好准备

00:34:54.661 --> 00:34:58.632 
你可以在我们所有的
异步编程模式下使用GCD

00:34:58.699 --> 00:35:03.170 
以确保你最大可能利用用户的系统

00:35:03.237 --> 00:35:05.973 
并尽可能快地返回Xcode

00:35:07.641 --> 00:35:08.942 
当然...

00:35:09.776 --> 00:35:13.647 
如果没必要
你可以避免更换所有的文本缓存

00:35:15.516 --> 00:35:19.486 
最后就像我说的
你需要快速处理取消指令

00:35:20.787 --> 00:35:24.725 
因为在你的指令完成取消之前

00:35:24.791 --> 00:35:27.327 
它对用户而言都是不可用的

00:35:29.997 --> 00:35:33.934 
今天Mike向大家展示了许多关于

00:35:34.001 --> 00:35:35.469 
Xcode源代码编辑器的
出色的新特性

00:35:35.536 --> 00:35:38.338 
比如我们能够添加文档注释

00:35:38.605 --> 00:35:42.876 
以及在Code Completion中
支持Swift color和Swift image字符

00:35:43.277 --> 00:35:46.313 
还展示了一些添加的最新功能

00:35:46.380 --> 00:35:50.517 
这些功能已经添加进了
Xcode7.3 比如模糊代码完成

00:35:51.151 --> 00:35:54.855 
我向大家展示了Xcode源代码
编辑器扩展是如何工作的

00:35:55.289 --> 00:35:57.257 
以及如何创建它们

00:35:57.824 --> 00:36:00.794 
我已迫不及待地想看到
各位通过我们的新API作出的成就

00:36:01.995 --> 00:36:04.164 
大家可以获得更多可用的信息

00:36:04.231 --> 00:36:08.035 
在我们 WWDC 16 网站页面上

00:36:09.603 --> 00:36:13.440 
还可以收看一些相关课程的视频

00:36:13.941 --> 00:36:19.112 
特别说明Optimizing App
Startup Time不适用于应用

00:36:19.179 --> 00:36:21.081 
它仅适用于应用扩展

00:36:21.148 --> 00:36:23.650 
因为它搭载了大量相同的技术

00:36:24.518 --> 00:36:26.553 
我们对Xcode的介绍也非常棒

00:36:26.620 --> 00:36:28.956 
适合于想要了解
Xcode开发环境动态的人

00:36:29.022 --> 00:36:32.626 
当你实现扩展时
用户们会为此充满期待

00:36:33.160 --> 00:36:36.430 
最后我们有些前些年推出的节目

00:36:36.496 --> 00:36:39.366 
讨论应用扩展意味着什么

00:36:39.466 --> 00:36:41.802 
以及实现它们的最佳方法

00:36:43.136 --> 00:36:46.807 
我们今晚也会参加这个盛会因此...

00:36:47.741 --> 00:36:49.543 
感谢光临 WWDC 大会

00:36:49.610 --> 00:36:52.746 
若有任何疑问 可以届时向我们提问