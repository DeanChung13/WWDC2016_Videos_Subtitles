00:00:19.920 --> 00:00:23.557
Cocoa的新特性

00:00:26.326 --> 00:00:27.261
上午好

00:00:27.895 --> 00:00:29.096
我叫Ali Ozer

00:00:29.329 --> 00:00:30.731
我和我的同事们

00:00:31.431 --> 00:00:32.366
谢谢

00:00:35.269 --> 00:00:37.905
我和我的同事Raleigh Ledet
还有Taylor Kelly

00:00:37.971 --> 00:00:40.073
来自Cocoa框架团队
将给大家讲讲

00:00:40.140 --> 00:00:41.808
今年Cocoa的新特性

00:00:42.743 --> 00:00:44.011
我们的议程非常简单

00:00:44.077 --> 00:00:46.880
首先 继AppKit和
Foundation新特性

00:00:46.947 --> 00:00:48.182
之后的API更新

00:00:49.683 --> 00:00:53.954
关于API更新方面
我想跟大家讲讲

00:00:54.021 --> 00:00:55.556
我们主要有两类API更新

00:00:55.622 --> 00:00:58.959
第一 由于新Swift API指南
导致的API更新

00:00:59.359 --> 00:01:02.062
第二 我们做的一些常用API改良

00:01:02.362 --> 00:01:03.430
让我们开始吧

00:01:04.897 --> 00:01:07.634
无论你昨天是否听过

00:01:07.701 --> 00:01:11.338
今天上午 我们有关于
Swift新API设计指南

00:01:11.538 --> 00:01:13.774
并且这些指南包含Cocoa约定和实践

00:01:13.841 --> 00:01:17.377
我不过是要
提醒你这些东西是什么

00:01:18.078 --> 00:01:20.414
使用清晰和一致性命名

00:01:20.848 --> 00:01:24.318
追求流畅的使用
大家都知道 调用的地方读起来

00:01:24.384 --> 00:01:26.854
应该像英文短句
命名增强

00:01:26.920 --> 00:01:30.457
和不可变方法保持对应一致
sort与sorted

00:01:30.524 --> 00:01:33.694
append与appending
还有避免缩写

00:01:33.760 --> 00:01:36.563
这些都是我们多年来使用的主要指南

00:01:36.630 --> 00:01:39.066
我们把它写成文档

00:01:39.132 --> 00:01:41.235
在以前WWDC大会上
我们也讲过

00:01:41.301 --> 00:01:42.903
正如这次演讲你看到的一样

00:01:43.504 --> 00:01:45.772
现在我们把这些指南做了更新

00:01:45.839 --> 00:01:49.109
使用了Swift的特性 比如强类型

00:01:49.176 --> 00:01:51.645
类型推断 还有重载

00:01:51.712 --> 00:01:54.681
并且确保我们的API
在Swift中能表现出来

00:01:54.748 --> 00:01:57.084
我来讲下API中的一些关键不同点

00:01:57.150 --> 00:01:58.819
由于这些改变的结果

00:01:59.386 --> 00:02:02.523
一方面 我们消除了重复和
不必要的单词

00:02:02.589 --> 00:02:05.492
显然使我们的API更加敏捷

00:02:05.559 --> 00:02:06.693
你昨天可能听了

00:02:06.760 --> 00:02:08.095
昨天有个例子

00:02:08.161 --> 00:02:11.098
如Chris Lattner
关于“详情咨文”的部分

00:02:11.164 --> 00:02:14.735
这里有另外一个例子
contacts.arrayByAddingObject

00:02:14.801 --> 00:02:18.906
比如这样的一个方法调用
“数组”和

00:02:18.972 --> 00:02:21.341
“对象”并不能
真实反应这个调用

00:02:21.675 --> 00:02:25.245
所以这个名字现在改成了
contacts.adding(person)

00:02:26.713 --> 00:02:29.349
在NSColor这个类上
还有另外一个例子

00:02:29.950 --> 00:02:33.453
NSColor.blueColor
我们现在NSColor类上

00:02:33.520 --> 00:02:34.922
Blue已经是一个颜色了

00:02:34.988 --> 00:02:37.424
color这个单词其实在
这调用中不需添加

00:02:37.791 --> 00:02:38.892
所以在新的指南中

00:02:38.959 --> 00:02:40.961
它将变成NSColor.blue

00:02:41.795 --> 00:02:44.431
不过需要注意的是我们仍然追求清晰

00:02:44.498 --> 00:02:47.901
这是NSColor另一方法
NSColor.textColor

00:02:48.902 --> 00:02:51.605
文本本质上不是一个颜色
其实

00:02:51.672 --> 00:02:54.975
谈论文本的颜色可能会产生混乱

00:02:55.409 --> 00:02:58.979
文本是代表颜色的RGB值
还是其它的？

00:02:59.413 --> 00:03:01.715
所以在此案例中 我们没改变这个方法

00:03:01.782 --> 00:03:04.051
还是作为
NSColor.textColor

00:03:04.151 --> 00:03:05.452
跟它之前一样

00:03:08.488 --> 00:03:12.593
另外一些关键变化是类型的利用

00:03:13.660 --> 00:03:17.497
这里有个例子
document.readFromURL ofType

00:03:18.498 --> 00:03:22.402
现在这个API将变成
document.readFrom ofType

00:03:22.769 --> 00:03:26.540
你会注意到我们移除了
这个单词... URL

00:03:26.640 --> 00:03:27.908
从我们的方法签名中

00:03:27.975 --> 00:03:31.411
那是因为第一个参数的类型就是URL

00:03:31.478 --> 00:03:34.214
根据类型推断
Swift知道该如何去处理它

00:03:34.281 --> 00:03:35.449
通过移除这个单词

00:03:35.516 --> 00:03:38.352
其实在NSDocument上
现有三个阅读方法

00:03:38.819 --> 00:03:42.589
他们都准确的命名了同样一件事
从ofType读取

00:03:42.656 --> 00:03:45.459
并且它是作为第一个参数
第一个参数的类型

00:03:45.526 --> 00:03:47.828
URL 数据
或者FileWrapper

00:03:47.895 --> 00:03:50.497
把它们区分开来

00:03:51.698 --> 00:03:54.401
现在这需要注意的一件事情就是利用

00:03:54.468 --> 00:03:55.602
第一个参数

00:03:56.970 --> 00:03:59.907
这里从此以后就被拉到了括号内

00:04:00.440 --> 00:04:01.909
我们这样做是基于大量的案例

00:04:01.975 --> 00:04:05.212
例如 当第一个参数表现成
介词短语的一部分时

00:04:05.279 --> 00:04:08.515
我们会把这个短语拉到括号内
正如你这看到的一样

00:04:08.582 --> 00:04:12.352
你可以从我们的API中
看到大量这样的例子

00:04:12.653 --> 00:04:15.622
可能大家也注意到
第二个参数ofType

00:04:15.989 --> 00:04:18.725
我们并没有把类型这个单词
从API中移除

00:04:18.791 --> 00:04:22.362
因为这个参数是一个字符串
而且字符串是弱类型

00:04:22.429 --> 00:04:24.731
我们其实要一个单词来描述它们的角色

00:04:24.798 --> 00:04:27.901
而这里的角色就是我们打开的文件类型

00:04:27.968 --> 00:04:30.838
所以我们在API中
保留了类型这个单词

00:04:35.042 --> 00:04:38.245
现在很多框架和
标准库API都被改变了

00:04:38.312 --> 00:04:40.247
基于这些新的指南

00:04:40.314 --> 00:04:43.584
并且把Objective-C
API映射到

00:04:43.650 --> 00:04:46.887
Swift的输入者
也使用了这些新指南

00:04:46.954 --> 00:04:49.623
不过你可能会注意到有些API
还需要进一步调教

00:04:49.890 --> 00:04:52.693
我们已在些API中做了
如textColor API

00:04:52.759 --> 00:04:54.995
前面提到过的
它是一个例外

00:04:55.062 --> 00:04:57.998
若你在Swift中
暴露Objective-C API

00:04:58.065 --> 00:05:00.534
你可能需要使用一些

00:05:00.601 --> 00:05:04.371
像NS Swift Name
它可以让你覆盖默认的

00:05:04.438 --> 00:05:05.472
输入者做的事情

00:05:06.039 --> 00:05:08.208
大家知道移植器转换你的——

00:05:08.275 --> 00:05:10.544
移植器可将你现有Swift 2代码

00:05:10.611 --> 00:05:14.515
转换成Swift 3并且
它还会帮你使用这些新命名

00:05:14.581 --> 00:05:16.116
在你现有的代码中 当然

00:05:16.316 --> 00:05:18.719
Swift API
设计指南讨论

00:05:18.785 --> 00:05:21.088
在此之前
你可以

00:05:21.154 --> 00:05:22.589
从视频中获取一些细节

00:05:22.656 --> 00:05:24.658
关于这些指南和它们的影响

00:05:25.759 --> 00:05:29.196
现在我们已经有很多常用的API改良

00:05:29.263 --> 00:05:32.399
有些我们已经完成有一段时间了
有些我们还将继续做

00:05:32.466 --> 00:05:34.101
我们来快速过一下

00:05:34.168 --> 00:05:35.435
可空性

00:05:35.502 --> 00:05:38.805
去年我们已经在这方面做了很多

00:05:38.872 --> 00:05:41.909
它通常用来声明是否有参数返回值

00:05:41.975 --> 00:05:44.845
属性可以为空
或者是否可选

00:05:44.912 --> 00:05:47.347
今年我们一直在持续完善它

00:05:47.414 --> 00:05:51.018
例如 该方法在10.11版本中标明

00:05:51.084 --> 00:05:52.719
返回一个可选值

00:05:52.786 --> 00:05:56.557
NSMenu中的addItem方法
但在10.12版本中 它并没有标明

00:05:56.623 --> 00:05:59.526
返回一个非可选值
因为我们决定

00:05:59.593 --> 00:06:01.762
它永远无法真正返回空值
而且

00:06:01.828 --> 00:06:03.630
最好由你的代码来反应出来更为适当

00:06:03.697 --> 00:06:04.965
当然 也更简单一点

00:06:06.166 --> 00:06:09.269
我们一直在改进属性
把getter和setter对

00:06:09.336 --> 00:06:11.672
转换成正规属性

00:06:11.738 --> 00:06:14.441
今年我们同样在实际中
使用了Swift的能力

00:06:14.508 --> 00:06:16.176
来声明类中的属性

00:06:16.543 --> 00:06:19.179
例如 这是NSWindow中的
一个新属性

00:06:19.246 --> 00:06:20.814
你会在后面的演讲中听到这个

00:06:20.881 --> 00:06:22.616
allowsAutomaticWindowTabbing

00:06:23.150 --> 00:06:26.320
这是在Swift中
一个真实类中的属性

00:06:27.120 --> 00:06:28.655
你还会注意到我们同样有能力

00:06:28.722 --> 00:06:30.157
在Objective-C中做到这样

00:06:30.224 --> 00:06:32.259
在Objective-C中
你也可定义类属性

00:06:32.326 --> 00:06:34.661
使用语法
@property class

00:06:34.728 --> 00:06:36.964
同样特性引入到了
Objective-C中

00:06:37.030 --> 00:06:38.632
这确实很酷

00:06:38.699 --> 00:06:42.970
这有个Core Data的例子
NSPersistentStoreCoordinator

00:06:43.036 --> 00:06:46.039
在10.11版本中 它有这个方法
registeredStoreTypes

00:06:46.106 --> 00:06:47.774
现在它被定义成了类的属性

00:06:47.841 --> 00:06:48.942
它是一个只读属性

00:06:49.009 --> 00:06:51.245
所以它只有get方法
正如你这里看到的一样

00:06:51.478 --> 00:06:55.983
同样在Objective-C
它也变成了类的属性 如你看到的一样

00:06:58.085 --> 00:06:59.820
泛型
我们把它应用到了

00:06:59.887 --> 00:07:02.155
集合类中
不过它们真的

00:07:02.222 --> 00:07:03.357
不仅用于集合

00:07:03.423 --> 00:07:05.425
它们还用于其它任何地方

00:07:05.492 --> 00:07:07.261
我敢肯定 你已经意识到了

00:07:07.728 --> 00:07:10.564
这里有一个Core Data
NSFetchRequest的例子

00:07:11.632 --> 00:07:14.301
这里是10.11版本中定义的方式
非常简单

00:07:14.368 --> 00:07:16.436
在10.12中 我们前进了一步

00:07:16.503 --> 00:07:19.239
添加了一个
ResultType类型参数

00:07:19.306 --> 00:07:23.076
我们同样在其它一些API中
添加了一些东西

00:07:23.143 --> 00:07:24.444
如这execute方法

00:07:24.511 --> 00:07:27.814
返回一个这种结果类型的数组

00:07:27.881 --> 00:07:31.752
因此 这个用例
现在就变成这个样了

00:07:31.818 --> 00:07:34.788
你从一个管理对象获得请求

00:07:34.855 --> 00:07:36.023
比如员工

00:07:36.290 --> 00:07:38.058
然后往前继续执行它

00:07:38.125 --> 00:07:40.060
现在返回值被自动推断为

00:07:40.127 --> 00:07:42.162
一个员工数组

00:07:42.596 --> 00:07:44.731
现在这个例子会是这样
不过我们希望

00:07:44.798 --> 00:07:49.269
在将来的版本中
我们可以像这样表达得更干净

00:07:49.336 --> 00:07:50.370
这确实很酷

00:07:50.437 --> 00:07:53.874
所以从这两行
编译器可以推断

00:07:53.941 --> 00:07:56.176
返回类型是一个被管理了的对象数组

00:07:57.845 --> 00:08:00.314
我们一直在改进枚举命名

00:08:00.380 --> 00:08:04.184
来看一个我们在这方面已实施的例子
NSColorPanelMode

00:08:04.251 --> 00:08:07.287
变化是——这是一个Swift用例

00:08:07.354 --> 00:08:08.755
你看它并非很吸引人

00:08:08.822 --> 00:08:12.860
是因为.NSCrayonModeColorPanel
非常冗长

00:08:13.560 --> 00:08:17.030
变化就是我们把通用后缀拉到前面

00:08:17.097 --> 00:08:19.199
变成前缀
使得Swift里的名字

00:08:19.266 --> 00:08:20.634
更清晰一点

00:08:20.701 --> 00:08:22.803
你知道 出现这点的地方

00:08:22.870 --> 00:08:24.905
用例就是.crayon

00:08:24.972 --> 00:08:27.241
这是它之前的样子

00:08:27.441 --> 00:08:29.576
这是它现在的样子 相当清晰

00:08:31.378 --> 00:08:33.113
在枚举这一块

00:08:33.179 --> 00:08:35.716
我们同样对字符串枚举
做了改进

00:08:35.782 --> 00:08:38.150
Swift支持字符串值的枚举

00:08:38.217 --> 00:08:41.154
许多Cocoa API
都会暴露一组字符串

00:08:41.221 --> 00:08:45.058
无论打开或者关闭的API
在我们的API中

00:08:45.125 --> 00:08:47.794
我们来看一个字符串转换的例子

00:08:48.829 --> 00:08:51.632
在Swift 2中我们有一堆
全局常量

00:08:51.999 --> 00:08:54.535
NSStringTransformLatinToGreek
等等

00:08:54.601 --> 00:08:56.904
有一个API
stringByApplyingTransform

00:08:56.970 --> 00:08:59.573
把这些字符串作为
它的第一个参数

00:08:59.773 --> 00:09:01.942
在Swift 3中
我们添加了一种新类型

00:09:02.009 --> 00:09:06.280
叫StringTransform
还有一个扩展我们给它定义多种值

00:09:06.346 --> 00:09:07.981
比如LatinToGreek

00:09:08.048 --> 00:09:10.551
有API叫
applyingTransform

00:09:10.617 --> 00:09:15.455
它第一个参数现在是官方的
StringTransform

00:09:15.522 --> 00:09:19.293
所以这个字符串参数现在是
StringTransform

00:09:19.359 --> 00:09:20.561
类型更加安全

00:09:21.094 --> 00:09:24.932
现在 注意这里有一个
开放式枚举

00:09:24.998 --> 00:09:26.967
这里面你可以定义
你自己的值

00:09:28.302 --> 00:09:29.436
我演示下如何做到这点

00:09:32.005 --> 00:09:33.040
你可以继续添加一个扩展

00:09:33.106 --> 00:09:36.043
到StringTransform
然后定义你自己的类型

00:09:36.109 --> 00:09:40.047
现在这里的值就是
ICU库接受的值

00:09:40.113 --> 00:09:41.114
用于做转换

00:09:41.181 --> 00:09:44.718
你可以使用任何有效的
ICU提供的ID

00:09:44.785 --> 00:09:47.020
它转换成
一个ICU拥有的需要出版的东西

00:09:47.087 --> 00:09:49.890
这些我们API中并不暴露

00:09:50.057 --> 00:09:52.960
所以 你可以定义你自己的
出版转换

00:09:53.026 --> 00:09:55.929
然后把它传给API
如果它是一个内置的

00:09:58.332 --> 00:10:00.534
字符串枚举
同样在Objective-C可以使用

00:10:00.601 --> 00:10:04.204
通过使用这两个宏
给开放或者封闭式的集合

00:10:04.271 --> 00:10:07.441
这是添加字符串转换声明的方式

00:10:07.508 --> 00:10:08.809
在10.11中 那是我们已有的方式

00:10:08.876 --> 00:10:11.078
在10.12中 有一个新
字符串转换类型

00:10:11.144 --> 00:10:14.648
被定义成NS Extensible
String Enum

00:10:16.984 --> 00:10:19.620
我们同样使用了Swift能力来改进

00:10:19.686 --> 00:10:24.224
在一个类型中嵌套声明另一种类型

00:10:24.625 --> 00:10:26.627
看一个NSData的例子

00:10:26.693 --> 00:10:30.097
我们有一个可选的集合
NSDataWritingOptions

00:10:30.163 --> 00:10:34.368
NSData类有一个API
writeToURL使用了这个值

00:10:34.768 --> 00:10:38.138
在Swift 3中
它变成NSData类

00:10:38.205 --> 00:10:40.774
嵌套了WritingOptions
如你在此所见

00:10:42.176 --> 00:10:44.978
使用这个API实际上是指向

00:10:45.045 --> 00:10:48.315
WritingOptions显然是
更加清晰更好作用域

00:10:48.749 --> 00:10:52.419
除了这些嵌套的改变
你可能注意到一些其它的东西

00:10:53.720 --> 00:10:55.923
那就是类型的变化

00:10:55.989 --> 00:11:00.260
你可能注意到
我们现在提供了一个空集合默认值

00:11:00.327 --> 00:11:03.297
大多数我们需要传入可选值时

00:11:03.363 --> 00:11:06.366
意味着我们不在需要传入可选参数了

00:11:07.034 --> 00:11:09.937
你可能还注意到
这里NSURL变成了URL

00:11:10.003 --> 00:11:11.104
你可能已听过这个了

00:11:11.171 --> 00:11:13.440
不过我们后面还会有
关于它的更多谈论

00:11:15.108 --> 00:11:18.579
现在 我离开舞台前的
最后一个主题是...

00:11:19.713 --> 00:11:20.747
noescape

00:11:20.814 --> 00:11:23.717
好的 noescape声明

00:11:23.784 --> 00:11:27.588
一个闭包的执行
在函数调用后将不会退出

00:11:27.888 --> 00:11:28.856
我的意思是什么？

00:11:28.922 --> 00:11:32.059
这里有一个NSCollection view的方法
performBatchUpdates

00:11:32.125 --> 00:11:33.894
它有两个闭包参数

00:11:35.195 --> 00:11:37.364
你可能注意到了
第一个参数标记为noescape

00:11:37.431 --> 00:11:39.733
意思是这个闭包的执行

00:11:39.800 --> 00:11:42.636
将完成执行

00:11:42.703 --> 00:11:44.404
在API performBatchUpdates
方法返回之前

00:11:44.471 --> 00:11:46.773
第二个参数没有标记为
noescape

00:11:46.840 --> 00:11:51.044
意思是这个闭包的执行将可能发生在

00:11:51.111 --> 00:11:52.713
函数返回之后

00:11:52.779 --> 00:11:53.947
所以 这对你来说是一个好的暗示

00:11:54.014 --> 00:11:55.682
同样对编译器也是一个好的暗示

00:11:55.916 --> 00:11:58.151
这个技巧同样适用于
Objective-C

00:11:58.218 --> 00:12:00.687
我们可以使用NS NOESCAPE
来装饰闭包

00:12:00.754 --> 00:12:01.855
以达到同样的效果

00:12:02.523 --> 00:12:05.692
这些就是我们常用API变化的概览

00:12:05.759 --> 00:12:07.561
现在大家拥有的版本中

00:12:07.628 --> 00:12:09.229
我们已完成了所有想要做的事情

00:12:09.296 --> 00:12:11.532
将会有一些字符串枚举变化

00:12:11.598 --> 00:12:14.234
类属性变化将会在其它版本中出现

00:12:14.301 --> 00:12:16.336
我们将会应用到更多的API中

00:12:19.806 --> 00:12:21.475
接着我们来谈谈关于AppKit

00:12:21.542 --> 00:12:25.045
我将给大家邀请Raleigh
Ledet上台给大家讲讲

00:12:25.112 --> 00:12:25.946
谢谢

00:12:30.284 --> 00:12:31.151
谢谢 Ali

00:12:31.385 --> 00:12:32.386
大家 上午好

00:12:33.287 --> 00:12:36.423
大家看到 在过去的一年里
我们在AppKit上下了很多功夫

00:12:36.723 --> 00:12:40.327
现在我们深入一下
来讲讲窗口捕捉

00:12:41.428 --> 00:12:45.165
当你在macOS Sierra下
拖动一个窗口

00:12:45.232 --> 00:12:47.634
当你靠向一个边缘的时候
将产生边缘粘连

00:12:47.701 --> 00:12:49.736
还有与另外一个窗口的顶部对齐

00:12:49.803 --> 00:12:51.238
甚至是在缩放大小的时候

00:12:51.305 --> 00:12:55.108
所以现在将窗口对齐就简单多了

00:12:55.175 --> 00:12:58.045
或者以你想要的方式
来缩放大小

00:12:58.612 --> 00:13:01.515
我们付出很多努力
在这里提供摸索

00:13:01.582 --> 00:13:03.984
来确保我们只提供捕捉行为

00:13:04.151 --> 00:13:07.487
第一时间推测
你想对窗口做些什么

00:13:08.288 --> 00:13:10.858
在你的应用中获取捕捉行为的方式就是

00:13:10.924 --> 00:13:14.027
让系统来为你处理窗口的拖拽

00:13:14.795 --> 00:13:16.630
如果你自己跟踪鼠标

00:13:16.697 --> 00:13:18.599
然后手动控制窗口的位置

00:13:18.665 --> 00:13:21.702
你将会绕开窗口捕捉
我们会恰当地放置窗口

00:13:21.768 --> 00:13:24.738
在这里你要求我们放置它
正如我们之前的发布

00:13:26.740 --> 00:13:29.443
如在keynote上看到的
我们现有了窗口tabbing

00:13:30.410 --> 00:13:34.114
这是一个TextEdit的例子
有三个文档tab打开

00:13:34.848 --> 00:13:38.485
关于窗口tabbing
其实他们就是多个窗口

00:13:38.819 --> 00:13:42.823
所以此例中
有三个tab的TextEdit

00:13:42.890 --> 00:13:44.858
其实就是三个不同NS窗口支持

00:13:46.093 --> 00:13:49.596
所以我们做的只是
对这些当中的每一个窗口

00:13:49.663 --> 00:13:52.366
只将一个tab设置可见
就认为是可见

00:13:52.933 --> 00:13:55.269
若你检查NSWindow
的.visible属性

00:13:55.335 --> 00:13:56.537
它将返回真

00:13:57.404 --> 00:14:00.607
只不过仅有可见的tab
才正真被渲染到屏幕上

00:14:00.807 --> 00:14:03.911
我们将其它窗口
隐藏到窗口服务器级别

00:14:03.977 --> 00:14:06.380
所以它们没有被渲染
也不占用任何资源

00:14:08.815 --> 00:14:10.651
而且我们自动处理这些过程

00:14:11.385 --> 00:14:14.054
那如何给窗口添加
一个New Tab呢？

00:14:14.688 --> 00:14:17.424
创建一个新的窗口
然后将它排到前面

00:14:17.491 --> 00:14:20.060
然后我们将会继续
恰当地为你创建一个tab

00:14:20.127 --> 00:14:21.762
然后放置在窗口中

00:14:22.462 --> 00:14:25.732
如果你要移除一个tab
将你的窗口过滤掉

00:14:25.799 --> 00:14:27.568
然后我们将继续为你移除掉tab

00:14:27.634 --> 00:14:29.136
这些都是自动玩完成的

00:14:30.704 --> 00:14:32.973
现在如果用户缩放了窗口
我们将仅仅

00:14:33.040 --> 00:14:35.442
缩放与当前激活的tab
相关联的窗口

00:14:36.143 --> 00:14:37.945
我们不会花费时间

00:14:38.011 --> 00:14:41.248
去处理其它窗口
当用户并不想切换到它们的时候

00:14:41.515 --> 00:14:43.817
不过当用户要切换到
其它tab中的某一个时

00:14:43.884 --> 00:14:45.586
在那时AppKit将会继续

00:14:45.652 --> 00:14:48.722
适当的缩放窗口
重新渲染它

00:14:48.789 --> 00:14:51.959
然后将窗口服务器等级的
隐藏属性修改

00:14:52.025 --> 00:14:54.461
所以用户得到的是无缝的体验

00:14:54.528 --> 00:14:57.831
一个窗口拥有多个tab
尽管在这背后

00:14:57.898 --> 00:14:59.833
我们只是处理了三个窗口

00:15:02.236 --> 00:15:05.138
我想谈一些
大家需要做的东西

00:15:05.205 --> 00:15:07.374
当你准备给你的应用采取tab

00:15:07.441 --> 00:15:09.610
这依赖于你的应用

00:15:09.676 --> 00:15:10.577
是什么类型

00:15:11.078 --> 00:15:14.181
如果你有一个例如类似基于
NSDocument一样的应用

00:15:14.615 --> 00:15:17.284
或者non-NSDocument
的应用

00:15:17.651 --> 00:15:18.685
你需要做些什么

00:15:18.752 --> 00:15:21.221
如果你已经存在一个tab实现

00:15:21.288 --> 00:15:24.858
我讲围绕这一节来讲解
用一些大家可以使用的API

00:15:25.058 --> 00:15:27.227
在你的应用中去定制tab

00:15:28.929 --> 00:15:31.398
若是基于NSDocument的应用
你不需要做什么

00:15:31.465 --> 00:15:34.868
这基本上是自动的
其实此处TextEdit

00:15:34.935 --> 00:15:38.172
我们几乎完全是修改了0行代码
在TextEdit上

00:15:38.405 --> 00:15:41.375
它完全支持标签
而且在这个方框下运行的非常正确

00:15:42.476 --> 00:15:46.280
若是基于non-NSDocument的应用
它大部分是自动的

00:15:46.346 --> 00:15:48.348
不过你可能需要做的是
开启

00:15:48.415 --> 00:15:51.752
New Tab按钮
在你的应用里

00:15:52.186 --> 00:15:54.922
New Tab按钮
在这里是一个附加的按钮

00:15:54.988 --> 00:15:56.323
在所有tab的右边

00:15:57.524 --> 00:16:02.162
要开启这个按钮 你需要实现
newWindowForTab NSResponder

00:16:02.229 --> 00:16:04.932
在你的NSWindow子类中重写

00:16:04.998 --> 00:16:06.700
或者在响应链中
某个更高的地方

00:16:06.767 --> 00:16:09.036
例如
NSWindow代理

00:16:09.102 --> 00:16:12.239
或者NSWindow控制器
或者NSWindow文档

00:16:12.506 --> 00:16:14.942
如果你在其中任何一个地方
实现了重写

00:16:15.008 --> 00:16:16.977
AppKit将会看到它并且将继续

00:16:17.044 --> 00:16:19.479
自动为你开启New Tab按钮

00:16:22.082 --> 00:16:24.818
如果你有自己已存在的tab实现

00:16:24.885 --> 00:16:26.386
你可能需要禁用

00:16:26.453 --> 00:16:28.856
AppKit的自动窗口
tabbing行为

00:16:29.790 --> 00:16:30.891
这里是这个类的属性

00:16:30.958 --> 00:16:33.260
NSWindow的
allowsAutomaticWindowTabbing

00:16:34.161 --> 00:16:36.430
这是一个类属性
在你的应用启动之初

00:16:36.496 --> 00:16:37.998
叫做NSWindow

00:16:38.065 --> 00:16:42.169
allowsAutomaticWindowTabbing
等于假

00:16:42.236 --> 00:16:44.771
这里将关闭
AppKit的tabbing行为

00:16:44.838 --> 00:16:47.975
然后你将可以继续使用
你自己的tabbing实现了

00:16:48.375 --> 00:16:51.311
这里非常重要
你需要在应用启动

00:16:51.378 --> 00:16:53.113
且开始将窗口展示出来前调用它

00:16:56.083 --> 00:16:59.453
你只需要在你的应用中添加tab支持

00:16:59.520 --> 00:17:00.687
它大多数情况下是自动工作的

00:17:00.754 --> 00:17:03.557
不过这里有些API
你可以用来自定义一些事情

00:17:04.090 --> 00:17:07.094
首先 用户可以定义一些行为

00:17:07.160 --> 00:17:10.030
指定在系统中
他们想要的tabbing方式

00:17:10.097 --> 00:17:11.832
且他们可以在系统设置中来这么做

00:17:11.898 --> 00:17:13.834
你获取用户设置

00:17:13.901 --> 00:17:17.804
通过在NSWindow上
用户tabbing设置的类属性

00:17:18.137 --> 00:17:21.241
它们可以设置为手动
始终或者仅仅tabbing

00:17:21.308 --> 00:17:23.143
在它们全屏的时候

00:17:25.279 --> 00:17:27.047
在剩下的这些属性
和函数中

00:17:27.114 --> 00:17:29.616
我讲给大家讨论下
实例属性以及

00:17:29.683 --> 00:17:30.984
NSWindow的函数

00:17:31.685 --> 00:17:33.687
一旦你有了一个NSWindow实例

00:17:33.954 --> 00:17:35.322
你可将它设置为tabbing模式

00:17:35.722 --> 00:17:37.457
默认情况下
这个tabbing模式是自动的

00:17:37.524 --> 00:17:40.694
也就是说我们将使用
用户的tabbing设置

00:17:41.061 --> 00:17:43.297
不过你可以将它设置为首选或者禁用

00:17:43.363 --> 00:17:44.965
取决于你的窗口类型和你的需要

00:17:47.100 --> 00:17:49.670
当我们把窗口分组到一起
变成一组tab的时候

00:17:49.736 --> 00:17:52.706
我们只想把类似的窗口分组到一起
我们判断的方式就是

00:17:52.773 --> 00:17:54.808
通过查看tabbing的标识符

00:17:54.875 --> 00:17:56.743
若有相同tabbing标识符窗口

00:17:56.810 --> 00:17:58.612
我们就可以把它们
以tab的方式分组到一起

00:17:59.213 --> 00:18:01.582
默认情况下 AppKit会使用
一种启发式搜索并且

00:18:01.648 --> 00:18:03.984
从你的利益角度出发
生成一个tabbing标识符

00:18:04.051 --> 00:18:07.387
我们检查这些东西
例如窗口的子类名称

00:18:07.754 --> 00:18:10.190
窗口的属性 文档

00:18:10.257 --> 00:18:13.260
还有一些其它各种属性
然后尝试生成

00:18:13.327 --> 00:18:16.129
适当的tabbing标识符

00:18:16.496 --> 00:18:17.865
这种方式运作得非常好

00:18:17.931 --> 00:18:20.501
如果它在你的应用中
运作不够好的话

00:18:20.567 --> 00:18:23.504
或者你想要更多的控制它

00:18:23.570 --> 00:18:25.706
你可以手动设置tabbing标识符

00:18:25.772 --> 00:18:27.441
AppKit将会遵守它

00:18:28.509 --> 00:18:30.978
你无法获取到哪些窗口被分组到了一起

00:18:31.044 --> 00:18:34.281
通过tab中的某个窗口实例

00:18:34.348 --> 00:18:35.849
获取所有tab窗口

00:18:36.383 --> 00:18:38.418
注意它会返回一个可选数组

00:18:38.886 --> 00:18:42.623
它可返回空 而且如果tab栏不显示
它必然返回空值

00:18:42.689 --> 00:18:44.925
这里根本没有关联的tab

00:18:46.760 --> 00:18:50.998
你可以手动添加
其它的tab窗口将它们分组到一起

00:18:51.064 --> 00:18:53.734
因为这些都是窗口
这正好说明了API名称

00:18:53.800 --> 00:18:56.637
当你添加一个tab窗口
而不是添加一个tab自身

00:18:56.703 --> 00:18:58.705
添加了tab窗口之后
可以使用

00:18:58.772 --> 00:19:01.408
NSWindowOrderingMode进行排序
它将使tab跟其他

00:19:01.875 --> 00:19:03.277
tab关联起来进行排序

00:19:05.579 --> 00:19:08.649
AppKit会给菜单添加一些新项

00:19:09.082 --> 00:19:12.219
也就是说在窗口菜单下
添加了一些项目

00:19:12.286 --> 00:19:15.055
以此来帮助用户在tab之前进行导航

00:19:15.122 --> 00:19:17.191
比如选择下一个或者上一个tab

00:19:17.624 --> 00:19:19.960
这只是NSWindow上的IB动作

00:19:20.027 --> 00:19:23.297
而且你也可以基于你自己的
用户界面元素来编写它们

00:19:23.530 --> 00:19:26.600
例如 你可能想要一个按钮
来切换tab栏

00:19:26.834 --> 00:19:28.836
你可以将那个按钮连接到窗口

00:19:30.070 --> 00:19:32.072
toggleTabBar IBAction

00:19:32.439 --> 00:19:35.843
NSWindow将为你处理
切换tab栏

00:19:37.477 --> 00:19:39.580
上面就是关于窗口捕获和
tabbing的所有内容

00:19:40.147 --> 00:19:42.816
让我们继续来讲下关于
右-左的支持

00:19:42.883 --> 00:19:44.551
我们在AppKit上做了很多工作

00:19:44.618 --> 00:19:47.120
来加强现有的右-左的支持

00:19:47.721 --> 00:19:51.491
大家这里看到的截图是运行在
阿拉伯语中的TextEdit

00:19:51.892 --> 00:19:54.127
标题栏是翻转过来的

00:19:54.261 --> 00:19:56.230
滚动条被放到了另外一边

00:19:56.296 --> 00:19:58.298
甚至New Tab按钮也放到另一边

00:19:58.365 --> 00:19:59.900
并且所有的小属性

00:19:59.967 --> 00:20:02.069
还有各式各样的标题栏按钮都翻转了

00:20:02.135 --> 00:20:04.705
非常符合右-左用户的期望

00:20:06.006 --> 00:20:09.142
我想从三个不同的级别来讨论
从右-左的支持

00:20:09.409 --> 00:20:12.913
系统级别会发生什么
当用户设置了他们的本地化

00:20:12.980 --> 00:20:14.381
在系统设置面板中

00:20:15.148 --> 00:20:16.517
它会对应用产生什么影响

00:20:16.583 --> 00:20:18.051
你的应用会表现成什么样

00:20:18.118 --> 00:20:20.187
依赖于你对本地化的支持

00:20:20.787 --> 00:20:22.422
然后下降到内容层面

00:20:22.489 --> 00:20:23.891
就是在NSView级别

00:20:24.224 --> 00:20:26.560
如果需要的话
你可以进一步重写一些东西

00:20:26.627 --> 00:20:28.428
直接使用用户界面布局

00:20:28.829 --> 00:20:30.931
然后我将会围绕着一节

00:20:30.998 --> 00:20:33.667
通过一个非常不错的开发技巧来帮助你

00:20:33.967 --> 00:20:36.436
给你的应用提供右-左的支持

00:20:37.704 --> 00:20:39.840
首先 让我们从系统层面开始讲

00:20:41.141 --> 00:20:42.876
这里的关键点是一致性

00:20:43.110 --> 00:20:45.245
我们需要保持一致性的表现

00:20:45.312 --> 00:20:47.447
在用户设置为右-左的系统中

00:20:47.814 --> 00:20:50.951
所以不管你支持哪种本地化

00:20:51.018 --> 00:20:53.820
在你的应用中
我们想要让所有菜单栏

00:20:54.087 --> 00:20:57.658
在一个右-左的系统中
从Apple这个菜单项开始

00:20:57.724 --> 00:21:01.762
在这里放在其它的菜单项的右边

00:21:01.828 --> 00:21:05.132
这里同样适用窗口的标题栏

00:21:06.033 --> 00:21:08.302
所以交通指示灯将翻转到另一边

00:21:08.368 --> 00:21:09.803
所有不在内容区域的东西

00:21:09.870 --> 00:21:11.305
都将翻转到另一边

00:21:11.705 --> 00:21:14.041
不管你的应用中支持的是何种本地化

00:21:14.274 --> 00:21:16.476
给用户提供一致性的体验

00:21:17.311 --> 00:21:21.181
现在降级到应用层面
我们将不能自动这么做了

00:21:21.248 --> 00:21:22.916
因为我们不想打断任何

00:21:22.983 --> 00:21:24.318
你的应用中可能有的设定

00:21:24.785 --> 00:21:28.522
所以强烈的建议你添加
右-左的支持

00:21:28.589 --> 00:21:31.959
在你的应用中
添加犹太人和阿拉伯人本地化

00:21:32.993 --> 00:21:35.996
一旦在有了这些本地化

00:21:36.496 --> 00:21:37.731
在应用层面

00:21:37.798 --> 00:21:41.301
所有的滚动区域将自动无视
垂直滚动和标尺

00:21:41.368 --> 00:21:43.670
NSBrowser将自动翻转

00:21:44.104 --> 00:21:46.340
在这个层面 我们同样需要一致性

00:21:46.406 --> 00:21:51.211
所以不管何种用户界面布局方向的
任何内容区域

00:21:51.979 --> 00:21:55.816
我们都想要滚动条保持一致性
都在同一侧

00:21:57.184 --> 00:21:58.719
下降到内容层面

00:21:59.253 --> 00:22:01.688
默认情况下用户界面布局方向
将会匹配

00:22:01.755 --> 00:22:04.091
你的是应用如何设置的

00:22:05.392 --> 00:22:08.529
在大部分情况下
这正是你所期望的

00:22:08.595 --> 00:22:09.963
不过有一些例外

00:22:10.030 --> 00:22:12.499
也就是说 如果你有
一些类似媒体控件

00:22:12.566 --> 00:22:15.035
或者空间控件 或者时间控件

00:22:15.102 --> 00:22:19.606
它们始终是一样的布局
从左往右

00:22:19.673 --> 00:22:22.376
对于左-右用户和
右-左用户来说都是这样

00:22:23.043 --> 00:22:25.812
所以你可以修改用户界面布局方向

00:22:26.513 --> 00:22:28.982
并且下面这些AppKit中的
控件都支持那样做

00:22:29.383 --> 00:22:31.885
所以自动布局将不会在这个阶段中

00:22:31.952 --> 00:22:38.492
不过在即将到来第二阶段中
我们将开始使用父容器

00:22:38.959 --> 00:22:44.731
来决定哪边是头哪边是尾

00:22:45.999 --> 00:22:47.534
版本中已有的表格视图

00:22:47.601 --> 00:22:50.270
和outline view会适当的
调整它们的列

00:22:50.337 --> 00:22:54.641
NSPageController
可切换动画且这个列表还在继续

00:22:54.708 --> 00:22:57.811
我们在AppKit中
有很多对右-左的支持

00:22:57.878 --> 00:22:59.980
让AppKit做繁琐的工作

00:23:00.347 --> 00:23:04.551
给你的用户提供一个右-左更好的体验

00:23:06.954 --> 00:23:08.422
我答应过给大家一个开发技巧

00:23:08.488 --> 00:23:10.057
我已使用这个技巧一整年了

00:23:10.123 --> 00:23:11.859
我发现它难以置信的有用

00:23:12.226 --> 00:23:14.828
在Xcode中 你可以修改项目体质

00:23:14.895 --> 00:23:17.497
在Options选项中
修改你的应用的语言

00:23:17.564 --> 00:23:19.099
设置成右-左虚拟语言

00:23:19.566 --> 00:23:21.435
这可以让你的应用

00:23:21.502 --> 00:23:24.037
在开发语言中运行
对我来说它就是英语

00:23:24.404 --> 00:23:26.173
大家看到这里
TextEdit运行在英语当中

00:23:26.640 --> 00:23:31.078
但是它在所有控件中使用了
右-左翻转

00:23:31.278 --> 00:23:34.281
所以窗口标题栏被翻转了

00:23:34.515 --> 00:23:36.383
滚动区域的滚动条翻转了

00:23:36.450 --> 00:23:39.186
大家看到所有小的子项和

00:23:39.253 --> 00:23:40.487
标题栏所有按钮都翻转了

00:23:40.554 --> 00:23:44.825
所以这是一个非常简单的方式
让你获得右-左的支持

00:23:44.892 --> 00:23:47.995
并且确保所有的东西
在你的原生语言下运行正确

00:23:49.796 --> 00:23:52.165
在这里仅仅涵盖了
我们在AppKit中做的事

00:23:53.033 --> 00:23:54.401
还有很多东西可以讨论

00:23:54.468 --> 00:23:57.504
在“国际化用户界面新特性”的演讲中

00:23:57.571 --> 00:23:59.139
在星期五上午9:00
于Nob Hill举行

00:23:59.640 --> 00:24:01.308
他们涵盖了更多东西在桌面方面

00:24:01.375 --> 00:24:05.979
比如WebKit 文本布局
资源管理

00:24:06.046 --> 00:24:09.049
他们还包含iOS上右-左的支持

00:24:09.116 --> 00:24:11.151
强烈推荐大家也关注下这个讨论

00:24:14.054 --> 00:24:15.889
让我们来讨论下promise拖拽

00:24:16.256 --> 00:24:18.225
若你还不熟悉
promise拖拽就是

00:24:18.292 --> 00:24:21.328
当用户从你的应用中拖拽一个文件

00:24:22.262 --> 00:24:25.799
但是在磁盘上其实并没有这个文件

00:24:26.133 --> 00:24:27.334
你只是许下个promise

00:24:27.401 --> 00:24:29.570
你将会写入到用户想要释放的地方

00:24:29.903 --> 00:24:30.971
这就是一个文件promise拖拽

00:24:31.038 --> 00:24:34.575
从一开始我们就在OS X中
支持promise拖拽

00:24:35.809 --> 00:24:38.712
在macOS Sierra中
我们升级了文件promise拖拽

00:24:38.779 --> 00:24:42.015
将会更加现代化
使用NSFilePromiseProvider

00:24:42.082 --> 00:24:44.284
和NSFilePromiseReceiver对象

00:24:44.985 --> 00:24:47.354
现在这些对象允许
文件promise拖拽

00:24:47.421 --> 00:24:48.789
来支持拖放群集

00:24:49.223 --> 00:24:50.490
若你对拖放群集还不熟悉

00:24:50.557 --> 00:24:52.259
其实就是当你拖放多个元素时

00:24:52.326 --> 00:24:54.361
它们会形成中间拖动

00:24:54.428 --> 00:24:56.463
这依赖于目标应用

00:24:56.530 --> 00:24:57.531
将会对它们做什么

00:24:59.666 --> 00:25:03.170
使用这两类的文件promise
拖拽可支持拖拽群集

00:25:03.237 --> 00:25:04.204
它们基于UTI

00:25:04.538 --> 00:25:06.974
它们完全是尊从
writer和reader样板

00:25:07.040 --> 00:25:10.811
即你可使用NSPasteboard
上基于元素的API

00:25:10.878 --> 00:25:12.446
同这些对象一起工作

00:25:13.280 --> 00:25:14.982
如果可能的话它们会适配文件

00:25:15.048 --> 00:25:16.884
所以你不用担心文件的适配

00:25:16.950 --> 00:25:19.253
我们会自动包装文件适配的读

00:25:19.319 --> 00:25:21.488
和写 从你的利益角度出发

00:25:22.089 --> 00:25:23.457
并且反过来它们也是兼容的

00:25:24.124 --> 00:25:27.895
它们反过来也兼容基于无元素的
文件promise API

00:25:28.462 --> 00:25:31.031
也就是说你只需要关心一个API

00:25:31.231 --> 00:25:33.734
如果你实现了一个
NSFilePromiseProvider

00:25:33.800 --> 00:25:35.502
你现可提供文件promise

00:25:35.569 --> 00:25:39.406
给任何使用新NSFilePromiseReceiver API的人

00:25:39.473 --> 00:25:41.575
或者那些在现有应用中

00:25:41.642 --> 00:25:43.610
使用基于无元素API的人

00:25:43.677 --> 00:25:45.979
他们同样可以接受
你的promise文件

00:25:46.046 --> 00:25:49.283
就像NSFilePromiseReceiver一样

00:25:49.349 --> 00:25:51.552
你也可以接受文件promise

00:25:51.618 --> 00:25:54.454
从任何使用NSFilePromiseProvider的地方

00:25:54.521 --> 00:25:57.057
或者使用基于无元素API的地方

00:25:59.693 --> 00:26:03.530
所以如果你想在拖拽中提供
一个文件promise

00:26:03.597 --> 00:26:06.200
当用户开始拖动时
你需要创建一个promise

00:26:06.266 --> 00:26:09.703
通过创建一个
NSFilePromiseProvider实例来实现

00:26:09.970 --> 00:26:13.207
如果你想要给
每个promise的文件

00:26:13.273 --> 00:26:14.641
都创建一个实例

00:26:14.708 --> 00:26:17.377
你需要提供一个
NSFilePromiseProvider代理

00:26:17.611 --> 00:26:19.580
这个代理将负担承重的任务

00:26:19.646 --> 00:26:21.248
把文件写入到磁盘上

00:26:21.949 --> 00:26:24.685
同时 目的地将调用
这个promise

00:26:24.751 --> 00:26:27.487
你将会被询问提供目的地的文件名称

00:26:27.554 --> 00:26:28.889
现在你知道目的地在哪里了

00:26:28.956 --> 00:26:30.657
你就可以弄清楚文件名了

00:26:30.724 --> 00:26:33.360
不过请不要在这个时候写入文件
因为它还没被包装成

00:26:33.427 --> 00:26:35.863
文件适配
而且我们发现

00:26:35.929 --> 00:26:37.598
拖动中还有一些其它项目

00:26:38.232 --> 00:26:39.099
当拖动结束之后

00:26:39.166 --> 00:26:40.667
我们知道了所有需要知道的信息

00:26:40.734 --> 00:26:43.904
再来调用代理 然后询问
你promise要写入到的URL

00:26:44.705 --> 00:26:46.340
并提供一个完成的处理器

00:26:46.406 --> 00:26:50.611
在这个时候 它们都包装成了
文件适配写入

00:26:50.944 --> 00:26:53.347
然后只需要写入文件到
提供的URL

00:26:53.413 --> 00:26:55.949
然后调用完成的处理器
让文件适配知道

00:26:56.016 --> 00:26:56.950
你已经完成了写入

00:26:58.385 --> 00:27:00.521
若你想要接受一个文件promise

00:27:00.821 --> 00:27:02.623
你首先需要注册view

00:27:02.689 --> 00:27:04.725
在你想要允许任务发生的地方

00:27:05.192 --> 00:27:07.861
这通常由view.register
forDraggedTypes完成

00:27:07.928 --> 00:27:11.198
你需要添加的拖动类型
就是NSFilePromiseReceiver

00:27:11.265 --> 00:27:12.699
readableDrappedTypes

00:27:12.766 --> 00:27:14.067
这非常简单

00:27:15.068 --> 00:27:17.771
现在一旦用户拖动一个文件
promise到这个view上

00:27:17.838 --> 00:27:19.273
你将会得到拖拽消息

00:27:19.339 --> 00:27:21.375
然后你想得到promise对象

00:27:22.242 --> 00:27:26.013
可以使用基于元素样板API

00:27:26.079 --> 00:27:29.650
访问这个对象的forClasses
NSFilePromiseReceiver.self来获得访问

00:27:29.716 --> 00:27:32.386
你将会得到一个
NSFilePromiseReceiver对象的数组

00:27:33.320 --> 00:27:35.689
你但你有了
NSFilePromiseReceiver对象

00:27:35.756 --> 00:27:37.090
你可以调用这个promise里面的

00:27:37.157 --> 00:27:40.227
通过调用receivePromisedFiles
atDestination options

00:27:40.294 --> 00:27:41.428
operationQueue reader

00:27:42.029 --> 00:27:44.531
然后它将迅速的从这个函数返回

00:27:44.598 --> 00:27:46.400
reader块还没有被调用

00:27:46.466 --> 00:27:47.768
我们将在后面返回来调用

00:27:48.869 --> 00:27:51.605
一但源文件写入所有的promise

00:27:51.672 --> 00:27:54.308
现在我们继续
返回过去调用reader块

00:27:54.374 --> 00:27:56.343
在指定的操作队列上

00:27:56.877 --> 00:28:01.615
现在 这点非常重要
你没有指定NSMainOperationQueue

00:28:01.682 --> 00:28:04.117
给这个操作队列
或者你将

00:28:04.184 --> 00:28:07.521
打断你的应用
在等待源进程

00:28:07.588 --> 00:28:08.822
完成文件写入的时候

00:28:08.889 --> 00:28:09.957
这过程需要一些时间

00:28:10.023 --> 00:28:12.392
而且你不想应用被打断在这整个过程中

00:28:15.963 --> 00:28:18.198
这就是关于文件
promise拖拽所做的事

00:28:18.265 --> 00:28:22.202
它有更简单的的API可以使用
而且可以同拖拽群集工作

00:28:22.269 --> 00:28:24.872
还可以通过样板支持基于元素API

00:28:25.772 --> 00:28:27.708
让我们继续来讲下我们做的一些改进

00:28:27.774 --> 00:28:29.243
针对各种容器视图

00:28:29.476 --> 00:28:31.178
我们从集合视图开始

00:28:31.812 --> 00:28:34.681
对于集合视图 预想你可以滚动

00:28:35.182 --> 00:28:38.318
内容可以在任何背景视图上滚动

00:28:38.385 --> 00:28:39.419
这就是你可能已有的

00:28:39.586 --> 00:28:42.055
现在你可以告诉背景视图
跟随上下文一起滚动

00:28:42.122 --> 00:28:44.858
通过设置backgroundViews
ScrollsWithContent为真

00:28:44.925 --> 00:28:46.093
它们将会一起滚动

00:28:46.927 --> 00:28:50.464
我们同样已经支持
可选浮动header和footer

00:28:50.531 --> 00:28:52.699
你可以把这里的文档header
设为浮动

00:28:52.766 --> 00:28:54.334
然后内容区域滚动将会在它下面

00:28:55.936 --> 00:28:58.739
使用NSCollectionView的浮动布局
这将非常的简单

00:28:59.006 --> 00:29:01.275
只需要设置sectionHeadersPinToVisible为真

00:29:01.341 --> 00:29:04.444
或者sectionFootersPinToVisibleBounds为真

00:29:04.511 --> 00:29:05.979
如果你想要footer为浮动

00:29:06.046 --> 00:29:07.714
NSCollectionView将会

00:29:07.781 --> 00:29:10.083
适当的处理 基于你的行为

00:29:11.151 --> 00:29:13.720
你也可以可选折叠任何部分

00:29:13.787 --> 00:29:16.023
到一个单独的水平的可滚动行

00:29:16.089 --> 00:29:18.926
正如你这里看到的一样
而且还有少许旋转效果

00:29:18.992 --> 00:29:20.527
当你水平滚动的时候

00:29:22.229 --> 00:29:25.732
通过toggleSectionCollapse IBAction
可以非常简单地做到这点

00:29:25.799 --> 00:29:27.201
在NSCollectionView上

00:29:27.634 --> 00:29:31.805
现在这个消息的发送者需要是一个视图

00:29:31.872 --> 00:29:35.375
在你的区块header或者一个
继承自区块header的视图

00:29:35.442 --> 00:29:38.312
NSCollectionView才能准确的确定

00:29:38.378 --> 00:29:41.248
哪个区块需要切换折叠

00:29:43.250 --> 00:29:47.154
一旦在header或者
派生的视图中有按钮

00:29:47.588 --> 00:29:50.891
你需要将区块的header
实现NSCollectionView

00:29:50.958 --> 00:29:53.994
SectionHeaderView协议
它仅仅只是

00:29:54.061 --> 00:29:56.530
把你的按钮链接到sectionCollapseButton的插口

00:29:57.097 --> 00:29:59.499
然后NSCollectionView
将可以可以找到你的按钮

00:29:59.566 --> 00:30:01.201
并且自动隐藏和显示它

00:30:01.268 --> 00:30:05.038
依赖于内部有足够的内容

00:30:05.105 --> 00:30:07.174
在这个区块来折叠

00:30:09.009 --> 00:30:11.712
NSTableView
将重绘所有的子视图

00:30:12.212 --> 00:30:13.814
当索引值为-1

00:30:13.881 --> 00:30:17.150
负1是我们的特殊数表示

00:30:17.217 --> 00:30:22.489
扩展你表格中的所有行和列

00:30:22.823 --> 00:30:24.091
因此 当你调用reloadData

00:30:24.157 --> 00:30:26.226
并且索引包含负1时

00:30:26.293 --> 00:30:29.396
我们将替你自动重载所有行

00:30:29.863 --> 00:30:33.667
这个仅从10.12版本开始支持

00:30:34.501 --> 00:30:37.271
因此在10.12或更新版本中

00:30:37.337 --> 00:30:40.774
NSOutlineView
也将自动加载它的表格

00:30:40.841 --> 00:30:43.610
相关联的也会重新加载

00:30:44.545 --> 00:30:48.348
另外 OutlineView
现在体验更好

00:30:48.415 --> 00:30:50.584
通过数据源返回

00:30:51.785 --> 00:30:56.557
这个功能非常有用 但若你的应用真想

00:30:56.623 --> 00:31:01.161
保持我们原有的刷新行为

00:31:01.228 --> 00:31:03.063
你可以设置
stronglyReferencesItems为假

00:31:03.130 --> 00:31:07.568
你就可以使用
10.12之前版本的行为

00:31:10.737 --> 00:31:13.740
然后 Taylor Kelly向前

00:31:13.807 --> 00:31:15.742
来和你谈谈网格视图

00:31:22.516 --> 00:31:23.417
谢谢Raleigh

00:31:23.917 --> 00:31:26.854
首先我想谈NSGridView视图

00:31:27.054 --> 00:31:30.157
这是和NSStackView
相似的一个新视图类

00:31:30.224 --> 00:31:31.692
我们实现了创建和管理

00:31:31.758 --> 00:31:33.894
约束你的布局

00:31:34.862 --> 00:31:37.564
但如同StackView
创建线性布局显示

00:31:37.631 --> 00:31:40.667
NSGridView
创建相交的行和列

00:31:41.001 --> 00:31:43.871
你在偏向窗格的UI中会经常看到

00:31:44.104 --> 00:31:46.440
是的 这些不同的行列

00:31:46.507 --> 00:31:48.942
会自动调整

00:31:49.009 --> 00:31:50.477
标准的定义

00:31:51.278 --> 00:31:55.682
它支持基线 头部 底部 对齐

00:31:56.383 --> 00:31:59.520
它支持GridView设置整体间距

00:31:59.586 --> 00:32:02.890
作为每个行列之间的间距

00:32:03.957 --> 00:32:06.727
类似电子表格应用 它支持单元格合并

00:32:06.793 --> 00:32:10.264
因此 一个单一的视图
可以跨越多行或多个列

00:32:11.098 --> 00:32:13.700
如同分隔符做的一样

00:32:15.135 --> 00:32:18.038
它还支持动态隐藏行和列的显示

00:32:18.105 --> 00:32:20.073
不改变GridView结构的情况下

00:32:20.440 --> 00:32:22.809
例如 当我们点击这个复选框

00:32:22.876 --> 00:32:24.811
我们可能想隐藏
显示偏好按钮

00:32:25.679 --> 00:32:28.382
我们可以通过获取包含按钮的行

00:32:28.448 --> 00:32:30.150
并设置其隐藏属性为true

00:32:30.784 --> 00:32:32.619
GridView将自动刷新界面

00:32:34.054 --> 00:32:36.490
还有几个可以改进我们自动布局

00:32:37.024 --> 00:32:39.660
一个是清理AppKit布局周期

00:32:40.260 --> 00:32:42.729
视图不在需要使用布局

00:32:42.796 --> 00:32:44.731
或者不需要层的参与

00:32:45.399 --> 00:32:47.768
通过设置needslayout
为true

00:32:47.835 --> 00:32:50.671
下一个界面显示时 它会调用布局

00:32:52.039 --> 00:32:55.542
这样布局显示时
不再被调用两次

00:32:55.609 --> 00:33:00.013
对于层的支持
我们减少了隐性脏布局

00:33:00.080 --> 00:33:02.749
因此减少布局

00:33:02.816 --> 00:33:04.284
这个实现方式很好

00:33:04.585 --> 00:33:05.719
但是 如果你遇到布局

00:33:05.786 --> 00:33:07.821
在你调用时没有响应

00:33:07.888 --> 00:33:10.324
确认你设置了needsLayout

00:33:11.358 --> 00:33:14.561
所有这一切都使它更容易
成为你的子视图手动布局

00:33:14.628 --> 00:33:17.431
所以你可以重写布局
而不需要调用super

00:33:17.497 --> 00:33:21.468
计算子视图宽架 设置并返回

00:33:22.536 --> 00:33:24.738
你要确保没有

00:33:24.805 --> 00:33:26.573
将自己的视图和其他视图混淆

00:33:26.640 --> 00:33:28.308
若在视图布局中发生这样的情况

00:33:28.375 --> 00:33:30.978
它设置自己的框架或父类的框架

00:33:31.245 --> 00:33:36.283
这将弄脏视图的布局
并导致额外的布局

00:33:37.117 --> 00:33:39.720
如果一直存在
这就是我们说的布局环

00:33:40.254 --> 00:33:41.755
这个很难去调试

00:33:42.222 --> 00:33:44.024
所以在macOS 和 iOS

00:33:44.091 --> 00:33:46.560
我们已经介绍了新的布局环的调试

00:33:46.627 --> 00:33:49.596
所以你可以更好的理解
哪儿布局有问题和为什么

00:33:51.164 --> 00:33:54.201
布局的改变添加的API到父类

00:33:54.268 --> 00:33:57.070
因此 你可以知道父类的含义

00:33:57.538 --> 00:34:00.474
即使不使用父类接口
你也需要申请

00:34:02.442 --> 00:34:04.411
除此之外
时间现在是可以为null

00:34:04.478 --> 00:34:07.181
因此 如果你正在使用该属性
一定要处理的是零的情况

00:34:08.081 --> 00:34:10.117
另外 接口支持新功能

00:34:10.184 --> 00:34:12.052
用于自动布局的添加

00:34:12.418 --> 00:34:13.620
因此在一个单独文件或

00:34:13.687 --> 00:34:17.357
在一个单一的视图层次结构中
你可以使用常量

00:34:17.424 --> 00:34:18.458
这是非常好的

00:34:19.726 --> 00:34:22.029
NSGridView布局环调试的
详细内容

00:34:22.094 --> 00:34:24.831
在周五“自动布局有何新特性”中讲解

00:34:26.099 --> 00:34:28.101
在这里
我想谈谈颜色

00:34:28.168 --> 00:34:30.237
特别是全范围的颜色

00:34:30.771 --> 00:34:33.540
所以sRGB是一个漂亮的
流行色彩空间

00:34:33.607 --> 00:34:37.844
通常是使用隐含的颜色
代替未指定的空间

00:34:38.145 --> 00:34:40.581
我们大部分的显示器
有一个sRGB色域

00:34:41.514 --> 00:34:44.650
新的5K iMac
和iPad Pro 9.7英寸屏

00:34:44.918 --> 00:34:48.856
都包含这些更新的显示器
可以显示更生动的颜色

00:34:49.322 --> 00:34:52.059
具体地说 他们正在使用
P3色域

00:34:52.559 --> 00:34:56.063
比起sRGB色域

00:34:56.129 --> 00:34:58.565
它可以显示很多
更充满活力的绿色和红色

00:34:59.433 --> 00:35:02.603
所以你的应用可以显示照片

00:35:02.669 --> 00:35:05.706
更精确的颜色
可以展示这些更具活力的

00:35:05.772 --> 00:35:08.075
颜色让界面看上去更加真实

00:35:08.842 --> 00:35:11.678
举颜色的一个例子
绿色

00:35:11.745 --> 00:35:14.915
正好是
Pantone的2013年度色

00:35:16.149 --> 00:35:17.985
它超出了sRGB范围

00:35:18.051 --> 00:35:19.786
所以以前显示器不能显示这个颜色

00:35:19.853 --> 00:35:22.623
但是使用P3可以完美显示出来

00:35:24.024 --> 00:35:27.160
你的照片也包含
这些更鲜艳的颜色

00:35:27.227 --> 00:35:29.196
特别是红色和橙色

00:35:29.730 --> 00:35:33.400
讽刺的是 投影机
甚至在家里的电视

00:35:33.467 --> 00:35:35.669
其实不去
显示这些颜色

00:35:35.736 --> 00:35:38.672
所以你不得不承认它们很特别

00:35:40.541 --> 00:35:41.875
如果你想用这些颜色

00:35:41.942 --> 00:35:45.212
有新的色彩空间displayP3
它让你可以拥有

00:35:45.279 --> 00:35:47.915
这包含sRGB和
其它的色彩空间

00:35:48.415 --> 00:35:53.086
NSColor中有新构造方法
displayP3红色 绿色 蓝色 阿尔法值

00:35:53.153 --> 00:35:55.589
它允许你
在颜色空间中创建一个颜色

00:35:55.789 --> 00:35:58.692
UIColor具有相同的构造函数
具有相同的效果

00:35:59.760 --> 00:36:01.595
另一种方式具有广泛的颜色

00:36:01.662 --> 00:36:05.098
采用的方式
我们调用扩展范围sRGB

00:36:06.667 --> 00:36:09.837
所以用色彩空间时
你通常被限制

00:36:09.903 --> 00:36:11.872
元件值从0到1

00:36:12.406 --> 00:36:14.274
且你可在色域范围内选择任何颜色

00:36:14.341 --> 00:36:16.710
比如蓝色 通过这些值

00:36:17.311 --> 00:36:20.147
但你不能代表一个颜色
这就是色域之外

00:36:20.214 --> 00:36:22.583
所以sRGB不能代表这个绿色的颜色

00:36:23.550 --> 00:36:26.353
扩展范围sRGB
使用相同的基色

00:36:26.420 --> 00:36:29.389
和相同的白色点为sRGB
但允许部件

00:36:29.456 --> 00:36:32.059
采取值小于
0或大于1

00:36:32.759 --> 00:36:36.163
所以它可以代表这个绿色
通过一个负的红色和蓝色的值

00:36:36.230 --> 00:36:38.131
和一个大于1的绿色值

00:36:39.066 --> 00:36:42.069
这恰好也是P3
绿色的原始值 因此

00:36:42.135 --> 00:36:45.105
扩展范围的sRGB
你可以代表全范围

00:36:45.172 --> 00:36:47.207
你需要的颜色
在显示器上

00:36:48.542 --> 00:36:51.311
这也有一个彩色空间
extendedSRGB

00:36:51.879 --> 00:36:53.380
和现有的NSColor

00:36:53.447 --> 00:36:55.616
以及UIColor已经在使用的函数

00:36:55.782 --> 00:36:57.951
先前提供的
颜色使用sRGB

00:36:58.218 --> 00:37:01.555
现在将接受较少的值
小于0或大于1

00:37:01.622 --> 00:37:03.891
给你回一个
扩展范围的sRGB色

00:37:04.391 --> 00:37:05.359
这是非常方便的

00:37:07.461 --> 00:37:08.662
考虑一个重要的事

00:37:08.729 --> 00:37:11.732
这些更广泛的颜色
色域颜色深度

00:37:12.132 --> 00:37:15.736
所以sRGB理论上可以
表示在其色域任何颜色

00:37:15.802 --> 00:37:17.137
但每比特8位

00:37:17.204 --> 00:37:20.440
你也只能解决数量有限的 是的

00:37:20.507 --> 00:37:22.876
这里的黑色空间只是非寻址颜色

00:37:22.943 --> 00:37:24.411
使用8位每组件

00:37:25.812 --> 00:37:29.283
当你扩大色域 增加该色域的音量

00:37:29.349 --> 00:37:31.118
但保持相同的位深度

00:37:31.185 --> 00:37:33.687
你是可寻址的色密度下降

00:37:34.121 --> 00:37:37.524
你能够指定的颜色丢失精度

00:37:38.158 --> 00:37:39.193
这就是为何我们建议

00:37:39.259 --> 00:37:42.462
工作时
这些更广泛的色彩空间中 如P3

00:37:42.529 --> 00:37:45.165
你用16位比特
使用每个组件

00:37:46.333 --> 00:37:48.535
它内存和存储数量翻倍

00:37:48.602 --> 00:37:51.271
但给你成倍增长更多可寻址颜色

00:37:51.338 --> 00:37:52.973
因此 我们认为 权衡是值得的

00:37:54.374 --> 00:37:57.945
需要使用什么API
考虑到这些更深的颜色

00:37:58.412 --> 00:38:00.981
好了 好消息是
大多数都是自动的

00:38:01.048 --> 00:38:04.151
所以NSWindow将自动使用
较深的支持存储

00:38:04.251 --> 00:38:07.321
有了这些更高的位深度
宽色域显示

00:38:07.387 --> 00:38:09.289
即使你拖动
它在整个屏幕

00:38:09.990 --> 00:38:11.959
如果你需要一个方法
明确控制

00:38:12.025 --> 00:38:15.295
你可以设置深度限制属性
为你选的值

00:38:16.430 --> 00:38:18.832
视图和层内窗口会自动

00:38:18.899 --> 00:38:22.202
继承该位深度
唯一的例外是OpenGL视图

00:38:22.636 --> 00:38:25.138
你应该用
相关的像素格式的API

00:38:26.406 --> 00:38:31.478
在macOS和iOS的
CALayer有一新内容格式的属性

00:38:32.079 --> 00:38:35.682
允许你再次
明确控制它使用比特深度

00:38:36.517 --> 00:38:39.119
所以这是你可以利用的优势
在你的应用广泛的颜色

00:38:39.186 --> 00:38:42.122
我们也提高了部分
系统性能 能够更好的利用

00:38:42.189 --> 00:38:43.357
这些广泛的色彩

00:38:43.790 --> 00:38:45.259
一个例子是彩色面板

00:38:45.659 --> 00:38:47.294
所以 在iMac左边

00:38:47.361 --> 00:38:49.530
颜色盘会显示

00:38:51.231 --> 00:38:52.065
开始

00:38:52.132 --> 00:38:55.969
它实际上会显示和允许
从全方位的P3的颜色

00:38:57.371 --> 00:38:59.773
超出sRGB
正常颜色轮也会允许

00:39:00.574 --> 00:39:03.677
然而 你也能
右键单击颜色轮

00:39:03.744 --> 00:39:06.280
并明确选择
工作区色彩空间

00:39:06.680 --> 00:39:09.783
因此 即使在这些以前的显示器
不能使P3的颜色

00:39:09.850 --> 00:39:11.785
你仍然可以允许选则他们

00:39:13.954 --> 00:39:15.989
RGB颜色选择器
始终允许你

00:39:16.056 --> 00:39:17.858
选择颜色
替换你工作空间

00:39:17.925 --> 00:39:19.960
但它也允许你
改变表示

00:39:20.027 --> 00:39:24.198
从8位值
从0到255到浮点数

00:39:24.565 --> 00:39:25.966
所以你又能得到精度更高

00:39:26.033 --> 00:39:28.001
工作时
有了这些更广泛的色彩空间

00:39:28.702 --> 00:39:32.539
这些颜色面板的变化是
所有的应用程序完全免费

00:39:32.606 --> 00:39:34.575
没有任何的接口需要调用

00:39:36.310 --> 00:39:39.313
工作具有广泛的颜色
星期四的谈话涵盖更多

00:39:39.379 --> 00:39:41.748
如目录支持
WebKit支持

00:39:42.149 --> 00:39:45.018
我建议你更新出来
如果这些东西使你感兴趣

00:39:46.520 --> 00:39:49.056
因此 下一个主题是
状况项目改进

00:39:49.122 --> 00:39:50.591
所以状态项的事情

00:39:50.657 --> 00:39:52.860
底部的菜单栏

00:39:52.926 --> 00:39:54.795
这些是
先前的使用要求

00:39:54.862 --> 00:39:57.965
私有API来实现
但现在大多是免费的

00:39:58.932 --> 00:40:00.367
首先是排序

00:40:00.434 --> 00:40:03.604
现在你可以命令点击
拖动任何项目排序它

00:40:03.670 --> 00:40:05.873
内部和外部的系统项目

00:40:06.440 --> 00:40:09.476
你也可以用键盘
焦点转到您的项

00:40:09.543 --> 00:40:11.712
甚至激活菜单项内

00:40:12.779 --> 00:40:15.983
这一切最好的部分 这是完全自动的

00:40:16.049 --> 00:40:17.918
没有API选择或链接检查

00:40:18.485 --> 00:40:21.054
所以所有的项目都是命令点击
拖动重新排序

00:40:21.321 --> 00:40:24.858
和任何菜单设置的项目
将参与键盘导航

00:40:25.192 --> 00:40:27.928
如果他们有一个自定义的目标活动
他们会被跳过

00:40:29.463 --> 00:40:31.265
其次是隐藏和去除

00:40:31.632 --> 00:40:34.401
您现在可以命令单击
并将一个项目从状态栏中拖动

00:40:34.468 --> 00:40:36.336
移除通知该更改

00:40:36.403 --> 00:40:38.472
甚至编程恢复

00:40:39.373 --> 00:40:41.642
不同的排序
这就需要选择

00:40:41.708 --> 00:40:44.511
没有状态项目将
自动移除

00:40:44.945 --> 00:40:47.347
你可以通过设置
现状项目的行为

00:40:47.414 --> 00:40:49.049
包含removalAllowed

00:40:49.683 --> 00:40:51.285
你可以编程
读/设置

00:40:51.351 --> 00:40:55.022
甚至得到KVO通知这个变化的
利用可见属性

00:40:55.589 --> 00:40:57.491
如果你的应用是一个状态栏的应用

00:40:57.558 --> 00:41:00.260
它只表示意义
是在状态栏图标

00:41:00.327 --> 00:41:03.597
有无文件图标或其他的方式
要退出它 你可以设置它

00:41:03.664 --> 00:41:05.599
自动退出清除

00:41:05.666 --> 00:41:07.801
通过设置terminationOnRemoval行为

00:41:09.369 --> 00:41:11.738
所有这一切都会为你保存
位置

00:41:11.805 --> 00:41:13.473
和可见的状态
所以你不必担心

00:41:13.540 --> 00:41:16.443
为了保持使用
自动保存名字

00:41:16.910 --> 00:41:19.346
我们自动生成
这种基于项目指标

00:41:19.413 --> 00:41:21.014
你在你的应用程序中创建的

00:41:21.481 --> 00:41:23.784
但如果你创造它们
一些非确定性的顺序

00:41:23.851 --> 00:41:25.485
或者只是想拥有
更明确的控制

00:41:25.686 --> 00:41:29.022
您可以设置自动保存的名称
你选择一些标识符

00:41:30.290 --> 00:41:31.658
这样的状况项目改进

00:41:31.725 --> 00:41:33.961
很多都是免费的
和一点点的调整

00:41:34.027 --> 00:41:36.163
你真的可以使他们
在应用程序中更好使用

00:41:37.097 --> 00:41:39.132
下一个是控件构造函数

00:41:39.533 --> 00:41:42.636
所以这些新的构造函数
在现有NS控制

00:41:42.703 --> 00:41:45.806
这使它很容易
得到标准的外观和感觉

00:41:46.507 --> 00:41:50.711
例如 不同类型的按钮
分段控制

00:41:50.944 --> 00:41:55.649
图像视图 滑块
标签和文本字段

00:41:56.116 --> 00:41:57.918
所以这些类型的
已有的

00:41:57.985 --> 00:41:59.753
Interface Builder对象库

00:41:59.820 --> 00:42:02.990
这使得它很容易使用盒子的性能

00:42:03.624 --> 00:42:07.227
他们跟标准的系统设置
合适的字体大小 颜色和文本颜色

00:42:07.294 --> 00:42:09.162
他们支持不同的情境

00:42:09.229 --> 00:42:12.833
浅绿色充满动感的标签看起来很棒

00:42:12.900 --> 00:42:15.469
甚至盒子中充满动感的暗色

00:42:15.536 --> 00:42:17.070
没有额外的安装

00:42:17.471 --> 00:42:20.007
这将对你代码起何作用
我想向你举例说明

00:42:20.974 --> 00:42:22.643
这是创建一个复选框前

00:42:22.709 --> 00:42:24.278
需设置相当多的属性

00:42:24.344 --> 00:42:26.947
不幸的是
我们真的只关心其中的三个

00:42:27.014 --> 00:42:28.682
标题 目标和行动

00:42:29.816 --> 00:42:33.187
复选框 以及标题 目标
行动 剩下的

00:42:33.587 --> 00:42:34.688
这是非常好的

00:42:38.158 --> 00:42:39.560
更多的一点 哦

00:42:42.196 --> 00:42:43.030
等着

00:42:43.530 --> 00:42:45.599
所以这就是创造一个静态标签

00:42:45.666 --> 00:42:47.401
只是屏幕上的一些文字

00:42:47.467 --> 00:42:50.237
而在这里 我们关心的
只是字符串值

00:42:50.971 --> 00:42:53.974
有文字的标签 又是这样的

00:42:54.808 --> 00:42:56.977
所以 这非常棒

00:42:57.044 --> 00:42:58.445
它是从盒子里出来的

00:43:03.417 --> 00:43:06.687
它出来的盒子可以用
带或不带自动布局

00:43:06.753 --> 00:43:08.922
所以 如果你要
定位约束

00:43:08.989 --> 00:43:11.024
你还需要设置
translatesAutoresizingMask

00:43:11.091 --> 00:43:14.361
IntoConstaints为假
像你其他的视图一样

00:43:14.695 --> 00:43:16.997
所以如果你已经有了类
做这些事情

00:43:17.064 --> 00:43:19.166
我们仍然建议移动到
这些新的系统

00:43:19.233 --> 00:43:21.702
因为你会确保
你的控制有标准的外观

00:43:21.768 --> 00:43:24.137
感觉现在和未来

00:43:25.639 --> 00:43:28.041
我最后想谈的是API的改进

00:43:28.108 --> 00:43:30.644
我只覆盖了一些这些
适用于我们所有的框架

00:43:30.711 --> 00:43:32.212
这些申请AppKit

00:43:32.279 --> 00:43:35.082
我还想谈谈适用于AppKit
的另外两点

00:43:36.016 --> 00:43:37.684
首先是弱委托

00:43:38.352 --> 00:43:40.654
所以我们已经添加了新的归零
弱委托的支持

00:43:40.721 --> 00:43:44.124
对于不同的代表和数据
不同类别的源

00:43:45.025 --> 00:43:46.860
所以你不再需要明确这些属性

00:43:46.927 --> 00:43:48.562
当引用们被释放

00:43:49.696 --> 00:43:52.032
它仍然支持非弱引用的对象

00:43:52.232 --> 00:43:54.501
在这种情况下 它会回到原有的分配

00:43:54.568 --> 00:43:56.570
或不安全的 不保留语义

00:43:57.838 --> 00:43:59.072
我们也经历过并确定了

00:43:59.139 --> 00:44:02.843
我们所有的类显式
并宣布其指定的初始化

00:44:03.377 --> 00:44:05.646
这些是和他们以前一样有效的

00:44:05.712 --> 00:44:08.115
但现在只是
在实际的接口中声明

00:44:08.682 --> 00:44:10.551
有一个例外
NSCursor

00:44:10.617 --> 00:44:13.187
所以 如果你是子NSCursor
请看发行说明

00:44:13.253 --> 00:44:14.922
你应该
正确处理

00:44:16.290 --> 00:44:18.725
与所有的新声明
指定的初始化

00:44:19.059 --> 00:44:23.163
你应该确保你是正确的
在你的类的处理

00:44:24.198 --> 00:44:25.766
所以如果你以前没有

00:44:25.832 --> 00:44:27.534
你可能会有这些错误问题

00:44:27.601 --> 00:44:29.236
这也许是微妙的错误

00:44:29.436 --> 00:44:31.772
在Objective-C
现在看到的编译警告

00:44:31.839 --> 00:44:33.841
在Swift 你要去
获得建立失败

00:44:34.308 --> 00:44:37.044
所以你要确保你
妥善处理这些不同的情况

00:44:38.212 --> 00:44:39.413
这是AppKit最新内容

00:44:39.479 --> 00:44:40.714
在这一点上
我想翻过去

00:44:40.781 --> 00:44:43.083
有请Ali
讲述“Foundation有何新特性”

00:44:50.490 --> 00:44:51.391
谢谢你 Taylor

00:44:53.861 --> 00:44:56.463
所以这里有一些东西
这是新基础

00:44:56.530 --> 00:44:58.632
现在进入主题

00:44:59.299 --> 00:45:02.336
现在你看到了
NSURL成为URL

00:45:02.402 --> 00:45:04.872
我想我们昨天也谈到了一点

00:45:04.938 --> 00:45:08.642
我们把NS前缀
在Swift中添加了快捷键

00:45:10.410 --> 00:45:13.280
现在 你可能知道
地基大的子集

00:45:13.347 --> 00:45:16.416
实际上
用Swift核心库

00:45:16.483 --> 00:45:18.085
作为Swift 代码部分

00:45:18.151 --> 00:45:20.621
是可用的
在其他平台上 如Linux

00:45:21.321 --> 00:45:25.526
我们要匹配的命名样式
这部分的基础

00:45:25.592 --> 00:45:28.028
随着公约的建立
通过Swift标准库

00:45:28.095 --> 00:45:29.963
而不使用前缀

00:45:31.164 --> 00:45:35.002
因此 我们的类型很多
没有了NS前缀

00:45:35.068 --> 00:45:36.970
在基础和Swift中
正如你所看到的

00:45:37.037 --> 00:45:38.972
NSFormatter变成了
Formatter等等

00:45:39.306 --> 00:45:42.576
最后两个 NSData和NSURL
是一个特殊类别的一部分

00:45:42.643 --> 00:45:44.878
我会提到这一点

00:45:45.913 --> 00:45:48.182
现在 这正在发生
只有在基础上修改

00:45:48.248 --> 00:45:49.349
这不是我们应用的东西

00:45:49.416 --> 00:45:52.186
到我们的其他框架
甚至在基础

00:45:52.252 --> 00:45:54.154
这只是应用于一些API

00:45:54.221 --> 00:45:56.757
我们不把这
NS放到API

00:45:56.823 --> 00:45:59.326
本质上依赖于Objective-C

00:45:59.393 --> 00:46:03.230
例如 NSObject
NSProxy NSAutoreleasePool

00:46:03.530 --> 00:46:06.633
我们也不把它的API
在特定的平台

00:46:06.700 --> 00:46:09.303
事实上
在其他平台上不可用

00:46:09.369 --> 00:46:13.006
比如NSUserNotification
NSXPCConnection

00:46:14.341 --> 00:46:18.879
在另一个情况是类
这也暴露了值类型

00:46:19.313 --> 00:46:22.216
所以在这里 我们正在暴露
数据 网址 等等 但

00:46:22.282 --> 00:46:26.220
我们也将NSData NSURL

00:46:26.286 --> 00:46:27.855
等等
我的意思是

00:46:28.121 --> 00:46:30.791
现在先让我解释
一点关于值类型

00:46:32.025 --> 00:46:34.228
你可能已经
熟悉值类型

00:46:34.294 --> 00:46:36.697
我们有这个概念在
基础很长一段时间

00:46:36.763 --> 00:46:40.033
这些类型的值是
重要的 而不是身份

00:46:40.501 --> 00:46:44.505
比如NSString NSData
URL  Array等等

00:46:45.405 --> 00:46:49.643
现在 由于一些基础的API
已经有这些值类型的语义

00:46:49.710 --> 00:46:52.412
我们已经提前并将
它们最为Swift值类型添加

00:46:52.980 --> 00:46:55.682
我们已经做的全套API

00:46:55.883 --> 00:46:59.887
这当然是
字符串 数组 字典

00:46:59.953 --> 00:47:02.322
和设置已经
作为值类型

00:47:02.389 --> 00:47:04.958
在Swift中  他们是可用的
在标准库中

00:47:05.425 --> 00:47:09.663
所以现在这里的这些类型是
暴露结构在Swift中

00:47:09.730 --> 00:47:13.534
他们有价值的语义类型
这意味着他们可以直接变异

00:47:13.600 --> 00:47:15.302
如果他们有意义的可变性

00:47:15.369 --> 00:47:19.173
你可以使用let或者var突出异变

00:47:19.540 --> 00:47:20.841
在你声明他们的时候

00:47:21.108 --> 00:47:24.011
这些也符合Swift协议

00:47:24.077 --> 00:47:25.445
正如你所期望的

00:47:28.182 --> 00:47:30.984
现在已有的类的API
仍然保持在case

00:47:31.051 --> 00:47:32.886
在我们创建这些值类型

00:47:32.953 --> 00:47:35.756
让我看看
这里的案例研究

00:47:36.123 --> 00:47:38.659
一个例子是数据
我已经提到的那个

00:47:38.725 --> 00:47:40.694
所以现在我们的结构数据类型

00:47:40.761 --> 00:47:42.329
这是数据值类型

00:47:42.429 --> 00:47:48.068
这是我们期望的数据类型
在编程过程中使用最多

00:47:48.135 --> 00:47:51.939
这是前进的类型
然而 我们也有NSData

00:47:52.005 --> 00:47:54.575
这是NSObject和
NSMutableData子类

00:47:54.641 --> 00:47:57.411
这是一类NSData本身

00:47:57.778 --> 00:48:01.348
现在NS类型仍然存在
因为如NSMutableData

00:48:01.415 --> 00:48:05.052
不是很容易迁移
所以他们不会迁移它

00:48:05.452 --> 00:48:08.155
我们的另一个原因是NS类型
有时你真的

00:48:08.222 --> 00:48:09.423
要继承这些类型

00:48:09.489 --> 00:48:12.159
你知道 你可以子类化
NSData或者NSMutableData

00:48:12.226 --> 00:48:14.461
提供一些专业化的实现

00:48:14.528 --> 00:48:18.065
当然 你可以这样做
类类型 如您在这里看到的

00:48:18.131 --> 00:48:20.801
所以这些都是一些原因
为什么NS类型仍然存在

00:48:22.102 --> 00:48:24.471
现在 让我们来看一看
这里有些差异

00:48:25.772 --> 00:48:29.376
NSData类有一个长度属性

00:48:29.443 --> 00:48:31.745
这个被命名为数
在结构版本

00:48:31.812 --> 00:48:35.048
因为它与其他
Swift标准库更一致

00:48:35.482 --> 00:48:38.752
如写入方法 范围
和许多其他方法

00:48:38.819 --> 00:48:39.920
保持相当完整

00:48:39.987 --> 00:48:42.189
他们遇到相同的
方法 除非你会注意到

00:48:42.256 --> 00:48:45.692
NSRange和NSData
已成为指标范围

00:48:46.760 --> 00:48:50.697
在数据结构的版本 这是
更符合Swift库

00:48:50.931 --> 00:48:54.034
最后你会注意到
这一变异的功能 如添加

00:48:54.101 --> 00:48:57.237
是不可以在这
直接值类型数据

00:48:57.304 --> 00:49:00.374
在NSData中
它在NSMutableData类中

00:49:00.941 --> 00:49:02.342
所以这些都是一些
的差异 你会看到

00:49:02.409 --> 00:49:04.478
在值类型
与类类型之间

00:49:06.313 --> 00:49:08.382
现在我不准备说
更多关于这个内容

00:49:08.448 --> 00:49:11.585
今天下午有一个谈话
“Swift基础有何新特性”

00:49:11.652 --> 00:49:12.886
在任务室里

00:49:13.120 --> 00:49:15.722
我鼓励你们参加
并听到更多关于这些内容

00:49:17.824 --> 00:49:20.160
现在我们有几个
基础新类型

00:49:20.227 --> 00:49:21.862
代表测量的量

00:49:22.162 --> 00:49:24.264
这里的主要类
是单元类

00:49:24.331 --> 00:49:27.868
这是一个抽象的类型
代表单位 如英里

00:49:27.935 --> 00:49:30.504
摄氏度 公里
每小时 等等

00:49:30.904 --> 00:49:33.774
然后我们有一个类维度
这是一个单位的子类

00:49:33.841 --> 00:49:35.943
这代表单位家庭
如长度

00:49:36.043 --> 00:49:38.145
温度和速度 等

00:49:38.612 --> 00:49:40.047
因此 在此 我们有单位类

00:49:40.347 --> 00:49:43.383
我们有子类维度
然后我们的子类

00:49:44.117 --> 00:49:48.355
如单位长度 单位温度
单位速度 和一堆更多

00:49:50.090 --> 00:49:52.860
有一个辅助类单元
转换器可以

00:49:52.926 --> 00:49:55.395
单位之间
同一单位家庭转换

00:49:56.263 --> 00:49:59.399
有一种结构测量
它是一个类

00:49:59.466 --> 00:50:02.503
在Objective-C
在Swift中作为一个值类型

00:50:02.936 --> 00:50:05.839
结构测量相结合的值 如10

00:50:05.906 --> 00:50:07.875
用一个单位 如英里

00:50:07.941 --> 00:50:09.843
所以这基本上现在是一个测量

00:50:09.910 --> 00:50:11.645
最后锦上添花

00:50:11.712 --> 00:50:13.614
我们有测量
格式化程序类

00:50:13.680 --> 00:50:15.449
将一个测量

00:50:15.516 --> 00:50:17.818
并将其显示给用户区域中的用户

00:50:18.318 --> 00:50:23.323
所以它会显示10英里的用户
在美国这里

00:50:23.390 --> 00:50:26.560
但会显示16公里 例如在欧洲

00:50:26.627 --> 00:50:27.728
使用欧洲系统的用户

00:50:27.794 --> 00:50:31.164
所以它会为你做的转换
并向用户展示正确的数据

00:50:36.803 --> 00:50:40.707
我们有很多已定义即可用的
单位家庭定义

00:50:40.774 --> 00:50:41.909
这是全套

00:50:42.142 --> 00:50:44.077
所以这些尺度的子类

00:50:44.144 --> 00:50:46.246
在其中的每一个
单位家庭

00:50:46.313 --> 00:50:49.383
我们实际上有多个即可用的单位

00:50:49.650 --> 00:50:51.919
让我们看一看单位的温度

00:50:52.352 --> 00:50:54.821
你会看到温度
有三个标准单位

00:50:54.888 --> 00:50:57.191
开尔文 摄氏和华氏

00:50:57.491 --> 00:51:01.728
UnitTemperature类中
这些都被定义为类属性

00:51:01.795 --> 00:51:05.966
许多其他尺寸
也有一些单位规定

00:51:06.033 --> 00:51:08.035
知道彼此之间如何转换

00:51:08.202 --> 00:51:13.207
更好的消息
你可以添加你自定义的单位

00:51:13.273 --> 00:51:16.510
我们提供
它们将使用现有的

00:51:16.577 --> 00:51:19.012
而且你也可以添加
你自己的单位家庭

00:51:19.413 --> 00:51:22.916
你可以听到更多关于这个的内容
星期五下午4点

00:51:22.983 --> 00:51:24.451
测量和单位

00:51:26.787 --> 00:51:29.356
DateInterval是新类型
我们已添加到基础版本

00:51:29.423 --> 00:51:32.059
它表示一个日期间隔

00:51:33.260 --> 00:51:36.597
它有三个属性
开始 结束和持续时间

00:51:36.663 --> 00:51:38.365
相当直观 当然 这些都不是

00:51:38.432 --> 00:51:41.435
完全独立 但它们
作为三个独立的属性

00:51:41.502 --> 00:51:42.769
除了这些属性

00:51:42.836 --> 00:51:46.640
DateInterval能够做到
检查日期是否在日期间隔内

00:51:46.707 --> 00:51:48.976
或是否两个日期间隔重叠等

00:51:49.510 --> 00:51:54.181
当然日期间隔在格式化时很有用

00:51:54.248 --> 00:51:55.682
通过DateIntervalFormatter类

00:51:55.749 --> 00:51:58.719
这就是我们
这是我们去年发布API

00:51:59.553 --> 00:52:01.788
有个从String修改过来的
API接口

00:52:01.855 --> 00:52:05.092
现在我们从API到String
只需要一个日期间隔

00:52:05.659 --> 00:52:06.860
如此相当简单

00:52:07.728 --> 00:52:12.032
现在在这里让我告诉你们
一个关于公共服务通告

00:52:12.099 --> 00:52:13.500
处理日期和时间

00:52:14.635 --> 00:52:16.603
所以处理日期可能是复杂的

00:52:17.204 --> 00:52:19.106
现在 这不是这里建议的

00:52:19.173 --> 00:52:22.209
好吗 我不是医生

00:52:23.977 --> 00:52:26.313
让我们说你想要
表示10秒时间

00:52:26.780 --> 00:52:28.982
你创建个DateInterval类

00:52:29.049 --> 00:52:31.652
开始时间和10秒

00:52:31.718 --> 00:52:34.721
这可能是正确的
无论你试图做什么

00:52:34.788 --> 00:52:37.391
无论你试图
怎样处理10秒

00:52:37.791 --> 00:52:39.760
但是让我们说你是
试图代表一天

00:52:40.227 --> 00:52:42.196
你也可能这样
写你的代码

00:52:43.397 --> 00:52:46.433
24乘以60乘以60表示一天的秒数

00:52:46.900 --> 00:52:49.336
这是一个数字
24小时内的秒数

00:52:49.736 --> 00:52:52.873
它往往不是
正确的

00:52:53.240 --> 00:52:55.909
原因是因为一天
并不总是24小时长

00:52:55.976 --> 00:52:57.678
一个月并非总是31天

00:52:57.744 --> 00:53:00.280
年不总是
365天 等等

00:53:00.347 --> 00:53:02.783
我们总是把那些记在心里
但是有时一天

00:53:02.850 --> 00:53:07.688
23小时 或者有时
24小时 25小时 如你所知

00:53:08.222 --> 00:53:11.592
所以取决于你想做什么
通过DateInterval表示日期

00:53:11.959 --> 00:53:14.628
你想设置一个闹钟吗
正是从现在开始的24个小时

00:53:14.695 --> 00:53:17.865
你想在第二天同一时间发出一闹钟吗

00:53:17.931 --> 00:53:19.032
你可要小心了

00:53:19.233 --> 00:53:23.470
通常情况下正确的解决方案
涉及使用日历类

00:53:23.537 --> 00:53:25.205
你会遇到这些问题

00:53:25.272 --> 00:53:28.542
而且幸运的是他们的解决方案
上面所提到的从2013年开始

00:53:28.609 --> 00:53:30.511
常见的数据的解决方案
和时间的问题

00:53:30.577 --> 00:53:33.447
我建议你
回去重新看看

00:53:35.249 --> 00:53:38.752
ISO8601 DateFormatter
是基础类中新提供的API

00:53:38.819 --> 00:53:40.420
这是一个格式化日期类

00:53:40.787 --> 00:53:41.622
谢谢

00:53:45.392 --> 00:53:47.094
很显然你们中的一些人

00:53:47.160 --> 00:53:50.330
以前使用8601
8601是一个标准

00:53:50.397 --> 00:53:52.566
这是一个用于指定日期的交换格式

00:53:52.633 --> 00:53:53.967
在明确的方法中

00:53:54.334 --> 00:53:56.603
所以这是一个单独的类
和DateFormatter相比

00:53:56.670 --> 00:53:57.938
因为不向DateFormatter

00:53:58.005 --> 00:54:03.010
它是用户本地化的日期
8601格式是非本地化

00:54:03.310 --> 00:54:05.712
你知道这是交换格式
所以这是一个单独的类型

00:54:05.779 --> 00:54:08.115
我们决定让事情变得简单

00:54:08.448 --> 00:54:09.616
使用起来非常简单

00:54:10.484 --> 00:54:11.818
所以创建一个格式化

00:54:13.554 --> 00:54:16.390
给自己一个日期
又没有关系的建议

00:54:17.991 --> 00:54:20.527
简单地问格式化程序
为日期转为字符串

00:54:20.594 --> 00:54:22.129
它会返回你的格式

00:54:22.196 --> 00:54:24.531
现在DateFormatter
可以两种方式实现

00:54:24.731 --> 00:54:25.732
所以你实际上可以

00:54:25.799 --> 00:54:28.402
哦 顺便说一下
这是调用的输出 正如你所看到的

00:54:28.468 --> 00:54:29.903
就要到午餐时间

00:54:31.004 --> 00:54:33.407
这里是 此格式化程序
还有其他的方式

00:54:33.473 --> 00:54:34.641
也做解析

00:54:34.708 --> 00:54:38.612
所以你可以自己格式化
并要求从字符串转换成日期

00:54:38.679 --> 00:54:40.113
它会返回你的日期

00:54:40.180 --> 00:54:41.415
所以它是双向的

00:54:42.616 --> 00:54:46.286
这默认是RFC 3339
它是一种格式

00:54:46.353 --> 00:54:48.522
然而
有选项可让您指定

00:54:48.589 --> 00:54:50.691
一些行为 如果你需要的话

00:54:52.192 --> 00:54:55.495
现在让我快速的告诉你们
我们提供的其他功能

00:54:56.396 --> 00:55:00.434
URL有一堆新的属性

00:55:00.501 --> 00:55:04.104
如一个文件和一系列其他的典型路径

00:55:04.171 --> 00:55:06.406
像音量是否加密等

00:55:06.473 --> 00:55:08.542
你可以阅读所有
这些在发行说明中

00:55:08.609 --> 00:55:11.111
有一个新类
URLSessionTaskMetrics

00:55:11.512 --> 00:55:15.315
这个类可以帮助你收集
网络资源

00:55:15.382 --> 00:55:17.117
加载性能信息

00:55:17.184 --> 00:55:20.954
所以你可以看看应用程序的网络性能

00:55:22.422 --> 00:55:25.459
PersonNameComponentsFormatter
是新版本我们提供的一个API

00:55:25.893 --> 00:55:27.895
正如你所知道的 它需要一个名字

00:55:27.961 --> 00:55:30.697
它以一个区域设置适当的方式来格式化

00:55:31.064 --> 00:55:33.300
在这个版本中
其实现在可以解析名称

00:55:33.367 --> 00:55:35.135
所以你给它一个名字
它会返回你

00:55:35.202 --> 00:55:37.471
名字 姓 等等

00:55:37.538 --> 00:55:38.639
这是一个不错的工作

00:55:38.705 --> 00:55:41.475
由于它采用了一种基于
真实数据的统计模型

00:55:43.410 --> 00:55:45.445
最后

00:55:45.946 --> 00:55:47.814
但也有一些棘手的名字

00:55:47.881 --> 00:55:49.750
所以不要期望太高

00:55:52.853 --> 00:55:55.155
DateComponentsFormatter

00:55:55.222 --> 00:55:58.492
是我们最新的版本中添加的

00:55:58.559 --> 00:56:01.228
除了长短类型

00:56:01.295 --> 00:56:04.264
我们现在有一个简单的风格
你可以格式化日期

00:56:04.331 --> 00:56:07.000
下一个发布
也许我们会添加boxer风格

00:56:07.534 --> 00:56:09.369
好吧 这就是基础

00:56:11.305 --> 00:56:13.540
核心数据 只是一个
简短的提及核心数据

00:56:13.607 --> 00:56:15.576
你已经看到一些
API的改进

00:56:15.642 --> 00:56:16.844
在核心数据与泛型

00:56:16.910 --> 00:56:19.713
有更多的
新的API在核心代码里

00:56:19.780 --> 00:56:22.583
比如generational查询
持久性存储

00:56:22.649 --> 00:56:26.353
NSFetchedResultsController类
现在在系统OS X中可以使用

00:56:26.420 --> 00:56:28.689
对不起 是macOS系统

00:56:28.989 --> 00:56:32.392
周五上午10点你将听到所有这一切
“核心数据有何新特性”

00:56:33.026 --> 00:56:35.429
还有一个我想大喊出来的

00:56:36.430 --> 00:56:39.833
我们每年都在这里
告诉你关于新的API

00:56:39.900 --> 00:56:41.602
介绍了新技术

00:56:41.668 --> 00:56:44.471
你可能并不总是处于一个方式
通过这些API

00:56:44.538 --> 00:56:46.306
因为你在做其他事情

00:56:46.373 --> 00:56:48.041
或者你等一个版本

00:56:48.342 --> 00:56:51.712
好吧 如果你想得到一个概述
关于最近我们已经添加的API

00:56:51.778 --> 00:56:55.082
APIs是重要的
创建用于Mac的现代应用

00:56:55.148 --> 00:56:56.250
这个谈话是给你们的

00:56:56.450 --> 00:56:59.620
它将涉及很多主题
他们将有

00:56:59.686 --> 00:57:02.189
其他感兴趣的演讲
不只是在本届 WWDC

00:57:02.256 --> 00:57:04.157
往届 WWDC 也有

00:57:04.391 --> 00:57:07.561
它也适用于每个人
各年龄 不同经验水平

00:57:07.895 --> 00:57:09.363
这也是星期五下午5点

00:57:09.429 --> 00:57:11.164
所以我希望你在这里

00:57:13.033 --> 00:57:17.471
好的 那么这是网页
你可以了解更多信息

00:57:17.738 --> 00:57:20.440
请读AppKit
与基础版本说明

00:57:20.507 --> 00:57:22.509
您可以在我们的开发工具站点中找到

00:57:22.576 --> 00:57:25.846
它是一些原始信息
很多我已经谈到了

00:57:26.146 --> 00:57:27.948
这是我们提到的有关演讲

00:57:28.015 --> 00:57:29.149
还有更多的课程

00:57:29.416 --> 00:57:30.350
非常感谢大家