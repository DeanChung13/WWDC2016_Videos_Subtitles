00:00:19.686 --> 00:00:22.489
为用户打造隐私保护

00:00:32.866 --> 00:00:36.670
大家好 欢迎来到
“为用户打造隐私保护”

00:00:37.304 --> 00:00:39.206
我是Julien
我来自隐私工程组

00:00:39.273 --> 00:00:41.275
我非常激动
能在今天来到这里

00:00:42.576 --> 00:00:45.946
你是否想过
要怎样了解你的用户

00:00:46.013 --> 00:00:47.514
而不让他们觉得隐私被侵犯？

00:00:49.183 --> 00:00:52.085
你是否曾和你的团队争论过
到底要开放哪些控制选项

00:00:52.152 --> 00:00:55.822
要保持多高的透明度
才能赢得用户的信任？

00:00:56.490 --> 00:00:57.891
要回答这些问题

00:00:57.958 --> 00:01:01.261
今天我们将要介绍
我们自己所采用的隐私保护技术

00:01:01.662 --> 00:01:03.297
以及你可以如何应用它们

00:01:04.831 --> 00:01:08.602
众所周知
Apple非常注重用户隐私保护

00:01:09.303 --> 00:01:11.972
就在去年
Tim这样说过

00:01:12.539 --> 00:01:16.877
“用户愿意把最私密的信息托付于我们
是因为信任

00:01:17.411 --> 00:01:19.813
我们能回报他们的
只有最安全的隐私保护

00:01:19.880 --> 00:01:21.348
我们将为此竭尽全力”

00:01:22.049 --> 00:01:25.819
不只是Tim
所有在Apple工作的人 从上到下

00:01:25.886 --> 00:01:29.156
都相信隐私保护
是赢得用户信任的重要一环

00:01:29.523 --> 00:01:33.460
为了打造一个健康的生态系统
来保护你的数据

00:01:34.795 --> 00:01:39.600
我们整个隐私工程组
和Apple的其他团队通力合作

00:01:39.666 --> 00:01:42.569
把隐私保护
根植于我们的产品

00:01:43.136 --> 00:01:46.106
年复一年后
我们发现

00:01:46.406 --> 00:01:51.879
最好的产品和服务
是那些尊重用户隐私

00:01:51.979 --> 00:01:54.681
同时还能不牺牲用户体验

00:01:55.115 --> 00:02:00.220
它们是非凡的服务
拥有不可思议的功能

00:02:00.354 --> 00:02:02.389
同时尊重用户隐私

00:02:02.956 --> 00:02:05.325
它们鼓励用户
更放心地使用应用

00:02:05.459 --> 00:02:08.829
因为它们提供 透明度
可控性 一致性

00:02:09.162 --> 00:02:13.367
数据的安全性
最少的数据采集

00:02:13.433 --> 00:02:15.602
和数据使用限制

00:02:16.703 --> 00:02:21.241
随着越来越多的敏感信息
被存入我们的设备

00:02:21.475 --> 00:02:25.913
我们认为隐私保护功能正在成为
一种价值不断提升的商品

00:02:26.513 --> 00:02:28.382
它值得你的投资

00:02:29.249 --> 00:02:32.653
隐私保护不只是
简单的一组规则

00:02:32.719 --> 00:02:35.556
它也是一个契机
让你实现更智能的开发设计

00:02:35.689 --> 00:02:39.293
考虑不同的设计方案
来保证用户的最大权益

00:02:39.960 --> 00:02:43.330
比如说
它会鼓励你不断地优化产品

00:02:43.397 --> 00:02:45.966
把更多智能功能带给设备

00:02:46.166 --> 00:02:50.270
以提高用户体验
并降低网络压力

00:02:51.038 --> 00:02:54.441
它会鼓励你
只收集你需要的数据

00:02:54.708 --> 00:02:56.510
来提升你的服务

00:02:57.678 --> 00:03:00.447
今天我们将会介绍标识符

00:03:00.981 --> 00:03:03.917
如何收集与标识符绑定的数据

00:03:04.251 --> 00:03:08.121
给用户提供哪些控制选项
给他们多高的透明度

00:03:08.188 --> 00:03:12.726
有意义的选项及怎样让隐私保护
成为你应用的一部分

00:03:14.228 --> 00:03:15.796
我们从标识符开始

00:03:17.364 --> 00:03:20.634
我们很多人
每天都需要借助标识符

00:03:20.701 --> 00:03:24.438
来了解用户
分析他们的行为模式

00:03:24.972 --> 00:03:30.310
这很重要 对用户的了解
通常是从标识符开始的

00:03:30.711 --> 00:03:32.079
然而...

00:03:33.514 --> 00:03:37.351
如果你追踪
用户所做的每一件事

00:03:37.684 --> 00:03:40.988
这会给你的用户
制造不安的使用气氛

00:03:41.221 --> 00:03:44.791
降低他们的热情
他们会开始思考

00:03:45.292 --> 00:03:49.196
如果我点击了这个链接
我是不是也会被追踪

00:03:49.963 --> 00:03:53.600
一旦你的用户开始犹豫
你就开始失去他们了

00:03:55.035 --> 00:03:59.640
标识符能帮助我们打造定制化的服务
这些服务能让我们

00:03:59.706 --> 00:04:03.177
更好地了解用户
给他们提供有用的预测信息

00:04:03.477 --> 00:04:06.513
但是如果你过多地使用它
来追踪所有事情

00:04:06.580 --> 00:04:10.751
然后开始提出奇怪的建议
这会让用户很不自在

00:04:11.985 --> 00:04:15.856
标识符能非常有效地打击诈骗

00:04:16.055 --> 00:04:19.726
能尽早地探测和防止
数据的恶意使用

00:04:20.060 --> 00:04:24.965
但它们并不能分辨
你是否从用户那里无节制地收集数据

00:04:25.566 --> 00:04:26.533
所以你会怎样做？

00:04:28.135 --> 00:04:30.904
这里有一些最佳做法
我们想推荐给大家

00:04:31.004 --> 00:04:33.707
首先
更多地使用短期的标识符

00:04:33.974 --> 00:04:36.410
不要持续地使用长期存在

00:04:36.476 --> 00:04:38.846
并且一成不变的标识符

00:04:39.179 --> 00:04:41.615
你可以让标识符
随着时间推移自动变化

00:04:41.782 --> 00:04:43.817
或者让它们很容易被重置

00:04:44.885 --> 00:04:46.820
大量使用随机的标识符

00:04:46.887 --> 00:04:50.023
而不是机械性地使用某人的
用户名

00:04:50.090 --> 00:04:51.592
邮箱 或是电话号码

00:04:51.758 --> 00:04:53.360
大多数时候你都不需要用到它们

00:04:53.727 --> 00:04:57.164
问问自己
我是否真的需要对用户身份进行验证

00:04:57.231 --> 00:04:59.433
还是采用匿名模式

00:04:59.700 --> 00:05:01.802
为用户提供匿名的体验
就足够了呢？

00:05:02.302 --> 00:05:04.438
遵从这些最佳做法

00:05:04.638 --> 00:05:07.708
你将能让用户更放心地
使用你的应用

00:05:07.774 --> 00:05:10.110
不用担心隐私的泄漏

00:05:10.377 --> 00:05:12.246
让我们来看看一些例子

00:05:13.046 --> 00:05:16.216
在我们自己的产品里
全部沿用了这些标准

00:05:16.283 --> 00:05:19.586
如在Spotlight和Maps中
所有的标识符

00:05:19.653 --> 00:05:22.055
都会定期自动更改

00:05:22.189 --> 00:05:24.725
所以用户能放心使用它们

00:05:24.791 --> 00:05:27.094
不用担心隐私的泄漏

00:05:27.594 --> 00:05:30.163
我们保持了这些产品的用户体验

00:05:30.330 --> 00:05:33.100
同时保证了应用的标识符定时改变

00:05:34.501 --> 00:05:38.872
我们尽量让标识符的重置
变得简单易行

00:05:39.173 --> 00:05:43.944
举个例子 每一次开启和关闭Siri

00:05:44.011 --> 00:05:47.881
你都会得到一个新的标识符
你的隐私受到保护

00:05:48.749 --> 00:05:53.820
同时我们也尽可能地对会话进行标识
而不是用户

00:05:53.987 --> 00:05:57.224
因为大多数时候
这就是我们需要用到的全部信息

00:05:57.958 --> 00:06:00.994
我们想让你们更简单地

00:06:02.095 --> 00:06:03.564
使用这些标准

00:06:03.630 --> 00:06:06.633
所以我们开放了相应的API
能让你们很方便地

00:06:06.934 --> 00:06:09.069
生成标识符

00:06:09.203 --> 00:06:12.906
举个例子
生成通用唯一标识符（UUID）的API

00:06:13.440 --> 00:06:15.442
在Swift中只是简单的一行代码

00:06:15.509 --> 00:06:18.278
当你调用它的时候
就能生成一个标识符

00:06:19.046 --> 00:06:20.681
快速地演示一下

00:06:21.248 --> 00:06:26.620
每当你调用这个API的时候
会得到一个128位的随机数

00:06:27.020 --> 00:06:30.090
这个数字如此之大
足以让它成为全局唯一的

00:06:30.157 --> 00:06:31.925
随机数字

00:06:31.992 --> 00:06:34.194
如果再调用一次
你会得到另一个数字

00:06:34.461 --> 00:06:35.696
再调用一次等等

00:06:36.330 --> 00:06:38.966
你能自由决定如何使用

00:06:39.132 --> 00:06:40.767
这个随机数字

00:06:40.834 --> 00:06:44.605
你可以用它来标识
对象 会话 或者用户

00:06:45.939 --> 00:06:47.941
如果想使用固定的标识符
应该怎么办呢

00:06:48.008 --> 00:06:49.977
你不需要生成标识符

00:06:50.043 --> 00:06:51.311
而是调用它

00:06:51.512 --> 00:06:53.447
Vendor ID能解决这个问题

00:06:53.847 --> 00:06:55.616
它解决问题的方法是

00:06:55.682 --> 00:06:57.718
每当你调用这个API时

00:06:57.918 --> 00:07:00.554
它会给这台设备提供一个标识符

00:07:00.621 --> 00:07:03.323
有了它你就能很容易地
为设备定制服务

00:07:03.390 --> 00:07:05.425
不需要再生成一个标识符了

00:07:06.126 --> 00:07:09.229
每当你调用这个API时

00:07:09.563 --> 00:07:12.032
对于某一个应用
以及某一个应用开发商

00:07:12.165 --> 00:07:15.369
他们将会得到同样的字符串
即通用唯一标识符（UUID）

00:07:16.036 --> 00:07:18.205
比如 你在App Store上
下载了两款应用

00:07:18.305 --> 00:07:22.376
并且它们来自于同一个开发商
开发商就能识别出同一个UUID

00:07:22.442 --> 00:07:23.977
这能让开发工作变得简单

00:07:24.044 --> 00:07:26.947
更方便地为用户定制服务

00:07:27.281 --> 00:07:29.883
相应的 不同的应用开发商
从你设备上得到的标识符

00:07:29.950 --> 00:07:31.051
也各不相同

00:07:31.885 --> 00:07:33.921
请注意 用户拥有最终的控制权

00:07:34.087 --> 00:07:36.156
他们可以选择卸载你的应用

00:07:37.724 --> 00:07:41.828
另一个系统层面的固定标识符
是Advertising ID

00:07:42.362 --> 00:07:45.299
它只是被用来接收广告

00:07:45.766 --> 00:07:49.102
它的工作原理是
每当有应用调用这个API

00:07:49.469 --> 00:07:52.773
这台设备对应的UUID就会被生成

00:07:53.106 --> 00:07:56.410
从此以后这个UUID会是固定的数值

00:07:56.643 --> 00:08:00.480
直到用户决定重置它
或者完全取消它

00:08:01.014 --> 00:08:04.084
以上就是我们提供的几个API

00:08:04.151 --> 00:08:05.485
每一个都有不同的功能

00:08:05.586 --> 00:08:07.888
有的被用来生成标识符

00:08:08.088 --> 00:08:10.891
有的被用来识别系统固定的标识符

00:08:12.092 --> 00:08:15.495
除了系统层面的标识符
我们还会用到网络层面的标识符

00:08:15.562 --> 00:08:18.065
每当你检索无线网络
连接到一个Wi-Fi网络时

00:08:18.232 --> 00:08:22.803
你的MAC地址就被开放给所有人

00:08:22.870 --> 00:08:25.239
这可能会造成位置隐私的泄漏

00:08:25.739 --> 00:08:29.576
所以在iOS 8中我们改变了
扫描网络的工作方式

00:08:29.710 --> 00:08:33.046
我们开始使用本地管理员MAC地址

00:08:33.113 --> 00:08:35.148
随着时间推移它会自动改变

00:08:35.215 --> 00:08:38.619
这能极大地保证隐私安全

00:08:38.986 --> 00:08:41.587
因为别人很难再追踪到你了

00:08:41.922 --> 00:08:44.691
我们非常开心和骄傲
将这项技术

00:08:44.758 --> 00:08:47.160
不仅应用于iOS
同样在macOS中

00:08:48.362 --> 00:08:50.931
如果你拥有一个Wi-Fi网络
并且拥有网络测试设备

00:08:51.198 --> 00:08:53.700
我们建议你测试你的装置

00:08:53.767 --> 00:08:56.570
用iOS seeds
及macOS seeds

00:08:58.639 --> 00:09:02.109
你们一定已听说Messages应用
以及它对应用扩展的支持

00:09:02.209 --> 00:09:05.112
这是非常酷的新功能
兼有强大的隐私保密性

00:09:05.345 --> 00:09:09.316
这些应用扩展
不能读取你的信息内容

00:09:09.483 --> 00:09:12.052
它们只能看到一个随机的UUID

00:09:12.352 --> 00:09:14.655
对于不同的应用扩展

00:09:14.721 --> 00:09:18.225
在每一组对话里
UUID也会各不相同

00:09:18.859 --> 00:09:20.360
所以它的保密性非常强

00:09:21.662 --> 00:09:26.366
有时 即便你不生成或访问任何标识符

00:09:26.433 --> 00:09:29.536
只是收集一些无序的数据

00:09:29.970 --> 00:09:33.207
也会产生问题
如果你把这些数据汇总

00:09:33.373 --> 00:09:38.011
你就可能得到一个稳定的设备特征

00:09:38.078 --> 00:09:39.913
或者一个隐性的标识符

00:09:40.047 --> 00:09:42.649
一旦发生数据外泄时
这个漏洞就会被暴露出来

00:09:42.749 --> 00:09:44.618
你可能会认为数据都是匿名的

00:09:44.685 --> 00:09:46.353
但是许多研究者指出

00:09:46.420 --> 00:09:49.456
通过这个漏洞
黑客将很容易识别出数据里的用户信息

00:09:49.823 --> 00:09:51.592
你肯定不想面临这样的情况

00:09:51.658 --> 00:09:54.127
所以你应该尽少地收集用户数据

00:09:54.728 --> 00:09:56.430
我们也为此提供帮助

00:09:56.697 --> 00:09:59.466
我们创建了安全强大的沙盒

00:09:59.533 --> 00:10:03.136
保护你的应用数据安全不被第三方攻破

00:10:03.437 --> 00:10:08.041
同时防止用户身份泄漏

00:10:08.976 --> 00:10:13.113
我们开放了功能强大的API
来帮助开发应用功能

00:10:13.313 --> 00:10:17.451
实现数据保护
同时我们也限制了这些API

00:10:17.518 --> 00:10:19.319
对用户身份信息的采集

00:10:19.453 --> 00:10:22.689
举个例子
今年我们重新修订了一些API

00:10:22.756 --> 00:10:24.525
以往它们能被用作身份信息采集

00:10:24.758 --> 00:10:28.028
我们把其中有用的API属性
列入了白名单

00:10:28.095 --> 00:10:29.830
将其它可能用作身份采集的属性

00:10:29.997 --> 00:10:32.032
列入了黑名单

00:10:32.699 --> 00:10:35.235
简而言之
这些对你意味着什么呢？

00:10:36.570 --> 00:10:38.872
标识符非常有用
但是我们推荐

00:10:38.939 --> 00:10:41.842
尽可能多地使用短期标识符

00:10:42.176 --> 00:10:45.012
尽可能多地使用系统提供的API

00:10:45.078 --> 00:10:47.381
来生成以及读取标识符

00:10:47.781 --> 00:10:51.518
用户会更放心地使用你的应用

00:10:51.585 --> 00:10:53.854
并且分享他们的数据

00:10:54.788 --> 00:10:57.191
谈到数据
让我们来看一看数据收集

00:10:59.092 --> 00:11:02.429
我们每天都在向用户收集数据

00:11:02.696 --> 00:11:06.400
这对于数据驱动型的产品开发非常有用

00:11:06.767 --> 00:11:08.101
这个功能非常棒

00:11:08.368 --> 00:11:11.538
但是有一天
你可能会面临一个奇怪的问题

00:11:11.605 --> 00:11:13.807
你从用户那里得到了太多的信息

00:11:13.874 --> 00:11:16.977
你可能比他们更了解他们自己

00:11:17.344 --> 00:11:18.412
这非常奇怪

00:11:20.314 --> 00:11:21.381
所以问问自己...

00:11:22.249 --> 00:11:26.320
如果他们知道 你拥有他们的所有数据
你会怎么想？

00:11:26.987 --> 00:11:28.455
你会觉得尴尬吗？

00:11:29.089 --> 00:11:31.692
万一这些数据是关于你的父亲？

00:11:31.758 --> 00:11:33.193
你的母亲 或兄弟姐妹呢？

00:11:34.528 --> 00:11:36.763
拥有数据既是一项优势 也是一种风险

00:11:36.964 --> 00:11:38.665
你需要很好地平衡它们

00:11:38.832 --> 00:11:40.033
所以我们能做什么？

00:11:42.102 --> 00:11:44.004
我们建议你采用

00:11:44.605 --> 00:11:47.407
注重隐私保护的数据收集方法

00:11:48.075 --> 00:11:52.279
尤其要避免投机性的数据采集

00:11:52.446 --> 00:11:56.583
你可以一次性收集所有能找到的数据
因为将来你可能会使用到

00:11:56.650 --> 00:11:59.353
找出应用的关键绩效指标

00:11:59.620 --> 00:12:01.488
根据它们来收集数据

00:12:01.855 --> 00:12:05.092
以下是几个可以采用的小技巧

00:12:05.292 --> 00:12:07.895
分级收集 采样收集 聚合收集

00:12:08.996 --> 00:12:10.297
我们来看看分级收集

00:12:11.398 --> 00:12:14.635
分级收集的核心思想
就是只采集某一个等级的数据

00:12:14.701 --> 00:12:16.970
只要它能满足你的需要

00:12:18.505 --> 00:12:20.274
假如你想知道

00:12:20.340 --> 00:12:24.545
用户打开应用内设置的频率

00:12:24.845 --> 00:12:27.414
我们向某一个用户提出这个问题

00:12:28.015 --> 00:12:30.617
要实现它非常简单
你只要加入一个计数器

00:12:30.751 --> 00:12:32.653
然后查看次数

00:12:32.819 --> 00:12:37.024
假如这个测试用户 他在一天内

00:12:37.090 --> 00:12:38.725
先后86次打开了应用内设置

00:12:39.126 --> 00:12:40.694
这条信息非常有用 对吧？

00:12:40.761 --> 00:12:44.298
因为这预示着你的应用配置可能有问题

00:12:44.498 --> 00:12:47.167
你可能需要让某些设置更可见

00:12:47.835 --> 00:12:51.238
但是你真的需要收集
精确度如此高的信息吗？

00:12:51.672 --> 00:12:54.541
也许只要知道
有人进入应用内设置多过50次

00:12:54.741 --> 00:12:57.811
这样的收集会不会更有效呢？

00:12:57.878 --> 00:12:59.913
它能给你提供同样的信息

00:12:59.980 --> 00:13:01.882
也许你需要改进和提升

00:13:01.949 --> 00:13:04.084
你的应用配置

00:13:06.286 --> 00:13:07.721
如果你想知道

00:13:07.788 --> 00:13:09.723
不仅仅是一个用户

00:13:09.957 --> 00:13:11.692
而是很多用户的使用趋势

00:13:12.559 --> 00:13:15.462
你只需要向每一位用户提出这个问题

00:13:15.963 --> 00:13:20.100
在某一天内
我的用户打开应用设置的次数是多少？

00:13:21.568 --> 00:13:24.471
如果你只想知道一个平均值

00:13:24.538 --> 00:13:27.875
你根本不需要向所有用户采集数据

00:13:27.941 --> 00:13:32.446
你只要得到统计意义上的
平均估计值就足够了

00:13:32.779 --> 00:13:37.718
事实上你只需要
从0.1%的用户设备上收集数据

00:13:38.118 --> 00:13:40.621
你就能得到一个非常接近的平均值

00:13:40.921 --> 00:13:43.824
事实上
如果你只从10%的用户收集数据

00:13:44.024 --> 00:13:47.060
你的估计值就能达到0.1的精准度

00:13:47.728 --> 00:13:51.932
所以你并不需要机械地
从所有用户那里采集数据

00:13:51.999 --> 00:13:55.536
这一切只取决于你所关心的性能指标

00:13:57.571 --> 00:14:01.575
有时 若你想采集一些非常敏感的数据

00:14:02.209 --> 00:14:05.913
而数据本身是不应该被采集的

00:14:06.813 --> 00:14:09.650
可是你又非常希望了解它们
你会怎么办？

00:14:10.784 --> 00:14:13.387
你可能会需要这样一种科技

00:14:13.554 --> 00:14:18.792
它能让你从一个整体得到信息
同时保护个体的隐私安全

00:14:20.527 --> 00:14:24.031
这样的科技是存在的
我们称之为差分隐私

00:14:25.098 --> 00:14:29.603
差分隐私技术是用户捐献数据
最安全的方式之一

00:14:30.838 --> 00:14:33.507
它能帮助你从整体得到信息

00:14:33.707 --> 00:14:35.475
同时保护个体的隐私安全

00:14:36.076 --> 00:14:40.380
它提供了强大的数学算法
来保证个体的隐私安全

00:14:40.948 --> 00:14:44.318
在今年 我们将这项技术
集成到了iOS和macOS

00:14:45.452 --> 00:14:48.121
在我开始前
我想强调两件事

00:14:48.188 --> 00:14:54.094
第一 这项技术是
我们的隐私技术工具箱里的新成员

00:14:54.261 --> 00:14:56.630
我们已拥有了许多用以保护隐私的工具

00:14:56.797 --> 00:14:59.299
而它将是其中最令人兴奋
最前景广阔的一个

00:14:59.800 --> 00:15:04.304
第二 这将是一个快速的介绍
关于这项令人着迷的技术

00:15:04.371 --> 00:15:08.075
我将竭尽全力启发大家
希望你也能为之兴奋

00:15:08.775 --> 00:15:10.110
让我们开始

00:15:10.978 --> 00:15:13.714
如我之前所说
它提供了强大的数学算法保证

00:15:13.947 --> 00:15:16.116
让我们先看看一些数学定理

00:15:17.217 --> 00:15:20.921
不 我想我们可以试着
换一个角度来认识它

00:15:21.388 --> 00:15:24.124
假如你有一些敏感数据

00:15:24.525 --> 00:15:28.028
给它加入一些噪音
你就得到了一些私有化数据

00:15:28.529 --> 00:15:31.098
然后你可以聚集这些私有化数据

00:15:31.365 --> 00:15:32.566
来得到一些信号

00:15:33.500 --> 00:15:36.270
让我举一个例子
我上周花费了多少个小时

00:15:36.503 --> 00:15:37.905
来准备这些幻灯片

00:15:37.971 --> 00:15:41.041
那是一个忙碌的星期
所以假设我工作了128个小时

00:15:42.075 --> 00:15:45.145
我给它添加一些噪音
也就是说

00:15:45.212 --> 00:15:47.948
我把这个数字变成
一个完全不同的数字

00:15:48.515 --> 00:15:51.251
让我进步一解释一下
噪音在这里的含义

00:15:51.552 --> 00:15:54.988
先向大家声明 这是一个简化版的解释

00:15:55.055 --> 00:15:57.925
但是它能够描述这项技术的核心要领

00:15:58.225 --> 00:16:00.928
使用这个数字 128

00:16:01.128 --> 00:16:04.498
我们用它来生成一个投影数值
类似于哈希算法

00:16:04.798 --> 00:16:08.335
要生成这个数值
我需引入一个所有位置全部为0的矢量

00:16:08.602 --> 00:16:11.839
只把第128号位置标注为1

00:16:12.439 --> 00:16:15.475
这样它就变成了只有一个1
其余全是0的大型矢量

00:16:16.977 --> 00:16:19.847
要给它添加噪音
也就是切换矢量的

00:16:19.913 --> 00:16:21.982
某些位置上的数值

00:16:22.115 --> 00:16:24.251
一些0会变成1

00:16:24.351 --> 00:16:26.320
一些1会变成0

00:16:26.854 --> 00:16:31.959
最关键的一点是
0保持不变的概率

00:16:32.025 --> 00:16:34.361
只稍微大于它变成1的概率

00:16:34.862 --> 00:16:37.764
1保持不变的概率

00:16:37.831 --> 00:16:39.833
也只稍微大于它变成0的概率

00:16:40.534 --> 00:16:43.604
这就是模糊化处理数据的一种方式

00:16:43.871 --> 00:16:45.839
在将它分享给Apple之前完成

00:16:46.540 --> 00:16:49.643
这里还有另外一个有趣的发现

00:16:49.977 --> 00:16:52.379
如果我对数据进行两次模糊化处理

00:16:52.479 --> 00:16:54.181
即使是相同的数字

00:16:54.314 --> 00:16:56.717
每一次处理过后我会得到不同的数字

00:16:57.584 --> 00:16:59.653
不同于典型的哈希算法

00:16:59.720 --> 00:17:01.989
我无法使用字典攻击

00:17:02.122 --> 00:17:04.790
来破译它对应的数值

00:17:05.626 --> 00:17:08.328
这一切都在设备本地完成

00:17:10.797 --> 00:17:15.002
在你的数据被分享给Apple前完成

00:17:15.469 --> 00:17:17.604
另一个例子 如果我想知道

00:17:17.738 --> 00:17:20.507
Apple员工上周的工作时长

00:17:20.941 --> 00:17:25.612
我工作了128小时 Jessie工作了48小时
Timmy工作了130小时

00:17:26.280 --> 00:17:29.082
这些数据都收集自Apple员工

00:17:29.416 --> 00:17:31.385
然后噪音被添加到这些数据上

00:17:31.518 --> 00:17:36.623
最后 Apple收集到的
是一大堆二进制的噪音矢量

00:17:36.823 --> 00:17:40.227
每个单独的矢量对于我们都毫无意义

00:17:40.594 --> 00:17:44.698
但是如果把它们加在一起
清除它们的噪音

00:17:44.765 --> 00:17:47.201
我们最后会得到一些特征的统计结果

00:17:47.434 --> 00:17:48.702
比如说在这里

00:17:48.769 --> 00:17:52.372
Apple员工上周的
平均工作时长为41个小时

00:17:53.040 --> 00:17:56.810
我们先计算矢量和

00:17:56.877 --> 00:17:58.178
再使结果标准化

00:17:58.378 --> 00:18:00.080
接着观察矢量的每一列

00:18:00.147 --> 00:18:02.749
寻找统计意义上的显著值

00:18:02.916 --> 00:18:04.318
看它是否大于随机数

00:18:05.419 --> 00:18:06.553
为什么这项技术很酷？

00:18:08.088 --> 00:18:10.090
因为它为我们提供了一种途径

00:18:10.157 --> 00:18:12.659
安全地得到整体性的答案

00:18:12.993 --> 00:18:16.430
有了它 你可以计算平均值
判断某种特征属性是否存在

00:18:16.797 --> 00:18:19.433
甚至绘制频率直方图

00:18:19.933 --> 00:18:21.335
这种方法能够保证

00:18:21.401 --> 00:18:24.538
个体的隐私被充分尊重

00:18:24.605 --> 00:18:26.006
即使Apple也不例外

00:18:26.106 --> 00:18:28.141
我们只能从聚合的数据中得到结果

00:18:29.343 --> 00:18:30.978
可是你也许会问

00:18:31.445 --> 00:18:36.149
万一我是唯一一个贡献数据的人呢？

00:18:37.251 --> 00:18:40.621
有时候可能一个用户会成为唯一的聚合者

00:18:41.355 --> 00:18:45.292
为了回避这个问题
我们引入了“隐私预算”概念

00:18:45.359 --> 00:18:47.561
它限制了某台设备

00:18:47.628 --> 00:18:51.398
在单位时间内的数据捐献次数

00:18:51.899 --> 00:18:56.303
这些信息也不会绑定任何一个标识符

00:18:56.503 --> 00:18:59.072
之后我们也会从服务器上
永久删除这些数据

00:18:59.740 --> 00:19:01.408
我们来看一看这个例子

00:19:01.642 --> 00:19:04.411
假如我们想了解表情符号的使用情况

00:19:04.711 --> 00:19:08.916
我们需要从愿意分享
“诊断与使用”数据

00:19:08.982 --> 00:19:10.484
的用户那里收集数据

00:19:11.318 --> 00:19:14.655
当用户开始使用键盘输入表情符号

00:19:14.721 --> 00:19:16.723
数据被记录在本地设备上

00:19:16.924 --> 00:19:19.693
接着Julien Jessie
和Timmy

00:19:19.860 --> 00:19:22.029
分享了各自的数据
且在设备本地添加了噪音

00:19:22.162 --> 00:19:24.464
在上传给Apple之前

00:19:24.698 --> 00:19:27.734
随着越来越多的人分享数据

00:19:27.935 --> 00:19:29.837
我们可以得到各类信息

00:19:29.903 --> 00:19:31.772
比如哪些表情符号是最受欢迎的

00:19:32.806 --> 00:19:35.442
我们可以使用这个信息

00:19:35.509 --> 00:19:37.110
相应调整它们在用户界面的顺序

00:19:37.177 --> 00:19:40.214
也能更准确地预测用户的使用习惯

00:19:40.881 --> 00:19:43.383
今年我们将把这项技术

00:19:43.617 --> 00:19:45.352
主要应用到四个用例里

00:19:45.552 --> 00:19:48.121
用它来收集表情符号数据

00:19:48.722 --> 00:19:50.691
用它来收集新造词

00:19:50.757 --> 00:19:54.094
我们能学到本地字典里
没有的新词 比如俚语

00:19:54.161 --> 00:19:56.797
我们还用它来收集深层链接数据

00:19:56.864 --> 00:19:58.866
查看哪些深层链接在应用里最受欢迎

00:19:58.932 --> 00:20:02.903
让它们在Spotlight
以及Lookup Hints中推广

00:20:04.771 --> 00:20:06.106
这让人非常兴奋

00:20:06.273 --> 00:20:10.010
并且我们保证在采集数据时
不侵犯用户隐私

00:20:10.677 --> 00:20:12.579
数据的收集对象仅限于

00:20:12.646 --> 00:20:15.282
开启了“诊断与使用”选项的用户

00:20:15.516 --> 00:20:18.185
如果你没有开启它

00:20:18.252 --> 00:20:20.254
我们就不会从你那里收集数据

00:20:20.320 --> 00:20:21.855
你拥有决定权

00:20:23.123 --> 00:20:25.192
这项技术对你有何意义呢？

00:20:25.626 --> 00:20:29.096
我们认为差分隐私是
一种前景非常广阔的

00:20:29.162 --> 00:20:31.899
注重隐私保护的数据收集技术

00:20:32.399 --> 00:20:35.869
我们很高兴能在今年把它集成到
iOS和macOS上

00:20:35.936 --> 00:20:39.673
从整体的角度收集数据
同时不侵犯个体隐私

00:20:40.340 --> 00:20:41.708
我们不使用任何标识符

00:20:42.009 --> 00:20:44.011
我们不收集任何原始数据

00:20:46.380 --> 00:20:50.184
这就是我们隐私保护工具箱里的
另外一个成员

00:20:50.284 --> 00:20:52.553
我们希望它能被越来越多地使用

00:20:52.686 --> 00:20:54.922
来开发新的功能

00:20:56.190 --> 00:20:58.625
你们的用户会看到我们的努力

00:20:58.825 --> 00:21:01.795
我们竭尽所能

00:21:01.929 --> 00:21:03.864
保护他们隐私的决心

00:21:04.097 --> 00:21:06.099
我们希望这能鼓励你和我们一起

00:21:06.166 --> 00:21:08.936
采用这些尊重隐私的开发准则

00:21:09.970 --> 00:21:12.573
接下来我们将介绍
隐私的透明度和控制权

00:21:12.840 --> 00:21:15.275
我想邀请Jessie上台

00:21:15.375 --> 00:21:16.276
谢谢

00:21:17.010 --> 00:21:18.645
大家好 我叫Jessie

00:21:18.712 --> 00:21:20.781
我也来自隐私工程团队

00:21:20.848 --> 00:21:23.250
我负责以下产品隐私安全
如Apple Music

00:21:23.650 --> 00:21:25.152
Photos和教育类产品

00:21:26.553 --> 00:21:28.188
Julien给我们详细介绍了

00:21:28.255 --> 00:21:30.824
如何识别用户身份

00:21:30.891 --> 00:21:32.826
以及收集必要的数据

00:21:33.160 --> 00:21:35.996
来开发强大的功能
同时尊重用户隐私

00:21:36.463 --> 00:21:40.133
除此以外 数据收集过程的透明
也非常重要

00:21:40.200 --> 00:21:42.669
让用户了解他们被收集的数据

00:21:43.337 --> 00:21:45.339
当你这样做时
用户会更加了解

00:21:45.405 --> 00:21:47.641
自己隐私的控制权

00:21:48.208 --> 00:21:50.244
只要用户对他们隐私安全有信心

00:21:50.310 --> 00:21:51.812
你就赢得了他们的信任

00:21:52.813 --> 00:21:55.215
他们会更放心地使用你的应用

00:21:55.782 --> 00:21:58.385
其中一个提高用户隐私透明度
增加控制权的例子

00:21:58.452 --> 00:22:00.587
是iOS 10中的广告推送服务

00:22:02.089 --> 00:22:04.558
在News和App Store里

00:22:04.825 --> 00:22:08.529
用户可以看见这个蓝色的广告按钮

00:22:09.129 --> 00:22:10.097
当用户点击它时

00:22:10.163 --> 00:22:13.133
他们就能知道
这条广告为什么会被推送给自己

00:22:13.567 --> 00:22:16.270
所以当任何开发者购买广告服务时

00:22:16.336 --> 00:22:19.072
可以选择特定的目标用户群

00:22:19.139 --> 00:22:20.741
来投放广告

00:22:21.241 --> 00:22:23.911
同样的 用户现在也能通过广告信息

00:22:24.044 --> 00:22:26.513
清楚地知道自己所在的

00:22:26.914 --> 00:22:28.782
广告用户组

00:22:30.017 --> 00:22:34.121
除此以外 用户还能进入隐私设置

00:22:36.190 --> 00:22:38.025
广告

00:22:39.159 --> 00:22:40.761
查看广告信息

00:22:41.261 --> 00:22:44.097
我们对用户完全透明

00:22:44.231 --> 00:22:46.233
让用户知道我们正在收集哪些数据

00:22:46.300 --> 00:22:49.403
服务于News和App Store

00:22:49.703 --> 00:22:51.772
这个功能将会在接下来推出

00:22:52.840 --> 00:22:56.009
在广告服务中
我们为用户提供隐私控制权

00:22:56.276 --> 00:22:57.911
是通过限制广告追踪的方式完成

00:22:58.846 --> 00:23:00.247
正如Julien提到的

00:23:00.314 --> 00:23:02.282
用户拥有专门的广告标识符

00:23:02.482 --> 00:23:04.318
你可以使用它来追踪用户

00:23:04.384 --> 00:23:06.653
在我们平台上投放广告

00:23:08.121 --> 00:23:10.858
当用户打开限制广告追踪选项

00:23:11.091 --> 00:23:12.259
其实是在告诉我们

00:23:12.326 --> 00:23:15.062
他们不想被广告追踪

00:23:15.529 --> 00:23:17.898
因此在iOS 10中
我们在此基础上更进一步

00:23:18.198 --> 00:23:20.400
当用户开启了限制广告追踪

00:23:20.801 --> 00:23:24.404
广告标识符变成
一个全部为0的UUID

00:23:25.506 --> 00:23:27.441
我们从代码等级实现了这一功能

00:23:27.541 --> 00:23:29.643
一旦用户开启了广告追踪限制

00:23:29.776 --> 00:23:32.279
他们就再也不能
通过广告标识符被追踪到

00:23:33.380 --> 00:23:35.883
如果用户取消了广告追踪限制

00:23:36.216 --> 00:23:39.386
你的应用就能访问一个新的随机标识符

00:23:41.688 --> 00:23:44.825
你也许会问
对于开启了追踪限制的用户

00:23:44.892 --> 00:23:46.560
我还能给他们投放广告吗？

00:23:47.027 --> 00:23:48.161
当然可以

00:23:48.228 --> 00:23:50.197
你可以在应用里显示文意广告

00:23:50.430 --> 00:23:52.232
根据应用内容的上下文来投放广告

00:23:52.733 --> 00:23:55.536
你只是不能再追踪广告用户

00:23:55.602 --> 00:23:57.337
如果他们开启了广告追踪限制

00:23:58.038 --> 00:23:59.806
请注意 我们禁止缓存广告标识符

00:23:59.940 --> 00:24:02.743
到用户的应用的存储里

00:24:02.809 --> 00:24:05.646
因为这会给用户重置标识符带来麻烦

00:24:07.381 --> 00:24:09.183
所以 这一切对你有什么意义？

00:24:09.449 --> 00:24:12.719
我们提升了广告服务的隐私透明度

00:24:12.786 --> 00:24:15.756
让用户更放心地使用
News和App Store

00:24:16.256 --> 00:24:19.193
我们从代码等级开始支持
广告追踪限制

00:24:20.494 --> 00:24:23.397
当用户能够使用这些隐私保护选项

00:24:23.463 --> 00:24:25.232
比如广告追踪限制

00:24:26.033 --> 00:24:29.803
这能帮助他们作出正确的
隐私保护选择

00:24:30.604 --> 00:24:33.006
我们还为用户提供另外一种方式

00:24:33.073 --> 00:24:36.243
来进行隐私保护设置
就是同意警报

00:24:37.945 --> 00:24:41.215
所以在iOS macOS tvOS
以及watchOS里

00:24:41.515 --> 00:24:44.184
用户有权决定哪些应用可以访问

00:24:44.251 --> 00:24:45.953
某一类受保护的数据

00:24:46.854 --> 00:24:49.656
受保护数据包括日历

00:24:50.090 --> 00:24:52.960
联系人 照片 HomeKit

00:24:54.494 --> 00:24:56.797
当你的应用第一次请求访问时

00:24:56.864 --> 00:24:59.066
需要通过调用API来完成

00:24:59.466 --> 00:25:01.401
iOS会显示这样的警告

00:25:01.668 --> 00:25:03.937
这时用户有权决定

00:25:04.171 --> 00:25:06.473
是否授予应用访问权限

00:25:08.108 --> 00:25:11.545
当时机和情境都正确时

00:25:12.312 --> 00:25:14.581
用户就能做出他们认为正确的选择

00:25:14.715 --> 00:25:16.416
我们称这个为
及时警告

00:25:18.519 --> 00:25:21.255
我还想给大家介绍一下
今年我们推出的新特性

00:25:21.321 --> 00:25:24.758
它们也都拥有隐私设置
和同意警报功能

00:25:25.259 --> 00:25:28.462
首先是媒体库隐私设置

00:25:28.862 --> 00:25:31.465
它可授权开发者读取
Apple Music用户账户状态

00:25:33.100 --> 00:25:34.735
读取用户的商店首页信息

00:25:36.270 --> 00:25:37.971
向播放列表添加内容

00:25:39.339 --> 00:25:41.108
以及读取用户的媒体库

00:25:42.976 --> 00:25:45.546
我们理解
用户的媒体库数据和

00:25:45.646 --> 00:25:47.414
Apple Music账户信息

00:25:47.481 --> 00:25:50.217
都是非常私人的信息

00:25:50.317 --> 00:25:52.352
所以我们希望用户拥有决定权

00:25:52.419 --> 00:25:54.421
哪些应用能够访问这些信息
哪些不能

00:25:55.189 --> 00:25:59.059
现在如果你的应用
已可在iOS 9.3里访问媒体库

00:25:59.226 --> 00:26:01.595
在iOS 10中你可以继续访问

00:26:02.663 --> 00:26:04.665
所以如何知道你是否已有访问权限了？

00:26:05.699 --> 00:26:08.168
对于大多数的受保护类数据

00:26:08.235 --> 00:26:11.238
我们拥有一个授权状态API

00:26:11.305 --> 00:26:14.508
对于不同类型的数据
API的名字可能会有所不同

00:26:14.575 --> 00:26:16.810
以媒体库为例

00:26:17.144 --> 00:26:18.912
你可以调用这个API

00:26:19.413 --> 00:26:21.248
然后得到这样一个enum数值

00:26:22.549 --> 00:26:24.151
若是notDetermined

00:26:24.218 --> 00:26:26.153
两个原因会造成这种情况

00:26:26.320 --> 00:26:28.522
一 你还没有请求用户授权

00:26:29.089 --> 00:26:32.726
或者二 你已经请求访问受保护数据了

00:26:32.926 --> 00:26:35.796
随后用户重置了隐私设置

00:26:37.030 --> 00:26:38.732
如果你看到denied

00:26:39.032 --> 00:26:41.268
这表示用户“不允许”

00:26:41.602 --> 00:26:45.072
他们不允许
你的应用访问某类受保护数据

00:26:45.172 --> 00:26:47.074
这时你有几个选择

00:26:47.174 --> 00:26:49.643
你能相应地调整应用的使用方式

00:26:49.710 --> 00:26:51.778
让用户能够使用一部分功能

00:26:52.212 --> 00:26:55.115
而不需要开放他们的数据

00:26:55.282 --> 00:26:58.719
或者 你可以打开应用的隐私设置

00:26:58.952 --> 00:27:01.588
也许这一次用户会做出不同的决定

00:27:01.655 --> 00:27:03.056
如果他们愿意的话

00:27:04.224 --> 00:27:05.859
若你看到restricted

00:27:05.926 --> 00:27:07.761
可能是由于这两个原因

00:27:07.995 --> 00:27:11.365
一 这台设备设有家长控制

00:27:11.532 --> 00:27:14.701
限制了应用程序对这类保护数据的访问

00:27:15.068 --> 00:27:17.538
或者 二
这个应用被管制了

00:27:17.604 --> 00:27:21.308
也许它处于教育模式
或者企业模式

00:27:21.475 --> 00:27:24.311
设备管理员规定了你的应用程序

00:27:24.378 --> 00:27:25.979
不能访问这类受保护数据

00:27:27.014 --> 00:27:29.650
当然若你看到authorized
代表你的应用程序已被授权

00:27:31.318 --> 00:27:33.153
此外 我们还推出了
其他非常棒的新特性

00:27:33.220 --> 00:27:35.155
它们也支持隐私设置

00:27:35.589 --> 00:27:37.191
另一个例子是语音识别

00:27:37.858 --> 00:27:41.361
你可以选择是否允许
录制的语音被上传给Apple

00:27:41.428 --> 00:27:43.230
然后被转录成文字

00:27:43.931 --> 00:27:45.899
为什么我们让用户选择

00:27:45.966 --> 00:27:48.402
哪些应用可以访问语音识别
哪些应用不可以

00:27:48.569 --> 00:27:50.204
因为我们想让用户知道

00:27:50.270 --> 00:27:51.905
一旦他们授权了访问

00:27:52.072 --> 00:27:54.341
他们的语音文件

00:27:54.408 --> 00:27:56.677
会被上传给Apple并转录成文字

00:27:57.845 --> 00:28:01.648
确保你使用这个API时
提前获取授权

00:28:02.583 --> 00:28:04.084
我们还推出了SiriKit

00:28:04.585 --> 00:28:05.919
这非常令人兴奋

00:28:06.019 --> 00:28:08.455
用户现在可以直接使用Siri

00:28:08.622 --> 00:28:10.991
控制应用程序

00:28:13.093 --> 00:28:17.297
但是为了使Siri懂得
用户具体的操控请求

00:28:17.364 --> 00:28:20.133
你的应用必须
首先发送使用情境信息给Siri

00:28:20.200 --> 00:28:22.769
包括用户个人信息以及应用程序信息

00:28:23.270 --> 00:28:25.339
我们希望给予用户决定权

00:28:25.405 --> 00:28:28.075
哪些应用可发送情境信息给Siri

00:28:28.141 --> 00:28:29.610
以及哪些不可以

00:28:31.411 --> 00:28:33.714
所以你必须事先向用户请求这项权限

00:28:33.780 --> 00:28:35.849
Siri才会响应用户的操作

00:28:36.617 --> 00:28:39.753
这项授权可以通过
requestSiriAuthorization API完成

00:28:41.188 --> 00:28:44.825
你也许已经听说了
全新的TV单点登录功能

00:28:45.826 --> 00:28:48.262
它允许特定的电视应用

00:28:48.695 --> 00:28:51.331
访问用户的订阅状态信息

00:28:51.398 --> 00:28:53.500
然后将他们自动登录进应用程序里

00:28:54.735 --> 00:28:57.104
目前这项功能只开放给特定的电视应用

00:28:57.204 --> 00:28:59.106
请咨询我们的WWDR客户经理

00:28:59.173 --> 00:29:01.642
如果你也想为应用开通此项功能

00:29:03.043 --> 00:29:07.314
你们喜爱的iOS版Photos应用
其一切特性现都移植到tvOS上了

00:29:07.714 --> 00:29:09.216
同样的还有HomeKit

00:29:09.449 --> 00:29:13.287
它们在tvOS上的
应用都拥有隐私设置

00:29:14.521 --> 00:29:16.924
除了这些强大的新功能外

00:29:17.157 --> 00:29:20.327
我们还更新了你的应用

00:29:20.394 --> 00:29:22.262
请求权限的方式

00:29:23.830 --> 00:29:28.135
2014年我们开始要求所有应用程序
向用户请求使用位置信息时

00:29:28.202 --> 00:29:30.737
必须提前申请

00:29:30.804 --> 00:29:32.639
并说明使用位置信息的原因

00:29:32.973 --> 00:29:34.575
我们发现这对用户很有用

00:29:34.641 --> 00:29:36.343
他们能做出更加正确的选择

00:29:36.410 --> 00:29:39.680
如果他们理解位置信息被使用的原因

00:29:41.682 --> 00:29:46.253
所以在iOS 10中我们把这项服务
延伸到了所有类型的受保护数据

00:29:47.654 --> 00:29:51.024
当你的应用程序试图访问
任一保护类数据

00:29:51.091 --> 00:29:52.993
你需要在plist里提前声明

00:29:53.060 --> 00:29:57.130
并附带明确的使用原因

00:29:58.432 --> 00:30:00.567
让我们看一看这个列表

00:30:01.435 --> 00:30:04.771
回想一下我的应用有没有使用到
这里的任意一类数据？

00:30:05.739 --> 00:30:07.774
都有谁的应用使用到了一种数据？

00:30:08.141 --> 00:30:10.010
好的 两类或者三类的呢？

00:30:11.144 --> 00:30:13.547
好的 你将需要提前声明

00:30:13.614 --> 00:30:15.649
在应用的info plist里面

00:30:15.916 --> 00:30:19.520
如果你是tvOS开发者
这四类受保护数据

00:30:19.586 --> 00:30:21.688
可以在tvOS上被申请访问了

00:30:21.755 --> 00:30:25.425
你也需在应用info plist上
提前声明

00:30:25.993 --> 00:30:30.631
现在 我将快速介绍
目的字符串里的

00:30:30.764 --> 00:30:33.567
关键值和关键名
它们需在应用info plist里提前声明

00:30:33.834 --> 00:30:35.602
你们不需要现在就把它们记下来

00:30:35.669 --> 00:30:39.139
它们会在开发文档和
Xcode上开放给大家

00:30:42.042 --> 00:30:46.079
我们来假设
你想编写一个迪斯科灯光的应用

00:30:46.813 --> 00:30:49.550
用户第一次下载后

00:30:49.616 --> 00:30:52.886
会浏览不同的特性 了解其功能

00:30:53.053 --> 00:30:56.757
当他们添加第一个迪斯科灯的时候

00:30:56.823 --> 00:31:00.861
你的应用会请求
HomeKit的访问权限

00:31:02.196 --> 00:31:05.199
当时间和情境都正确的时候

00:31:05.265 --> 00:31:07.434
用户看到同意警报
出现在屏幕上

00:31:07.701 --> 00:31:10.337
此时此刻 你将需要给用户展示一条

00:31:10.404 --> 00:31:13.073
目的清晰 意义明确的目的字符串
在同意警报里面

00:31:15.242 --> 00:31:17.244
我将给你展示 如何简单地

00:31:17.311 --> 00:31:18.912
使用Xcode添加
目的字符串

00:31:20.814 --> 00:31:22.950
去到应用的target选项

00:31:23.717 --> 00:31:25.118
Info部分

00:31:26.019 --> 00:31:28.989
自定义iOS目标属性

00:31:29.857 --> 00:31:31.124
添加新键

00:31:31.625 --> 00:31:33.393
在这个例子中我们选择

00:31:33.794 --> 00:31:36.296
隐私HomeKit使用描述

00:31:38.665 --> 00:31:41.668
输入一条意义明确的
目的字符串

00:31:41.735 --> 00:31:42.903
让我们输入...

00:31:42.970 --> 00:31:45.939
这将允许你使用HomeKit
来添加迪斯科灯光

00:31:47.007 --> 00:31:49.243
时间和情境都正确

00:31:49.576 --> 00:31:52.379
用户知道为什么我们需要
HomeKit的使用权限

00:31:52.446 --> 00:31:55.449
他们更可能做出对于他们而言正确的选择

00:31:56.316 --> 00:31:58.085
如果你不提前声明

00:31:58.151 --> 00:32:00.821
你的应用会怎样呢？

00:32:02.189 --> 00:32:03.757
你的应用程序会崩溃

00:32:04.625 --> 00:32:06.493
因此 为了保护隐私安全

00:32:06.994 --> 00:32:09.963
任何为iOS 10或其以上版本
开发的应用

00:32:10.697 --> 00:32:14.134
在请求某类数据的访问权限之前

00:32:14.201 --> 00:32:17.771
必须先在info plist里
提前声明

00:32:18.505 --> 00:32:21.241
如果不这样做
应用程序将会自动退出

00:32:21.475 --> 00:32:24.111
你的用户会看到应用程序自动关闭

00:32:24.444 --> 00:32:27.681
在Xcode你能看到这样的报错

00:32:28.148 --> 00:32:31.485
它将指出应用请求访问
数据的具体类型

00:32:31.552 --> 00:32:33.720
及你要在info plist里
添加的具体key

00:32:34.555 --> 00:32:36.523
我们让你的应用崩溃的原因

00:32:36.590 --> 00:32:39.126
是为了防止你的应用被攻破时

00:32:39.393 --> 00:32:43.397
第三方访问你没有
请求过权限的保护数据

00:32:43.730 --> 00:32:46.233
我们不希望你的应用

00:32:46.300 --> 00:32:48.202
访问任何未授权的保护数据

00:32:49.536 --> 00:32:52.206
请记住 你必须为应用里的

00:32:52.272 --> 00:32:55.275
所有用到的第三方库负责

00:32:55.442 --> 00:32:57.945
当你选择这些第三方库时

00:32:58.345 --> 00:33:00.614
请保证它不侵犯用户隐私

00:33:02.115 --> 00:33:03.984
所以这一切对你都意味着什么呢？

00:33:05.085 --> 00:33:08.822
在iOS 10和tvOS中
有一些强大的新特性

00:33:09.790 --> 00:33:11.692
他们都拥有隐私设置

00:33:12.326 --> 00:33:13.894
你需要提前声明

00:33:13.961 --> 00:33:16.730
请求读取受保护数据

00:33:16.797 --> 00:33:18.732
在应用的info plist里

00:33:19.199 --> 00:33:21.401
拥有一个清晰并明确的
目的字符串 

00:33:21.468 --> 00:33:23.937
将会帮助用户做出更好的决定

00:33:25.138 --> 00:33:27.007
除了这些强大的新功能

00:33:27.074 --> 00:33:31.278
我们对现有的框架也做了一些更改

00:33:31.345 --> 00:33:34.615
来帮助你从头打造应用的隐私保护

00:33:36.149 --> 00:33:38.685
首先 我想介绍一下
pasteboard的更改

00:33:40.787 --> 00:33:44.424
现你可设定一个过期时限
和localOnly变量

00:33:44.558 --> 00:33:46.527
给每个pasteboard上的条目

00:33:47.961 --> 00:33:50.130
设置过期时限

00:33:50.197 --> 00:33:52.533
会让pasteboard上的
信息条目

00:33:52.733 --> 00:33:54.735
在超过期限那天被移除

00:33:55.903 --> 00:33:57.771
而设定localOnly为真

00:33:57.838 --> 00:34:00.474
将会使相应的信息条目
从全局剪切板中被移除

00:34:01.675 --> 00:34:03.177
现在来看个例子

00:34:04.444 --> 00:34:06.380
这个例子中
我们有一个UIImage

00:34:06.780 --> 00:34:08.315
将把它放进pasteboard中

00:34:08.382 --> 00:34:10.083
和它一起的还有一条字符串
“Hello, world.”

00:34:12.652 --> 00:34:16.255
我们将会把过期时限
设置为120秒后

00:34:17.324 --> 00:34:19.760
并且我们将把localOnly值
设置为真

00:34:19.927 --> 00:34:22.262
所以 两分钟后这些信息

00:34:22.329 --> 00:34:23.664
将不会在pasteboard中
被找到

00:34:23.764 --> 00:34:28.302
并且这些信息也不能
从全局剪切板中被复制

00:34:29.536 --> 00:34:31.371
为什么要这么做呢

00:34:31.438 --> 00:34:32.873
你需要了解一个事实

00:34:33.106 --> 00:34:35.509
当用户在复制一些十分敏感的信息时

00:34:35.576 --> 00:34:40.013
比如说密码 电话号码 或者邮箱地址

00:34:40.112 --> 00:34:42.916
它们不应该长时间存在于剪切板上

00:34:42.983 --> 00:34:44.751
那么就设定过期时限

00:34:45.418 --> 00:34:47.754
如果你觉得这些复制的信息

00:34:47.821 --> 00:34:49.556
不应该被用在全局剪切板上

00:34:50.157 --> 00:34:51.757
就设定localOnly为真

00:34:53.893 --> 00:34:56.230
我们也对pasteboard
做了一些更改

00:34:56.463 --> 00:35:00.234
首先 所有已经被命名的剪切板
会被默认更改为非持久的

00:35:00.634 --> 00:35:03.070
将剪切板设为“持久”

00:35:03.270 --> 00:35:05.105
将会触发一个弃用警告

00:35:05.973 --> 00:35:07.007
此外

00:35:07.074 --> 00:35:09.343
调用
Find pasteboard函数

00:35:09.409 --> 00:35:11.445
将会得到一个空白对象

00:35:12.746 --> 00:35:14.147
我们强烈推荐大家使用

00:35:14.214 --> 00:35:16.850
shared containers
而非pasteboard

00:35:16.917 --> 00:35:19.253
当你想在同一设备的不同应用中

00:35:19.319 --> 00:35:22.022
共享信息的时候

00:35:22.356 --> 00:35:23.891
这将会是更安全的做法

00:35:23.957 --> 00:35:25.826
相对于pasteboard来说

00:35:27.561 --> 00:35:30.397
我相信你们的应用程序很多都集成了
Core Spotlight框架

00:35:30.464 --> 00:35:33.166
所以这里还有几点需要大家注意

00:35:33.233 --> 00:35:35.936
尤其在集成Core
Spotlight框架过程中

00:35:36.270 --> 00:35:38.772
首先需要确保
用户的每一个点击动作

00:35:38.839 --> 00:35:40.908
不会导致
NSUserActivity被触发

00:35:41.341 --> 00:35:43.544
你绝不会想让你的系统呈现出

00:35:43.610 --> 00:35:45.512
一系列的用户并不明白的事件

00:35:45.579 --> 00:35:48.749
相反的 只触发那些真正有意义的
并且用户会回去再看的事件

00:35:50.250 --> 00:35:53.520
并且 当用户数据十分敏感时

00:35:53.720 --> 00:35:56.123
不要设定eligibleFor
PublicIndexing为真

00:35:59.560 --> 00:36:03.330
你肯定还知道 在iOS 10中
我们新支持的微件

00:36:03.931 --> 00:36:05.465
当用户开启一个微件时

00:36:05.799 --> 00:36:09.436
它会在主页面和锁屏页面同时显示

00:36:10.170 --> 00:36:13.607
正是因为这样 我想推荐一些最佳做法

00:36:13.674 --> 00:36:16.143
来提醒你们
在创建自己的微件时

00:36:16.210 --> 00:36:19.146
谨记它们也在会显示在锁屏界面

00:36:19.646 --> 00:36:22.115
首先你需要评估

00:36:22.182 --> 00:36:24.251
那些将被放入微件
的数据敏感性

00:36:24.351 --> 00:36:27.254
若你觉得这些数据不适合出现在锁屏上

00:36:27.621 --> 00:36:30.490
那就不要放入微件
或者想办法

00:36:30.724 --> 00:36:32.092
不让它出现在锁屏上

00:36:33.293 --> 00:36:35.829
确保这些数据是连贯的并且可预测的

00:36:36.163 --> 00:36:37.831
当我今天开启你的微件

00:36:38.632 --> 00:36:40.801
我明天是不是还能看到类似的内容？

00:36:41.368 --> 00:36:43.103
一个月过后呢？

00:36:44.805 --> 00:36:47.007
每天呈现不同的数据其实是可行的

00:36:47.074 --> 00:36:50.110
不过我需要了解什么类型的
数据适合展示在那里

00:36:51.011 --> 00:36:54.147
并且请记住那些属性为
FileProtectionType.complete的数据

00:36:54.314 --> 00:36:56.250
不能在锁屏时出现

00:36:58.118 --> 00:37:00.554
接下来让我展示一个实例

00:37:00.621 --> 00:37:02.523
一个查看好友位置的微件

00:37:02.956 --> 00:37:05.826
在锁屏的时候 位置信息是不可用的

00:37:05.926 --> 00:37:08.929
因为我们知道你朋友们的
位置信息是极其敏感的

00:37:08.996 --> 00:37:11.198
它们不应该出在锁屏界面

00:37:11.465 --> 00:37:14.401
因此我们显示了一条提醒
解锁以查看位置信息

00:37:14.701 --> 00:37:16.403
并且位置信息并不在其中

00:37:16.637 --> 00:37:20.507
当我用touch ID去解锁设备时
位置信息才可见

00:37:21.909 --> 00:37:23.510
我们推荐这种做法

00:37:23.577 --> 00:37:26.847
尤其当你觉得微件的信息
很敏感时

00:37:31.185 --> 00:37:34.388
今天 Julien和我介绍了
很多方面的内容

00:37:35.022 --> 00:37:37.257
一开始 我们介绍了标识符

00:37:37.524 --> 00:37:40.160
它是进行用户识别的最根本依据

00:37:40.394 --> 00:37:41.528
在应用程序中

00:37:41.595 --> 00:37:43.997
并且你应该更多地使用短期标识符

00:37:44.064 --> 00:37:46.133
和系统API提供的标识符

00:37:47.134 --> 00:37:50.237
然后我们介绍了

00:37:50.304 --> 00:37:52.472
当你在收集用户数据的时候

00:37:52.806 --> 00:37:56.510
你应该通过一种更尊重隐私的方式
比如分级收集或者采样收集

00:37:56.777 --> 00:37:59.446
或者应用新的技术
比如差分隐私

00:38:00.848 --> 00:38:04.218
给用户提供更高的透明度
以及更多的控制权

00:38:04.284 --> 00:38:06.920
来管理标识符和数据的分享

00:38:06.987 --> 00:38:10.257
你将取得他们的信任
并鼓励他们放心使用你的应用

00:38:12.359 --> 00:38:15.762
当你让用户决定
自己的隐私设置的时候

00:38:15.829 --> 00:38:19.867
这会促使他们作出
对自己更有利的决定

00:38:20.901 --> 00:38:22.903
我们还展示了一些特别棒的新特性

00:38:22.970 --> 00:38:25.005
及一些非常棒的工具
帮助你为自己应用

00:38:25.072 --> 00:38:27.341
从头打造隐私保护

00:38:28.742 --> 00:38:31.645
想要了解更多的详情
请浏览这个网址

00:38:32.613 --> 00:38:35.682
这里还有一些本周相关演讲
你也许会感兴趣

00:38:35.849 --> 00:38:36.717
谢谢