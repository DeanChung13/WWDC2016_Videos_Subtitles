00:00:19.853 --> 00:00:24.291 
Swift的新特性

00:00:24.992 --> 00:00:25.826 
早上好

00:00:29.730 --> 00:00:32.198 
欢迎来到“Swift的新特性”

00:00:33.200 --> 00:00:37.171 
先说一下Swift 3的发布目标

00:00:37.938 --> 00:00:40.440 
Swift作为开源工程发布

00:00:40.507 --> 00:00:41.708 
六个月前

00:00:42.276 --> 00:00:45.979 
这么做的重要原因不只是为了

00:00:46.046 --> 00:00:46.980 
把代码推到GitHub上

00:00:47.314 --> 00:00:49.850 
更是为了创建一个开放的社区

00:00:50.184 --> 00:00:53.253 
来推动Swift向前发展

00:00:53.987 --> 00:00:57.191 
Swift 3是Swift的
第一个重要更新

00:00:57.257 --> 00:01:00.994 
作为社区的产品

00:01:01.361 --> 00:01:04.263 
我们谈一下社区的演进

00:01:04.331 --> 00:01:08.435 
和这个语言的演进过程

00:01:08.602 --> 00:01:09.837 
Chris会讲一下

00:01:09.903 --> 00:01:12.472 
关于社区对Swift 3做了什么

00:01:14.641 --> 00:01:19.713 
这次发布的另一个重要方面是为了
把Swift带给更多的人

00:01:20.380 --> 00:01:23.417 
现在的软件生态系统非常多样化

00:01:23.483 --> 00:01:25.819 
人们做很多不同的事情

00:01:25.886 --> 00:01:27.087 
在不同的情况下

00:01:27.321 --> 00:01:28.989 
他们或者做服务器端程序

00:01:29.056 --> 00:01:30.958 
还有应用和其他的东西

00:01:31.024 --> 00:01:33.560 
我们想让任何人都能用Swift

00:01:33.794 --> 00:01:37.598 
我们还会讨论Swift
在Linux上的重要进展

00:01:37.998 --> 00:01:41.435 
这真的是Swift第一次重要的更新

00:01:41.502 --> 00:01:43.604 
自从Swift被移植到Linux上

00:01:45.472 --> 00:01:47.908 
现在仔细看看这次发布

00:01:48.242 --> 00:01:51.378 
Swift已经被不断迭代和打磨

00:01:51.445 --> 00:01:53.247 
在过去的两次发布中

00:01:53.313 --> 00:01:56.984 
基于使用它的开发者的反馈

00:01:57.751 --> 00:02:00.053 
当然 还有来自社区的反馈

00:02:00.120 --> 00:02:01.488 
自从它开源以后

00:02:02.055 --> 00:02:03.257 
关于Swift 3的重大事件

00:02:03.323 --> 00:02:06.960 
我们想让重要的基础都固定下来

00:02:07.027 --> 00:02:10.229 
然后我们能从上面继续前进

00:02:11.298 --> 00:02:14.101 
最后 可能是最宽泛的目标

00:02:14.168 --> 00:02:17.471 
我们很想让Swift变得更迷人

00:02:17.738 --> 00:02:18.572 
不应该这样么

00:02:19.039 --> 00:02:21.675 
Swift想成为一个强大的工具

00:02:21.742 --> 00:02:23.477 
给开发者用

00:02:23.544 --> 00:02:27.014 
他们可以用它做一些惊人的事情

00:02:27.181 --> 00:02:28.749 
这是我们想要的

00:02:29.383 --> 00:02:31.885 
现在 这可能是比较宽泛的目标

00:02:31.952 --> 00:02:35.756 
我们努力听取反馈

00:02:35.822 --> 00:02:38.058 
从使用Swift的应用开发者那里

00:02:38.525 --> 00:02:41.495 
Apple内部如何使用

00:02:42.029 --> 00:02:44.498 
我想说说我们自己怎么使用Swift

00:02:44.565 --> 00:02:48.602 
尤其是去年在我们发布的系统和工具中

00:02:49.736 --> 00:02:52.673 
重要的不是我们在
Apple使用Swift越来越多

00:02:52.739 --> 00:02:55.542 
是我们使用的方式越来越多

00:02:55.609 --> 00:02:57.811 
不仅是写应用

00:02:57.878 --> 00:03:00.147 
我们现在内部框架中也在用Swift

00:03:00.214 --> 00:03:02.950 
Agents 和 Daemons
类似这样的加强了

00:03:03.016 --> 00:03:05.986 
这种操作系统的深层体验

00:03:06.620 --> 00:03:10.224 
如果你看一下 你会发现
对Sierra和iOS 10

00:03:10.290 --> 00:03:12.593 
你会看到像新的音乐应用

00:03:13.026 --> 00:03:14.795 
使用了大量的Swift

00:03:14.862 --> 00:03:17.030 
Sierra里的终端应用

00:03:17.097 --> 00:03:20.501 
和新的日志记录联系紧密

00:03:21.468 --> 00:03:23.971 
也是用大量的Swift

00:03:25.239 --> 00:03:29.409 
通过Agents和Daemons
Sierra中新的画中画功能

00:03:29.476 --> 00:03:31.879 
完全是用Swift写的

00:03:32.579 --> 00:03:34.047 
现在看看工具

00:03:34.114 --> 00:03:37.284 
Xcode也使用了Swift

00:03:37.618 --> 00:03:40.287 
比如 Xcode 8中的新文档查看

00:03:40.354 --> 00:03:41.922 
是用Swift写的

00:03:42.389 --> 00:03:45.425 
和为iOS设计的优美
Swift Playgrounds

00:03:45.759 --> 00:03:47.928 
也是完全用Swift写的

00:03:48.495 --> 00:03:52.165 
所以我们Swift做了很多

00:03:52.232 --> 00:03:56.670 
这让我们集中精力解决各种不同的问题

00:03:56.737 --> 00:04:00.274 
无论是性能问题 比如内存使用

00:04:00.340 --> 00:04:02.442 
保证常规调用正确 等等

00:04:02.509 --> 00:04:06.013 
在各种情况下 保证Swift可用

00:04:07.281 --> 00:04:10.017 
我想讲一个特别案例

00:04:10.284 --> 00:04:11.385 
就是Dock

00:04:12.219 --> 00:04:15.055 
有两个原因

00:04:16.290 --> 00:04:19.059 
一个是它没有人们想象那么简单

00:04:19.125 --> 00:04:23.063 
它不仅仅是桌面的一个条

00:04:23.397 --> 00:04:27.935 
它代表一大部分macOS
的桌面管理体验

00:04:28.302 --> 00:04:32.272 
像Mission Control
LaunchPad Spaces

00:04:32.639 --> 00:04:34.942 
我们认为他们是Dock的一部分

00:04:36.043 --> 00:04:38.111 
第二个原因是

00:04:38.178 --> 00:04:40.347 
这两次的发布中我们已用了Swift

00:04:40.414 --> 00:04:42.983 
在El Capitan
开始采用Swift

00:04:43.050 --> 00:04:46.887 
我们有两个版本
来对比Swift的使用

00:04:48.555 --> 00:04:51.491 
在Sierra中Dock有很多改变

00:04:52.392 --> 00:04:56.363 
首先 绝大部分Mission
Control被用Swift重写

00:04:56.430 --> 00:04:59.066 
辅助引擎已经用Swift重写了

00:04:59.266 --> 00:05:00.100 
为什么我们这么做

00:05:00.167 --> 00:05:03.270 
我们不是为了重写代码而重写

00:05:03.604 --> 00:05:06.039 
这使代码质量提高了

00:05:06.106 --> 00:05:09.109 
通过接入新的特性和重构

00:05:09.476 --> 00:05:11.812 
同时有一些新的功能需要实现

00:05:11.879 --> 00:05:16.850 
所以这是重写代码的合适时机

00:05:17.985 --> 00:05:20.621 
从工程角度 看起来是什么样呢

00:05:22.089 --> 00:05:25.325 
给你点提示
Dock有差不多20万行代码

00:05:26.059 --> 00:05:28.829 
有差不多几万行Swift

00:05:29.796 --> 00:05:32.733 
在El Capitan
和Sierra

00:05:33.300 --> 00:05:36.303 
项目中Swift的代码超过两倍

00:05:37.471 --> 00:05:39.840 
实际上 通过重写

00:05:40.107 --> 00:05:43.710 
替换掉了大量的C
和Objective-C代码

00:05:45.345 --> 00:05:47.748 
这里的影响不容易衡量

00:05:48.081 --> 00:05:51.218 
因为我们还做了重构和添加了新特性

00:05:51.285 --> 00:05:53.720 
但我们看到大约少了15%的代码

00:05:53.787 --> 00:05:57.558 
在用Swift替换掉C
和Objective-C时

00:05:57.624 --> 00:06:00.761 
这包括其中新加的特性

00:06:01.562 --> 00:06:03.830 
直接结果是

00:06:03.897 --> 00:06:06.099 
这个工程在Sierra中变小了

00:06:06.533 --> 00:06:09.002 
比在El Capitan中

00:06:10.003 --> 00:06:10.838 
现在

00:06:11.138 --> 00:06:13.240 
有更多的统计

00:06:13.507 --> 00:06:15.442 
我认为最重要的是

00:06:15.509 --> 00:06:18.812 
写Dock的工程师喜欢用Swift

00:06:19.279 --> 00:06:20.814 
他们没有被强制使用它

00:06:21.048 --> 00:06:24.685 
他们是自发的
他们很想用Swift

00:06:25.352 --> 00:06:27.855 
他们的经验是感觉

00:06:27.921 --> 00:06:30.924 
他们更容易的写出他们想写的代码

00:06:30.991 --> 00:06:33.193 
他们喜欢Swift的安全的特性

00:06:33.260 --> 00:06:36.096 
让他们坚信他们的代码很棒

00:06:38.098 --> 00:06:39.800 
我们说说Swift的开源

00:06:40.634 --> 00:06:44.438 
如果你还不知道
请访问swift.org

00:06:45.072 --> 00:06:48.742 
你可以找到各种贡献的方式

00:06:49.076 --> 00:06:50.177 
比如 你想做

00:06:50.244 --> 00:06:53.080 
最专业的编译器黑客

00:06:53.146 --> 00:06:56.049 
你可以检出源代码来找漏洞

00:06:57.551 --> 00:07:00.153 
也有其他方式你可以贡献想法

00:07:00.220 --> 00:07:02.589 
我们想给Swift带来什么

00:07:04.658 --> 00:07:07.594 
现在 如何运作这个项目很重要

00:07:08.362 --> 00:07:10.531 
这意味着保持平等

00:07:10.998 --> 00:07:15.903 
我们非常想开放 透明和自由

00:07:15.969 --> 00:07:20.374 
每个人都能参与进来推动它向前

00:07:20.607 --> 00:07:23.677 
你能看到我们做出改变的合理理由

00:07:24.178 --> 00:07:25.445 
这真的非常重要

00:07:25.512 --> 00:07:26.847 
所有语言的改变

00:07:26.914 --> 00:07:29.650 
无论你在Apple工作

00:07:30.017 --> 00:07:32.119 
或者你是应用开发者

00:07:32.186 --> 00:07:34.788 
你有想法想要改变Swift

00:07:34.855 --> 00:07:36.356 
大家用的方法都一样

00:07:36.757 --> 00:07:38.592 
我认为这很重要

00:07:38.992 --> 00:07:42.796 
这意味着非苹果工程师
可以直接

00:07:42.863 --> 00:07:46.433 
提交代码给编译器和其他储存库

00:07:46.600 --> 00:07:50.404 
我们想授权社区来推动Swift向前

00:07:51.438 --> 00:07:53.607 
第三 我想它同样重要

00:07:53.774 --> 00:07:56.343 
对这个项目是面向代码的

00:07:56.476 --> 00:07:59.379 
我们认为每个人能贡献代码时

00:07:59.446 --> 00:08:01.849 
不会感到歧视很重要

00:08:01.915 --> 00:08:05.719 
不会被不专业的方式对待
我们很注意这些

00:08:06.820 --> 00:08:11.825 
最后这个项目的开源许可证比较宽松

00:08:12.226 --> 00:08:15.229 
这同样重要
因为我们想让Swift

00:08:15.362 --> 00:08:17.097 
以Apple不曾设想的方式使用

00:08:17.164 --> 00:08:19.967 
这也是开源Swift的一个目标

00:08:20.033 --> 00:08:23.937 
我们想让大家用各种方式使用它

00:08:24.338 --> 00:08:27.975 
同时社区也有很好的专利保护

00:08:28.041 --> 00:08:29.810 
这是我们为何选择该许可证的原因

00:08:32.078 --> 00:08:33.179 
你可有很多方式跟随

00:08:33.246 --> 00:08:37.551 
Swift主干开发

00:08:37.618 --> 00:08:39.886 
你可以检出源代码或者编译编译器

00:08:40.520 --> 00:08:43.256 
通常我们也有可下载的快照

00:08:43.323 --> 00:08:46.960 
你可以从swift.org上下载
直接在Xcode中使用

00:08:47.027 --> 00:08:48.262 
或者在Linux上使用

00:08:48.328 --> 00:08:50.564 
其他支持的平台

00:08:50.631 --> 00:08:52.799 
我们也会提供快照

00:08:53.567 --> 00:08:56.904 
更棒的是在Xcode 8中的
Playgrounds

00:08:56.970 --> 00:08:59.006 
全部支持这些快照

00:08:59.072 --> 00:09:03.310 
这是一个很棒的方式来试验Swift
伴随着它的演进

00:09:03.644 --> 00:09:05.546 
同时你不再需要重启Xcode

00:09:05.612 --> 00:09:07.481 
如果你想用其中的工具链

00:09:07.548 --> 00:09:10.317 
这体验很清爽

00:09:10.384 --> 00:09:12.553 
在试用最新版本的Swift时

00:09:14.188 --> 00:09:17.224 
所有的开发都在GitHub上进行

00:09:17.791 --> 00:09:19.826 
不止一个工程

00:09:19.893 --> 00:09:22.429 
有一系列的代码库

00:09:22.496 --> 00:09:25.199 
你可以在swift.org上
找到它们的描述

00:09:26.233 --> 00:09:30.470 
它们可以大体被归为三类

00:09:31.171 --> 00:09:33.540 
语言和它的演进过程

00:09:33.774 --> 00:09:36.743 
一个包管理工具和一个核心库集合

00:09:37.110 --> 00:09:38.212 
我们挨个说一下

00:09:39.713 --> 00:09:43.717 
包管理工具发布
当Swift开源时

00:09:44.218 --> 00:09:47.087 
还处于早期阶段和活跃开发阶段

00:09:47.154 --> 00:09:51.024 
GitHub有逾1,000个软件库

00:09:51.091 --> 00:09:52.659 
使用包管理

00:09:53.493 --> 00:09:54.328 
它是什么

00:09:55.329 --> 00:09:58.465 
它是一个跨平台的 包管理
用来编译

00:09:58.532 --> 00:10:00.801 
给Linux和0S 10打包

00:10:01.101 --> 00:10:02.903 
我们主要想编译

00:10:03.203 --> 00:10:07.040 
让社区给Swift打造一个生态系统

00:10:07.107 --> 00:10:09.943 
我们认为把Swift带到
其他平台非常重要

00:10:10.010 --> 00:10:11.612 
像服务器端

00:10:13.413 --> 00:10:15.716 
它为顺畅的开发设计

00:10:15.782 --> 00:10:19.219 
它容易上手
最小化配置

00:10:19.486 --> 00:10:21.355 
容易解决依赖

00:10:21.421 --> 00:10:24.224 
目的是写代码然后运行

00:10:25.726 --> 00:10:28.262 
我们认为对Swift来说
包管理如此基础

00:10:28.762 --> 00:10:31.932 
它是一个长期成功

00:10:32.199 --> 00:10:34.701 
我们持续提交把

00:10:34.768 --> 00:10:37.638 
包管理集成到Xcode
随着它更成熟

00:10:41.241 --> 00:10:43.277 
我们讨论下核心库

00:10:43.443 --> 00:10:44.311 
什么是核心库

00:10:45.546 --> 00:10:47.414 
在iOS中有很多很棒的API

00:10:47.614 --> 00:10:51.652 
macOS tvOS和
watchOS中

00:10:52.186 --> 00:10:55.489 
其中许多基础API

00:10:55.556 --> 00:10:58.492 
我们想让很多人能使用它

00:10:59.059 --> 00:11:00.894 
所以核心库代表

00:11:01.361 --> 00:11:05.232 
可选择的实现了不绑定
Objective-C运行时间

00:11:05.599 --> 00:11:08.035 
Linux上的核心API

00:11:08.101 --> 00:11:11.038 
还有其他Swift会移植到的平台

00:11:11.939 --> 00:11:14.575 
有名的例子包括像XE测试组件

00:11:14.641 --> 00:11:16.376 
你可以用来写单元测试

00:11:16.944 --> 00:11:19.012 
一个基础的子集

00:11:19.346 --> 00:11:21.515 
需要可移植并不会绑定到Cocoa

00:11:21.882 --> 00:11:24.718 
同时进行libdispatch移植

00:11:24.785 --> 00:11:26.820 
然后你可以用这些并发API

00:11:27.821 --> 00:11:31.191 
这些工作都刚开始进行
和Swift开源同时开始

00:11:31.258 --> 00:11:32.893 
但现在已经有不少了

00:11:33.227 --> 00:11:35.195 
在Linux上的基础库

00:11:35.262 --> 00:11:38.999 
支持许多很棒的API
像操作URL 日期

00:11:39.066 --> 00:11:41.835 
还有数据 UID等等

00:11:41.902 --> 00:11:46.173 
我们希望在未来会变的成熟

00:11:46.240 --> 00:11:49.476 
随着社区希望更多的功能

00:11:52.479 --> 00:11:55.048 
现在 来讨论下语言

00:11:55.782 --> 00:11:58.452 
Chris会讲很多具体的变化

00:11:58.652 --> 00:12:01.989 
我想说说这些变化的演化历程

00:12:02.489 --> 00:12:05.392 
这些都在Swift软件库中发生

00:12:06.760 --> 00:12:09.963 
比如现在你想要改变Swift

00:12:10.030 --> 00:12:11.765 
你感觉有些地方很烂

00:12:11.832 --> 00:12:15.936 
重要的开发中有些地方出了问题

00:12:16.003 --> 00:12:18.172 
可能两年前这种设计比较好

00:12:18.238 --> 00:12:19.806 
但现在应该重新考虑下

00:12:20.274 --> 00:12:23.844 
或有些很棒的东西我们应该加进去

00:12:24.144 --> 00:12:27.848 
能给开发者带来全新的机会

00:12:28.215 --> 00:12:29.049 
没关系

00:12:29.183 --> 00:12:32.452 
你可以从邮件列表开始

00:12:32.519 --> 00:12:35.822 
告诉其他有相同兴趣的开发者

00:12:36.256 --> 00:12:37.090 
开始观察

00:12:37.824 --> 00:12:40.794 
这是个好想法么
它的好处和弊端是什么

00:12:41.628 --> 00:12:43.564 
一旦有足够的关键论据

00:12:44.131 --> 00:12:46.133 
它会成为一个提议

00:12:46.800 --> 00:12:50.037 
这里仅是一个用
markdown写的白皮书

00:12:50.971 --> 00:12:54.208 
可以在GitHub上查看

00:12:55.108 --> 00:12:57.978 
这里有一个实际的提议

00:12:58.745 --> 00:13:01.882 
通过pull request
提交等待审核

00:13:02.649 --> 00:13:08.288 
左下角是数字标识 SE0046

00:13:08.622 --> 00:13:10.057 
每个提议都会被数字标记

00:13:10.123 --> 00:13:11.558 
我们通过它指定

00:13:11.625 --> 00:13:15.395 
实际的提议在Swift变化中

00:13:15.696 --> 00:13:17.497 
Chris引用这些提议

00:13:17.898 --> 00:13:21.368 
在他讲Swift的变化的时候

00:13:22.236 --> 00:13:24.872 
这些提议是大家建议修改

00:13:25.239 --> 00:13:27.908 
Swift的方法

00:13:27.975 --> 00:13:30.844 
合理的建议为什么我们需要做这些改变

00:13:32.713 --> 00:13:35.048 
具体的改变应该是什么样

00:13:35.649 --> 00:13:36.683 
优点和缺点

00:13:36.984 --> 00:13:40.954 
一旦提议合理将会被接受

00:13:42.589 --> 00:13:47.628 
之前的审查在接受进入仓库是开始

00:13:48.662 --> 00:13:51.164 
审查还是会被开放讨论

00:13:51.231 --> 00:13:53.800 
在邮件列表中
但这次会集中

00:13:53.867 --> 00:13:57.104 
在具体的提议
不仅仅是抽象的想法

00:13:58.071 --> 00:14:00.941 
一段时间后
Swift核心团队

00:14:01.008 --> 00:14:04.545 
一小部分单独的推动着项目向前的人

00:14:04.611 --> 00:14:06.547 
会看社区的反馈

00:14:07.214 --> 00:14:08.849 
看优点和缺点

00:14:09.249 --> 00:14:13.420 
根据社区的需要做最终选择

00:14:13.854 --> 00:14:17.925 
他们要考虑很多
怎么把提议融合到Swift中

00:14:18.225 --> 00:14:20.527 
这有意义么
一些提议会被驳回

00:14:20.594 --> 00:14:22.896 
“嘿 当前这样的话

00:14:22.963 --> 00:14:24.164 
行不通

00:14:24.231 --> 00:14:27.234 
所以回去考虑和改进一下”

00:14:27.467 --> 00:14:29.636 
或者这对Swift永远都不合适

00:14:31.004 --> 00:14:33.106 
有时提议通常也会被接受

00:14:33.273 --> 00:14:34.775 
通过改进

00:14:34.842 --> 00:14:38.912 
无论被驳回或者接受
所基于的理论都会做记录

00:14:38.979 --> 00:14:42.015 
所以每个人都可以回头看看
这个语言的发展史

00:14:42.082 --> 00:14:44.051 
同时明白什么被提议

00:14:44.117 --> 00:14:47.988 
为什么被提议
为什么被拒绝或者接受了

00:14:49.623 --> 00:14:51.425 
你可以看到所有的提议

00:14:51.491 --> 00:14:54.328 
通过Swift-evolution
仓库

00:14:54.561 --> 00:14:56.997 
这个是为Swift 3建立的

00:14:57.064 --> 00:14:59.399 
由所有人推动

00:15:00.467 --> 00:15:04.104 
下面由Chris讲一下都发生了什么

00:15:07.307 --> 00:15:08.141 
谢谢 Ted

00:15:12.145 --> 00:15:13.580 
因为有很多其他事

00:15:13.647 --> 00:15:17.484 
不幸的是我没有时间准备演讲稿

00:15:17.551 --> 00:15:20.521 
我打印了所有的提议
我想我会给你们读一下

00:15:20.888 --> 00:15:21.722 
听起来不错吧

00:15:23.190 --> 00:15:24.024 
开个玩笑

00:15:25.259 --> 00:15:26.760 
那么我们将要干什么

00:15:27.461 --> 00:15:30.330 
之前我们说我们想要把
Swift的核心体验变得很棒

00:15:30.397 --> 00:15:32.165 
不仅是语言

00:15:32.232 --> 00:15:33.901 
也包括标准库

00:15:34.234 --> 00:15:37.070 
使用像Cocoa主要API的体验

00:15:37.304 --> 00:15:38.972 
还有使用工具的体验

00:15:39.039 --> 00:15:41.241 
我们会挨个介绍

00:15:42.543 --> 00:15:45.212 
Swift 3的一个目标是代码兼容

00:15:45.579 --> 00:15:47.881 
这是个很大的目标
这意味着我们想

00:15:47.948 --> 00:15:50.617 
无论你在应用中
写了什么样的代码

00:15:50.684 --> 00:15:53.020 
我们要保证
当Swift 3发布的时候

00:15:53.086 --> 00:15:54.922 
不会有其他问题

00:15:55.455 --> 00:15:59.193 
这是一个相当困难的任务
因为这不仅关系到

00:15:59.626 --> 00:16:03.931 
我们用的分号还是逗号

00:16:03.997 --> 00:16:05.832 
还关系到关键的API

00:16:05.899 --> 00:16:08.635 
做尽可能多的工作让Swift 3

00:16:08.702 --> 00:16:10.204 
兼容 然后我们可以一直使用

00:16:10.270 --> 00:16:12.840 
你写的代码

00:16:13.540 --> 00:16:16.043 
这里有几个不同的方面

00:16:16.109 --> 00:16:17.544 
一个是整合这些到

00:16:17.611 --> 00:16:20.881 
刚才Ted说的Swift-evolution提议过程

00:16:20.948 --> 00:16:23.217 
Swift 3之后的提议

00:16:23.584 --> 00:16:25.886 
都应当好好考虑下代码兼容性

00:16:26.753 --> 00:16:30.057 
现在 我为最重要的方面
Swift 3中最大的改变是

00:16:30.123 --> 00:16:33.961 
影响我们每天写的代码的API

00:16:34.428 --> 00:16:36.129 
我们深入看一下API命名

00:16:36.196 --> 00:16:38.365 
先大体了解下

00:16:39.633 --> 00:16:42.035 
API是一个基础组成

00:16:42.102 --> 00:16:44.938 
当Apple在创建这个平台的时候

00:16:45.005 --> 00:16:47.875 
是你每天使用的重要部分

00:16:47.941 --> 00:16:50.110 
你用它来创建应用

00:16:50.344 --> 00:16:51.311 
命名规则

00:16:51.378 --> 00:16:53.747 
和设计方法

00:16:53.814 --> 00:16:55.749 
对它的影响很深远

00:16:56.383 --> 00:16:58.018 
在Swift 3中

00:16:58.385 --> 00:17:00.721 
我们会思考写这些API最好的
方式是什么

00:17:00.787 --> 00:17:02.656 
我们应该更详细些么

00:17:02.723 --> 00:17:06.159 
还是应该尽可能的简洁

00:17:06.693 --> 00:17:10.196 
我们发现最重要的是要清晰

00:17:10.263 --> 00:17:12.065 
能够清晰的被使用

00:17:12.232 --> 00:17:13.500 
我们对API进行了优化

00:17:13.567 --> 00:17:15.969 
提取最重要的基础信息

00:17:16.036 --> 00:17:18.672 
去掉其他不必要的信息

00:17:19.339 --> 00:17:21.808 
我们看几个例子
给你们展示下

00:17:21.875 --> 00:17:25.512 
实际操作中我们的一些思考
和这么做是为了什么

00:17:25.846 --> 00:17:28.682 
这里有几个Swift 2中的API

00:17:29.583 --> 00:17:31.952 
我们从数组和往里面添加内容开始

00:17:32.286 --> 00:17:34.721 
在Swift 3中 被削减了一半

00:17:35.289 --> 00:17:38.859 
动词添加
现在操作是操作了

00:17:39.259 --> 00:17:43.397 
contentsOf是传进参数描述

00:17:43.463 --> 00:17:45.599 
现在它是传递参数的标签

00:17:45.999 --> 00:17:47.734 
调用的时候使用

00:17:47.935 --> 00:17:49.903 
这能让它更清晰一些

00:17:50.370 --> 00:17:54.107 
插入索引 这个已经很合理了

00:17:54.174 --> 00:17:57.744 
但是这个索引没有额外的信息

00:17:57.811 --> 00:18:01.448 
只是重复类型信息最好去掉

00:18:02.149 --> 00:18:05.219 
在基础库中 我们看看NSURL

00:18:05.586 --> 00:18:08.021 
它有个fileURL方法或者属性

00:18:08.088 --> 00:18:11.091 
看看它
它返回一个布尔值但不明显

00:18:11.158 --> 00:18:14.061 
如果用is开头将会很清晰

00:18:14.628 --> 00:18:17.898 
另一个简单的例子是
URLByAppendingPathComponent

00:18:18.265 --> 00:18:20.834 
它去掉了多余的返回类型

00:18:20.901 --> 00:18:22.302 
因为没有必要

00:18:22.736 --> 00:18:25.005 
有非常多的像这样的改善

00:18:25.305 --> 00:18:27.574 
把所有的这些加起来

00:18:27.641 --> 00:18:31.211 
在10:00将会有个
关于这些更详细的介绍

00:18:33.080 --> 00:18:36.383 
我们看看Objective-C和CAPI
在Swift中如何工作

00:18:36.450 --> 00:18:40.888 
因为它是你使用API时
非常关键的一部分

00:18:40.954 --> 00:18:42.756 
影响你在Swift中的体验

00:18:43.423 --> 00:18:47.060 
我们做了很多提升
其中一个我们叫import为成员

00:18:47.461 --> 00:18:49.963 
这是一个典型的C的核心图像API

00:18:50.664 --> 00:18:53.467 
在Swift 2中
它会被当做全局函数引用

00:18:53.867 --> 00:18:55.002 
好的 这样可以

00:18:55.068 --> 00:18:58.138 
但这不符合Swift开发者
用的API

00:18:58.205 --> 00:19:02.809 
所以我们引入了一个新特性
允许API作者给他们的API标记

00:19:02.876 --> 00:19:06.880 
用这个宏来把它封装为一个属性
当做一个方法导入

00:19:06.947 --> 00:19:08.715  
提供一个优美的面向对象的API

00:19:08.782 --> 00:19:11.151  
就像核心图像和dispatch中的

00:19:11.251 --> 00:19:13.453  
你也可以在你的代码里这么用

00:19:14.888 --> 00:19:16.924 
另一个是泛型

00:19:16.990 --> 00:19:19.760 
去年在Swift 2中
我们引入了轻量级的泛型

00:19:19.826 --> 00:19:23.030 
我们使用它来引入类型
结合到Swift中

00:19:23.931 --> 00:19:25.532 
但Apple的几个框架

00:19:25.599 --> 00:19:27.234 
用其他方式采用了轻量泛型

00:19:27.301 --> 00:19:29.703 
比如 自动布局和核心数据

00:19:30.437 --> 00:19:35.843 
在Swift 3中
我们可以引入完全通用泛型

00:19:35.909 --> 00:19:38.512 
到Swift 3中作为泛型类型

00:19:38.579 --> 00:19:42.149 
就是说许多冗余的类型信息

00:19:42.216 --> 00:19:43.383 
可以不要了

00:19:44.885 --> 00:19:45.719 
我们讲一下

00:19:51.992 --> 00:19:53.393 
关于常量

00:19:53.660 --> 00:19:56.196 
在许多Cocoa API中
一种常见的模式是

00:19:56.263 --> 00:19:58.732 
用字符串作为枚举

00:19:59.132 --> 00:20:03.704 
我们这么做因为在C语言中
最好的方法是

00:20:03.770 --> 00:20:06.507 
写一个开放的可扩展的枚举

00:20:06.907 --> 00:20:08.642 
但这有很多缺点

00:20:08.709 --> 00:20:12.346 
这些枚举 变成了全局常量

00:20:12.412 --> 00:20:15.048 
在Swift中被引用为全局的

00:20:15.115 --> 00:20:16.984  
使用的时候需要输入很长的名字

00:20:17.050 --> 00:20:21.355  
在很多地方都不是很好
一个是完全类型不安全

00:20:21.421 --> 00:20:24.091  
你可以传递一个任意的字符串
但它不会工作

00:20:24.458 --> 00:20:27.261 
同时它还不好因为
它污染了代码的完整性

00:20:27.327 --> 00:20:30.564 
让人感觉不像Swift API

00:20:30.831 --> 00:20:34.134 
这是对Swift APIs
来说非常好的发展方向

00:20:35.369 --> 00:20:36.803 
Swift 3中得以解决

00:20:36.870 --> 00:20:41.308  
现在API的作者可以
给typedef添加一个简单的属性

00:20:41.375 --> 00:20:44.878  
不同的是
它变成了Swift中的强类型

00:20:44.978 --> 00:20:48.081  
你可看到通过常用的
NSNotification.Name

00:20:48.282 --> 00:20:52.452  
在这个例子中
是在UserDefaults范围中

00:20:52.519 --> 00:20:55.589  
现在可以通过点属性来调用

00:20:55.956 --> 00:20:59.126  
最棒的是它经过了类型检查

00:21:04.898 --> 00:21:07.201 
所以在SDK中它有巨大的提升

00:21:07.267 --> 00:21:09.970 
通过这一周大家就可了解这些新的特性

00:21:10.037 --> 00:21:12.072 
这周有许多很棒的讲座

00:21:12.706 --> 00:21:14.842 
我们深入了解下核心语言

00:21:15.876 --> 00:21:20.814 
通过这些改变
我们回头看看参数标签

00:21:20.881 --> 00:21:24.284 
快速介绍下
如果你在Swift 2中有这个函数

00:21:24.551 --> 00:21:28.755 
你应该三个中取两个参数使用

00:21:28.822 --> 00:21:29.656 
为什么这样

00:21:30.057 --> 00:21:35.262 
因为沿袭了Objective-C
的命名和设计模式

00:21:35.329 --> 00:21:39.032 
我们想要在Swift中
和Cocoa的体验一致

00:21:39.566 --> 00:21:42.603 
当然在Swift中
从根本上改变了Cocoa的工作方式

00:21:42.669 --> 00:21:45.806 
现在我们可以把参数标签给所有变量

00:21:45.873 --> 00:21:49.042 
可以让Swift表现更一致和可预测

00:21:54.615 --> 00:21:55.949 
我们说说泛型

00:21:56.149 --> 00:21:59.853 
Swift泛型语法 我认为
非常优美并富有表达力

00:21:59.920 --> 00:22:04.157 
它能让你知道函数主要是干啥的

00:22:04.224 --> 00:22:06.393 
用一个简洁和友好的方式

00:22:07.394 --> 00:22:10.097 
不幸的是 当你开始
使用更高级例子

00:22:10.163 --> 00:22:12.099 
你需要添加泛型约束

00:22:12.165 --> 00:22:16.303 
基本上是这些函数的第二功能

00:22:16.370 --> 00:22:18.972 
但是它们却在第一位置

00:22:19.406 --> 00:22:22.342 
使代码变得难读

00:22:22.576 --> 00:22:25.245 
Swift 3中 我们拓展了语法
并修正了这个问题

00:22:25.312 --> 00:22:28.048 
现在签名被放在了前面

00:22:28.115 --> 00:22:30.250 
约束是第二位了

00:22:35.022 --> 00:22:36.657 
我们讨论下未使用的结果

00:22:36.857 --> 00:22:39.960 
这里有个简单的函数
它加上一个数字并且返回

00:22:40.227 --> 00:22:42.663 
在Swift 2中
这段代码不会被警告

00:22:42.729 --> 00:22:44.665 
即使它是一个漏洞

00:22:44.731 --> 00:22:46.533 
可能你忘记把它赋给一个变量

00:22:46.600 --> 00:22:49.837 
可能你完全调用错了函数 对么

00:22:50.404 --> 00:22:53.540 
在Swift 3中
你默认会得一个到警告

00:22:53.607 --> 00:22:55.075 
它很安全 这很棒

00:22:55.542 --> 00:22:57.511 
这在其他地方也很好

00:22:57.578 --> 00:23:00.747 
因为对复杂例子的组合也很好

00:23:01.348 --> 00:23:04.318 
当然不是所有函数都这么理想化

00:23:04.384 --> 00:23:07.354 
在实际中它们可能有副作用

00:23:08.088 --> 00:23:10.624 
你可能会想
如果有副作用

00:23:10.691 --> 00:23:13.093 
也许我就是为了这样使用它

00:23:13.660 --> 00:23:16.630 
这没有问题
你可以把它赋值给下划线

00:23:16.697 --> 00:23:21.034 
告诉编译器或者维护你代码的人

00:23:21.101 --> 00:23:23.770 
你认为这个函数返回的东西

00:23:23.837 --> 00:23:25.906 
你明确表示你不关心

00:23:25.973 --> 00:23:26.807 
对么

00:23:27.174 --> 00:23:29.910 
现在 不是所有的函数有这个属性

00:23:29.977 --> 00:23:32.446 
有些函数
像一些异常

00:23:32.579 --> 00:23:35.082 
有副作用
作为它们的首要功能

00:23:35.148 --> 00:23:38.619 
返回值通常是你第二位你不需要关心的

00:23:38.785 --> 00:23:41.788 
在异常函数的例子中
你可以使用一个属性表示

00:23:41.855 --> 00:23:44.625 
我知道这个返回值是第二件事

00:23:44.691 --> 00:23:47.394 
不要产生警告如果我没有使用

00:23:47.461 --> 00:23:48.562 
一个友好的系统

00:23:50.063 --> 00:23:55.602 
我们说说Swift 3中
最令人兴奋的地方

00:23:55.869 --> 00:23:57.271 
被去掉的特性

00:23:57.337 --> 00:24:00.073 
你可能会问
为什么这么做

00:24:00.440 --> 00:24:02.943 
但我们真的让Swift 3变得很棒

00:24:03.310 --> 00:24:06.013 
Swift 3是这些的总和

00:24:06.079 --> 00:24:08.916 
许多部分被放进Swift

00:24:08.982 --> 00:24:11.385 
在我们真正明白
什么应该被编译进去

00:24:11.451 --> 00:24:12.853 
和我们该往哪里走

00:24:13.353 --> 00:24:16.857 
所以我们回头想了下
Swift所有的属性

00:24:16.924 --> 00:24:19.826 
无论它是何时被引入进来的
我们问一下基本的问题

00:24:20.394 --> 00:24:24.198 
若该特性还没被加入到Swift
现在应该添加么

00:24:25.566 --> 00:24:28.669 
对于一些特性 答案是否定的
所以我们把它拿走

00:24:28.969 --> 00:24:31.071 
这样做很棒

00:24:31.138 --> 00:24:33.473 
它为大家简化了语言

00:24:33.874 --> 00:24:38.745 
我意识到其中可能有偏见和争议

00:24:39.746 --> 00:24:43.183 
Swift-evolution最棒
之处是作为社区让大家可以在其中讨论

00:24:43.517 --> 00:24:47.454 
它们中的每一个
有个有丰富理论基础的提议

00:24:47.521 --> 00:24:50.991 
如果你想回头阅读关于它的上百封邮件

00:24:51.058 --> 00:24:54.661 
请到归档的邮件列表查阅

00:24:54.761 --> 00:24:57.497 
我想邮件列表各个方面都有

00:24:57.564 --> 00:24:59.900 
这些问题都被描述得很好了

00:25:01.435 --> 00:25:04.671 
Swift也有其他小的提升

00:25:04.738 --> 00:25:06.373 
我没有时间去全部说一遍

00:25:06.440 --> 00:25:08.642 
但我们有像泛型别名

00:25:08.709 --> 00:25:12.713 
我们有类型安全选择器
和关键路径引用

00:25:12.980 --> 00:25:14.748 
我们有新的编译配置

00:25:14.815 --> 00:25:17.284 
匹配功能提升
和其他好多东西

00:25:17.351 --> 00:25:19.119 
你可以从提议中阅读

00:25:19.186 --> 00:25:20.654 
或者从发布日志中看到

00:25:21.922 --> 00:25:26.593 
关于核心语言的另一方面是语法

00:25:27.060 --> 00:25:30.197 
我想我们大家都喜欢
我希望你们喜欢

00:25:30.264 --> 00:25:33.300 
Swift的基本语法结构

00:25:33.367 --> 00:25:35.068 
我认为它是其中一个主要部分

00:25:35.135 --> 00:25:37.905 
因为它感觉起来熟悉
并在一起工作的很好

00:25:38.405 --> 00:25:40.574 
不幸的是
Swift的有些部分

00:25:40.641 --> 00:25:45.512 
没有被好好考虑

00:25:45.579 --> 00:25:47.848 
我们每天用的语法结构

00:25:48.382 --> 00:25:50.083 
所以我们进行重新设计

00:25:50.150 --> 00:25:52.886 
对你最喜欢
的颜色添加了美观一致的色调

00:25:54.388 --> 00:25:57.057 
我们研究了一些奇怪的例子

00:25:57.124 --> 00:26:01.094 
因为它们和语言剩下的地方不一致

00:26:01.161 --> 00:26:03.063 
它让语言变得难用

00:26:03.130 --> 00:26:06.233 
这些被包含进Swift
因为它们很重要

00:26:06.533 --> 00:26:08.902 
我们回过头来标准化所有的东西

00:26:08.969 --> 00:26:11.939 
我们想把它弄正确
并在长时间里保持正确

00:26:13.006 --> 00:26:14.975 
这还是核心语言的简述

00:26:15.042 --> 00:26:17.845 
我想深入点说下类型系统

00:26:19.046 --> 00:26:20.848 
首先 什么是类型系统

00:26:20.981 --> 00:26:23.951 
在Swift中类型系统和类型检查器

00:26:24.418 --> 00:26:25.786 
一起定义类型怎么工作

00:26:26.220 --> 00:26:28.755 
类型检查器和编译器使用类型系统

00:26:28.822 --> 00:26:33.560 
来保证你的代码是正确的
或检验它是正确的

00:26:33.627 --> 00:26:36.163 
同时推断你代码忽略的东西

00:26:36.230 --> 00:26:39.266 
因为它默认是隐式的
例如 什么是A类型

00:26:39.900 --> 00:26:42.503 
在Swift 3中
我们想要简化类型系统

00:26:42.569 --> 00:26:45.272 
让它更一致
我们也想杜绝

00:26:45.339 --> 00:26:47.975 
人们遇到的常见类型问题

00:26:48.041 --> 00:26:49.843 
引起漏洞

00:26:50.477 --> 00:26:52.412 
我们讨论几个例子

00:26:53.013 --> 00:26:54.848 
首先是不安全的指针

00:26:56.083 --> 00:26:58.919 
不知道你们是否注意到你可以在

00:26:58.986 --> 00:27:01.822 
Swift 2中
给一个不安全的指针赋值nil

00:27:01.889 --> 00:27:03.991 
你可以直接测试它是否nil

00:27:04.191 --> 00:27:05.859 
你可以使用不安全的指针

00:27:05.926 --> 00:27:08.562 
不用关心它是否为nil

00:27:08.829 --> 00:27:11.231 
它和其他语言不一样

00:27:11.298 --> 00:27:13.901 
它让不安全的指针更不安全了

00:27:14.601 --> 00:27:17.538 
在Swift 3中
不安全的指针不能为nil

00:27:17.604 --> 00:27:20.641 
你可以使用optionals
就像这个语言的其他部分

00:27:20.707 --> 00:27:24.411 
你可以用if let安全的测试
然后包起来

00:27:24.478 --> 00:27:27.881 
甚至使所有的语法
提示我们提供optionals

00:27:27.948 --> 00:27:30.784 
让所有的代码工作的更稳定些

00:27:32.486 --> 00:27:34.421 
说到optionals

00:27:34.488 --> 00:27:38.358 
这个语言另一个有趣的部分
是隐式展开optionals

00:27:38.825 --> 00:27:41.828 
隐式展开optionals
是语言非常重要的一部分

00:27:41.895 --> 00:27:44.131 
通过两个阶段的初始化

00:27:44.198 --> 00:27:47.367 
或者调用API还没有验证时是否为空

00:27:47.668 --> 00:27:49.036 
这里有个简单的例子

00:27:49.102 --> 00:27:52.539 
我有个int
用了隐式展开optional

00:27:52.606 --> 00:27:55.676 
对其他类型也可以这么用

00:27:56.109 --> 00:27:59.012 
现在 Swift 2中的隐式展开
optional的基本工作方式

00:27:59.079 --> 00:28:01.315 
我想 大家都已经清楚了

00:28:02.049 --> 00:28:03.951 
这个例子中的X 比如

00:28:04.585 --> 00:28:08.055 
编译器必须强制展开那个IUO

00:28:08.121 --> 00:28:10.157 
为了做加法 它是这么做的

00:28:10.390 --> 00:28:12.559 
对于y 就不必这么做了

00:28:12.626 --> 00:28:15.229 
就像从代码上传递下来了

00:28:15.529 --> 00:28:18.365 
这个传递有很多原因

00:28:18.498 --> 00:28:21.535 
这也很令人意外
因为很多复杂的情况

00:28:21.602 --> 00:28:25.439 
常常让我们挠头
不知道代码到底是在做什么

00:28:25.839 --> 00:28:29.576 
在很多情况 你甚至不知道你有IUO

00:28:29.977 --> 00:28:33.180 
这里 我有一个int和一个IUO

00:28:33.247 --> 00:28:35.716 
IUO是强制的么

00:28:35.782 --> 00:28:38.418 
我能得到任何数组么 或者可选的
这到底怎么回事

00:28:38.485 --> 00:28:39.953 
你永远不会知道

00:28:40.020 --> 00:28:42.823 
直到你编译代码时
并且你得到了一些奇怪的编译错误

00:28:42.890 --> 00:28:45.626 
我们不想在这里费力

00:28:46.727 --> 00:28:50.397 
所以IUO作为一个概念非常重要

00:28:51.331 --> 00:28:52.332 
我们保留了它

00:28:52.733 --> 00:28:55.903 
但是我们改变了它的工作方式
用一个新的简单的模型

00:28:56.637 --> 00:28:58.138 
这个模型还比较原始

00:28:58.472 --> 00:29:01.008 
如果使用了IUO

00:29:01.642 --> 00:29:04.745 
如果值是可选的 那么就是

00:29:05.078 --> 00:29:08.148 
这是安全的
我们不想展开值

00:29:08.215 --> 00:29:09.483 
在你不想展开的地方

00:29:09.883 --> 00:29:12.352 
然而 如果编译器需要展开它

00:29:12.419 --> 00:29:14.421 
为了做类型检查 它就展开

00:29:15.255 --> 00:29:17.224 
我们再来看些例子

00:29:17.691 --> 00:29:18.725 
这里 有个x

00:29:18.792 --> 00:29:21.828 
编译器需要展开它做加法 所以展开

00:29:21.895 --> 00:29:24.765 
这是IUO的重要部分

00:29:24.831 --> 00:29:26.233 
与强属性的有所区别

00:29:27.267 --> 00:29:28.101 
为什么

00:29:28.535 --> 00:29:31.171 
好的 这里这个编译器可以
对表达式做类型检查

00:29:31.638 --> 00:29:32.906 
作为optional

00:29:32.973 --> 00:29:35.809 
所以现在不需要传递IUO

00:29:35.876 --> 00:29:39.079 
可能在深入到代码不同层级

00:29:39.146 --> 00:29:40.681 
它转换成了一个强的optional

00:29:40.747 --> 00:29:43.517 
可以让你思考

00:29:43.817 --> 00:29:45.819 
这让数组更可控

00:29:45.886 --> 00:29:46.753 
因为现在

00:29:47.020 --> 00:29:50.924 
当然 它可以作为一个
强的optional被类型检查

00:29:51.592 --> 00:29:54.962 
如果你实际上需要展开 这样也可以

00:29:55.028 --> 00:29:58.599 
你可以明确地
在代码中使用感叹号包上它

00:29:58.665 --> 00:30:00.767 
现在读代码的人可以知道是什么意思

00:30:00.834 --> 00:30:02.469 
你的代码好了很多

00:30:03.971 --> 00:30:05.572 
这是我的快速浏览

00:30:05.639 --> 00:30:08.008 
关于类型系统的一些有意思的事情

00:30:08.075 --> 00:30:10.010 
我们谈谈标准库

00:30:11.578 --> 00:30:15.382 
标准库最大的改变是
全新的集合索引模型

00:30:16.083 --> 00:30:18.585 
这是什么意思
你可能使用过索引

00:30:18.652 --> 00:30:19.486 
或者没有

00:30:19.553 --> 00:30:21.588 
有很多方式使用索引

00:30:21.655 --> 00:30:23.590 
这里的不同是它们如何移动

00:30:23.957 --> 00:30:26.660 
之前在Swift 2中
你可以调用索引的方法

00:30:26.727 --> 00:30:28.495 
像Successor 向前移动

00:30:29.029 --> 00:30:31.331 
在Swift 3中这个模型基本相同

00:30:31.398 --> 00:30:34.234 
除了现在索引可以自己移动

00:30:34.535 --> 00:30:38.238 
collection自己移动索引

00:30:39.373 --> 00:30:40.541 
为什么我们要做这些

00:30:40.607 --> 00:30:42.442 
在Springs有很多很棒的事

00:30:42.509 --> 00:30:44.344 
首先 我们开始简化标准库

00:30:44.411 --> 00:30:46.580 
许多类型去掉了 这很棒

00:30:46.980 --> 00:30:50.984 
更好的是 一些常见问题根本上就没了

00:30:51.218 --> 00:30:54.188 
你可以随便使用与发挥

00:30:54.254 --> 00:30:57.491 
之前可能触发一个没人知道的陷阱

00:30:58.025 --> 00:30:59.726 
同时性能也提高了

00:30:59.793 --> 00:31:03.063 
因为我们可以去掉很多特殊情况处理

00:31:03.130 --> 00:31:04.798 
对这些我们很兴奋

00:31:06.066 --> 00:31:07.401 
我们讨论下数字类型

00:31:07.868 --> 00:31:10.871 
我们有一个新的浮点类型协议
或者一个家族协议

00:31:10.938 --> 00:31:14.208 
可以帮助定义操作让你们写通用的算法

00:31:14.274 --> 00:31:16.476 
超出浮点类型更广的范围

00:31:17.144 --> 00:31:20.480 
更好的是
如果你是个数字分析类型的人员

00:31:20.547 --> 00:31:22.416 
你理解IEEE浮点数

00:31:22.482 --> 00:31:25.052 
我不是 大部分人都不是

00:31:25.118 --> 00:31:28.355 
它有很多低层次的操作

00:31:28.422 --> 00:31:31.859 
像让数字ULPS出来

00:31:31.925 --> 00:31:33.861 
其中有些重要的有技巧的东西

00:31:35.429 --> 00:31:36.930 
我也不全懂这些东西

00:31:36.997 --> 00:31:40.367 
我认为这很重要

00:31:40.434 --> 00:31:44.404 
我理解像Pi样的东西
每个人都喜欢Pi

00:31:44.838 --> 00:31:48.308 
在Swift 2中
使用MPi时我们总是遇到困难

00:31:48.375 --> 00:31:49.643 
这经常让我恼怒

00:31:49.710 --> 00:31:52.346 
它总是错误的类型
你需要强制转换它

00:31:52.412 --> 00:31:54.481 
总让人泄气

00:31:55.115 --> 00:31:59.353 
现在 除了包含IEEE的全部东西

00:31:59.419 --> 00:32:02.689 
我们有了Pi
在浮点数类型中

00:32:03.290 --> 00:32:05.392 
Swift通常有类型可用

00:32:05.459 --> 00:32:07.561 
另一个很棒的事情是

00:32:08.228 --> 00:32:10.564 
如果你有类型上下文

00:32:10.631 --> 00:32:12.866 
比如这里我们返回一个CGFloat

00:32:13.166 --> 00:32:16.336 
替代强制转换
你可以用CGFloat.Pi

00:32:16.637 --> 00:32:20.307 
更好的是你可以让编译器给你做推断

00:32:20.374 --> 00:32:21.975 
会有不错的结果

00:32:27.514 --> 00:32:29.716 
语言方面
有很多提升

00:32:29.783 --> 00:32:31.185 
贯穿标准库

00:32:31.251 --> 00:32:35.155 
其中有些对提高你的
Swift代码很有用

00:32:35.222 --> 00:32:39.026 
我强烈建议你看下其他Swift演讲

00:32:39.092 --> 00:32:40.460 
可以得到更多信息

00:32:41.361 --> 00:32:43.363 
这是一个快速浏览 关于语言

00:32:43.430 --> 00:32:45.766 
标准库
Cocoa在Swift如何工作

00:32:45.999 --> 00:32:49.970 
另一个重要的部分是
Swift和这些工具怎么在一起工作

00:32:50.337 --> 00:32:54.007 
讲到这里
我想请Ewa Matejska给大家讲讲

00:32:54.508 --> 00:32:55.342 
Ewa？

00:32:58.178 --> 00:32:59.146 
谢谢 Chris

00:33:01.515 --> 00:33:02.783 
大家早上好

00:33:03.417 --> 00:33:04.985 
让我们说说Tools

00:33:05.319 --> 00:33:06.720 
一个比较好的着入点是

00:33:06.787 --> 00:33:09.556 
就是工具如何提高性能

00:33:10.424 --> 00:33:12.893 
你可以看到
我们这一年非常忙碌

00:33:13.493 --> 00:33:15.963 
我们讨论其中的几个

00:33:17.464 --> 00:33:20.701 
我们重新实现了字典

00:33:21.034 --> 00:33:23.170 
我们集中

00:33:23.504 --> 00:33:26.073 
优化了字符串哈希算法

00:33:26.139 --> 00:33:27.307 
为ASCII字符串

00:33:27.674 --> 00:33:29.977 
我们看到一些不错的提升

00:33:30.477 --> 00:33:35.415 
从去年我们做的一些简单的测试

00:33:36.617 --> 00:33:38.685 
我们还添加了栈的推广

00:33:39.419 --> 00:33:42.055 
针对类实例数组常量

00:33:42.122 --> 00:33:45.058 
我们从堆栈中提取出来
相当费资源的操作

00:33:45.759 --> 00:33:46.693 
到栈

00:33:47.127 --> 00:33:52.332 
我们看到一些相当不错的提升
在我们测试的时候

00:33:53.300 --> 00:33:55.068 
同时 像我说的

00:33:55.135 --> 00:33:58.005 
我们集中优化了
字符串哈希算法

00:33:58.372 --> 00:34:00.541 
我们看到它提升很大

00:34:00.974 --> 00:34:06.413 
在我们对比字符串前缀和后缀

00:34:06.480 --> 00:34:08.447 
我们有86倍的提升

00:34:10.150 --> 00:34:14.254 
接下来 我想说一下整体的模块优化

00:34:14.955 --> 00:34:16.989 
这是去年我们引入的特性

00:34:17.056 --> 00:34:20.194 
我想给大家提醒下它是什么东西

00:34:21.428 --> 00:34:23.096 
当你看这个图表

00:34:23.463 --> 00:34:26.600 
你可以看到一个并行编译流程

00:34:27.134 --> 00:34:29.837 
一个文件进入 一个文件出去

00:34:30.237 --> 00:34:32.339 
通过全模块优化

00:34:33.273 --> 00:34:37.844 
我们扩展了编译从一个文件到多个文件

00:34:38.745 --> 00:34:42.416 
这真的很棒
因为编译器有很多信息

00:34:42.683 --> 00:34:45.585 
来写新的创新性优化

00:34:45.652 --> 00:34:47.721 
来让你的代码运行的更快

00:34:48.522 --> 00:34:52.492 
我们认为从我们的内部测试中
已经可以稳定工作了

00:34:52.926 --> 00:34:57.798 
所以今年我们将把它
作为新工程的默认值

00:34:58.699 --> 00:35:02.870 
以前的工程会有优化建议

00:35:03.170 --> 00:35:06.840 
按照它的建议 我们认为你应该接受

00:35:08.542 --> 00:35:11.445 
这里有个重要提醒
就是编译时间

00:35:12.112 --> 00:35:14.815 
就像图里展示的

00:35:14.882 --> 00:35:17.684 
你会发现编译器成了瓶颈

00:35:18.852 --> 00:35:22.055 
就像你想的
编译时间 会增加

00:35:22.723 --> 00:35:24.224 
为了抵消它

00:35:24.625 --> 00:35:26.927 
我们让编译器变得更智能

00:35:26.994 --> 00:35:29.563 
它会尽可能的缓存

00:35:30.097 --> 00:35:33.267 
来避免重新优化和编译

00:35:33.967 --> 00:35:37.871 
最后结果是
虽然你第一次编译时间

00:35:38.338 --> 00:35:41.041 
变长了

00:35:41.241 --> 00:35:44.645 
接下来 增量编译应该更快

00:35:46.780 --> 00:35:48.582 
说说代码大小

00:35:49.416 --> 00:35:53.420 
我们在这方面做了许多工作

00:35:53.487 --> 00:35:55.656 
从Swift 2.2开始

00:35:55.989 --> 00:35:57.858 
我们有了不错的结果

00:35:58.392 --> 00:36:00.794  
DemoBots是一个样例应用

00:36:00.861 --> 00:36:03.630  
你可以从developer.apple.com下载

00:36:04.264 --> 00:36:07.401  
你可以看到应用二进制文件大小减小

00:36:07.467 --> 00:36:09.203  
了差不多25%

00:36:09.736 --> 00:36:11.905  
自从Swift 2.2开始

00:36:12.339 --> 00:36:14.474  
这真的不错

00:36:15.642 --> 00:36:18.045  
好的 关于性能只有这么多

00:36:18.612 --> 00:36:21.548 
但关于Xcode还有不少可以讲的

00:36:23.183 --> 00:36:25.652 
今年Xcode我最喜欢的特性是

00:36:25.719 --> 00:36:29.523 
Swift代码浏览的提升

00:36:29.790 --> 00:36:33.527 
它对每天的开发影响很大

00:36:34.494 --> 00:36:36.196 
我们看一个例子

00:36:36.763 --> 00:36:38.332 
这里有个例子

00:36:38.999 --> 00:36:43.203 
我们创建了个整型数组
接着进行排序

00:36:43.604 --> 00:36:45.072 
你认为会发生什么

00:36:45.305 --> 00:36:49.309 
当你右击Sort跳到声明

00:36:50.744 --> 00:36:52.613 
在Xcode 7.1中

00:36:53.547 --> 00:36:56.483 
你会进入一个综合的像这样的头文件

00:36:56.917 --> 00:36:58.318 
这是什么

00:36:58.385 --> 00:37:01.121 
这是一个可变集合类型

00:37:01.722 --> 00:37:05.526 
sort这里返回
Self.Generated.Element

00:37:05.859 --> 00:37:09.029 
注释中只有一个数组的参考

00:37:09.563 --> 00:37:12.132 
所以这不是很有意义

00:37:12.199 --> 00:37:13.467 
也不是很符合逻辑

00:37:13.734 --> 00:37:16.503 
在Xcode 8中
我们做的更好一些

00:37:16.937 --> 00:37:18.372 
现在你可以看到

00:37:18.605 --> 00:37:21.508 
这里有个数组的扩展

00:37:21.942 --> 00:37:23.810 
和sorted

00:37:23.877 --> 00:37:27.481 
因为在Xcode 8中
sort被重命名为sorted

00:37:27.881 --> 00:37:30.117 
现在返回一个包含元素的数组

00:37:30.751 --> 00:37:32.352 
这真的提升了

00:37:32.586 --> 00:37:37.424 
你在Xcode中浏览代码

00:37:37.491 --> 00:37:38.859 
阅读时候更有逻辑了

00:37:40.294 --> 00:37:42.596 
同时 在标准库中

00:37:42.996 --> 00:37:45.799 
我们通过逻辑区域添加了分组

00:37:45.866 --> 00:37:49.870 
比如 数组被分组为集合

00:37:50.637 --> 00:37:52.806 
说到标准库

00:37:53.607 --> 00:37:56.243 
我们有了各种新的文档

00:37:56.944 --> 00:38:02.049 
同时协议被锁定进了API

00:38:02.115 --> 00:38:04.885 
你可以有逻辑的浏览

00:38:05.185 --> 00:38:07.888 
就像在综合接口中

00:38:09.957 --> 00:38:10.791 
谢谢

00:38:13.727 --> 00:38:16.230 
我认为你们会喜欢这部分 是的

00:38:17.331 --> 00:38:20.267 
多少人有Swift 2.2的代码？

00:38:20.734 --> 00:38:21.969 
可能有很多

00:38:22.302 --> 00:38:25.806 
所以 当然
我们像往常一样有迁移工具

00:38:26.139 --> 00:38:27.808 
但今年你需要选择

00:38:28.475 --> 00:38:32.446 
在Swift 2.3和
Swift 3之间

00:38:33.113 --> 00:38:33.947 
如果你

00:38:37.284 --> 00:38:40.254 
如果你没有准备好跳到Swift 3

00:38:40.954 --> 00:38:45.526 
Swift 2.3就是包含
新SDK的Swift 2.2

00:38:46.093 --> 00:38:46.927 
可以么

00:38:47.027 --> 00:38:50.531 
我们会接受提交到app store

00:38:50.597 --> 00:38:53.100 
的Swift 3和2.3的应用

00:38:54.001 --> 00:38:57.171 
但你应该注意Xcode中
有一些关键特性

00:38:57.237 --> 00:38:58.805 
是专门针对Swift 3的

00:38:58.872 --> 00:39:00.974 
像Playgrounds和
Documentation

00:39:01.508 --> 00:39:04.144 
和新的特性
像Thread Sanitizer

00:39:05.245 --> 00:39:08.715 
Swift 2.3
其实是个临时解决方案

00:39:09.016 --> 00:39:12.953 
让你有时间规划升级到Swift 3

00:39:13.320 --> 00:39:14.788 
所以请从今天开始规划吧

00:39:15.889 --> 00:39:17.024 
是的

00:39:19.059 --> 00:39:22.529 
如果你在用Swift 2.3
我有几个建议

00:39:23.163 --> 00:39:24.631 
这是个例子

00:39:24.698 --> 00:39:28.969 
这是个小的代码片段是2.2的

00:39:29.570 --> 00:39:33.607 
当你将Swift迁移到2.3

00:39:33.674 --> 00:39:37.511 
它会建议你在frame后添加叹号

00:39:37.578 --> 00:39:40.113 
因为核心图像API

00:39:40.180 --> 00:39:43.717 
可以编辑

00:39:44.785 --> 00:39:49.823 
现在这代码同时用Swift 2.2
和Swift 2.3编译

00:39:49.890 --> 00:39:52.726 
但如果你个复杂点的脚本

00:39:52.993 --> 00:39:55.095 
你可以选择性的编译你的代码

00:39:55.329 --> 00:39:58.765 
用#if #else语句

00:39:59.032 --> 00:40:00.367 
这是一个小的建议

00:40:02.436 --> 00:40:05.639 
当你准备好升级到Swift 3

00:40:06.707 --> 00:40:08.408 
可以使用迁移工具

00:40:08.742 --> 00:40:12.279 
编辑 转换当前的Swift语法

00:40:12.546 --> 00:40:15.415 
你可以再次体验迁移

00:40:16.216 --> 00:40:17.818 
这很简单

00:40:17.885 --> 00:40:20.087 
从今天开始计划迁移到Swift 3

00:40:21.622 --> 00:40:23.690 
这是我想说的关于工具

00:40:24.558 --> 00:40:26.059 
概括一下

00:40:27.127 --> 00:40:27.961 
概括说

00:40:28.562 --> 00:40:31.398 
Chris说了Swift 3如何

00:40:31.465 --> 00:40:33.400 
集中在基础改变

00:40:34.134 --> 00:40:37.304 
这些都公开在Swift.org

00:40:37.371 --> 00:40:38.739 
像Ted说的

00:40:38.805 --> 00:40:42.075 
你可以到那里看看是如何演进的

00:40:42.242 --> 00:40:45.913 
你还可以看到我们为
Xcode做了很棒的集成

00:40:46.713 --> 00:40:50.684 
这周还有很多信息
这仅仅是开始

00:40:50.751 --> 00:40:53.020 
我们这周有很多课程

00:40:53.253 --> 00:40:54.621 
我想推荐一个

00:40:55.055 --> 00:40:57.624 
就是Swift API设计规范

00:40:57.891 --> 00:41:00.060 
还在这个房间在这个课程结束以后

00:41:00.360 --> 00:41:01.929 
祝大家能和我们一起度过这美好的一周

00:41:02.196 --> 00:41:03.030 
谢谢