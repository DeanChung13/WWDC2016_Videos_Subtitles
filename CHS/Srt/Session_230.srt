00:00:20.020 --> 00:00:26.226
用CallKit提升VoIP应用

00:00:32.399 --> 00:00:33.433
大家好

00:00:33.800 --> 00:00:35.335
欢迎来到演讲230

00:00:35.536 --> 00:00:38.138
我是Sirisha
一名CallKit的工程师

00:00:38.605 --> 00:00:40.974
今天和我一起的还有
我的同事Stewart和Nick

00:00:41.308 --> 00:00:44.912
今天我们很兴奋地向大家
介绍一个全新的框架

00:00:45.412 --> 00:00:46.380
CallKit

00:00:49.383 --> 00:00:51.985
你们有很多人已经编写过VoIP应用

00:00:52.719 --> 00:00:55.055
你们改变了电话通讯的面貌

00:00:55.122 --> 00:00:56.790
让世界变得更小

00:00:57.891 --> 00:01:01.662
你想让你的应用成为用户
的首要选择

00:01:01.728 --> 00:01:05.331
他们用你的应用在iOS上接听电话
我们想为你们提供这方面的支持

00:01:06.200 --> 00:01:10.103
CallKit是一个框架 能够大大提升
第三方VoIP应用

00:01:10.170 --> 00:01:11.839
使它和原装应用的体验一样好

00:01:18.879 --> 00:01:19.713
谢谢

00:01:20.614 --> 00:01:22.749
因为你们很多人已经
编写过VoIP应用

00:01:22.816 --> 00:01:25.853
接下来的40分钟中
假设我们创建了

00:01:25.919 --> 00:01:28.021
一个全新的应用
叫做Speakerbox

00:01:28.655 --> 00:01:31.358
Speakerbox是一个简单的应用

00:01:31.425 --> 00:01:35.929
能在iOS上拨打与接听电话
就像现在的iOS上的软件一样

00:01:37.097 --> 00:01:39.666
在开始之前
先让我设置一个场景

00:01:40.434 --> 00:01:42.369
Jane一直在欧洲旅游

00:01:42.970 --> 00:01:45.138
关心她的父母想要联系她

00:01:45.205 --> 00:01:46.673
以确定她现在很好

00:01:47.508 --> 00:01:50.143
因为是国际长途
他们要使用Speakerbox

00:01:50.210 --> 00:01:51.311
给她打电话

00:01:52.479 --> 00:01:55.649
现在看看给Jane的来电是什么样子

00:01:57.184 --> 00:01:58.719
这是Jane的锁屏屏幕

00:01:59.653 --> 00:02:01.588
首先她收到爸爸的iMessage

00:02:02.222 --> 00:02:05.792
在她还没有回复的时候
就收到了妈妈打进来的电话

00:02:07.194 --> 00:02:08.996
Jane不能分辨

00:02:09.062 --> 00:02:12.666
iMessage通知

00:02:12.733 --> 00:02:15.402
与打入电话通知的区别

00:02:16.103 --> 00:02:19.139
因为现在的VoIP电话

00:02:19.373 --> 00:02:20.674
它仅仅是一个通知

00:02:21.642 --> 00:02:23.877
如果Jane想接听这个电话

00:02:24.178 --> 00:02:27.481
她要打开Speakerbox
输入密码

00:02:27.848 --> 00:02:31.785
连接到应用上去
然后开始讲话

00:02:34.154 --> 00:02:38.559
这是Jane开锁后的屏幕
体验很糟糕

00:02:39.459 --> 00:02:41.061
她收到妈妈打来的电话

00:02:43.130 --> 00:02:45.332
你会不小心错过这个电话吗？

00:02:46.400 --> 00:02:48.502
有可能
它仅仅是一个顶部的横条

00:02:49.736 --> 00:02:51.338
那么是不是这样更好呢？

00:02:51.405 --> 00:02:55.809
如果给Jane的来电是这个样子

00:02:56.743 --> 00:02:58.512
这是Jane的锁屏屏幕

00:02:59.146 --> 00:03:00.914
她收到妈妈打来的电话

00:03:01.481 --> 00:03:03.450
注意全屏本地用户界面

00:03:08.822 --> 00:03:12.960
Jane滑动一下就可以
接听电话和妈妈交谈了

00:03:14.528 --> 00:03:18.632
而且在解锁屏幕上也是这样

00:03:18.699 --> 00:03:21.668
同样丰富的本地用户界面
上面有接听和拒接按钮

00:03:21.735 --> 00:03:23.704
而且预先设置好的铃声会响起

00:03:29.910 --> 00:03:31.111
这样不是更好吗？

00:03:31.178 --> 00:03:34.047
如果VoIP电话能够和系统中
的其它电话互动

00:03:34.982 --> 00:03:38.218
例如本地电话、
FaceTime语音电话

00:03:38.685 --> 00:03:40.521
或者另一个VoIP电话

00:03:41.922 --> 00:03:46.460
甚至VoIP电话能够从通话记录、
常用联系人、

00:03:46.793 --> 00:03:48.595
甚至是联系人中拨打电话

00:03:49.830 --> 00:03:52.900
或者从Siri、
Bluetooth上拨打电话

00:03:53.534 --> 00:03:57.905
甚至有请勿打扰和黑名单等功能

00:03:58.705 --> 00:03:59.940
这就是CallKit

00:04:09.716 --> 00:04:12.886
今天我们将讲解CallKit的架构、

00:04:13.287 --> 00:04:16.490
打入电话流程和打出电话流程

00:04:16.557 --> 00:04:19.026
最后详细讲解一下它的API

00:04:19.560 --> 00:04:20.627
现在开始

00:04:21.361 --> 00:04:25.265
好 这儿我们有所有的系统服务
例如蓝牙、

00:04:25.332 --> 00:04:28.068
Siri、CarPlay和本地用户界面

00:04:28.402 --> 00:04:31.772
这儿有全部的VoIP应用
例如Speakerbox

00:04:32.506 --> 00:04:34.408
它们是两个独立的实体

00:04:34.708 --> 00:04:38.645
系统和服务不能获知
对Speakerbox进行的调用

00:04:39.913 --> 00:04:44.017
在iOS 10中我们已经在
系统服务中采用了CallKit

00:04:44.718 --> 00:04:48.889
现在系统通过CallKit
可以获知对蓝牙的调用

00:04:49.923 --> 00:04:52.693
如果Speakerbox想要相似的体验

00:04:52.759 --> 00:04:54.294
它要使用CallKit

00:04:55.095 --> 00:04:58.732
系统现在通过CallKit可以获知
对Speakerbox做出的调用

00:04:59.299 --> 00:05:03.604
然后系统会给其它服务
公布这些调用

00:05:04.805 --> 00:05:07.307
让我们深入讲解一下
Speakerbox

00:05:08.876 --> 00:05:11.512
现在我们有Speakerbox
和它的所有代码

00:05:12.145 --> 00:05:15.148
它和网络通信
它有自己的应用用户界面

00:05:15.916 --> 00:05:17.351
现在我们要连接CallKit

00:05:18.418 --> 00:05:21.288
在CallKit中我们关心
两个主要的类

00:05:22.055 --> 00:05:24.424
第一个是CXProvider类

00:05:25.359 --> 00:05:27.861
这个类是Speakerbox用来

00:05:27.928 --> 00:05:31.431
让系统获知

00:05:31.498 --> 00:05:32.432
发生过的带外通知

00:05:33.567 --> 00:05:36.170
第二个类是
CXCallController

00:05:36.970 --> 00:05:39.840
这个类是Speakerbox用来

00:05:39.907 --> 00:05:43.043
让系统获知本地用户的操作

00:05:44.578 --> 00:05:48.448
让我们详细了解一下这两个类
首先是供应商

00:05:49.216 --> 00:05:51.084
供应商 正如我刚才说的

00:05:51.318 --> 00:05:55.522
是让系统获知带外通知的一个类

00:05:55.989 --> 00:05:58.659
这些通知不是用户的行为

00:05:59.126 --> 00:06:01.995
他们实际是外来的事件 例如

00:06:02.062 --> 00:06:04.231
Speakerbox接到一个
打来的电话

00:06:05.098 --> 00:06:07.201
和CXCallController
对比一下

00:06:07.901 --> 00:06:11.371
CXCallController
是Speakerbox用来

00:06:11.438 --> 00:06:15.709
让系统获知来自应用内部请求的类

00:06:16.176 --> 00:06:18.478
它实际上是用户行为

00:06:19.580 --> 00:06:22.683
是内部事件 例如拨打电话的操作

00:06:24.284 --> 00:06:27.221
通过CallController
Speakerbox

00:06:27.287 --> 00:06:28.956
可以与系统的其它呼叫互动

00:06:30.190 --> 00:06:33.493
例如在一个本地电话通话时

00:06:33.560 --> 00:06:37.764
用户想从Speakerbox界面
发起一个Speakerbox通话

00:06:39.233 --> 00:06:41.034
通过使用控制器

00:06:41.101 --> 00:06:43.570
系统会获知发起通话的操作

00:06:43.871 --> 00:06:46.340
并且系统会通知
本地电话的供应商

00:06:46.406 --> 00:06:50.444
保持它的通话 从而让
Speakerbox开始它的通话

00:06:52.212 --> 00:06:54.381
让我们举一些例子说明一下

00:06:55.482 --> 00:06:59.853
供应商用来报告带外通知

00:07:00.187 --> 00:07:02.990
例如向Speakerbox发起的来电

00:07:03.924 --> 00:07:06.193
或者向外拨出的电话已经连接

00:07:06.894 --> 00:07:09.863
或者拨出的电话已被对方终止

00:07:11.064 --> 00:07:14.468
而控制器用来请求

00:07:14.735 --> 00:07:17.437
来自系统的操作 例如用户想

00:07:17.504 --> 00:07:20.974
发起一个的通话
或者用户想接听

00:07:21.041 --> 00:07:25.479
Speakerbox的来电
或者结束Speakerbox的通话

00:07:27.347 --> 00:07:29.416
当供应商想和

00:07:29.483 --> 00:07:33.587
系统通信的时候
它使用CSXCallUpdate类

00:07:34.221 --> 00:07:36.256
当系统想让Speakerbox

00:07:36.323 --> 00:07:38.125
和用户互动的时候

00:07:38.292 --> 00:07:41.862
它使用CXAction类
通知Speakerbox

00:07:43.330 --> 00:07:46.033
控制器和系统通信时

00:07:46.099 --> 00:07:49.136
用户的操作被
捆绑成CSTransaction

00:07:49.670 --> 00:07:51.972
以便让系统获知这些操作

00:07:53.941 --> 00:07:55.576
刚才讲了许多

00:07:55.843 --> 00:07:59.546
让我们看看打入电话的流程

00:08:00.814 --> 00:08:04.852
我们有Speakerbox
Jane接到了来自妈妈的呼叫

00:08:05.652 --> 00:08:10.390
呼叫来到Speakerbox以后
Speakerbox创建了CXCallUpdate

00:08:10.757 --> 00:08:12.960
并且使用供应商
把呼叫传送给系统

00:08:13.927 --> 00:08:16.363
然后系统会把呼入

00:08:16.430 --> 00:08:18.765
公布给所有的服务进程 包括用户界面进程

00:08:20.200 --> 00:08:23.437
如果Jane想通过应用界面来接听呼叫

00:08:23.504 --> 00:08:25.706
接听操作会传递给系统

00:08:26.206 --> 00:08:30.244
系统接着会告诉Speakerbox
供应商

00:08:30.544 --> 00:08:33.013
会回复CXAnswerCallAction

00:08:33.881 --> 00:08:37.150
在需要的情况下
Speakerbox会接听这个呼叫

00:08:38.150 --> 00:08:43.289
如果Jane现在想从应用界面
内结束这个通话

00:08:43.357 --> 00:08:45.125
结束操作就传递到控制器中

00:08:45.459 --> 00:08:48.161
控制器把它捆绑
传递给CXTransaction

00:08:48.562 --> 00:08:51.798
并且传递给系统
如果一切顺利的话

00:08:52.199 --> 00:08:55.169
系统把它通过供应商
返回给Speakerbox

00:08:55.569 --> 00:08:58.605
然后Speakerbox就可以结束通话

00:09:00.340 --> 00:09:02.843
下面我们让Stewart为
我们做一下演示

00:09:08.615 --> 00:09:09.650
谢谢Sirisha

00:09:09.850 --> 00:09:12.753
现在你们了解了CallKit的好处

00:09:12.819 --> 00:09:14.488
我将演示一下如何使用CallKit

00:09:14.555 --> 00:09:17.758
在一个已经做好的VoIP应用中
Speakerbox应用

00:09:17.824 --> 00:09:18.992
就是Sirisha刚才讲过的应用

00:09:19.393 --> 00:09:22.696
我首先给你们展示一下
如何用它处理一个呼入的通话

00:09:23.664 --> 00:09:26.900
我首先打开一个Speakerbox
Xscript工程

00:09:28.802 --> 00:09:32.206
在我深入讲解在应用中使用
CallKit之前

00:09:32.439 --> 00:09:34.608
让我给你们展示一下
这个应用的架构

00:09:34.675 --> 00:09:36.109
这样你就有一个参考的框架

00:09:36.510 --> 00:09:39.112
在应用中有两个主要的类

00:09:39.780 --> 00:09:43.984
SpeakerboxCallManager类
它维护应用中的通话列表

00:09:44.051 --> 00:09:48.956
它有一些操作
比如发起通话和结束通话

00:09:50.290 --> 00:09:53.026
另一个主要的类是
SpeakerboxCall

00:09:53.460 --> 00:09:56.997
这是一个模板类
表示应用中的一个通话

00:09:57.064 --> 00:10:00.367
它有关于通话的元数据
和一些回调代码区

00:10:00.434 --> 00:10:04.304
在它运行的时候我们可以得知
通话的生命周期

00:10:05.739 --> 00:10:09.209
正如Sirisha提到的 我们
使用CallKit时首先需要做的

00:10:09.276 --> 00:10:12.679
是创建CX供应商

00:10:12.746 --> 00:10:13.914
并且设置它的代理

00:10:14.381 --> 00:10:18.619
首先我要创建一个新文件叫做
供应商代理

00:10:23.724 --> 00:10:26.994
在这个新文件中我要加入一些
已经写好的新代码

00:10:27.361 --> 00:10:29.363
首先让我们看看它能做些什么

00:10:29.830 --> 00:10:32.733
在初始化程序中
我们把一个引用参数

00:10:32.799 --> 00:10:34.568
传递给SpeakerboxCallManager类

00:10:35.202 --> 00:10:38.972
使供应商代理
能够访问应用的通话列表

00:10:39.406 --> 00:10:42.409
然后通过UUID引用它们
我们在后面会演示

00:10:43.544 --> 00:10:46.647
然后我们 我们创建一个
CXProvider实例

00:10:47.214 --> 00:10:48.148
然后我们传递

00:10:48.215 --> 00:10:50.984
叫做供应商配置的东西
我们现在看到的就是

00:10:51.685 --> 00:10:53.053
供应商配置

00:10:53.120 --> 00:10:55.589
会在后面详细讲解

00:10:55.656 --> 00:10:58.926
它让应用能够配置一些系统选项

00:10:58.992 --> 00:11:00.260
以决定它的行为

00:11:01.662 --> 00:11:03.063
现在回到初始化程序

00:11:03.730 --> 00:11:08.502
我们把这个类设置为供应商代理
然后如果有必要的话

00:11:09.036 --> 00:11:11.405
我们请求使用供应商的授权

00:11:12.372 --> 00:11:13.207
好

00:11:13.273 --> 00:11:16.009
现在已经设置好了
供应商和代理

00:11:16.076 --> 00:11:18.212
我们需要在应用代理中创建这个

00:11:18.812 --> 00:11:21.481
我声明一个变量
供应商代理

00:11:22.616 --> 00:11:25.052
并且在application函数中实现了

00:11:25.118 --> 00:11:27.187
didFinishLaunchingWithOptions
方法

00:11:28.088 --> 00:11:28.922
酷

00:11:28.989 --> 00:11:31.458
现在应用中
有了一个供应商

00:11:32.392 --> 00:11:35.095
那么当有呼入的通话时
应用怎样对作出反应呢？

00:11:35.762 --> 00:11:36.930
我把它往下拉

00:11:37.397 --> 00:11:40.067
我们会看到应用现在使用PushKit

00:11:40.133 --> 00:11:42.903
通过推送通知获知呼入请求

00:11:43.704 --> 00:11:45.506
我们看看这个代码起了什么作用

00:11:46.039 --> 00:11:48.208
我们看到
它查阅了dictionaryPayload

00:11:48.275 --> 00:11:50.711
它从推送通知中查阅
并且获得一些

00:11:50.777 --> 00:11:54.448
关于呼入电话的元数据
例如UUID

00:11:54.515 --> 00:11:57.317
和代表呼入者的标识符
叫做句柄

00:11:58.318 --> 00:12:01.455
然后我们调用显示来电方法

00:12:01.922 --> 00:12:03.323
我们看 这儿的代码是

00:12:03.390 --> 00:12:06.393
应用控制本地的通知

00:12:06.560 --> 00:12:08.495
给用户显示来电

00:12:09.463 --> 00:12:10.797
但是如果使用CallKit

00:12:10.864 --> 00:12:14.101
我们不再需要本地通知来显示这个

00:12:14.635 --> 00:12:19.740
我们转而可以使用系统的
全屏本地来电用户界面

00:12:19.940 --> 00:12:22.543
我们这样做是因为
这能获得更好的体验

00:12:23.510 --> 00:12:26.713
要这样做 我将回到
供应商代理

00:12:27.214 --> 00:12:28.815
我要创建一个helper方法

00:12:29.449 --> 00:12:31.919
它让我们为
供应商调用API

00:12:33.320 --> 00:12:35.088
我将会调用reportIncomingCall方法

00:12:36.490 --> 00:12:37.658
在这个方法中

00:12:38.292 --> 00:12:41.161
我首先要创建一个
CXCallUpdate类

00:12:41.228 --> 00:12:44.431
它含有呼入电话的元数据

00:12:45.265 --> 00:12:49.002
然后我们为供应商调用
reportNewIncomingCall方法

00:12:49.303 --> 00:12:52.706
这将会告知系统来电的信息

00:12:53.841 --> 00:12:55.642
现在我们要在代码中加入异常处理

00:12:56.410 --> 00:12:57.878
我们要检查是否有异常

00:12:58.612 --> 00:13:02.616
如果没有异常我们就创建
SpeakerboxCall实例且配置它

00:13:02.783 --> 00:13:05.652
然后我们把这个通话添
加到应用的通话列表中

00:13:06.520 --> 00:13:08.522
后面我们会详细讲解

00:13:08.589 --> 00:13:10.524
为什么这儿有个异常处理？

00:13:10.791 --> 00:13:13.060
无需多说 有些情况下

00:13:13.126 --> 00:13:15.529
设备没有准备好

00:13:15.596 --> 00:13:16.864
接听来电

00:13:18.432 --> 00:13:21.168
好 现在我们的供应商代理中
有了helper方法

00:13:21.735 --> 00:13:23.270
回到我的应用代理

00:13:23.770 --> 00:13:26.707
把这些代码改为调用helper

00:13:27.574 --> 00:13:28.775
发布本地通知

00:13:30.043 --> 00:13:30.878
好

00:13:30.944 --> 00:13:32.880
现在我们使用CallKit

00:13:32.946 --> 00:13:35.315
通知呼入电话

00:13:35.382 --> 00:13:37.518
而过去我们通过推送通知获知这个消息

00:13:37.584 --> 00:13:41.255
系统使用全屏本地来电用户界面
显示了来电

00:13:42.022 --> 00:13:44.992
好 那么如果用户按下绿色按钮

00:13:45.058 --> 00:13:46.460
接听来电会发生什么呢？

00:13:47.661 --> 00:13:48.829
在这个时候

00:13:49.296 --> 00:13:52.966
供应商代理
会收到另一个方法 我们还需要实现它

00:13:54.101 --> 00:13:59.206
这就是ProviderPerformAnswer
CallAction方法

00:13:59.773 --> 00:14:01.208
让我演示一下

00:14:02.176 --> 00:14:04.044
首先我们创建一个

00:14:04.111 --> 00:14:07.314
Speakerbox call
类的实例 它和

00:14:07.381 --> 00:14:08.715
我们正接听的通话UUID相对应

00:14:09.850 --> 00:14:13.086
下面我们调用
answerSpeakerboxcall方法

00:14:13.520 --> 00:14:17.090
这些代码来自老版本的应用

00:14:17.157 --> 00:14:20.160
它和网络通信告诉它要应答这个来电

00:14:20.494 --> 00:14:23.030
我们在供应商代理
回调中这样做

00:14:24.031 --> 00:14:27.000
最后我们调用执行操作

00:14:28.001 --> 00:14:30.771
在CallKit中 每一个动作
要么被执行

00:14:30.838 --> 00:14:34.441
如果成功的话 要么执行失败
如果有异常的话

00:14:35.242 --> 00:14:37.578
这儿有几行代码

00:14:37.878 --> 00:14:41.215
如果我们找不到Speakerbox
对这个UUID的调用

00:14:41.281 --> 00:14:44.384
我们就调用failed方法
向系统报告

00:14:46.119 --> 00:14:48.755
这个方法处理对来电的应答

00:14:49.289 --> 00:14:51.491
那么如果用户如何结束通话呢？

00:14:52.059 --> 00:14:56.230
为此我们有一个相似的方法叫做

00:14:56.296 --> 00:14:58.565
ProviderPerformEndCallAction

00:14:59.499 --> 00:15:00.868
它们很相似

00:15:00.934 --> 00:15:03.904
它查询一个基于UUID的调用

00:15:04.838 --> 00:15:07.774
它使用endSpeakerBoxCall
方法和网络通信

00:15:08.575 --> 00:15:11.745
通过调用执行告知这方法执行成功

00:15:12.513 --> 00:15:14.948
然后把通话从应用的通话列表中删除

00:15:16.350 --> 00:15:18.485
现在处理呼入的通话
我们讲的差不多了

00:15:18.819 --> 00:15:20.621
还有一件事情

00:15:20.687 --> 00:15:22.456
在处理呼入的通话时应该考虑

00:15:22.856 --> 00:15:24.258
就是通话的音频

00:15:25.225 --> 00:15:26.660
使用CallKit时

00:15:26.727 --> 00:15:30.063
你不需要直接激活应用的音频会话

00:15:30.664 --> 00:15:33.767
你只需要配置音频会话

00:15:33.834 --> 00:15:36.537
系统会为你激活应用的音频会话

00:15:36.603 --> 00:15:38.338
并且提高它的优先级

00:15:38.872 --> 00:15:40.340
让我演示一下它是如何工作的

00:15:42.242 --> 00:15:45.612
回到PerformAnswerCallAction方法中

00:15:46.647 --> 00:15:49.983
我在函数configureaudiosession中
插入一个通话

00:15:51.018 --> 00:15:54.421
正如字面意思
它能配置应用的音频会话

00:15:54.488 --> 00:15:55.722
但是并没有激活它

00:15:56.857 --> 00:15:59.726
音频会话将被系统激活

00:16:00.093 --> 00:16:01.195
然后

00:16:01.261 --> 00:16:03.964
我们会收到一个返回的代理叫做
供应商

00:16:04.031 --> 00:16:05.365
didActivate audioSession

00:16:05.999 --> 00:16:08.936
从这儿开始
我们开始处理通话的音频

00:16:10.304 --> 00:16:14.875
最后一步是停止处理通话的音频

00:16:14.942 --> 00:16:17.010
它是用PerformEndCallAction
方法实现的

00:16:18.312 --> 00:16:22.983
好的 这是我们使用CallKit
处理呼入通话的所有代码

00:16:23.650 --> 00:16:27.921
现在我把设备屏幕显示在电脑屏幕上

00:16:28.322 --> 00:16:30.290
让我们编译运行设备上的应用

00:16:32.426 --> 00:16:34.094
为了本次演示

00:16:34.161 --> 00:16:37.297
我仅仅使用底部的按钮
模拟呼入通话

00:16:37.965 --> 00:16:39.166
现在我按下它

00:16:39.600 --> 00:16:42.503
我们会看到Speakerbox
的呼入请求

00:16:42.569 --> 00:16:45.305
它使用了全屏本地呼入用户界面

00:16:46.073 --> 00:16:47.841
我可以接听这个电话

00:16:48.642 --> 00:16:52.713
供应商代理就会收到
PerformAnswerCallAction方法

00:16:53.180 --> 00:16:57.317
它执行了
最后当我和Jane交谈完以后

00:16:57.551 --> 00:17:02.189
我可以结束通话和应用
供应商代理也执行了

00:17:03.257 --> 00:17:06.492
这是使用CallKit处理
呼入电话的演示

00:17:06.560 --> 00:17:08.829
现在交给Sirisha

00:17:09.128 --> 00:17:09.963
谢谢

00:17:16.036 --> 00:17:16.970
谢谢 Stewart

00:17:17.538 --> 00:17:19.839
让我们再回顾一下Stewart的演示

00:17:20.140 --> 00:17:22.175
首先 把呼入的请求

00:17:22.242 --> 00:17:25.012
通过reportnew
Incomingcall API通知给系统

00:17:25.779 --> 00:17:27.948
然后我们处理接听电话的操作

00:17:28.015 --> 00:17:30.817
通过实现代理方法
performActionAnswer

00:17:31.084 --> 00:17:32.119
CallAction

00:17:32.686 --> 00:17:34.488
然后我们接听了电话

00:17:34.555 --> 00:17:37.257
我们通过调用执行API
执行了这个操作

00:17:38.458 --> 00:17:40.627
CallKit能做的不仅仅只是接电话

00:17:41.128 --> 00:17:43.463
这个列表
列举了它支持的其它操作

00:17:43.931 --> 00:17:48.168
有保持通话、多人通话、
双音多频电话等等

00:17:49.536 --> 00:17:52.639
现在花点时间谈谈多人通话

00:17:53.273 --> 00:17:55.809
假如Speakerbox可以
处理多人通话

00:17:56.476 --> 00:17:57.878
在这儿 在这个例子中

00:17:57.945 --> 00:18:00.547
已经有一个活动的
Speakerbox通话了

00:18:00.614 --> 00:18:02.783
这时又呼入了一个电话

00:18:03.383 --> 00:18:05.485
若用户想用本地用户界面
结束这个活动的通话

00:18:05.552 --> 00:18:09.356
并且接听下一个呼叫

00:18:09.423 --> 00:18:12.326
系统就会发送CXTransaction
给Speakerbox

00:18:13.227 --> 00:18:18.899
CXTransaction就是一个
或多个操作的列表

00:18:19.132 --> 00:18:22.169
在这种情况下 那就是
结束和应答的操作

00:18:22.836 --> 00:18:25.005
一旦Speakerbox处理

00:18:25.072 --> 00:18:26.874
和执行其中的操作

00:18:26.940 --> 00:18:29.209
它需要分别完成它们

00:18:29.276 --> 00:18:32.246
这样系统知道要转换用户界面

00:18:33.647 --> 00:18:37.484
现在我要交给Nick
讲解打出电话流程

00:18:41.455 --> 00:18:42.489
谢谢Sirisha

00:18:43.190 --> 00:18:44.691
让我们继续用Jane的例子

00:18:45.359 --> 00:18:48.729
她昨天和妈妈通了电话
但是今天她有点想家了

00:18:48.795 --> 00:18:50.163
她想和家人联络

00:18:51.031 --> 00:18:53.267
让我们看看如何打出电话

00:18:57.137 --> 00:18:59.873
首先Jane要做的是到最近联系人中

00:18:59.940 --> 00:19:03.644
点击 给她的妈妈打电话
应用启动时

00:19:03.710 --> 00:19:05.412
首先出现了可能通话操作列表

00:19:06.780 --> 00:19:10.217
你们中有人可能已经看了
SiriKit的演讲介绍

00:19:11.251 --> 00:19:12.920
我们介绍了可能通话操作列表

00:19:12.986 --> 00:19:15.055
如果你想了解更多信息

00:19:15.122 --> 00:19:16.890
你可以观看在线视频

00:19:17.724 --> 00:19:19.960
一言以蔽之
可能操作列表

00:19:20.027 --> 00:19:22.296
就是期望的用户行为

00:19:22.563 --> 00:19:26.033
被打包在NSUser活动中
并且传送给应用

00:19:27.434 --> 00:19:30.604
应用收到可能通话操作列表

00:19:30.671 --> 00:19:33.540
就创建可能通话操作

00:19:33.607 --> 00:19:35.442
根据可能通话操作中的信息

00:19:36.610 --> 00:19:40.581
我们会得到相应的操作 然后通过
CallController发出请求

00:19:41.782 --> 00:19:44.985
CallController
会把操作传送给系统

00:19:45.419 --> 00:19:48.956
如果它接收了 它会通过
供应商代理返回给应用

00:19:50.224 --> 00:19:52.392
最后我们的应用会得到这个操作

00:19:52.860 --> 00:19:55.829
使用网络上必要的命令

00:19:55.896 --> 00:19:57.164
打出电话

00:19:57.965 --> 00:20:01.201
首先看看从这时开始的
呼出电话的生命周期

00:20:01.969 --> 00:20:04.404
我们已经开始进行呼出操作

00:20:05.005 --> 00:20:06.707
所以呼叫现在处于正在开始状态

00:20:08.008 --> 00:20:10.677
这时我们完成了执行这个操作

00:20:10.744 --> 00:20:13.914
执行操作把呼叫转移到已经开始状态

00:20:15.148 --> 00:20:17.618
当对方接听电话时

00:20:18.385 --> 00:20:21.788
我们会通知供应商
通话正在连接

00:20:23.156 --> 00:20:24.091
最后

00:20:24.791 --> 00:20:28.462
我们会通知供应商
通话已经连接并且通知系统

00:20:28.529 --> 00:20:30.864
双方可以通话了

00:20:32.733 --> 00:20:34.168
有请Stewart回台上

00:20:34.234 --> 00:20:35.636
做另一个演示

00:20:41.508 --> 00:20:42.409
谢谢 Nick

00:20:42.476 --> 00:20:44.478
现在我要演示第二部分

00:20:44.545 --> 00:20:46.713
如何使用CallKit
和Speakerbox

00:20:46.914 --> 00:20:49.850
这一次是如何使用它
处理呼出的通话

00:20:50.817 --> 00:20:54.154
我要再次打开一个
Speakerbox Xscript工程

00:20:55.122 --> 00:20:57.391
回到我们的应用代理类

00:20:57.991 --> 00:21:01.528
我们看到Speakerbox
现在这样处理启动

00:21:01.595 --> 00:21:03.664
用一个URL开始新的通话

00:21:04.631 --> 00:21:06.800
当用CallKit的时候

00:21:06.867 --> 00:21:09.937
拨出电话的过程是相似的

00:21:10.470 --> 00:21:14.141
但是当用户从这些场合中
发起通话的时候 例如电话应用、

00:21:14.208 --> 00:21:18.145
最近联系人、联系人
卡片或者Siri

00:21:18.212 --> 00:21:20.147
应用启动时有可能操作列表

00:21:20.214 --> 00:21:23.250
并且会通过NSUser活动传递给我们

00:21:24.218 --> 00:21:27.454
这儿使用CallKit的第一步是

00:21:27.521 --> 00:21:31.658
实现applicationContinue
UserActivity方法

00:21:32.793 --> 00:21:34.494
看看是怎么做的吧

00:21:34.928 --> 00:21:37.865
先看看
NSUser活动

00:21:38.232 --> 00:21:40.767
我们要得到startCallHandle
变量的值

00:21:41.668 --> 00:21:45.038
这些代码我们已经写好了
查看NSUser活动

00:21:45.472 --> 00:21:48.342
得到可能操作列表 返回句柄

00:21:48.408 --> 00:21:51.211
它是一个字符串代表我们
想要把电话打给何人

00:21:52.446 --> 00:21:53.847
现在一旦我们有了句柄

00:21:54.281 --> 00:21:58.652
开始新通话的过程就等于
上面的URL句柄

00:21:58.952 --> 00:22:01.955
我们仅仅是在通话管理器中
调用了开始通话方法

00:22:03.257 --> 00:22:05.125
现在看看这个方法做了什么

00:22:06.793 --> 00:22:09.696
我们可以在
SpeakerboxCallManager类中看到

00:22:09.763 --> 00:22:13.033
我们通过创建模板类的一个新实例
就开始了一个通话

00:22:13.100 --> 00:22:14.301
Speakerbox通话

00:22:14.968 --> 00:22:17.971
然后我们调用
StartSpeakerBoxCall方法

00:22:18.338 --> 00:22:20.941
它会和网络通信 然后开始发起通话

00:22:21.608 --> 00:22:25.012
最后还把这个通话加入
到通话列表中

00:22:26.113 --> 00:22:28.749
但是现在还没有使用
CallKit来通知系统

00:22:28.815 --> 00:22:30.584
我们打算发起一个新的通话

00:22:30.918 --> 00:22:32.019
我们需要这样做

00:22:32.486 --> 00:22:34.555
所以我现在要删除这些代码

00:22:34.621 --> 00:22:36.690
过一会儿我还要把某些部分添加回来

00:22:38.425 --> 00:22:41.361
在这个类中采用CallKit
首先要

00:22:41.428 --> 00:22:42.663
导入框架

00:22:45.098 --> 00:22:48.702
然后我需要Sirisha
提到的第二个类

00:22:48.769 --> 00:22:50.571
CXCallController

00:22:52.039 --> 00:22:55.542
现在在开始通话方法里已经有了

00:22:56.543 --> 00:22:59.046
我需要创建
startCallAction

00:22:59.112 --> 00:23:02.015
然后用我想拨出的句柄配置它

00:23:03.383 --> 00:23:06.954
然后创建CXTransaction
它含有有上面的操作

00:23:07.921 --> 00:23:10.924
最后我在callController中
调用请求事务

00:23:10.991 --> 00:23:13.193
请求系统执行操作

00:23:14.161 --> 00:23:17.531
现在仅仅是重复Sirisha
提到的这一点

00:23:17.931 --> 00:23:20.901
你可能想知道为什么我们
需要向系统请求这个事务

00:23:20.968 --> 00:23:23.804
其实看起来这一切只是

00:23:23.871 --> 00:23:25.339
发生在应用的内部

00:23:26.106 --> 00:23:29.009
原因是当你试图

00:23:29.076 --> 00:23:30.344
发起一个通话的时候

00:23:30.410 --> 00:23:33.080
系统可能已经有了一个
其它的通话正在进行

00:23:33.146 --> 00:23:36.517
例如 如果用户使用本地电话、
FaceTime电话

00:23:36.884 --> 00:23:38.619
或者其它的VoIP应用电话

00:23:39.119 --> 00:23:43.423
如果这样的话 系统需要在你的通话
开始之前保留原来的通话

00:23:43.924 --> 00:23:46.426
为什么我们需要
从系统层请求操作

00:23:46.693 --> 00:23:48.595
要让系统知道这些操作

00:23:51.298 --> 00:23:55.569
现在 一旦系统接收并且
改善了我们的开始通话操作

00:23:55.936 --> 00:23:59.907
它要通过供应商代理
把这个操作发送回给应用

00:24:00.674 --> 00:24:03.911
所以我需要实现供应商代理
的另一个方法

00:24:04.645 --> 00:24:08.649
它叫做provider perform
StartCallAction方法

00:24:09.316 --> 00:24:10.584
让我们一起写这些代码吧

00:24:11.852 --> 00:24:14.555
和以前一样 我们首先

00:24:14.621 --> 00:24:17.090
创建一个Speakerbox call
模板实例

00:24:17.324 --> 00:24:20.027
然后用我们用拨出
通话的句柄来配置它

00:24:20.961 --> 00:24:24.798
然后配置音频会话
这和以前一样

00:24:24.865 --> 00:24:28.135
当应答不同时间打来的电话时

00:24:28.268 --> 00:24:30.804
我们需要在通话上配置一些属性

00:24:31.371 --> 00:24:33.874
这儿的代码很多 让我们梳理一下

00:24:34.675 --> 00:24:37.878
我们为通话设置两个通话返回代码区

00:24:38.545 --> 00:24:43.383
hasStartedConnectingDidChange和
hasConnctedDidChange

00:24:44.184 --> 00:24:47.287
它们是异步的通话返回代码区
它们会被激活

00:24:47.354 --> 00:24:49.756
当通话由已连接状态

00:24:49.823 --> 00:24:52.259
进入正在连接状态
然后再进入已连接状态

00:24:52.893 --> 00:24:54.561
在这些通话返回代码区中

00:24:54.895 --> 00:24:57.664
我们向系统报告通话的过程

00:24:57.731 --> 00:25:01.001
这样系统就会知道
并且在界面中显示出来

00:25:02.169 --> 00:25:06.807
设置好了以后 我们就可以
调用startSpeakerboxCall方法

00:25:06.874 --> 00:25:07.741
在通话时

00:25:08.008 --> 00:25:10.878
它会再次同网络通信 然后拨出电话

00:25:11.745 --> 00:25:15.249
完成了这个操作就可以
向系统报告操作成功

00:25:15.949 --> 00:25:17.985
并且把通话添加到
通话管理列表中

00:25:20.821 --> 00:25:24.057
好 这是对呼出通话的处理

00:25:24.124 --> 00:25:26.927
但是如果用户想结束通话
我们该怎么做呢？

00:25:26.994 --> 00:25:29.463
从我们自己的--应用自己的用户界面上

00:25:30.464 --> 00:25:33.967
这样我们需要回到
Speakerbox callManager类中

00:25:34.034 --> 00:25:35.335
看看结束通话方法

00:25:36.036 --> 00:25:39.806
在这儿 我们可以看到
和前面的发起通话方法一样

00:25:39.873 --> 00:25:41.375
它还没有使用CallKit

00:25:41.875 --> 00:25:43.877
所以我要替换一下代码

00:25:44.845 --> 00:25:49.583
我把它拖进来
看看 我们创建了结束通话操作

00:25:50.017 --> 00:25:51.785
它被打包成事务

00:25:52.052 --> 00:25:54.821
从callController可以
请求这个事务

00:25:55.956 --> 00:25:58.425
这一次你不需要在
供应商代理中做任何改动

00:25:58.492 --> 00:26:01.361
因为你可以看到

00:26:01.428 --> 00:26:03.764
我们已经在前面的演示中实现了这个

00:26:04.998 --> 00:26:07.668
这就是我们处理
呼出通话的所有代码

00:26:07.868 --> 00:26:11.138
现在我要在设备上编译和运行应用
给你们另一个演示

00:26:17.110 --> 00:26:20.047
我已经在设备上编译和更新了应用

00:26:20.280 --> 00:26:21.548
为了给你们演示呼出通话

00:26:21.615 --> 00:26:26.286
我想回到联系人卡中的电话应用

00:26:26.687 --> 00:26:31.058
现我们能够看到Speakerbox
应用列在联系人卡中了

00:26:31.592 --> 00:26:34.194
我只要点击这儿就可以运行应用

00:26:34.461 --> 00:26:36.763
应用启动了

00:26:36.830 --> 00:26:38.665
它会收到可能操作列表

00:26:38.999 --> 00:26:42.936
使用callController
开始一个通话

00:26:43.637 --> 00:26:46.940
它会请求系统支持的一个事务

00:26:47.307 --> 00:26:51.144
提供给供应商代理
然后供应商代理执行操作

00:26:51.845 --> 00:26:53.914
现在看 就是这样

00:26:53.981 --> 00:26:55.482
现在通话正在进行

00:26:57.451 --> 00:27:02.155
现在正在通话 如果我按下home键
退出 我们能看到一些新鲜玩意

00:27:02.589 --> 00:27:06.059
竟然出现了绿色的双倍高度的状态条

00:27:06.126 --> 00:27:08.262
在显示我们的应用正在运行

00:27:08.829 --> 00:27:11.164
以前这是本地电话

00:27:11.231 --> 00:27:13.934
和FaceTime电话专用的
如果我点击它

00:27:14.168 --> 00:27:16.303
将会回到Speakerbox通话页面

00:27:20.240 --> 00:27:21.108
谢谢！

00:27:21.742 --> 00:27:24.645
当通话结束的时候
我点击结束通话

00:27:24.711 --> 00:27:27.848
这会向系统发出请求 终止通话操作

00:27:27.915 --> 00:27:29.449
供应商代理
会执行这个操作

00:27:30.450 --> 00:27:34.454
这是使用CallKit处理
呼出通话的所有演示

00:27:34.521 --> 00:27:38.292
现在交回给Nick回顾一下
然后介绍几个别的API

00:27:38.592 --> 00:27:39.426
谢谢

00:27:46.400 --> 00:27:47.267
谢谢 Stewart

00:27:47.768 --> 00:27:50.437
首先快速回顾一下刚才的内容

00:27:53.140 --> 00:27:56.643
首先是Speakerbox
收到可能通话列表

00:27:57.411 --> 00:27:59.580
基于这个列表创建了开始通话操作

00:27:59.813 --> 00:28:01.715
然后请求开始通话操作

00:28:02.816 --> 00:28:05.953
开始通话操作通过
供应商代理被接收

00:28:06.386 --> 00:28:08.188
然后执行

00:28:09.156 --> 00:28:13.360
最后 Speakerbox报告
通话成为正在连接状态

00:28:13.861 --> 00:28:15.395
然后是已经连接状态

00:28:17.998 --> 00:28:21.201
这是基本的流程

00:28:21.802 --> 00:28:23.837
现在让我们深入研究
一下API的细节

00:28:23.904 --> 00:28:25.706
以便充分的使用CallKit

00:28:26.507 --> 00:28:30.611
我们要尤其关注供应商授权

00:28:30.677 --> 00:28:34.214
和配置
它们帮助在本地用户界面中定制应用

00:28:34.915 --> 00:28:37.518
我们看看如何处理操作异常

00:28:37.584 --> 00:28:39.019
和系统约束

00:28:39.353 --> 00:28:41.755
最后看看CallKit

00:28:41.822 --> 00:28:44.091
在应用的通话音频扮演什么角色

00:28:47.394 --> 00:28:51.798
所以和其它API一样
例如联系人和定位

00:28:52.499 --> 00:28:54.801
CallKit要求用户的使用许可

00:28:55.335 --> 00:28:56.336
因此

00:28:56.403 --> 00:28:59.239
应用在启动的时候
首先要做的是

00:28:59.306 --> 00:29:01.775
检查它当前授权的状态

00:29:02.476 --> 00:29:05.112
因为从上次启动应用以来
它可能发生了变化

00:29:05.179 --> 00:29:08.348
如果用户设置激活或者终止你的应用

00:29:09.616 --> 00:29:10.751
那么现在

00:29:10.817 --> 00:29:13.220
如果你发现应用的授权状态

00:29:13.287 --> 00:29:17.324
还没有确定
你应该请求应用的授权

00:29:18.192 --> 00:29:21.028
这就是
告诉操作系统给用户展示一个

00:29:21.094 --> 00:29:23.197
警告 请求获得许可

00:29:23.931 --> 00:29:25.566
这是为你的应用做出的授权

00:29:26.066 --> 00:29:29.069
因为这是为你的应用做出的授权
你应该确定

00:29:29.136 --> 00:29:32.840
在应用的info.plist中包含
应用字符串 提供相应的信息

00:29:35.475 --> 00:29:37.544
最后 当应用启动的时候

00:29:37.945 --> 00:29:40.180
你应该确定时刻监听

00:29:40.247 --> 00:29:42.716
可能发生的授权状态的改变

00:29:43.717 --> 00:29:46.253
这样你能一直为用户显示
最新的用户界面

00:29:49.790 --> 00:29:52.226
现在谈谈供应商配置

00:29:53.026 --> 00:29:55.629
供应商配置使你的应用

00:29:55.729 --> 00:30:00.701
直接在本地或者通话用户界面中
定制通话体验

00:30:02.836 --> 00:30:06.240
可以定制

00:30:06.306 --> 00:30:08.442
为你的通话显示应用的本地名称

00:30:09.610 --> 00:30:11.478
这包括特定的功能

00:30:11.545 --> 00:30:14.181
例如应用是否支持视频通话

00:30:15.415 --> 00:30:16.550
这甚至包括

00:30:16.617 --> 00:30:20.954
是否指定自己定制的图像
直接显示在

00:30:21.021 --> 00:30:22.990
终端用户界面的按钮处

00:30:23.490 --> 00:30:26.927
当点击的时候
会让用户直接启动应用

00:30:28.295 --> 00:30:30.797
记一下 对于本应用图标的支持

00:30:30.864 --> 00:30:32.833
在下一个版本会实现

00:30:36.570 --> 00:30:40.407
到目前为止我们看到了
执行顺畅的时候应用的表现

00:30:40.474 --> 00:30:42.543
但是如果碰到问题会怎样呢？

00:30:43.277 --> 00:30:45.612
看看前面拨出电话的例子吧

00:30:46.580 --> 00:30:50.217
我们已经执行了开始通话操作

00:30:50.851 --> 00:30:54.221
但是在执行的过程中
我们碰到了异常

00:30:54.922 --> 00:30:57.591
也许是和网络服务器连接不好

00:30:57.658 --> 00:30:59.626
导致我们无法拨出电话

00:31:00.727 --> 00:31:04.498
在这种情况下 我们要终止通话操作

00:31:05.499 --> 00:31:09.269
这很重要是因为它要通知
操作系统

00:31:09.336 --> 00:31:10.637
出问题了

00:31:11.004 --> 00:31:12.973
操作系统反过来

00:31:13.607 --> 00:31:17.044
会通过调用失败用户界面通知用户

00:31:19.179 --> 00:31:22.583
同这些操作异常密切相关的是
操作失败时间

00:31:23.917 --> 00:31:28.121
系统的每一个操作都有和它关联的
特定的失败时间

00:31:28.822 --> 00:31:31.391
这些失败时间很重要
因为它们确保

00:31:31.458 --> 00:31:35.462
用户发出的操作

00:31:35.529 --> 00:31:38.498
以操作和回应的方式进行

00:31:39.399 --> 00:31:42.236
因此
应用应该总是确保

00:31:42.302 --> 00:31:45.339
在一定时间内来执行这些操作

00:31:46.707 --> 00:31:49.443
如果某个操作超时了

00:31:50.043 --> 00:31:54.081
应用会通过合适的
供应商代理方法得到通知

00:31:54.147 --> 00:31:56.116
同时做出合适的反应

00:32:00.687 --> 00:32:03.257
根据设备当时的状态

00:32:03.323 --> 00:32:05.792
一定的系统约束是必要的

00:32:06.793 --> 00:32:09.296
让我们用打入电话作为例子

00:32:10.564 --> 00:32:13.433
你的呼叫

00:32:13.500 --> 00:32:17.638
应用的打入呼叫被拒绝了
可能因为

00:32:17.704 --> 00:32:21.508
用户停止了应用
它不再被授权使用

00:32:22.643 --> 00:32:25.279
或者拨入电话者

00:32:25.345 --> 00:32:26.747
在接入电话的黑名单中

00:32:27.581 --> 00:32:29.917
或者用户启用了
禁止打扰功能

00:32:30.350 --> 00:32:33.120
现在不想接任何电话

00:32:34.955 --> 00:32:36.590
对于所有这些情况

00:32:37.024 --> 00:32:40.894
应用会通过API的
完成句柄得到通知

00:32:41.995 --> 00:32:44.831
例如 reportNewIncomingCall
API

00:32:44.898 --> 00:32:47.134
在完成句柄中会返回一个错误代码

00:32:48.035 --> 00:32:52.472
你看 应用检查了返回的错误代码

00:32:53.006 --> 00:32:56.009
看到错误代码是禁止打扰

00:32:56.543 --> 00:32:58.045
就会做出相应的处理

00:32:59.446 --> 00:33:02.216
现在让我们看看CallKit的音频

00:33:03.750 --> 00:33:07.955
有了CallKit的通话音频
应用得到很多好处

00:33:08.255 --> 00:33:10.090
最大的好处是

00:33:10.424 --> 00:33:14.728
它的音频会话在系统中的
优先级会得到很大提高

00:33:14.795 --> 00:33:17.431
同本地电话和
FaceTime电话不相上下

00:33:18.232 --> 00:33:21.468
这意味着系统上的其它应用不能

00:33:21.535 --> 00:33:23.337
打断你的应用的通话音频

00:33:24.838 --> 00:33:26.139
除此之外

00:33:26.640 --> 00:33:29.943
CallKit能分辨系统的
特定音频路由

00:33:30.677 --> 00:33:34.548
这意味着它能知道如何路由音频
根据

00:33:34.615 --> 00:33:37.784
用户的当前访问配置

00:33:37.851 --> 00:33:40.454
还是当前连接的蓝牙设备

00:33:42.990 --> 00:33:46.627
让我们把呼入电话流程作为例子

00:33:47.361 --> 00:33:49.663
我们知道在接到电话以后
应用

00:33:50.097 --> 00:33:54.401
会收到回应呼叫操作
然后执行这个操作

00:33:55.702 --> 00:33:58.505
在收到回应呼叫操作以后应该

00:33:58.572 --> 00:34:00.841
配置音频会话

00:34:01.308 --> 00:34:03.977
因为我们知道
通话很快就会进入已连接状态

00:34:05.312 --> 00:34:07.581
当我们执行回应呼叫操作以后

00:34:08.581 --> 00:34:11.618
系统会自动为应用
开启一个音频会话

00:34:11.685 --> 00:34:14.054
而且具有很高的优先级

00:34:14.721 --> 00:34:16.623
然后让应用知道这些已经完成

00:34:17.157 --> 00:34:20.527
这是通过did activateaudiosession
Providerdelegatecallback告知的

00:34:21.328 --> 00:34:22.996
这实际是通知应用

00:34:23.563 --> 00:34:26.033
应该为通话开启多媒体了

00:34:26.667 --> 00:34:29.870
这是对API 的细节的
简要介绍

00:34:29.937 --> 00:34:32.672
它们帮助我们使用CallKit

00:34:37.511 --> 00:34:41.681
现在我们邀请你在创建的
VoIP 应用中采用CallKit

00:34:42.014 --> 00:34:45.118
或者使用CallKit创建一个
全新的VoIP 应用

00:34:46.353 --> 00:34:50.757
使用CallKit你将直接调用
整合系统的底层驱动

00:34:51.692 --> 00:34:55.062
一旦你使用了CallKit
你的应用将获得

00:34:55.128 --> 00:34:56.964
和本地电话服务平等的功能

00:34:57.965 --> 00:34:59.166
最重要的是

00:34:59.566 --> 00:35:02.970
使用CallKit你的应用将

00:35:03.036 --> 00:35:05.939
在系统中是可见的
无论是在全屏、

00:35:06.006 --> 00:35:10.244
锁屏的来电提醒、最近来电、

00:35:10.310 --> 00:35:14.715
常用联系人和联系人中 还是和Siri、

00:35:14.781 --> 00:35:16.350
CarPlay和Bluetooth的整合中

00:35:19.186 --> 00:35:21.622
要获得更多信息请查阅我们的演讲网址

00:35:21.688 --> 00:35:23.090
developer.apple.com

00:35:23.457 --> 00:35:25.826
那儿也有Speakerbox
的示例代码

00:35:25.893 --> 00:35:27.995
这个演讲中
我们也一直在引用上面的代码

00:35:29.696 --> 00:35:32.065
我们有很多精彩的相关演讲

00:35:32.366 --> 00:35:35.769
一定要参阅关于Siri、
可能操作列表、

00:35:35.836 --> 00:35:37.237
网络和音频的更多信息

00:35:38.672 --> 00:35:41.341
非常感谢你们的到来
希望在实验室里看到你们