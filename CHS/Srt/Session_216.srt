00:00:19.586 --> 00:00:24.291 
UIkit 动画和过渡的新进展

00:00:29.830 --> 00:00:30.931 
下午好

00:00:32.299 --> 00:00:33.734 
我是Bruce Nilo

00:00:33.834 --> 00:00:36.470 
我是UIKit的一名工程经理

00:00:36.870 --> 00:00:41.575 
今天 我和我的同伴
Mike Turner都非常兴奋

00:00:41.808 --> 00:00:44.645 
我们会介绍一些新的动画API

00:00:44.711 --> 00:00:47.848 
在iOS 10中的UIKit
将会包含这些新特性

00:00:48.448 --> 00:00:51.752 
我们相信这些API将会让你更简单的

00:00:51.818 --> 00:00:54.888 
创建自然的 顺畅的

00:00:54.955 --> 00:01:00.060 
和可响应的应用

00:01:00.961 --> 00:01:04.598 
今天我们会先快速重温一下

00:01:04.965 --> 00:01:09.837 
UIKit中已有的
一些隐式动画API

00:01:10.504 --> 00:01:12.840 
然后我们会深入的介绍一个全新的类

00:01:12.906 --> 00:01:16.410 
我们叫它UIViewPropertyAnimator

00:01:17.511 --> 00:01:21.782 
我们还会介绍一些
用于视图控制器切换的扩展

00:01:21.949 --> 00:01:24.818 
以便于你们更好的使用这些新类

00:01:26.386 --> 00:01:31.024 
Mike将上台给大家一个很棒的展示
展示如何使用这些新的API

00:01:31.091 --> 00:01:33.594 
还有一个全新的图片应用的例子

00:01:33.660 --> 00:01:35.929 
不久你就可以下载到

00:01:36.964 --> 00:01:40.100 
我们还会讨论一些细微的问题

00:01:40.167 --> 00:01:43.337 
关于这些新类的触摸处理和点击测试

00:01:43.904 --> 00:01:45.839 
和该如何使用这些新的类

00:01:45.906 --> 00:01:49.276 
来创建甚至可以被中断的关键帧动画

00:01:51.078 --> 00:01:54.948 
UIKit中的隐式属性动画

00:01:55.415 --> 00:01:59.219 
基本上是为了

00:01:59.920 --> 00:02:04.625 
让你可以创建动态的内容

00:02:04.691 --> 00:02:10.163 
你可以通过设置视图的属性
并让动画在一段时间内发生

00:02:12.999 --> 00:02:18.672 
它是隐式的
因为UIKit为你创建了动画

00:02:18.739 --> 00:02:21.208 
值变化时会被记下来

00:02:21.275 --> 00:02:25.879 
用原始值和最后的值做个差值

00:02:25.946 --> 00:02:29.983 
这个值会在你指定的时间段上

00:02:30.050 --> 00:02:34.821 
用一个可选的定时函数决定
这个动画的节奏

00:02:36.290 --> 00:02:37.991 
我们再具体的介绍下

00:02:38.759 --> 00:02:41.128 
这里有一个非常简单的动画

00:02:41.595 --> 00:02:44.898 
今天的展示中我们会一直使用这个例子

00:02:44.965 --> 00:02:48.035 
我们有个圆基本就是从左到右来运动

00:02:48.836 --> 00:02:51.538 
通过设置视图的中心属性来让其运动

00:02:51.605 --> 00:02:55.742 
在这个图中我们看到一个虚线圆形

00:02:55.809 --> 00:02:57.845 
或者是一个虚线正方形
它代表了视图

00:02:57.911 --> 00:02:59.880 
在实际动画中你看到的样子

00:03:00.247 --> 00:03:03.383 
而实线形状代表目标值

00:03:03.450 --> 00:03:06.887 
我们也分别把它们叫做模型值和展示值

00:03:07.921 --> 00:03:12.626 
我们开始这个动画
然后它以一定的速度进行

00:03:12.693 --> 00:03:15.762 
实际上你会注意到这个速度是恒定的

00:03:16.630 --> 00:03:18.665 
问题是今天我们将要怎么做

00:03:19.099 --> 00:03:20.534 
今天的实现将会很简单

00:03:21.468 --> 00:03:25.239 
你们中大部分可能熟悉
animateWithDuration API

00:03:26.139 --> 00:03:30.177 
在这个例子中 我们指定在X轴上

00:03:30.244 --> 00:03:33.180 
圆的中心应该从0移动到100

00:03:35.916 --> 00:03:39.586 
现在定时函数可设置为.linear

00:03:39.653 --> 00:03:42.022 
简单来说它表示一个特性函数

00:03:42.089 --> 00:03:45.392 
我们快速介绍下在UIKit中
什么是定时函数

00:03:45.759 --> 00:03:52.232 
它是一个三次函数
映射"0到1"到"0到1"

00:03:52.366 --> 00:03:53.901 
同时有两个约束

00:03:53.967 --> 00:03:56.170 
就是说 在动画开始的时候

00:03:56.236 --> 00:03:58.572 
即在一开始时

00:03:58.772 --> 00:04:03.377 
动画进行的速度值就是这个开始值

00:04:03.810 --> 00:04:05.479 
结束的时候 就是结束值

00:04:06.313 --> 00:04:13.020 
现在定时函数不定义你的动画速度了

00:04:13.320 --> 00:04:19.125 
现在通过这个夸大的渐入定时函数
可以很容易的实现

00:04:19.692 --> 00:04:22.796 
你会注意到动画进行到一半时

00:04:23.330 --> 00:04:25.632 
它的进度移动很少

00:04:25.999 --> 00:04:28.702 
它真的时进行的相当的慢

00:04:29.403 --> 00:04:32.406 
我们差不多离完成有90%了

00:04:32.773 --> 00:04:34.374 
但我们还是只到了一半的位置

00:04:34.908 --> 00:04:37.811 
在你指定时间的最后10%里

00:04:37.878 --> 00:04:39.680 
我们将会完成剩下的距离

00:04:39.746 --> 00:04:41.748 
简单说 它会加速

00:04:41.982 --> 00:04:46.787 
从速度非常慢到非常快直到最后

00:04:47.054 --> 00:04:49.022 
这就是定时函数的作用

00:04:50.490 --> 00:04:55.395 
现在UIKit有四个定时函数

00:04:55.629 --> 00:04:58.398 
这些是特定的三次贝塞尔函数实例

00:04:58.465 --> 00:05:00.767 
这是我们以前看到的特定函数

00:05:01.001 --> 00:05:02.402 
这是渐入渐出

00:05:03.804 --> 00:05:06.807 
这是渐入

00:05:08.442 --> 00:05:11.578 
最后 这是渐出

00:05:12.746 --> 00:05:15.282  
这些是我们提供的非常细微的函数

00:05:15.349 --> 00:05:19.052  
将会影响一部分动画的感觉

00:05:22.022 --> 00:05:23.423  
关于回弹会有什么呢

00:05:24.091 --> 00:05:27.995 
我们也有隐式的动画API
提供给你来设置一个回弹

00:05:28.529 --> 00:05:30.764 
我们不会否认如果你想说

00:05:30.831 --> 00:05:32.499 
"那不是实际的插值

00:05:32.566 --> 00:05:36.170 
我们把这个值做得
有点过并且有点回弹"

00:05:36.970 --> 00:05:40.474 
然而 接下来 大家可以都

00:05:40.541 --> 00:05:43.877 
想一下把回弹作为
另一种类型的定时函数

00:05:44.411 --> 00:05:46.113 
现在看看我们为什么能这么做

00:05:46.580 --> 00:05:48.916 
来看看这个简单的应用

00:05:48.982 --> 00:05:51.618 
我们让一个方块从左面移动到了右面

00:05:54.388 --> 00:05:57.758 
我们绘制了位置移动图

00:05:57.824 --> 00:06:01.595 
在方块移动的过程中

00:06:01.662 --> 00:06:03.764 
它有点像定时函数

00:06:03.830 --> 00:06:05.365 
实际上它不是立方函数

00:06:05.632 --> 00:06:07.835 
我们过度设置了它的值

00:06:07.901 --> 00:06:12.406 
但我们仍可认为
它是可以影响动画的速度的

00:06:12.539 --> 00:06:16.877 
接下来的API中
我们将会对回弹动画进行分类

00:06:18.545 --> 00:06:22.783 
现在在iOS 8中有另一个重要的
用来制造动画的版本

00:06:23.283 --> 00:06:24.685 
我告诉你这些

00:06:24.751 --> 00:06:27.487 
因为稍后我们还会谈到它

00:06:28.555 --> 00:06:34.194 
简单说 考虑一个动画
在动画进行的中间改变

00:06:34.261 --> 00:06:36.029  
所以你将从一个位置到另一个位置

00:06:36.096 --> 00:06:37.731  
到一半的时候 你变了

00:06:37.931 --> 00:06:44.204  
在iOS 8以前 如果你这么做
你的动画将会有一个中断

00:06:44.438 --> 00:06:46.640  
除非制定了一个特别的配置

00:06:46.707 --> 00:06:50.911  
UIViewAnimationOption
BeginFromCurrentState

00:06:51.278 --> 00:06:53.947  
如果你这么做了
将会看起来好一点

00:06:54.681 --> 00:06:56.683  
将不会有间断和跳跃

00:06:56.950 --> 00:06:58.418  
但是仍然不会顺滑

00:06:58.485 --> 00:07:01.054  
速度变化的很突然

00:07:02.055 --> 00:07:07.528  
在iOS 8中
我们做了一个重大改变

00:07:07.895 --> 00:07:10.464  
动画中的特定的属性被渐进的完成

00:07:10.531 --> 00:07:13.600  
我们没有移除之前的动画
我们把后来的加了上去

00:07:13.667 --> 00:07:16.370  
这样能平滑处理速度的变化

00:07:17.538 --> 00:07:22.809  
通过使用新的UIViewPropertyAnimator
第一种情况就不会再存在了

00:07:25.345 --> 00:07:29.983 
好的 现在我们看看新的类
我们已经快速浏览了

00:07:31.718 --> 00:07:32.719 
它的一些特性

00:07:32.786 --> 00:07:33.787 
我们已经很熟悉了

00:07:34.054 --> 00:07:38.825 
如果你熟悉以前的
animateWithDuration配套的API

00:07:38.892 --> 00:07:41.962 
新的API你也不会陌生

00:07:42.396 --> 00:07:43.430 
它是可以被中断的

00:07:43.497 --> 00:07:46.200 
这意味着你可以暂停和停止动画

00:07:46.834 --> 00:07:50.137 
你可以打磨它们
意思就是说你可以让它前进后退

00:07:50.204 --> 00:07:53.640 
用你喜欢的方式
基于这个可编程的API

00:07:54.308 --> 00:07:55.275 
你可以反转它们

00:07:55.342 --> 00:07:57.778 
你可以说
别担心 往回走

00:07:58.445 --> 00:08:01.548 
我们将会介绍一整套定时函数

00:08:01.615 --> 00:08:03.784 
而不仅仅是以前的那四个

00:08:03.851 --> 00:08:08.755 
通过回弹动画的一种小的子集

00:08:09.723 --> 00:08:11.358 
最后 当动画运行时

00:08:11.425 --> 00:08:15.162 
往上添加动画将会非常简单

00:08:16.763 --> 00:08:20.767 
但是介绍这些API有点困难

00:08:20.834 --> 00:08:24.972 
所以我不打算做这挠头的事

00:08:25.205 --> 00:08:28.108 
让我们大体看一下
这些API是什么样子

00:08:28.342 --> 00:08:32.145 
在所有这些新类的中心是
UIViewPropertyAnimator

00:08:32.645 --> 00:08:36.416 
它实现了两个新的协议

00:08:37.484 --> 00:08:40.453 
把它们作为协议实现的原因

00:08:40.520 --> 00:08:43.890 
或实现这两个新的协议
我们将会看到它会非常有用

00:08:43.957 --> 00:08:46.527 
当我们把它
和视图控制器切换放在一起使用时

00:08:48.095 --> 00:08:49.663  
当你创建一个属性动画生成器

00:08:49.730 --> 00:08:51.598  
你将会创建一个新的对象类型

00:08:51.665 --> 00:08:54.735  
这会高效的指定定时函数

00:08:54.801 --> 00:08:57.337  
将会使用在你的动画中

00:08:57.437 --> 00:09:00.340  
我们提供了两个新的具体的类来实现

00:09:01.208 --> 00:09:04.545 
我们已经引入了一些新的枚举

00:09:04.811 --> 00:09:07.614 
以供协议中的方法使用

00:09:07.681 --> 00:09:13.053 
例如 动画生成器的状态可以为非活动
活动或者停止

00:09:13.253 --> 00:09:15.856 
一会我们再讨论这些

00:09:16.557 --> 00:09:18.659 
我们也引入了位置

00:09:18.959 --> 00:09:21.795 
即动画停止的地方

00:09:21.862 --> 00:09:24.731 
动画会遍历所有我们设定的地方么

00:09:24.798 --> 00:09:26.800 
我们是通过反转它来回到开始位置么

00:09:26.867 --> 00:09:31.004 
或者我们可能打断了它
还有可能其他的实现

00:09:31.805 --> 00:09:32.673 
好的

00:09:34.541 --> 00:09:37.845 
我们先来集中在这个图的中间部分

00:09:38.745 --> 00:09:42.015  
然后我们会简要说下
所有的这些新的定时函数

00:09:43.584 --> 00:09:47.688 
那么我们来看看这个角上的API

00:09:47.754 --> 00:09:50.624 
它被定义在UIViewAnimating协议中

00:09:50.691 --> 00:09:52.025 
有趣的地方都在这

00:09:52.092 --> 00:09:53.427 
实际上这非常的简单

00:09:53.493 --> 00:09:56.630 
有几个属性你可以获得和设置

00:09:57.598 --> 00:09:59.867 
比如 你可以设置
fractionComplete

00:09:59.933 --> 00:10:01.468 
你可以让动画开始

00:10:01.535 --> 00:10:03.237 
你可以暂停 停止 完成动画

00:10:03.303 --> 00:10:04.838 
这些都不用过多解释

00:10:06.240 --> 00:10:10.711 
下一个协议给这个动画生成器增加了
隐式的特征

00:10:10.777 --> 00:10:14.314 
比如你想在哪里设置块和目标值

00:10:14.381 --> 00:10:16.884 
给这个设置动画的属性

00:10:17.184 --> 00:10:21.588 
这里同时有个有意思的方法
叫做continueAnimation

00:10:21.655 --> 00:10:24.925 
能让一个暂停的动画

00:10:25.158 --> 00:10:28.295 
和一个完全不同的结束时间一起处理

00:10:28.495 --> 00:10:30.764 
甚至是一个不同的定时函数

00:10:33.800 --> 00:10:37.304 
UIViewPropertyAnimator
有几个构造方法

00:10:37.371 --> 00:10:40.407 
也有一些属性用来处理触摸事件

00:10:40.474 --> 00:10:42.709 
我们会在最后讨论它

00:10:44.411 --> 00:10:48.949 
首先我们讨论下
如何使用这些基本的东西

00:10:49.249 --> 00:10:52.219 
我们将会讨论一些不是那么明显的细节

00:10:52.286 --> 00:10:55.556 
你可能会在暂停和刷新
一个动画的时候遇到

00:10:56.356 --> 00:10:58.358 
同时也有一些有趣的可能

00:10:58.425 --> 00:11:00.427 
取决于你如何反转一个动画

00:11:02.062 --> 00:11:06.099 
最后 我们会介绍所有的定时提供者

00:11:07.167 --> 00:11:09.303 
让我们从一个实际的简单的动画开始

00:11:10.504 --> 00:11:12.339 
同时我让这个例子变得更有趣了一些

00:11:12.406 --> 00:11:15.576 
为了教学目的 稍后你会看到

00:11:16.176 --> 00:11:17.945 
我来问个问题

00:11:18.812 --> 00:11:21.448 
“你将怎么样使用属性
动画生成器来完成它”

00:11:21.882 --> 00:11:23.350 
它非常非常简单

00:11:23.650 --> 00:11:26.053 
第一步需要创建一个定时对象

00:11:26.320 --> 00:11:32.759 
就像以前用的
枚举.easeInOut

00:11:33.227 --> 00:11:37.364 
你需要指定持续时间
来实例化其中的一个对象

00:11:37.865 --> 00:11:39.233 
和这个定时对象

00:11:40.400 --> 00:11:43.270 
通过使用闭包添加动画

00:11:43.337 --> 00:11:46.206 
更新你想设置动画的属性

00:11:46.740 --> 00:11:48.575 
你可添加一个可选的完成后执行函数

00:11:48.876 --> 00:11:52.846 
这个例子中
这个函数把背景色变成了橘色

00:11:53.413 --> 00:11:55.482 
然后你可以在任何时候开始这个动画

00:11:56.483 --> 00:12:00.187 
是的 相对于旧的API有点繁琐

00:12:00.254 --> 00:12:02.022 
但现在你有了个对象

00:12:02.089 --> 00:12:04.124 
你可以用它来做所有的事情

00:12:04.191 --> 00:12:06.059 
这和以前有点不同

00:12:07.327 --> 00:12:13.700 
让我们看下UIViewPropertyAnimator
一些其他可用的属性

00:12:13.767 --> 00:12:15.269 
其中有三个比较有意思

00:12:15.335 --> 00:12:17.905 
有状态 有是否在运行

00:12:17.971 --> 00:12:21.108 
和是在正向还是反向在运行

00:12:21.441 --> 00:12:24.778 
这些都是KVO中可观察的属性

00:12:26.213 --> 00:12:28.081 
第一步你需要做的是添加一个动画

00:12:28.148 --> 00:12:30.918 
我们将会让这个圆再一次从左移动到右

00:12:31.118 --> 00:12:34.888 
一旦你开始你应该添加一个动画闭包

00:12:35.389 --> 00:12:37.057 
你可以开始这个动画

00:12:37.391 --> 00:12:40.894 
然后你开始这个动画
动画的状态会改变 变成运行

00:12:41.228 --> 00:12:44.965 
现在这个视图实际的值开始改变

00:12:45.032 --> 00:12:48.035 
有一个目标值你可以在屏幕上看到

00:12:48.702 --> 00:12:50.604 
然后动画开始运行

00:12:50.671 --> 00:12:55.075 
现在不同的是
我可以在动画运行的时候暂停

00:12:55.309 --> 00:12:58.245 
我可以通过让动画生成器暂停实现

00:12:59.346 --> 00:13:02.783 
我还可以让它从相反的方向再来一次

00:13:03.083 --> 00:13:06.086 
现在动画还是在在暂停中
你可以注意状态的变化

00:13:07.154 --> 00:13:08.188 
然后我开始

00:13:09.056 --> 00:13:11.158 
动画开始运行从相反的方向

00:13:12.426 --> 00:13:15.629 
现在我再改变 动画接着向前运行

00:13:16.230 --> 00:13:17.431 
当完成的时候

00:13:18.165 --> 00:13:20.934 
将会调用你注册的完成处理函数

00:13:21.201 --> 00:13:24.238 
这次我们通过.end来调用

00:13:24.304 --> 00:13:27.875 
我们一直用这种方式来初始化

00:13:28.108 --> 00:13:30.477 
如果在动画运行时
我们没有再一次反转它

00:13:30.744 --> 00:13:33.080 
我们将会调用.start来完成动画

00:13:33.146 --> 00:13:37.584 
这样 你的结束处理函数
能知道动画实际是在哪儿结束的

00:13:39.553 --> 00:13:40.420 
好的

00:13:40.487 --> 00:13:44.391 
除了暂停动画还有其他你可以做

00:13:44.625 --> 00:13:46.293 
你可以停止动画

00:13:46.560 --> 00:13:47.628 
这是什么意思呢

00:13:47.895 --> 00:13:50.264 
首先你会注意到的是 立刻

00:13:50.330 --> 00:13:53.200 
这个圆在中间停住了

00:13:53.567 --> 00:13:57.237 
在屏幕中间可以看到我们明显提示了

00:13:57.304 --> 00:14:01.141 
动画视图的实际模式数值

00:14:01.775 --> 00:14:04.478 
这时你可以对这个圆做任何操作

00:14:04.845 --> 00:14:08.649 
但我们传了个false参数来停止

00:14:08.715 --> 00:14:10.417 
表示不要立即跳到

00:14:10.484 --> 00:14:13.520 
非活动状态 保持在准完成状态

00:14:13.987 --> 00:14:15.956 
它表示在未来某个时候

00:14:16.023 --> 00:14:18.592 
你将调用
finishAnimation

00:14:18.659 --> 00:14:23.764  
同时你将指定一个动画实际结束的位置

00:14:23.830 --> 00:14:27.734  
在这个例子中 我们既不会在开始完成
也不会在结束完成

00:14:28.135 --> 00:14:31.171  
你的完成函数
将会在这个位置被调用

00:14:31.638 --> 00:14:34.241 
现若你调用了stopAnimation
并传入了true参数

00:14:34.308 --> 00:14:36.410 
我们将不会调用你的结束函数

00:14:36.476 --> 00:14:39.580 
它将会在那个点完成

00:14:40.180 --> 00:14:44.651 
现在我们看看如果你调用
finishWithADifferentPosition会发生什么

00:14:44.952 --> 00:14:47.154 
若调用
finishWithTheEnd

00:14:48.355 --> 00:14:52.860 
它将会直接跳到动画的起始位置

00:14:53.393 --> 00:14:56.196 
你可能回想
“为什么需要这么做”

00:14:56.630 --> 00:14:59.733 
实际上这给了你很多可能

00:14:59.800 --> 00:15:03.036 
比如 想象下你将要暂停这个圆

00:15:03.170 --> 00:15:05.772 
或者在你触摸它的时候来暂停动画

00:15:06.206 --> 00:15:07.875 
然后你可以拽这个圆来回转动

00:15:07.941 --> 00:15:10.844 
也许你设置了一些
UIKit的临时行为

00:15:10.911 --> 00:15:14.281 
在结束位置或者目标位置

00:15:14.481 --> 00:15:17.718 
当你释放它 根据你手势的速度

00:15:17.885 --> 00:15:20.387 
它可能卡入那些相对位置

00:15:20.587 --> 00:15:23.557 
一旦到达了那里就可调用
finishAnimation

00:15:23.757 --> 00:15:25.726 
通过.end和.begin

00:15:25.926 --> 00:15:27.561 
然后你可以做一些有意思的事情

00:15:27.628 --> 00:15:30.764 
来种植你开启的动画

00:15:40.274 --> 00:15:42.609 
好的 暂停和刷新

00:15:43.310 --> 00:15:44.845 
不是很多 对么

00:15:45.479 --> 00:15:46.947 
这有点意思

00:15:47.014 --> 00:15:50.517 
这里有个样例程序

00:15:51.351 --> 00:15:53.887 
我们给这个方块设置了一些手势识别

00:15:53.954 --> 00:15:56.023 
在那个绿色进度条上

00:15:56.957 --> 00:16:00.594 
我们可以刷那个进度条

00:16:00.661 --> 00:16:03.096 
我们用方块的位置更新它的值

00:16:03.163 --> 00:16:04.998 
然后我们继续操作方块

00:16:05.632 --> 00:16:09.736 
你会发现移动的时候方块的位置

00:16:09.803 --> 00:16:12.206 
在图中看起来有奇怪的突起

00:16:12.272 --> 00:16:14.041 
这里我们简单的说下

00:16:15.509 --> 00:16:18.478 
在介绍之前 我们看看这些手势识别

00:16:18.545 --> 00:16:21.915 
在方块上 我们添加了轻触手势识别

00:16:22.115 --> 00:16:24.751 
来检查动画是否是活动的

00:16:25.018 --> 00:16:28.155 
如果是活动的 它将会检查是否在运行

00:16:28.522 --> 00:16:30.224 
如果它在运行 将会暂停它

00:16:30.290 --> 00:16:32.359 
如果不是 它将会重新开始

00:16:32.693 --> 00:16:33.760 
相当直观

00:16:34.995 --> 00:16:38.699 
在进度条上
我们设置了一个平移手势

00:16:38.932 --> 00:16:41.802 
我们会根据位置计算一个分数

00:16:41.869 --> 00:16:46.807 
我们在平移时

00:16:46.874 --> 00:16:50.244 
相对整个进度条的边界

00:16:50.310 --> 00:16:52.346 
根据我们计算的分数

00:16:52.513 --> 00:16:56.817 
我们将同时更新动画生成器和
进度条作为fractionComplete

00:17:00.554 --> 00:17:01.388 
好的

00:17:01.622 --> 00:17:04.590 
那么 这个图怎么了

00:17:08.896 --> 00:17:11.498 
有些有意思的事情在发生

00:17:14.167 --> 00:17:17.069 
方便解释它
我将会回到之前类似的

00:17:17.137 --> 00:17:19.573 
夸大的渐入曲线

00:17:20.307 --> 00:17:23.944 
这次 进入了50%

00:17:24.011 --> 00:17:26.780 
我们暂停了动画
现在我们想刷信它

00:17:29.116 --> 00:17:31.852 
需要重点注意的是
fractionComplete

00:17:32.119 --> 00:17:35.422 
实际上你的设置和时间无关

00:17:35.489 --> 00:17:37.024 
我们刚暂停了动画

00:17:37.090 --> 00:17:42.629 
你设置的是相对于终点值的小数

00:17:42.930 --> 00:17:46.166 
在这种情况下 我们不会有任何进展

00:17:46.633 --> 00:17:48.969 
现在我们将会刷新这条线

00:17:49.036 --> 00:17:50.637 
我们将会继续来一次

00:17:51.138 --> 00:17:56.243 
我们不想跳到能看出位置

00:17:56.543 --> 00:17:58.345 
这个正在设置动画的视图

00:17:58.779 --> 00:18:02.115 
所以 实际上 我们是把时间映射回

00:18:02.182 --> 00:18:04.585 
定时函数开始的位置

00:18:04.918 --> 00:18:08.956 
就是说当我们继续这个特殊的例子的话

00:18:09.857 --> 00:18:11.859 
这个动画将会快速的完成

00:18:12.759 --> 00:18:16.063 
所以当我们回到刚才看到的曲线

00:18:16.129 --> 00:18:18.398 
你会发现我们有点往回跳

00:18:18.465 --> 00:18:22.169 
到渐入渐出定时函数

00:18:22.636 --> 00:18:25.205 
并且注意到这很重要
当暂停和刷新的时候

00:18:25.272 --> 00:18:29.309 
根据任何UI提示你可能需要这么做

00:18:29.409 --> 00:18:33.847 
你可能会看到这些不连续性
并且需要做些补偿

00:18:35.015 --> 00:18:36.984 
好的 让我们谈下反转

00:18:37.885 --> 00:18:40.921 
有三种方式你可以用来反转

00:18:41.421 --> 00:18:46.527 
一个是你可以暂停反转 比如需要交互

00:18:46.894 --> 00:18:48.095 
需要再来一遍

00:18:48.662 --> 00:18:52.699 
你会发现你是字面上的直接反转回来

00:18:52.799 --> 00:18:55.402 
通过你指定的定时函数

00:18:55.836 --> 00:18:57.571 
你可以在任何时候反转

00:18:58.038 --> 00:18:59.973 
就是说 即使在动画运行时

00:19:00.040 --> 00:19:01.208 
你也可以来让动画反转

00:19:01.275 --> 00:19:03.377 
这有点像打一堵墙

00:19:03.710 --> 00:19:07.080 
再一次
这将会导致速度上的很大的不连续性

00:19:07.414 --> 00:19:12.219 
这将可能是你想要的

00:19:12.286 --> 00:19:15.389 
如果你想要一个完美的非弹性碰撞
或者类似的东西

00:19:15.989 --> 00:19:18.959 
如果你不想这样或者
你想让它更顺滑些

00:19:19.193 --> 00:19:21.195 
你可以累加的使用动画

00:19:21.628 --> 00:19:24.965 
在这个例子中 我们将会反转动画

00:19:25.065 --> 00:19:27.134  
不是通过修改反转属性

00:19:27.568 --> 00:19:31.905  
二是通过实际的修改值到
原始的位置

00:19:32.573 --> 00:19:34.741  
它们的不同是

00:19:34.808 --> 00:19:36.877  
结束的时候处理函数的调用

00:19:36.944 --> 00:19:38.979  
.end函数将会被调用

00:19:39.213 --> 00:19:41.014  
你已经改变了目标

00:19:41.081 --> 00:19:46.687  
你将不会回到初始的目标

00:19:46.753 --> 00:19:50.190 
你将会回到你刚才指定的目标

00:19:51.825 --> 00:19:54.361 
好的 有些有意思的

00:19:55.329 --> 00:20:01.468 
定时对象可以用

00:20:02.503 --> 00:20:05.639 
第一个是UICubicTimingParameter类

00:20:05.706 --> 00:20:08.141 
如果创建这一类时不设定任何参数

00:20:08.208 --> 00:20:11.778 
你将得到默认的core animation时间曲线

00:20:11.845 --> 00:20:14.848 
这之前在UIKit层面并不可用

00:20:15.482 --> 00:20:17.584 
第二 构造函数变量

00:20:17.651 --> 00:20:23.357 
本质上是现有的canned动画曲线

00:20:23.423 --> 00:20:27.494 
最后我们开放了所有l
可用的贝赛尔曲线

00:20:27.761 --> 00:20:29.830 
供你在这个单位正方形内使用

00:20:30.030 --> 00:20:32.299 
举个你可能会做的事情为例

00:20:32.366 --> 00:20:34.968 
这个特殊的贝塞尔曲线
如果给它个名字

00:20:35.035 --> 00:20:36.737 
就叫“快进 快出”

00:20:37.004 --> 00:20:40.974 
你一定会欣喜若狂 当你看到想要用来
创建时间函数的贝塞尔曲线

00:20:47.581 --> 00:20:52.119 
我们已经为你们提供了更多方法
去做比如弹跳这样的动画

00:20:52.219 --> 00:20:56.657 
而且再来想一下我们认为
弹跳现在会影响时间

00:20:56.924 --> 00:21:01.128 
如果创建UISpringTimingParameter对象时
不设定引值

00:21:01.195 --> 00:21:03.864 
你会获得一个临界阻尼的弹跳动画

00:21:03.931 --> 00:21:05.432 
这是很多人想要的动画

00:21:05.699 --> 00:21:10.938 
比如我们就会用这个动画
在导航控制上进行推入或调出

00:21:16.476 --> 00:21:22.482 
第二个变量很像现有的
UIKit弹跳动画应用编程接口

00:21:22.549 --> 00:21:25.052 
但是还是点小区别
我马上就会讲到

00:21:25.919 --> 00:21:27.120 
但在讲这个之前

00:21:27.521 --> 00:21:30.290 
我们以为你打开了一个弹跳方程

00:21:30.357 --> 00:21:33.560 
你可以定义任何你想要的系数

00:21:33.627 --> 00:21:36.830 
我们也会切实重视这些系数

00:21:37.364 --> 00:21:38.565 
但这里有个问题

00:21:38.632 --> 00:21:44.104 
就是你定义的时长
被忽略了

00:21:44.171 --> 00:21:48.041 
我们对这个时长的计算是根据
弹跳方程的解法

00:21:48.275 --> 00:21:49.810 
举这样一个例子

00:21:53.680 --> 00:21:54.948 
我说过他们之间有区别

00:21:55.015 --> 00:21:58.252 
你会发现初始的速率
现在变成了矢量

00:21:58.418 --> 00:21:59.720 
而不是标量

00:22:00.721 --> 00:22:02.890 
很多时候我们不会注意

00:22:02.956 --> 00:22:04.958 
这个矢量的y分量

00:22:05.359 --> 00:22:09.563 
但是如果你在视图中心做动画

00:22:09.863 --> 00:22:14.034 
那么这个矢量的x和y分量
必须都要注意

00:22:14.101 --> 00:22:16.904 
原因就用这个应用程序实例说明

00:22:17.304 --> 00:22:19.740 
我们将正这个方形拖离中心

00:22:20.073 --> 00:22:22.276 
并在松手的时候要让它

00:22:22.342 --> 00:22:24.845 
根据手势的速率
弹回中心

00:22:25.779 --> 00:22:31.418 
直至现在这个速率
始终沿着一条线

00:22:31.485 --> 00:22:34.888 
就是两个正方形之间的连线
这不是件好事

00:22:34.955 --> 00:22:39.026 
因为我的手势可能
在平面的任何地方结束

00:22:39.092 --> 00:22:42.062 
而我们事实上并没有
实际考虑到这一点

00:22:42.996 --> 00:22:44.431 
但现在我们想到了

00:22:44.498 --> 00:22:46.166 
所以我们来看一下这个小视频

00:22:46.233 --> 00:22:50.504 
展示了我们现在是怎样
让正方形弹回中心

00:22:50.571 --> 00:22:54.508 
并将二维矢量位置都考虑在内

00:22:54.741 --> 00:22:56.243 
你会看到
在我们开始做时

00:22:56.310 --> 00:22:58.645 
会同时考虑到
x和y分量

00:22:58.912 --> 00:22:59.913 
这很简单

00:23:06.954 --> 00:23:08.856 
现在我们有了这个
很好的属性动画

00:23:08.922 --> 00:23:09.957 
那么如何呢？

00:23:10.190 --> 00:23:13.961 
我想要利用它实现
自定义视图控制器转换

00:23:14.027 --> 00:23:16.330 
而且我希望它们也是可中断的

00:23:17.331 --> 00:23:21.335 
三年前
我就此做了一整场演讲

00:23:21.401 --> 00:23:23.036 
所以它的确有些复杂

00:23:23.103 --> 00:23:26.573 
如果你不熟悉自定义视图控制器转换

00:23:26.640 --> 00:23:28.408 
请参考之前的演讲

00:23:28.475 --> 00:23:32.579 
但我会快速地概述一下
打个基础

00:23:32.646 --> 00:23:34.982 
准备讲解我们如何拓展这些协议

00:23:35.182 --> 00:23:39.019 
视图控制器转换一般是
一组连锁协议

00:23:39.086 --> 00:23:43.524 
其中两个包括
交互转换和动画转换

00:23:43.590 --> 00:23:46.894 
他们是你创建对象时
需要符合的协议

00:23:47.427 --> 00:23:49.563 
好吧 是你创建的对象
要符合的协议

00:23:50.664 --> 00:23:53.767 
系统会创建另一个对象并传递给

00:23:53.834 --> 00:23:57.171 
该协议的方法

00:23:57.237 --> 00:23:58.772 
这个稍后我们会讲清楚

00:23:59.473 --> 00:24:01.375 
但是要记得我们为什么想这么做

00:24:01.441 --> 00:24:04.545 
假设你有一个应用程序
带导航控制器

00:24:06.180 --> 00:24:08.215 
而且pop看上去挺正常

00:24:08.282 --> 00:24:11.852 
它是个不错的
临界阻尼弹跳动画

00:24:12.219 --> 00:24:14.321 
但是你的应用
需要点不一样的东西

00:24:14.655 --> 00:24:18.559 
它需要的是
完全不一样的外观

00:24:18.625 --> 00:24:22.362 
它可以爆炸式弹出
或许下面还带模糊效果

00:24:22.829 --> 00:24:25.699 
这就是自定义视图控制器转换
让你能做到的事情

00:24:25.832 --> 00:24:29.303 
而且它还可以让你的编写
和驱动更有交互性

00:24:30.504 --> 00:24:33.407 
要得到这些符合协议的对象

00:24:33.473 --> 00:24:35.375 
只需要通过一个代理

00:24:35.475 --> 00:24:37.678 
它可以是导航控制器代理

00:24:37.744 --> 00:24:40.514 
也可以是视图控制器的转换代理

00:24:41.381 --> 00:24:42.916 
我们要问这个代理

00:24:42.983 --> 00:24:45.953 
“你是否都有符合动画转换的对象

00:24:46.019 --> 00:24:49.022 
可以在任何时候显示
推入或者弹出？”

00:24:49.590 --> 00:24:53.227 
如果有 我们将
绕过内置转换

00:24:53.594 --> 00:24:56.563 
我们要创建其中一个
转换context对象

00:24:56.630 --> 00:24:58.599 
它可以给你所有你需要的信息

00:24:58.665 --> 00:25:00.868 
去实现转场动画

00:25:01.101 --> 00:25:05.205 
我们会命令animateTransition
将context传递给你"

00:25:07.040 --> 00:25:08.475 
那如何让这个流程可中断？

00:25:08.976 --> 00:25:14.748 
我们所做的是添加了新的方法
叫interruptibleAnimator(using

00:25:15.082 --> 00:25:18.151 
如果要执行它
你需要返回一个对象

00:25:18.218 --> 00:25:20.954 
符合UIViewImplicitlyAnimating

00:25:21.021 --> 00:25:23.357 
他可以是一个UIViewPropertyAnimator

00:25:23.657 --> 00:25:24.858 
但不是必须的

00:25:24.925 --> 00:25:28.095 
它也可以是另一种动画

00:25:28.161 --> 00:25:34.001 
即你的执行可以根据UIKit动态
或者其他动画策略

00:25:36.670 --> 00:25:41.675 
如果你不执行交互控制器

00:25:42.409 --> 00:25:44.778 
意思是你只执行了
自定义动画控制器

00:25:44.845 --> 00:25:46.980 
那么你需要执行
animateTransition

00:25:47.047 --> 00:25:50.918 
这个十分简单
只要你用这个方法

00:25:50.984 --> 00:25:54.188 
你只要接收可中断的
animator然后返回值

00:25:54.621 --> 00:25:56.290 
然后只要给一个开始命令

00:25:56.623 --> 00:25:59.726 
这就是执行animateTransition的所有步骤了

00:26:01.461 --> 00:26:05.032 
但是我们建议你使用交互控制器

00:26:05.098 --> 00:26:06.800 
如果你想让它变成可中断

00:26:07.434 --> 00:26:11.972 
重申一下首要的事
就是要符合

00:26:12.172 --> 00:26:15.876 
是说返回的对象要符合
转场动画的协议

00:26:15.943 --> 00:26:19.646 
然后我们会要你提供一个
符合交互转场的对象

00:26:19.713 --> 00:26:22.716 
并且会传递
之前返回给我们的对象

00:26:22.783 --> 00:26:24.952 
是作为一个参数来传递

00:26:26.086 --> 00:26:29.489 
很多时候
你希望这个交互控制器

00:26:29.556 --> 00:26:32.860 
可以真正驱动动画控制器

00:26:36.096 --> 00:26:38.899 
若是如此 我们就不用调出
animateTransition

00:26:38.966 --> 00:26:41.134 
而是调出
startInteractiveTransition

00:26:41.201 --> 00:26:42.936 
传递的context是完全一样

00:26:43.003 --> 00:26:45.305 
用animateTransition也是这样

00:26:47.941 --> 00:26:50.577 
我们会提供一个具体的类
你可以直接使用

00:26:50.644 --> 00:26:52.513 
这样操作起来就十分简单

00:26:53.914 --> 00:26:57.050 
在此之前还有一个限制

00:26:57.117 --> 00:27:00.721 
若要执行UIPercentDriven
InteractiveTransition

00:27:00.787 --> 00:27:04.157 
那么animateTransition方法

00:27:04.224 --> 00:27:07.661 
在动画控制器中的执行就要按照

00:27:07.728 --> 00:27:10.564 
现有的UIKit动画应用编程接口执行

00:27:11.498 --> 00:27:14.868 
但是现在有了可中断的animator

00:27:14.935 --> 00:27:18.238 
UIPercentDriven InteractiveTransition
根本就不需要在意这个接口

00:27:18.305 --> 00:27:23.944 
只要使用
UIViewImplicitlyAnimating定义的协议

00:27:24.077 --> 00:27:25.646 
就这些了

00:27:25.712 --> 00:27:27.948 
这样你就可以真正创造一个
全然不同的动画

00:27:28.015 --> 00:27:30.918 
由UIPercentDriven
I交互转场驱动

00:27:31.451 --> 00:27:32.452 
这是不是很酷

00:27:34.021 --> 00:27:36.423 
假设你已经有了一个这样的动画

00:27:36.490 --> 00:27:37.891 
也有了一个自定义转场

00:27:37.958 --> 00:27:38.992 
如何将他们合并呢？

00:27:39.426 --> 00:27:41.828 
一种方法从表面上来讲

00:27:41.895 --> 00:27:46.233 
将animateTransition方法
重命名为myAnimateTransition

00:27:46.300 --> 00:27:49.303 
再用同样的方法
创建可中断的animator

00:27:49.636 --> 00:27:52.873 
你就只要添加这个任务方法到

00:27:54.208 --> 00:27:56.276 
animator中
一个动画上就可以了

00:27:56.643 --> 00:27:57.711 
这不难

00:28:00.314 --> 00:28:04.685 
我们的确要拓展
协议中的某些对象

00:28:04.751 --> 00:28:09.056 
比如现在的context转场中就添加了
pauseInteractiveTransition

00:28:09.423 --> 00:28:13.193 
现在这就是进入交互状态的方法

00:28:13.493 --> 00:28:17.998 
在这之前要先启动交互
并关闭非交互式

00:28:18.098 --> 00:28:19.700 
现在你就可以来回移动了

00:28:19.766 --> 00:28:25.205 
移动要通过调用pauseInteractive
结束或取消也一样

00:28:27.174 --> 00:28:30.377 
同样isInteractive属性
以及

00:28:30.444 --> 00:28:34.047 
transitionWasCancelled
就可以随着你的前后移动

00:28:34.114 --> 00:28:37.784 
在交互和非交互中切换

00:28:40.053 --> 00:28:42.990 
我们添加了一个变量
叫wantsInteractiveStart

00:28:43.056 --> 00:28:44.925 
既然已经可以前后移动

00:28:45.459 --> 00:28:49.630 
那你也许想要交互控制器
从非交互式出发

00:28:49.863 --> 00:28:52.232 
此变量就控制这一行为

00:28:54.902 --> 00:29:00.140 
最后我们更新
UIPercentDriven交互转场

00:29:01.308 --> 00:29:02.342 
这有几点规定

00:29:02.409 --> 00:29:05.078 
如果执行InterruptibleAnimator

00:29:05.212 --> 00:29:07.781 
我们希望它能真正有用

00:29:08.048 --> 00:29:09.650 
就是说不做其他事情

00:29:09.716 --> 00:29:11.084 
系统可能会很不高兴

00:29:11.451 --> 00:29:13.053 
我们会始终调用
animateTransition

00:29:13.120 --> 00:29:15.088 
并最先启动startInteractiveTransition

00:29:15.389 --> 00:29:17.391 
这样就有很大的空间

00:29:17.457 --> 00:29:20.727 
去创建可中断的animator
因为它将在

00:29:20.794 --> 00:29:23.163 
之后编写中被重复调出
用同样的context

00:29:23.230 --> 00:29:28.168 
我们也希望返回值能
一直是同一个

00:29:28.769 --> 00:29:32.272 
最后animator的时长
可以涵盖整个转场时长

00:29:32.439 --> 00:29:36.343 
在整个转场结束之前
它必须处于活动状态

00:29:37.244 --> 00:29:40.981 
现在请Mike上台为大家展示
如何在应用程序中使用应用编程接口

00:29:42.783 --> 00:29:44.017 
没给你留多少时间

00:29:48.589 --> 00:29:49.756 
谢谢你 Bruce

00:29:52.926 --> 00:29:53.794 
不客气

00:29:55.429 --> 00:29:57.664 
首先来看这个演示应用

00:29:58.198 --> 00:30:02.603 
这个应用使用UIViewPropertyAnimator

00:30:02.669 --> 00:30:05.572 
和UIViewController
转场的添加函数

00:30:06.907 --> 00:30:10.143 
在基本应用中创建
完美的可中断自定义转场

00:30:10.410 --> 00:30:13.814 
第一 应用要使用UINavigationController

00:30:14.348 --> 00:30:15.916 
并且内置有一个集合视图控制器

00:30:15.983 --> 00:30:17.951 
这是个照片格子
可以拉动浏览

00:30:18.519 --> 00:30:19.820 
当我们点击其中一张照片

00:30:20.120 --> 00:30:22.422 
它会推进导航栈上
其他视图控制器

00:30:23.123 --> 00:30:26.059 
让你的图片视图
更加清晰具体

00:30:26.126 --> 00:30:28.595 
如果我们点击返回键
这个视图就弹回导航栈

00:30:28.962 --> 00:30:31.965 
另外我们可以滑动屏幕
从左向右

00:30:32.332 --> 00:30:34.201 
实现交互转场返回

00:30:34.268 --> 00:30:37.704 
这些在UINavigationController基本都免费

00:30:38.539 --> 00:30:41.842 
就像Bruce刚才所说
我们还有很多套应用编程接口

00:30:41.909 --> 00:30:43.911 
能让你自定义转场

00:30:44.178 --> 00:30:45.946 
如果我们想放大照片

00:30:46.013 --> 00:30:49.316 
让他铺满页面
我们也可以做到 这很酷

00:30:49.383 --> 00:30:51.418 
点击返回键
照片就缩小回去

00:30:51.818 --> 00:30:53.320 
这些在此之前都只是设想

00:30:53.820 --> 00:30:56.023 
另外你也可以向下拖拽

00:30:56.089 --> 00:30:58.926 
来启动交互转场
再转动几下

00:30:59.092 --> 00:31:01.128 
让整个动作以动画方式完成

00:31:01.762 --> 00:31:03.964 
我想向你们展示的是
我们如何做到这样

00:31:04.031 --> 00:31:05.732 
通过使用UIViewPropertyAnimator

00:31:12.739 --> 00:31:15.409 
首先你做的就是告诉系统

00:31:15.475 --> 00:31:16.910 
这里应该说是导航控制器

00:31:17.110 --> 00:31:19.913 
你要提供一个自定义转场

00:31:19.980 --> 00:31:22.716 
那么这里我们就要符合
导航控制器的代理

00:31:23.050 --> 00:31:25.519 
通过AssetTransitionController来实现

00:31:25.586 --> 00:31:29.790 
这是我们创建的对象
可以执行这些转场协议

00:31:30.490 --> 00:31:32.626 
这里我们要注意
两种十分重要的方法

00:31:32.693 --> 00:31:34.962 
第一个是调出动画控制器

00:31:35.395 --> 00:31:37.464 
通过一个特定操作
推入或弹出

00:31:37.664 --> 00:31:40.067 
我们要保存该操作
然后返回值给自己

00:31:40.133 --> 00:31:41.635 
因为我们就是动画控制器

00:31:42.469 --> 00:31:44.938 
然后当我们将对象
从那个接口返回后

00:31:45.205 --> 00:31:47.407 
系统将调出一个交互控制器

00:31:48.041 --> 00:31:50.077 
在这里我们还是返回值给自己

00:31:50.143 --> 00:31:51.912 
因为我们也要扮演交互控制器

00:31:52.212 --> 00:31:54.581 
完成之后
系统就会知道

00:31:54.648 --> 00:31:55.916 
这里会有一个交互转场

00:31:56.717 --> 00:32:00.354 
现在来看一下UIViewController
InteractiveTransitioning

00:32:01.221 --> 00:32:04.358 
这里系统会调出
startInteractiveTransition

00:32:04.424 --> 00:32:06.660 
并以转场context调出
我们的对象

00:32:06.727 --> 00:32:08.295 
这会包含所有有关信息

00:32:08.362 --> 00:32:11.164 
对于我们开始自定义转场十分必要

00:32:12.132 --> 00:32:14.268 
这里我们将创建一个辅助对象

00:32:14.334 --> 00:32:16.703 
一会儿我们会看到更多

00:32:16.937 --> 00:32:21.275 
这个对象将会
创建我们的转场动画

00:32:21.341 --> 00:32:24.411 
我们要将context传递给
我们之前所保存的操作

00:32:24.478 --> 00:32:28.348 
同时也要传给panGestureRecognizer
就是之前用于启动交互转场的程序

00:32:28.849 --> 00:32:32.319 
IOS10允许交互转场

00:32:32.386 --> 00:32:35.656 
分两个进程开始
动画进程和交互进程

00:32:35.923 --> 00:32:38.192 
若从panGestureRecognizer开始

00:32:38.258 --> 00:32:41.161 
就要设initiallyInteractive变量

00:32:41.228 --> 00:32:42.963 
为真
以便系统知道

00:32:43.030 --> 00:32:45.832 
我们正在开始这个交互转场

00:32:48.001 --> 00:32:51.471 
下面看一下动画转场的执行

00:32:51.738 --> 00:32:54.842 
这里我们不太在意
动画方法

00:32:54.908 --> 00:32:57.611 
就像布鲁斯提到那样
我们使用的是交互控制器

00:32:57.678 --> 00:32:59.580 
它会调出startInteractiveTransition

00:32:59.646 --> 00:33:01.648 
相对于animateTransition

00:33:01.715 --> 00:33:04.751 
但iOS10里
新的可中断动画接口

00:33:04.818 --> 00:33:06.286 
才是我们真正的兴趣所在

00:33:06.753 --> 00:33:07.921 
这里是我们的辅助对象

00:33:07.988 --> 00:33:11.625 
一会儿会看到它创建了一个
UIViewPropertyAnimator

00:33:11.692 --> 00:33:13.460 
并且将它的值返回了系统

00:33:13.827 --> 00:33:17.364 
所以这里就是系统
添加任何并列动画的地方

00:33:17.431 --> 00:33:20.767 
在这个演示中你会看到
顶部的导航条

00:33:20.834 --> 00:33:22.402 
跟着我们的转场一起在动

00:33:22.469 --> 00:33:26.406 
系统会利用这个animator
来添加这些动画

00:33:27.040 --> 00:33:29.877 
现在看看转场驱动
辅助对象有多快

00:33:31.545 --> 00:33:35.382 
在此 startInteractiveTransition
初始化了这个对象

00:33:36.783 --> 00:33:39.019 
这就会联通
抱歉

00:33:40.387 --> 00:33:41.288 
是这里

00:33:41.355 --> 00:33:44.024 
这就可以联通这个辅助方法

00:33:44.091 --> 00:33:45.759 
和一些动画
然后它会设定一些

00:33:45.826 --> 00:33:47.995 
背景动画给这个转场

00:33:48.662 --> 00:33:50.163 
视觉效果就是动态的

00:33:50.230 --> 00:33:52.399 
这两个视图控制器和alpha
也是动态的

00:33:52.699 --> 00:33:56.603 
我们稍后再讲
图片边框切换

00:33:57.037 --> 00:34:00.274 
它会传递完成关闭指令
也会帮助清理

00:34:00.340 --> 00:34:01.542 
一些背景视图

00:34:01.608 --> 00:34:04.144 
但是这里的重点是
我们如何创建这个属性动画

00:34:04.211 --> 00:34:06.780 
并返回到interruptibleAnimator接口

00:34:07.114 --> 00:34:09.516 
首先我们从辅助函数中
获得一个转场时长

00:34:09.583 --> 00:34:11.150 
我们也是过会儿再看这个

00:34:11.485 --> 00:34:13.954 
创建PropertyAnimator
并选择时长

00:34:14.021 --> 00:34:15.322 
以及easeOut曲线

00:34:15.621 --> 00:34:18.025 
我们会在收到的动画间传递

00:34:18.692 --> 00:34:20.327 
并在这里创建一个完成处理

00:34:21.061 --> 00:34:23.730 
然后调出这些传给我们的
完成命令

00:34:23.797 --> 00:34:25.299 
重要的是我们要调出

00:34:25.364 --> 00:34:28.001 
转场context
在动画结束时

00:34:28.368 --> 00:34:31.103 
告诉系统
“嘿 我们的转场完成了”

00:34:31.505 --> 00:34:33.206 
然后到了...

00:34:33.273 --> 00:34:34.141 
抱歉

00:34:34.208 --> 00:34:36.777 
completionTransition接口有一个博尔值

00:34:37.710 --> 00:34:39.847 
让我们可以得到
应该传递的值

00:34:39.913 --> 00:34:42.382 
所以从这个接口传递“yes”

00:34:42.449 --> 00:34:43.951 
这就意味着
我们要结束这个转场

00:34:44.016 --> 00:34:46.320 
如果传递“no”
意思就是取消转场

00:34:47.221 --> 00:34:52.492 
在我接着讲转场动画
辅助对象之前

00:34:52.826 --> 00:34:54.895 
我想再展示这个演示应用的
一些其他特点

00:34:54.962 --> 00:34:57.931 
都由UIViewPropertyAnimator实现

00:35:02.302 --> 00:35:06.273 
回到演示应用
我之前展示了如何放大图片

00:35:06.340 --> 00:35:08.942 
和通过点击返回键缩小屏幕

00:35:09.009 --> 00:35:11.812 
但我没有展示
你可以在半空中暂停

00:35:12.379 --> 00:35:14.882 
现在我们正在动画进程
但是暂停动画

00:35:15.048 --> 00:35:16.650 
然后进入交互进程

00:35:16.984 --> 00:35:19.186 
这样与照片的交互
就在转场中途开始

00:35:19.253 --> 00:35:21.588 
当我们松开手
动画会继续

00:35:21.655 --> 00:35:22.656 
然后可以再次中断

00:35:22.723 --> 00:35:25.893 
这样我们可以自由来回
往返于动画进程

00:35:25.993 --> 00:35:28.061 
和交互进程之间

00:35:28.295 --> 00:35:29.329 
这真的很炫

00:35:30.964 --> 00:35:33.634 
在返回代码
告诉你我们如何做到之前

00:35:33.700 --> 00:35:35.002 
通过用新视图控制器接口

00:35:35.502 --> 00:35:38.305 
我想用具体的场景来帮助大家

00:35:38.372 --> 00:35:40.107 
理解这些代码是做什么的

00:35:40.407 --> 00:35:41.808 
假设我们正在开始

00:35:41.875 --> 00:35:43.944 
用panGestureRecognizer
向下拉动视图

00:35:44.011 --> 00:35:45.712 
从而开始一个交互式转场

00:35:46.346 --> 00:35:48.081 
然后我们从屏幕上拿起手指

00:35:48.148 --> 00:35:50.584 
开始动画进程
在动画播放时

00:35:50.684 --> 00:35:53.820 
我们在中途暂停
然后再次回到动画

00:35:53.887 --> 00:35:56.256 
然后取消转场
直接向上拉回

00:35:56.823 --> 00:35:58.926 
这就是我要描述的场景

00:35:58.992 --> 00:36:00.360 
对照下面这段代码

00:36:04.731 --> 00:36:08.468 
我将这个示例应用分成了四个方法

00:36:09.036 --> 00:36:12.039 
updateInteraction
是手势识别处理

00:36:12.105 --> 00:36:14.808 
用来更新交互转场

00:36:15.108 --> 00:36:16.310 
当抬起手指

00:36:16.376 --> 00:36:18.278 
调出endInteraction函数

00:36:18.979 --> 00:36:21.014 
然后调出动画函数添加动画

00:36:21.081 --> 00:36:22.583 
在开始或者结束位置

00:36:23.250 --> 00:36:25.152 
然后当我们中断动画

00:36:25.219 --> 00:36:26.887 
最后调出pauseAnimation

00:36:26.954 --> 00:36:31.491 
这个可以在转场时长中
多次循环

00:36:31.558 --> 00:36:33.060 
想做多少次都可以

00:36:33.160 --> 00:36:35.128 
这里我们只做了两次

00:36:36.063 --> 00:36:37.965 
然后是
updateInteraction

00:36:38.031 --> 00:36:39.766 
这是手势识别处理

00:36:39.967 --> 00:36:43.370 
当它调出
“状态开始”或者“状态改变”时

00:36:43.437 --> 00:36:45.873 
我们会看到手势识别的翻译

00:36:45.939 --> 00:36:48.976 
我们就会用这个去计算
要添加的进程步骤

00:36:49.042 --> 00:36:51.411 
把他们作为fractionComplete
添加到转场动画

00:36:52.412 --> 00:36:54.681 
之后要在背景中
擦除这些动画

00:36:54.748 --> 00:36:57.985 
就像chrome导航条的
背景视觉效果

00:36:58.051 --> 00:36:59.019 
这个很简单

00:36:59.086 --> 00:37:01.255 
就跟在转场动画里
设定fractionComplete一样

00:37:01.321 --> 00:37:04.825 
这就可以基本免费
擦除所有动画

00:37:05.526 --> 00:37:07.227 
再调出transitionContext

00:37:07.294 --> 00:37:09.530 
来更新交互转场percentComplete

00:37:10.330 --> 00:37:12.766 
最后我们的图片
就可以在屏幕上移动了

00:37:12.933 --> 00:37:15.002 
当处于转场的
交互进程时

00:37:15.068 --> 00:37:17.104 
我们要手动设定边框

00:37:17.171 --> 00:37:18.906 
因此我们要做一个小的辅助函数

00:37:20.174 --> 00:37:23.310 
最后我们重新设定
这个手势识别的翻译

00:37:23.744 --> 00:37:26.580 
当我们收到指令时
手指离开屏幕

00:37:26.647 --> 00:37:30.484 
手势识别会出现“状态结束”
然后调出endInteraction

00:37:31.118 --> 00:37:32.819 
研究endInteraction时

00:37:32.886 --> 00:37:35.722 
第一只看我们的转场context
是否是交互的

00:37:35.789 --> 00:37:38.959 
我们要保证它是在我们
离开交互进程之前完成

00:37:39.593 --> 00:37:41.028 
然后调出小辅助函数

00:37:41.094 --> 00:37:42.829 
它告诉我们
这个完成是在

00:37:42.896 --> 00:37:45.599 
动画的开始位置
或者结束位置

00:37:46.066 --> 00:37:47.634 
如果在结束位置完成

00:37:47.701 --> 00:37:49.236 
调出context以表明

00:37:49.303 --> 00:37:51.505 
“嘿 交互转场在这里结束

00:37:51.772 --> 00:37:53.240 
我们要进入动画进程了”

00:37:53.807 --> 00:37:55.709 
如果在开始位置完成

00:37:55.776 --> 00:37:57.711 
意思就是我们取消了这个交互进程

00:37:57.778 --> 00:37:59.346 
将要进入动画进程

00:37:59.646 --> 00:38:00.581 
然后只要做动画就好

00:38:00.914 --> 00:38:02.749 
现在来看动画方法

00:38:04.351 --> 00:38:07.521 
之前我告诉你们
转场动画转换的是

00:38:07.588 --> 00:38:10.791 
背景chrome和alpha通道

00:38:11.291 --> 00:38:13.594 
但这里我们要创建一个
二级propertyAnimator

00:38:13.660 --> 00:38:15.696 
我们要使用它来绘制边框动画

00:38:15.762 --> 00:38:17.531 
让图片可以在屏幕上移动

00:38:17.598 --> 00:38:20.300 
我们之所以这么做
是希望有些动画

00:38:20.367 --> 00:38:23.804 
能有不一样的时间函数
相较于背景动画而言

00:38:23.937 --> 00:38:25.405 
一会儿就来讲看这个

00:38:25.472 --> 00:38:27.474 
这里我们要做的只是插入动画

00:38:27.875 --> 00:38:30.043 
具体定义结束位置

00:38:30.110 --> 00:38:33.046 
或者只是定义目标
或者是图片的初始边框

00:38:33.380 --> 00:38:35.182 
随后开始这个属性动画

00:38:35.249 --> 00:38:36.250 
并实时记录

00:38:36.817 --> 00:38:38.919 
要记住我们还有一个转场动画

00:38:38.986 --> 00:38:42.756 
时长与我们之前返回系统的
转场时长一样

00:38:43.423 --> 00:38:46.393 
我们只要确保
这个动画的方向是正确的

00:38:46.460 --> 00:38:48.795 
如果我们定义一个toPosition值为“开始”

00:38:48.862 --> 00:38:50.597 
我们需要推翻该animator

00:38:51.398 --> 00:38:55.736 
最后 如果这是第一次
联通这个动画

00:38:55.802 --> 00:38:58.539 
转场动画就会处于
非活动状态

00:38:58.739 --> 00:39:00.841 
所以我们要做的就是
开始这个转场动画

00:39:00.908 --> 00:39:02.509 
然后就进入动画进程

00:39:03.577 --> 00:39:06.647 
另外 如果程序开始后
又暂停了

00:39:06.947 --> 00:39:08.148 
我们要用不一样的东西

00:39:08.582 --> 00:39:10.350 
调出continueAnimation

00:39:11.018 --> 00:39:13.587 
withTimingParameters和durationFactor

00:39:13.654 --> 00:39:17.157 
continueAnimation
让你可以暂停一个动画

00:39:17.224 --> 00:39:19.793 
根据不同时间参数
和不同的时长

00:39:19.860 --> 00:39:21.295 
和剩余时长
随你喜好

00:39:21.628 --> 00:39:22.829 
这里要传递“nil”

00:39:22.896 --> 00:39:25.098 
表示我们要用的时间参数

00:39:25.165 --> 00:39:27.768 
是在初始化这个转场动画时
就已经输入过的

00:39:28.068 --> 00:39:32.139 
但是我们需要改变
后续动画的durationFactor

00:39:32.206 --> 00:39:34.541 
这使得我们能使时长同步

00:39:34.608 --> 00:39:37.010 
让新创建的itemFrameAnimator时长

00:39:37.077 --> 00:39:39.880 
与这个转场动画的剩余时长一致

00:39:40.180 --> 00:39:42.082 
durationFactor
从而定义为

00:39:42.149 --> 00:39:46.186 
1.0等同于之前设定的初始时长

00:39:46.253 --> 00:39:47.955 
在创建转场动画时

00:39:48.589 --> 00:39:51.325 
这就是开始动画进程
要做的所有事情

00:39:51.391 --> 00:39:52.593 
循环的最后一步

00:39:52.659 --> 00:39:54.795 
看一下pauseAnimation

00:39:54.928 --> 00:39:58.465 
这发生在动画进程中
但是暂停了

00:39:58.532 --> 00:40:00.200 
把手指放在图片视图下方

00:40:00.267 --> 00:40:03.670 
然后只要设置一个手势识别
在这个示例应用中的图片视图

00:40:03.904 --> 00:40:05.239 
现在这都是免费的了

00:40:05.305 --> 00:40:09.009 
因为UIViewPropertyAnimator会
自动点击测试动画视图

00:40:09.910 --> 00:40:12.579 
在刚刚创建的itemFrameAnimator里

00:40:12.646 --> 00:40:15.849 
我们要完全停止这个动画
就要设参数值为“真”

00:40:15.916 --> 00:40:20.521 
告诉系统我们不想
再继续此动画

00:40:20.587 --> 00:40:22.823 
而且我们要直接写模态值

00:40:24.157 --> 00:40:27.127 
应该是显示值直接返回模式

00:40:27.628 --> 00:40:31.164 
之后回到转场动画
调出pauseAnimation

00:40:31.231 --> 00:40:34.501 
就像updateInteraction里
看到的一样 我们会擦除动画

00:40:34.568 --> 00:40:36.036 
在我们与图片互动的时候

00:40:36.336 --> 00:40:38.672 
最后我们会告诉
转场context

00:40:38.739 --> 00:40:43.510 
我们要离开动画进程
回到交互进程

00:40:44.578 --> 00:40:46.880 
我再给大家展示另一个
技能和诀窍

00:40:47.748 --> 00:40:49.483 
也是这个演示应用的一个小细节

00:40:51.652 --> 00:40:56.156 
我们看到现在这个时间很慢
这是出于展示的目的

00:40:57.057 --> 00:40:59.426 
但你可能想要
更自然的感觉

00:40:59.493 --> 00:41:01.161 
再更生动一点

00:41:01.795 --> 00:41:04.698 
所以如果我们要
更改弹跳的时间

00:41:04.798 --> 00:41:06.366 
让它跳出页面

00:41:06.667 --> 00:41:09.570 
而且只让图片跳出页面

00:41:09.636 --> 00:41:11.538 
而这些背景动画还是继续

00:41:11.605 --> 00:41:13.941 
按照我们定义的
easeOut曲线运行

00:41:14.608 --> 00:41:16.577 
其实我们可以实现这个变化

00:41:16.643 --> 00:41:19.813 
让视觉更加生动
只用一行代码就可以

00:41:19.880 --> 00:41:21.448 
而且在非中断时
还可以继续互动

00:41:21.515 --> 00:41:23.217 
那么快速看一下这行代码

00:41:27.487 --> 00:41:28.856 
回到演示应用

00:41:28.922 --> 00:41:31.592 
看看propertyAnimator的方便方法

00:41:31.959 --> 00:41:34.528 
注意我们正在定义
一个属性动画

00:41:34.595 --> 00:41:36.630 
其时间参数在这里为线性

00:41:36.964 --> 00:41:39.066 
这也就是为什么感觉
动画很机械

00:41:39.533 --> 00:41:41.401 
我的一个同事留下了这个
伟大的注释

00:41:41.468 --> 00:41:44.104 
来定义某些SpringTimingParameters

00:41:44.171 --> 00:41:48.675 
并使用大规模数据 强度
阻尼和初始速率

00:41:48.742 --> 00:41:50.677 
这样就完整的定义了这个弹跳

00:41:51.178 --> 00:41:53.614 
当在创建
propertyAnimator

00:41:53.680 --> 00:41:56.483 
我们正在传递的时长
其实并不使用

00:41:56.750 --> 00:41:58.619 
而是会被计算

00:41:58.685 --> 00:42:00.821 
根据我们在弹跳时间中
所提供的属性

00:42:01.421 --> 00:42:05.425 
因此我们需要有一个
动画时长辅助函数

00:42:05.492 --> 00:42:08.161 
它只用propertyAnimator应用程序接口

00:42:08.228 --> 00:42:11.598 
就是下面这个
来计算时长

00:42:11.665 --> 00:42:13.934 
基本上它就为我们
解开了这个弹跳方程

00:42:14.001 --> 00:42:17.371 
我们可以用这个去匹配
转场动画的其他时长

00:42:18.372 --> 00:42:19.873 
这都超级简单

00:42:19.940 --> 00:42:23.310 
这个代码看上去
是有点复杂

00:42:23.377 --> 00:42:25.112 
但也确实只要
几百行而已

00:42:25.312 --> 00:42:28.115 
UIViewPropertyAnimator
使一切成为可能

00:42:28.415 --> 00:42:31.218 
就这样
让我们请回布鲁斯

00:42:36.056 --> 00:42:36.924 
谢谢你 Mike

00:42:39.092 --> 00:42:39.960 
好的

00:42:40.661 --> 00:42:43.197 
我得讲快点了
时间所剩无几

00:42:44.932 --> 00:42:47.034 
我们要来讲一点
点击测试

00:42:48.836 --> 00:42:52.840 
假定UserInteractionEnabled
值为真

00:42:52.906 --> 00:42:55.475 
我们实际上就可以
点击测试我们的视图

00:42:55.542 --> 00:42:58.212 
如果值为“假”
我们将吃掉所有触摸事件

00:42:58.745 --> 00:43:01.815 
我们将这个属性叫做
isManualHitTestingEnabled

00:43:01.882 --> 00:43:03.217 
并定义为“假”

00:43:03.650 --> 00:43:05.185 
默认值为“假”的原因是

00:43:05.252 --> 00:43:08.922 
我们想能够
点击测试我们的视图

00:43:09.189 --> 00:43:12.292 
如果值为“真”
也就是现在的系统活动

00:43:12.459 --> 00:43:15.596 
当你要触摸
这个视图下面的位置

00:43:15.662 --> 00:43:17.297 
就会发现我们无法点击测试

00:43:17.798 --> 00:43:21.802 
令人迷惑的是
好像只在它运动方向上开始点击测试

00:43:22.069 --> 00:43:25.839 
我们不想要这样的结果
尤其是对可中断的属性动画

00:43:26.106 --> 00:43:29.142 
在这个演讲下方
我想你们推荐

00:43:29.510 --> 00:43:32.746 
一个技能
让你们可以重写点击测试

00:43:32.813 --> 00:43:35.749 
做一些计算来绕过
显示层面

00:43:35.816 --> 00:43:39.286 
调令“super”
来点击测试一个移动视图

00:43:40.320 --> 00:43:41.822 
这个技术依然生效

00:43:41.889 --> 00:43:45.225 
但是现在有了propertyAnimators
如果你有移动视图

00:43:45.292 --> 00:43:48.095 
默认的手动
点击测试值为假

00:43:48.161 --> 00:43:50.898 
我们实际上就在
点击测试这个视图

00:43:51.498 --> 00:43:53.667 
所以这很酷炫
也很轻松

00:43:53.734 --> 00:43:56.904 
事实上 这个舞台上
我们看到的所有东西

00:43:56.970 --> 00:43:58.238 
之前都是好用的

00:43:58.805 --> 00:44:00.307 
现在出了些问题

00:44:00.374 --> 00:44:02.509 
如果你有深层的视图层
或者其他

00:44:02.576 --> 00:44:04.244 
我们就无法正确运行

00:44:04.578 --> 00:44:08.949 
这时你可能就要用其他技术
可能在其他演讲中有提过

00:44:10.250 --> 00:44:11.084 
好的

00:44:11.151 --> 00:44:14.321 
我们今天讲了关键帧动画
所用的整个应用程序接口

00:44:14.388 --> 00:44:16.590 
这是UIKit现在所有的接口

00:44:16.790 --> 00:44:18.592 
如果让它可中断？

00:44:18.825 --> 00:44:20.727 
要重调
关键帧动画

00:44:20.794 --> 00:44:24.565 
作为一个常用动画
除非你定义一个路径

00:44:24.631 --> 00:44:27.201 
来导入你想要的动画

00:44:29.236 --> 00:44:31.471 
我们也想让他们
变成可中断的

00:44:32.439 --> 00:44:36.343 
事实上我们想要做的
跟现在视频上看到的是一样的

00:44:36.410 --> 00:44:37.845 
我们要暂停它 擦除它

00:44:38.245 --> 00:44:40.380 
这应该都是意料之中

00:44:40.447 --> 00:44:41.982 
而且 你可以做到

00:44:42.182 --> 00:44:43.383 
这很简单

00:44:43.450 --> 00:44:45.252 
使用现有的接口

00:44:45.319 --> 00:44:50.190 
封装动画控制器的动画

00:44:50.457 --> 00:44:54.194 
从而你的关键帧动画
也是可中断的了

00:44:58.732 --> 00:45:00.734 
我再说最后一点
虽然听上去是在撒谎

00:45:01.268 --> 00:45:03.337 
互动PopGestureRecognizers

00:45:03.403 --> 00:45:05.906 
这是内置的导航弹出视图

00:45:06.340 --> 00:45:08.876 
现在如果你有
一个交互控制器

00:45:09.443 --> 00:45:10.777 
你就无法使用这个

00:45:11.445 --> 00:45:14.948 
但是新的iOS 10里
如果你输入一个错误请求

00:45:15.048 --> 00:45:17.951 
给手势识别或者你自己

00:45:18.318 --> 00:45:22.322 
那么内置的弹出
手势识别就可以识别了

00:45:22.389 --> 00:45:28.462 
使用内置导航转场
要与你自定义的互动一起

00:45:30.964 --> 00:45:32.199 
总的来说

00:45:33.300 --> 00:45:37.471 
我们学习了如何使用UIViewPropertyAnimator
创建可中断动画

00:45:38.372 --> 00:45:42.075 
你可以用到很多全新的
时间函数

00:45:42.843 --> 00:45:45.746 
你可以使用可中断的
propertyAnimators

00:45:45.812 --> 00:45:48.882 
去创建可中断的
视图控制器转场

00:45:49.750 --> 00:45:52.319 
更多信息请浏览这个网址

00:45:52.753 --> 00:45:54.588 
这里有其他有关UIKit的演讲

00:45:54.655 --> 00:45:57.858 
他们讲的是动画的其他种类
其中两个就在明天

00:45:57.925 --> 00:45:59.359 
我希望你们听一听 看一看

00:45:59.860 --> 00:46:00.827 
谢谢