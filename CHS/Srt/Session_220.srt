00:00:20.020 --> 00:00:22.756
在iOS上使用触摸输入

00:00:22.823 --> 00:00:23.857
早上好

00:00:29.129 --> 00:00:31.765
欢迎来到在iOS上使用触摸输入

00:00:31.999 --> 00:00:34.168
我是Dominik Wagner
我是工程师

00:00:34.234 --> 00:00:36.403
在UIKit团队
我会告诉你

00:00:36.470 --> 00:00:39.206
如何最好地利用我们的进展

00:00:39.273 --> 00:00:41.909
关于Multi-Touch
和Apple Pencil

00:00:42.843 --> 00:00:46.313
首先让我们回顾一下最近新发布的硬件

00:00:46.380 --> 00:00:49.850
从去年WWDC起
我们发布了很多东西

00:00:50.851 --> 00:00:54.521
比如带3D Touch的
iPhone 6s和6s plus

00:00:55.055 --> 00:00:57.824
允许你使用每种触摸的能力

00:00:58.559 --> 00:01:00.294
我不会就此谈太多

00:01:00.561 --> 00:01:04.965
但是你可以了解Peek和Pop
带来的良好体验

00:01:05.465 --> 00:01:07.835
在今天晚些时候的演讲
“窥视3D Touch”中

00:01:09.403 --> 00:01:13.273
我们介绍了更快的触摸扫描
从iPad Air 2和iPad Pro开始

00:01:13.340 --> 00:01:16.877
给我们一个时间分辨率
是显示刷新的两倍

00:01:18.111 --> 00:01:21.281
我们还介绍了针对Apple iPad Pro
的Apple Pencil

00:01:21.715 --> 00:01:26.720
这个惊艳的设备 谢谢
给你精确的定位

00:01:26.787 --> 00:01:28.789
为你的绘画提供很好的精度

00:01:29.523 --> 00:01:33.060
它有更高的时间分辨率
是240赫兹

00:01:34.862 --> 00:01:39.633
它允许你使用它的倾斜和方向
当然还有力量

00:01:41.301 --> 00:01:44.805
我们的算法组在手掌拒绝上做了
很好的工作

00:01:45.172 --> 00:01:49.576
所以你可以在绘画时休息手掌
不需要考虑它

00:01:50.777 --> 00:01:53.647
还发布了带有Siri Remote的
Apple TV

00:01:54.848 --> 00:01:57.985
它的轨迹主要驱动
UIFocusEngine

00:01:58.051 --> 00:01:59.987
和你与Apple TV的互动

00:02:00.721 --> 00:02:04.491
但是你还能使用跟踪板
通过使用游戏控制器框架

00:02:04.558 --> 00:02:10.229
用来做为一个游戏控制器
和获得跟踪板的绝对位置

00:02:11.064 --> 00:02:14.334
最后你还可以处理跟踪板

00:02:14.401 --> 00:02:18.071
在UIKit触摸处理方法中的
间接触摸

00:02:19.006 --> 00:02:23.110
我也不会谈太多这方面
但有很好的Apple TV技术演讲

00:02:23.177 --> 00:02:28.182
还有昨天的Apple TV
游戏控制器输入

00:02:28.882 --> 00:02:30.384
那我要讲什么？

00:02:30.784 --> 00:02:33.754
我要讲你怎么开发绘画应用

00:02:34.288 --> 00:02:36.790
我们会从头开始开发一个绘画应用

00:02:36.857 --> 00:02:40.127
并且我会谈到所有针对
Apple Pencil的新API

00:02:40.194 --> 00:02:43.096
所以你能访问所有的新数据

00:02:44.097 --> 00:02:46.466
我们会一步步告诉你

00:02:47.034 --> 00:02:52.072
向你展示你可以采用的不同步骤
根据你看到的

00:02:52.706 --> 00:02:56.410
这个应用的全部代码是可以下载的

00:02:56.476 --> 00:03:01.281
所以你不用担心幻灯片上的代码
晚些时候和它玩一玩

00:03:02.282 --> 00:03:05.285
向SpeedSketch问好
这是我们的例子

00:03:06.553 --> 00:03:09.323
SpeedSketch是一张纸
你可以在上面绘画

00:03:09.389 --> 00:03:12.626
它完全支持iPad Pro
上的Apple Pencil

00:03:13.026 --> 00:03:16.330
和iPhone 6S上的
3D Touch

00:03:16.396 --> 00:03:19.399
它还工作在所有以前的iOS设备上

00:03:20.667 --> 00:03:22.469
让我们先谈谈模型

00:03:25.639 --> 00:03:31.011
这是一个笔画
这是UIKit如何看到取样

00:03:31.078 --> 00:03:33.981
每个点是一个实例

00:03:34.047 --> 00:03:36.450
和可变的UITouch是同样的实例

00:03:36.750 --> 00:03:39.086
你传递给触摸处理方法

00:03:39.820 --> 00:03:43.657
并且我们建模我们的数据为一系列
笔画

00:03:47.594 --> 00:03:49.563
因为UITouch是

00:03:49.630 --> 00:03:52.332
一个可变量
表示一个触摸序列

00:03:52.833 --> 00:03:57.571
我们需要在触摸处理方法中
从UITouch中复制出数据

00:03:57.838 --> 00:03:59.439
到更静态的东西中

00:04:01.241 --> 00:04:03.110
所以我们会创建一个笔画取样

00:04:03.177 --> 00:04:06.213
做为我们的数据结构最深层的元素

00:04:06.947 --> 00:04:10.918
它现在只包括UITouch的位置

00:04:10.984 --> 00:04:14.321
稍后我们会填入额外的数据

00:04:15.856 --> 00:04:19.593
我们会把那些取样放入一个笔画

00:04:19.660 --> 00:04:21.394
是一个笔画取样数组

00:04:21.461 --> 00:04:25.199
我们有一些方法来添加它们

00:04:26.266 --> 00:04:28.335
因为我们想用笔画

00:04:28.402 --> 00:04:33.407
作为我们的主数据获取结构
它还有一个状态

00:04:33.974 --> 00:04:36.977
当用户在绘画时它是活动的
是完成

00:04:37.044 --> 00:04:39.246
当用户完成时
可以是取消

00:04:39.313 --> 00:04:42.783
如果另一个用户操作造成它被取消

00:04:42.850 --> 00:04:45.419
所以我们可以抛弃它而不是保留它

00:04:47.554 --> 00:04:49.857
最后我们把这些放入一个笔画集合

00:04:49.923 --> 00:04:54.728
它是一个笔画数组
我们会添加完成的笔画

00:04:54.795 --> 00:04:57.297
要使它成为我们的应用的
一个完整的数据模型

00:04:57.364 --> 00:05:00.300
我们要把活动笔画做为一个可选项

00:05:00.367 --> 00:05:04.938
这样我们可以用这个笔画集合作为
一个完整应用的数据模型

00:05:05.973 --> 00:05:08.642
下一个问题是在哪获取那些笔画

00:05:09.576 --> 00:05:12.346
基本上你有3个地方可以这么做

00:05:12.412 --> 00:05:15.249
第一个是UIGestureRecognizer

00:05:15.315 --> 00:05:17.885
一个定制的UIGestureRecognizer
子类

00:05:18.986 --> 00:05:23.156
下一个要寻找的地方
是一个UIView子类

00:05:24.057 --> 00:05:26.226
触摸到达这里

00:05:26.293 --> 00:05:31.164
你可以顺着响应器链向上处理
我想

00:05:31.231 --> 00:05:33.133
我想你想想这个的顺序

00:05:33.200 --> 00:05:37.604
若你可以用一个定制子类
或UIGestureRecognizer来做

00:05:38.205 --> 00:05:43.110
第二用UIView并尽可能接近你
能得到事件的地方

00:05:43.177 --> 00:05:46.146
最后才不得不沿着响应器链向上

00:05:48.749 --> 00:05:50.117
这就是我们要做的

00:05:50.684 --> 00:05:54.188
我们创建一个子类独有的
笔画手势识别器

00:05:54.888 --> 00:05:56.957
我们会把我们的主视图控制器作为
目标

00:05:58.892 --> 00:06:00.394
然后在行动方法中

00:06:00.460 --> 00:06:04.031
我们会用笔画触发一个视图重绘

00:06:05.899 --> 00:06:08.535
让我们开始创建这个手势识别器子类

00:06:08.602 --> 00:06:12.906
要做的第一件事是导入
UIGestureRecognizer子类

00:06:13.273 --> 00:06:16.810
这向你暴露
UIGestureRecognizer的内部

00:06:16.877 --> 00:06:18.846
这样你可以创建子类

00:06:19.246 --> 00:06:22.549
但要小心
不要使用这些内部

00:06:22.616 --> 00:06:24.952
在UIGestureRecognizer以外

00:06:25.018 --> 00:06:29.656
比如状态设置器被暴露
如果你导入它

00:06:29.723 --> 00:06:32.726
你不应该在子类以外使用它

00:06:32.793 --> 00:06:39.466
否则手势系统会工作异常
你会有许多问题需要调试

00:06:41.134 --> 00:06:43.504
让我们添加我们的笔画做为
主数据结构

00:06:43.570 --> 00:06:46.173
在我们的手势识别器中获得笔画

00:06:46.573 --> 00:06:48.475
并实现触摸处理方法

00:06:49.376 --> 00:06:54.848
因为我们做很多相似的事情
在总计4个触摸处理方法中

00:06:54.915 --> 00:06:59.920
我们会有一个辅助方法实际上
查看这一系列UITouch

00:07:00.220 --> 00:07:03.991
决定我们是否对触摸的其中之一
感兴趣

00:07:04.725 --> 00:07:07.895
把它加入我们的数据模型
就是复制它的位置

00:07:07.961 --> 00:07:11.265
在此时作为一个取样
并返回给我们

00:07:11.331 --> 00:07:12.866
如果你对此感兴趣

00:07:13.433 --> 00:07:16.770
我们会在这个触摸开始
函数中使用辅助方法

00:07:16.837 --> 00:07:18.872
并把状态设置成开始

00:07:19.406 --> 00:07:22.142
对UIGestureRecognizer
这是反常的

00:07:22.209 --> 00:07:26.680
因为在状态可能和状态开始之间
的时间

00:07:26.747 --> 00:07:32.252
是不同的手势识别器发生竞争的时间
处理这些触摸序列

00:07:32.686 --> 00:07:36.190
但是对我们的笔画
我们很想它马上开始

00:07:36.256 --> 00:07:37.457
当触摸向下传递时

00:07:37.524 --> 00:07:39.760
所以这是我们要做的

00:07:41.261 --> 00:07:44.831
在touchesMoved中
我们做相同的事并把状态切换成已改变

00:07:44.898 --> 00:07:46.466
注意在手势识别器中

00:07:46.533 --> 00:07:50.370
每个状态改变触发一个行动方法
即使是相同的

00:07:51.538 --> 00:07:54.308
我们对触摸结束和取消做相同的事

00:07:56.109 --> 00:08:02.149
最后我们重置手势识别器
用一个新的笔画取代之前那个

00:08:02.216 --> 00:08:03.851
这样我们能获取下一个

00:08:04.551 --> 00:08:06.987
做为好公民
我们总是调用super.reset

00:08:10.090 --> 00:08:12.492
让我们在视图控制器中使用它

00:08:14.361 --> 00:08:18.031
在viewDidLoad函数中
我们设置笔画手势识别器

00:08:18.098 --> 00:08:22.336
把我们自己做为目标
动作是笔画更新了

00:08:22.402 --> 00:08:24.638
然后把它加到主视图

00:08:26.740 --> 00:08:29.776
在更新回调中
我们从手势中获得笔画

00:08:29.843 --> 00:08:32.446
然后设置到我们的视图中

00:08:32.513 --> 00:08:33.914
现在就做这些

00:08:34.815 --> 00:08:36.950
我告诉过你笔画集合

00:08:37.017 --> 00:08:40.287
只是提一下
我想要保持它简单

00:08:41.455 --> 00:08:43.991
所以让我们看看它给我们什么

00:08:45.692 --> 00:08:48.929
我总是喜欢这一刻
一些东西第一次运行

00:08:50.564 --> 00:08:56.136
你看到的是
这是Pencil在屏幕上的位置

00:09:00.374 --> 00:09:01.441
让我们看一看

00:09:04.144 --> 00:09:06.480
这看起来不好

00:09:07.848 --> 00:09:08.849
发生了什么？

00:09:09.316 --> 00:09:11.118
让我们仔细看看慢动作

00:09:17.057 --> 00:09:18.759
这完全不是我们想要的

00:09:18.825 --> 00:09:20.794
我们看到了什么？

00:09:20.861 --> 00:09:22.696
我们有Pencil的位置

00:09:23.297 --> 00:09:26.967
我们和最后画的那条线之间有
非常非常大的距离

00:09:28.735 --> 00:09:31.371
我们画的线很长而且不断改变方向

00:09:31.438 --> 00:09:33.507
这不是我期待的

00:09:33.574 --> 00:09:36.043
我们有很好的时间分辨率

00:09:36.109 --> 00:09:37.611
为什么它看起来是这样？

00:09:38.512 --> 00:09:40.480
显然我们错过了一些事件

00:09:41.014 --> 00:09:43.550
因为多个原因我们错过了一些事件

00:09:43.617 --> 00:09:46.687
其中之一是我们的绘制引擎的
实现很幼稚

00:09:47.020 --> 00:09:50.724
它每次都绘制一个完整位图
以及每次有事件进入时

00:09:50.791 --> 00:09:55.529
它的速度不足以跟上显示率

00:09:56.129 --> 00:09:58.131
我们会晚点谈到这方面

00:09:58.498 --> 00:10:02.769
最重要的是我们没有用iOS 9的
新API

00:10:02.836 --> 00:10:05.606
我们应该这么做来获得我们错过
的事件

00:10:05.939 --> 00:10:09.176
因此我想再仔细地看看笔画

00:10:10.677 --> 00:10:11.979
让我们再看一次

00:10:12.913 --> 00:10:15.983
这里的所有取样我们都想有
并且看到

00:10:17.985 --> 00:10:22.523
在我们的触摸处理方法中
我们永远都得到开始

00:10:23.156 --> 00:10:28.829
和结束 但是在中间
我们得到touchesMoved

00:10:31.365 --> 00:10:35.402
我们没有得到所有的作为取样进来
的touchesMoved

00:10:36.270 --> 00:10:37.671
这是有原因的

00:10:37.738 --> 00:10:40.974
如果我们发给你
所有的touchesMoved

00:10:41.041 --> 00:10:43.010
即使你阻塞主线程

00:10:43.310 --> 00:10:45.579
你会看到一些东西类似于重播

00:10:45.646 --> 00:10:48.215
触摸互动的重播
如果你是进行实时互动

00:10:48.515 --> 00:10:50.050
这完全不是你想要的

00:10:50.117 --> 00:10:52.553
你想要发送给你的最新位置

00:10:52.953 --> 00:10:54.488
那是我们通常做的

00:10:54.555 --> 00:10:56.823
那是我们在OS 9之前做在

00:10:56.890 --> 00:10:58.625
实际上我们抛弃了其他事件

00:10:58.692 --> 00:11:02.462
如果你在主循环中不够快

00:11:02.763 --> 00:11:06.466
那么你看不到它们中的任何一个
但是从iOS 9开始

00:11:06.533 --> 00:11:09.102
我们使你能访问以前的事件

00:11:09.703 --> 00:11:14.641
另一个原因是我们的数字转换器
现在比显示更快

00:11:16.109 --> 00:11:21.481
我们不想在我们有的每个数据点
都给你一个事件

00:11:21.982 --> 00:11:23.951
你会进行太多工作

00:11:24.017 --> 00:11:26.186
所以我们试着把它们合并在一起

00:11:26.620 --> 00:11:30.157
每次屏幕刷新发送一个

00:11:33.527 --> 00:11:38.866
你现在能做的是使用你从API
获得的实时触摸

00:11:39.233 --> 00:11:41.935
查询错过的触摸

00:11:42.236 --> 00:11:44.605
这将包括你当前查询的触摸

00:11:44.671 --> 00:11:46.874
这样你就有个完整一致的图像

00:11:47.241 --> 00:11:49.676
这些触摸被称为合并触摸

00:11:50.244 --> 00:11:52.546
你为所有的触摸事件做这件事

00:11:55.549 --> 00:11:58.252
也为开始和结束这么做

00:11:58.952 --> 00:12:00.954
因为你要待在相同的地方

00:12:01.021 --> 00:12:04.892
或者处理你的实时触摸
或者合并触摸

00:12:05.325 --> 00:12:08.462
因为视图里有方法比如之前位置

00:12:08.529 --> 00:12:11.632
是之前触摸的引用
如果你混合搭配

00:12:11.698 --> 00:12:13.267
那你会遇到问题

00:12:14.434 --> 00:12:18.172
现在我们知道怎么获得它们
让我们在代码中这么做

00:12:20.641 --> 00:12:23.477
这个方法是coalescedTouches
为了触摸UIEvent

00:12:23.544 --> 00:12:25.946
你在触摸处理回调函数中获得事件

00:12:27.514 --> 00:12:34.288
这个结果可选不是因为我们会给
你无值

00:12:35.155 --> 00:12:38.392
任何时候如果你只有一个触摸
而且我们没有合并触摸

00:12:38.725 --> 00:12:43.230
这是因为你可以要求任何
不是事件一部分的UI测试

00:12:43.297 --> 00:12:44.498
那么你会得到无值

00:12:44.565 --> 00:12:46.934
你一定会得到UITouch

00:12:47.000 --> 00:12:50.070
至少你放入的一个
即使我们没有合并更多

00:12:50.470 --> 00:12:54.308
所以你不需要在这用一个if语句

00:12:55.442 --> 00:12:57.277
让我们把这些用在代码中

00:12:58.912 --> 00:13:01.448
在我们的代码中 看看感兴趣的触摸

00:13:01.515 --> 00:13:04.484
我们进行了触摸追加
我们需要做的是循环

00:13:04.551 --> 00:13:07.554
在合并触摸中并且追加那些

00:13:08.021 --> 00:13:09.423
这给你所有数据

00:13:10.490 --> 00:13:12.392
让我们看看它看起来是怎样的

00:13:15.062 --> 00:13:17.598
很好 现在我们真的有所有数据了

00:13:18.432 --> 00:13:20.300
让我们比较一下

00:13:24.571 --> 00:13:27.808
在有一个停止的慢动作中

00:13:30.777 --> 00:13:32.012
你在这看到什么

00:13:32.079 --> 00:13:35.649
这是Pencil现在玻璃上的位置

00:13:36.884 --> 00:13:40.954
灰色的是合并触摸

00:13:41.021 --> 00:13:43.557
现在调试绘制引擎

00:13:44.157 --> 00:13:48.262
黑色的也是合并触摸
但是对应那些实时触摸

00:13:49.630 --> 00:13:52.900
你还可以看到有太多合并触摸

00:13:53.467 --> 00:13:56.904
如果我们的数字转换器是以四倍
于显示的速度运行 你看到

00:13:56.970 --> 00:14:01.074
我们应该看到黑色之间平均应该
有三个灰色

00:14:01.508 --> 00:14:02.709
这太多了

00:14:04.111 --> 00:14:06.480
我们在末尾的间隙也很大

00:14:06.547 --> 00:14:10.617
这引起延迟
用户可见的延迟

00:14:12.452 --> 00:14:13.353
我们看到什么？

00:14:13.787 --> 00:14:15.589
我们绘制引擎的速度还是落后了

00:14:15.656 --> 00:14:17.357
我们目前还没有解决它

00:14:18.292 --> 00:14:20.627
但是UIKit通过合并触摸帮助我们

00:14:20.694 --> 00:14:24.264
最后的绘制有它需要的所有数据

00:14:24.698 --> 00:14:27.968
所以如果你只获取这一类中的
一件事

00:14:28.035 --> 00:14:30.037
那么用合并触摸
如果你真的想

00:14:30.103 --> 00:14:32.606
获得你Pencil的丰富数据

00:14:37.311 --> 00:14:39.546
那绘制的问题出在哪？

00:14:39.613 --> 00:14:41.615
你不应该在每个触摸事件上绘制

00:14:42.015 --> 00:14:44.384
因为显示刷新率只有60赫兹

00:14:44.751 --> 00:14:48.689
尽管我们试着每帧只传递一个事件

00:14:49.189 --> 00:14:51.425
你可以知道
有时候是不可能的

00:14:51.491 --> 00:14:54.494
因为如果你把手指和Pencil混合

00:14:54.561 --> 00:14:58.398
或者有其他事件传入
我们需要按顺序发送它们

00:14:58.465 --> 00:15:04.238
因此你需要准备好
获得比显示刷新率多的事件

00:15:05.138 --> 00:15:06.907
但是不要试着绘制更快

00:15:06.974 --> 00:15:11.245
因为这只会影响性能并增加延迟

00:15:11.311 --> 00:15:14.681
做一些甚至不会显示在屏幕上的工作

00:15:15.315 --> 00:15:16.483
那你应该何时渲染？

00:15:16.550 --> 00:15:20.087
在我们的例子中我们使用
一个普通的UIView和核心图像

00:15:20.654 --> 00:15:24.324
在这个情况下你应该在那个视图中
使用需要显示

00:15:24.858 --> 00:15:28.195
来标记那个视图需要更新并把工作
交给CA

00:15:28.262 --> 00:15:33.400
来调用你需要实现的绘制方法
而不是你定制的位图绘制

00:15:34.401 --> 00:15:37.504
如果你在用一个GLKView
或MetalView

00:15:38.205 --> 00:15:42.476
你还可以选择这些行为而不是
一个不变的更新

00:15:42.910 --> 00:15:46.346
通过把enableSetsNeedsDisplay
属性设置为真

00:15:46.947 --> 00:15:50.784
这样如果你想要的话
那些视图的行为是一样的

00:15:51.718 --> 00:15:53.687
如果你想用固定的速度绘制

00:15:53.754 --> 00:15:57.457
然后请用固定的速度绘制
不要根据进入的事件

00:15:57.524 --> 00:16:02.529
你可以用Metal和GLViews
的内部机制这么做

00:16:02.596 --> 00:16:05.432
或者你可以用
CADisplayLink这么做

00:16:05.499 --> 00:16:08.202
在你的DisplayLink
唤醒时 调用显示

00:16:08.602 --> 00:16:12.172
我们所做的是在我们的
StrokesCGView中

00:16:12.239 --> 00:16:16.109
一个在笔画上的didSet函数
用drawImageAndUpdate函数绘制

00:16:16.343 --> 00:16:18.512
这创建位图
这并不好

00:16:18.846 --> 00:16:21.248
让我们用
setsNeedsDisplay

00:16:22.916 --> 00:16:25.552
并且把绘制代码移动到绘制方法中

00:16:26.320 --> 00:16:29.189
如果你使用一个普通的UFU
你可以做得更好

00:16:29.489 --> 00:16:33.360
你可以只标记改变了的区域
用setNeedsDisplayIn(rect)

00:16:34.094 --> 00:16:38.232
这也需要一些触摸的档案管理

00:16:38.298 --> 00:16:42.703
因为你的绘制可能稍微大于
改变了的触摸

00:16:42.769 --> 00:16:45.339
和采样中的触摸改变

00:16:45.739 --> 00:16:48.575
你可以看一个示例代码来得到一个
例子

00:16:48.642 --> 00:16:51.011
关于你如何进行这类档案管理

00:16:52.713 --> 00:16:56.149
更进一步 你可以在这一层上
激活drawsAsynchronously

00:16:57.050 --> 00:17:03.090
这把所有你在绘制矩形里所做
的绘制向上传递到CG和CA

00:17:03.156 --> 00:17:05.992
CA在主线程外绘制它

00:17:06.126 --> 00:17:09.128
使你的主线程能更快进行事件处理

00:17:09.663 --> 00:17:13.767
要这么做你只需要简单地设置
drawsAsynchronously为真

00:17:13.834 --> 00:17:15.301
在你的扩散层上

00:17:16.537 --> 00:17:18.172
让我们看看这带我们进行了多远

00:17:25.412 --> 00:17:26.512
再一次在慢动作中

00:17:32.920 --> 00:17:36.423
现在我们有我说过的稳定的
合并触摸数量

00:17:36.490 --> 00:17:39.293
大约3个合并触摸和1个黑色的

00:17:40.861 --> 00:17:42.429
但我们还是有些延迟

00:17:42.496 --> 00:17:47.634
但是它小多了因为我们按显示的
速度进行绘制

00:17:47.868 --> 00:17:51.538
我们只有剩余的延迟

00:17:51.905 --> 00:17:53.307
我们怎么改进它？

00:17:53.874 --> 00:17:58.478
从iOS 9起我们有一个功能叫做
预测触摸

00:17:58.812 --> 00:18:02.282
预测触摸让你瞥见未来

00:18:02.349 --> 00:18:06.820
和合并触摸的使用方法相同
你询问事件

00:18:06.887 --> 00:18:09.056
触摸的预测触摸

00:18:09.122 --> 00:18:13.760
你得到未来的一个触摸数组

00:18:15.896 --> 00:18:17.464
你对这些触摸做什么？

00:18:17.531 --> 00:18:20.300
你临时把它们加入你的数据结构

00:18:20.367 --> 00:18:22.269
他们在每个事件回调中改变

00:18:22.536 --> 00:18:25.038
所以你必须临时加入它们

00:18:25.906 --> 00:18:28.041
你根据你的应用选择它们的外观

00:18:28.842 --> 00:18:33.914
我强烈推荐你使它们看起来像
真正的触摸

00:18:34.882 --> 00:18:36.250
看看结果

00:18:36.750 --> 00:18:41.922
除非我们的预测偏差太多
那么降低它

00:18:41.989 --> 00:18:46.994
使它看起来像暂定的
使它仍然看起来接近Pencil

00:18:49.563 --> 00:18:51.365
让我们看看代码

00:18:52.199 --> 00:18:55.736
现在在我们的触摸设置方法
当你添加合并触摸之后

00:18:58.138 --> 00:19:01.642
你临时添加预测触摸

00:19:02.075 --> 00:19:06.180
你需要确保删除之前添加的临时触摸

00:19:07.347 --> 00:19:09.516
我会给你看一个视频
看看它看起来怎样

00:19:09.583 --> 00:19:11.351
和你应该做的对比

00:19:11.418 --> 00:19:15.422
我会用红色高亮预测触摸这样我们
可以看到

00:19:15.489 --> 00:19:18.458
如果它对我们的例子足够好

00:19:21.094 --> 00:19:23.730
再次在慢动作中
因为这很快

00:19:29.903 --> 00:19:34.608
这些是预测触摸
它使你更接近实际的Pencil位置

00:19:35.175 --> 00:19:39.947
这非常非常有助于屏幕上可见的
延迟

00:19:40.180 --> 00:19:43.817
你可以在这个例子中看到
这工作得很好

00:19:43.884 --> 00:19:45.118
所以我们会使用它们

00:19:45.185 --> 00:19:47.888
用我们绘制普通触摸一样的方式
绘制它们

00:19:49.456 --> 00:19:50.757
目前为止我们看到什么？

00:19:51.158 --> 00:19:55.295
我们看到了如何收集输入
使用定制的UIGestureRecognizer

00:19:56.163 --> 00:19:58.265
如何访问合并触摸

00:20:00.400 --> 00:20:02.903
如何使渲染更快并有效率

00:20:03.971 --> 00:20:06.340
最后 如何使用预测触摸

00:20:06.406 --> 00:20:10.677
所有的这些技术工作在所有iOS
设备上

00:20:10.744 --> 00:20:15.349
我们在例子中针对Pencil使用它们
但它们基本在其它设备也都运作

00:20:15.682 --> 00:20:20.888
现在让我们看看
新Apple Pencil API

00:20:22.389 --> 00:20:24.324
让我们从触摸类型开始

00:20:24.791 --> 00:20:29.830
有了Apple Pencil
UITouch添加了新类型的方法

00:20:30.163 --> 00:20:33.834
UITouch类型
可以是三个值中的一个

00:20:34.268 --> 00:20:38.338
可以是直接
是你知道的以前的所有触摸

00:20:39.673 --> 00:20:43.443
有只针对Siri Remote
的间接触摸

00:20:44.211 --> 00:20:47.214
还有针对Apple Pencil
的尖笔

00:20:50.918 --> 00:20:54.855
你用Apple Pencil可获得的
第一个东西是更高的精度

00:20:54.922 --> 00:20:58.091
你在视图中用精确位置

00:20:58.892 --> 00:21:01.695
你还在视图中有精确的以前的位置

00:21:02.362 --> 00:21:05.132
无论何时你想要精确位置时你
应该用那些

00:21:05.199 --> 00:21:06.667
针对像是绘画的一些事

00:21:06.733 --> 00:21:08.235
如果你想进行点击测试

00:21:08.302 --> 00:21:12.973
你还是应该用以前的
叫做位置在

00:21:13.040 --> 00:21:14.741
和以前的位置在

00:21:15.142 --> 00:21:17.311
但是对绘画 这会带来不同

00:21:17.644 --> 00:21:19.079
没有精确位置

00:21:19.146 --> 00:21:22.649
你会在你的绘画中加入一些楼梯状
的图案

00:21:22.716 --> 00:21:23.984
这是你不想看到的

00:21:24.551 --> 00:21:27.588
你可以向所有的触摸要求精确位置

00:21:27.654 --> 00:21:29.556
你将只获得普通的

00:21:31.325 --> 00:21:33.293
接下来有力量

00:21:33.360 --> 00:21:38.432
力量做为一个叫作力量的属性暴露
还有一个最大可能力量

00:21:38.765 --> 00:21:40.100
它们是CGFloat类型

00:21:40.868 --> 00:21:44.238
它们的范围是0到最大可能力量

00:21:44.605 --> 00:21:47.541
1.0表示平均的触摸

00:21:47.608 --> 00:21:50.244
所以它们不是物理值

00:21:50.310 --> 00:21:53.780
所以你不应该做任何和实际的
力量有关的事

00:21:53.847 --> 00:21:59.152
但是你用这些值来影响你的绘画

00:22:00.988 --> 00:22:06.894
在所有之前的设备和普通手指触摸
它会永远返回0

00:22:09.763 --> 00:22:10.998
关于力量的快速说明

00:22:11.064 --> 00:22:13.767
因为我们把力量加入了UITouch

00:22:13.834 --> 00:22:16.003
在触摸处理中有一个不同

00:22:16.069 --> 00:22:19.306
touchesMoved
被更多地调用

00:22:19.373 --> 00:22:23.310
因为你想要能够区分力量是否变化了

00:22:24.011 --> 00:22:26.680
我们现在会一直发送
touchesMoved给你

00:22:26.747 --> 00:22:31.485
以前我们努力尝试只发送
touchesMoved给你

00:22:31.552 --> 00:22:33.554
当位置改变时

00:22:35.055 --> 00:22:38.125
那是通过普通位置
甚至不是精确位置

00:22:38.926 --> 00:22:40.894
这给了你一些暗示

00:22:41.395 --> 00:22:44.231
比如你在野外看到很多这种

00:22:44.298 --> 00:22:46.400
若你在touchesMoved中
做了

00:22:46.466 --> 00:22:51.638
如果你有意取消一个点击
这不好

00:22:51.705 --> 00:22:53.240
这不再工作

00:22:53.907 --> 00:22:59.012
你看到在iPhone 6s上
或者用Pencil

00:22:59.079 --> 00:23:02.883
如果你不得不非常非常轻地触摸屏幕

00:23:02.950 --> 00:23:04.685
这是你会遇到的

00:23:04.751 --> 00:23:07.187
你需要看看你的触摸处理代码

00:23:07.487 --> 00:23:08.522
你应该怎么做？

00:23:08.989 --> 00:23:11.725
如果可以你应该使用
UITouchGesturesRecognizer

00:23:11.792 --> 00:23:14.628
因为它封装了我们的所有知识

00:23:14.695 --> 00:23:19.733
至少你需要做的事
是记得触摸开始的位置

00:23:19.800 --> 00:23:24.104
只取消它

00:23:24.171 --> 00:23:25.606
当你从开始位置移动了足够远时

00:23:27.307 --> 00:23:30.744
让我们把力量加入模型
到我们的笔画取样中

00:23:31.078 --> 00:23:34.615
我们用一个可选的力量变量这么做

00:23:35.682 --> 00:23:41.555
我们晚点会添加其他东西
我不会再显示这个幻灯片

00:23:41.622 --> 00:23:45.826
所以让我们看看力量在我们的绘制
中是什么样的

00:23:47.995 --> 00:23:49.630
很好 我们做了什么？

00:23:50.063 --> 00:23:53.166
我们改变了力量的宽度空间

00:23:55.068 --> 00:23:57.204
下一个是倾斜

00:23:58.005 --> 00:24:01.542
Apple Pencil使你能利用
它和设备之间的倾斜

00:24:01.842 --> 00:24:04.211
这是用角度来测量的

00:24:04.278 --> 00:24:08.515
在Pencil和设备之间
我们调用高度

00:24:09.583 --> 00:24:12.653
这个高度角度作为
altitudeAngle暴露

00:24:13.053 --> 00:24:14.421
是一个CGFloat

00:24:15.422 --> 00:24:20.994
它报告一个角度的弧度
在大概10度到90度之间的范围

00:24:25.098 --> 00:24:27.568
第二个部分是方向

00:24:27.634 --> 00:24:32.039
方向是针对设备平面测量的

00:24:32.673 --> 00:24:39.146
测量正的x方向
和Pencil来自的方向之间

00:24:40.981 --> 00:24:42.683
这叫做方位角

00:24:44.251 --> 00:24:47.921
方位角和倾斜一起构成Pencil
的完整位置

00:24:47.988 --> 00:24:51.925
你用它来绘画时可以驱动你的UI或者
数据点

00:24:52.726 --> 00:24:56.163
所以方位角依赖你的设备方向

00:24:56.230 --> 00:25:00.133
你需要在视图中调用一个方法叫
azimuthAngle

00:25:00.501 --> 00:25:03.904
大部分时候你可能想用一个矢量

00:25:04.137 --> 00:25:07.341
所以我们在视图中向你暴露方位角
单位矢量

00:25:07.407 --> 00:25:10.944
这个矢量会指向Pencil
来自的方向

00:25:11.278 --> 00:25:12.579
它的大小是1

00:25:15.682 --> 00:25:16.917
下一个 力量

00:25:17.484 --> 00:25:22.322
Pencil力量和
3D Touch力量的行为有些不同

00:25:22.956 --> 00:25:27.327
力量是沿着Pencil的轴测量的

00:25:27.828 --> 00:25:30.364
3D Touch的力量
是在屏幕上测量的

00:25:30.430 --> 00:25:32.566
和设备平面垂直

00:25:33.133 --> 00:25:37.237
这造成一些不同
我催促你们试一试

00:25:37.404 --> 00:25:43.076
如果你们想要得到实际力量
所有你的绘画工具的垂直力量

00:25:43.143 --> 00:25:45.245
因为它们真的感觉不同

00:25:45.712 --> 00:25:48.415
幸运的是计算这个分量很容易

00:25:49.216 --> 00:25:50.651
这是这么做的代码

00:25:51.451 --> 00:25:54.922
你可以获得垂直力量
通过力量除以

00:25:54.988 --> 00:25:57.191
高度角度的正弦

00:25:57.257 --> 00:25:59.259
要确保你保持在同样的范围内

00:25:59.326 --> 00:26:02.362
你应该取它和最大可能力量的
最小值

00:26:04.531 --> 00:26:08.836
最后一个关于
Apple Pencil力量的消息

00:26:08.902 --> 00:26:10.637
它是在Pencil内测量的

00:26:11.772 --> 00:26:14.274
然后无线传输给iPad

00:26:15.008 --> 00:26:17.911
这是通过无线传输的所有属性

00:26:17.978 --> 00:26:22.950
这表明需要花一点时间
而且数据有可能丢失

00:26:23.483 --> 00:26:27.321
所以为了不让你等待
对无线传输的力量

00:26:27.387 --> 00:26:30.457
我们决定首先给你估计的属性

00:26:31.225 --> 00:26:35.662
并稍后更新它们
这样你能有最好的体验

00:26:37.497 --> 00:26:40.968
为此我们在UITouch上暴露了
估计属性

00:26:41.401 --> 00:26:43.704
它的类型是
UITouchProperties

00:26:44.438 --> 00:26:46.807
所以估计属性

00:26:49.643 --> 00:26:51.311
可以有一个力量值

00:26:51.378 --> 00:26:55.582
对你得到的第一个
Apple Pencil事件总为真

00:26:57.851 --> 00:27:03.724
但是方位角和高度也可以被标记
为估计的

00:27:04.124 --> 00:27:06.193
这发生在你从边上进入

00:27:06.260 --> 00:27:11.498
我们不是百分之百确定值是什么
或者你在离你手指很近的地方绘画

00:27:11.565 --> 00:27:15.435
因为我们的传感器不能非常精确
地侦测它们

00:27:15.736 --> 00:27:18.939
我们告诉你它们是估计的
这样你可以做一些事

00:27:19.006 --> 00:27:21.275
比如当从边上进入时

00:27:21.341 --> 00:27:24.378
你可以在得到第一个确定的值
后回头填充它们

00:27:24.444 --> 00:27:27.147
在我给你的例子中

00:27:27.214 --> 00:27:31.552
我那么做来阐明那点

00:27:32.286 --> 00:27:37.057
还有位置
只对预测触摸是估计属性

00:27:37.124 --> 00:27:40.894
它给你一个简单的方法区分预测触摸
和普通的触摸

00:27:43.630 --> 00:27:47.634
关于更新
我们也有估计属性

00:27:47.701 --> 00:27:49.236
期待更新

00:27:50.137 --> 00:27:53.874
它的类型也是UITouchProperties
现在只有力量

00:27:53.941 --> 00:27:56.777
也许以后会有方位角和高度

00:27:56.844 --> 00:28:00.647
但是现在只有力量值
如果方位角和高度被设置

00:28:01.048 --> 00:28:03.150
我们会在未来向你发送更新

00:28:03.851 --> 00:28:08.789
我们还会在叫做触摸估计属性更新
的新响应器中这么做

00:28:09.356 --> 00:28:10.757
我们还会在事后这么做

00:28:10.824 --> 00:28:13.460
所以我们会在触摸开始时发送
触摸给你

00:28:13.527 --> 00:28:15.495
并在稍后发送更新

00:28:16.897 --> 00:28:18.298
让我们看看这些

00:28:18.966 --> 00:28:20.133
所以你要怎么做？

00:28:20.200 --> 00:28:21.969
当触摸开始或移动时

00:28:22.035 --> 00:28:25.973
你在触摸上检查estimatedProperties-
ExpectedUpdates

00:28:26.240 --> 00:28:27.941
如果它不为空

00:28:29.209 --> 00:28:33.347
你在UITouch使用
estimationUpdateIndex

00:28:33.413 --> 00:28:36.216
它是一个索引号 只针对触摸被设置

00:28:36.283 --> 00:28:39.820
期待一个更新或表示一个更新

00:28:40.220 --> 00:28:43.423
并用它储存你想更新的东西

00:28:43.490 --> 00:28:47.628
你当前的触摸取样在一个字典里
你可以晚点查询它

00:28:48.695 --> 00:28:50.597
在touchesEstimated-
PropertiesUpdated中

00:28:50.664 --> 00:28:52.999
然后你查询你的取样

00:28:53.667 --> 00:28:55.869
使用触摸的估计更新

00:28:55.936 --> 00:29:00.174
你得到一个更新是那些期待
获得更新的值

00:29:01.475 --> 00:29:05.279
注意 一些更新会在触摸结束后
到达

00:29:06.180 --> 00:29:08.182
这是一个关于生命周期的事
你需要注意到

00:29:08.248 --> 00:29:12.553
如果你不在触摸结束后保持
数据结构

00:29:12.619 --> 00:29:15.556
你会看到估计的力量

00:29:15.622 --> 00:29:17.858
出现在你的笔画的末尾
它看起来会很怪

00:29:20.794 --> 00:29:22.396
让我们看看代码

00:29:23.730 --> 00:29:26.133
我们有touchesEstimated-
PropertiesUpdated

00:29:26.200 --> 00:29:28.602
我们遍历触摸

00:29:29.236 --> 00:29:32.105
我们查询估计索引因为我们在
这个方法中

00:29:32.172 --> 00:29:34.241
我们可以隐性地打开它

00:29:34.875 --> 00:29:37.811
我们找到我们的在取样索引上的
取样

00:29:37.878 --> 00:29:40.047
我们更新取样
像我告诉过你的

00:29:40.113 --> 00:29:42.883
我们只在那个方法中更新数值

00:29:42.950 --> 00:29:45.018
我们在之前期待更新

00:29:46.954 --> 00:29:50.824
然后我们更新我们的笔画
为了以防未来

00:29:50.891 --> 00:29:53.794
我们还检查这个触摸是否还期待
更新

00:29:53.861 --> 00:29:56.697
只有它不的时候我们把它移出集合

00:29:57.197 --> 00:29:59.266
让我们在活动中看看这

00:30:05.472 --> 00:30:07.241
我试着用方位角角度

00:30:07.708 --> 00:30:10.310
来做一个书法Pencil模拟

00:30:11.979 --> 00:30:14.848
现在我们有所有我们想要的数据

00:30:14.915 --> 00:30:17.784
让我们看看它
没有调试模式

00:30:21.922 --> 00:30:23.156
它看起来难道不好？

00:30:23.590 --> 00:30:27.728
我连接所有从硬件得到的点

00:30:27.794 --> 00:30:30.964
并没有做插值或幻想的事

00:30:31.031 --> 00:30:32.799
像是你的绘制引擎会做的

00:30:37.771 --> 00:30:41.375
有了它 让我们为最终应用做一些
画龙点睛的事

00:30:41.708 --> 00:30:45.512
目前为止我们只是绘制整个屏幕

00:30:45.579 --> 00:30:48.482
我们不想被这么限制

00:30:48.549 --> 00:30:52.052
让我们支持任意画布尺寸

00:30:52.119 --> 00:30:56.290
为此 我们在一个容器视图中包括
我们的笔画视图

00:30:56.356 --> 00:30:58.625
和一点阴影

00:30:58.692 --> 00:31:01.862
把它放到你的滚动视图中
我们完成了 对吗

00:31:03.063 --> 00:31:04.031
还没有

00:31:04.464 --> 00:31:09.736
我们需要考虑如何处理手势

00:31:09.803 --> 00:31:12.072
因为滚动视图
UIPanGestureRecognizer

00:31:12.139 --> 00:31:14.942
和我们的
StrokeGestureRecognizer冲突

00:31:15.409 --> 00:31:18.412
如果我们不做改变
我们会永远画笔画

00:31:18.478 --> 00:31:19.913
我们永远不能滚动

00:31:19.980 --> 00:31:21.215
这不是我们想要的

00:31:21.715 --> 00:31:25.385
一个方法是禁止
用Apple Pencil滚动

00:31:25.552 --> 00:31:28.121
这对注释应用之类的会有用

00:31:28.188 --> 00:31:31.525
你总是想只用Pencil进行注释

00:31:31.592 --> 00:31:33.627
特别地禁用那

00:31:33.694 --> 00:31:36.864
你可以那么做因为我们添加了
被允许的触摸类型

00:31:36.930 --> 00:31:38.699
到UIGestureRecognizer中

00:31:38.932 --> 00:31:44.404
UITouch类型是一个触摸类型
的NSNumber数组

00:31:44.471 --> 00:31:46.673
它默认是所有触摸类型

00:31:47.641 --> 00:31:49.276
我们在这要做的是

00:31:49.343 --> 00:31:53.647
在这个例子中我们从滚动视图中
得到panGestureRecognizer

00:31:54.581 --> 00:31:56.783
我们会设置允许的触摸类型

00:31:56.850 --> 00:32:00.654
只允许直接触摸
所以它只对手指反应

00:32:01.655 --> 00:32:05.359
我们会改变笔画识别器只允许尖笔

00:32:06.360 --> 00:32:08.428
这显然不是全部

00:32:08.495 --> 00:32:10.731
在代码例子中你可以看到一个实现

00:32:10.797 --> 00:32:13.300
但是根据使用动态切换

00:32:13.367 --> 00:32:15.068
更复杂一点

00:32:15.135 --> 00:32:19.606
但是它说明一点是你可以限制你的
触摸处理

00:32:19.673 --> 00:32:22.543
只针对Pencil或普通触摸

00:32:26.613 --> 00:32:28.315
最后的一点注意事项

00:32:29.783 --> 00:32:32.019
UIGestureRecognizer
有一个新属性

00:32:32.085 --> 00:32:34.755
叫做
requiresExclusiveTouchType

00:32:35.255 --> 00:32:41.094
虽然我们的手势识别器默认针对
所有触摸类型

00:32:42.496 --> 00:32:47.167
如果它们看到一个触摸并开始识别
它们会坚持那个触摸类型

00:32:47.701 --> 00:32:51.738
这样你不会意外捏Pencil和手指

00:32:51.805 --> 00:32:55.876
这是你通常想
UIGestureRecognizer做的

00:32:55.943 --> 00:33:00.848
如果你不希望这样 你设置
requiresExclusiveTouchType为假

00:33:01.248 --> 00:33:04.718
这样你可以在
手指和Pencil间识别

00:33:05.385 --> 00:33:09.556
来总结一下 我展示了所有
UITouch新属性

00:33:10.657 --> 00:33:12.926
这样你可以理解
Apple Pencil

00:33:13.594 --> 00:33:16.463
我展示了如何用合并和预测触摸

00:33:16.530 --> 00:33:22.503
来获得最丰富的绘画数据
并有最少的延迟

00:33:23.670 --> 00:33:26.406
我告诉你们属性估计
我们为什么这么做

00:33:26.473 --> 00:33:31.745
你如何实际更新数据
得到Pencil提供的完整丰富数据

00:33:33.013 --> 00:33:39.686
我展示了如何调整手势来只
对Pencil或手指反应

00:33:42.289 --> 00:33:45.192
这是一个已经存在的示例应用的
截图

00:33:45.259 --> 00:33:48.829
默认使用漂亮的书法钢笔

00:33:48.896 --> 00:33:50.864
对你来说更有趣

00:33:50.931 --> 00:33:54.601
它还有调试模式
你看到由它们组成的视频

00:33:54.668 --> 00:33:57.504
你可以看到你的合并触摸的行为

00:33:57.571 --> 00:34:03.110
它们在边界是怎么被估计的
还看到倾斜和方位角

00:34:03.877 --> 00:34:08.148
玩一玩它来看看你的所有触摸
处理怎么工作

00:34:09.882 --> 00:34:13.187
这个演讲的完整信息可以在这个
URL获得

00:34:15.956 --> 00:34:19.326
昨天我们有Apple TV
控制游戏输入

00:34:19.393 --> 00:34:21.395
Siri Remote处理

00:34:21.628 --> 00:34:25.933
“窥视3D Touch”会向你展示
更高层的互动

00:34:25.998 --> 00:34:31.170
有了3D Touch中的力量来提供
Peek和Pop体验

00:34:31.237 --> 00:34:35.542
要知道更多触摸到显示的延迟

00:34:36.009 --> 00:34:40.080
你应该看看去年的iOS上的
高级触摸输入

00:34:40.514 --> 00:34:42.683
就是这些了

00:34:42.748 --> 00:34:43.650
非常感谢