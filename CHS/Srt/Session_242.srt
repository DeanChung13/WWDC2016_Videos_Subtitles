00:00:19.353 --> 00:00:23.357
Core Data的新特性

00:00:23.423 --> 00:00:24.892
大家好

00:00:30.964 --> 00:00:33.367
我是Melissa
Core Data工程师

00:00:33.767 --> 00:00:35.903
不夸张地说这是第一年
上台前没有人跟我说

00:00:35.969 --> 00:00:37.971
祝你好运

00:00:38.038 --> 00:00:41.575
因为我实际一个月前腿折了
这是我第一天脱离石膏绷带

00:00:41.975 --> 00:00:44.311
所以如果我一瘸一拐
你们知道是怎么回事

00:00:47.915 --> 00:00:49.917
在Core Data团队工作
最好的是

00:00:49.983 --> 00:00:52.286
实际上每年能站在这个舞台上

00:00:52.352 --> 00:00:55.289
告诉大家我们都做了
哪些新鲜有趣的事情

00:00:55.355 --> 00:00:58.292
不可思议 我们今年做了
很多 而且都非常有用

00:00:58.358 --> 00:00:59.960
我们希望大家喜欢这些新内容

00:01:01.195 --> 00:01:03.630
好 我要介绍一项新功能
查询生成

00:01:03.997 --> 00:01:06.099
Core Data并发领域的
一些变化

00:01:06.633 --> 00:01:08.502
我要介绍我们
在Core Data堆栈配置领域

00:01:08.569 --> 00:01:10.704
的一些新进展

00:01:10.771 --> 00:01:12.206
及我们新添加的一些API

00:01:12.806 --> 00:01:15.542
我们也会简单介绍下
为了更灵巧利落地

00:01:15.609 --> 00:01:17.744
与Swift集成
我们都做了哪些事情

00:01:18.011 --> 00:01:21.782
还有我们在Xcode集成
方面的一些改进

00:01:22.683 --> 00:01:26.420
内容不少 现在第一项 查询生成

00:01:27.554 --> 00:01:29.423
查询生成是我们添加的一项新功能

00:01:29.489 --> 00:01:32.059
不过在开始介绍查询生成前

00:01:32.125 --> 00:01:33.727
我需要简单介绍下fault

00:01:34.394 --> 00:01:37.264
可能有人知道
Core Data常使用fault

00:01:38.265 --> 00:01:41.602
管理对象可能是fault
它们之间的关系可能是fault

00:01:41.668 --> 00:01:43.470
如果你在使用批量提取

00:01:43.537 --> 00:01:45.005
那你执行抓取请求获得的阵列

00:01:45.072 --> 00:01:47.708
从NSManagedObjectContext

00:01:47.774 --> 00:01:49.510
也会是
一种非常特殊的fault

00:01:49.910 --> 00:01:52.746
话虽这么说 什么是fault？

00:01:53.013 --> 00:01:57.351
现在 在屏幕上
有一张对象图

00:01:57.417 --> 00:01:59.486
其中有国家 美国

00:01:59.920 --> 00:02:03.457
州 加利福尼亚 若干的郡
圣克拉拉和旧金山

00:02:03.790 --> 00:02:07.861
以及圣克拉拉的若干
城市 圣何塞和库比蒂诺

00:02:08.662 --> 00:02:11.765
这很像是旅游指南
指南书籍的一部分

00:02:12.099 --> 00:02:15.502
你可以翻开 浏览
从而在你计划游玩的

00:02:15.569 --> 00:02:18.505
城市中找到
你感兴趣的地方

00:02:19.606 --> 00:02:22.476
不过 仅基于我们
对美国的了解

00:02:22.543 --> 00:02:23.911
这不是完整的对象图

00:02:23.977 --> 00:02:26.780
实际上只是对象图的一部分
是子图

00:02:26.847 --> 00:02:29.283
因为我们知道美国有其他州

00:02:29.349 --> 00:02:31.618
这些州有其他郡

00:02:31.685 --> 00:02:34.054
这些郡有其他城市

00:02:34.454 --> 00:02:35.756
你也知道 除此之外

00:02:35.822 --> 00:02:38.792
我们知道美国只是
众多国家之一

00:02:40.627 --> 00:02:42.996
即使是在指南书籍中
我一次想看的

00:02:43.063 --> 00:02:44.464
也仅是一个数据集

00:02:44.531 --> 00:02:46.166
如果我计划到圣何塞旅行

00:02:46.233 --> 00:02:49.703
我不会关心俄勒冈或华盛顿
或其它类似的地方

00:02:49.770 --> 00:02:51.505
我甚至不会关心旧金山

00:02:52.072 --> 00:02:55.676
我需要能够锁定这些对象
到达这些目的地

00:02:55.742 --> 00:02:56.910
如果我感兴趣

00:02:56.977 --> 00:02:59.613
我可以随后改主意
改变想要浏览的内容

00:02:59.680 --> 00:03:01.915
但就目前短期而言
当我在计划

00:03:01.982 --> 00:03:05.452
到圣克拉拉的旅行时
我不在意其它地方

00:03:06.386 --> 00:03:09.890
这种不在意
在内存中表示为

00:03:09.957 --> 00:03:12.860
fault
它是一种对象

00:03:12.926 --> 00:03:16.530
了解在随后的某个
时间点如何开始检索数据

00:03:16.597 --> 00:03:18.098
如果我确定我想使用它

00:03:18.165 --> 00:03:20.267
比如 我发现我朋友
要结婚了

00:03:20.334 --> 00:03:22.402
婚礼在西雅图 我想去

00:03:22.469 --> 00:03:23.837
计划到西雅图的旅行

00:03:24.271 --> 00:03:26.440
此时 我会再次浏览美国

00:03:26.507 --> 00:03:28.308
下一层
我想浏览华盛顿州

00:03:28.375 --> 00:03:31.445
Core Data会自动检索

00:03:31.512 --> 00:03:35.182
关于华盛顿的信息
即使当我首次加载子图时

00:03:35.249 --> 00:03:37.317
华盛顿信息不在内存中

00:03:37.751 --> 00:03:41.021
你知道 我可以接着向下浏览
等等...

00:03:41.655 --> 00:03:44.992
这就是fault
它是未来 或承诺

00:03:45.058 --> 00:03:46.193
或延迟加载

00:03:46.260 --> 00:03:49.196
这些不同的名称
指的都是同样的东西

00:03:49.263 --> 00:03:51.498
Core Data可进行这操作
帮你尽量减少

00:03:51.565 --> 00:03:53.333
在任意给定时间点
内存中的数据量

00:03:54.635 --> 00:03:55.569
我们为什么使用fault？

00:03:55.636 --> 00:03:58.805
答案是 性能 性能 性能
还是性能

00:04:00.007 --> 00:04:01.942
性能最好的应用

00:04:02.009 --> 00:04:03.944
是那些不做任何额外功的应用

00:04:04.711 --> 00:04:07.948
你不会在iobus上加载
任何不需要的对象

00:04:08.015 --> 00:04:11.051
你不会在不需要的对象上
花费任何时间

00:04:11.552 --> 00:04:14.955
你也不想
在用户不注意的时候

00:04:15.022 --> 00:04:16.656
这些对象闲置在那里

00:04:17.057 --> 00:04:18.926
推高你的内存占用

00:04:19.159 --> 00:04:21.528
不过fault有一个小问题

00:04:22.262 --> 00:04:23.564
基本上是这样的

00:04:23.864 --> 00:04:25.999
这里我们再看对象图

00:04:26.500 --> 00:04:28.902
在这个案例中
我们有很多fault

00:04:29.369 --> 00:04:31.872
我顺着树形结构向下浏览
来到圣克拉拉

00:04:31.939 --> 00:04:34.041
我想启动
库比蒂诺fault

00:04:34.508 --> 00:04:35.609
但同时

00:04:36.076 --> 00:04:38.612
一个外部过程已经
开始从网站导入数据

00:04:38.679 --> 00:04:40.881
而且不知为何
库比蒂诺被删除了

00:04:41.315 --> 00:04:42.916
发生了什么？

00:04:42.983 --> 00:04:44.518
我有一个fault
它应开始

00:04:44.585 --> 00:04:47.254
检索关于
库比蒂诺的信息

00:04:47.321 --> 00:04:49.223
但那里却没有任何信息了

00:04:50.390 --> 00:04:53.126
我说过 我多次介绍
不要加载不需要的数据

00:04:53.193 --> 00:04:55.195
但在这个案例中
你会问自己

00:04:55.262 --> 00:04:58.432
我是不是实际上需要
那个数据呢？

00:04:59.499 --> 00:05:00.334
哎哟

00:05:02.736 --> 00:05:03.937
现在Core Data中

00:05:04.071 --> 00:05:06.840
通过NSManagedObjectContext
上的shouldDeleteInaccessibleFaults

00:05:06.907 --> 00:05:08.642
属性 你可以应对这种情况

00:05:09.142 --> 00:05:11.478
如果你设置了这个属性
然后当上下文注意到

00:05:11.545 --> 00:05:14.147
你正在试图启动
已删除对象的fault

00:05:14.214 --> 00:05:16.049
上下文会将fault
标记为已删除

00:05:16.116 --> 00:05:18.819
并将fault的所有属性
标记为零

00:05:19.186 --> 00:05:22.189
大多情况下 这就是你需要的
但有时候这也会不便利

00:05:22.256 --> 00:05:25.726
因为你的UI不知道如何处理
为零的标识符

00:05:26.293 --> 00:05:28.562
另一种方法是
预提取所有内容

00:05:28.629 --> 00:05:31.431
使用关系小键盘进行预提取
从而加载你认为你用户

00:05:31.498 --> 00:05:33.800
可能需要的所有对象

00:05:34.034 --> 00:05:35.736
这样 你的任务就升级了

00:05:35.802 --> 00:05:38.071
你需要更努力了解
确切地

00:05:38.505 --> 00:05:40.107
预测用户未来可能的需要

00:05:40.340 --> 00:05:42.676
这会很棘手 我们都知道
用户是不可预测的

00:05:43.277 --> 00:05:44.945
另一种方法
存在第三种方法

00:05:45.012 --> 00:05:47.181
始终都存在第三种方法
就是写很多代码

00:05:47.381 --> 00:05:49.349
首先在管理对象上下文中

00:05:49.416 --> 00:05:51.919
使用带ID的既有对象
确保在尝试fault前

00:05:51.985 --> 00:05:53.787
对象位于数据库中

00:05:54.488 --> 00:05:55.956
编写很多try catch

00:05:56.156 --> 00:05:58.859
围绕着所有fault启动的
异常处理程序

00:05:58.926 --> 00:06:01.028
实话说 这个代码写起来
可不怎么有意思

00:06:01.094 --> 00:06:03.463
你实际上会更愿意
写一些用户会使用的

00:06:03.530 --> 00:06:05.766
有趣功能
因为那才是用户

00:06:05.832 --> 00:06:08.001
使用你应用的原因
即你的应用提供灵巧功能

00:06:08.635 --> 00:06:09.970
不过让我们后退一步

00:06:10.037 --> 00:06:13.006
稍稍想一下你的用户
与你应用的交互

00:06:14.308 --> 00:06:16.510
用户视图和UI
通常不关心

00:06:16.577 --> 00:06:20.180
是否看到绝对的最近
最新和最快的数据

00:06:20.247 --> 00:06:21.448
我们怎么知道这一点？

00:06:22.449 --> 00:06:24.284
让我们先想想气泵

00:06:24.852 --> 00:06:28.322
大多数人对气泵很熟悉
你有时会给汽车加油

00:06:28.822 --> 00:06:30.858
气泵的显示屏会告诉你

00:06:30.924 --> 00:06:33.627
你实际已经给汽车加了
多少加仑或升的油

00:06:34.127 --> 00:06:36.763
显示数字有千分位

00:06:37.197 --> 00:06:40.634
我想问下大家
在给车加油时

00:06:41.301 --> 00:06:43.537
谁能实时读到
千分位请举手

00:06:44.071 --> 00:06:46.240
正如我所料
没有人能做到

00:06:46.306 --> 00:06:48.775
人类大脑喜欢数字

00:06:48.842 --> 00:06:50.577
以一定间隔整齐排列
这样容易理解

00:06:51.111 --> 00:06:54.648
所以用户实际不需要最近
最新的数据 他们只需要数据...

00:06:55.482 --> 00:06:56.884
合理快速地更新

00:06:57.918 --> 00:07:00.320
保存数据的用户
对此也不在乎

00:07:00.420 --> 00:07:02.189
正因如此
Core Data才有合并策略

00:07:02.256 --> 00:07:04.658
这些策略规定进行一连串
编辑并将这些编辑保存

00:07:04.725 --> 00:07:06.493
并与数据库中的内容混合

00:07:06.560 --> 00:07:07.928
以及产生预期的效果

00:07:08.529 --> 00:07:11.665
你可以选择你需要的合并策略
因为你比我们更了解你的用户

00:07:13.100 --> 00:07:16.069
那么 如果我们能够汲取这个
洞见并进一步延伸会怎样？

00:07:16.737 --> 00:07:19.306
如果我们有方法
使你通过UI看到数据库中

00:07:19.373 --> 00:07:21.508
数据的稳定视图
会怎样？

00:07:22.543 --> 00:07:24.344
如果我们有方法
应对变化

00:07:24.411 --> 00:07:26.146
更确定地更新变化
会怎样？

00:07:27.347 --> 00:07:30.284
如果我们能做到所有这些
你不会再看到这个 会怎样？

00:07:36.590 --> 00:07:38.559
现在 我可以介绍
查询生成了

00:07:39.660 --> 00:07:40.928
查询生成是一种方法

00:07:40.994 --> 00:07:43.397
能使你的管理对象上下文

00:07:43.463 --> 00:07:46.366
基本上 执行读取数据库中
数据的操作

00:07:46.834 --> 00:07:48.802
所有向管理对象
上下文的读取操作

00:07:48.869 --> 00:07:52.606
都将看到同样的数据视图
直到你选择向前进

00:07:52.840 --> 00:07:55.576
你永远不会再看到
无法完成fault的消息

00:07:56.043 --> 00:07:57.978
而且重要的是
我们能高效完成这一操作

00:07:58.345 --> 00:08:00.080
这永远都是棘手的部分

00:08:01.348 --> 00:08:02.182
这些是怎么实现的？

00:08:02.249 --> 00:08:06.153
这里有一个数据库 里面有
一个对象id是1名字是fred

00:08:06.220 --> 00:08:07.988
因为这些是幻灯片

00:08:08.488 --> 00:08:09.356
我将进行删减

00:08:09.423 --> 00:08:11.491
因为我需要完成此构建
需要的所有资产

00:08:12.826 --> 00:08:15.262
在传统数据库中
这就是你得到的

00:08:15.329 --> 00:08:17.698
你有一个文件 该文件有
对所有数据的单一视图

00:08:18.131 --> 00:08:19.800
但是使用查询生成

00:08:20.367 --> 00:08:23.570
那就变成了你数据库中的
第一代数据

00:08:25.038 --> 00:08:27.708
随着过程的进行
这可能会成为你的应用

00:08:27.774 --> 00:08:30.978
它可以是导入程序
可以是watch上的扩展

00:08:31.044 --> 00:08:33.013
某物对数据库进行修改

00:08:34.881 --> 00:08:36.383
新一代创建了

00:08:37.650 --> 00:08:40.754
而且更多的数据被创建
新的对象

00:08:41.054 --> 00:08:44.525
此时 用户启动你的应用

00:08:47.194 --> 00:08:49.696
创建管理对象上下文
你加载数据

00:08:50.130 --> 00:08:51.598
该上下文现在知道

00:08:51.665 --> 00:08:54.535
它是从数据库中的哪一代
加载数据

00:08:54.968 --> 00:08:59.306
所以随着其他过程或上下文
等的继续进行

00:08:59.373 --> 00:09:01.742
并进一步修改数据库

00:09:03.143 --> 00:09:06.847
更多代的数据被创建
该上下文仍然知道它所属的代

00:09:06.914 --> 00:09:11.685
第二个上下文出现
加载一些数据 进行一些编辑

00:09:12.719 --> 00:09:16.223
进行保存 保存之后
便创建了新一代

00:09:16.290 --> 00:09:19.493
并追踪它现在
代表的一代

00:09:19.560 --> 00:09:21.361
在本例中
是数据库中的第6代

00:09:21.828 --> 00:09:25.299
此时 如果我们
在上下文1中启动fault

00:09:25.365 --> 00:09:27.167
即使fault对应的对象

00:09:27.234 --> 00:09:29.570
可能在第6代中
已经被删除

00:09:29.636 --> 00:09:32.673
上下文中仍可看到该对象
因为它仍然在数据库中

00:09:32.739 --> 00:09:34.341
就在标签第3代下

00:09:35.576 --> 00:09:39.313
此时 用户可以
在上下文1中略微编辑

00:09:39.379 --> 00:09:43.383
删除一些对象 更改一些对象
插入新的对象

00:09:43.684 --> 00:09:47.054
当保存上下文时
Core Data将使用合并策略

00:09:47.120 --> 00:09:50.190
将所有这些变更
与数据库中的内容合并

00:09:50.991 --> 00:09:53.260
并创建新的第7代

00:09:55.462 --> 00:09:57.197
以与上下文1
相同的

00:10:00.367 --> 00:10:03.604
上下文1
在固定到第3代时

00:10:03.670 --> 00:10:05.672
能够看到第3代
同样地

00:10:06.240 --> 00:10:09.810
上下文2能够对其对象
作出任意操作

00:10:09.877 --> 00:10:12.212
将对象变成fault
重新启动这些fault

00:10:12.279 --> 00:10:14.448
且上下文2将仍能看到

00:10:14.515 --> 00:10:16.550
数据库第6代中的数据

00:10:17.618 --> 00:10:20.387
所以 基本上
它是管理对象上下文级别的

00:10:20.454 --> 00:10:22.155
完全读取事务

00:10:22.923 --> 00:10:25.993
我们长篇介绍了
为什么上下文

00:10:26.426 --> 00:10:27.928
本质上是对的事务

00:10:27.995 --> 00:10:30.030
现在我们也将它们变成读取事务

00:10:30.097 --> 00:10:34.001
使你能够在上下文的
级别上立即隔离你的工作

00:10:34.067 --> 00:10:38.205
并最小化预防性预提取等
这意味着 所有人都获益

00:10:40.274 --> 00:10:41.108
基本要点

00:10:41.175 --> 00:10:43.844
单个上下文
可以选择想要的行为

00:10:44.311 --> 00:10:46.914
它可以决定它想要

00:10:46.980 --> 00:10:51.251
你在iOS 9和macOS 11上
适应的当前行为

00:10:52.553 --> 00:10:55.689
我们称为已取消固定 注意看
加载数据时树形结构顶端

00:10:55.756 --> 00:10:57.624
你也可以指定
上下文应固定到

00:10:57.691 --> 00:10:59.893
数据库中任意当前的世代

00:10:59.960 --> 00:11:02.362
当数据首次加载到
该上下文时

00:11:02.429 --> 00:11:05.832
或者 你可以指定
你想要它固定到特定世代

00:11:05.899 --> 00:11:08.402
如果另一个上下文
固定到该世代

00:11:09.570 --> 00:11:12.639
嵌套上下文
将继承父级的世代

00:11:12.940 --> 00:11:15.676
它们悄悄取消固定
但是能够看到

00:11:15.742 --> 00:11:18.145
通过父级世代查看的数据

00:11:18.212 --> 00:11:21.949
以及父级闲置未保存的
任何挂起的变更

00:11:24.818 --> 00:11:27.187
更新一定程度上很重要
我们都认可这一点

00:11:27.254 --> 00:11:28.488
用户不想看到更新

00:11:28.555 --> 00:11:30.991
最终 他们不希望看到10年前的数据

00:11:32.526 --> 00:11:35.262
世代的更新
发生在你通过设置

00:11:35.329 --> 00:11:37.664
新世代标记
明确告诉上下文更新时

00:11:37.731 --> 00:11:38.999
它们在保存时更新

00:11:39.466 --> 00:11:42.703
它们在你调用mergeChanges时更新
这时它们将更新至树的顶端

00:11:42.769 --> 00:11:44.371
既然你已经告诉上下文

00:11:44.438 --> 00:11:47.541
你知道它应该在查看
数据库中的一组新变化

00:11:47.841 --> 00:11:50.711
它的更新是调用重置引起的

00:11:53.714 --> 00:11:55.382
需要注意的是

00:11:55.983 --> 00:11:57.618
当你更新世代时

00:11:57.684 --> 00:12:00.420
已注册的对象不会被刷新
你可能不想要那样

00:12:00.654 --> 00:12:02.623
我们可以很轻松地
让你这么做

00:12:02.689 --> 00:12:05.759
如果我们选择代你做
再让你取消难度会加大很多

00:12:06.727 --> 00:12:08.095
如果你想要刷新数据

00:12:08.161 --> 00:12:10.831
你必须调用fetch或
refreshAllObjects

00:12:10.898 --> 00:12:14.334
但是当数据实际得到更新时
这样会使你获得控制

00:12:16.069 --> 00:12:19.173
如果你想使用查询生成
你必须使用SQL store

00:12:19.239 --> 00:12:21.175
且SQL store应在
wall模式下

00:12:21.241 --> 00:12:22.843
尽管如果你
尝试使用查询生成

00:12:22.910 --> 00:12:25.846
你并未满足上述两项要求
系统会正常退出

00:12:25.913 --> 00:12:27.614
只是恢复到
已取消固定的行为

00:12:29.216 --> 00:12:30.184
我们是如何做的？

00:12:30.250 --> 00:12:33.420
好 现在有一种opaque
标记 你可以使用它

00:12:33.487 --> 00:12:34.755
跟踪查询生成

00:12:34.821 --> 00:12:39.059
这将告诉上下文 什么时候
从什么存储加载了数据

00:12:40.594 --> 00:12:43.463
查询生成标记
有一个方法current

00:12:43.530 --> 00:12:45.399
你可以使用它检索标记

00:12:45.465 --> 00:12:47.801
以表明在它加载数据时
上下文应固定

00:12:50.070 --> 00:12:52.439
ManagedObjectContext
我们有若干新方法

00:12:52.506 --> 00:12:54.274
有一个属性
QueryGenerationToken

00:12:54.341 --> 00:12:58.078
它将会告诉你 上下文
正在使用哪个查询生成

00:12:58.478 --> 00:13:00.547
如果上下文取消固定
则该属性为零

00:13:01.048 --> 00:13:03.283
你可以由标记设置查询生成

00:13:03.350 --> 00:13:07.020
或者是来自类属性的
current标记

00:13:07.354 --> 00:13:09.122
或是在另一个管理对象上下文调用

00:13:09.189 --> 00:13:10.958
queryGenerationToken的结果

00:13:12.993 --> 00:13:16.496
一个世代创建后
该世代不会包含添加到

00:13:16.563 --> 00:13:18.232
存储协调器的存储

00:13:18.498 --> 00:13:21.134
如果你将数据加载
到管理对象上下文

00:13:21.201 --> 00:13:23.403
将存储添加到
协调器然后进行提取

00:13:23.470 --> 00:13:25.539
你不会从该新存储
看到结果

00:13:26.139 --> 00:13:28.575
但是它不会阻止你
从协调器移除存储

00:13:28.642 --> 00:13:29.810
尽管当你已移除
从中加载数据的所有存储时

00:13:29.877 --> 00:13:33.814
如果你尝试将数据加载到上下文

00:13:33.881 --> 00:13:36.750
你会发现错误

00:13:38.886 --> 00:13:41.288
现在 我将谈论并发
因为

00:13:41.722 --> 00:13:43.557
我们总是谈论并发

00:13:45.425 --> 00:13:47.694
这是Core Data
当前的情况

00:13:47.761 --> 00:13:49.830
它的管理对象
上下文是执行者

00:13:51.865 --> 00:13:54.568
你使用perform以及
performAndWait与它交互

00:13:54.635 --> 00:13:58.138
做调度块 以便
执行管理对象上下文队列

00:13:58.472 --> 00:14:00.574
还有第三个模型
或者说另一个模型

00:14:00.641 --> 00:14:02.676
它使用
confinementConcurrencyType

00:14:02.743 --> 00:14:04.511
允许你直接对上下文
发出通知

00:14:04.578 --> 00:14:08.415
不过我们不推荐使用
因为在任何线程情景下

00:14:08.482 --> 00:14:10.817
它都很难操作正确

00:14:11.585 --> 00:14:14.788
永久性存储协调器
也是执行者

00:14:14.855 --> 00:14:17.624
拥有同样的API
perform和performAndWait

00:14:17.691 --> 00:14:19.793
协调器将对来自
单个管理对象上下文的

00:14:19.860 --> 00:14:22.462
请求进行序列化操作

00:14:22.529 --> 00:14:24.898
同样也对你在坐标上使用
perform和performAndWait API

00:14:24.965 --> 00:14:28.402
直接安排的任何请求
进行序列化操作

00:14:30.571 --> 00:14:32.773
现在 我想宣布一件
重要的事情

00:14:33.240 --> 00:14:36.009
我们为在ObjC中编程

00:14:36.076 --> 00:14:39.213
并使用手动保留释放的
开发者

00:14:39.279 --> 00:14:40.814
在执行、阻拦和等待
周围添加了自动释放池

00:14:41.381 --> 00:14:43.150
这意味着 你将负责

00:14:43.217 --> 00:14:46.553
延长你安排的组块内

00:14:46.620 --> 00:14:48.088
创建的任何对象的寿命

00:14:48.155 --> 00:14:50.591
如果你想要在组块外
使用这些对象

00:14:50.958 --> 00:14:52.693
要记住进行这个操作
很简单

00:14:52.759 --> 00:14:54.328
对于 比如执行提取
导致的结果

00:14:55.829 --> 00:14:57.431
有一点不是特别明显

00:14:57.497 --> 00:14:59.466
你还需对可能返回的NSErrors

00:14:59.533 --> 00:15:00.601
进行此操作

00:15:01.368 --> 00:15:03.837
这不仅影响使用
手动保留释放的开发者

00:15:03.904 --> 00:15:06.373
我们有链接时间检查
这样你就不会看到此行为

00:15:06.440 --> 00:15:10.143
直到你针对iOS X
或macOS 12进行重新编译

00:15:11.979 --> 00:15:14.948
不过让我们讨论下
当今世界中存在的并发

00:15:15.749 --> 00:15:18.986
或者说截止昨天为止
世界上存在的并发

00:15:20.187 --> 00:15:25.626
上下文1试图进行进入
永久性存储所需的操作

00:15:25.959 --> 00:15:27.628
所以它通知协调器

00:15:28.228 --> 00:15:30.797
协调器由于清理请求
锁定了

00:15:30.864 --> 00:15:32.065
而此时 上下文2

00:15:32.132 --> 00:15:35.068
可能作为你的UIContext
想要采取些行动

00:15:35.135 --> 00:15:36.837
并试图通知协调器

00:15:37.070 --> 00:15:40.607
但由于协调器被锁定
所以上下文2必须等待

00:15:40.841 --> 00:15:45.646
同时来自上下文1的请求
传递到永久性存储

00:15:45.712 --> 00:15:49.716
任何需要被评估的工作
得到评估

00:15:49.983 --> 00:15:53.887
只有当这些工作完成
并且执行线程返回时

00:15:54.888 --> 00:15:57.291
上下文2才能锁定协调器

00:15:57.357 --> 00:15:59.960
并将其工作向下分派给存储

00:16:00.027 --> 00:16:02.196
这意味着上下文2基本上

00:16:02.262 --> 00:16:04.798
对于上下文1在进行的
所有工作都会被锁定

00:16:06.266 --> 00:16:08.435
最终会恢复
但同时你的IU

00:16:08.502 --> 00:16:10.370
可能会比较慢

00:16:11.972 --> 00:16:15.709
新东西 SQL存储目前有
连接池

00:16:15.776 --> 00:16:18.679
并且能够处理多个并发请求

00:16:18.745 --> 00:16:22.549
具体地 它现在能够处理
多个读取器和单个编写器

00:16:23.116 --> 00:16:26.086
不同平台的连接池
大小各异

00:16:26.620 --> 00:16:30.824
我们已经采用了它 并将通过
几张幻灯片向你展示如何更改

00:16:31.158 --> 00:16:32.459
现在这是怎么实现的？

00:16:33.026 --> 00:16:36.263
上下文1分派到协调器

00:16:37.064 --> 00:16:39.066
且没有任何锁定

00:16:39.766 --> 00:16:44.538
上下文2 可能仍然作为你的
UIContext 也分派协调器

00:16:45.405 --> 00:16:49.776
两条消息同时都向下发送给
永久性存储

00:16:50.544 --> 00:16:52.980
永久性存储随后会进行
所有必要工作以发现

00:16:53.046 --> 00:16:55.616
需要将什么消息
发送到SQLite

00:16:55.883 --> 00:16:57.417
这些消息发送到SQLite

00:16:57.484 --> 00:16:59.620
只有在这时才进行锁定

00:16:59.686 --> 00:17:02.155
这是标准的
SQLite文件锁

00:17:03.090 --> 00:17:07.194
SQLite进行所有必要的操作
开始打开事务

00:17:07.261 --> 00:17:09.896
对了 就是一堆SQL
关闭事务

00:17:11.131 --> 00:17:14.800
在此时结束 返回

00:17:15.301 --> 00:17:18.105
所以 现在 我们确实
已经缩小了

00:17:18.172 --> 00:17:20.273
关键部分的范围

00:17:21.175 --> 00:17:22.175
为什么要在意这一点？

00:17:22.242 --> 00:17:24.678
这会使你的UI反应更灵敏

00:17:25.412 --> 00:17:27.915
比如 当后台工作
在不同的上下文进行时

00:17:27.981 --> 00:17:31.385
你可以在主UI上

00:17:31.451 --> 00:17:32.920
进行fault和提取操作

00:17:33.520 --> 00:17:35.222
这直接的附带结果是

00:17:35.289 --> 00:17:37.524
简化了应用架构

00:17:37.591 --> 00:17:41.361
一个相当标准的模式是

00:17:41.662 --> 00:17:45.332
人们会有一个导入程序上下文
其正在从网页加载数据

00:17:45.499 --> 00:17:49.536
而另外 主UIContext正在
将数据传送到主UI

00:17:50.504 --> 00:17:52.773
最终它们的数据
位于不同的堆栈上

00:17:52.840 --> 00:17:54.508
这是因为UI需要快速响应

00:17:54.575 --> 00:17:58.111
它们需要关键部分的锁定
尽可能小

00:17:59.379 --> 00:18:03.283
而以前 当你必须锁定整个堆栈
唯一做到的方法是

00:18:03.350 --> 00:18:04.885
有两个不同的堆栈

00:18:05.352 --> 00:18:07.654
这就导致了要在两者
之间倒换的问题

00:18:07.721 --> 00:18:10.090
比如 有一个管理对象
上下文完成保存的通知

00:18:10.157 --> 00:18:12.593
但它是来自完全不同的
永久性存储协调器

00:18:12.659 --> 00:18:14.194
我需要将它迁移过来

00:18:15.062 --> 00:18:18.398
现在这不再是问题
你现在可以将两个上下文

00:18:18.465 --> 00:18:22.469
都附加到同一永久性
存储协调器 它们将同时执行

00:18:22.970 --> 00:18:25.639
你仅需进行标准的合并

00:18:25.706 --> 00:18:29.076
而这其中的一大好处是
这意味着它们共享行缓存

00:18:29.142 --> 00:18:31.044
这样将大大降低你的
内存占用

00:18:31.111 --> 00:18:33.480
这将内存占用减半

00:18:33.547 --> 00:18:35.415
因为 我们现在只有
一个行缓存

00:18:41.622 --> 00:18:44.658
默认情况下它是打开的
它只针对SQL存储

00:18:46.460 --> 00:18:48.562
它只有
在永久性存储协调器上的

00:18:48.629 --> 00:18:51.098
所有协调存储是SQL存储时
才有效

00:18:51.765 --> 00:18:54.434
你可以配置连接池的大小

00:18:54.501 --> 00:18:56.970
使用NSPersistentStore
ConnectionPoolMax SizeKey

00:18:58.305 --> 00:19:01.742
你将能够确切地知道
连接池的最大容量

00:19:01.808 --> 00:19:05.379
如果你想要串行请求处理
旧有行为 你可以设置为1

00:19:06.013 --> 00:19:08.215
我们确实保留权利
你已经尝试将它设置为

00:19:08.282 --> 00:19:09.850
一百万 而这有点蠢

00:19:09.917 --> 00:19:11.885
所以我们会使用
更合理的数字

00:19:13.787 --> 00:19:16.790
它应该立即
可为你们大多数人所见

00:19:16.857 --> 00:19:19.426
你的UI可能会响应更快

00:19:20.360 --> 00:19:22.863
将此功能打开后
我们内部最大的发现是

00:19:22.930 --> 00:19:26.099
很多人说
哇 我能写出

00:19:26.800 --> 00:19:29.136
几百 几千行的代码

00:19:29.236 --> 00:19:31.572
你应该试试 因为
天啊 这太过瘾了

00:19:34.308 --> 00:19:35.175
有些人...

00:19:39.313 --> 00:19:43.717
有些人可能注意到
一些小小的时间问题

00:19:43.784 --> 00:19:47.354
若你有一个上下文
上下文1有执行、阻拦和等待

00:19:47.421 --> 00:19:49.823
上下文2也有执行
阻拦和等待

00:19:49.890 --> 00:19:53.360
最初 上下文2不会
开始执行其数据块

00:19:53.427 --> 00:19:56.697
直到上下文1的数据块返回
现在事实不是如此了

00:19:56.763 --> 00:20:00.133
所以 对于大概1%
遇到这种情况的人

00:20:00.200 --> 00:20:01.301
你的时间会发生改变

00:20:01.368 --> 00:20:05.038
你可能需要降低带宽
连接池rearchitect

00:20:05.439 --> 00:20:06.340
而其他人

00:20:07.474 --> 00:20:09.910
你们只需编写更新
更有趣更简单的代码就行了

00:20:10.944 --> 00:20:13.580
现在 我将邀请我的同事
Scott上台

00:20:13.647 --> 00:20:15.682
他会介绍很多其它内容

00:20:22.789 --> 00:20:23.757
谢谢Melissa

00:20:27.494 --> 00:20:31.098
早上好
让我们介绍下Core Data设置

00:20:32.599 --> 00:20:34.468
首先添加永久性存储

00:20:35.169 --> 00:20:36.970
要对协调器
添加永久性存储

00:20:37.037 --> 00:20:39.173
你需要四块数据

00:20:39.239 --> 00:20:41.408
而完成大多数操作
你至少需要两块

00:20:42.176 --> 00:20:44.912
今年新内容中 Core Data
引入了一种新类型

00:20:44.978 --> 00:20:48.515
叫做NSPersistentStoreDescription
可以将所有

00:20:48.582 --> 00:20:50.184
描述存储所需要的数据封装

00:20:50.250 --> 00:20:53.687
同时包含方便的API
可用于一般的选项

00:20:53.754 --> 00:20:56.256
比如存储是否应以只读
形式打开

00:20:56.323 --> 00:20:58.258
协调器应使用的超时

00:20:58.926 --> 00:21:02.529
现在默认情况下均已启用的
自动迁移和映射选项

00:21:02.930 --> 00:21:05.699
以及一个新增选项
用于异步添加存储

00:21:07.501 --> 00:21:11.104
这种新类型适用于永久性
存储协调器上的一种新方法

00:21:11.171 --> 00:21:15.242
该方法采取记录圈号
附有用于描述存储的参数

00:21:15.309 --> 00:21:18.712
以及一个可选NSError
该NSError在操作失败时非零

00:21:19.713 --> 00:21:21.248
如果你异步添加存储

00:21:21.315 --> 00:21:23.417
你可以在回调函数中
扩展条件

00:21:23.684 --> 00:21:27.454
针对的是发布通知
或推送应用UI等

00:21:27.521 --> 00:21:29.623
时间是在成功添加存储后

00:21:30.090 --> 00:21:33.760
这样 你应用的模型设置
可以在主要线程外发生

00:21:33.827 --> 00:21:36.029
这在启动应用时尤其有用

00:21:36.096 --> 00:21:38.031
因为迁移可能导致延迟

00:21:38.332 --> 00:21:41.134
记住 如果iOS注意到
你的应用在启动后

00:21:41.201 --> 00:21:43.604
一段时间仍不响应
则iOS将关闭应用

00:21:44.171 --> 00:21:46.507
这可能使迁移无法完成

00:21:46.573 --> 00:21:49.910
但现在如果你在异步
添加存储 这不再是问题

00:21:52.045 --> 00:21:54.515
所以 那是
永久性存储描述 不过

00:21:54.581 --> 00:21:57.050
设置Core Data堆栈
还涉及更多的东西

00:21:57.417 --> 00:21:59.987
要代表Core Data堆栈
你至少需要三个对象

00:22:00.053 --> 00:22:02.589
及将它们互相联系的
boilerplate样板

00:22:03.757 --> 00:22:06.026
今年新内容中
Core Data有另一类型

00:22:06.093 --> 00:22:07.528
可以封装这些对象

00:22:07.594 --> 00:22:10.564
及叫做NSPersistentContainer
的大多boilerplate样板

00:22:11.565 --> 00:22:12.399
它不仅...

00:22:17.538 --> 00:22:20.874
我想很多人自己
已经写过这种类型 不过...

00:22:21.808 --> 00:22:25.746
这个不仅封装建模配置
它还有名称

00:22:26.280 --> 00:22:31.251
存储描述列表 以及
从该列表中加载

00:22:31.318 --> 00:22:33.387
尚未添加到协调器的
存储描述的方法

00:22:34.121 --> 00:22:36.557
这意味着设置Core Data所需
项目boilerplate样板

00:22:36.623 --> 00:22:40.961
从一整页代码
缩减到了仅几行代码

00:22:51.872 --> 00:22:54.775
所以现在少了很多代码
让我们看看这是如何实现的

00:22:55.209 --> 00:22:57.444
容器保证其属性始终有效

00:22:57.511 --> 00:23:00.314
所以协调器和模型等的
接收方

00:23:00.380 --> 00:23:03.383
能够始终返回可安全使用的
新对象

00:23:04.084 --> 00:23:06.820
容器的初始值设定项基于
你输入初始值设定项的

00:23:06.887 --> 00:23:08.355
名称找到模型

00:23:09.189 --> 00:23:12.526
还有另外一个初始值设定项
它采取明确的模型参数

00:23:13.660 --> 00:23:17.631
默认情况下 新容器在列表中
仅有一个存储描述

00:23:17.698 --> 00:23:19.967
它是SQLite
附有默认选项

00:23:20.033 --> 00:23:23.170
以及基于容器名称的
文件名称

00:23:23.637 --> 00:23:25.439
它存储在一个目录中

00:23:25.506 --> 00:23:27.774
目录由容器上的
类方法定义

00:23:28.509 --> 00:23:30.511
而默认情况下 永久性容器

00:23:30.978 --> 00:23:34.348
将基于你使用的平台
向你返回目录

00:23:34.414 --> 00:23:37.117
所以它会在macOS上使用
应用支持目录

00:23:37.451 --> 00:23:40.487
在iOS和launchOS上使用
你的容器文档结构

00:23:40.554 --> 00:23:44.024
以及tvOS上使用你的
容器缓存目录

00:23:45.459 --> 00:23:47.828
若你想设置自己的目录
那么你可在永久性容器中

00:23:47.895 --> 00:23:50.230
划分子类并替代直接

00:23:50.297 --> 00:23:53.100
不好意思 默认的
目录URL类方法

00:23:54.401 --> 00:23:56.803
容器在设置
Core Data时真很有用

00:23:56.870 --> 00:23:59.606
不过它们也
给一般操作带来了便利

00:24:00.207 --> 00:24:02.843
容器有一个主队列
上下文属性

00:24:02.910 --> 00:24:05.712
叫做查看上下文
你可以使用它驱动你的UI

00:24:06.246 --> 00:24:09.116
还有一种工厂方法
可以提供随时可用的

00:24:09.183 --> 00:24:11.885
后台上下文
但大多时候

00:24:11.952 --> 00:24:14.154
你可能要使用容器的方法

00:24:14.221 --> 00:24:17.791
来执行叫做performBackgroundTask的
后台任务

00:24:19.626 --> 00:24:22.095
所以你无需安装
新的后台上下文 进行连接

00:24:22.162 --> 00:24:24.331
然后排列数据块
以便在后台进行操作

00:24:24.398 --> 00:24:26.200
你只需将数据块
传送到容器

00:24:27.167 --> 00:24:30.137
使用performBackgroundTask的
优势远不止获得简洁的代码

00:24:30.204 --> 00:24:33.106
使用它可以使Core Data
减少为完成你作业而

00:24:33.173 --> 00:24:36.643
创建的上下文数目
同时能够与连接池一起

00:24:36.710 --> 00:24:39.646
确保你的应用响应快速
即使是在重负载的情况下

00:24:41.782 --> 00:24:43.884
说到一般上下文工作流

00:24:44.117 --> 00:24:47.020
NSManagedObjectContext
今年有一个新属性 叫做

00:24:47.087 --> 00:24:49.189
自动合并来自父级的变更

00:24:49.723 --> 00:24:51.425
它是布尔值
当你将它设置为真

00:24:51.491 --> 00:24:54.795
上下文会自动合并
保存其父级数据的更改

00:24:55.262 --> 00:24:56.129
这可以用于...

00:25:00.534 --> 00:25:02.903
这真的很便利
它可在父级

00:25:02.970 --> 00:25:05.005
保存变化时用于子上下文

00:25:05.539 --> 00:25:09.710
它也可以在同级保存到存储时
用于顶层上下文

00:25:10.244 --> 00:25:12.179
它尤其适用于世代标记

00:25:12.246 --> 00:25:13.881
这个Melissa之前介绍过

00:25:14.781 --> 00:25:18.485
所以如果你把UI上下文固定到
最近的世代

00:25:18.552 --> 00:25:21.154
并且启用自动合并
你可以不必维护你的UI

00:25:21.221 --> 00:25:23.190
你的fault会很安全
你的对象绑定

00:25:23.257 --> 00:25:26.126
以及提取结果控制器
将保持最新

00:25:30.364 --> 00:25:31.398
好

00:25:33.967 --> 00:25:35.469
让我们讨论下泛型

00:25:36.136 --> 00:25:37.971
Core Data今年采用了泛型

00:25:38.038 --> 00:25:40.541
而且它们在ObjC
和Swift中都很好用

00:25:41.008 --> 00:25:43.911
有一种新的协议叫做
NSFetchRequestResult

00:25:44.111 --> 00:25:47.314
所有你可能看到的类型

00:25:47.381 --> 00:25:49.516
都采用了这种新协议
从提取请求

00:25:49.583 --> 00:25:52.853
如NSManagedObject
或所有的实体子类

00:25:53.320 --> 00:25:57.291
对象ID、NSDictionary
以及NSNumber

00:25:58.692 --> 00:26:01.995
NSFetchRequest
现基于结果类型被参数化

00:26:02.062 --> 00:26:04.998
协议一致性限制结果类型
在Swift中

00:26:05.065 --> 00:26:08.869
NSManagedObjectContext上的提取
方法探究提取请求的类型

00:26:08.936 --> 00:26:10.571
一直探究到你的结果

00:26:12.139 --> 00:26:13.640
最后 提取结果控制器

00:26:13.707 --> 00:26:16.910
它采取了对创建
它的提取请求的参数化

00:26:18.879 --> 00:26:20.547
说到
NSFetchResultsController

00:26:20.614 --> 00:26:23.817
如果你正在使用UICollection
视图 不好意思 在这儿

00:26:23.884 --> 00:26:25.385
UICollection视图
若你使用Core Data

00:26:25.452 --> 00:26:28.222
采用新数据元预提取功能

00:26:28.288 --> 00:26:29.656
会非常简单

00:26:29.723 --> 00:26:31.425
你需要做的只是
异步提取请求

00:26:31.491 --> 00:26:34.061
从而从主要线程获得请求
而且你应该确保

00:26:34.127 --> 00:26:36.129
不会将对象作为fault
返回

00:26:37.397 --> 00:26:39.199
关于数据源预提取的
详细信息

00:26:39.266 --> 00:26:41.235
请查看Steve和Peter
昨天的分享

00:26:41.301 --> 00:26:43.170
UICollection视图新特点

00:26:44.771 --> 00:26:47.374
如果你是Mac开发者
我也有好消息告诉你

00:26:47.441 --> 00:26:50.010
现在macOS提供
提取结果控制器

00:26:54.948 --> 00:26:58.352
好 让我们讨论下
Core Data中的一些常见操作

00:26:58.418 --> 00:27:00.687
从获取实体描述开始

00:27:01.555 --> 00:27:03.257
额 这个 好了

00:27:04.858 --> 00:27:06.727
为此 你需要
实体的字符串名称

00:27:06.793 --> 00:27:08.495
以及一个管理对象上下文

00:27:09.463 --> 00:27:11.798
创建提取请求同样
需要字符串常数

00:27:11.865 --> 00:27:15.068
以及类型转换
如果你想利用新的泛型

00:27:15.536 --> 00:27:18.071
最后是
创建新的管理对象

00:27:18.138 --> 00:27:20.207
其中三样都有 包括
字符串常数

00:27:20.274 --> 00:27:23.310
上下文参数
以及类型转换

00:27:23.944 --> 00:27:25.879
今年 这些操作都变得简单了

00:27:25.946 --> 00:27:28.715
因为我们改进了
对象子类的管理

00:27:29.449 --> 00:27:32.319
实体描述现在是子类上的
类方法

00:27:39.092 --> 00:27:40.327
别担心 这样更好

00:27:41.328 --> 00:27:42.863
这一类也有工厂方法

00:27:42.930 --> 00:27:45.365
可用于创建新的
完全键入的提取请求

00:27:50.704 --> 00:27:52.739
最后 你可以创建
新的管理对象

00:27:53.407 --> 00:27:56.109
只需直接使用子类的
初始值设定项

00:28:04.384 --> 00:28:06.420
还有一件事值得介绍

00:28:06.486 --> 00:28:08.322
那就是执行提取请求

00:28:08.388 --> 00:28:11.725
我之前提到过 上下文提取
方法在Swift经过参数化

00:28:11.792 --> 00:28:14.461
但ObjC不支持方法级别的泛型

00:28:14.528 --> 00:28:17.831
所以我们也添加了像语义
之类的执行者以提取请求

00:28:17.998 --> 00:28:20.000
所以你只需从提交
到上下文的数据块内

00:28:20.067 --> 00:28:22.035
调用执行方法

00:28:22.102 --> 00:28:24.404
就会返回正确键入的结果

00:28:29.576 --> 00:28:32.946
针对模型子类的新API
可以简化很多事情

00:28:33.013 --> 00:28:34.748
不过我猜想
你可能真正期待的是

00:28:34.815 --> 00:28:36.850
重新生成你所有的子类

00:28:37.417 --> 00:28:39.219
但不用担心 因为

00:28:39.286 --> 00:28:41.688
这应该是你需要
处理它们的最后一年

00:28:41.955 --> 00:28:44.992
因为Xcode 8现在能够
为你自动生成该代码

00:28:49.696 --> 00:28:51.865
你可以按实体配置代码世代

00:28:51.932 --> 00:28:55.068
Xcode会把生成的代码写入
你项目导出的数据

00:28:55.135 --> 00:28:57.571
所以不会导致未经你手的代码
对源树造成污染

00:28:58.405 --> 00:28:59.773
你无需编辑这些文件

00:28:59.840 --> 00:29:01.341
因为当你变更模型时

00:29:01.408 --> 00:29:02.342
代码会自动重新生成

00:29:02.409 --> 00:29:04.444
但如果你想进行

00:29:04.511 --> 00:29:07.281
在子类中添加自己的
实例变量等操作

00:29:07.347 --> 00:29:10.384
那么你也可以告诉Xcode
仅生成一个类别或扩展

00:29:10.450 --> 00:29:12.219
然后你可以拥有类本身

00:29:15.189 --> 00:29:17.658
在Swift中 为使用该功能
你需进行的操作是

00:29:17.724 --> 00:29:19.726
导入你实体所属的模块

00:29:19.793 --> 00:29:21.728
该模块通常也是你代码
所属的模块

00:29:22.062 --> 00:29:25.532
但是在ObjC中 你还需要了解
一些其中的工作原理

00:29:26.266 --> 00:29:31.004
ObjC中最需要了解的是
Core Data模型标题文件

00:29:31.638 --> 00:29:33.974
每个模型都有自己的标题文件
你需要将它导入

00:29:34.041 --> 00:29:36.743
以便访问所有
该模型生成的类

00:29:37.544 --> 00:29:40.047
如果我们放大 看一下
生成的其他文件

00:29:40.113 --> 00:29:42.149
了解为生成类而配置的实体

00:29:42.216 --> 00:29:45.018
Xcode创建了两个标题
你在自己生成类时

00:29:45.085 --> 00:29:46.520
可能已看见过
因而可识别出

00:29:46.887 --> 00:29:48.355
其中一个声明类界面

00:29:48.422 --> 00:29:50.724
另一个声明管理属性

00:29:52.025 --> 00:29:53.861
在ObjC中了解这点通常很重要

00:29:53.927 --> 00:29:55.829
因为如果你在生成
一个类别

00:29:55.896 --> 00:29:58.298
那么Xcode不会生成
类界面

00:29:58.799 --> 00:30:01.235
模型的标题将会
直接导入类别

00:30:02.302 --> 00:30:04.338
没有类界面
就无法声明类别

00:30:04.404 --> 00:30:06.773
所以生成的代码的
预期是能够

00:30:06.840 --> 00:30:09.476
在以该类命名的项目中
找到标题

00:30:09.710 --> 00:30:12.846
这是你拥有的文件
如果它不在你的项目中

00:30:12.913 --> 00:30:14.481
那么你就无法构建
你的目标

00:30:16.016 --> 00:30:18.118
让我们稍稍离开幻灯片
看一看

00:30:18.185 --> 00:30:20.187
这些新东西能为你带来什么

00:30:24.858 --> 00:30:26.260
我打开了Xcode 8

00:30:26.326 --> 00:30:28.495
我们将创建新的
Xcode项目

00:30:29.830 --> 00:30:32.399
并使用iOS
主明细应用

00:30:33.133 --> 00:30:36.203
我们今年更新了模块
以便使用新UI

00:30:36.436 --> 00:30:42.576
所以 如果我们将这个保存在
某位置 然后转至应用代理

00:30:43.177 --> 00:30:44.945
接着我们会看到

00:30:45.712 --> 00:30:47.948
我们这里使用的是
永久性容器

00:30:48.182 --> 00:30:52.219
我们将母版视图控制器

00:30:52.286 --> 00:30:54.354
与容器的视图上下文连接

00:30:56.123 --> 00:30:57.824
如果我们切换到
母版视图控制器

00:30:57.891 --> 00:31:00.961
我们可以看到
在创建新对象的地方

00:31:01.028 --> 00:31:05.132
我们已经在使用
Core Data生成的子类

00:31:05.599 --> 00:31:07.267
初始值设定项

00:31:07.534 --> 00:31:09.903
我们不再使用KVC

00:31:09.970 --> 00:31:12.506
我们可以在管理对象上
直接设置属性

00:31:12.573 --> 00:31:15.709
如果我们命令单击
就会转到生成的文件

00:31:19.046 --> 00:31:22.349
如果我们返回 看一下如何
设置提取结果控制器

00:31:22.916 --> 00:31:23.951
好了

00:31:25.752 --> 00:31:28.188
我们能看到
在事件分类上

00:31:28.255 --> 00:31:29.790
引发提取请求工厂方法

00:31:29.990 --> 00:31:33.927
这里没有额外明确的键入

00:31:33.994 --> 00:31:37.631
当我们创建提取结果控制器
但是它的类型

00:31:38.131 --> 00:31:40.200
非常小
如果我们在这儿放大

00:31:41.068 --> 00:31:42.936
它的类型通过提取请求
传递

00:31:43.937 --> 00:31:45.739
这意味着 其它地方

00:31:46.240 --> 00:31:48.775
比如
prepare for segue

00:31:51.578 --> 00:31:52.579
好了

00:31:53.847 --> 00:31:55.682
当我们从提取结果控制器
获得对象

00:31:55.749 --> 00:31:57.518
会返回正确的类型

00:31:58.886 --> 00:32:01.221
这样 都好了
我们不再有任何类型转换

00:32:03.423 --> 00:32:06.527
不过 我不想让这个应用
像默认设置这样

00:32:06.593 --> 00:32:08.729
在母版视图控制器中
显示时间戳

00:32:08.795 --> 00:32:12.733
所以让我们在这里给事件
实体添加一个标题属性

00:32:15.235 --> 00:32:18.205
我们希望它是字符串类型

00:32:20.541 --> 00:32:22.943
好了 我们重建并保存了模型

00:32:23.010 --> 00:32:25.979
如果我们返回到这儿
转至配置单元格

00:32:28.315 --> 00:32:29.750
我们可在这里删除相应代码

00:32:31.552 --> 00:32:33.453
使用Xcode的
自动完成功能

00:32:33.520 --> 00:32:36.290
获取我们刚刚在模型中
设置的新属性

00:32:43.063 --> 00:32:44.998
同样 如果我们命令单击它

00:32:45.065 --> 00:32:46.567
将更新所有的代码

00:32:52.639 --> 00:32:54.641
这其中最大一个隐性的好处是

00:32:54.708 --> 00:32:56.777
如果你使用手动生成的子类

00:32:56.844 --> 00:33:00.080
甚至KVC 如果你更改
属性的名称

00:33:00.247 --> 00:33:01.882
你最后可能遇到非常奇怪的故障

00:33:01.949 --> 00:33:03.617
因为你的项目会编译

00:33:03.684 --> 00:33:08.789
但如果实际调用时
你会遇到运行时错误

00:33:08.856 --> 00:33:10.924
因为注册表项路径
不再存在

00:33:11.458 --> 00:33:14.127
子类生成自动处理所有这些

00:33:17.197 --> 00:33:18.732
这就是自动分类生成

00:33:18.799 --> 00:33:21.835
以及Core Data新API的
一些工作实例

00:33:24.872 --> 00:33:27.407
最后 让我们介绍下
SQLite的新特性

00:33:28.742 --> 00:33:31.011
操作系统附带的
SQLite库

00:33:31.078 --> 00:33:33.347
有一些你在其它地方
找不到的新功能

00:33:33.413 --> 00:33:35.949
首先是多线程声明

00:33:37.317 --> 00:33:40.587
Apple平台上的SQLite
没有线程安全连接

00:33:40.654 --> 00:33:43.056
多线程故障很难诊断

00:33:43.123 --> 00:33:45.926
有时是因为它们
通常显示为崩溃报告

00:33:45.993 --> 00:33:48.495
SQLite深处只有一个线程

00:33:49.463 --> 00:33:51.698
为使这些问题更容易被
识别和重现

00:33:51.765 --> 00:33:54.067
系统SQLite支持新的
环境变量

00:33:54.134 --> 00:33:56.103
该变量可以启用
多线程声明

00:33:56.170 --> 00:33:59.139
当它们启用时
你将在SQLite中看到两个线程

00:33:59.206 --> 00:34:01.375
两个线程均使用同一连接

00:34:03.911 --> 00:34:06.446
SQLite始终通过可使用
SQLite3 config进行配置

00:34:06.513 --> 00:34:09.882
支持用户定义的记录功能

00:34:09.949 --> 00:34:12.985
但是应在库初始化之前
调用该功能

00:34:13.053 --> 00:34:14.688
而库初始化可能已经发生

00:34:15.422 --> 00:34:17.157
SQLite的可配置性很棒

00:34:17.224 --> 00:34:20.194
不过我们在运行建模系统
该系统有内置记录设施

00:34:20.260 --> 00:34:22.429
所以现在有另一个环境变量

00:34:22.496 --> 00:34:25.032
将SQLite记录送到系统日志

00:34:27.266 --> 00:34:30.938
最后 我要介绍下文件操作

00:34:32.072 --> 00:34:34.741
所有的数据库
由一组文件表示

00:34:34.808 --> 00:34:37.444
当文件操作在多个文件中
进行时

00:34:37.511 --> 00:34:39.045
文件操作不可能是原子的

00:34:39.112 --> 00:34:41.014
这样的结果是
所有的文件操作

00:34:41.081 --> 00:34:42.449
本身都是不安全的

00:34:42.850 --> 00:34:45.953
从Unix文件API
到NSFileManager 所有的

00:34:46.587 --> 00:34:47.688
这一点确实很重要

00:34:47.754 --> 00:34:49.889
我想分享几个实际的例子

00:34:49.956 --> 00:34:51.024
表明问题如何产生

00:34:52.458 --> 00:34:55.362
比如 我发现目录中
有两个数据库文件

00:34:56.263 --> 00:34:58.465
我的代码要进行清理
所以删除了两个文件

00:34:58.532 --> 00:35:00.000
在删除数据库时

00:35:00.067 --> 00:35:02.236
日志之类的东西
连接到数据库文件

00:35:03.170 --> 00:35:05.405
该数据库无法访问日志

00:35:05.539 --> 00:35:07.474
所以系统无法识别数据库

00:35:07.541 --> 00:35:09.409
就立即报告错误

00:35:09.476 --> 00:35:10.978
因此影响你的应用

00:35:11.745 --> 00:35:13.914
除非你能保证
目前没有任何东西

00:35:13.981 --> 00:35:16.083
将来也不会有任何东西试图
连接到数据库

00:35:16.149 --> 00:35:18.018
否则删除文件都是不安全的

00:35:19.887 --> 00:35:21.588
比如 我有wall模式的数据库

00:35:21.655 --> 00:35:23.357
该数据库正在使用中

00:35:23.757 --> 00:35:26.426
由于某种原因 数据库最终
被移开

00:35:27.661 --> 00:35:29.496
当数据库在新位置打开时

00:35:29.563 --> 00:35:31.899
相应的连接创建了
新的日志和锁定文件

00:35:32.266 --> 00:35:33.200
现在你就有两个连接

00:35:33.267 --> 00:35:34.902
分别使用不同日志和锁定

00:35:34.968 --> 00:35:37.571
不久 它们就会损坏数据库

00:35:40.073 --> 00:35:42.042
这些例子可能有些
牵强不常见

00:35:42.109 --> 00:35:44.011
但是总共有超过十亿的设备

00:35:44.077 --> 00:35:45.279
可能发生问题

00:35:45.345 --> 00:35:47.781
对每个可能文件的
每个可能的操作

00:35:47.848 --> 00:35:49.583
都可能导致使用你应用的
用户遇到问题

00:35:49.650 --> 00:35:52.319
如果用户数据丢失 就会很慌乱

00:35:53.787 --> 00:35:55.489
硬链接非常不好

00:35:55.556 --> 00:35:57.424
不要对数据库文件
使用硬链接

00:35:59.126 --> 00:36:02.996
所以 今年的新内容是
操作系统附带的SQLite库

00:36:03.063 --> 00:36:05.199
充分利用分派源

00:36:05.399 --> 00:36:07.501
如果非法操作
对文件产生影响

00:36:07.568 --> 00:36:10.204
数据库连接会报告错误

00:36:10.771 --> 00:36:13.240
系统自身解决
数据损坏问题

00:36:13.307 --> 00:36:15.609
大多情况下 损坏已经发生

00:36:15.876 --> 00:36:18.412
所以为帮助你识别
并纠正这些问题

00:36:18.478 --> 00:36:22.516
我们添加了另一个环境变量
该变量可以使连接

00:36:22.583 --> 00:36:25.452
在发现非法操作影响其文件时
立即作出声明

00:36:26.653 --> 00:36:27.754
如果你想知道

00:36:27.821 --> 00:36:29.056
数据库损坏的更多原因

00:36:29.122 --> 00:36:31.425
SQLite在网站上有指导手册

00:36:31.491 --> 00:36:34.228
名称是“如何损坏
SQLite数据库文件”

00:36:39.867 --> 00:36:41.668
幸运地是 这些问题是
可以避免的

00:36:42.302 --> 00:36:44.204
如果你直接使用SQLite
你应确保

00:36:44.271 --> 00:36:46.807
只有一段代码拥有该数据库

00:36:46.874 --> 00:36:49.376
该段代码应进入
专门的文件访问

00:36:49.443 --> 00:36:51.278
所以文件在打开时无法被修改

00:36:52.212 --> 00:36:54.181
若你正使用Core Data
你应该是在用

00:36:54.248 --> 00:36:56.216
永久性存储协调器内
有一个API

00:36:56.283 --> 00:36:58.318
可以始终安全地用于
SQLite数据库

00:36:58.385 --> 00:36:59.686
无论是数据库打开与否

00:36:59.853 --> 00:37:02.789
replacePersistentStore
可将一个数据库更换为

00:37:02.856 --> 00:37:04.024
另一个数据库的内容

00:37:04.258 --> 00:37:05.826
而destroyPersistentStore

00:37:05.893 --> 00:37:07.928
可以安全删除数据库中
所有内容

00:37:07.995 --> 00:37:09.663
并留下空白的数据库

00:37:12.866 --> 00:37:16.103
好 上述就是今年
Core Data的新特性

00:37:16.170 --> 00:37:18.739
简要回顾下 我们新增了一项
叫做查询生成的功能

00:37:18.805 --> 00:37:21.942
这种功能可以使你
即刻看到数据的稳定视图

00:37:23.076 --> 00:37:25.646
我们现在使用支持连接池
以及永久性存储协调器

00:37:25.712 --> 00:37:27.781
这样可以同时允许多个读取器

00:37:27.848 --> 00:37:30.551
作为单个编写器
使你在进行大量数据操作的同时

00:37:30.617 --> 00:37:32.486
能够保持漂亮的界面

00:37:33.820 --> 00:37:35.656
Core Data设置更简单了

00:37:35.722 --> 00:37:38.025
新API也使Core Data
使用更简单

00:37:38.091 --> 00:37:39.860
它在Swift中尤其好用

00:37:40.327 --> 00:37:43.330
这得到Xcode全新集成的
全面支持

00:37:43.397 --> 00:37:46.166
我们在SQLite中
也有新功能

00:37:46.333 --> 00:37:49.069
可以使一般问题的
调试更简单

00:37:52.472 --> 00:37:53.340
要了解更多信息

00:37:53.407 --> 00:37:56.810
请查看我们的开发者网站
是在演讲242

00:37:57.878 --> 00:38:00.247
如果你想了解更多
可以参考Swift新特性

00:38:00.314 --> 00:38:01.982
以及Cocoa的新特性

00:38:02.482 --> 00:38:03.417
感谢大家的到来