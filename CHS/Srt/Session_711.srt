00:00:19.486 --> 00:00:22.389 
NSURLSession：新特性和典范

00:00:29.796 --> 00:00:31.798 
谢谢大家 早上好

00:00:34.034 --> 00:00:35.969 
感谢大家今天的到来

00:00:36.537 --> 00:00:41.308 
这里是NSURLSession:
新特性和典范讲座

00:00:41.408 --> 00:00:42.809 
我是Jeff Jenkins

00:00:42.876 --> 00:00:46.213 
我是一个软件工程师
来自网络技术部

00:00:46.747 --> 00:00:50.284 
我今天有一些非常有用的信息
想和大家分享

00:00:50.350 --> 00:00:51.752 
关于NSURLSession

00:00:51.818 --> 00:00:54.688 
那我们还等什么
现在就按日程开始

00:00:54.755 --> 00:00:57.224 
看看今天我们会讲些什么

00:00:58.525 --> 00:01:02.863 
NSURLSession API
给我们提供了非常丰富的类

00:01:02.963 --> 00:01:07.067 
和方法可以简化
现代日常网络工作的复杂性

00:01:08.368 --> 00:01:13.073 
今天我们就来讨论下
NSURLSession API已取得的发展

00:01:13.140 --> 00:01:15.309 
我还要和你分享一些它的新特性

00:01:15.442 --> 00:01:18.478 
和我们对这个API所做的强化

00:01:18.679 --> 00:01:20.547 
我们将会用一个实例应用向你展示

00:01:20.614 --> 00:01:24.051 
一些新特性和运行状况

00:01:26.420 --> 00:01:28.989 
我来花些时间谈谈安全性

00:01:29.356 --> 00:01:34.361 
对于你们用户来说
保护你们的数据和隐私很重要

00:01:34.528 --> 00:01:35.829 
如果这个对你们很重要

00:01:35.896 --> 00:01:38.832 
我们就知道这个对你和
你的应用程序很重要

00:01:39.199 --> 00:01:41.635 
我会和你们分享下
我们做得一些技术强化

00:01:41.702 --> 00:01:44.938 
对于NSURLSession安全性

00:01:46.573 --> 00:01:49.810 
在讲座的整个阶段

00:01:49.877 --> 00:01:53.313 
我会不时的和大家分享
一些最佳实践和技巧

00:01:53.380 --> 00:01:55.916 
这样你就能让你的应用变得更了不起

00:01:58.819 --> 00:02:02.356 
好了 我们先从顶层API开始看起

00:02:02.422 --> 00:02:05.826 
它对Apple所有平台的
应用程序都是可用的

00:02:06.894 --> 00:02:11.164 
这么多年来Foundation框架
一直支撑着NSURLConnection API

00:02:11.598 --> 00:02:15.435 
NSURLConnection
现如今成为了一个强大的网络抽象

00:02:15.502 --> 00:02:18.772 
它提供了很多非常好的基础网络功能

00:02:18.839 --> 00:02:20.607 
可以被开发者在应用中使用

00:02:21.041 --> 00:02:24.244 
但是 我们常问自己
怎么才能做的更好

00:02:24.745 --> 00:02:27.681 
还有开发者会想要我们做什么

00:02:27.748 --> 00:02:30.284 
于是我们就坐下来讨论这个话题

00:02:30.350 --> 00:02:33.253 
然后我们发现很多问题的答案都和

00:02:33.320 --> 00:02:34.821 
配置网络有关

00:02:34.888 --> 00:02:37.457 
但是在应用中配置网络可能会非常困难

00:02:37.524 --> 00:02:38.525 
特别是你需要

00:02:38.592 --> 00:02:41.895 
在同一个应用程序中
配置不同类型的网络

00:02:43.397 --> 00:02:44.631 
因此 我们就采取了行动

00:02:45.132 --> 00:02:50.470 
在2015年我们正式的弃用了
NSURLConnection API

00:02:50.537 --> 00:02:53.941 
意思是我们不会对那API增加新功能

00:02:54.007 --> 00:02:56.176 
它只能得到很少的维护

00:02:57.477 --> 00:03:02.416 
但是我们在2013年的
WWDC 上正式弃用之前

00:03:02.749 --> 00:03:04.785 
我们引入了NSURLSession

00:03:04.852 --> 00:03:08.388 
来替换Foundation层
网络的API

00:03:09.056 --> 00:03:12.226 
我们当时提倡过你们
我们现在继续提倡你们

00:03:12.492 --> 00:03:14.962 
在网络代码中开始使用
NSURLSession API

00:03:15.028 --> 00:03:16.630 
现在正在使用的应用

00:03:16.697 --> 00:03:19.533 
和你未来即将开发的应用程序

00:03:21.535 --> 00:03:25.506 
既然NSURLSession
是最好的顶层API

00:03:25.973 --> 00:03:29.042 
对于Apple平台的网络编程来说

00:03:29.343 --> 00:03:32.679 
先来看一些NSURLSession
的基础知识

00:03:33.013 --> 00:03:39.186 
如果你想要一个详细深入的
NSURLSession介绍

00:03:39.253 --> 00:03:44.224 
我推荐你去2015年 WWDC

00:03:44.291 --> 00:03:46.593 
特别是2014年的

00:03:46.660 --> 00:03:49.029 
然后看看那些

00:03:50.697 --> 00:03:54.101 
和NSURLSession讲座
配套的视频和幻灯片

00:03:55.636 --> 00:03:57.671 
我一直吹捧
NSURLSession API

00:03:57.738 --> 00:04:01.275 
推荐在你的应用中使用这个API

00:04:01.675 --> 00:04:05.245 
那到底为何NSURLSession
值得这样的称赞？

00:04:05.312 --> 00:04:09.583 
其中一部分好处是
我们会持续有力的支持

00:04:09.750 --> 00:04:12.519 
HTTP/1.1协议

00:04:13.887 --> 00:04:16.523 
我们也支持SPDY协议

00:04:16.690 --> 00:04:21.128 
但我们不赞成
新网页服务的建立基于SPDY协议

00:04:21.195 --> 00:04:26.800 
你应该朝前看 使用HTTP/2协议

00:04:26.867 --> 00:04:31.405 
显然我们的NSURLSession
支持HTTP/2

00:04:31.772 --> 00:04:35.142 
我们的支持是基于RFC7540的

00:04:35.375 --> 00:04:38.345 
而且我们会不停的给这个协议
增加新的功能

00:04:41.181 --> 00:04:43.917 
应用安全传输 或ATS

00:04:43.984 --> 00:04:46.887 
是NSURLSession
内置非常好的功能

00:04:47.120 --> 00:04:50.324 
它是一个安全性功能
可以提高隐私保护

00:04:50.624 --> 00:04:55.662 
和数据完整性
在应用和网页连接过程中

00:04:56.830 --> 00:04:59.666 
ATS最重要方面之一

00:04:59.733 --> 00:05:03.303 
是你的应用必须使用HTTPS协议

00:05:03.971 --> 00:05:06.306 
同时它允许你 也就是开发者

00:05:06.373 --> 00:05:09.576 
在建立连接时采用最佳实践

00:05:09.643 --> 00:05:12.279 
通过HTTPS来和远程服务器通信

00:05:13.680 --> 00:05:18.118 
HTTP严格传输安全
或叫HSTS

00:05:18.318 --> 00:05:20.988 
是NSURLSession内置的
另外一个非常好的功能

00:05:21.154 --> 00:05:24.291 
这个功能保护了用户的数据和隐私

00:05:24.358 --> 00:05:27.728 
现在它可以通过HTTP报头进行配置

00:05:27.794 --> 00:05:29.897 
来自你的网页服务

00:05:30.163 --> 00:05:32.966 
或者它可以通过预加载的列表进行配置

00:05:33.033 --> 00:05:36.069 
（列表）是嵌入在你应用程序系统中的

00:05:36.470 --> 00:05:40.307 
当配置好了以后
所有被传输 发送 接收的数据

00:05:40.374 --> 00:05:42.176 
都会通过一个安全的连接进行

00:05:42.609 --> 00:05:43.877 
HSTS最棒的

00:05:43.944 --> 00:05:47.447 
是它不需要在你的应用程序中
进行任何代码改动

00:05:50.150 --> 00:05:53.420 
所有非常好的内置功能都支持

00:05:53.487 --> 00:05:58.025 
来处理缓存cookies代理

00:05:58.292 --> 00:05:59.760 
和认证请求的内置子系统

00:05:59.826 --> 00:06:02.162 
所有这些都是
NSURLSession自带的

00:06:03.764 --> 00:06:05.399 
最后特别是 配置

00:06:05.465 --> 00:06:07.501 
正如我所说
我们讨论了很多如何才能把

00:06:07.568 --> 00:06:11.772 
网络或在你应用程序中
配置网络变得简单一些

00:06:12.406 --> 00:06:14.942 
因为我们需要更好的去控制网络

00:06:15.008 --> 00:06:17.077 
所以我们刻苦钻研了配置这一块儿

00:06:17.144 --> 00:06:22.649 
为了达到二级精度
和让你更好的控制网络

00:06:22.716 --> 00:06:24.985 
在NSURLSession中
我们创建了一个新的类

00:06:25.052 --> 00:06:27.354 
叫NSURLSessionConfiguration

00:06:27.888 --> 00:06:31.458 
这个类包含了很多你可以配置的属性

00:06:32.693 --> 00:06:34.528 
你可以在你的应用程序中

00:06:34.595 --> 00:06:38.165 
根据不同的网络需求创建配置文件

00:06:39.399 --> 00:06:42.436 
这里是一些属性的一个样本

00:06:42.536 --> 00:06:45.772 
你可以用NSURLSessionConfiguration
来设置它们

00:06:46.773 --> 00:06:50.978 
安全传输层协议
或TLS版本

00:06:51.778 --> 00:06:54.715 
你可以控制TLS版本的最低值和最高值

00:06:54.781 --> 00:06:56.884 
以便你的应用来支持

00:06:57.184 --> 00:07:02.956 
我们默认设置TSL最低版本是1.0
最高版本是1.2

00:07:04.892 --> 00:07:09.162 
你可以用你的应用程序
控制蜂窝数据的使用

00:07:09.229 --> 00:07:12.299 
你是否允许你的应用使用
蜂窝网络

00:07:12.366 --> 00:07:16.470 
可能你只想用Wi-Fi网络
你就可以在这里设置

00:07:19.406 --> 00:07:22.309 
你可以指定你的网络服务类型

00:07:22.576 --> 00:07:24.811 
这里的一些例子可能都是默认值

00:07:24.878 --> 00:07:27.181 
也是标准的网络数据流量

00:07:27.481 --> 00:07:30.284 
你的应用可能会有VoiP控制

00:07:30.350 --> 00:07:34.488 
或视频数据和声音数据
各种不同种类的数据

00:07:34.555 --> 00:07:38.091 
说实在的
这只是低端网络层的一些提示

00:07:38.358 --> 00:07:42.729 
告诉你都有什么样的数据
这样才能建立一个高质量的服务

00:07:42.796 --> 00:07:45.966 
这对你设备上运行的程序是最好的

00:07:48.402 --> 00:07:49.436 
Cookie政策

00:07:49.503 --> 00:07:52.673 
也许你想让你的cookie
只存在一段时间

00:07:52.739 --> 00:07:54.107 
或者一直存在

00:07:54.174 --> 00:07:56.376 
这里就是设置它的地方

00:07:56.577 --> 00:07:59.646 
同理 对于缓存
也许你想要一个临时缓存

00:07:59.780 --> 00:08:02.850 
或者在加载应用时用持续缓存

00:08:03.283 --> 00:08:05.219 
这里就是设置它的地方

00:08:06.320 --> 00:08:09.323 
你还可以指定存储对象

00:08:09.523 --> 00:08:13.760 
好吧 有可能你需要在
不同类型的网络之间共享缓存

00:08:13.827 --> 00:08:17.331 
或不同类型网络间共享cookies
而且全部在你同一个应用中

00:08:17.531 --> 00:08:21.802 
这里就可以设置
存储对象实现那个配置

00:08:22.703 --> 00:08:27.975 
超时设定
你可以设置资源和请求的超时时间

00:08:28.208 --> 00:08:31.778 
这样你的应用就可以处理
网络中的错误情况

00:08:33.580 --> 00:08:38.251 
假设大多数人都有些了解
NSURLSession API

00:08:38.318 --> 00:08:43.490 
若没 去2014年 WWDC 看看
关于NSURLSession部分

00:08:43.557 --> 00:08:47.995 
你会更深的
了解那个API是怎么工作的

00:08:48.195 --> 00:08:50.797 
我想对于我们剩下要谈的部分

00:08:50.864 --> 00:08:53.901 
最好能看一下
NSURLSession

00:08:54.501 --> 00:08:56.737 
从代码角度来看是怎么工作的

00:08:57.738 --> 00:08:59.973 
很简单 我们第一步要做的

00:09:00.040 --> 00:09:02.709 
是创建一个配置对象

00:09:02.776 --> 00:09:05.979 
第一件事 这里我们把它称作
NSURLSessionConfigurations

00:09:06.046 --> 00:09:08.448 
.defaultSessionConfiguration

00:09:08.949 --> 00:09:13.487 
我们全部使用默认值然后我们就
有了一个非常简单的配置可以使用

00:09:15.088 --> 00:09:18.625 
现在我们把那个配置传给一个session

00:09:18.692 --> 00:09:21.495 
通过调用NSURLSessions emitter
可创建一个session

00:09:21.762 --> 00:09:23.163 
它接收的参数是一配置对象

00:09:23.230 --> 00:09:26.300 
噢！我们就有了
一个非常简单的session可以使用

00:09:28.001 --> 00:09:30.737 
有了这个session
我们就可以做点事情了

00:09:31.171 --> 00:09:34.308 
好 我们首先要建立一个NSURL

00:09:34.708 --> 00:09:36.310 
并指定它的端点

00:09:36.376 --> 00:09:39.746 
就是我们从哪儿接收和请求数据

00:09:40.314 --> 00:09:43.217 
当我们有了它
我们就可以新建一个任务

00:09:43.283 --> 00:09:45.152 
在此我们调用dataTask方法

00:09:45.219 --> 00:09:47.421 
然后把NSURL对象

00:09:47.621 --> 00:09:49.923 
是我们之前新建的
传给dataTask方法

00:09:51.592 --> 00:09:53.727 
我们也提供一个闭包

00:09:54.394 --> 00:09:56.964 
这个闭包在这里被异步地调用

00:09:57.097 --> 00:09:59.099 
当我们的任务加载完成时

00:09:59.166 --> 00:10:02.870 
请求的资源就返回给了我们

00:10:04.238 --> 00:10:08.108 
老样子 别忘了你要确保调用了
task.resume

00:10:08.208 --> 00:10:10.677 
我们新建的所有任务都处于挂起状态

00:10:10.744 --> 00:10:14.348 
你必须调用task.resume
来执行那个任务

00:10:15.916 --> 00:10:18.519 
好了 现在复习下 简单的复习

00:10:18.719 --> 00:10:22.055 
NSURLSession
实际上就是一个三部曲

00:10:22.890 --> 00:10:25.192 
首先你需要新建一个配置对象

00:10:27.794 --> 00:10:30.597 
有了那个配置项
你就可以新建你的session

00:10:32.332 --> 00:10:35.169 
有了session你就能开始干活了

00:10:35.235 --> 00:10:37.504 
还要在session上新建些任务

00:10:37.871 --> 00:10:40.741 
我现在要建议给你些最佳实践

00:10:42.476 --> 00:10:47.447 
一定要避免单任务对单
session的模型

00:10:48.782 --> 00:10:52.019 
你绝对不应该这样设置你的网络

00:10:52.686 --> 00:10:55.789 
说真的 你应该这样设计

00:10:55.856 --> 00:10:59.426 
有一个session服务
建立很多很多任务

00:10:59.493 --> 00:11:01.495 
当然你也可以有多个session

00:11:01.728 --> 00:11:06.099 
但是一定要避免单session对单
任务的模型

00:11:06.233 --> 00:11:09.269 
原因是
它真的会降低你的网络性能

00:11:09.403 --> 00:11:13.340 
你可以通过创建很少的几个sessions
运行很多任务

00:11:13.407 --> 00:11:17.444 
这样就会更好地管理内存
优化OS资源使用

00:11:20.180 --> 00:11:23.617 
像我提到过的
NSURLSession API一直在改进

00:11:23.951 --> 00:11:27.087 
我们来谈一下HTTP/2协议

00:11:27.454 --> 00:11:29.723 
还有我们一直在这个协议上做出的努力

00:11:29.790 --> 00:11:31.458 
都和
NSURLSession相关

00:11:34.094 --> 00:11:37.531 
在NSURLSession中
对HTTP/2协议的支持

00:11:37.598 --> 00:11:40.100 
是去年在 WWDC 上引入的

00:11:40.701 --> 00:11:43.103 
它正在变得热门起来

00:11:44.238 --> 00:11:48.775 
你知道吧 大的因特网服务提供商
逐渐开始支持HTTP/2

00:11:50.010 --> 00:11:53.447 
是什么让HTTP/2协议
变得如此吸引人

00:11:53.914 --> 00:11:55.716 
那我们就来看一下它的一些功能

00:11:55.816 --> 00:12:00.621 
HTTP/2协议非常棒的功能之一是
支持多路复用技术和并发

00:12:00.921 --> 00:12:05.158 
这个功能允许多个请求和响应

00:12:05.225 --> 00:12:07.594 
同时发生

00:12:07.995 --> 00:12:10.264 
响应可以不按顺序被接收

00:12:10.464 --> 00:12:13.667 
所有的响应都在一次TCP连接中完成

00:12:14.801 --> 00:12:18.005 
这个协议另一个很棒的功能是
报头压缩

00:12:18.205 --> 00:12:22.142 
这样可以减少HTTP/2报头的大小

00:12:22.509 --> 00:12:24.945 
这也减少了在网络上往返的次数

00:12:25.012 --> 00:12:26.446 
这样对带宽更好

00:12:26.513 --> 00:12:29.283 
而且更好的是可提高你应用程序的性能

00:12:30.517 --> 00:12:33.687 
还有一个很棒的功能
是流的优先级

00:12:33.820 --> 00:12:36.156 
作为HTTP/2的客户端

00:12:36.256 --> 00:12:40.994 
你可以指定从服务器返回资源的优先级

00:12:41.061 --> 00:12:43.730 
这就允许你留意并调整

00:12:43.797 --> 00:12:46.233 
你应用的网络

00:12:47.467 --> 00:12:51.605 
所以本质上讲
HTTP/2都是关于性能的

00:12:51.672 --> 00:12:55.075 
这样会提升终端用户的体验

00:12:55.142 --> 00:12:56.977 
当他们和你的应用进行互动时

00:12:57.344 --> 00:13:02.349 
好了 关于HTTP/2
我们还有最后一个功能要来看一下

00:13:02.850 --> 00:13:06.086 
今天我们介绍的是
NSURLSession

00:13:06.153 --> 00:13:09.923 
对于HTTP/2服务器
推送功能的支持

00:13:15.996 --> 00:13:17.931 
那么什么是服务器推送

00:13:17.998 --> 00:13:22.803 
当客户端发出一个请求
服务器就会对请求做出响应

00:13:23.237 --> 00:13:27.608 
但同时 它可以推送
额外的响应给客户端

00:13:27.674 --> 00:13:29.209 
试想一个网页

00:13:29.276 --> 00:13:31.578 
它是由很多很多资源组成的

00:13:31.945 --> 00:13:36.216 
与其让客户端在
网络上一个个的抓取资源

00:13:36.283 --> 00:13:40.487 
服务器可以
在发送原始响应的同时

00:13:40.654 --> 00:13:45.459 
推送额外客户端可能会用到的信息

00:13:46.994 --> 00:13:52.332 
这样服务器推送就避免了HTTP/1.1
和无服务器推送产生的HTTP/2

00:13:52.399 --> 00:13:56.637 
如今所要求的网络上往返多次

00:13:57.938 --> 00:14:01.175 
现在我想请大家注意下
服务器

00:14:01.241 --> 00:14:05.078 
很显然得支持这个协议
得支持HTTP/2

00:14:05.145 --> 00:14:07.514 
还得进行配置

00:14:07.814 --> 00:14:10.317 
来使用服务器推送的功能

00:14:10.851 --> 00:14:14.021 
服务器推送现在可以被

00:14:14.788 --> 00:14:16.757 
使用NSURLSession
的应用程序使用了

00:14:16.823 --> 00:14:21.195 
没有必要去选择性加入
没有搞笑的属性你需要去设置

00:14:21.261 --> 00:14:23.730 
它就在那儿
就这么简单

00:14:24.198 --> 00:14:25.933 
这就是我们强烈认为

00:14:25.999 --> 00:14:30.504 
NSURLSession API是
如今应用程序可以使用的最好的API

00:14:30.871 --> 00:14:33.907 
我们现在来花几分钟深入探讨下

00:14:33.974 --> 00:14:36.343 
服务器推送如何让你的应用受益

00:14:39.279 --> 00:14:42.983 
我有一个图表代表着一个应用使用
NSURLSession的情况

00:14:43.050 --> 00:14:48.355 
它是用HTTP/1.1协议
来做一些网络加载

00:14:48.689 --> 00:14:52.626 
现在我们往下看这个图表
时间在累积

00:14:52.693 --> 00:14:55.095 
这些总共的延迟

00:14:55.162 --> 00:14:57.965 
就是当我们的应用程序
进行网络加载时产生的

00:14:59.299 --> 00:15:02.503 
下面 首先我们的应用
要继续开始一个任务

00:15:03.904 --> 00:15:07.074 
这个任务要请求index.html

00:15:08.041 --> 00:15:11.411 
我们会假设一切运行良好
因为网络会办到的

00:15:12.079 --> 00:15:15.682 
我们就会从服务器得到响应
包含我们请求的数据

00:15:16.450 --> 00:15:19.753 
除了index.html的数据

00:15:19.820 --> 00:15:21.522 
我们发现时间已经过去了

00:15:21.755 --> 00:15:25.058 
我们的总延迟在累计 在增长

00:15:26.293 --> 00:15:28.929 
现在我们的应用要继续执行另一个任务

00:15:28.996 --> 00:15:32.232 
然后从服务器请求style.css

00:15:32.299 --> 00:15:34.434 
假设一切正常工作

00:15:34.501 --> 00:15:36.303 
我们将会得到响应

00:15:36.937 --> 00:15:39.373 
我们就有了style.css

00:15:39.706 --> 00:15:42.576 
我们的总延迟也开始增长

00:15:42.643 --> 00:15:44.811 
随着在网络上获取所需资源的时间

00:15:47.247 --> 00:15:49.616  
现在应用程序将继续执行最后一个任务

00:15:49.683 --> 00:15:51.752  
请求background.jpg

00:15:52.219 --> 00:15:56.890  
我们会从服务器得到响应
就有了background.jpg

00:15:58.158 --> 00:16:01.595  
我们的应用到此就结束了它的网络加载

00:16:01.795 --> 00:16:05.799  
再来看图表
我们看到这个就是我们的总延时

00:16:05.866 --> 00:16:08.635  
用的是HTTP/1.1协议进行加载

00:16:10.537 --> 00:16:12.372 
再来看我们的应用程序

00:16:12.439 --> 00:16:16.009 
当它可以使用服务器推送的情况

00:16:16.343 --> 00:16:19.213 
我准备把HTTP/1.1
加载结果的图表移到

00:16:19.279 --> 00:16:20.948 
一边来做参考

00:16:21.782 --> 00:16:26.854 
我们的应用将再次继续一个任务
请求index.html

00:16:27.087 --> 00:16:31.491 
这是我们第二次得到响应的总延迟

00:16:32.492 --> 00:16:36.029 
我们的总延迟的变化

00:16:36.163 --> 00:16:38.932 
和无服务器推送比相差不大

00:16:39.366 --> 00:16:40.567 
这是预料之中的

00:16:40.968 --> 00:16:43.237 
会发生的是

00:16:43.437 --> 00:16:47.508 
在原始请求响应的同时

00:16:47.574 --> 00:16:51.011 
服务器会推送
其他资源给NSURLSession

00:16:52.246 --> 00:16:55.115 
这个会和原始请求一起

00:16:55.182 --> 00:16:57.384 
或者是对原始请求的响应

00:16:58.452 --> 00:17:02.155 
当我们的应用继续第二个任务时

00:17:02.723 --> 00:17:07.060 
也就是请求style.css时
我们几乎立马得到了响应

00:17:07.127 --> 00:17:09.363 
这是因为服务器推送给了我们这个数据

00:17:09.429 --> 00:17:11.964 
在我们知道需要它之前

00:17:12.933 --> 00:17:16.670 
我们就有了style.css
看累计时间我们注意到

00:17:16.737 --> 00:17:19.439 
style.css的延时非常的短

00:17:19.506 --> 00:17:21.642 
比起HTTP/1.1而言

00:17:21.708 --> 00:17:24.578 
需要加载的是一摸一样的资源

00:17:27.013 --> 00:17:31.118 
现在 我们的应用继续了最后一个任务
请求了background.jpg

00:17:31.285 --> 00:17:33.620 
又一次 我们很快得到了响应

00:17:33.887 --> 00:17:36.023 
应用得到了background.jpg

00:17:36.223 --> 00:17:39.760 
我们把这次总延时加到累计总延时上

00:17:40.727 --> 00:17:43.597 
到这里 应用结束了它的网络加载

00:17:44.698 --> 00:17:48.235 
我们看到使用服务器推送的
HTTP/2所用的总延时

00:17:48.302 --> 00:17:53.507 
比使用HTTP/1或者
不用服务器推送的加载时间要短的多

00:17:53.974 --> 00:17:57.444 
能提高性能的原因是有了服务器推送

00:17:57.678 --> 00:18:00.981 
我们就能缩短在网络上多次往返的延时

00:18:01.048 --> 00:18:03.450 
当我们需要请求资源的时候

00:18:06.920 --> 00:18:09.923 
下面 有请
Andreas Garkuscha

00:18:09.990 --> 00:18:14.361 
向我们展示在实际应用程序中
服务器推送是什么样子的

00:18:14.428 --> 00:18:15.596 
Andreas

00:18:20.100 --> 00:18:20.934 
谢谢你 Jeff

00:18:21.869 --> 00:18:23.070 
大家早上好

00:18:23.604 --> 00:18:25.873 
今天我将向大家展示的是

00:18:25.939 --> 00:18:30.244 
当你的应用加载资源时
使用HTTP/2服务器推送的优势

00:18:39.219 --> 00:18:42.789 
你们看到的是一个应用非常普通的部分
你们很多人

00:18:43.056 --> 00:18:44.625 
可能已经实现过

00:18:44.691 --> 00:18:48.095 
或者在使用你们已有的应用时至少见过

00:18:48.729 --> 00:18:53.567 
你现在看到的可能是
一个针对摄影者的社交应用

00:18:53.634 --> 00:18:55.402 
可以展示最受欢迎的照片

00:18:55.669 --> 00:19:00.107 
可以为特定的摄影者
列出最受欢迎的图片

00:19:00.340 --> 00:19:02.142 
可以单独看照片

00:19:02.910 --> 00:19:04.044 
可以看下一张

00:19:04.845 --> 00:19:08.215 
可以看上一张 可以回到列表最顶端
选择另外一张进行浏览

00:19:09.049 --> 00:19:10.217 
等等

00:19:11.151 --> 00:19:14.154 
这个应用也可能是关于食谱的应用

00:19:14.221 --> 00:19:17.257 
或者音乐流的应用
在向我们展示专辑封面

00:19:17.324 --> 00:19:21.862 
这里有一个应用正在从服务器加载资源

00:19:23.363 --> 00:19:26.500 
假设它是在加载和展示一些图片

00:19:27.067 --> 00:19:30.604 
请注意的是出于演示原因
这里有一个开关

00:19:31.271 --> 00:19:33.907 
它允许我们在初始URL上

00:19:33.974 --> 00:19:37.244 
选择配置服务器推送
或者没有服务器推送

00:19:38.345 --> 00:19:42.316 
在这两种情况下
首先我们请求一个初始文档

00:19:42.816 --> 00:19:45.285 
里面包含有图片的URL以便加载

00:19:46.053 --> 00:19:47.688 
然后我们请求图片

00:19:48.388 --> 00:19:51.625 
如果没有使用服务器推送
什么都不会被推送

00:19:51.692 --> 00:19:53.227 
我们就需要发送请求

00:19:53.293 --> 00:19:55.729 
让每一个图片都通过网络传回来

00:19:56.763 --> 00:20:00.667 
在启用服务器推送的情况下
我现在就选择到这个模式

00:20:01.835 --> 00:20:04.037 
正如Jeff之前解释的

00:20:04.471 --> 00:20:09.576 
请求初始文档就会引发服务器推送资源

00:20:09.643 --> 00:20:12.145 
到你的应用程序里

00:20:13.113 --> 00:20:17.317 
这就不用通过网络
为每一个图片发送请求

00:20:17.417 --> 00:20:20.153 
数据任务请求的数据就会

00:20:20.220 --> 00:20:24.291 
从服务器推送存储中
直接传递到你的应用程序里

00:20:26.627 --> 00:20:31.098 
现在我们来对比下
服务器推送和无服务器推送的加载性能

00:20:31.632 --> 00:20:36.170 
我将会在初始URL上在有服务器推送

00:20:36.236 --> 00:20:37.504 
和无服务器推送之间转换

00:20:39.206 --> 00:20:40.507 
几次

00:20:42.309 --> 00:20:46.213 
这样你就可以看到
当服务器推送启用时

00:20:47.181 --> 00:20:50.517 
整个集合视图会加载的快一些

00:20:51.585 --> 00:20:54.788 
但是到底快多少？
好吧 让我来展示给你

00:20:55.589 --> 00:21:00.093 
现在示例应用程序
即将给我们呈现结果

00:21:00.394 --> 00:21:02.062 
这是当前视图的底部

00:21:02.362 --> 00:21:05.499 
红色的是无服务器推送的最快结果

00:21:06.166 --> 00:21:09.336 
绿色的是服务器推送的最快结果

00:21:11.338 --> 00:21:13.006 
让我多做几次

00:21:17.845 --> 00:21:19.780 
艺术家视图也是一样的

00:21:23.083 --> 00:21:25.619 
多做几次
服务器推送关闭 服务器推送开启

00:21:26.486 --> 00:21:31.458 
你会发现服务器推送的
加载速度至少快2倍

00:21:34.561 --> 00:21:38.031 
推送图片
大概快2到3倍

00:21:38.098 --> 00:21:41.268 
在高延迟的网络环境中

00:21:41.335 --> 00:21:42.836 
就像我们现在正在使用的

00:21:43.203 --> 00:21:45.305 
这样的网络是你的应用程序

00:21:45.372 --> 00:21:48.542 
在使用蜂窝数据或
很慢的Wi-Fi下可以碰到的

00:21:49.610 --> 00:21:51.678 
我准备了一个视频来展示

00:21:52.179 --> 00:21:56.450 
服务器推送和无服务器推送的比对

00:21:56.683 --> 00:21:58.352 
让我来展示给你

00:22:07.628 --> 00:22:12.666 
你能看见有服务器推送
用户已经在浏览图片了

00:22:12.733 --> 00:22:15.269 
另外一个人还在试图加载艺术家视图

00:22:18.705 --> 00:22:20.274 
让我们再看一遍

00:22:20.707 --> 00:22:25.612 
又一次 右边使用服务器推送的用户

00:22:25.679 --> 00:22:28.715 
比左边无服务器推送的用户进展快的多

00:22:36.323 --> 00:22:37.824 
要快2到3倍

00:22:38.258 --> 00:22:39.927 
试想下

00:22:40.093 --> 00:22:43.330 
想像下你能给你的用户
提供的用户体验

00:22:43.430 --> 00:22:47.134 
你只需在你的HTTP/2服务器上
配置服务器推送

00:22:47.501 --> 00:22:50.704 
你连程序中的一个代码都不用改

00:22:50.771 --> 00:22:52.873 
这太棒了
简直完美

00:22:53.006 --> 00:22:54.408 
这就是服务器推送的演示

00:22:54.508 --> 00:22:56.510 
非常感谢
会议愉快

00:22:56.677 --> 00:22:57.845 
好了 换回Jeff

00:23:04.151 --> 00:23:05.452 
好 谢谢Andreas

00:23:08.188 --> 00:23:10.591 
下面让我们总结下我们看到和讨论过的

00:23:10.657 --> 00:23:14.228 
关于HTTP/2和服务器推送的内容

00:23:15.395 --> 00:23:18.799 
仅NSURLSession API
支持服务器推送

00:23:18.866 --> 00:23:22.436 
所以若你在写新的应用或
还用NSURLConnection

00:23:22.970 --> 00:23:26.974 
我们强烈建议你马上改用
NSURLSession API

00:23:28.041 --> 00:23:32.279 
利用服务器推送不需要任何代码改动

00:23:32.346 --> 00:23:34.681 
不需要选择加入
直接就可以用

00:23:35.983 --> 00:23:39.987 
你的应用有了服务器推送
就能以最佳方式运行

00:23:40.120 --> 00:23:44.358 
让你的用户对你的应用程序
有甚至更好的用户体验

00:23:47.127 --> 00:23:50.364 
NSURLSession API
的另一个改进

00:23:50.430 --> 00:23:52.966 
是附加的Network Statistics

00:23:55.836 --> 00:23:58.906 
那么在场的谁喜欢统计？
有没搞统计的人？

00:23:58.972 --> 00:24:00.340 
有没热爱统计的人？

00:24:00.407 --> 00:24:02.576 
好了 我这儿有个统计给你
准备好了吗？

00:24:03.577 --> 00:24:04.478 
就是这个

00:24:06.914 --> 00:24:08.815 
好吧
刚才不好意思 抱歉

00:24:08.882 --> 00:24:11.652 
我们将要看些实际有用的统计

00:24:11.718 --> 00:24:16.423 
这个就是 我们相信网络统计就在
那2%有用的数据里

00:24:16.857 --> 00:24:19.092 
那么 它为什么有用？

00:24:19.159 --> 00:24:23.030 
你们的应用是否
碰到很差网络性能的时候

00:24:23.730 --> 00:24:24.765 
我猜有些人遇见过

00:24:24.831 --> 00:24:27.968 
你怎么做才能
发现到底哪儿出了问题？

00:24:28.368 --> 00:24:29.937 
你怎么调试？

00:24:30.671 --> 00:24:34.641 
我们相信网络统计对你们会很有用

00:24:34.741 --> 00:24:37.778 
当你在开发或调试环境下的时候

00:24:38.478 --> 00:24:41.615 
你能用这个收集信息
可能在实际运行时

00:24:41.682 --> 00:24:43.550 
可能你会最大限度利用
Test Flight

00:24:43.617 --> 00:24:46.653 
然后收集一些你的应用
在实际运行时的信息

00:24:47.688 --> 00:24:50.724 
Network Statistics是关于

00:24:50.791 --> 00:24:52.726 
你的应用中网络加载的性能分析

00:24:52.793 --> 00:24:56.463 
是关于找到并修复和网络相关的漏洞

00:24:56.763 --> 00:24:59.032 
也是关于让你更好理解

00:24:59.099 --> 00:25:02.603 
你的应用里的网络表现如何

00:25:04.371 --> 00:25:10.711 
目前 iOS  macOS和
tvOS平台支持网络统计

00:25:12.479 --> 00:25:15.716 
在我们开始看实际统计数据之前

00:25:15.782 --> 00:25:18.552 
让我来解释下
你怎样才能得到这些数据

00:25:18.619 --> 00:25:20.921 
要得到数据
我们需要看一些代码

00:25:22.456 --> 00:25:28.095 
在此我们有一个全新委托
叫DidFinishCollectingMetrics

00:25:28.362 --> 00:25:32.533 
这是NSURLSession Task Delegate
类的一个委托方法

00:25:32.966 --> 00:25:36.003 
当你实现这个委托时

00:25:36.103 --> 00:25:40.240 
它需要接收一个任务参数
被用来收集度量值

00:25:40.307 --> 00:25:45.312 
还要接收一个新的类对象
这就是NSURLSessionTaskMetrics

00:25:47.414 --> 00:25:52.319 
NSURLSessionTaskMetrics类
有一个属性叫taskInterval

00:25:53.520 --> 00:25:56.390 
这是一个时间间隔
从任务建立开始到

00:25:56.456 --> 00:25:58.525 
所有的统计数字刚被收集完成

00:25:58.592 --> 00:25:59.960 
马上就可以传送给

00:26:00.027 --> 00:26:02.963 
你的didFinish
CollectingMetrics委托为止

00:26:03.197 --> 00:26:06.600 
我在这里向你展示的另外一个属性
是redirectCount

00:26:06.934 --> 00:26:09.837 
这个很直接
如它的名字所示

00:26:09.903 --> 00:26:13.540 
这是HTTP重定向发生的次数

00:26:13.607 --> 00:26:16.276 
在任务执行期间

00:26:17.177 --> 00:26:18.612 
NSURLSessionTaskMetrics
的最后一个属性

00:26:19.980 --> 00:26:24.017 
叫transactionMetrics

00:26:24.451 --> 00:26:26.253 
这个属性才是核心

00:26:26.320 --> 00:26:28.422 
这是网络数据的灵魂

00:26:28.488 --> 00:26:33.994 
你可以从这里得到一个数组包含
NSURLTaskTransactionMetric对象

00:26:34.061 --> 00:26:37.598 
我们来仔细看下这个独特的新类因为

00:26:37.664 --> 00:26:40.601 
这才是非常有用的度量值所在的地方

00:26:42.402 --> 00:26:44.705 
为了更好的理解这些度量值

00:26:44.771 --> 00:26:47.474 
我们得把他们分割成4类

00:26:49.042 --> 00:26:52.880 
头两个NSURLTaskTransactionMetrics的属性

00:26:52.946 --> 00:26:54.314 
组成了第一类

00:26:54.381 --> 00:26:57.351 
我们把它称作请求和响应

00:26:58.652 --> 00:27:03.156 
这里有两个属性叫做请求和响应

00:27:03.624 --> 00:27:07.928 
它们允许你去分析我到底要的是什么

00:27:07.995 --> 00:27:12.799 
还有对原始问题的响应是什么

00:27:14.635 --> 00:27:19.006 
统计数据的第二类是关于协议和连接的

00:27:21.708 --> 00:27:24.144 
属性networkProtocolName

00:27:24.878 --> 00:27:28.448 
告诉你传输时用的是哪种类型的协议

00:27:28.515 --> 00:27:31.785 
和收集了的统计数据

00:27:31.852 --> 00:27:34.588 
这里是你可能看到的名字的列表

00:27:34.721 --> 00:27:37.824 
HTTP/1.1 HTTP/2
或者SPDY

00:27:37.891 --> 00:27:40.160 
注意这个列表可能而且也会
随时间而变化

00:27:41.094 --> 00:27:44.598 
你能接触到的另一个属性是
isProxyConnection

00:27:44.965 --> 00:27:48.168 
这个告诉你
事务是其中一部分

00:27:48.235 --> 00:27:52.439 
或者在数据采集期间有代理连接参与

00:27:52.940 --> 00:27:55.209 
或者统计数据被采集或收集了

00:27:57.311 --> 00:28:00.848 
isReusedConnection
这个属性会被设置为是

00:28:00.914 --> 00:28:05.219 
如果在资源获取的时候
使用的是持续连接

00:28:08.088 --> 00:28:11.058 
度量值的第三个分类只有一个属性

00:28:11.124 --> 00:28:15.562 
它处理的是资源加载或加载信息的信息

00:28:16.663 --> 00:28:19.633 
这个单一的属性叫
resourceFetchType

00:28:19.967 --> 00:28:22.669 
它告诉你的是一个资源如何被得到

00:28:22.736 --> 00:28:26.373 
你在这里可以看到网络加载的一些数据

00:28:26.440 --> 00:28:28.909 
它意味着资源是从网络进行加载的

00:28:28.976 --> 00:28:31.678 
或者通常所说的源加载

00:28:32.379 --> 00:28:34.081 
你可能会看见本地缓存

00:28:34.181 --> 00:28:36.450 
意味着资源是从本地缓存获取的

00:28:36.517 --> 00:28:37.985 
资源是在你应用程序本地保存

00:28:38.051 --> 00:28:40.854 
不需要网络事务参与

00:28:41.321 --> 00:28:42.623 
还有服务器推送

00:28:42.890 --> 00:28:47.561 
这个说明资源是从
服务器推送后的缓存里找到的

00:28:48.195 --> 00:28:49.730 
当你发送了相应的请求时

00:28:51.164 --> 00:28:53.300 
第四类事务

00:28:53.367 --> 00:28:56.470 
和连接的建立和传输有关

00:28:57.538 --> 00:28:59.540 
第一组度量值

00:28:59.606 --> 00:29:03.243 
测量的是网络连接建立所花的时间

00:29:04.745 --> 00:29:09.583 
第二组度量值测量的是
网络加载中和HTTP相关活动的时间

00:29:09.950 --> 00:29:11.652 
这些属性是时间戳

00:29:11.718 --> 00:29:15.122 
每有一个事件发生时被记录一次

00:29:15.189 --> 00:29:18.725 
让我们仔细看看
这些度量值和它们被收集的时间

00:29:18.792 --> 00:29:21.061 
在网络加载被执行的时候

00:29:22.329 --> 00:29:24.965 
要做这个
我们来看一个很简单的网络加载

00:29:25.032 --> 00:29:28.035 
值得注意的是这只是加载中
某一类的某一个模型

00:29:28.101 --> 00:29:31.905 
在网络加载时会有各种各样的活动发生

00:29:32.005 --> 00:29:34.708 
你有缓存查找
你有cookie查找

00:29:34.775 --> 00:29:38.312 
你要处理重定向
有时候还有请求认证

00:29:38.378 --> 00:29:41.481 
但是我们让它简单点
只要能达到我们的目的就行

00:29:42.649 --> 00:29:45.886 
NSURLTaskTransactionMetrics类

00:29:45.953 --> 00:29:50.023 
包含的属性中含有
在不同点的所有的这些时间戳

00:29:50.090 --> 00:29:51.725 
那么 我们先从

00:29:52.793 --> 00:29:54.061 
fetchStart开始

00:29:54.828 --> 00:29:58.565 
fetchStart是应用程序
开始请求资源时的时间

00:29:58.632 --> 00:30:01.268 
这个获取可以从本地缓存中实现

00:30:01.368 --> 00:30:03.971 
或者可能是源加载的资源

00:30:05.539 --> 00:30:07.774 
我们现在看的是
domainLookup

00:30:09.009 --> 00:30:11.144 
domainLookupStart
属性

00:30:11.211 --> 00:30:15.015 
这个是资源开始准备进行
名字查找的时间

00:30:15.082 --> 00:30:16.850 
这个是DNS查询

00:30:16.917 --> 00:30:19.820 
它把主机名转换成一个IP地址

00:30:20.020 --> 00:30:23.991 
所以domainLookupEnd
是查找完成的时间

00:30:24.091 --> 00:30:26.193 
一个IP地址会发送回给调用者

00:30:28.195 --> 00:30:29.496 
这里我们会看一下

00:30:29.563 --> 00:30:32.566 
连接建立时我们收集到什么样的度量值

00:30:33.567 --> 00:30:37.604 
connectStart属性
是应用准备运行

00:30:37.671 --> 00:30:41.208 
或者与远程服务器
建立TCP连接的时间

00:30:41.475 --> 00:30:43.143 
这个值可能是无效的

00:30:43.210 --> 00:30:45.512 
如果响应是从本地缓存中发现的

00:30:46.246 --> 00:30:48.849 
我马上会谈connectEnd属性

00:30:52.519 --> 00:30:56.924 
如果你用的是HTTPS
你需要一个TLS握手协议

00:30:56.990 --> 00:30:58.759 
我们得到了
一个相关的统计数据

00:30:59.126 --> 00:31:02.329 
secureConnectionStart度量值是

00:31:02.396 --> 00:31:05.465 
在应用程序准备开始安全握手

00:31:05.532 --> 00:31:09.236 
来保证当前连接的安全性的时间
secureConnectionEnd

00:31:09.303 --> 00:31:12.773 
是当安全握手完成时 它也计时完成

00:31:14.208 --> 00:31:16.476 
正如我提过的connectEnd

00:31:16.543 --> 00:31:18.679 
是当一个应用

00:31:18.745 --> 00:31:20.814 
刚刚和远程服务器建立起连接的时间

00:31:20.881 --> 00:31:23.917 
包括所有的安全相关的握手

00:31:24.151 --> 00:31:28.155 
这就是一个连接被认为建立完成的时候

00:31:29.923 --> 00:31:32.025 
现在我们有了一个建立完成的连接

00:31:32.092 --> 00:31:34.394 
我们实际上可以做一些HTTP

00:31:35.863 --> 00:31:38.065 
我们有一小部分可以收集的数据

00:31:38.131 --> 00:31:40.234 
是关于请求和响应的

00:31:40.300 --> 00:31:42.636 
首先我们有requestStart

00:31:42.703 --> 00:31:45.138 
这个是当应用开始请求资源的时间

00:31:45.205 --> 00:31:47.407 
不管有没有获取资源

00:31:47.474 --> 00:31:49.743 
从本地缓存也好从远程服务器也罢

00:31:50.043 --> 00:31:51.979 
如果需要一个源加载

00:31:52.312 --> 00:31:57.251 
这就是HTTP报头
准备传输第一个字节的时间

00:31:57.851 --> 00:32:02.890 
requestEnd是向
网络发送请求的最后一个字节完成时间

00:32:06.593 --> 00:32:08.061 
responseStart

00:32:08.428 --> 00:32:11.331 
这个代表服务器响应返回的第一个字节

00:32:11.398 --> 00:32:13.467 
被收到的时间

00:32:13.800 --> 00:32:14.968 
如果这是一个缓存加载

00:32:15.035 --> 00:32:19.072 
这就是从缓存收到缓存响应的时间

00:32:19.306 --> 00:32:22.843 
responseEnd
是当应用程序刚刚

00:32:22.910 --> 00:32:27.614 
收到请求资源的最后一个字节的时间

00:32:30.517 --> 00:32:34.588 
我们一直在看源加载过程中
收集到的数据

00:32:34.955 --> 00:32:37.658 
那就是 我们得通过物理网络
发送每一个字节

00:32:39.760 --> 00:32:42.496 
网络请求有可能

00:32:42.563 --> 00:32:44.164 
从本地缓存中得到
我也提过这点

00:32:44.231 --> 00:32:48.235 
如果一个本地缓存包含我们请求的响应

00:32:48.335 --> 00:32:49.736 
那就没有必要用DNS

00:32:49.803 --> 00:32:52.906 
也就是没必要建立TCP连接等等

00:32:53.273 --> 00:32:56.276 
在此缓存情况下
这些统计数据值会被设成无效

00:32:56.343 --> 00:32:59.146 
所以当你看这些统计数据时
请留意一下以上情况

00:33:00.581 --> 00:33:03.016 
那么 你有可能会问
“嗯 这个非常酷

00:33:03.784 --> 00:33:08.388 
但我如何在我的代码中使用它？”
想实现它 我们需要来看一些代码

00:33:10.057 --> 00:33:12.626 
就像我之前给你们讲过的
我们从委托入手

00:33:12.726 --> 00:33:17.364 
这里我有
NSURLSessionTaskDelegate的一个实现

00:33:17.698 --> 00:33:21.702 
它实现了新
didFinishCollectingMetrics

00:33:21.768 --> 00:33:22.970 
委托的回调函数

00:33:23.036 --> 00:33:24.137 
而我在此展示的这个

00:33:24.204 --> 00:33:26.874 
在此时其实什么用都没有

00:33:26.940 --> 00:33:30.077 
我完全能预料到你们会在这里
搞出一番名堂

00:33:30.143 --> 00:33:31.845 
有可能你会输出些日志

00:33:31.945 --> 00:33:33.213 
一个调试的好地方

00:33:33.280 --> 00:33:35.716 
可以看看你的网络出了什么状况

00:33:35.782 --> 00:33:38.652 
最大限度利用Test Flight
然后输出些日志

00:33:38.719 --> 00:33:42.222 
这样你就可以收集一些
在你应用程序实际运行时

00:33:42.289 --> 00:33:44.892 
网络性能如何的信息

00:33:45.659 --> 00:33:46.727 
这都取决于你

00:33:47.194 --> 00:33:50.030 
让我们回到这个例子上来

00:33:50.097 --> 00:33:52.499 
我们来做一些清理代码

00:33:52.599 --> 00:33:55.135 
第一件事 我们要对委托实现

00:33:55.202 --> 00:33:57.704 
实例化出一个对象

00:34:00.073 --> 00:34:02.209 
我们要新建一个默认的配置对象

00:34:02.276 --> 00:34:06.113 
我们想全部使用默认值只需要调用
defaultSessionConfiguration

00:34:07.548 --> 00:34:10.417 
下一步我们要新建一个实例

00:34:10.484 --> 00:34:13.587 
或者说我们要新建一个
NSOperatonQueue实例

00:34:13.887 --> 00:34:16.956 
我们不得不这么做是因为
我们需要有个地方 有个队列

00:34:17.190 --> 00:34:20.494 
这样我们的委托才能真正的开始工作

00:34:23.563 --> 00:34:25.666 
像我之前提到过的

00:34:25.899 --> 00:34:29.101 
我用配置对象
创建一个NSURLSession

00:34:29.168 --> 00:34:32.773 
但在此我将调用
NSURLSession的init函数

00:34:32.940 --> 00:34:34.541 
它可以接收额外的参数

00:34:34.608 --> 00:34:38.812 
也就是那些实例化的委托对象

00:34:38.879 --> 00:34:42.416 
和我们创建的NSOperationQueue对象

00:34:42.716 --> 00:34:44.418 
好了 现在我们可以干活了

00:34:45.886 --> 00:34:47.888 
我们用session创建一个任务

00:34:48.522 --> 00:34:50.757 
那我们需要我们的任务做些什么？

00:34:50.824 --> 00:34:53.694 
那就让它做个简单的加载
服务器根目录下的网页吧

00:34:54.027 --> 00:34:57.030 
在这我又一次调用了
dataTask方法

00:34:57.464 --> 00:35:01.068 
它要求一个闭包作为参数

00:35:01.802 --> 00:35:04.004 
注意下这个闭包

00:35:04.071 --> 00:35:07.441 
我们的didFinishCollectingMetrics
委托回调函数

00:35:07.508 --> 00:35:12.746 
会首先被调用而且在
闭包被调用之前

00:35:13.614 --> 00:35:14.448 
那么

00:35:15.716 --> 00:35:18.252 
噢 还有 别忘了
你的老朋友resume任务

00:35:18.318 --> 00:35:21.755 
你得确保你让那个任务恢复执行
这样工作才会真正的开始

00:35:21.822 --> 00:35:25.492 
下面是一个非常非常简短的复习
怎样实现

00:35:25.559 --> 00:35:30.664 
networkStatisticDelegate回调函数
和让它能正常工作的代码

00:35:30.764 --> 00:35:33.367 
我相信你们会去做很多更有意思的事情

00:35:33.433 --> 00:35:34.501 
会更富创造性

00:35:34.568 --> 00:35:37.704 
在你使用Network
Statistics的时候

00:35:39.773 --> 00:35:41.909 
我希望你们喜欢刚才看到的
关于Network Statistics的内容

00:35:41.975 --> 00:35:43.143 
你们感觉如何？

00:35:44.411 --> 00:35:45.245 
好了

00:35:47.648 --> 00:35:52.352 
现在你们可以接触到关于后台

00:35:52.419 --> 00:35:54.488 
网络传输中到底发生了什么的一些信息

00:35:55.055 --> 00:35:57.958 
这会在调试环境中帮你

00:35:58.792 --> 00:36:00.427 
找到漏洞并修复你的应用

00:36:00.494 --> 00:36:03.297 
让你的应用达到它们理想的工作状态

00:36:03.363 --> 00:36:07.668 
还有调整 真正的调整网页服务
和你在开发的应用的类型

00:36:07.734 --> 00:36:09.837 
这样它们可以以最佳的方式运行

00:36:10.971 --> 00:36:14.875 
再说一次 这个新功能在
NSURLSession API里已可用了

00:36:14.942 --> 00:36:18.045 
现在到了使用
NSURLSession的时候了

00:36:20.414 --> 00:36:22.416 
在最后一个环节

00:36:22.482 --> 00:36:25.085 
我会谈论一个
对每个人都至关重要的话题

00:36:25.552 --> 00:36:27.221 
作为一个开发者

00:36:27.354 --> 00:36:30.891 
我们都在意保护用户数据的隐私

00:36:31.458 --> 00:36:35.195 
NSURLSession API
有一些内置的非常好的功能

00:36:35.262 --> 00:36:39.066 
我想给大家分享一些
我们对这些功能作出的加强

00:36:40.334 --> 00:36:42.302 
传输层安全 简称TLS

00:36:42.369 --> 00:36:47.374 
是一个保护网络终端数据传输的协议

00:36:47.441 --> 00:36:51.445 
有时候你听到SSL
这是TLS的前辈

00:36:51.512 --> 00:36:54.815 
所以TLS和SSL
有时候会换着用

00:36:55.182 --> 00:36:58.986 
TLS利用cipher
来实现这个保护

00:36:59.052 --> 00:37:03.891 
cipher在一端把数据打乱
打乱的数据通过网络发送出去

00:37:03.991 --> 00:37:06.360 
接收端用一样的cipher

00:37:06.426 --> 00:37:09.663 
还原打乱的数据
这样它就可以被理解和使用

00:37:09.730 --> 00:37:12.733 
如果有人截获了这些数据

00:37:12.799 --> 00:37:14.735 
那只能是一大堆乱码

00:37:14.801 --> 00:37:16.737 
他们没办法使用
这样就保护了数据

00:37:17.604 --> 00:37:21.175 
有一点发生了变化
我希望提醒一下大家

00:37:21.241 --> 00:37:26.580 
那就是APPLE的平台
不再支持RC4 cipher

00:37:27.648 --> 00:37:32.019 
想要了解更多细节
我推荐你看一下

00:37:32.753 --> 00:37:35.789 
周二关于安全性的讲座

00:37:36.056 --> 00:37:37.824 
有机会的话加入他们的实验室

00:37:37.891 --> 00:37:40.861 
然后在那儿问些更细致的问题

00:37:41.228 --> 00:37:43.797 
这对你的应用程序意味着 尽管

00:37:43.864 --> 00:37:47.334 
你之前的连接是成功的

00:37:47.401 --> 00:37:49.903 
它有可能突然失败

00:37:49.970 --> 00:37:54.808 
这有可能是因为服务器
只支持RC4 cipher

00:37:55.142 --> 00:37:58.245 
我们有一个方法
你可以测试下这个理论

00:37:59.279 --> 00:38:02.883 
Mac OS有一个命令行工具
叫nscurl

00:38:03.317 --> 00:38:06.453 
可用来测和你的应用通讯的
只支持RC4 ciphers

00:38:06.520 --> 00:38:08.922 
的服务器

00:38:10.290 --> 00:38:15.796 
这里 我会用nscurl简单地
抓取服务器根目录的文档

00:38:15.929 --> 00:38:17.731 
如果我执行这个命令

00:38:18.365 --> 00:38:22.135 
哇！我看到了
HTTP加载失败

00:38:22.202 --> 00:38:24.738 
太搞笑了
我之前还能连上那个服务器

00:38:24.805 --> 00:38:28.375 
让我们来看看
我们关于RC4的理论到底成不成立

00:38:29.576 --> 00:38:34.348 
在这里我向nscurl添加了
一个标记叫enable-rc4

00:38:34.648 --> 00:38:37.851 
它的意思是
我会强制使用RC4

00:38:37.918 --> 00:38:40.821 
在连接的客户端这边
我接着执行这个

00:38:41.355 --> 00:38:43.257 
哇！
一下子就连上了

00:38:43.323 --> 00:38:46.793 
所以这个证明了
服务器只支持RC4

00:38:46.894 --> 00:38:49.630 
我要和服务器的管理员谈谈

00:38:49.730 --> 00:38:53.267 
怎样才能把
一些安全的cipher加进服务器

00:38:53.333 --> 00:38:57.037 
那样我们就能在
应用程序中保护用户数据

00:38:57.104 --> 00:38:58.939 
我希望你理解这点

00:38:59.006 --> 00:39:01.909 
我们的平台
不再支持RC4 cipher了

00:39:01.975 --> 00:39:04.845 
这可能会影响你的应用程序
所以请注意下

00:39:06.480 --> 00:39:09.850 
应用程序安全传输 简称ATS
这是一个非常棒的功能

00:39:09.917 --> 00:39:13.053 
它允许你为你的应用设置安全性策略

00:39:13.120 --> 00:39:15.656 
你指定密钥来同意授权

00:39:15.956 --> 00:39:18.358 
这些成为你应用程序的策略

00:39:18.425 --> 00:39:21.061 
我们向其中添加了两个新的密钥
我想和你们分享一下

00:39:21.628 --> 00:39:25.899 
第一个是
NSAllowsArbitraryLoadsInWebContent

00:39:25.999 --> 00:39:31.605 
如果你有一个WK网页视图
而且限定了范围只有那个类、

00:39:31.672 --> 00:39:34.374 
如果在你的应用程序中有那个类、

00:39:34.441 --> 00:39:37.477 
而且你把这个密钥呈现出来
那个对象就会被允许、

00:39:37.544 --> 00:39:40.214 
使用你指定的任何种形式的网络加载、

00:39:40.280 --> 00:39:43.417 
它会忽略你的应用中任何其它策略

00:39:43.584 --> 00:39:45.619 
只有在这个对象内适用

00:39:45.686 --> 00:39:50.457 
任何这个对象之外的加载
会遵循你的安全性策略

00:39:52.726 --> 00:39:57.598 
另外一个密钥
是NSRequiresCertificateTransparency

00:39:57.731 --> 00:40:00.601 
这个要求你的应用收到的证书

00:40:00.667 --> 00:40:05.305 
必须支持证书透明功能

00:40:05.606 --> 00:40:09.409 
证书透明
是签名证书的一个功能

00:40:09.610 --> 00:40:14.047 
它允许你使用一个更加有保障的证书

00:40:14.314 --> 00:40:15.983 
可以保障提供的证书是合法的

00:40:16.283 --> 00:40:19.286 
而且你可以相信终端提供给你的证书

00:40:20.020 --> 00:40:23.323 
更多关于那个主题的细节

00:40:23.390 --> 00:40:26.293  
我还是要推荐你去看一看
这些关于安全性的讲座

00:40:26.360 --> 00:40:31.031  
或者参加他们的实验室来了解
证书透明的更多细节

00:40:31.431 --> 00:40:34.968 
我谈过的所有内容都是关于
NSURLSession API的

00:40:35.135 --> 00:40:39.273 
我们也目睹了这个API
通过新增加的功能而进步

00:40:39.473 --> 00:40:40.908 
我们非常兴奋的想看到

00:40:40.974 --> 00:40:43.277 
你们会对你们的应用程序
做出怎样的调整

00:40:43.343 --> 00:40:45.879 
在你们利用某些新功能时

00:40:47.447 --> 00:40:51.251 
我介绍了对HTTP/2服务器
推送功能的支持

00:40:51.652 --> 00:40:55.088 
这意味着你们的应用
将可以运行的更良好

00:40:56.823 --> 00:40:59.026 
我介绍了Network Statistics

00:40:59.426 --> 00:41:02.529 
你就可以内省
你的应用程序的网络行为

00:41:02.596 --> 00:41:04.064 
这是前所未有的

00:41:04.364 --> 00:41:08.836 
这会提升你应用程序的
终端用户的用户体验

00:41:10.070 --> 00:41:13.473 
我还分享了ATS中
一些安全性相关的功能

00:41:13.540 --> 00:41:16.076 
和弃用RC4 cipher

00:41:16.243 --> 00:41:19.379 
你的应用现在可以实现
最佳的安全实践

00:41:19.446 --> 00:41:22.883 
来保证你用户数据的安全

00:41:24.251 --> 00:41:28.322 
我们希望你会在应用程序中
使用NSURLSession

00:41:28.622 --> 00:41:31.225 
不仅仅因为这些原因
也因为所有非常棒的功能

00:41:31.291 --> 00:41:33.627 
都内置于
NSURLSession API

00:41:35.362 --> 00:41:38.765 
如果你需要更多信息
这是今天讲座的URL链接

00:41:38.832 --> 00:41:41.702 
你可以回去回顾
我们今天谈到的一些内容

00:41:42.736 --> 00:41:46.507 
我们认为你可能会
感兴趣的一些和这个主题相关的讲座

00:41:46.573 --> 00:41:48.542 
我把它们在这儿给你列出来了

00:41:49.376 --> 00:41:50.611 
好的 就是这些
谢谢

00:41:50.677 --> 00:41:53.947 
希望你在余下的
WWDC 会议里过得愉快 谢谢