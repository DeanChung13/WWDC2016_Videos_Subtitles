00:00:24.324 --> 00:00:29.162 
下午好
欢迎来到2016全球开发者大会

00:00:30.764 --> 00:00:33.333 
自我们上次相聚 已有一年时间
且发生了不少事情

00:00:33.800 --> 00:00:37.638 
新出了tvOS
然后是四个Apple OS平台

00:00:37.704 --> 00:00:39.506 
其中很多
拥有其App Store

00:00:40.040 --> 00:00:43.610 
并且我们的所有平台都为其
自身的独特体验进行了优化

00:00:43.844 --> 00:00:47.581 
但他们共享了相当多的
通用技术和API

00:00:47.648 --> 00:00:50.984 
令你容易将你的应用带到
所有四个平台

00:00:51.285 --> 00:00:53.921 
通过同时衡量个体特性

00:00:55.155 --> 00:00:58.325 
我们的专家工具链
对于这四个平台是相同的

00:00:59.226 --> 00:01:01.762 
他们共享大部分的框架和库

00:01:02.262 --> 00:01:05.065 
还有基本的编程概念和语言

00:01:05.132 --> 00:01:06.266 
也是相同的

00:01:07.634 --> 00:01:11.505 
今天我们要宣布很多
新的API和技术

00:01:11.572 --> 00:01:13.540 
你将可以利用到的

00:01:13.740 --> 00:01:16.243 
你会找到更多的方式来表达你的观点

00:01:16.310 --> 00:01:19.479 
你甚至可以瞄准更多市场中的
更多用户

00:01:20.848 --> 00:01:24.685 
特别是我们的iOS X
对于开发者来说变化巨大

00:01:25.352 --> 00:01:28.922 
事实上 至少如果你看下
我们今早宣布的 iOS

00:01:28.989 --> 00:01:32.559 
你会发现我们开放了
iOS的整个用户体验

00:01:32.626 --> 00:01:35.696 
给开发者 涵盖了所有东西
从通知

00:01:35.762 --> 00:01:38.365 
到电话 信息 地图
甚至是Siri

00:01:40.200 --> 00:01:43.470 
一个重要的概念我们用来实现这个
那就是extension

00:01:43.537 --> 00:01:46.507 
并且你可能记得我们两年前
介绍了extension

00:01:46.707 --> 00:01:49.409 
其代表了一个日益重要的机制

00:01:49.476 --> 00:01:51.879 
因为他们允许你从应用中扩展开来

00:01:51.945 --> 00:01:54.548 
并参与到我们的系统功能性

00:01:55.215 --> 00:01:58.018 
它们允许你安全地定制我们的OS

00:01:58.085 --> 00:02:02.556 
通过运行短生命周期的沙盒服务
沙盒服务按需启动

00:02:04.525 --> 00:02:08.294 
我们发出的产品已支持很多
extension points

00:02:08.395 --> 00:02:10.197 
并且今年我们会添加更多

00:02:10.531 --> 00:02:13.800 
允许你更深入的连接到
我们的OS和应用

00:02:15.202 --> 00:02:18.839 
也许最令人兴奋的新extension point
就是创造iMessage App

00:02:19.039 --> 00:02:22.209 
我将交给Darin Adler
来给你讲述它的所有细节

00:02:29.316 --> 00:02:32.753 
新信息用起来非常好

00:02:32.819 --> 00:02:34.421 
并且我希望你们都会这样

00:02:34.555 --> 00:02:37.424 
iMessage App是你如何
变成它的一部分

00:02:38.759 --> 00:02:42.329  
现在 正如Andreas所提到的
iMessage App是extension

00:02:42.429 --> 00:02:44.231  
意味着它和其他extensions一样

00:02:44.298 --> 00:02:46.700  
你将其包含到App Store
里的应用上

00:02:47.467 --> 00:02:50.070  
但对于iMessage Apps
也有另一个选项

00:02:50.137 --> 00:02:52.339  
你可将它们包含到
iMessage App Store

00:02:52.406 --> 00:02:54.808  
也就是从信息里直接获取

00:02:54.875 --> 00:02:56.076  
看起来像这样

00:02:57.978 --> 00:03:04.284 
现在 当你通过iMessage
App发送交互信息

00:03:04.518 --> 00:03:09.356 
你会在上方角落
看到应用的图标

00:03:09.556 --> 00:03:11.124 
但甚至更重要的是

00:03:11.191 --> 00:03:13.794 
如果你发给交互信息的那个人

00:03:14.127 --> 00:03:15.495 
还没有这个应用

00:03:16.029 --> 00:03:18.966 
他们将得到这条链接上面写道
获取应用名称

00:03:19.333 --> 00:03:20.667 
如果你点击该链接

00:03:21.235 --> 00:03:23.470 
这会带着你获取或者购买这个应用

00:03:23.537 --> 00:03:27.174 
因此这是个令人惊异的方式来
令你的用户

00:03:27.241 --> 00:03:29.243 
传播你的应用 从一个人到另一个人

00:03:31.044 --> 00:03:33.814 
现在 如果你想创建一个便签应用
这真的很简单

00:03:33.881 --> 00:03:35.282 
根本不需要编写代码

00:03:35.349 --> 00:03:38.085 
你只需为应用的图标
准备好所有的图像素材

00:03:38.151 --> 00:03:39.586 
便签的图片素材

00:03:39.653 --> 00:03:43.657 
把他们放进Xcode建立 然后
提交到iTunes Connect

00:03:44.925 --> 00:03:48.228 
如果你想编写一个更为复杂的应用

00:03:48.295 --> 00:03:51.164 
并利用iMessage Apps
里的所有力量

00:03:51.398 --> 00:03:56.303 
你用Swift编程并使用UIKit
就像其他的extensions一样

00:03:56.470 --> 00:03:58.972 
还有一个新的Messages
extension point

00:03:59.806 --> 00:04:02.743 
这个Messages extension point中的类
给你访问权限

00:04:02.809 --> 00:04:05.078 
你需要一切
都在Messages App里

00:04:05.145 --> 00:04:08.482 
因此有一个对象代表
你发出的信息

00:04:08.549 --> 00:04:10.117 
有一个对象代表

00:04:10.184 --> 00:04:12.352 
此信息作为其中一部分的整个对话

00:04:12.419 --> 00:04:15.055 
甚至有一个对象代表
一个叫会话的东西

00:04:15.122 --> 00:04:17.089 
让你将信息汇集在一起

00:04:17.156 --> 00:04:21.461 
这是一个很好的方式来创建
协作性的iMessage Apps

00:04:22.563 --> 00:04:26.333  
现在 所有这些已完成
都没有妥协掉私密性

00:04:26.400 --> 00:04:28.035  
信息就是以此出名的

00:04:28.635 --> 00:04:32.706  
你的应用没有除当前对话外的
任何访问权限

00:04:32.773 --> 00:04:35.008  
应用之外正在发生什么

00:04:35.108 --> 00:04:38.345  
它甚至不需知道

00:04:38.412 --> 00:04:40.581  
谁参与了 你发送给谁

00:04:40.781 --> 00:04:43.483  
因为保持了私密性的完好无缺

00:04:45.686 --> 00:04:51.391 
现在适应性设计对于任何
iOS app开发都很重要

00:04:51.859 --> 00:04:54.528 
这对于iMessage Apps
甚至更加重要

00:04:54.595 --> 00:04:57.030 
那是因为信息运行在

00:04:57.097 --> 00:05:01.935 
所有种类尺寸形状不一的设备
和适应性

00:05:02.002 --> 00:05:04.872 
所以它运行在iPad上
它运行在iPhone上

00:05:04.938 --> 00:05:08.008 
它运行在iPad的
slide over里 竖直和水平

00:05:08.075 --> 00:05:10.711 
iMessage Apps也需要它

00:05:11.078 --> 00:05:13.547 
对于iMessage Apps
有额外考虑因素

00:05:13.614 --> 00:05:16.149 
就是当它们运行在
Compact Mode

00:05:16.216 --> 00:05:18.018 
底部键盘

00:05:18.085 --> 00:05:21.889 
并且你能在它们间滑动切换
或者你能调用相同的应用

00:05:21.955 --> 00:05:23.924 
并将其扩展到全尺寸

00:05:23.991 --> 00:05:26.326 
有时应用会完成这个操作
有时用户完成该操作

00:05:26.393 --> 00:05:30.063 
适应性设计对于这个体验也很重要

00:05:31.365 --> 00:05:34.701 
所有你所需开发iMessages
App的东西都可用了

00:05:34.768 --> 00:05:36.370 
因此你现在就能开始了

00:05:36.637 --> 00:05:39.439  
SDK有我谈论的所有东西

00:05:39.506 --> 00:05:41.742  
所有来自messages
extension point的东西

00:05:42.309 --> 00:05:46.246  
并且模拟器甚至有一个新的
特殊版本的信息

00:05:46.313 --> 00:05:47.514  
专门给开发者的

00:05:47.581 --> 00:05:50.918  
来让你看到对话的双方

00:05:50.984 --> 00:05:52.619  
并且试验你的
iMessage Apps

00:05:52.686 --> 00:05:54.588  
来看它们是如何发送和接收的

00:05:55.389 --> 00:06:01.361  
现在Adele Peterson将向你展示如何
将这些在iOS X中集合起来

00:06:07.768 --> 00:06:08.602 
谢谢 Darin

00:06:09.369 --> 00:06:13.440 
正如你今早所见 我们在迪斯尼的朋友
已经做了一些很棒的便签

00:06:13.507 --> 00:06:14.608 
我将向你展示他们是如何做到的

00:06:14.675 --> 00:06:16.977 
在Xcode中组合起一个便签应用

00:06:18.378 --> 00:06:21.949 
现在 这仅将花一分钟
因此即使我现在开始一个新的项目

00:06:22.015 --> 00:06:23.283 
其实我几乎都要完成了

00:06:23.550 --> 00:06:26.753 
通过选择便签包应用模板

00:06:27.020 --> 00:06:29.790 
我会给它一个好的名字像是
《星球大战》

00:06:31.158 --> 00:06:35.128 
保存它 且选择便签资源类别

00:06:35.662 --> 00:06:38.165 
现在 我想要便签有一个好的图标

00:06:38.232 --> 00:06:40.367 
当我在信息应用抽屉看他们时

00:06:40.434 --> 00:06:43.370 
我将从拖拽进我的图标开始

00:06:44.071 --> 00:06:47.441 
现在我可以选择我的便签包
并把便签拽入

00:06:49.042 --> 00:06:50.410 
好的 让我们试一下

00:06:51.478 --> 00:06:53.380 
信息现在模拟器中

00:06:53.447 --> 00:06:56.550 
对于你在iMessage Apps
中试用你的便签很容易

00:06:59.453 --> 00:07:05.092 
好的 让我们运行便签包
我喜欢这个8-bit的机器人

00:07:05.325 --> 00:07:07.060 
所以我可以试下发送一个

00:07:08.195 --> 00:07:10.464 
并且我甚至可以试验剥离

00:07:10.531 --> 00:07:12.733 
并且拖拽一个便签到另一个信息

00:07:14.134 --> 00:07:17.371 
看起来不错 如此轻松就做出一个
便签应用

00:07:25.379 --> 00:07:27.848 
现在看看iMessage Apps

00:07:28.515 --> 00:07:30.184 
我这有个冰淇淋应用

00:07:30.551 --> 00:07:32.786 
我女儿很喜欢这类的应用

00:07:32.853 --> 00:07:36.223 
可以让她设计和创造事物
现在我要做iMessage App

00:07:36.290 --> 00:07:38.992 
为她和她的朋友们制作冰淇淋便签

00:07:39.359 --> 00:07:43.397 
在Compact View中 你有
已经完成的冰淇淋便签

00:07:43.864 --> 00:07:48.068 
并且当我点击加号 应用扩展开
并显示冰淇淋创建UI

00:07:48.669 --> 00:07:51.271 
我将从选择一个筒身开始

00:07:52.639 --> 00:07:54.908 
我将会选择它并发送

00:07:55.576 --> 00:07:57.110 
现在模拟器显示

00:07:57.177 --> 00:07:59.980 
会话的发送方和接收方

00:08:00.314 --> 00:08:02.916 
所以你甚至不需要使用两台iOS设备

00:08:02.983 --> 00:08:04.351 
来测试你的iMessage App

00:08:04.751 --> 00:08:09.156 
在这个视图中 我实际是John Appleseed
并且我将会把筒身发送给Kate Bell

00:08:09.223 --> 00:08:11.391 
让我们从会话的另一方来看一下

00:08:12.526 --> 00:08:14.428 
在这里Kate已经收到了筒身

00:08:14.628 --> 00:08:16.897 
你可以点击此信息 启动app

00:08:17.397 --> 00:08:19.900 
添加一些冰淇淋球
并将其发回给John

00:08:21.168 --> 00:08:23.403 
然后在会话的另外一边

00:08:24.204 --> 00:08:25.405 
你接收到这个

00:08:25.472 --> 00:08:27.774 
你点击此信息 加上冰淇淋顶

00:08:29.343 --> 00:08:31.078 
并将其发回给Kate

00:08:32.246 --> 00:08:33.947 
现在 就如看起来的一样美味

00:08:34.014 --> 00:08:36.049 
我不想要我的整个会话

00:08:36.116 --> 00:08:38.751 
被这些半成品冰淇淋甜筒所占据

00:08:38.852 --> 00:08:42.722 
其实有个更为简洁的方法来创建这个
协同性的iMessage App

00:08:43.323 --> 00:08:46.093 
如果我为每一个信息
使用相同的MS会话

00:08:46.393 --> 00:08:49.096 
那么早前创建冰淇淋的步骤将被取代

00:08:49.162 --> 00:08:50.764 
通过紧凑简洁的描述

00:08:50.831 --> 00:08:54.101 
并且你将只会看到后者
也就是最新的冰淇淋信息

00:08:54.301 --> 00:08:57.471 
我将在Xcode里做出变化并向你
展示它看起来什么样

00:08:58.338 --> 00:09:03.076 
让我切换到冰淇淋项目
让我们看看

00:09:04.912 --> 00:09:08.482 
这里是我的部分代码
创建了MS message对象

00:09:08.549 --> 00:09:10.517 
我将会拖拽进

00:09:11.285 --> 00:09:12.986 
我将会拖拽进此代码

00:09:14.354 --> 00:09:17.925 
这段代码是看会话中有没有选定的信息

00:09:17.991 --> 00:09:19.493 
那是你点击该信息时所得到的

00:09:19.560 --> 00:09:21.361 
并且它全屏启动应用

00:09:21.628 --> 00:09:23.163 
因此如果有一个选定的信息

00:09:23.230 --> 00:09:25.566 
我们会使用该信息所关联的会话

00:09:25.632 --> 00:09:28.135 
我们会传入一个新的MS会话

00:09:28.535 --> 00:09:29.903 
让我们试一下

00:09:33.740 --> 00:09:38.212 
好的 现在我们再次启动这个应用

00:09:38.412 --> 00:09:43.984 
我们点击加号按钮 选择一个筒身
将它发送给Kate

00:09:45.819 --> 00:09:50.791 
加上一些冰淇淋顶 发回给John

00:09:52.926 --> 00:09:57.030 
然后将它完成 并发回给Kate

00:09:57.197 --> 00:09:59.299 
所以现在你能看到那些描述

00:09:59.366 --> 00:10:01.635 
描述此过程先前的步骤

00:10:01.702 --> 00:10:03.604 
并且你不再有半成品的冰淇淋了

00:10:03.704 --> 00:10:05.639 
在完成的产品的上面

00:10:06.006 --> 00:10:09.510 
这就是你能利用iMessage
Apps所能做的一些小尝试

00:10:09.810 --> 00:10:12.746 
接下来 Robby Walker
会跟你们谈谈Siri

00:10:17.651 --> 00:10:18.519 
谢谢你 Adele

00:10:20.320 --> 00:10:21.288 
五年前

00:10:21.822 --> 00:10:25.893 
我们发布了Siri
iPhone的智能助手

00:10:26.693 --> 00:10:30.731 
从那时起 Siri已经和人们交谈
几千亿次了

00:10:31.198 --> 00:10:35.135  
如今 Siri在五类设备上都可用

00:10:35.636 --> 00:10:37.871  
并且支持36种本地化语言

00:10:38.839 --> 00:10:42.509 
Siri也有很多新的特性和改进的
核心体验

00:10:43.010 --> 00:10:46.847 
一个很酷的例子 在iPhone 6s
和iPhone 6s Plus上

00:10:46.914 --> 00:10:49.983 
你可以立即开始和Siri说话
当你按Home键的时候

00:10:50.050 --> 00:10:52.219 
以几乎零毫秒的延迟

00:10:52.286 --> 00:10:55.656 
多亏了我们硬件和软件团队之间
令人惊奇的合作

00:10:55.923 --> 00:10:58.025 
但是当然 直到今天

00:10:58.091 --> 00:11:01.261 
有些很重要的东西一直缺失
那就是应用

00:11:01.328 --> 00:11:05.432  
所以我们非常兴奋地在
iOS上启用初版的SiriKit

00:11:13.307 --> 00:11:16.343  
我们相信对于人们的最佳体验就是
使用他们喜欢的应用

00:11:16.410 --> 00:11:17.978  
你们所有人已经创建的应用

00:11:18.178 --> 00:11:19.179  
有着SiriKit

00:11:19.246 --> 00:11:21.481  
人们现在将能够同这些应用进行交互

00:11:21.548 --> 00:11:23.250  
通过一个崭新的 谈话式的方式

00:11:23.784 --> 00:11:26.687  
我会谈谈如何让你的应用
与SiriKit一起工作

00:11:26.753 --> 00:11:29.156  
来提供一个很棒的 谈话式的体验

00:11:31.225 --> 00:11:33.827 
Siri所做的第一件事是
理解用户说了什么

00:11:33.894 --> 00:11:36.129 
采集音频并将它转换成文本

00:11:37.064 --> 00:11:38.932 
然后 Siri理解用户是什么意思

00:11:38.999 --> 00:11:42.135 
采集文本并将它转换成
我们称之为intent的东西

00:11:43.403 --> 00:11:46.406 
依据intent
Siri接下来采取行动

00:11:47.040 --> 00:11:49.476 
并且提供反馈 同时通过视觉和语音

00:11:50.444 --> 00:11:52.679 
你的应用将提供三样东西

00:11:52.880 --> 00:11:55.649 
第一个是帮助Siri进行理解的词汇

00:11:55.716 --> 00:11:58.385 
第二个是应用逻辑
你的核心功能

00:11:58.452 --> 00:12:00.854 
并且当然了 一个很棒的用户界面

00:12:01.588 --> 00:12:04.892  
现在 我们设计了SiriKit
以便Siri可以处理对话

00:12:04.958 --> 00:12:07.060  
并且你的应用处理功能

00:12:07.261 --> 00:12:10.864  
这么做最棒的是它意味着采用
SiriKit会难以置信的容易

00:12:10.931 --> 00:12:14.902  
并且你的用户们可以期待一个连续的
高质量的体验 它非常自然

00:12:14.968 --> 00:12:17.604  
感觉像是一个谈话而不是一个命令行

00:12:18.238 --> 00:12:19.373  
让我们深入一点

00:12:20.207 --> 00:12:22.676  
你的应用的一个角色是提供词汇

00:12:22.743 --> 00:12:25.546  
有两种 第一种是应用的词汇

00:12:25.712 --> 00:12:28.615  
这是面向你应用的任何用户
都应该知道的术语

00:12:28.682 --> 00:12:30.350  
像是UberX或Pinboard

00:12:30.751 --> 00:12:32.819  
另一种是用户词汇

00:12:33.153 --> 00:12:37.391  
这些术语对于你应用的个体用户来说
更详尽和重要

00:12:37.457 --> 00:12:40.160  
像是他们的联络人姓名
或是照片相册的名字

00:12:41.428 --> 00:12:44.198  
你的应用的主要角色是提供应用逻辑

00:12:44.264 --> 00:12:46.834  
它在三个重要时刻伴随
extension而来

00:12:47.267 --> 00:12:50.571 
第一个是帮助Siri理解
用户意图的参数

00:12:50.704 --> 00:12:53.707 
第二个是帮助Siri展示给用户
将会发生什么

00:12:53.774 --> 00:12:55.342 
如果当他们确认的时候

00:12:55.409 --> 00:12:58.545 
第三个 当然了 就是掌控此意图

00:12:58.612 --> 00:13:00.814  
来完成用户想完成的

00:13:01.815 --> 00:13:04.985  
并且在此会话中
Siri展现图像给用户

00:13:05.152 --> 00:13:08.021  
你可以选择性提供第二个
extension来配置这些

00:13:08.088 --> 00:13:09.957  
以便在使用Siri时 你的应用

00:13:10.023 --> 00:13:12.593  
仍然像是在其他地方用你的应用一样

00:13:13.527 --> 00:13:16.864 
让我们看一个 叫Hologram的
信息应用集成

00:13:17.130 --> 00:13:19.800 
Hologram是在遥远的银河系
发送信息类软件中

00:13:19.867 --> 00:13:21.535 
排名第一的应用

00:13:23.170 --> 00:13:24.872 
假设有人跟Siri说

00:13:25.305 --> 00:13:28.141 
“发一个hologram给
Obi-Wan 你是我唯一的希望”

00:13:29.510 --> 00:13:32.913 
现在 Siri的工作是提取音频并
将其转化为文本

00:13:33.247 --> 00:13:34.982 
但Siri需要你应用的帮助

00:13:35.749 --> 00:13:38.852 
Siri自己不知道Obi-wan
是一个重要的用户

00:13:38.919 --> 00:13:40.821 
还是你用户生活中一个重要的人

00:13:40.888 --> 00:13:43.290 
所以通过提供这部分的词汇给Siri

00:13:43.357 --> 00:13:45.859 
你可以确保Siri理解
你的用户说了什么

00:13:47.327 --> 00:13:50.297 
接下来 Siri会进行理解
用户正试图做什么

00:13:50.364 --> 00:13:52.633 
在这个案例中 是发送一个重要的信息

00:13:53.367 --> 00:13:55.502 
并且Siri也将试图理解参数

00:13:55.569 --> 00:13:57.471 
像是收件人和内容

00:13:58.872 --> 00:14:01.675 
Siri将所有这些信息打包成一个
结构化的对象

00:14:01.742 --> 00:14:03.577 
一个很好 简洁的对象

00:14:03.911 --> 00:14:06.079 
你的应用不需要担心数不胜数的方式

00:14:06.146 --> 00:14:08.448 
某人可能会表达同样的观点给Siri

00:14:08.515 --> 00:14:11.318 
它是不是不同的短语
或者多步骤的交互

00:14:11.385 --> 00:14:13.387 
那些都被搞定了
所有你需要操心的就是

00:14:13.453 --> 00:14:14.922 
这个相当简单的对象

00:14:16.356 --> 00:14:18.525 
然后SiriKit会把这个对象
传递给

00:14:18.592 --> 00:14:20.327 
extension
来帮助参数的解析

00:14:20.394 --> 00:14:23.530 
例如 可能你的app知道用户说
“Obi-Wan”

00:14:23.597 --> 00:14:25.899 
但其通常指
Old Ben Kenobi

00:14:26.066 --> 00:14:28.202 
你可以教SiriKit来更新
此intent

00:14:29.236 --> 00:14:30.470 
然后就是重要的时刻了

00:14:30.537 --> 00:14:32.840 
现在要实际处理用户的intent

00:14:32.906 --> 00:14:36.310 
SiriKit再次将这个对象传给
extension来进行处理

00:14:36.376 --> 00:14:38.045 
在这个例子中 你会发送信息

00:14:38.111 --> 00:14:39.146 
你会进入一个逃生舱

00:14:39.213 --> 00:14:41.114 
翻滚过沙丘 对付一些Jawa

00:14:41.181 --> 00:14:43.250 
你会为你的用户们完成这些

00:14:44.685 --> 00:14:46.453 
与此同时 Siri会提供

00:14:46.520 --> 00:14:49.456 
一个默认的用户界面给这个交互

00:14:49.523 --> 00:14:53.126 
如果你想 你也可以把你的应用体验
带进Siri

00:14:53.193 --> 00:14:55.429 
以便让你的用户们感觉更熟悉

00:14:56.563 --> 00:14:57.397 
就是这样

00:14:57.497 --> 00:14:59.600 
这就是你的应用必须得做的三件事

00:14:59.666 --> 00:15:01.835 
因为SiriKit会处理会话

00:15:02.769 --> 00:15:04.972 
处理这个会话实际上意味着很多

00:15:05.105 --> 00:15:06.240 
Siri行为不一

00:15:06.306 --> 00:15:09.176 
取决于某人是如何
开始和Siri谈话的

00:15:09.276 --> 00:15:12.279 
所以如果你拿着你的电话
按Home键

00:15:12.346 --> 00:15:13.514 
看着你的屏幕

00:15:13.580 --> 00:15:16.984 
Siri将会提供更多视觉反馈
减少大声说出来的东西

00:15:17.084 --> 00:15:20.120 
但若你说“Hey Siri”
或你在车里用CarPlay

00:15:20.187 --> 00:15:22.022 
那么Siri会展现更多东西

00:15:22.089 --> 00:15:24.591 
抱歉 是说更多而展现更少

00:15:26.260 --> 00:15:29.596 
SiriKit由extensions
和NSUserActivity所支持

00:15:29.963 --> 00:15:32.766 
这些相同的技术还支持了正在增加的
OS集成

00:15:32.833 --> 00:15:34.535 
本周你会听到更多关于它们的消息

00:15:36.136 --> 00:15:39.106 
今年 SiriKit会在六个领域
连接到应用

00:15:39.173 --> 00:15:41.308 
在每个领域中
会有多于一个的intent

00:15:41.375 --> 00:15:43.744 
来提供一个完整的 会话式的体验

00:15:43.810 --> 00:15:47.014 
例如 在Messaging里
你可以发送或者搜索信息

00:15:47.080 --> 00:15:50.017 
在支付里
你可以请求或者发送支付

00:15:51.151 --> 00:15:54.221 
并且SiriKit会对
所有Siri语言可用

00:15:54.454 --> 00:15:55.889 
这可是意义重大

00:15:55.956 --> 00:15:58.825 
当我之前说Siri会处理会话的时候

00:15:58.892 --> 00:16:01.728 
我实际的意思是Siri会处理会话

00:16:01.795 --> 00:16:03.630 
用所有36种本地化语言

00:16:03.697 --> 00:16:06.400 
所以你的应用不需要担心这些

00:16:15.108 --> 00:16:19.513 
我们非常兴奋想看到你们将会创建什么
其他我们认识的人也是

00:16:19.746 --> 00:16:21.815 
Siri 跟应用问好

00:16:23.717 --> 00:16:25.986 
我很快地跟它们成了朋友

00:16:27.387 --> 00:16:30.824 
籍此有请Chris
Lattnert谈下Swift

00:16:40.267 --> 00:16:41.101 
好的

00:16:41.168 --> 00:16:42.002 
谢谢 Robby

00:16:42.769 --> 00:16:44.638 
让我们看看Swift有什么新特性

00:16:44.905 --> 00:16:47.241 
很容易忘记我们推出了Swift

00:16:47.441 --> 00:16:50.077 
并在不到两年前发布了它

00:16:50.511 --> 00:16:51.678 
在这么短的时间内

00:16:51.745 --> 00:16:56.283 
你们已建立并提交逾
100,000个应用到Apps

00:16:56.750 --> 00:16:58.919 
包括这些响当当的应用

00:16:59.586 --> 00:17:03.090 
现在 Swift在企业中也同样流行

00:17:03.390 --> 00:17:04.625 
举个简单的例子

00:17:04.691 --> 00:17:08.628 
IBM已经开发和部署了
数以百计用Swift写的应用

00:17:10.030 --> 00:17:10.864 
现在

00:17:15.002 --> 00:17:17.137 
人们喜欢Swift有很多原因

00:17:17.204 --> 00:17:20.473 
其中一个就是
我们不到六个月前把它开源了

00:17:28.482 --> 00:17:29.783 
从那开始 它变成

00:17:29.850 --> 00:17:32.920 
GitHub上下载量第一的语言项目

00:17:33.487 --> 00:17:35.155 
观看量排名第一的

00:17:35.222 --> 00:17:38.625 
最喜爱排名第一的 并且它保持在前列

00:17:39.193 --> 00:17:41.562 
我想对我而言 比这更棒的是

00:17:41.628 --> 00:17:45.299 
我们有很多的新人参与到这个项目

00:17:45.432 --> 00:17:49.436 
我们现在有数以百计的新贡献者
通过开源参与

00:17:49.503 --> 00:17:51.772 
且我们已处理了
数以千计的投票请求

00:17:51.839 --> 00:17:53.774 
这反响真是很大

00:17:54.875 --> 00:17:57.978 
我们将Swift开源的一个原因是
对于我们很重要的是

00:17:58.045 --> 00:17:59.947 
我们想看到它到处都是

00:18:00.514 --> 00:18:03.617 
例如
我们认为Swift对于服务器很棒

00:18:03.851 --> 00:18:07.888 
所以我们把它迁移到Linux
社区认可了

00:18:08.655 --> 00:18:10.190 
在很短的时间内

00:18:10.257 --> 00:18:13.894 
他们已经开始将它带到其他流行的平台
像是FreeBSD

00:18:14.061 --> 00:18:16.096 
Android 甚至Windows

00:18:23.871 --> 00:18:26.240 
为了帮助Swift进入所有这些平台

00:18:26.306 --> 00:18:28.375 
我们启用了
Swift Package Manager

00:18:28.809 --> 00:18:32.412 
Package Manager是
一个很好的方式来建立 共享和重用

00:18:32.479 --> 00:18:34.147 
跨平台的package

00:18:34.748 --> 00:18:36.717 
它可以生成一个Xcode项目文件

00:18:36.783 --> 00:18:41.054 
甚至在像是Linux这样的平台上
本地化编译项目

00:18:42.055 --> 00:18:43.390 
另一个关于Swift开源很棒的事

00:18:43.457 --> 00:18:46.226 
是你能参与到语言的设计本身

00:18:46.493 --> 00:18:49.229 
Swift的进化一直是个很棒的体验

00:18:49.429 --> 00:18:50.931 
有着激烈的兴趣

00:18:50.998 --> 00:18:54.434 
在邮件列表上简直疯狂的邮件数

00:18:54.501 --> 00:18:55.669 
这太叫人吃惊了

00:18:56.803 --> 00:19:00.140 
现在 我发布了一个公开的路线图
包含了每次发布的更新

00:19:00.607 --> 00:19:04.478 
并且我们征求意见 讨论我们可能走的
不同方向

00:19:04.545 --> 00:19:06.813 
来共同向前推进语言的发展

00:19:07.514 --> 00:19:10.684 
然后我们像一个社区一样
一起公开讨论这些

00:19:10.884 --> 00:19:13.053 
我们将它们变成正式的提案

00:19:13.420 --> 00:19:17.457 
目前为止 我们已经有了超过
100个提案 来推进Swift发展

00:19:18.258 --> 00:19:19.726 
这仅仅是在六个月内

00:19:20.060 --> 00:19:23.864 
这是个很棒的标志来说明
Swift发展的多快

00:19:24.498 --> 00:19:27.267 
但是它也说明另一个重要和有趣的点

00:19:27.401 --> 00:19:28.769 
尽管它使用广泛

00:19:28.836 --> 00:19:31.638 
Swift仍然是个
相对较新的编程语言

00:19:32.139 --> 00:19:33.607 
现在 正如你所想的

00:19:33.907 --> 00:19:39.446 
我们选择快速发现Swift语言
中的问题并修复它们

00:19:39.646 --> 00:19:42.783 
因为我们不想永远被这些问题所困扰

00:19:43.483 --> 00:19:47.154 
我们正在开发Swift
将其作为下一代很棒的编程语言

00:19:47.221 --> 00:19:50.624 
所以我们想要
它对将到来的十年来说很好用

00:19:51.024 --> 00:19:53.193 
现在的问题是对于有些开发者

00:19:53.260 --> 00:19:55.696 
编程语言发生在深层的变化

00:19:55.762 --> 00:19:56.997 
可能会令你感到担忧

00:19:57.197 --> 00:20:00.033 
并且随着Swift来到新的平台

00:20:00.100 --> 00:20:02.569 
和Swift Playgrounds
带来的新类型用户

00:20:02.636 --> 00:20:04.771 
这会变成一个甚至更大的担忧

00:20:05.839 --> 00:20:08.976 
以此为背景
让我们看看Swift 3的新特性

00:20:10.711 --> 00:20:13.447 
我们在12月宣布了Swift 3

00:20:14.114 --> 00:20:16.917  
作为推出Swift开源的一部分

00:20:16.984 --> 00:20:19.353  
我们一直在完全开源地开发它

00:20:19.987 --> 00:20:23.357  
Swift 3的第一特性
和第一目标就是

00:20:23.423 --> 00:20:26.326  
克服这些早先成长期的痛处

00:20:26.393 --> 00:20:29.229  
并且将Swift转变成一个
稳定且成熟的平台

00:20:29.296 --> 00:20:32.666  
我们可以保持与语言未来版本的兼容性

00:20:34.101 --> 00:20:34.935  
不是吗

00:20:41.942 --> 00:20:45.012  
因此 我们在关注语言的核心要素

00:20:45.078 --> 00:20:48.348  
并使工具和开发体验非常棒

00:20:48.649 --> 00:20:51.385  
在Swift里
你有很多的方式可以看出来这个

00:20:51.785 --> 00:20:56.023 
给你举个简单的例子
对于Swift 2的一个常见抱怨是

00:20:56.089 --> 00:21:00.160 
一些Cocoa中的API
在Swift中感觉不是自然的

00:21:00.327 --> 00:21:04.097 
Swift喜欢清晰透明 且致力于
定义模板文件

00:21:04.631 --> 00:21:07.935 
在Swift 3中
Cocoa APIs有精致的感觉

00:21:08.035 --> 00:21:10.037 
你可以说他们完全Swift化了

00:21:11.171 --> 00:21:14.174 
我们是通过一些不同的初创完成的

00:21:14.441 --> 00:21:20.180 
首先 我们坐下来努力思考什么
造就一个很棒的Swift API

00:21:20.547 --> 00:21:24.117 
我们把它写成文档
并放在Swift.org上

00:21:25.219 --> 00:21:27.321 
然后我们采用那些规则

00:21:27.387 --> 00:21:29.790 
并把它们写到Swift的重编译器

00:21:29.857 --> 00:21:33.460 
所以它会自动把这些规则应用到
Objective-C API

00:21:33.527 --> 00:21:35.395 
把它们引入到Swift

00:21:36.230 --> 00:21:38.432 
但是Swift所做的远不止命名

00:21:38.498 --> 00:21:41.935 
命名是个相当困难的问题 不过
它做的远不止命名

00:21:42.536 --> 00:21:44.805 
举个简单的例子
若你看foundation

00:21:44.872 --> 00:21:47.708 
你会发现全新的Swift
本地化数据类型

00:21:48.809 --> 00:21:52.079 
Date就是一个例子
如果你比较Date和NSDate

00:21:52.145 --> 00:21:54.681 
你就会发现它提供了恰当的值语义

00:21:54.748 --> 00:21:57.150 
它有两倍快的速度去传值

00:21:57.551 --> 00:22:01.688 
由于减少了免于MalCon 的通信
拥有40倍快的速度去变化

00:22:09.396 --> 00:22:12.666 
现在 这些例子到处都是
随着Calendar变为了Calendar

00:22:12.733 --> 00:22:14.902 
Global Constant变成了
scoped enum

00:22:15.502 --> 00:22:18.438 
Date Components NSDate Components
变成了一个恰当的值类型

00:22:18.505 --> 00:22:20.741 
所有东西都感觉那么的快速和敏捷

00:22:21.108 --> 00:22:23.944 
如果你不看foundation

00:22:24.378 --> 00:22:27.915 
dispatch是另一个关键API
我们一直在用的

00:22:28.448 --> 00:22:31.151 
但是它提供的是低级别 C风格的接口

00:22:31.585 --> 00:22:34.288 
Swift 3中
Dispatch有一个重要的革新

00:22:34.354 --> 00:22:36.223 
有个漂亮的面向对象的API

00:22:44.498 --> 00:22:46.633 
并且它遵从所有最好的命名规范

00:22:46.700 --> 00:22:48.836 
从一个很棒的
Swift API期待的

00:22:49.336 --> 00:22:51.371 
Core Graphics
是另一例子

00:22:51.605 --> 00:22:54.842 
这里是Swift 3中典型的
core graphics代码

00:22:54.942 --> 00:22:58.478 
它精致 漂亮
并且就如你所期待的一样工作

00:23:04.251 --> 00:23:08.488 
现在Swift 3有很多很棒的特性
你能学足一周

00:23:09.022 --> 00:23:11.124  
Swift 3在Xcode 8中
可用

00:23:11.491 --> 00:23:14.294  
并且Xcode提供了一个
很好的迁移助手

00:23:14.361 --> 00:23:17.798  
来帮助迁移你的代码
从Swift 2到Swift 3

00:23:18.599 --> 00:23:22.336  
甚至更好的是 Xcode 8
也包含Swift 2.3

00:23:23.437 --> 00:23:25.806  
这意味着能迁移到Swift 3语法

00:23:25.873 --> 00:23:27.341  
当时机对你恰当的时候

00:23:34.014 --> 00:23:35.649  
这就是我今天要讲的全部

00:23:35.782 --> 00:23:38.385  
谢谢 我将交回给Andreas
谈谈下一个大事件

00:23:38.452 --> 00:23:39.319  
iPad上的Swift

00:23:44.925 --> 00:23:45.792 
谢谢你 Chris

00:23:47.861 --> 00:23:52.199  
Swift另一个让我们兴奋的方面是
它如此简单和易接近

00:23:52.266 --> 00:23:55.369  
它不仅对于开发应用和
服务器部件很棒

00:23:55.435 --> 00:23:58.338  
它作为第一个编程语言来学习也很棒

00:23:59.406 --> 00:24:02.309  
事实上 我们认为这超级重要
当我们设计Swift时

00:24:02.376 --> 00:24:04.211  
那也是个我们明确的目标

00:24:05.012 --> 00:24:08.148 
从Swift推出开始 我们介绍了
Xcode Playgrounds

00:24:08.215 --> 00:24:11.518 
一个交互的环境
你可以快速迭代你的代码

00:24:11.785 --> 00:24:15.322 
而且有经验的开发者
用我们的Xcode IDE很棒

00:24:15.722 --> 00:24:18.525 
我想要极度扩展我们的关注点
并包含kits

00:24:18.592 --> 00:24:20.827 
为初始学习如何编程的人

00:24:21.228 --> 00:24:24.798  
所以今天我们要宣布Swift Playgrounds
iPad的一个新app

00:24:24.865 --> 00:24:27.334  
你已经看了
今早keynote上的一个展示

00:24:27.868 --> 00:24:31.338 
它与Xcode技术匹配
但是它从底向上

00:24:31.405 --> 00:24:34.007 
为了学习和教授如何用Swift编程

00:24:34.174 --> 00:24:36.977 
它对于年轻观众既好玩又有参与感

00:24:37.144 --> 00:24:41.281 
并且它是个有趣的方式来尝试新的东西
对于有经验的开发者来说

00:24:42.449 --> 00:24:45.752 
它被设计成
利用iPad的触控界面工作

00:24:46.854 --> 00:24:48.422 
我们创建了一个
新的Smart Keyboard

00:24:48.488 --> 00:24:50.624 
为你的代码带来快速的键入提示

00:24:50.691 --> 00:24:52.793 
和Xcode中的代码自动完成类似

00:24:53.093 --> 00:24:54.862 
你经常能写完整段代码

00:24:54.928 --> 00:24:57.030 
而根本不用调出完全的键盘

00:24:58.365 --> 00:25:00.901 
当你编辑行中的值 比如数字和颜色时

00:25:00.968 --> 00:25:04.638 
我们弹出这些快速编辑控制
允许你轻松选择一个值

00:25:04.705 --> 00:25:07.174 
再次 不要调出完整的键盘

00:25:08.675 --> 00:25:10.444 
你可以在Playground里
快速修改代码

00:25:10.511 --> 00:25:14.214 
简单地在屏幕上用手指
拖拽这些结构化的元素

00:25:15.415 --> 00:25:18.185 
并且如你所期待的
有提前写好的代码片段的库

00:25:18.252 --> 00:25:20.487 
你可以简单点击就可以插入到你的代码

00:25:20.554 --> 00:25:22.656 
或者再次用手指拖拽它们

00:25:23.790 --> 00:25:26.627 
并且当有时候你调出完整键盘写代码时

00:25:26.693 --> 00:25:29.096 
我们展现给你一个专用的编程用键盘

00:25:29.162 --> 00:25:32.666 
对于访问许多特殊符号和数字超级容易

00:25:32.733 --> 00:25:37.137 
你用来写Swift代码的
就用一个手指滑动即可

00:25:37.371 --> 00:25:39.506 
不需要切换键盘布局

00:25:41.208 --> 00:25:44.311 
应用也带有很棒的课程内容

00:25:45.012 --> 00:25:47.080 
我们正在编写一个完整系列的课程

00:25:47.147 --> 00:25:49.783 
会一步一步向你介绍Swift编程

00:25:49.850 --> 00:25:51.885 
并且我们正计划快速扩展这一内容

00:25:51.952 --> 00:25:53.520 
对于明年的课程

00:25:54.354 --> 00:25:57.224 
但你可以提供给学习者一系列的挑战

00:25:57.291 --> 00:25:58.859 
他们将频繁更新的

00:25:58.926 --> 00:26:02.596 
所以他们会保持回到这个应用
并保持参与学习过程

00:26:02.663 --> 00:26:04.665 
对于这些有深度的主题

00:26:05.933 --> 00:26:09.570 
但是你不被限于跟从这个入门课程内容

00:26:09.636 --> 00:26:13.373 
你也有权利和灵活度
来探索你自己的编程

00:26:14.341 --> 00:26:16.009 
利用一系列的简单模板

00:26:16.076 --> 00:26:18.745 
我们创建了一个挺容易组成程序的

00:26:18.812 --> 00:26:20.514 
只带有文本的输入和输出

00:26:20.814 --> 00:26:24.351 
并且另一个允许你
探索和视觉化图像概念

00:26:24.418 --> 00:26:25.485 
基于形状

00:26:26.820 --> 00:26:30.357 
除此外
由于你在指尖拥有整个iOS SDK

00:26:30.657 --> 00:26:32.893 
自由创建任何
你喜欢的Playground

00:26:32.960 --> 00:26:35.229 
并且使用这个应用来教授许多主题

00:26:35.662 --> 00:26:38.131 
你甚至能控制机器人
像是屏幕上的这个

00:26:38.198 --> 00:26:40.434 
和其他的配件
从你的Playground

00:26:40.601 --> 00:26:42.069 
所以它将带来很多欢乐

00:26:42.135 --> 00:26:44.738 
为了向你更多展示你能如何操控应用

00:26:44.805 --> 00:26:47.174 
我会请Ken Orr来
给我们另一个演示

00:26:54.615 --> 00:26:56.183 
好的 谢谢 Andreas

00:26:57.050 --> 00:27:01.588 
Swift Playgrounds
令通过编程进行创新很容易

00:27:01.955 --> 00:27:04.491 
让我们看下我早前
创造的Playground

00:27:04.558 --> 00:27:06.193 
我会给你们展示我是什么意思

00:27:08.662 --> 00:27:11.398 
现在我从选择一个形状模板开始

00:27:11.465 --> 00:27:15.269 
你们能看到开始我的图片在右边

00:27:15.669 --> 00:27:20.107 
就是围绕中心旋转的
一些不同尺寸颜色的块

00:27:20.707 --> 00:27:26.413 
现在
所有右边的东西是我左边代码的产物

00:27:26.980 --> 00:27:30.617 
我代码的中心是这个for循环

00:27:30.918 --> 00:27:33.587 
在这里我创建了每个块

00:27:34.188 --> 00:27:37.724 
然后在顶部 我有个变量定义了

00:27:37.791 --> 00:27:39.860 
我应该创建多少个块

00:27:40.294 --> 00:27:43.797 
好的
现在被设成了15个 但是我想要

00:27:43.864 --> 00:27:47.367 
让整个右手边被颜色填充

00:27:47.701 --> 00:27:50.704 
为了实现这个
让我试试把这个调成80

00:27:51.605 --> 00:27:52.806 
然后我点击运行

00:27:54.274 --> 00:27:59.379 
好的 我也许不想用褐红色
想用个好看的蓝色

00:28:01.248 --> 00:28:02.082 
这看起来不错

00:28:02.583 --> 00:28:05.285 
我真的很喜欢这里的图案

00:28:05.352 --> 00:28:08.822 
螺旋进入画布中心的方块

00:28:08.889 --> 00:28:10.290 
这看起来真的很酷

00:28:10.891 --> 00:28:12.960 
我打赌我能把这做得更加明显

00:28:13.026 --> 00:28:17.364 
如果我随着时间的推移
更戏剧性地改变那些方块的大小

00:28:17.631 --> 00:28:22.569 
所以在for循环这里
我计算大小

00:28:22.636 --> 00:28:26.507 
我要去挖掘这两个不同
的表达式之间加分

00:28:27.074 --> 00:28:30.544 
而不是仅仅将它们放在一起
为什么不去我尝试乘法

00:28:31.578 --> 00:28:34.581 
运行 这看起来不错

00:28:35.082 --> 00:28:38.218 
所以 你就可以开始获得一个点子

00:28:38.285 --> 00:28:42.823 
使用touch代码探索和实践
是多么容易

00:28:43.857 --> 00:28:47.928 
所以接下来
我想将生活中的点滴带入图片

00:28:48.195 --> 00:28:49.930 
我将用一些动画

00:28:51.164 --> 00:28:55.602 
现在 为了做到这一点 我将使用
内置在了形状模板的API

00:28:56.470 --> 00:29:00.674 
我想我要的是
这个方块弹出来

00:29:01.175 --> 00:29:03.844 
并且停靠在流的中间

00:29:04.711 --> 00:29:08.482 
所以我要点击这里
在我创建每个方块以后

00:29:08.749 --> 00:29:11.785 
然后进入快捷工具条
接下来滚动

00:29:11.985 --> 00:29:14.054 
我要去点击动画功能

00:29:14.821 --> 00:29:18.258 
所以我有一个三秒长的动画

00:29:18.325 --> 00:29:22.896 
我会让它在开始前仅等待一秒

00:29:23.230 --> 00:29:26.767 
然后该块有内部的一切东西

00:29:26.834 --> 00:29:29.169 
它将代替我自动演示动画效果

00:29:29.803 --> 00:29:32.206 
所以我会拉动旋转

00:29:32.472 --> 00:29:36.543 
然后 我也想方块大小动画

00:29:36.677 --> 00:29:41.248 
所以我想我会在宽度和高度均为零开始

00:29:41.481 --> 00:29:45.419 
然后回到动画块
我将它设置为之前的参数

00:29:46.687 --> 00:29:51.792 
所以我说
square.size=size

00:29:52.359 --> 00:29:54.828 
然后 我已经计算上面的尺寸

00:29:54.895 --> 00:29:59.099 
我就用同一个变量 点击运行

00:30:01.368 --> 00:30:04.037 
很酷 它开始生动了

00:30:05.672 --> 00:30:06.507 
谢谢

00:30:10.811 --> 00:30:13.280 
我还想在此做一件事

00:30:13.514 --> 00:30:16.550 
对于触摸操控 我想补充一点

00:30:16.783 --> 00:30:20.654 
要做到这一点 我将使用一些
内置到了图形模板的API

00:30:21.522 --> 00:30:22.756 
底部这里

00:30:22.823 --> 00:30:26.994 
我其实已经在画布上添加了
一个拖动处理程序

00:30:27.361 --> 00:30:31.899 
块正等待我去填补它
而且我也在此写一个函数

00:30:32.032 --> 00:30:35.169 
它将使每个方块围绕画布中心

00:30:35.369 --> 00:30:38.772 
所以我只需要在此块调用该函数

00:30:39.139 --> 00:30:44.645 
因此 回到快捷方式栏
我说squares.rotateforTouches

00:30:45.546 --> 00:30:46.980 
然后我就点击运行

00:30:48.448 --> 00:30:51.518 
而现在我要用手指点击并按住右上角

00:30:51.585 --> 00:30:54.188 
并往下拉

00:30:54.721 --> 00:30:57.658 
就这样 我已经添加了触摸操控

00:30:59.259 --> 00:31:00.093 
谢谢

00:31:04.198 --> 00:31:07.467 
顺便说一句 到目前为止
你可能已注意到

00:31:07.534 --> 00:31:10.938 
对于任何这些 其实我还没用到全键盘

00:31:11.004 --> 00:31:12.506 
我认为这很酷

00:31:14.107 --> 00:31:17.244 
今天下午我还有另一个东西向大家展示

00:31:17.477 --> 00:31:22.182 
我是做UI的家伙 我喜欢
建立自定义的控制和俏皮的UI

00:31:22.549 --> 00:31:26.386 
我一直在四处摆弄
这个自定义颜色选择器

00:31:26.453 --> 00:31:27.688 
我很想向大家展示

00:31:28.889 --> 00:31:32.993 
当你点击颜色选择
会弹出一个颜色选择器

00:31:33.060 --> 00:31:35.562 
从你的手指下面
你可以拖动

00:31:35.629 --> 00:31:37.097 
并选择您想要的颜色

00:31:37.798 --> 00:31:41.935 
现在 所有将构建的代码在左边

00:31:42.436 --> 00:31:45.472 
因此 让我的代码变大
我们可以快速看下

00:31:46.173 --> 00:31:48.575 
现在 你首先会发现 最顶端

00:31:48.976 --> 00:31:54.248 
我导入的UIKit
我已能获取iOS的SDK

00:31:54.314 --> 00:31:58.352 
在这个Playground和
我创建的任何Playgrounds

00:31:59.186 --> 00:32:01.522 
然后一路下行
在底部

00:32:01.955 --> 00:32:05.459 
我告诉Swift Playground
获得我的视图

00:32:05.526 --> 00:32:07.895 
并显示在右侧

00:32:09.763 --> 00:32:13.267 
我想添加最后一样东西至
我的Playground

00:32:13.333 --> 00:32:16.637 
添加我可以设置颜色的东西

00:32:16.703 --> 00:32:18.805 
这样我可以尝试一下我的颜色选择器

00:32:19.740 --> 00:32:23.010 
我认为要做到这一点
我就添加了一个简单的UI图片浏览

00:32:23.143 --> 00:32:26.813 
让我调出编码键盘 我要说

00:32:26.980 --> 00:32:30.817 
“让图像视图

00:32:31.485 --> 00:32:34.955 
等于UI图像视图”

00:32:35.522 --> 00:32:38.258 
我会使用采用图像初始化

00:32:38.725 --> 00:32:42.429 
然后我就轻按在快捷栏的
第三项 即小图片

00:32:43.197 --> 00:32:44.565 
这是文字的图像

00:32:44.698 --> 00:32:48.035 
所以 当我在点击源代码 就可以选择

00:32:48.101 --> 00:32:50.838 
从已添加资源
到这个Playground

00:32:56.343 --> 00:32:57.978 
所以我提前加入了
Swift的logo（小鸟）元素

00:32:58.045 --> 00:32:59.379 
所以我会选择那个

00:33:01.181 --> 00:33:04.751 
我需在此做的最后一件事
我需要将你的

00:33:04.818 --> 00:33:08.555 
UI图像试图放进视图层次
所以我说

00:33:08.622 --> 00:33:15.629 
viewController.view.addSubview

00:33:16.897 --> 00:33:18.398 
折腾在图像视图

00:33:19.066 --> 00:33:22.369 
我们将运行 然后我将使视图全屏显示

00:33:23.103 --> 00:33:25.372 
而且知道我们可以看到我的图像

00:33:26.240 --> 00:33:27.508 
我已经有了颜色选择器

00:33:28.041 --> 00:33:30.777 
其实这一小小的其他功能让我有些困惑

00:33:30.978 --> 00:33:33.847 
我希望它有一点点乐趣
设置鸟的颜色

00:33:34.181 --> 00:33:36.283 
想通哎 为什么不那样做

00:33:43.257 --> 00:33:46.460 
这就是Swift Playgrounds
谢谢Andreas

00:33:51.832 --> 00:33:52.666 
谢谢你 Ken

00:33:57.504 --> 00:34:01.275 
所以你看到的 不管你创建
什么样的Playground

00:34:01.742 --> 00:34:05.913 
你总是通过利用
实际的iOS SDK做到这一点

00:34:05.979 --> 00:34:09.248 
包括让你访问
该设备的硬件API

00:34:09.516 --> 00:34:11.217 
并通过编写真正Swift代码

00:34:11.284 --> 00:34:14.188 
这也许是与其他学习应用
最大的区别

00:34:14.254 --> 00:34:17.491 
经常使用用户数量过快增长的有限方法

00:34:17.558 --> 00:34:21.094 
在Swift Playgrounds 你将学习
如何编写真正的SWIFT CODE

00:34:21.460 --> 00:34:22.462 
顺便提醒一下

00:34:22.529 --> 00:34:25.498 
Playgrounds应用本身
也是用Swift写的

00:34:32.406 --> 00:34:34.908 
Swift Playgrounds
为您提供了许多方法来试验

00:34:34.975 --> 00:34:37.043 
教授并学习如何编写代码

00:34:37.777 --> 00:34:40.581 
而我们尽可能让更多用户

00:34:40.647 --> 00:34:43.750 
尤其是孩子 对于利用这一新的机遇
充满激情

00:34:43.817 --> 00:34:45.786 
而事实上
我们希望你能帮助我们

00:34:46.219 --> 00:34:50.290 
通过创建其他内容
而创建整个学习平台

00:34:50.791 --> 00:34:51.859 
现在开始

00:34:51.925 --> 00:34:54.761 
我们正在制作Playground
文件格式的文档

00:34:54.828 --> 00:34:56.463 
今天在我们的网站
已经可以获得

00:34:56.964 --> 00:35:00.100 
而在今年晚些时候
我们计划发布学习资料

00:35:00.167 --> 00:35:02.236 
包括丰富的3D拼图

00:35:02.302 --> 00:35:06.340 
按照许可证 可以让您复制
和重复使用我们的材料

00:35:06.406 --> 00:35:07.808 
结合自己的想法

00:35:07.875 --> 00:35:10.577 
并帮助我们覆盖
世界各地的许多观众

00:35:13.013 --> 00:35:14.982  
一旦用户创造了Playground

00:35:15.148 --> 00:35:17.584  
有多种方式分享其成果

00:35:18.018 --> 00:35:20.020  
Playgrounds仅仅是文件
所以你可以分享

00:35:20.087 --> 00:35:22.089  
用你熟悉的常用的方式

00:35:22.155 --> 00:35:23.490 
而我们并没有就此止步

00:35:23.857 --> 00:35:26.493 
对于你的程序输出 拍照变得更容易

00:35:26.560 --> 00:35:30.264 
甚至纳入重播工具包
让您可以录制编码会话

00:35:30.330 --> 00:35:32.232 
并作为视频发布你的成果

00:35:33.333 --> 00:35:34.168  
并且对于

00:35:40.474 --> 00:35:41.642  
对于更高层次的学习者

00:35:41.708 --> 00:35:43.777  
iPad上的Swift Playgrounds

00:35:43.844 --> 00:35:46.480  
和Mac上的Xcode相得益彰

00:35:46.747 --> 00:35:49.449  
你可将Playgrounds来回
在两种环境间切换

00:35:49.516 --> 00:35:53.353  
最终过渡到在Xcode IDE
开发完整的应用

00:35:54.121 --> 00:35:56.323  
这很好地将我们带入下一个话题

00:35:59.693 --> 00:36:02.796 
更深入探讨Xcode
有请Matthew Furlich

00:36:08.836 --> 00:36:09.803 
谢谢Andreas

00:36:10.304 --> 00:36:13.240 
Xcode 8 是一个重大发布
可以谈的东西很多

00:36:13.307 --> 00:36:16.910  
让我们直入主题
从源码编辑器开始

00:36:17.511 --> 00:36:21.148  
此次发布 我们将重点放在
添加来自大家

00:36:21.215 --> 00:36:22.049  
最被要求的功能

00:36:23.250 --> 00:36:25.719 
我们开始添加活动行高亮

00:36:25.953 --> 00:36:27.988 
你可编辑该颜色

00:36:28.055 --> 00:36:30.023 
它会与任何编辑器主题完美融洽

00:36:34.328 --> 00:36:35.162 
变得更棒

00:36:36.930 --> 00:36:39.233 
我们也做了Swift的色彩文字支持

00:36:39.333 --> 00:36:42.402 
所以你现在可以在你的源代码中
查看并定义颜色

00:36:48.475 --> 00:36:49.409 
让我们进入第三点

00:36:49.476 --> 00:36:53.514 
我们还添加了Swift图像文字
所以你现可在源代码查看图像

00:36:55.716 --> 00:36:57.718 
作为代码完成的结果

00:36:59.052 --> 00:37:01.121 
并帮助你更好地编写文档

00:37:01.188 --> 00:37:02.856 
编辑器现在有一个命令

00:37:02.923 --> 00:37:05.659 
为记录你的API而生成标记

00:37:12.032 --> 00:37:14.668  
这些特性和多项可用性改进

00:37:14.735 --> 00:37:17.337  
真正让Xcode的编辑体验变得很棒

00:37:18.405 --> 00:37:21.108  
但我们并没有就此止步
我们已经增加了一个特性

00:37:21.175 --> 00:37:24.011  
它原来是你们的头号要求

00:37:25.345 --> 00:37:26.480  
应用程序扩展

00:37:34.087 --> 00:37:38.992  
Xcode 8中 我们正开放IDE
我们开始用源编辑

00:37:39.526 --> 00:37:41.662  
该扩展与活动编辑器一起运作

00:37:41.728 --> 00:37:44.331  
激活变革 选择中的改变

00:37:44.398 --> 00:37:46.066  
文件中导航

00:37:46.466 --> 00:37:48.769  
这开辟了诸多机会

00:37:48.836 --> 00:37:51.772  
对于命令 例如重新格式化 评论

00:37:51.839 --> 00:37:54.107  
本地化 甚至待办事项

00:37:54.808 --> 00:37:57.611  
现在 你可在每个extension
中实施许多操作

00:37:57.911 --> 00:38:00.981  
每个操作被列为编辑菜单的一部分

00:38:01.882 --> 00:38:04.451 
用户也可为这些操作设定按键

00:38:04.518 --> 00:38:06.553 
作为员工队伍的一部分
让他们工作

00:38:08.789 --> 00:38:10.891 
作为extension的开发者

00:38:15.495 --> 00:38:19.666 
你可以将它们通过App Store
加载或开发者ID部署

00:38:19.867 --> 00:38:21.702 
而这些Xcode
8上的extension

00:38:21.768 --> 00:38:24.204 
在Sierra和El
Capitan都运作

00:38:29.409 --> 00:38:32.412 
现在作为一个标准extension
用户也感到安全了

00:38:32.880 --> 00:38:34.948 
这些扩展作为一个单独进程运行

00:38:35.015 --> 00:38:37.150 
且自身签名通过验证

00:38:37.551 --> 00:38:39.119 
并进一步加强安全性

00:38:39.186 --> 00:38:42.322 
现在系统完整性保护
保证Xcode的安全

00:38:42.556 --> 00:38:45.325 
这意味着只有
受信任的库和扩展

00:38:45.392 --> 00:38:47.895 
可与IDE和你的代码交互

00:38:49.429 --> 00:38:52.699  
因此 新源编辑扩展是我们的第一步

00:38:52.766 --> 00:38:55.836  
致力于使Xcode变成
更可扩展的IDE

00:38:56.236 --> 00:39:00.073  
我们很想听听你们就此的反馈
以及想看到的其他extension

00:39:01.308 --> 00:39:04.778 
我们也一直致力于
改善您了解代码的方式

00:39:04.845 --> 00:39:08.282  
藉此 我们有全新API参照体验

00:39:10.083 --> 00:39:12.186  
我们已合并了API文档

00:39:12.252 --> 00:39:15.889  
将我们四个平台合并到单一统一的参照

00:39:16.857 --> 00:39:21.795  
现在 这个基准使导航变得容易
通过框架和符号运作

00:39:22.696 --> 00:39:26.867  
现在 搜索统一参照意味着
对于每个API 你看到单一结果

00:39:27.201 --> 00:39:28.969  
我们已经集成了同样的模糊匹配

00:39:29.036 --> 00:39:31.271  
我们用以快速代码完成和开放

00:39:32.873 --> 00:39:33.941  
浏览参照时

00:39:34.007 --> 00:39:37.711  
对于每个API
该平台可用性清楚地列出

00:39:38.512 --> 00:39:41.982 
而在以前的发布中 我们将这个
作为单独下载来加载

00:39:42.049 --> 00:39:43.217 
因为它的大小

00:39:43.483 --> 00:39:46.220 
在本发布中
我们已能够将其缩小为先前的十分之一

00:39:46.286 --> 00:39:49.122 
所以我们已默认将其包含在内

00:39:49.189 --> 00:39:51.525 
你总能获取你需要的信息

00:39:58.498 --> 00:40:01.602  
现在我们还在Interface Builder中
做了一些重大革新的改进

00:40:01.668 --> 00:40:03.871  
我想在演示中向你们展示

00:40:10.911 --> 00:40:14.414 
所以在这里我们有一个项目
我们称其为Trailblazer

00:40:14.481 --> 00:40:17.818 
它是共享你喜爱的健行步道
社交应用程序

00:40:18.719 --> 00:40:22.055 
除了你的界面布局方式

00:40:22.122 --> 00:40:24.124 
你会发现 Interface
Builder向你展示

00:40:24.191 --> 00:40:26.527 
它会呈现在设备上的方式

00:40:26.960 --> 00:40:28.929 
Interface Builder现可
向你展示视觉效果

00:40:28.996 --> 00:40:32.399 
例如画布上的活力 模糊 阴影

00:40:32.599 --> 00:40:36.170 
使设计和运行应用程序成为无缝体验

00:40:37.137 --> 00:40:39.072 
你还会注意到我们在设备纬度内

00:40:39.139 --> 00:40:40.841 
展示接口

00:40:41.108 --> 00:40:43.310 
并在底部有新配置

00:40:43.377 --> 00:40:44.845 
普通设备的尺寸

00:40:45.779 --> 00:40:48.782 
在此我们在iPhone 6s
Plus上看

00:40:49.349 --> 00:40:53.220 
我选择其他一项
就像让我点击iPad上的一项

00:40:53.287 --> 00:40:55.923 
我可以看到界面如何显示

00:41:03.263 --> 00:41:07.034 
你看 我们通过iPad上的两列
设计了自适应布局

00:41:08.402 --> 00:41:10.871 
要以其他方式查看它
我可以改变方向

00:41:10.938 --> 00:41:12.506 
如果我想横向进行查看

00:41:12.873 --> 00:41:14.942 
我还可以在自适应布局下查看

00:41:15.008 --> 00:41:17.377 
例如 让我们以三分之一大小来查看下

00:41:17.444 --> 00:41:20.247 
这是用于多任务的滑动

00:41:21.114 --> 00:41:22.616 
这很棒
因为它可以让我

00:41:22.683 --> 00:41:25.018 
为确保我实施了正确的界面

00:41:25.085 --> 00:41:27.955 
用户将以多种方式体验我的应用

00:41:29.256 --> 00:41:30.757 
我们还改进了经验

00:41:30.824 --> 00:41:34.027 
通过使用大小类创建自适应布局

00:41:34.094 --> 00:41:35.362 
具体来看一个例子

00:41:36.163 --> 00:41:39.800 
这个应用程序的设计者希望
在图像顶部放个按钮

00:41:39.867 --> 00:41:42.336 
在地图上覆盖显示健行步道

00:41:42.703 --> 00:41:46.373 
但因为地图的大小
他们只想在更广泛的显示器上做

00:41:46.907 --> 00:41:47.908 
这真的很容易

00:41:48.675 --> 00:41:51.745 
在配置栏中
我将点击Vary for Traits按钮

00:41:51.812 --> 00:41:53.981 
我将获得两个尺寸类选项

00:41:54.047 --> 00:41:55.249 
宽度和高度

00:41:55.983 --> 00:41:58.886 
iPhone和iPad上的
宽度尺寸类别不同

00:41:58.952 --> 00:42:00.220 
所以我会检查该选项

00:42:01.421 --> 00:42:03.524 
配置栏会变成蓝色 提醒我

00:42:03.590 --> 00:42:06.960 
我正在为特定尺寸类做自定义

00:42:07.461 --> 00:42:10.197 
但你也注意到设备的列表已经改变

00:42:10.264 --> 00:42:14.334 
我能看到那些将利用该定制的设备

00:42:14.868 --> 00:42:18.539 
在这里 我看到各种iPad
预览方向和适应

00:42:19.106 --> 00:42:22.843 
最后一个项目
iPhone 6s Plus的横向预览

00:42:23.477 --> 00:42:27.614 
该设备和预览方向使用常规宽度尺寸类

00:42:27.681 --> 00:42:30.017 
这是重要的信息 因为现在我可以确保

00:42:30.083 --> 00:42:32.719 
我将为设备设计正确的界面

00:42:33.554 --> 00:42:37.357 
我们的界面将很好看
所以让我们继续做这些改变

00:42:38.158 --> 00:42:40.727 
我将去到库中 拿出一个按钮

00:42:40.794 --> 00:42:42.329 
并将其拖到界面

00:42:43.297 --> 00:42:46.166 
如果你的手不那么汗湿
你可以拿住按钮

00:42:47.868 --> 00:42:48.702 
来吧

00:42:53.173 --> 00:42:54.541 
各位 一秒内不许看

00:43:00.080 --> 00:43:01.815 
一秒后 这将不再有趣

00:43:14.161 --> 00:43:14.995 
好了

00:43:24.271 --> 00:43:26.540 
这不应该赢得最响亮的掌声
好的

00:43:27.608 --> 00:43:31.144 
让我们继续
我将在此处删除标题

00:43:31.211 --> 00:43:33.547 
我们继续
为它设置图像

00:43:33.614 --> 00:43:35.949 
我们将把它做成这个漂亮的罗盘图标

00:43:36.083 --> 00:43:37.918 
而我们只需把它放在正确位置

00:43:38.151 --> 00:43:40.854 
现在 我将稍后连接这个按钮

00:43:40.921 --> 00:43:43.423 
但确保得到了我们想要的界面

00:43:43.724 --> 00:43:45.759 
我将在配置栏中点击完成

00:43:45.959 --> 00:43:49.563 
我们将横向切换回
iPhone 6S Plus

00:43:49.630 --> 00:43:50.664 
我们的按钮出现了

00:43:51.131 --> 00:43:54.034 
当我切换到纵向预览 这不

00:43:54.101 --> 00:43:56.203 
而这正是我想要的界面

00:43:56.370 --> 00:44:00.207 
Interface Builder
现使得设计自适应布局变得很容易

00:44:01.375 --> 00:44:05.512 
在配置栏中将会显示
iOS和watchOS设备

00:44:06.013 --> 00:44:08.248 
还显示了tvOS一些有用的选项

00:44:08.949 --> 00:44:11.652 
我将谈到应用程序的tvOS版本

00:44:11.718 --> 00:44:14.321 
你会看到在配置栏中
现在向你显示的选项

00:44:14.388 --> 00:44:17.991 
对于亮界面和暗界面

00:44:18.458 --> 00:44:20.360 
我甚至可以在此进行自定义

00:44:20.427 --> 00:44:23.697 
例如 让我们添加罗盘图标的特化

00:44:23.764 --> 00:44:26.266 
暗模式 使其弹出效果更好一点

00:44:27.901 --> 00:44:30.938 
我想给你看Interface
Builder的另一特性

00:44:31.939 --> 00:44:34.641 
你会看到tvOS Storyboard缩小

00:44:34.708 --> 00:44:36.910 
所以它覆盖整个画布

00:44:37.611 --> 00:44:41.615 
Interface Builder
现支持任意缩放级别的画布操作

00:44:49.389 --> 00:44:51.258 
因此 无论你想放大

00:44:51.325 --> 00:44:53.026 
获得完美像素比对

00:44:53.360 --> 00:44:55.996 
或者你想要缩小回来
在Overview模式上运作

00:44:56.296 --> 00:44:57.130 
你可以做到这一切

00:45:02.936 --> 00:45:05.172 
这就是我们给Interface
Builder配备的新特性

00:45:14.648 --> 00:45:15.482 
谢谢

00:45:15.816 --> 00:45:19.653 
设计Interface Builder
现在感觉就像直接在设备上工作

00:45:19.720 --> 00:45:23.390 
编辑任何缩放级别
意味着你不再受制于

00:45:23.457 --> 00:45:25.759 
设备的大小

00:45:27.961 --> 00:45:31.331  
在此发布中
我们还专注于工具的辅助性

00:45:31.398 --> 00:45:34.368  
我们尤其已让
Interface Builder

00:45:34.434 --> 00:45:35.669  
与语音辅助程序Voiceover
一起协调运作

00:45:36.103 --> 00:45:38.639  
我们也完全改写
AppleScript字典

00:45:38.705 --> 00:45:42.109  
使得Xcode更容易
融合于桌面自动化

00:45:48.482 --> 00:45:51.518 
现在 在每次发布中 我们增加了寻找

00:45:51.585 --> 00:45:53.754 
诊断和修复问题的额外技术支持

00:45:54.021 --> 00:45:56.990  
藉于Xcode 8
我们正跨出另一大步

00:45:58.125 --> 00:46:01.662  
在过去的一年 我们增加了
100多个新的诊断方法

00:46:01.728 --> 00:46:03.730  
提供了极大的洞察力
当你构建

00:46:03.797 --> 00:46:05.999  
以及当你编辑代码碰到实时问题

00:46:07.000 --> 00:46:08.836  
我们已添加了三个新的静态分析器

00:46:08.902 --> 00:46:12.105  
用于本地化 延展性和释放

00:46:12.172 --> 00:46:15.175  
所有常用的可能在应用程序中
引起问题的模式

00:46:16.276 --> 00:46:18.912  
我们继续投资测试系统

00:46:18.979 --> 00:46:22.683  
提高稳定性 性能
并增加一些新的选项

00:46:24.618 --> 00:46:28.322  
现在Xcode将捕获和显示崩溃日志

00:46:28.388 --> 00:46:29.957  
在你的测试期间发生

00:46:35.729 --> 00:46:37.798 
这很棒 因为你可以运行测试

00:46:37.865 --> 00:46:40.334 
收集这些日志 比如崩溃日志

00:46:40.400 --> 00:46:43.470 
你可以直接用调试器来查看诊断问题

00:46:44.438 --> 00:46:48.909 
我们还用一新选项来增强xcodebuild
联编以运行预建测试

00:46:54.648 --> 00:46:55.482  
哇哦 确实如此

00:46:55.549 --> 00:46:58.552  
这意味着这对合成
可扩展测试而言是完美的

00:46:58.619 --> 00:47:00.521  
与自己的持续合成

00:47:02.656 --> 00:47:05.092 
Xcode比以往任何时候都
更会帮助解决问题

00:47:05.158 --> 00:47:08.195 
当你构建 分析和测试自己的应用

00:47:08.595 --> 00:47:09.496 
但通常情况下

00:47:09.563 --> 00:47:13.233 
一些最有趣的 若非
我们说的毒辣问题

00:47:13.300 --> 00:47:15.169 
当你运行代码时发生

00:47:15.536 --> 00:47:19.206  
为此 我们推出了新的东西
叫做Runtime Issues

00:47:24.578 --> 00:47:26.180 
Runtime Issues与
其他应用一样

00:47:26.246 --> 00:47:28.448 
会在活动视图提醒你

00:47:28.515 --> 00:47:31.285 
你会在问题导航关看到详细信息

00:47:31.685 --> 00:47:34.188  
我们已在顶部添加了一个切换
以使其醒目

00:47:34.988 --> 00:47:37.925  
现在 有三种运行问题

00:47:37.991 --> 00:47:40.294  
UI 线程和存储器

00:47:40.894 --> 00:47:41.995  
让我们先从UI开始

00:47:43.330 --> 00:47:45.399  
视图调试器已是一个很棒的工具

00:47:45.465 --> 00:47:49.369  
用于你的界面可视化以及问题诊断

00:47:50.137 --> 00:47:52.873  
除了改进的准确度和视觉呈现

00:47:52.940 --> 00:47:56.376  
视图调试器现将在运行时检测布局问题

00:47:58.846 --> 00:48:00.547 
每次捕获 视图调试器

00:48:00.614 --> 00:48:03.951 
能够检测到含糊的布局视图

00:48:04.218 --> 00:48:07.154 
而这些是由于遗漏和错误
配置的限制而造成的

00:48:12.593 --> 00:48:14.595 
这些问题在导航器里浮现出来

00:48:14.661 --> 00:48:17.731 
检测将提供详细信息
帮助你解决这些问题

00:48:19.166 --> 00:48:22.102  
现在 线程问题往往难以预测

00:48:22.169 --> 00:48:25.606  
且可能难以调试
可能出现问题的原因很多

00:48:25.672 --> 00:48:29.243 
比如 从错误的线程或数据争用解锁

00:48:30.043 --> 00:48:32.479 
为了帮助你跟踪这类问题

00:48:32.546 --> 00:48:35.749 
我们正把Thread Sanitizer整合到Xcode 8中

00:48:36.817 --> 00:48:38.252  
当你的应用启动时

00:48:38.318 --> 00:48:42.122  
Thread Sanitizer检测常见线程问题

00:48:42.189 --> 00:48:44.258  
并将其作为运行问题呈现

00:48:45.025 --> 00:48:47.494  
你可在这些问题出现时
中断Xcode

00:48:47.561 --> 00:48:48.929  
或者你可以收集全部

00:48:48.996 --> 00:48:50.664  
在会话结束时审查

00:48:51.298 --> 00:48:54.468  
和综合报告提供了这些问题的具体细节

00:48:54.535 --> 00:48:56.837  
给你提供任何争用条件的详细信息

00:48:56.904 --> 00:48:59.273  
并提供栈帧来帮助你导航

00:49:00.807 --> 00:49:01.875  
像——是的

00:49:07.147 --> 00:49:12.019  
现在 像线程 内存问题
往往难以确定和修复

00:49:12.386 --> 00:49:13.754  
想要有效地进行调试

00:49:13.820 --> 00:49:16.456  
通常你得查看对象图

00:49:16.523 --> 00:49:20.561  
看看它们是如何相互关联的
这就是我们建立的东西

00:49:22.329 --> 00:49:26.133 
Xcode 8的新特征是工具条
提供了一个内存调试器

00:49:26.433 --> 00:49:29.636 
这将帮助你可视化和导航运行应用时的

00:49:29.703 --> 00:49:31.205 
对象图

00:49:45.085 --> 00:49:48.088 
你是否会更喜欢它
如果我告诉你 它会自动查找泄漏呢？

00:49:54.862 --> 00:49:57.998 
这是调试内存问题一个很棒的新工具

00:49:58.065 --> 00:49:59.867 
我想在演示中向你们展示

00:50:05.672 --> 00:50:08.208 
好了 在此我们有
Trailblazer应用

00:50:08.275 --> 00:50:10.277 
我要在模拟器中启动它

00:50:11.044 --> 00:50:12.379 
我之前在调试

00:50:12.446 --> 00:50:14.615 
我想看一下之前注意到的内存问题

00:50:15.315 --> 00:50:17.885 
当我们正在做这的同时
我将弹出内存报告

00:50:17.951 --> 00:50:19.486 
我会点击步道

00:50:19.686 --> 00:50:21.188 
你会看到内存峰值

00:50:21.255 --> 00:50:23.056 
没关系 我早调查过了

00:50:23.123 --> 00:50:25.592 
这还只是加载所有资源的步道

00:50:26.360 --> 00:50:28.996 
我注意到
当我点击每个评论

00:50:29.062 --> 00:50:30.330 
我们的内存峰值

00:50:31.131 --> 00:50:32.999 
我们不恢复内存

00:50:33.066 --> 00:50:36.436 
即使我们一路回到应用程序的起点

00:50:37.371 --> 00:50:39.606 
这预示存储器管理问题

00:50:39.673 --> 00:50:42.442 
我们可以使用内存调试器进行调查

00:50:43.343 --> 00:50:45.913 
我将点击工具栏中的内存调试器按钮

00:50:46.113 --> 00:50:49.650 
当我们暂停你的应用时
我们捕捉到对象图

00:50:50.617 --> 00:50:52.252 
调试导航现在向我显示

00:50:52.319 --> 00:50:54.888 
在我的应用程序中分配到的所有对象

00:50:54.955 --> 00:50:57.991 
有我创建的和系统创建的

00:50:59.226 --> 00:51:02.229 
我可以将其过滤
只显示我的项目中的相关条目

00:51:02.930 --> 00:51:06.934 
我还可以输入字符串
或地址来查找特定对象

00:51:07.568 --> 00:51:08.969 
我已经输入了“控制器”

00:51:09.036 --> 00:51:12.506 
我有评论视图控制器的三个实例

00:51:12.906 --> 00:51:14.141 
这令我感到诧异

00:51:14.808 --> 00:51:16.510 
当我选择它们中的任何一个

00:51:16.577 --> 00:51:19.012 
我们会看到该对象图表在右边显示

00:51:19.713 --> 00:51:23.350 
现在 你看到的都是该对象的参照路径

00:51:23.417 --> 00:51:25.319 
存在内存里

00:51:26.887 --> 00:51:30.290 
我在此看到的其中一个对象
是Swift捕获环境

00:51:30.424 --> 00:51:32.459 
这是代码中我的视图控制器的某处

00:51:32.526 --> 00:51:36.563 
已被捕获闭包的一部分
这是开始查看的一个好地方

00:51:37.698 --> 00:51:40.133 
我将用检查查看更多的细节

00:51:40.200 --> 00:51:42.302 
其中一个细节是回溯追踪

00:51:42.369 --> 00:51:44.238 
至捕获发生的地点

00:51:44.805 --> 00:51:47.274 
当然 我可以直接点击导航

00:51:47.341 --> 00:51:49.042 
至导致它的那一行代码

00:51:57.751 --> 00:51:59.286 
我看到问题的根源

00:51:59.353 --> 00:52:01.622 
我已经为这个视图控制器
建立了一个观察器

00:52:01.688 --> 00:52:03.557 
被告知评级何时发生变化

00:52:03.857 --> 00:52:06.159 
此API返回的观察令牌

00:52:06.226 --> 00:52:09.596 
当视图消失 我已妥善上下清理

00:52:09.963 --> 00:52:11.999 
但我从来没有保留它

00:52:12.266 --> 00:52:14.368 
这是一个常见和易犯的错误

00:52:14.434 --> 00:52:18.272 
也是内存调试器容易找到和修复的错误

00:52:19.606 --> 00:52:22.676 
现在 我之前提到的
内存调试还能发现泄漏

00:52:22.743 --> 00:52:25.679 
并且它提醒了我在活动视图有三个泄漏

00:52:26.280 --> 00:52:28.749 
我会点击那个
将被带到问题导航

00:52:28.815 --> 00:52:31.084 
在那里我看到泄漏的三种类型对象

00:52:31.418 --> 00:52:34.488 
阵列 用户评论和用户对象

00:52:35.355 --> 00:52:37.791 
我要点击任一评论
抱歉 点击用户

00:52:37.858 --> 00:52:40.060 
现在我们看到的是参照周期

00:52:40.727 --> 00:52:43.030 
用户有书面评论的数组

00:52:43.096 --> 00:52:46.533 
每一个用户评论都有一个
参照返回给该用户

00:52:47.167 --> 00:52:50.904 
如果所有参照都强行持有
这将泄漏遍布这些对象

00:52:51.905 --> 00:52:54.374 
现在 它看起来像是我一致泄漏它们

00:52:54.508 --> 00:52:57.144 
如果我想获取这些对象
中任何一个的详细信息

00:52:57.211 --> 00:53:00.614 
我可以使用上下文菜单
在控制台打印出来

00:53:00.681 --> 00:53:03.183 
或只是弹出一个快速浏览
看看更多的细节

00:53:04.985 --> 00:53:07.020 
在这种情况下 审查用户关系

00:53:07.087 --> 00:53:11.024 
是我要进行调查的
正如代码一样导航

00:53:11.091 --> 00:53:12.459 
我命令式点击一下就可以了

00:53:12.526 --> 00:53:15.495 
就将被带到产生参照源的代码行

00:53:15.662 --> 00:53:18.232 
果然 我忘了声明它是弱的

00:53:19.066 --> 00:53:21.535 
就这样
内存调试器能够告诉我

00:53:21.602 --> 00:53:23.437 
我有的泄漏 以及帮我解决这些问题

00:53:32.279 --> 00:53:34.448 
这是Xcode 8的新内存调试器

00:53:36.283 --> 00:53:39.453  
今天我还有一个其他类型的问题想谈谈

00:53:39.686 --> 00:53:41.255  
这与配置有关

00:53:46.894 --> 00:53:50.397 
没有什么更令人沮丧的
当你在做项目时

00:53:51.331 --> 00:53:53.200 
代码签名出了问题

00:53:55.102 --> 00:53:57.070 
其实 这并不完全真实

00:53:57.137 --> 00:53:59.373 
因为在一些情况下 解决方案

00:53:59.439 --> 00:54:01.608 
比问题本身更令人沮丧

00:54:08.949 --> 00:54:10.384 
因此 我们在Xcode 8中
解决了这个问题

00:54:10.450 --> 00:54:12.953 
我们已经完全重建了配置系统

00:54:19.326 --> 00:54:23.030 
我们开始通过创建更快
更强大的新签名行动

00:54:23.096 --> 00:54:25.365 
并考虑到新Xcode
的工作流而建立

00:54:25.766 --> 00:54:28.468 
我们构建了新的用户界面元素
以清晰地想你展示

00:54:28.535 --> 00:54:31.138 
概况 团队和你正使用的证书

00:54:31.205 --> 00:54:33.240 
并明确告诉你所有问题

00:54:33.640 --> 00:54:37.511 
我们完善了信息
以确保其始终包括可操作的信息

00:54:37.578 --> 00:54:40.881 
同时我们也确保生成请求日志

00:54:40.948 --> 00:54:43.784 
其结果是将所发生的任何事透明化

00:54:45.118 --> 00:54:46.486 
基此 我们有一个强大基础

00:54:46.553 --> 00:54:49.423 
以供建立两个新配置工作流

00:54:50.324 --> 00:54:52.993  
Xcode 8具有自动
代码签名的选项

00:54:53.493 --> 00:54:56.964  
有了这个代码签名选项
Xcode处理了所有的细节

00:54:57.030 --> 00:54:58.832  
通过专用信息

00:54:58.899 --> 00:55:02.369  
而此信息与你创建或管理的
任何其他信息无关

00:55:03.237 --> 00:55:05.239  
我们将应对所有签名请求

00:55:05.305 --> 00:55:08.208  
添加权利和再生新项

00:55:09.276 --> 00:55:12.546  
对于你希望对签名设置
有更多控制的情况下

00:55:12.679 --> 00:55:16.183  
您可以禁用此选项
并使用自定义代码签名

00:55:21.221 --> 00:55:23.123  
有了这个 你可以指定

00:55:23.190 --> 00:55:26.059  
你想使用的确切的签名资源

00:55:26.493 --> 00:55:29.530  
并且你可以在每个生成配置中指定

00:55:29.596 --> 00:55:32.699  
这是一个很好的选择
当你有各种各样的签名需要

00:55:37.638 --> 00:55:40.674  
自定义代码签名仍然利用了新基础

00:55:40.741 --> 00:55:43.977  
对于任何问题
给你很好的反馈和帮助

00:55:45.112 --> 00:55:47.648  
我们还想关注配置的另一点

00:55:47.714 --> 00:55:49.583  
就是开发证书

00:55:50.050 --> 00:55:53.020  
使用多台机器工作时
为了使开发更容易

00:55:53.086 --> 00:55:56.557  
Xcode现支持多个开发证书

00:56:01.728 --> 00:56:05.365 
这意味着当你得到一台新Mac
你只需要添加Apple ID即可

00:56:05.432 --> 00:56:07.835 
你不再需要取消或分享证书

00:56:07.901 --> 00:56:09.536 
从你的其他开发

00:56:16.643 --> 00:56:20.080 
所以新的授权系统
自动并且定制登录

00:56:20.147 --> 00:56:22.015 
并且复制开发许可

00:56:22.082 --> 00:56:25.085  
Xcode 8总是使得授权变得容易

00:56:25.152 --> 00:56:26.854  
并且给你你需要的控制

00:56:28.589 --> 00:56:30.891  
在这个版本里
我们把注意力集中在性能上

00:56:30.958 --> 00:56:32.926  
而且我们达到了一些
了不起的成就

00:56:33.560 --> 00:56:36.396  
和我们一年前发布的版本相比

00:56:36.463 --> 00:56:38.966  
你会发现Xcode的启动速度
提高了2倍

00:56:39.032 --> 00:56:42.269  
测试的索引速度甚至提高了50倍

00:56:48.509 --> 00:56:53.113 
所有的这些使得Xcode 8变得
更快更好用

00:56:54.248 --> 00:56:58.318 
这是你将在Xcode 8里找到
特性和提升的一部分

00:56:58.719 --> 00:57:01.755  
请在这周来实验室让我们知道
您的想法

00:57:02.389 --> 00:57:04.658  
接下来 邀请
Sebastien Marineau-Mes

00:57:04.725 --> 00:57:08.595  
他将会和你们分享一些
令人兴奋的新平台技术

00:57:08.762 --> 00:57:09.897 
Sebastien

00:57:11.532 --> 00:57:12.533 
谢谢Matthew

00:57:13.934 --> 00:57:14.768 
谢谢

00:57:15.335 --> 00:57:18.672 
让我介绍一些关键的
根本的技术的更新

00:57:18.739 --> 00:57:20.807 
我会从压缩开始

00:57:21.441 --> 00:57:24.611  
如果你们记得 去年我们介绍了
lzfse

00:57:24.678 --> 00:57:26.446  
作为我们主流的压缩算法

00:57:26.513 --> 00:57:30.517  
比zlib算法快3倍
并且能量消耗少一半以上

00:57:30.584 --> 00:57:34.154  
这真是一个引人注目的技术
并且获得了广泛的使用

00:57:34.888 --> 00:57:39.826 
现在我们宣布 我们要开源
lzfse 并且

00:57:41.628 --> 00:57:42.462 
现在你知道了

00:57:43.830 --> 00:57:46.900 
我们相信这会鼓励lzfse
获得更多的使用

00:57:46.967 --> 00:57:51.205 
特别是多平台以及离线压缩
这些使用案例中

00:57:51.805 --> 00:57:54.408 
接下来 我想要讨论网络

00:57:55.509 --> 00:57:59.246  
现在,我们知道一些
应用的性能

00:57:59.313 --> 00:58:01.949  
取决于拥有一个好的网络连接

00:58:02.015 --> 00:58:03.417  
但是如今的网络

00:58:03.483 --> 00:58:06.854  
没有好的办法给最重要的
通信优先级

00:58:07.054 --> 00:58:11.625 
比如说 人们在工作时下载
YouTube上的猫的视频

00:58:11.692 --> 00:58:14.494 
会影响你真正重要的视频会议

00:58:14.828 --> 00:58:18.699 
所以我们和思科合作
给网络加入智能

00:58:18.765 --> 00:58:23.170 
现在网络能够识别被信任的设备

00:58:23.470 --> 00:58:27.674 
识别对你的工作最重要的应用

00:58:28.041 --> 00:58:32.613 
然后优先让这些通信在网络终端
间传输

00:58:32.679 --> 00:58:34.581 
这将提供更好的性能

00:58:34.648 --> 00:58:37.351 
给那些对你最重要的应用

00:58:38.051 --> 00:58:40.254 
这就是网络部分
接下来

00:58:44.224 --> 00:58:46.693  
接下来 请我们讨论记录

00:58:47.160 --> 00:58:50.030  
如今 记录是你们所有人都
使用的一项技术

00:58:50.097 --> 00:58:53.767  
在开发 调试及现场诊断中

00:58:54.368 --> 00:58:57.137  
在传统中 记录是碎片化的

00:58:57.204 --> 00:58:59.740 
你们有很多人使用你们自己的
方案

00:59:00.174 --> 00:59:03.010 
这个平台已有的方案通常很慢

00:59:03.310 --> 00:59:06.647 
所以今年我们重新思考了记录

00:59:06.980 --> 00:59:10.250 
并用我们提出一个我们认为
很吸引人的技术

00:59:10.417 --> 00:59:12.886 
它是统一的并且非常快

00:59:12.953 --> 00:59:15.822 
它在硬盘上记录的数据很紧凑

00:59:16.056 --> 00:59:18.725 
它还给你足够的灵活性来支持

00:59:18.792 --> 00:59:22.529 
跨应用 守护进程 系统服务
的记录

00:59:22.863 --> 00:59:25.265 
它有内存内追踪的概念

00:59:25.332 --> 00:59:28.635 
你可以捕捉频繁的记录信息

00:59:28.702 --> 00:59:30.537 
只保存它们在硬盘中

00:59:30.604 --> 00:59:33.307 
当你的应用有错误时

00:59:33.807 --> 00:59:36.343 
最后 我们也加入了隐私

00:59:36.610 --> 00:59:39.646 
所以在开发时你可以捕捉非常
多的记录信息

00:59:39.713 --> 00:59:41.882 
并且使它们被自动编辑

00:59:41.949 --> 00:59:44.651 
当你向最终用户发布你的应用时

00:59:45.919 --> 00:59:47.087 
现在 和这个一起

00:59:49.022 --> 00:59:53.493 
我们重写了控制台应用
它有了更多的功能

00:59:53.560 --> 00:59:56.063 
比如说 它能够直播流媒体

00:59:56.129 --> 00:59:59.600 
通过开发设备
高级过滤的能力

00:59:59.666 --> 01:00:02.569 
等级系统的内省能力

01:00:02.669 --> 01:00:04.605 
这就是新的记录系统

01:00:06.039 --> 01:00:06.940  
接下来

01:00:09.576 --> 01:00:11.979 
接下来 我们来说说文件系统

01:00:13.046 --> 01:00:13.881 
好的

01:00:16.216 --> 01:00:21.188 
当然 如今HFS+是Mac上的主流
文件系统

01:00:21.255 --> 01:00:24.024 
它是1998年发布的

01:00:24.625 --> 01:00:27.961  
如今它被部署到所有的Apple
产品

01:00:28.028 --> 01:00:30.264  
超过10亿台设备

01:00:30.697 --> 01:00:35.102  
当然 HFS+是18年前设计的

01:00:35.369 --> 01:00:38.672  
我认为它证明了当初的设计相当
优秀

01:00:38.739 --> 01:00:41.074  
它在今天仍然是一个优秀的文件
系统

01:00:41.141 --> 01:00:44.511  
但是 在它设计的时候 Mac上
还有软驱

01:00:44.578 --> 01:00:50.384  
我们认为现在可能是我们
开始一个新的文件系统的时候

01:00:50.450 --> 01:00:54.421  
所以今天我们要宣布一个全新的
Apple File System

01:00:59.459 --> 01:01:00.294 
这就是它

01:01:01.695 --> 01:01:05.132 
我认为你们会为此感到兴奋

01:01:05.199 --> 01:01:09.570  
Apple File System
从我们最小的设备Watch扩展到

01:01:09.636 --> 01:01:12.940  
高端的拥有很大的存储配置的
Mac Pro

01:01:13.473 --> 01:01:16.143 
它还是现代的
我们设计它首先

01:01:16.210 --> 01:01:19.847 
针对当今以及未来的存储技术
闪存和SSD

01:01:19.913 --> 01:01:21.048 
它是有弹性的

01:01:21.114 --> 01:01:25.953 
并且我们利用这个机会来统一
iOS和Mac OS上的加密

01:01:26.019 --> 01:01:28.589 
使我们在未来有良好的灵活性

01:01:29.356 --> 01:01:32.292 
Apple File System
有很多新的独特特性

01:01:32.359 --> 01:01:34.461 
我想要重点展示其中的两个

01:01:34.995 --> 01:01:38.198 
第一个是克隆
为什么要克隆？

01:01:38.532 --> 01:01:41.401 
如果你看看一个运行了一段时间
的系统

01:01:41.468 --> 01:01:43.804 
你会发现很多同样的重复文件

01:01:43.871 --> 01:01:45.973 
到处复制是人的天性

01:01:46.039 --> 01:01:49.510 
这当然不高效
这会浪费存储空间

01:01:49.910 --> 01:01:54.414 
但是有了克隆 你可以复制文件
只需要使用初始存储空间

01:01:54.548 --> 01:01:56.416 
当文件被修改时

01:01:56.650 --> 01:02:01.221 
这很快并且你可以克隆
文件 目录 目录结构

01:02:02.289 --> 01:02:05.559 
第二个我想要强调的特性是快照

01:02:05.626 --> 01:02:06.927 
什么是快照？

01:02:07.160 --> 01:02:10.797 
他们是文件系统在一个时间点的
内容的镜像

01:02:11.231 --> 01:02:12.566 
为什么你们需要它？

01:02:12.633 --> 01:02:15.335 
好吧 假设你在开发一个备份
应用

01:02:15.502 --> 01:02:17.704 
使用快照 你可以备份

01:02:17.771 --> 01:02:20.674 
文件系统在一个时间点的
统一的视图

01:02:21.241 --> 01:02:24.978 
另一个这很有用的好的例子是
在教室

01:02:25.379 --> 01:02:27.247 
你可能会为学生准备一台设备

01:02:27.314 --> 01:02:30.517 
包括内容 配置文件 应用等等

01:02:30.584 --> 01:02:32.052 
在上课时使用

01:02:32.352 --> 01:02:34.621 
学生使用设备时

01:02:34.821 --> 01:02:37.724 
他们可能会修改内容或设置

01:02:37.791 --> 01:02:40.527 
你可以在课程结束时使用快照

01:02:40.761 --> 01:02:43.363 
使设备恢复到初始状态

01:02:43.430 --> 01:02:45.832 
这样它们就可以被下次课
的学生使用

01:02:46.733 --> 01:02:49.736 
这就是新的Apple
File System的特性

01:02:50.270 --> 01:02:54.141 
Developer Preview会做为
Mac OS Sierra的一部分

01:02:54.208 --> 01:02:55.475 
在今天提供给你

01:02:55.542 --> 01:02:59.046 
我们希望你们都可以下载它
使用它并向我们提供反馈

01:02:59.112 --> 01:03:02.749 
Apple File System
会很快来到所有的Apple设备

01:03:08.922 --> 01:03:09.756 
好的

01:03:11.658 --> 01:03:13.560 
最后 让我们来谈谈隐私

01:03:13.961 --> 01:03:17.231  
你们听说了一个新的 强大的
技术 叫做差分隐私

01:03:17.297 --> 01:03:18.665  
在今早的keynote中

01:03:18.732 --> 01:03:21.401  
我将向你们解释它

01:03:21.835 --> 01:03:25.672 
我从差分隐私背后的数学
开始

01:03:27.508 --> 01:03:30.777  
这看起来很复杂

01:03:30.844 --> 01:03:33.013  
但我保证这些数学很有效

01:03:33.080 --> 01:03:36.450  
我会用一些例子来解释它

01:03:36.950 --> 01:03:40.687  
第一个例子是我们将用差分
隐私来解决

01:03:40.754 --> 01:03:41.889  
一劳永逸地解决

01:03:41.955 --> 01:03:44.458  
最有争议和最重要的问题之一

01:03:44.525 --> 01:03:46.126  
在现代计算机科学中

01:03:47.060 --> 01:03:48.629 
代码格式

01:03:50.898 --> 01:03:52.499 
这当然是一个重要问题

01:03:52.566 --> 01:03:55.669 
我们将让听众对问题的答案投票

01:03:55.736 --> 01:03:59.406 
你们会希望你们的结果保持私密

01:03:59.473 --> 01:04:00.807 
因为让我们来面对它

01:04:00.908 --> 01:04:03.777 
你的一些同事会对这很热情

01:04:04.044 --> 01:04:07.147 
那么我们怎么利用差分隐私？

01:04:07.214 --> 01:04:10.350 
首先 你们每人提供你们的倾向

01:04:11.118 --> 01:04:14.855 
但是在我们把它发送给Apple
产生调查结果前

01:04:14.922 --> 01:04:18.158 
通过差分隐私
我们在每个答案里加入噪声

01:04:18.225 --> 01:04:19.693 
在我们加入噪声后

01:04:19.893 --> 01:04:22.262 
我们无法知道你的原始答案

01:04:22.663 --> 01:04:26.066 
我们把它发送给Apple
差分隐私的优点

01:04:26.366 --> 01:04:29.369 
就是我们把来自很多人的数据
集中在一起后

01:04:29.436 --> 01:04:33.073 
我们可以还原我们问题的答案

01:04:33.473 --> 01:04:36.476 
我不会对答案进行做判断

01:04:36.543 --> 01:04:40.614 
看起来我们的意见还是很不同

01:04:40.681 --> 01:04:43.617 
但是当你通过编译器运行你的
代码之后

01:04:43.684 --> 01:04:45.085 
这并不重要

01:04:45.853 --> 01:04:46.687 
所以

01:04:48.222 --> 01:04:49.056 
那就是

01:04:53.427 --> 01:04:56.864 
所以 现在我们怎样在
iOS X中使用差分隐私?

01:04:56.930 --> 01:04:58.465 
让我来提供一个例子

01:04:58.999 --> 01:05:02.002 
在Spotlight中 我们为
深层链接提供建议

01:05:02.069 --> 01:05:03.937 
我们当然希望提供

01:05:04.338 --> 01:05:08.041 
最相关和最流行的建议给
最终用户

01:05:09.109 --> 01:05:12.613 
我们这样做
我们赋予每个深层链接

01:05:12.679 --> 01:05:16.283 
一个独有的哈希值
当用户浏览它们的设备时

01:05:16.683 --> 01:05:20.654 
每当他们遇到一个深层链接
我们获取那个哈希值并加入噪声

01:05:20.721 --> 01:05:23.624 
提取它们的片断
并发送给Apple

01:05:24.091 --> 01:05:27.628 
现在 任意单独片断都没有意义

01:05:28.195 --> 01:05:31.164 
但是当我们把整个用户群
整合到一起时

01:05:31.465 --> 01:05:35.936  
我们可以还原深层链接的流行度
然后就可以使用它

01:05:36.003 --> 01:05:39.506  
使它们出现在Spotlight中
并提升用户体验

01:05:40.340 --> 01:05:44.912  
这就是差分隐私背后的科学

01:05:45.112 --> 01:05:47.748  
我还想介绍它的另一方面

01:05:48.015 --> 01:05:51.618  
你可能会想 如果我们从用户
收集样本

01:05:51.685 --> 01:05:54.421  
这通过从大量用户中收集
大量样本实现

01:05:54.721 --> 01:05:58.592  
如果Apple从同一个用户那收集
大量样本会怎样?

01:05:58.659 --> 01:06:00.961  
你们难道不会发现我在做什么?

01:06:01.428 --> 01:06:03.864 
这就是隐私预算起作用的时候

01:06:04.298 --> 01:06:07.601 
隐私预算限制我们可以获得的
样本数量

01:06:07.668 --> 01:06:10.337 
从任何一个用户
并且它确保最终

01:06:10.404 --> 01:06:14.374 
我们永远无法从任何用户那恢复
有意义的信息

01:06:15.242 --> 01:06:16.877 
这就是差分隐私

01:06:17.244 --> 01:06:20.647 
这个强大的技术允许我们从
用户那学习

01:06:20.747 --> 01:06:24.818 
提高用户体验的同时保护
你的隐私

01:06:25.385 --> 01:06:29.289 
就这些了 接下来请
Toby Paterson演讲

01:06:29.590 --> 01:06:32.626 
Toby将会介绍
iOS X的高层特性

01:06:33.627 --> 01:06:34.628 
谢谢 Sebastien

01:06:40.033 --> 01:06:40.868 
下午好

01:06:46.206 --> 01:06:47.040 
让我们开始

01:06:47.441 --> 01:06:51.445 
所以 你知道的 非常感谢你们
所有人

01:06:51.712 --> 01:06:55.115 
使得我们有一个如此好的
iOS生态环境

01:06:55.782 --> 01:07:00.821 
我们一直在努力寻找使用户
找到新应用的方法

01:07:01.221 --> 01:07:06.093 
进入到他们喜欢使用的应用中
并且整合你的应用

01:07:06.326 --> 01:07:08.128 
到其他操作系统中

01:07:09.763 --> 01:07:14.434 
你们之前已经看到你们的应用
可以怎样通过消息病毒式传播

01:07:14.902 --> 01:07:18.605 
并且我们使告诉人们你们的应用
变得相当容易

01:07:19.273 --> 01:07:21.141 
从主屏幕

01:07:22.476 --> 01:07:25.679 
我们在快速行动列表中新添加了
一个分享按钮

01:07:26.280 --> 01:07:27.915 
它会调出分享菜单

01:07:28.081 --> 01:07:31.084 
这样你就可以向全世界Tweet
你的应用

01:07:31.151 --> 01:07:33.921 
这在所有应用中都可以免费使用

01:07:36.256 --> 01:07:39.860 
现在 我们有很多方式来
获得用户

01:07:39.927 --> 01:07:42.563 
在正确的时间进入正确的应用

01:07:42.796 --> 01:07:45.699 
我将要快速介绍它们
请耐心等候

01:07:47.434 --> 01:07:51.839 
Handoff让你可以把任务
从一台设备带到另一台设备

01:07:52.172 --> 01:07:55.709 
Spotlight可以直接和你的
应用内容连接

01:07:56.176 --> 01:07:57.411 
一个通用链接

01:07:57.477 --> 01:08:00.614 
会把你带到对一个平台最合适的
地方

01:08:00.681 --> 01:08:05.052 
你可以直接将一个应用和另一个
应用连接起来

01:08:05.452 --> 01:08:09.656 
Siri会在今天的视图以及
Spotlight中推荐应用

01:08:09.823 --> 01:08:12.392 
我们可以只在正确的时间推荐
应用

01:08:12.526 --> 01:08:14.895 
在主屏的任务切换器中

01:08:15.262 --> 01:08:17.865 
我们可以基于相同的数据类型
连接应用

01:08:17.930 --> 01:08:21.134 
就像这个 这个 以及这个

01:08:22.202 --> 01:08:23.670 
我想你已经了解了这个主意

01:08:24.136 --> 01:08:27.674 
只有一件事我想你从中拿走

01:08:28.075 --> 01:08:30.444 
那就是NSUserActivity

01:08:30.611 --> 01:08:33.447 
这是很多的功能出入口

01:08:34.113 --> 01:08:38.585 
这是你的应用如何告诉操作系统
人们在你的应用里做什么

01:08:39.019 --> 01:08:42.956 
并且让我们能够创造智能的
建议和连接

01:08:43.023 --> 01:08:44.825 
在你的应用之间

01:08:45.792 --> 01:08:50.162 
在iOS X中 我们加入了2个
重要的信息

01:08:51.365 --> 01:08:55.202 
现在 很多应用用多种方式使用
地址

01:08:55.402 --> 01:08:59.573 
我们可以用它来在你的应用间
建立连接

01:09:00.073 --> 01:09:02.743 
让我用一个例子来说明

01:09:03.676 --> 01:09:06.913 
这是一家我最喜欢的餐厅的
Yelp页面

01:09:06.979 --> 01:09:08.182 
在旧金山

01:09:08.782 --> 01:09:13.353 
假设向NSUserActivity
提供这个地址

01:09:14.054 --> 01:09:18.759 
这将使我能够做类似于要Siri
带我到这来

01:09:20.294 --> 01:09:23.363 
我的手机知道我经常用Uber出行

01:09:23.430 --> 01:09:25.165 
这使得很容易

01:09:25.232 --> 01:09:28.569 
让我叫车去餐厅

01:09:29.336 --> 01:09:34.107 
或者当我在期待获得位置数据的
文本域打字时

01:09:34.408 --> 01:09:38.078 
QuickType能建议一个
我刚刚在看的地址

01:09:38.612 --> 01:09:42.149 
而且地图可以在推荐列表里
包含这个地址

01:09:42.448 --> 01:09:45.953 
以及一个快速回到这个应用
的方法

01:09:48.020 --> 01:09:51.325  
现在 我们也用多种方式
和其他人互动

01:09:51.390 --> 01:09:56.263  
操作系统可以学习我用什么
应用和特定的人联系

01:09:57.064 --> 01:10:00.834  
要达到这点 你的应用需要提供
3个信息

01:10:01.468 --> 01:10:03.937 
足够的上下文
这样我们能找到一个入口

01:10:04.004 --> 01:10:06.006 
在该人的Address Book中

01:10:06.507 --> 01:10:11.478 
你提供的服务种类
那是消息或者视频聊天平台

01:10:11.912 --> 01:10:16.583 
以及一个你将为那个人使用的
特定的标识符或处理者

01:10:18.051 --> 01:10:20.287 
这是新的Address Book卡

01:10:20.354 --> 01:10:23.957 
通过它我们可以在操作系统中
实现很多功能

01:10:24.558 --> 01:10:27.594 
而且你将注意到我们可以
自动包含

01:10:27.661 --> 01:10:30.697 
我们从你的应用学到的信息

01:10:31.565 --> 01:10:35.335 
现在 当我按任意一个
快速通信按钮时

01:10:35.402 --> 01:10:37.037 
在卡的顶部

01:10:37.104 --> 01:10:40.641 
我们还可以在选项列表里包含
你的应用

01:10:41.208 --> 01:10:44.344 
当我做出选择时
我们会记下来

01:10:44.411 --> 01:10:47.214 
所以下一次
当我按这个按钮时

01:10:47.648 --> 01:10:50.584 
我们可以把你直接打到那个应用

01:10:51.185 --> 01:10:53.854 
我需要指出所有这些学习

01:10:53.921 --> 01:10:57.991 
是用户的私密
只有他们的设备能访问

01:11:00.561 --> 01:11:05.732 
现在 我们深深的相信
跨操作系统的应用整合

01:11:05.799 --> 01:11:09.403 
提供更丰富的用户体验

01:11:10.070 --> 01:11:12.239 
扩展 当然 是你如何做那些

01:11:12.306 --> 01:11:15.309 
而且你早前已经听说了新的
iMessage Apps

01:11:15.375 --> 01:11:17.911 
地图扩展和SiriKit

01:11:19.046 --> 01:11:22.082 
那么 我想要告诉你们两个
扩展点的一些信息

01:11:22.149 --> 01:11:24.251 
我们加入到通知中

01:11:26.186 --> 01:11:28.522 
一个服务扩展在后台运行

01:11:28.589 --> 01:11:31.124 
并且允许你修改推送内容

01:11:31.425 --> 01:11:34.228 
在我们向用户显示通知前

01:11:34.661 --> 01:11:39.299 
这使你可以做一些事
比如下载图片 视频 音频文件

01:11:39.366 --> 01:11:43.337 
在后台并将之直接嵌入到通知里

01:11:44.137 --> 01:11:48.375 
或者你可以在你的服务器上
对推送内容加密

01:11:48.442 --> 01:11:52.145 
并用一个服务扩展在设备上解密

01:11:52.513 --> 01:11:55.616 
提供完全的端对端加密

01:11:59.486 --> 01:12:02.556 
我需要指出你可能想要使用
一些更强大的

01:12:02.623 --> 01:12:05.692 
比我们在这提出的ROT13算法

01:12:05.893 --> 01:12:09.663 
我们会在明年改进ROT13
来提供更多的安全性

01:12:14.034 --> 01:12:18.839 
现在如果你想要更丰富的
用户体验

01:12:19.072 --> 01:12:22.442 
一个内容扩展可以提供一个
任意的视图

01:12:22.509 --> 01:12:25.746 
我们会用来扩展一条通知的
界面

01:12:26.113 --> 01:12:29.883 
这使你能提供动态的互动的
体验

01:12:29.950 --> 01:12:32.553 
安全为你的应用量身打造

01:12:35.389 --> 01:12:38.825 
今早你快速浏览了改进后的
今日视图

01:12:38.892 --> 01:12:41.628 
和它充满活力的 拥有新外观的
小部件

01:12:41.762 --> 01:12:46.633 
一个小部件可以是任意大小
只要在合理的限制内

01:12:47.067 --> 01:12:50.504 
但是我们还添加了一个新的
紧凑的 固定大小

01:12:50.571 --> 01:12:53.207 
来优化信息密度

01:12:54.074 --> 01:12:56.476 
使我们感到兴奋的是

01:12:56.777 --> 01:13:00.414 
使这些小部件在主屏上就
可以使用

01:13:00.848 --> 01:13:05.352 
我将要告诉你使你的小部件工作
需要做什么

01:13:06.486 --> 01:13:09.189 
首先你可能想要更新它的外观

01:13:09.256 --> 01:13:13.093 
并且支持新的紧凑大小
这样你的小部件不会看起来可笑

01:13:14.027 --> 01:13:18.966 
你需要用iOS X SDK构建它
如此而已

01:13:19.333 --> 01:13:22.836 
不需要改变构建小部件的
其他方面

01:13:23.003 --> 01:13:25.372 
你将免费获得这个新功能

01:13:25.439 --> 01:13:26.940 
所以我们很兴奋

01:13:27.007 --> 01:13:31.144 
我们认为这将为你的应用打开
一个新的次元

01:13:33.013 --> 01:13:36.049 
好的 让我们转到Mac

01:13:37.317 --> 01:13:41.989 
Mac OS Sierra加入了
本地化应用的全面支持

01:13:42.055 --> 01:13:43.924 
在从右到左的语言中

01:13:43.991 --> 01:13:48.161 
包括有意义的
翻转UI元素

01:13:49.029 --> 01:13:52.299 
Mac加入了iOS和watchOS

01:13:52.366 --> 01:13:56.403 
它们在今年早些时候悄悄加入了
对这一功能的支持

01:13:57.037 --> 01:14:00.874 
在全世界有这么多潜在客户

01:14:00.974 --> 01:14:03.777 
这比以往更加重要

01:14:03.844 --> 01:14:07.714 
你的应用被正确的本地化和
全球化

01:14:07.781 --> 01:14:09.816 
你可以在这获得更多相关信息

01:14:12.419 --> 01:14:16.089 
你知道 当Sebastien
首先谈论制表符和空格符

01:14:16.156 --> 01:14:18.525 
我们很确定他会讲到这

01:14:19.326 --> 01:14:23.397 
你今早看到人们怎样把他们
所有的窗口收集到一起

01:14:23.463 --> 01:14:25.465 
到一个分页UI

01:14:26.466 --> 01:14:29.770 
AppKit将会在这为你处理所有事

01:14:29.837 --> 01:14:32.506 
它聪明到知道不要将你的设置
窗口配对

01:14:32.573 --> 01:14:35.909 
你的文档窗口 等等

01:14:36.376 --> 01:14:38.045 
其实 若你使用NSDocument

01:14:38.111 --> 01:14:42.349 
你在你的应用中不需要做其他事

01:14:43.083 --> 01:14:44.818 
如果你没有使用NSDocument

01:14:44.885 --> 01:14:48.989 
你需要采用一些API来支持创建
新标签页

01:14:49.122 --> 01:14:52.059 
但是我强烈建议你看看
NSDocument是否

01:14:52.125 --> 01:14:56.196 
不符合你的使用案例
你看

01:14:56.663 --> 01:14:59.700 
我们今早还向你展示了
我们如何使人们易于

01:14:59.766 --> 01:15:03.203 
把他们的文档和数据迁移到云上

01:15:03.270 --> 01:15:07.074 
并且我们相信
那是文件存储的未来

01:15:07.774 --> 01:15:12.279 
所以你的应用采用最佳做法
非常重要

01:15:12.579 --> 01:15:16.016 
关于文件协调和元数据查询

01:15:16.617 --> 01:15:19.553 
如果你在此使用NSDocument

01:15:19.720 --> 01:15:22.856 
它会为你处理所有琐事

01:15:22.990 --> 01:15:27.294 
就像iOS上的
UIDocument那样

01:15:28.996 --> 01:15:32.232 
现在我有一个iCloud的重要更新

01:15:33.200 --> 01:15:37.671 
如你所知iCloud API在
我们的所有平台上都可用

01:15:38.105 --> 01:15:42.309 
但是在Mac上 对这些API的使用
受到限制

01:15:42.376 --> 01:15:46.180 
只有通过Mac App Store
发布的应用可以使用

01:15:46.747 --> 01:15:50.817 
在Mac OS Sierra中
我们移除了这一限制

01:15:57.424 --> 01:15:58.258 
现在

01:15:58.325 --> 01:16:01.361 
你的应用仍然需要被有效的
developer ID签名

01:16:01.428 --> 01:16:05.866 
同时也会移除那些烦人的
不受信任开发者警告

01:16:06.466 --> 01:16:09.169 
但是一旦你完成了这一步
你可以使用所有的API

01:16:09.236 --> 01:16:12.306 
无论你怎样分发你的应用给用户

01:16:15.008 --> 01:16:16.643 
接下来CloudKit

01:16:17.377 --> 01:16:19.546 
我们2年前介绍了CloudKit

01:16:19.613 --> 01:16:22.216 
它是基础 我们用来开发

01:16:22.282 --> 01:16:24.418 
所有我们的新云服务

01:16:25.085 --> 01:16:28.088 
现在他的权限模型相当粗粒化

01:16:28.689 --> 01:16:32.793 
你的数据或者可以被任何人访问

01:16:33.293 --> 01:16:36.430 
或者只能被一个用户访问

01:16:37.364 --> 01:16:41.134 
新的CloudKit分享特性
允许你的应用

01:16:41.201 --> 01:16:44.371 
能够绝对决定谁能访问你的数据

01:16:51.011 --> 01:16:52.880 
新的CKShare类

01:16:54.314 --> 01:16:56.650 
使你能管理权限

01:16:56.717 --> 01:16:59.286 
谁能读写一个指定的数据集

01:16:59.353 --> 01:17:02.856 
这个API在所有的平台上都可
使用

01:17:03.991 --> 01:17:08.529 
在Mac和iOS上
我们提供标准API

01:17:08.662 --> 01:17:11.765 
来处理邀请他人的机制

01:17:11.865 --> 01:17:14.334 
并且在你的应用中管理他人

01:17:15.602 --> 01:17:19.506 
我们用CloudKit分享来实现
新的合作特性

01:17:19.573 --> 01:17:21.208 
我们把它加入了Notes

01:17:21.275 --> 01:17:24.845 
我鼓励你们在今天developer
preview中看一看它们

01:17:26.213 --> 01:17:28.615 
接下来交给Josh Shaffer

01:17:28.682 --> 01:17:30.984 
他会向你们介绍watchOS的
一些更新

01:17:31.051 --> 01:17:31.885 
谢谢

01:17:37.891 --> 01:17:38.725 
谢谢 Toby

01:17:40.127 --> 01:17:44.164 
如你们在keynote所知
watchOS 3简化了导航

01:17:44.231 --> 01:17:45.999 
并提升了性能

01:17:46.700 --> 01:17:49.503 
这些改进超过了系统层面

01:17:49.736 --> 01:17:52.372 
并且包含很多对应用的改进

01:17:53.407 --> 01:17:57.444 
这些改进聚焦在Watch应用的
3个关键方面

01:17:57.911 --> 01:18:00.047  
首先是方便查看

01:18:01.114 --> 01:18:04.084  
和Apple Watch的单次互动
都很短暂

01:18:04.284 --> 01:18:07.387  
所以需要呈现设计良好
简单的信息

01:18:07.454 --> 01:18:10.858  
给用户
只聚集最相关的信息

01:18:10.991 --> 01:18:13.093  
来确保容易消化

01:18:14.561 --> 01:18:16.463  
第二是易于操作

01:18:17.064 --> 01:18:18.932  
这包括简化使用

01:18:18.999 --> 01:18:21.768  
对最常用的
发生在Watch上的操作

01:18:22.302 --> 01:18:24.905  
比如 我们重新设计了健身应用

01:18:24.972 --> 01:18:27.841  
来减少开始一次健身
所需的步骤

01:18:28.842 --> 01:18:32.012  
这也意味着简化访问关键信息

01:18:32.079 --> 01:18:34.014  
你的用户将会希望按照它来行动

01:18:34.248 --> 01:18:36.884  
即使他们不会在Watch上
采取这些行动

01:18:38.085 --> 01:18:41.255  
第三是保证你的应用的响应性

01:18:41.321 --> 01:18:44.958  
通过保持它们在被需要时
状态是最新的并且立即可使用的

01:18:47.628 --> 01:18:49.696 
当然 谢谢 我同意

01:18:51.131 --> 01:18:52.966 
所以 当你思考一个应用

01:18:53.033 --> 01:18:56.670 
首先想到的是全屏应用

01:18:57.204 --> 01:18:58.739 
它绝对是这个的一部分

01:18:58.805 --> 01:19:02.142 
但是在Apple Watch上
重要的一点是记住你的应用可使用

01:19:02.209 --> 01:19:06.947 
另外2种界面
complications和通知

01:19:07.848 --> 01:19:12.319 
这三种界面只是你同一应用的
3种不同视图

01:19:12.452 --> 01:19:15.289 
所以重要的一点是他们呈现
一致的信息

01:19:15.789 --> 01:19:18.892 
当你更新它们中的一个
你应当更新其他的

01:19:19.059 --> 01:19:21.261 
因为如果他们显示不同信息

01:19:21.328 --> 01:19:23.630 
你的用户不会信任任何一个

01:19:24.598 --> 01:19:27.100 
你可能记得在watchOS 2中

01:19:27.167 --> 01:19:29.369 
有第4种界面叫做Glances

01:19:29.870 --> 01:19:32.206 
Glances简化获得

01:19:32.272 --> 01:19:35.242 
你最喜欢的应用的信息的摘要

01:19:36.276 --> 01:19:40.080 
在watchOS 3中
新的Dock将提供这一功能

01:19:40.247 --> 01:19:44.117 
并且只要按一下侧边按钮就
可以从任何地方立即达到

01:19:45.619 --> 01:19:48.155 
若你watchOS 2
使用Glance界面

01:19:48.322 --> 01:19:51.792 
这个分开的界面
在watchOS 3中不再需要

01:19:52.125 --> 01:19:55.295 
但是它简单的设计可以帮助你
更新主界面

01:19:55.362 --> 01:19:58.866 
为你的应用 来确保它
看起来和使用起来都很好

01:19:58.932 --> 01:20:00.200 
当用Dock显示时

01:20:01.535 --> 01:20:04.805 
在Dock里的应用会立即响应
来确保

01:20:04.872 --> 01:20:07.040 
Watch上最常用的任务

01:20:07.107 --> 01:20:09.576 
可以在几秒内完成

01:20:10.310 --> 01:20:12.412 
现在 那很明显是很短的时间

01:20:12.479 --> 01:20:14.882 
为此努力可以成为一个好的引导

01:20:14.948 --> 01:20:17.951 
帮助你为你的应用设计
顶级的特性

01:20:18.018 --> 01:20:21.054 
为确保在Apple Watch上
确实运行良好

01:20:22.523 --> 01:20:24.658 
尽管每一个单独操作都很短

01:20:24.725 --> 01:20:28.428 
一些应用可能会在较长的一段
时间里被使用多次

01:20:28.962 --> 01:20:32.199 
比如我可能会多次查看购物清单

01:20:32.266 --> 01:20:33.367 
当我在一家商店时

01:20:34.301 --> 01:20:36.537 
在watchOS 3中
每当我抬起手腕

01:20:36.603 --> 01:20:39.306 
我能马上看到我要买的东西

01:20:39.473 --> 01:20:41.675 
并且删除我已经拿了的东西

01:20:42.276 --> 01:20:45.879 
现在设计拥有这种交互模型的
应用相当容易

01:20:45.946 --> 01:20:49.249 
因为watchOS 3会
返回你使用的最后一个应用

01:20:49.316 --> 01:20:52.019 
在你最后使用它之后长达8分钟内

01:20:52.853 --> 01:20:55.556 
当你完成之后
你会返回到Watch界面

01:21:01.828 --> 01:21:03.163 
当你的应用未被使用时

01:21:03.230 --> 01:21:06.900 
确保它保持响应意味着
让它在后台保持最新

01:21:06.967 --> 01:21:09.636 
所以当你要使用它时
它已经准备好了

01:21:10.003 --> 01:21:11.271 
要达到这非常容易

01:21:11.338 --> 01:21:15.542  
watchOS 3包括一系列新的
后台应用刷新API

01:21:16.276 --> 01:21:18.245  
后台应用刷新是一个关键部分

01:21:18.312 --> 01:21:21.048  
来开发可响应的watchOS应用

01:21:21.114 --> 01:21:23.450  
周期性的在后台更新你的应用

01:21:23.517 --> 01:21:24.918  
是一个巨大的改进

01:21:24.985 --> 01:21:26.887  
不管你开发何种应用

01:21:27.321 --> 01:21:30.724  
现在 如果你开发健身应用
对这类应用

01:21:30.791 --> 01:21:33.126  
它们保持最新更加重要

01:21:33.193 --> 01:21:35.128  
在整个健身过程中

01:21:35.229 --> 01:21:37.865  
所以我们为它们有一些额外改进

01:21:39.099 --> 01:21:40.434 
在一次健身中

01:21:40.501 --> 01:21:43.370 
这些应用将会持续在后台运行

01:21:43.437 --> 01:21:44.838 
即使屏幕关闭时

01:21:45.172 --> 01:21:47.207 
确保他们能监视健身进度

01:21:47.274 --> 01:21:48.709 
并向用户提供更新

01:21:48.775 --> 01:21:51.378 
当他们用触真体验技术达到里程碑

01:21:53.814 --> 01:21:56.683 
在健身中
它们也保持立刻可用

01:21:56.750 --> 01:21:59.653 
即使你切换到另一个应用
来完成其他任务

01:21:59.920 --> 01:22:02.789 
所以当我跳出到音乐应用里
切换音乐

01:22:02.923 --> 01:22:04.191 
我放下手腕后

01:22:04.258 --> 01:22:06.727 
我会很快回到我的健身

01:22:07.628 --> 01:22:09.129 
我们还加强了访问

01:22:09.196 --> 01:22:11.031 
心率计和加速仪

01:22:11.098 --> 01:22:13.500 
所以现在它们提供连续的数据

01:22:13.567 --> 01:22:15.702 
在整个健身过程中

01:22:20.807 --> 01:22:22.209 
除了这些传感器方面的增强

01:22:22.276 --> 01:22:25.445 
还有一系列新的硬件访问API

01:22:25.979 --> 01:22:29.650 
Crown事件使你原始访问来自
Digital Crown旋转事件

01:22:30.484 --> 01:22:35.088 
手势识别使为应用添加定制的
触碰操作更容易

01:22:35.155 --> 01:22:38.792 
触摸操作 比如轻触 滑动 拖移
当然还有

01:22:38.859 --> 01:22:42.362 
除了加速仪 现在还可以
访问陀螺仪

01:22:46.900 --> 01:22:50.170 
来确保你可以通过这些硬件访问
API来做一些很酷的事情

01:22:50.237 --> 01:22:54.107 
我们还为watchOS SDK
带来了一系列图形图像框架

01:22:54.508 --> 01:22:57.311 
SpriteKit和SceneKit
给你很多自由

01:22:57.377 --> 01:23:01.982 
来增强你的应用和通知的外观

01:23:02.850 --> 01:23:06.486 
AV Foundation使得
用Watch的外放播放声音相当容易

01:23:06.954 --> 01:23:09.356 
本着简化应用浏览的精神

01:23:09.423 --> 01:23:13.560 
你现在可以在应用界面中
播放视频

01:23:16.296 --> 01:23:19.499 
当然 你也常常需要将数据
传入或传出Watch

01:23:19.566 --> 01:23:21.768 
Toby已经提到 为了简化这方面

01:23:21.835 --> 01:23:24.471  
CloudKit是
watchOS SDK一部分

01:23:24.905 --> 01:23:27.541  
因为它基于NSURL会话

01:23:27.608 --> 01:23:29.510  
它甚至可以脱离手机运行

01:23:29.576 --> 01:23:31.745  
若你的Watch
靠近已知Wi-Fi网络

01:23:32.713 --> 01:23:37.050  
Apple Watch是在
商店购买商品的方便途径

01:23:37.150 --> 01:23:40.320  
在watchOS 3中
你可以卖东西

01:23:40.387 --> 01:23:41.889  
在你自己的应用里

01:23:41.955 --> 01:23:44.691  
只需双击侧边按钮即可购买

01:23:45.926 --> 01:23:48.462 
开发一个Watch应用只是第一步

01:23:48.662 --> 01:23:50.964 
另一件重要的事是使用户易于

01:23:51.031 --> 01:23:52.999 
发现和安装你的应用

01:23:53.367 --> 01:23:54.501 
为了帮助你实现这点

01:23:54.568 --> 01:23:57.037 
在iOS X新的
Watch Face Gallery中

01:23:57.104 --> 01:24:01.141 
含有一整个部分专门用来显示
所有你的应用

01:24:01.942 --> 01:24:05.312 
只需几个简单的步骤就能创建
一个complication bundle

01:24:05.379 --> 01:24:08.081 
使应用出现在表盘图库中

01:24:08.615 --> 01:24:10.951 
当拿到新表时
你第一眼就会看到表盘图库

01:24:11.018 --> 01:24:14.188 
在成功配对之后
显示complications

01:24:14.254 --> 01:24:17.457 
来自你iPhone上每天
经常使用的应用

01:24:17.991 --> 01:24:21.395 
这就让安装应用 变得非常简单

01:24:21.461 --> 01:24:23.230 
并添加到他们的表盘上

01:24:24.164 --> 01:24:26.800 
我们竭尽所能为你提供所需要
的全部工具 帮你创建

01:24:26.867 --> 01:24:30.237  
非常棒的、引人注目的、
可控性强的、响应式的应用

01:24:30.304 --> 01:24:32.439  
并且我们迫不及待想看到你
要如何利用它们

01:24:32.573 --> 01:24:35.809  
为了让你了解这将如何在
watchOS中强化你的应用

01:24:35.876 --> 01:24:39.112  
Eliza Block会给我们展示一个
Background App Refresh的演示

01:24:39.179 --> 01:24:41.582  
和一些新的图形API Eliza

01:24:47.554 --> 01:24:52.092 
大家好 我这儿有一款基于
watchOS 2创建的应用

01:24:52.292 --> 01:24:55.495 
展示了一位名叫Max的熊猫朋友

01:24:55.629 --> 01:24:58.999 
它能告诉我他在不同时间的不同心情

01:24:59.233 --> 01:25:01.235 
那么现在 你可以看到他很高兴

01:25:02.336 --> 01:25:04.004 
如果我挂起应用

01:25:04.571 --> 01:25:07.975 
可看到有complication
仍然会告诉我他很高兴

01:25:08.375 --> 01:25:12.880 
但这儿有个通知 说Max饿了

01:25:13.480 --> 01:25:15.816 
这个watchOS 2的应用

01:25:15.883 --> 01:25:18.285 
有一些问题 我现在要演示给你们看

01:25:18.385 --> 01:25:20.821 
首先 如果我不理会这个通知

01:25:21.355 --> 01:25:25.492 
我的complication就不会更新
也不会体现出Max现在很饿

01:25:26.460 --> 01:25:31.999 
更糟糕的是 当我进入Dock
Dock中的应用快照

01:25:32.266 --> 01:25:35.269 
也没有更新 所以我不能演示出

01:25:35.335 --> 01:25:40.307 
在app中所有界面都享有一致的数据

01:25:42.676 --> 01:25:47.147 
现在让我们看看代码
在watchOS 3中有一种

01:25:47.214 --> 01:25:48.448 
简单新方法来处理该问题

01:25:49.783 --> 01:25:52.619 
在扩展委托中有一个单一点管道

01:25:52.719 --> 01:25:56.089 
叫做处理和后台任务
可以完美地更新

01:25:56.156 --> 01:25:58.592 
所有界面 当数据变化时

01:25:59.393 --> 01:26:01.929 
在快照刷新后台任务中

01:26:02.095 --> 01:26:05.365 
我只需要添加两行代码
就能处理这两个问题

01:26:05.432 --> 01:26:10.170 
第一行代码更新界面上的
当前状态

01:26:11.772 --> 01:26:14.808 
第二行代码刷新
complication

01:26:16.243 --> 01:26:17.978 
当查看快照的时候

01:26:18.612 --> 01:26:21.882 
好了 这就解决了我们之前的问题

01:26:22.616 --> 01:26:23.784 
既然说到这儿了

01:26:23.851 --> 01:26:26.220 
那咱们就把这个应用变得
更有意思一些吧

01:26:26.286 --> 01:26:30.290 
显然 你所看到的Max在
watchOS 2中只是个静态图像

01:26:30.457 --> 01:26:34.561 
但在watchOS 3中
可合成一个SceneKit场景

01:26:34.795 --> 01:26:36.330 
实现一些动画

01:26:37.364 --> 01:26:39.766 
那么我要切换到我的界面

01:26:40.167 --> 01:26:43.470 
这是我的应用界面 我要先
删除这个图片

01:26:44.104 --> 01:26:47.908 
然后拖一个SceneKit场景进来

01:26:50.978 --> 01:26:53.280 
我之前写好了少量的代码

01:26:53.347 --> 01:26:56.984 
只是给这个场景填充一些
SceneKit assets

01:26:57.217 --> 01:26:59.920 
然后创建一个出口
现在我要把它连上了

01:27:02.222 --> 01:27:04.091 
把它拖到SceneKit界面

01:27:05.592 --> 01:27:09.663 
现在 不仅能在应用中添加
SceneKit场景

01:27:09.730 --> 01:27:11.965 
还能在通知中添加场景

01:27:12.432 --> 01:27:15.402 
这可比文字通知有意思多了

01:27:15.936 --> 01:27:17.871 
我还要把一个场景拖到那儿去

01:27:19.106 --> 01:27:21.008 
我需要稍微调一下尺寸

01:27:22.376 --> 01:27:24.645 
钩住出口

01:27:29.483 --> 01:27:32.953 
这就行了 我要再运行一下应用

01:27:33.987 --> 01:27:36.823 
这次 我们有希望能看到更多
动态画面

01:27:46.166 --> 01:27:49.703 
那么 我们就有了一个更养眼的
版本 因为Max能跑了

01:27:50.370 --> 01:27:53.040 
我现在再挂起应用

01:27:54.141 --> 01:27:55.609 
等他变饿

01:28:00.113 --> 01:28:04.718 
我们看到一个非常沮丧的Max
摸着肚子 这个版本更直观

01:28:08.655 --> 01:28:10.157 
我觉得这好玩儿多了

01:28:10.224 --> 01:28:12.059 
当我挂起通知时

01:28:12.960 --> 01:28:17.064 
complication如我们希望
那样更新了 体现出了他的当前状态

01:28:17.564 --> 01:28:19.166 
如果我在Dock中查看

01:28:19.666 --> 01:28:22.069 
你会看到快照也更新了

01:28:22.135 --> 01:28:24.137 
体现出他饿了 不高兴了

01:28:24.204 --> 01:28:26.673 
这只是能实现的很小一
部分新功能

01:28:26.740 --> 01:28:29.142 
用watchOS 3提供的新API

01:28:29.209 --> 01:28:31.044 
我们非常期待你们会
创造出什么

01:28:31.111 --> 01:28:35.115 
接下来 让我们请Jim Young
上台来讲一下tvOS

01:28:42.556 --> 01:28:43.390 
谢谢Eliza

01:28:44.057 --> 01:28:47.327 
自App Store在Apple TV上线以来
我们一直很兴奋

01:28:47.394 --> 01:28:48.695 
就在去年十月

01:28:49.630 --> 01:28:51.965 
因为我们坚信TV的未来属于应用

01:28:52.366 --> 01:28:54.468 
从那一刻起 你们就忙于

01:28:55.536 --> 01:29:00.073 
让6000多个应用在App Store
上架 其中包括娱乐应用、游戏应用、

01:29:00.274 --> 01:29:03.043 
保健和健身应用、教育应用等等

01:29:03.577 --> 01:29:06.513 
现在让我们谈谈这对于tvOS
的开发意味着什么

01:29:07.614 --> 01:29:09.416 
首先 你已经很熟悉它了

01:29:09.583 --> 01:29:11.952 
你可以使用你已经掌握的
工具和语言

01:29:12.920 --> 01:29:16.857 
而且tvOS包含你已经熟悉的
iOS的基础框架

01:29:17.658 --> 01:29:21.161 
此外 我们还有一些针对tvOS
创建的新框架

01:29:22.429 --> 01:29:25.599 
还有你创建很棒的应用时所需要
的所有基础支持

01:29:26.133 --> 01:29:28.535 
有丰富多媒体资源
帮你创建音频/视频应用

01:29:29.536 --> 01:29:32.039 
当然 我们对游戏应用的
支持也非常出色

01:29:33.607 --> 01:29:36.043 
而且我们也将更多的特性
引入到平台中

01:29:36.343 --> 01:29:37.911 
现你可用PhotoKit创建

01:29:37.978 --> 01:29:41.181 
能在大屏幕中显示用户的
图片的应用

01:29:42.349 --> 01:29:45.385 
并且使添加明暗变化
变得非常简单—

01:29:46.053 --> 01:29:47.988 
请看一下明暗效果

01:29:49.857 --> 01:29:52.359 
这样的技术相当丰富
这个列表只列出了其中一部分

01:29:52.426 --> 01:29:53.660 
还有一大批没有列出来

01:29:56.430 --> 01:29:58.365 
现在让我们谈谈这些技术的使用

01:29:58.432 --> 01:30:01.668 
并把它们结合在一起 在tvOS中
实现一种优秀的用户体验

01:30:02.769 --> 01:30:04.238 
我想先从Touch谈起

01:30:04.905 --> 01:30:07.274 
在设计tvOS时 我们很清楚
需要引入

01:30:07.341 --> 01:30:09.843 
一种优秀的Touch体验 到客厅

01:30:10.477 --> 01:30:12.713 
现在 Touch必须让人感到
流畅和连贯

01:30:13.113 --> 01:30:15.082 
要精准和有趣

01:30:15.916 --> 01:30:19.186 
这在客厅里是极具挑战性的
因为TV就在10英尺之内

01:30:20.954 --> 01:30:22.589 
让我们看看该如何解决这个问题

01:30:23.423 --> 01:30:24.892 
我们更新了UIKit

01:30:25.158 --> 01:30:28.028 
所以大屏幕上的所有控件和视图
看起来都很漂亮

01:30:29.062 --> 01:30:33.300 
我们添加UIFocus 可定义UI
中的哪些元素可设定为焦点

01:30:34.268 --> 01:30:38.472 
更新了UIMotionEffect
可获取聚焦引擎的输入

01:30:39.473 --> 01:30:41.375 
以上这些都可以直接连接

01:30:41.441 --> 01:30:43.544 
在用户远程操作

01:30:43.610 --> 01:30:45.145 
和在大屏幕上看到的结果之间

01:30:46.813 --> 01:30:49.449 
好消息是我们已经帮你们
做了大量的工作

01:30:50.050 --> 01:30:52.085 
你们的UIKit app
可免费使用该成果

01:30:53.654 --> 01:30:56.890 
如果你现在还有基于服务器、
用于提交内容的app

01:30:56.957 --> 01:30:59.660 
我们有很多不错的应用 就像
Showtime频道显示的这个一样

01:30:59.726 --> 01:31:02.996 
我们有一种技术叫TVMLKit
还有一个框架叫TVMLKit

01:31:03.931 --> 01:31:07.768 
TVMLKit是我们专门为tvOS
开发的一个新的高级框架

01:31:08.635 --> 01:31:10.637 
它建立在UIKit的基础上

01:31:10.704 --> 01:31:13.707 
所以你能获得我们刚刚展示的
所有无缝Touch体验

01:31:15.042 --> 01:31:17.444 
我们提供大量模板 你们甚至
可以提供

01:31:17.511 --> 01:31:20.080 
自己的自定义模板和本地控件

01:31:21.815 --> 01:31:23.450 
TVMLKit允许团队创建

01:31:23.517 --> 01:31:26.253 
漂亮的、高度程式化的、
自定义应用

01:31:26.320 --> 01:31:27.554 
在短时间内

01:31:29.556 --> 01:31:33.827 
现在让我们谈谈如何将这种体验
扩展到Apple TV之外

01:31:33.894 --> 01:31:36.263 
通过整合其他Apple设备

01:31:37.531 --> 01:31:40.934 
可以用CloudKit很方便地在
云中保存应用和游戏状态

01:31:41.835 --> 01:31:44.471 
用户可以很方便地在Apple TV
上开始游戏

01:31:44.738 --> 01:31:47.975 
然后在iPhone或iPad上再
继续游戏

01:31:52.479 --> 01:31:56.049 
我们还看到了一些不错的应用
可同时使用多个Apple设备

01:31:56.350 --> 01:31:58.619 
比如FreshPlanet中的
SongPop Party

01:31:58.685 --> 01:32:00.854 
每个家庭成员都可以
用自己的iPhone

01:32:01.221 --> 01:32:03.457 
来回答音乐相关的提问

01:32:05.359 --> 01:32:08.128 
为了让不同的设备更好地进行沟通

01:32:08.195 --> 01:32:10.864 
我们在平台中引入了
Multipeer Connectivity

01:32:11.131 --> 01:32:12.466 
只需要少量代码

01:32:17.504 --> 01:32:21.341 
就能很容易地连接运行在多个
设备上的应用

01:32:23.243 --> 01:32:25.712 
今天早晨 我们发布了新的
Apple TV Remote

01:32:26.213 --> 01:32:28.582 
现在 你的家人只要有iPhone

01:32:28.649 --> 01:32:30.651 
就相当于有
Apple TV Remote了

01:32:32.186 --> 01:32:35.355 
你的apps无论看起来还是用
起来都跟Siri Remote很像

01:32:35.422 --> 01:32:37.925 
并且我们还利用屏幕优势
增加了更多功能

01:32:38.825 --> 01:32:41.428 
Now Playing在屏幕上
提供了一整套的

01:32:41.495 --> 01:32:43.197 
重播控制和媒体封面

01:32:44.364 --> 01:32:47.534 
就像iOS在锁屏时显示的画报
和控制一样

01:32:47.601 --> 01:32:49.469 
使用Media Player Remote

01:32:49.536 --> 01:32:52.206 
我经常用Media Player Remote
Command API

01:32:52.706 --> 01:32:54.575 
把信息添到Remote app中

01:32:56.143 --> 01:32:58.779 
这个应用还提供游戏设定的布局

01:32:59.246 --> 01:33:02.349 
在玩儿游戏时 这个新应用可以
当做微型游戏手柄

01:33:02.983 --> 01:33:04.718 
就像Siri Remote一样

01:33:05.152 --> 01:33:07.054 
要实现多个微型游戏手柄

01:33:07.120 --> 01:33:10.123 
你需要设置一个
Info.plist key

01:33:12.326 --> 01:33:14.761 
除了Siri Remote和新的
Remote app之外

01:33:14.895 --> 01:33:17.497 
tvOS还支持MFi游戏控制器

01:33:18.832 --> 01:33:19.700 
今年秋季

01:33:19.766 --> 01:33:22.970  
tvOS将同时支持多达四个
游戏控制器

01:33:29.142 --> 01:33:30.711  
但我们不想止步于此

01:33:31.311 --> 01:33:33.480  
我们想做出更出色的游戏

01:33:33.747 --> 01:33:36.984  
我们想做出需要这种控制器的游戏

01:33:37.885 --> 01:33:41.889  
因此我们很高兴地宣布
我们将更新控制器政策

01:33:42.756 --> 01:33:45.792  
你可以限定你的游戏必须使用控制器

01:33:53.734 --> 01:33:56.170  
tvOS会查看所需要的
控制器是否存在

01:33:56.236 --> 01:33:58.105  
如果必要的话 会提醒用户

01:33:59.806 --> 01:34:03.477 
这是tvOS的进步 我们非常高兴
能取得这样的成绩

01:34:03.544 --> 01:34:06.213 
我们会举办很多tvOS工程师参
与的实践活动和研讨会

01:34:06.280 --> 01:34:07.681 
欢迎你们参加

01:34:08.081 --> 01:34:09.983 
接下来
我们欢迎Geoff Stahl上台

01:34:10.050 --> 01:34:12.352 
谈一谈图形技术 Geoff

01:34:16.156 --> 01:34:16.990 
谢谢Jim

01:34:18.525 --> 01:34:19.693 
我要谈谈绘图

01:34:19.760 --> 01:34:23.030 
我要谈一下图形学的几个领域

01:34:23.197 --> 01:34:25.566  
今天我们要谈一些了不起的技术

01:34:25.632 --> 01:34:26.934  
我要从色彩说起

01:34:29.002 --> 01:34:34.308 
我们为最新的iPads和Macs
打造了令人惊叹的新显示器

01:34:34.842 --> 01:34:38.545 
可以完全还原色彩

01:34:39.379 --> 01:34:41.415 
其实DisplayMate展现的是

01:34:41.481 --> 01:34:46.153 
“色彩的精确程度是人眼不可
辨别的”

01:34:47.254 --> 01:34:50.257 
那么我们要如何实现 嗯
这其实是色饱和度

01:34:51.124 --> 01:34:54.294 
绝大多数显示屏都采用了
sRGB色饱和度

01:34:54.361 --> 01:34:55.796 
范围很窄

01:34:55.863 --> 01:34:59.099 
不能准确还原我们日常生活中能
看到的所有色彩

01:34:59.166 --> 01:35:01.268 
比如花儿和画儿的色彩

01:35:01.335 --> 01:35:03.203 
亦或是你穿的衣服的色彩

01:35:04.338 --> 01:35:07.608 
所以我们步入了范围更广的P3
色饱和度的时代

01:35:07.674 --> 01:35:11.245 
可以真正实现色彩的精准还原

01:35:11.311 --> 01:35:13.113 
并把这些现实的对象渲染出来

01:35:14.915 --> 01:35:18.151 
但我们并没有止步不前 我们
将色彩做到极致

01:35:18.418 --> 01:35:22.289 
从系统API到系统应用

01:35:22.356 --> 01:35:24.458 
我们始终致力于显示更深、
更广的色域

01:35:24.758 --> 01:35:29.062 
如果app采用了
UIImageView或UIView

01:35:29.463 --> 01:35:32.065 
可以免费使用 自动获取

01:35:32.499 --> 01:35:35.736 
如果你要自己控制范围更广的色彩

01:35:35.802 --> 01:35:38.138 
我们还提供API

01:35:39.439 --> 01:35:41.608 
当然 我们有一个很棒的色彩
捕捉工具

01:35:41.842 --> 01:35:44.711 
我们最新的摄像头支持捕捉更
深、更广的色彩

01:35:44.945 --> 01:35:48.115 
我们用API获取原始图像

01:35:48.849 --> 01:35:52.819 
而且现在还可以用
API LivePhotos来获取

01:35:54.087 --> 01:35:54.922 
以上说的是色彩

01:36:00.861 --> 01:36:02.696 
现在我要谈一谈技术

01:36:02.763 --> 01:36:05.933  
改变了产业走向 即Metal

01:36:06.767 --> 01:36:10.804  
我们在两年前引入了Metal
目前已被广泛使用

01:36:11.371 --> 01:36:13.207  
请记住 当我们开发Metal时

01:36:13.273 --> 01:36:16.443  
我们优化它时 我们同时也
考虑到了我们的设备

01:36:16.510 --> 01:36:18.879  
所以我们能很快地创新

01:36:19.213 --> 01:36:22.683  
用Metal细分曲面技术这样的高
质量的表面处理技术

01:36:22.749 --> 01:36:25.152  
来实现之前从未实现的渲染精确度

01:36:26.019 --> 01:36:27.988  
或Metal功能专业化

01:36:28.088 --> 01:36:32.359  
结合S码 可以创建一套着色器

01:36:32.459 --> 01:36:35.896  
自动处理材质并照亮场景中的道具

01:36:37.431 --> 01:36:39.499 
对于低内存的渲染目标

01:36:39.566 --> 01:36:42.669 
可采用碎片兑现中的结构

01:36:42.736 --> 01:36:46.340 
来减少应用或源代码中使用的内存

01:36:46.406 --> 01:36:47.975 
这就允许应用

01:36:48.141 --> 01:36:51.478 
有一种专门的算法在Metal应用
中处理内存

01:36:54.648 --> 01:36:59.419 
Metal几乎无处不在 成千上万的
设备都使用Metal

01:37:00.320 --> 01:37:02.990 
我们的关键图形框架
和主游戏引擎

01:37:03.056 --> 01:37:04.157 
就建立在它的基础上

01:37:05.626 --> 01:37:09.663 
所以 无论是用高级API 还是直
接在Metal中编程

01:37:09.730 --> 01:37:13.233 
都能获得我们创建的所有
的性能优化

01:37:14.568 --> 01:37:15.869 
关于Metal的另外一点是

01:37:15.936 --> 01:37:19.907 
它是我们游戏生态系统的
基础技术之一

01:37:20.140 --> 01:37:21.408 
因此让我们来谈一谈游戏

01:37:23.644 --> 01:37:26.980 
在过去几年中 我们创建了伟大
的游戏生态系统

01:37:27.047 --> 01:37:30.784 
目的是创建API和工具

01:37:30.851 --> 01:37:34.888 
把你对于游戏的想法付诸实践

01:37:35.155 --> 01:37:37.024 
今天在这里我想有重点地说几个

01:37:38.258 --> 01:37:40.460  
第一个是上午说过的
Replay Kit

01:37:40.861 --> 01:37:44.364  
我们去年引入了Replay Kit
应用起来非常简单

01:37:44.565 --> 01:37:48.368 
可以让你的用户录制游戏过程

01:37:49.703 --> 01:37:53.140 
编辑录像 然后分享给他们的朋友

01:37:54.107 --> 01:37:58.378  
今年 我们会更上一层楼
将推出ReplayKit Streaming

01:38:00.047 --> 01:38:02.316  
目前 Replay Kit可以现场直播

01:38:02.382 --> 01:38:05.819  
在支持ReplayKit Streaming
Extension服务的设备上

01:38:05.886 --> 01:38:09.823  
这就允许用户不仅仅是—

01:38:09.990 --> 01:38:14.061 
不仅仅是能和朋友分享
还能通过Internet实时发布

01:38:14.127 --> 01:38:16.730 
自动地 通过ReplayKit
Live Streaming

01:38:16.797 --> 01:38:18.565 
并且——是绝对的

01:38:23.370 --> 01:38:24.605 
甚至更好

01:38:24.671 --> 01:38:27.574 
如果你已经使用了Replay Kit
只需要添加三行代码

01:38:27.641 --> 01:38:32.346 
非常简单 可以真正扩展应用
的社交覆盖度

01:38:32.880 --> 01:38:35.349 
说到社交 让我们谈一谈
Game Center

01:38:37.384 --> 01:38:40.320  
我们将改变Game Center
Multiplayer工作模式

01:38:40.387 --> 01:38:42.689  
目前在最新版的OS中

01:38:42.890 --> 01:38:45.826  
只要能发信息就能邀请

01:38:45.893 --> 01:38:48.862  
所以你的用户可以邀请任何
通过信息能联系到的人

01:38:48.929 --> 01:38:52.432  
就是这么简单 发个信息就可以了

01:38:53.600 --> 01:38:54.601 
而且最酷的是

01:38:54.668 --> 01:38:57.437 
如果你已经在游戏中使用了
多玩家API

01:38:57.504 --> 01:39:00.974 
你甚至不需要做任何改动
在最新版的OS中就可以这样运行了

01:39:02.609 --> 01:39:04.244 
并且我们不会止步不前

01:39:04.311 --> 01:39:08.849 
我们将向Game Center中
添加新API

01:39:08.916 --> 01:39:10.584 
Game Center Sessions

01:39:10.651 --> 01:39:14.521 
Game Center Sessions
营造了一种坚挺的分享体验

01:39:14.588 --> 01:39:16.056 
用户可以随意进出

01:39:16.323 --> 01:39:19.793 
意思是你要在设计游戏时充分
考虑到移动设备用户

01:39:19.860 --> 01:39:22.563 
进入和离开应用的方式

01:39:22.729 --> 01:39:26.366 
这就需要一个移动设备的多玩家
游戏的新典范

01:39:28.702 --> 01:39:30.604 
最后 说一下GameplayKit

01:39:30.704 --> 01:39:33.340 
GameplayKit是一个
基于组件的API

01:39:33.407 --> 01:39:36.143 
可以实例化和自定义这些组件

01:39:36.210 --> 01:39:38.512 
并为游戏对象构建模块

01:39:38.579 --> 01:39:40.514 
把难题留给我们来解决吧

01:39:41.648 --> 01:39:44.518 
接下来
我要邀请Norman Wang上台

01:39:44.585 --> 01:39:48.555 
讲解这些组件和Xcode
gameplay工具的展示

01:39:54.228 --> 01:39:55.062 
谢谢Geoff

01:39:55.896 --> 01:40:00.067 
我想向你们展示在Xcode 8中
创建一个游戏有多快

01:40:00.334 --> 01:40:02.669 
这是一个我正在开发的游戏项目

01:40:03.070 --> 01:40:06.106 
这是一款竞技性游戏 角色有
英雄和敌人

01:40:06.173 --> 01:40:08.108 
互相投掷彩绘气球

01:40:08.742 --> 01:40:12.779 
我现已使用了今年发布的
新API中的SpriteKit和GameplayKit

01:40:12.946 --> 01:40:16.650 
你可以看到 游戏需要三个主要元素

01:40:16.984 --> 01:40:20.153 
一张地图、一个英雄和游戏设定

01:40:21.021 --> 01:40:25.425 
我已经实现了英雄的移动和动画

01:40:25.492 --> 01:40:29.329 
但毫无疑问 缺失了小岛边界的冲突

01:40:29.396 --> 01:40:30.864 
那么让我们来解决一下

01:40:32.466 --> 01:40:35.869 
打开Xcode对象 看一下源代码

01:40:36.303 --> 01:40:38.872 
我已经写了一些游戏设定行为

01:40:38.939 --> 01:40:42.075 
使用了GameplayKit提供的
GKComponent

01:40:42.142 --> 01:40:43.744 
比如这个战斗组件

01:40:44.111 --> 01:40:49.316 
在Xcode 8中 我可以公开
任何一个类属性

01:40:50.684 --> 01:40:53.587 
是在2D编辑器中定义的类

01:40:53.654 --> 01:40:54.955 
然后我可以自定义

01:40:55.022 --> 01:40:58.325 
在场景中这个行为何时与
一个实体相关联

01:40:59.092 --> 01:41:03.330 
我用了新版的碎片地图编辑器
来创建小岛地图

01:41:03.931 --> 01:41:04.965 
因此在游戏中

01:41:05.032 --> 01:41:08.101 
有三个不同的碎片集

01:41:08.368 --> 01:41:10.704 
分别是沙子、水和草

01:41:11.271 --> 01:41:16.610 
我不仅可以指定内部和外部的碎片

01:41:16.677 --> 01:41:18.679 
还可以引入差异

01:41:18.846 --> 01:41:21.715 
所以这里的这个红边 比如说

01:41:21.782 --> 01:41:25.319 
对于这个独立的碎片图片
如果我想添加一个新外观

01:41:25.385 --> 01:41:27.154 
去掉小石头

01:41:27.221 --> 01:41:30.023 
我只需要把它从Media Library
中拽进来

01:41:30.224 --> 01:41:32.125 
现在这个碎片集就完成了

01:41:32.693 --> 01:41:35.128 
现在让我来展示一下如何使用它

01:41:35.462 --> 01:41:38.165 
那么我们再切换到小岛地图

01:41:40.501 --> 01:41:44.037 
小岛是用新的碎片地图功能创建的

01:41:44.104 --> 01:41:45.439 
由SpriteKit提供的

01:41:45.706 --> 01:41:49.176 
所以要修改它 我只需要
选择碎片地图

01:41:49.243 --> 01:41:50.310 
双击

01:41:50.377 --> 01:41:52.946 
选择激活的碎片

01:41:53.280 --> 01:41:56.350 
现在 我觉得小岛看起来
有点儿太单调

01:41:56.517 --> 01:42:02.022 
要进行更多修改 我只需要
绘制各个游戏关卡

01:42:02.823 --> 01:42:05.626 
Xcode会自动绘制正确的碎片

01:42:05.692 --> 01:42:08.428 
使相邻的元素得以匹配
就这么简单

01:42:08.962 --> 01:42:11.932 
现在我觉得我实现了我想要的
小岛的效果

01:42:11.999 --> 01:42:14.401 
让我们看一下这里的一些
游戏设定元素

01:42:14.668 --> 01:42:20.140 
要武装我们的英雄
让他有一些动作和动画

01:42:20.207 --> 01:42:22.843 
我已经关联了玩家输入组件

01:42:22.910 --> 01:42:24.311 
和动作组件

01:42:24.711 --> 01:42:29.082 
要让玩家待在小岛的边界之内

01:42:29.183 --> 01:42:32.419 
我只需要添加一个冲突组件

01:42:32.719 --> 01:42:35.622 
这样 它会自动创建一个实体

01:42:35.689 --> 01:42:37.591 
为我们的英雄和小岛

01:42:37.658 --> 01:42:40.294 
基于当前设置好的碎片集

01:42:41.261 --> 01:42:44.831 
要使玩家能投掷水球

01:42:44.898 --> 01:42:47.634 
我只需要添加战斗组件

01:42:47.935 --> 01:42:52.773 
请留意一下 战斗组件类是
如何公开健康值的

01:42:52.840 --> 01:42:56.176 
现在是可见的了
我可以给它一个自定义值

01:42:56.243 --> 01:42:59.246 
比如说 我可以设置它的值是2

01:42:59.346 --> 01:43:01.548 
而不是使用默认值1

01:43:02.349 --> 01:43:08.055 
另外 我设置了一个雄蜂投
掷彩绘气球

01:43:08.288 --> 01:43:10.390 
还有一个敌人 在场景中

01:43:10.924 --> 01:43:13.360 
要赋予敌人同样的战斗力

01:43:13.427 --> 01:43:16.663 
捡起彩绘气球并扔向我

01:43:16.997 --> 01:43:19.333 
我要添加同样的战斗组件

01:43:19.566 --> 01:43:21.235 
要让游戏成为一个公平的游戏

01:43:21.301 --> 01:43:23.704 
我会给敌人设置同样的健康
等级 即2级

01:43:23.770 --> 01:43:26.340 
而不是使用默认值1

01:43:27.708 --> 01:43:30.043 
现在 我觉得这个关卡的设置
非常棒

01:43:30.110 --> 01:43:33.213 
让我们运行一下 看一下效果

01:43:34.414 --> 01:43:37.918 
雄蜂会随机投下彩绘气球

01:43:37.985 --> 01:43:40.454 
气球战斗即将打响

01:43:40.521 --> 01:43:42.689 
那么看起来所有的元素都齐了

01:43:43.056 --> 01:43:47.995 
因此在Xcode 8中 可以很轻松
地实现游戏关卡的设置

01:43:48.061 --> 01:43:50.797 
并关联所有游戏设置逻辑

01:43:51.899 --> 01:43:52.833 
相当迅捷

01:43:52.900 --> 01:43:55.369 
因为我用了SpriteKit和
GameplayKit

01:43:55.435 --> 01:43:58.472 
我的游戏可以在所有Apple
平台上顺利运行

01:43:59.173 --> 01:44:01.508 
谢谢大家 现在让我们把舞台
交还给Andreas

01:44:06.446 --> 01:44:07.381 
谢谢Norman

01:44:07.681 --> 01:44:11.418 
好了 让我们快速回顾一下
我们刚谈到的几个重点

01:44:12.553 --> 01:44:14.655 
现在有四个Apple OS平台

01:44:14.721 --> 01:44:17.658 
都有自己的App Store
你可以在里面发布自己的想法

01:44:18.325 --> 01:44:21.862 
而且今天 我们增加了丰
富的新扩展接口

01:44:21.929 --> 01:44:24.965 
可以更深层地连接我们的OS平台

01:44:25.365 --> 01:44:26.567 
也许最重要的是

01:44:26.633 --> 01:44:29.369 
我们建议你考虑创建一
个iMessage App

01:44:29.570 --> 01:44:32.172 
并把你的app与SiriKit整
合在一起

01:44:32.940 --> 01:44:36.210 
但这只是今天我们要发布的
众多API中的两个

01:44:36.877 --> 01:44:38.378 
并且全部支持

01:44:38.445 --> 01:44:41.381 
都由新版Xcode IDE提供

01:44:41.548 --> 01:44:44.084 
Xcode 8的运行平台包括
Mac OS El Capitan

01:44:44.151 --> 01:44:45.118 
和Sierra

01:44:45.219 --> 01:44:48.288 
当然 也支持Swift 3的开发

01:44:49.256 --> 01:44:51.491  
现在 这些技术都可以下载了

01:44:51.558 --> 01:44:53.994  
今天 从WWDC Attendee Portal中

01:44:54.061 --> 01:44:56.730  
那么你可以在今年下半年
捷足先登

01:44:56.797 --> 01:44:59.600  
当我们发布产品时

01:44:59.666 --> 01:45:02.669  
你就可以为你的用户创建
更强大、更独特的应用

01:45:03.770 --> 01:45:06.039 
同时 留意一下新版Swift
Playgrounds app

01:45:06.106 --> 01:45:08.709 
我们将它纳入了iOS X
Developer Preview

01:45:08.775 --> 01:45:10.477 
我想你们一定会获得很多乐趣

01:45:10.544 --> 01:45:12.579 
也许你会考虑创建额外的内容

01:45:12.646 --> 01:45:15.315 
为刚开始学习如何使用Swift
编程的孩子们

01:45:16.650 --> 01:45:18.852 
此次会议中有许多机会

01:45:18.919 --> 01:45:21.021 
来更多地了解我们今天
所发布的一切

01:45:21.088 --> 01:45:24.091 
有100多场研讨会和很多
实践活动

01:45:24.157 --> 01:45:26.894 
你可以跟现场的每个工程师
一对一地进行交流

01:45:26.960 --> 01:45:29.329 
他们会在这里回答你的所有提问

01:45:30.130 --> 01:45:33.066 
我希望你们能尽情享受此次
研讨会 下半周再见