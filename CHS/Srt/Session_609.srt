00:00:19.353 --> 00:00:23.423
SceneKit渲染的进展

00:00:24.925 --> 00:00:25.826
早上好

00:00:28.996 --> 00:00:32.633
欢迎来到
“SceneKit渲染的进展”

00:00:33.634 --> 00:00:36.103
我叫Amaury 很高兴在这里

00:00:36.236 --> 00:00:39.273
为大家讲解如何
让SceneKit再上一个台阶

00:00:39.339 --> 00:00:40.741
利用艺术图形状态

00:00:42.176 --> 00:00:44.077
所以我们今天会讲很多东西

00:00:44.144 --> 00:00:46.647
首先对SceneKit做一个简介

00:00:46.713 --> 00:00:49.616
在讨论渲染的新进展之前

00:00:50.384 --> 00:00:55.422
接下来Jean-Baptiste和Sebastien
会和我一起为大家演示一个很酷的例子

00:00:55.489 --> 00:00:59.059
来解释该例子是如何编写出来
并为大家展示所有新的性能

00:00:59.159 --> 00:01:00.894
比如全新的照相效果

00:01:01.395 --> 00:01:05.732
最后 Nick会为我们讲解
Model I/O的基础

00:01:07.367 --> 00:01:08.402
简而言之

00:01:09.937 --> 00:01:14.875
如你所知 SceneKit是
GameKit下的高级API

00:01:14.942 --> 00:01:16.877
主要应用于3D图形

00:01:17.578 --> 00:01:19.880
它和2D图形的
Spritkit完美结合

00:01:19.947 --> 00:01:23.183
并且构建在Metal和
OpenGL之上

00:01:24.084 --> 00:01:26.687
你可以把SceneKit
应用于各种情况

00:01:26.753 --> 00:01:28.655
把屏幕上的图形进行分散

00:01:29.223 --> 00:01:33.026
仔细想会发现
它们被应用到很多领域

00:01:34.228 --> 00:01:37.764
比如 我们刚引进了
Swift Playgrounds

00:01:38.298 --> 00:01:41.101
SceneKit让其界面更为可视化

00:01:41.168 --> 00:01:46.740
帮助孩子们迈出学习编程的第一步

00:01:48.308 --> 00:01:50.644
在Xcode
我们用SceneKit建立了

00:01:50.711 --> 00:01:53.947
一个创新并极为有用的接口

00:01:54.348 --> 00:01:56.884
帮助你编写应用的视图结构

00:01:58.352 --> 00:02:02.222
在iBooks和iBooks Author里
人们可写出丰富的书本

00:02:02.289 --> 00:02:06.627
利用增强的插图效果 并且是互动型的

00:02:07.828 --> 00:02:10.097
当然SceneKit也被用在游戏上

00:02:11.498 --> 00:02:13.534
最后 但不失其重要性的 谢谢你们

00:02:14.034 --> 00:02:17.871
你们为SceneKit和3D图形
找到了非常多的用户用例

00:02:18.272 --> 00:02:22.075
你们在app store里发布了
成千上万基于SceneKit的应用

00:02:22.242 --> 00:02:23.076
所以谢谢你们

00:02:29.483 --> 00:02:33.854
现在 如你所知 SceneKit
和系统紧密结合

00:02:34.288 --> 00:02:36.924
它和所有Apple技术无缝合作

00:02:37.324 --> 00:02:40.060
它充分利用macOS和iOS平台

00:02:40.527 --> 00:02:42.529
这两个平台已经问世多年

00:02:43.630 --> 00:02:48.569
在去年的WWDC上 我们还在
tvOS上引入了SceneKit

00:02:49.870 --> 00:02:55.375
我们在狐狸例子里所添加的
只是为游戏控制器加了两个端口

00:02:55.642 --> 00:02:58.312
就可以在大屏幕上玩了

00:02:59.313 --> 00:03:02.249
真的非常精彩 能看到同一款游戏

00:03:02.482 --> 00:03:06.353
和代码能在macOS、iOS
和tvOS运行

00:03:07.020 --> 00:03:10.924
今年我们画了一个完整圆 让
SceneKit进入watchOS

00:03:14.094 --> 00:03:14.928
谢谢

00:03:18.432 --> 00:03:22.269
SceneKit应用到
watchOS是一个非常好的机会

00:03:22.336 --> 00:03:24.605
开始思考新互动

00:03:24.671 --> 00:03:27.040
以及在手腕上展现内容的方法

00:03:27.841 --> 00:03:29.343
如你所想象的

00:03:30.310 --> 00:03:33.046
在Apple Watch编程
有很多可讲的内容

00:03:33.213 --> 00:03:35.315
今天无法面面俱到

00:03:35.616 --> 00:03:37.584
但是我们有一个专门的演讲

00:03:37.651 --> 00:03:40.888
星期五的
“Apple Watch游戏技巧”

00:03:41.288 --> 00:03:43.824
你可以了解到更多可用功能

00:03:43.891 --> 00:03:46.827
如何利用SceneKit
SpriteKit和其他技术

00:03:48.428 --> 00:03:50.631
如果你是SceneKit新手
想学习更多

00:03:50.697 --> 00:03:56.470
可随时上网观看过去几年WWDC演讲
我们讲解过基本技巧

00:03:56.570 --> 00:03:59.072
也讲过SceneKit中
非常高级的功能

00:04:00.641 --> 00:04:04.611
好的 让我们开始
看看这个新的渲染技术

00:04:05.646 --> 00:04:09.049
今年 SceneKit把手动渲染

00:04:09.116 --> 00:04:10.584
交到了你们手中

00:04:11.685 --> 00:04:14.087
也就是说 编程者 你们大家

00:04:14.154 --> 00:04:18.192
可以在艺术作品和游戏中
取得惊人的图形效果

00:04:19.625 --> 00:04:23.330
这在SceneKits渲染能力里
是一个显著进步

00:04:23.430 --> 00:04:24.965
自从它问世以来

00:04:25.532 --> 00:04:30.304
我们在3D图形最新高级技巧的基础上
利用了先进的技术

00:04:30.370 --> 00:04:33.540
提供准确的渲染和基于物理着色

00:04:35.275 --> 00:04:38.946
现在 基于物理着色有一些要求

00:04:39.146 --> 00:04:41.715
首先从线性渲染开始

00:04:43.083 --> 00:04:47.721
这里是一个平滑的辐射图 从0到1

00:04:47.788 --> 00:04:50.290
如你所见 显示很完美

00:04:51.124 --> 00:04:52.860
直到你把它压缩

00:04:52.926 --> 00:04:56.730
想储存到8寸的磁盘光学映像里 比如

00:04:57.464 --> 00:05:00.033
可以看到 发生了光度弯曲

00:05:00.133 --> 00:05:04.238
这是因为我们的眼睛对于变化很敏感

00:05:04.304 --> 00:05:05.472
在深色的影响下

00:05:06.473 --> 00:05:12.379
通过伽马编码
可以给该暗圈函数指定更多的值

00:05:13.914 --> 00:05:18.018
比如 这里的图例显示了

00:05:18.085 --> 00:05:22.389
储存原始像素数据和
利用了伽马编码之后的不同

00:05:24.558 --> 00:05:28.161
现在的问题是当着色［听不清］

00:05:28.228 --> 00:05:32.933
所有的光信息和公式
都在一个线性空间表示

00:05:34.234 --> 00:05:37.371
所以在非线性管道中

00:05:37.437 --> 00:05:40.741
只存在鲜艳的颜色数据
在纹理上进行伽马编码后

00:05:41.475 --> 00:05:44.444
并且用线性公式进行处理

00:05:44.511 --> 00:05:48.015
产生的浓缩结果会被
写入某个纹理或帧缓存中

00:05:48.882 --> 00:05:51.018
如你所想 这是错误的

00:05:52.019 --> 00:05:58.091
为了最终的图片显示正确
所有的操作都需要有足够的空间

00:05:59.760 --> 00:06:05.699
作为一个演示例子
这是伽马空间内光照场景

00:06:06.466 --> 00:06:09.803
这是同样的场景
以线性空间的着色显示

00:06:10.971 --> 00:06:13.740
如果比较两者 会发现光照如何消退

00:06:13.974 --> 00:06:17.444
以及边缘变得粗糙 在线性渲染里

00:06:18.745 --> 00:06:22.916
线性渲染对于基于物理的渲染十分关键

00:06:22.983 --> 00:06:26.520
它实际上被应用于
所有SceneKit光照模型

00:06:26.587 --> 00:06:28.689
因为从数学角度上很正确

00:06:30.757 --> 00:06:35.062
如你所知
颜色是今年WWDC的重要话题

00:06:35.128 --> 00:06:39.032
除了伽马纠正

00:06:39.099 --> 00:06:42.769
SceneKit［听不清］
自动管理颜色和线性渲染

00:06:44.972 --> 00:06:45.973
这代表了什么？

00:06:46.473 --> 00:06:49.476
它意味着指定给一个纹理的颜色配置

00:06:49.543 --> 00:06:50.844
现在将会［听不清］

00:06:51.678 --> 00:06:54.948
任何操作 从发生在图像从磁盘

00:06:55.015 --> 00:06:57.918
被加载 到传给系统那一刻

00:06:57.985 --> 00:06:59.920
可以显示在屏幕上

00:06:59.987 --> 00:07:02.623
我们会保持颜色数据的完整性

00:07:04.057 --> 00:07:08.795
基于SceneKit的应用
会产生高度的色彩准确性

00:07:08.862 --> 00:07:11.298
和某些专业照片编辑应用一样

00:07:12.666 --> 00:07:16.336
如今 如你所知
［听不清］地图和普通地图

00:07:16.870 --> 00:07:21.375
都不再显示被存储为色彩的原始数据

00:07:21.775 --> 00:07:24.912
SceneKit知道这一点
它不会为此类图像配色

00:07:26.013 --> 00:07:29.149
为了帮助你解决这一点
有一个全新的很棒的性能

00:07:29.216 --> 00:07:32.986
在Xcode 8资产目录里
就是纹理集合

00:07:34.388 --> 00:07:40.227
在纹理集合里 可以指定一个图像
显示色彩数据或者原始数据

00:07:40.294 --> 00:07:44.731
然后Xcode
可以自动把这些图像转换为

00:07:44.798 --> 00:07:48.368
CPU和GPU高效纹理格式

00:07:49.269 --> 00:07:52.539
关于这点 午饭后我们还有一个演讲

00:07:52.606 --> 00:07:53.974
“用广色域来工作”

00:07:54.241 --> 00:07:56.910
Metal团队将会讲解更多相关细节

00:07:58.979 --> 00:08:04.218
除了纹理 色彩管理也应用于色彩对象

00:08:05.252 --> 00:08:08.121
色彩组件不能再假定为sRGB

00:08:08.889 --> 00:08:11.191
如果要变成新建色彩

00:08:11.258 --> 00:08:14.428
使用正确的构造器非常重要

00:08:15.495 --> 00:08:18.665
这里展示了两个色彩对象

00:08:19.032 --> 00:08:21.568
一个叫Display P3
另一个叫sRGB

00:08:21.902 --> 00:08:24.271
它们是由同一个组件构建出来的

00:08:26.173 --> 00:08:27.808
当使用色彩选择器时

00:08:27.875 --> 00:08:30.310
请注意选择的色彩空间

00:08:30.377 --> 00:08:33.780
菜单上可以选择不同的色彩空间

00:08:34.280 --> 00:08:38.684
包括和设备无关的
比如Display P3和sRGB

00:08:39.352 --> 00:08:42.222
还有一个很方便的选项显示数值

00:08:42.289 --> 00:08:44.892
以浮点数显示 而不是整数

00:08:44.958 --> 00:08:47.461
这样它们可以方便地复制粘贴到代码中

00:08:48.395 --> 00:08:50.998
讲到这里 如你所知

00:08:51.565 --> 00:08:53.867
着色修改器是
SceneKit非常优秀的性能

00:08:54.034 --> 00:08:57.004
它允许自定义渲染

00:08:58.005 --> 00:09:01.708
如我所说 今年着色出现在线性空间

00:09:02.376 --> 00:09:05.212
所以你必须确保把色彩

00:09:05.279 --> 00:09:08.148
转换为线性扩展sRGB色彩空间

00:09:08.549 --> 00:09:11.318
在这些组件被用来［听不清］

00:09:13.520 --> 00:09:16.323
关于向后兼容性要注意几点

00:09:18.892 --> 00:09:22.796
线性渲染和色彩管理会自动启动

00:09:22.863 --> 00:09:25.732
当你把应用和
新的SDKs连接起来时

00:09:26.333 --> 00:09:28.869
启动不会产生性能下降

00:09:29.002 --> 00:09:32.506
但是会显著改变旧场景的外观

00:09:32.940 --> 00:09:37.711
举例说明 这是去年的演示
并没有使用线性渲染

00:09:38.478 --> 00:09:41.582
如果对其进行重组会变成这样

00:09:42.716 --> 00:09:46.220
当然 纹理 光照和阴影修改器

00:09:46.286 --> 00:09:48.822
可以用线性渲染重新进行改写

00:09:49.523 --> 00:09:53.861
但是如果想把应用部署到旧版本的系统

00:09:53.927 --> 00:09:57.264
或者出于某种原因
想在色彩管理中更新线性渲染

00:09:57.731 --> 00:09:59.066
有一个方法可以实现

00:10:00.467 --> 00:10:04.071
你可以通过指定一个关键字

00:10:04.137 --> 00:10:05.839
在应用的info.plist文件

00:10:07.641 --> 00:10:10.210
将会显示广域内容

00:10:10.544 --> 00:10:13.714
如你所知 广域色彩空间

00:10:13.780 --> 00:10:17.851
比如存在扩展sRGB

00:10:17.918 --> 00:10:20.988
对现代硬件设备来说非常重要

00:10:22.723 --> 00:10:26.126
新款带Retina显示的
iPad Pro和iMac

00:10:26.193 --> 00:10:29.229
有广域显示
SceneKit自动支持

00:10:29.997 --> 00:10:35.068
你只需要取出广域内容
比如纹理或色彩

00:10:35.435 --> 00:10:38.572
SceneKit可以透明化进入其中

00:10:42.309 --> 00:10:46.747
广域纹理和帧缓存
需要更多的内存存储该数据

00:10:46.813 --> 00:10:49.983
从而会带来更多的带宽消耗

00:10:50.050 --> 00:10:52.286
如果产生任何性能问题

00:10:52.386 --> 00:10:56.390
我们提供了一种重新上传的方法
［听不清］

00:11:01.528 --> 00:11:04.464
下面来看一下色域展示示例代码

00:11:05.165 --> 00:11:08.402
是和Cocoa和
Cocoa Touch团队合作编写

00:11:09.236 --> 00:11:12.272
它是一个基于同步的应用 允许

00:11:12.406 --> 00:11:15.676
可以在色域组件外观察

00:11:15.742 --> 00:11:19.213
这非常有用 因为在广域显示里

00:11:19.279 --> 00:11:21.949
你可以看到该显示情况

00:11:22.049 --> 00:11:24.818
因为你可以模拟一个非广域显示

00:11:26.453 --> 00:11:29.122
从而可以学习利用广域

00:11:29.189 --> 00:11:35.062
以及如何在色彩空间内转换色彩组件

00:11:35.128 --> 00:11:37.130
再次说明
今天下午我们会有一个精彩演讲

00:11:38.398 --> 00:11:40.467
也可以应用到准确渲染

00:11:40.534 --> 00:11:44.271
也是基于物理渲染的前提

00:11:44.338 --> 00:11:45.572
基于物理渲染

00:11:45.639 --> 00:11:49.276
什么是基于物理渲染 为什么要用它

00:11:50.010 --> 00:11:53.714
人们总是认为精细的场景

00:11:53.780 --> 00:11:57.017
是带有很多细节模块的场景

00:11:57.284 --> 00:11:58.652
的确是这样

00:11:59.253 --> 00:12:02.322
但是着色才能让对象有形

00:12:03.257 --> 00:12:06.793
在屏幕上看到的
这幅图曾经是一组多边形

00:12:07.694 --> 00:12:12.232
着色是为屏幕上每个细节
找到正确色彩的过程

00:12:12.466 --> 00:12:18.071
所有的高亮 阴影和深度感
都是从着色而来

00:12:19.940 --> 00:12:24.411
着色就是那个神奇的操作
能够让场景栩栩如生

00:12:25.412 --> 00:12:26.747
工作原理是什么？

00:12:27.381 --> 00:12:30.317
首先有一个光源发出的光

00:12:30.984 --> 00:12:33.086
当光碰到对象

00:12:33.153 --> 00:12:37.591
会根据表面的属性跟物质发生相互作用

00:12:37.658 --> 00:12:41.895
光发生反射
进入人眼或本例中的一台相机

00:12:43.797 --> 00:12:47.768
光和物质之间的相互作用非常复杂

00:12:48.368 --> 00:12:50.771
多年来很多数学模型

00:12:50.838 --> 00:12:53.373
都在尝试对它进行最好的解释

00:12:54.541 --> 00:12:58.679
基于物理渲染是光传输的模拟

00:12:58.745 --> 00:13:01.248
基于这种数学模型之上

00:13:01.315 --> 00:13:04.751
它们考虑到了光和物质的物理性质

00:13:05.385 --> 00:13:08.155
但是 如你所知
SceneKit是高级API

00:13:08.288 --> 00:13:12.092
我们想让每个人
都从该全新光照模型受益

00:13:12.693 --> 00:13:15.596
所以我们公开了一个超为简单的API

00:13:15.963 --> 00:13:19.333
可以让你利用基于美术师们热衷的
物理渲染技术

00:13:20.400 --> 00:13:24.371
本次演讲结尾 你可以从该渲染

00:13:24.438 --> 00:13:27.341
也是标准渲染 变成基于物理渲染

00:13:29.910 --> 00:13:34.081
在SceneKit
我们从两个角度导出基于物理渲染

00:13:34.615 --> 00:13:38.585
首先 基于物理材料 以及
基于物理光照

00:13:40.387 --> 00:13:43.457
基于物理材料

00:13:43.524 --> 00:13:45.292
首先 基于物理材料

00:13:47.160 --> 00:13:50.097
这里描述了表面上的一点

00:13:50.163 --> 00:13:53.166
通常指示方向是空间

00:13:54.334 --> 00:13:57.304
当光照碰到该点 发生两种反射

00:13:58.172 --> 00:14:00.707
漫反射和镜面反射

00:14:02.042 --> 00:14:04.444
漫反射通过

00:14:04.511 --> 00:14:06.280
回应进入表面下面的光

00:14:06.346 --> 00:14:09.316
进行多次反射 并射向各个方向

00:14:09.383 --> 00:14:10.617
看上去均匀

00:14:12.019 --> 00:14:16.924
漫反射的色彩是对象的底色的反照率

00:14:17.658 --> 00:14:20.928
所以在SceneKit中
设计基于物理材料的接口时

00:14:20.994 --> 00:14:23.664
我们需要用到反照率映射图

00:14:24.698 --> 00:14:27.801
镜面反射不需要如此

00:14:29.069 --> 00:14:32.906
镜面反射由从表面弹回的光组成

00:14:32.973 --> 00:14:35.375
所以它的颜色是光源射线的颜色

00:14:36.543 --> 00:14:38.245
这是我们称作的立方体映射图

00:14:38.312 --> 00:14:42.149
这是六个空间的集合

00:14:42.216 --> 00:14:44.351
代表3D空间位置的周边环境

00:14:45.619 --> 00:14:48.055
当我们把一个全镜面对象

00:14:48.121 --> 00:14:52.159
放入该环境 可以看到它好比一个镜子

00:14:52.893 --> 00:14:56.463
我们来举一个更实际的例子 用塑料球

00:14:57.264 --> 00:14:59.600
可以看出 它不是一个完美的镜子

00:15:00.000 --> 00:15:02.503
中间部分反射很暗

00:15:02.569 --> 00:15:06.039
越向边缘靠近越亮

00:15:06.440 --> 00:15:09.676
实际上在高角度 所有的光都被反射

00:15:11.111 --> 00:15:14.448
不是所有材料都有相同的反射量

00:15:14.915 --> 00:15:20.254
上方是代表反射值的曲线

00:15:20.320 --> 00:15:23.724
从0到90度入射角的函数

00:15:24.391 --> 00:15:26.760
可以看到这些反射值

00:15:26.827 --> 00:15:29.663
从0到45度时几乎保持不变

00:15:30.030 --> 00:15:33.934
我们实际上可以利用该值重建整条曲线

00:15:34.768 --> 00:15:36.803
金子是一个很有意思的例子

00:15:37.204 --> 00:15:40.040
因为它有不同的反射值

00:15:40.107 --> 00:15:42.242
对红色 绿色和蓝色组件

00:15:43.577 --> 00:15:46.513
最后要注意的是 金属

00:15:46.580 --> 00:15:51.185
比如铝或金 反射值较高

00:15:51.251 --> 00:15:56.356
而非金属或绝缘体的反射值较低

00:15:57.958 --> 00:16:01.061
反射值的区别很重要

00:16:01.128 --> 00:16:02.329
对于对象的最终显示

00:16:02.829 --> 00:16:05.866
所以在SceneKit中
我们想要公开一张金属性映射图

00:16:06.400 --> 00:16:12.272
显示对象的哪些部分是金属的
哪些不是

00:16:13.841 --> 00:16:17.544
所以除了不同的反射值以外

00:16:17.945 --> 00:16:21.748
要注意金属也会吸收表面之下的所有光

00:16:21.815 --> 00:16:24.251
而绝缘体将会发生散射

00:16:24.651 --> 00:16:26.320
两者的视觉效果

00:16:27.654 --> 00:16:33.827
是金属有广泛的镜面反射 没有漫反射

00:16:33.894 --> 00:16:36.763
绝缘体则有非常多的漫反射

00:16:36.830 --> 00:16:40.901
镜面反射几乎只能在高角度看到

00:16:42.302 --> 00:16:47.441
在SceneKit我们会重新使用
发散的Metal属性

00:16:47.875 --> 00:16:53.447
储存金属的反射值和绝缘体的反照率

00:16:54.581 --> 00:16:58.051
对于绝缘体的反射值

00:16:58.118 --> 00:17:01.054
我们只使用一个全局常量

00:17:03.257 --> 00:17:06.993
并且重用金属属性diffuse

00:17:07.060 --> 00:17:09.429
我们从其他［听不清］取得

00:17:10.597 --> 00:17:15.469
最后我要讲的一点是表面粗糙度

00:17:16.869 --> 00:17:19.940
你们知道 没有完全光滑的表面

00:17:20.473 --> 00:17:23.577
从微观来看 总有小的凸起

00:17:24.044 --> 00:17:26.713
和裂纹将影响镜面反射

00:17:27.981 --> 00:17:33.053
微观表面越粗糙 反射越模糊

00:17:33.120 --> 00:17:36.723
因为光的反射线不再对齐

00:17:37.558 --> 00:17:40.827
所以在SceneKit里
也会提供粗糙度映射图

00:17:40.894 --> 00:17:46.466
将会显示表面的哪些部分是粗糙的
哪些部分是光滑的

00:17:46.934 --> 00:17:48.936
这是一张灰度图

00:17:51.505 --> 00:17:56.910
可以看出如何分开三个基本属性

00:17:57.411 --> 00:17:59.713
每一个属性都有明确的含义

00:17:59.780 --> 00:18:03.851
都是来自表面的属性

00:18:04.751 --> 00:18:08.255
在SceneKit中
建立基于物理材料很简单

00:18:08.722 --> 00:18:12.392
新建一个材料 设置其光照模型

00:18:12.459 --> 00:18:14.461
为新的基于物理光照模型

00:18:14.928 --> 00:18:16.530
最后提供映射图

00:18:17.831 --> 00:18:19.733
来看一个例子

00:18:19.800 --> 00:18:23.036
从一台矿车开始 它只有一张漫反射映射图

00:18:23.971 --> 00:18:25.706
然后添加粗糙度映射图

00:18:25.772 --> 00:18:27.908
比如 看一下煤

00:18:28.675 --> 00:18:32.479
煤很粗糙 所以没有［听不清］

00:18:33.647 --> 00:18:36.183
随后我们加一个金属性映射图

00:18:36.250 --> 00:18:39.186
比如 看看铁轨和车轮

00:18:41.622 --> 00:18:42.990
再举一个例子

00:18:43.056 --> 00:18:44.491
这是一辆消防车

00:18:45.259 --> 00:18:47.160
我们还是从漫反射映射图开始

00:18:47.895 --> 00:18:49.997
现在添加金属性映射图

00:18:51.565 --> 00:18:53.267
最后是粗糙度映射图

00:18:53.333 --> 00:18:56.170
比如 看看轮胎

00:18:59.139 --> 00:19:02.109
我想要指出一点

00:19:02.809 --> 00:19:05.812
对于金属度 粗糙度和环境闭合映射图

00:19:06.280 --> 00:19:08.148
请使用灰度图像

00:19:08.582 --> 00:19:11.952
使用红绿蓝色彩通道

00:19:12.019 --> 00:19:13.687
只会造成内存浪费

00:19:13.754 --> 00:19:15.956
如果还添加另一个函数 浪费更大

00:19:16.924 --> 00:19:20.594
此外 如果想在整个表面使用相同的值

00:19:20.661 --> 00:19:22.162
可以利用色彩对象

00:19:22.729 --> 00:19:27.234
或更好的方法 因为对于这些金属属性
支持数量已知

00:19:29.169 --> 00:19:33.207
我们看看如何建立简单而高级的API

00:19:33.273 --> 00:19:35.475
从而建立各种各样的材料

00:19:36.109 --> 00:19:37.177
这是同一个对象

00:19:37.911 --> 00:19:40.581
在一个轴上 改变粗糙度值

00:19:40.914 --> 00:19:44.251
在另一个轴上 改变粗糙度值

00:19:46.520 --> 00:19:50.290
我们曾经说过 会导出基于物理渲染

00:19:51.091 --> 00:19:54.027
来看一下基于物理光照

00:19:54.895 --> 00:19:57.831
在SceneKit光照分为三类

00:19:58.966 --> 00:20:02.302
首先是基于图像光照 IBL,

00:20:02.936 --> 00:20:05.539
然后是光照探测 最后是点光源

00:20:06.773 --> 00:20:08.575
基于图像关照

00:20:10.444 --> 00:20:14.581
我说过
可以利用一个立方体映射图描述

00:20:14.781 --> 00:20:17.150
3D空间位置的周边环境

00:20:18.785 --> 00:20:20.621
当对表面上的一点进行着色时

00:20:20.687 --> 00:20:24.725
我们可以把终点上方当做完结点
根据它的平均值

00:20:25.125 --> 00:20:27.828
和色彩的正确光照信息

00:20:27.895 --> 00:20:29.863
从立方体映射图中获取的

00:20:30.731 --> 00:20:33.033
举例说明 这里有一个对象

00:20:33.100 --> 00:20:36.236
只利用图像光照进行照明

00:20:36.303 --> 00:20:37.771
在该场景中没有光照

00:20:38.272 --> 00:20:39.406
你可看到根据立方体映射图的改变

00:20:39.473 --> 00:20:42.876
如何显著影响了对象的外观

00:20:44.344 --> 00:20:47.648
对场景内所有对象利用基于图像光照

00:20:47.714 --> 00:20:50.684
将会带来一致的观感 协调合作

00:20:52.085 --> 00:20:55.322
在SceneKit里
使用基于图像光照非常简单

00:20:55.923 --> 00:20:59.226
我们为场景添加一个
“lightingEnvironment”属性

00:20:59.927 --> 00:21:02.329
只需把它的内容设置为
一个立方体映射图

00:21:03.230 --> 00:21:06.533
很棒的是它和background属性
完美结合

00:21:07.801 --> 00:21:14.074
比如 如果取一个对象
把其background

00:21:14.141 --> 00:21:16.276
和lightingEnvironment属性
都设为相同的图片

00:21:16.343 --> 00:21:19.346
就可以在上下文中显示一个对象

00:21:21.348 --> 00:21:26.320
立方体映射图
可以显示远处的环境和艺术

00:21:27.487 --> 00:21:29.356
当对表面上的一点进行着色时

00:21:29.423 --> 00:21:32.960
有可能这个环境不可见

00:21:33.026 --> 00:21:37.097
因为你正处于山洞
或它们之间有别的对象

00:21:37.798 --> 00:21:41.268
基于图像光照应该要考虑到这一点

00:21:41.335 --> 00:21:44.705
所以对封闭对象来说效果没那么好

00:21:45.539 --> 00:21:48.542
还好我们对此有解决方案 光照探测器

00:21:49.543 --> 00:21:51.345
光照探测器

00:21:51.411 --> 00:21:55.349
光照探测器是面向场景的局部光照

00:21:55.415 --> 00:21:59.753
它们捕捉局部漫反射

00:22:00.420 --> 00:22:05.926
当着色表面某点时
可以找到四个最近的光照探测器

00:22:05.993 --> 00:22:08.929
然后从这些探测器添加光照

00:22:10.397 --> 00:22:13.567
如我所说 光照探测器
它们是局部光源

00:22:13.634 --> 00:22:15.536
它们可以被认为是闭合的

00:22:16.370 --> 00:22:18.405
可以用这种方法实现

00:22:18.472 --> 00:22:20.741
它们重量轻 效率高

00:22:21.341 --> 00:22:24.044
可以在场景中放置很多光照探测器

00:22:24.311 --> 00:22:25.812
我们推荐这么做

00:22:26.680 --> 00:22:30.484
因为探测器越多 就越精细

00:22:30.551 --> 00:22:33.287
获取的局部光照信息就越准确

00:22:34.855 --> 00:22:36.490
建立光照探测器很简单

00:22:37.090 --> 00:22:39.359
新建光照 修改其类型

00:22:40.093 --> 00:22:41.962
可以编写代码实现

00:22:42.396 --> 00:22:44.865
也可在Xcode SceneKit
的场景编辑器里

00:22:46.300 --> 00:22:51.505
和立方体映射图一样
光照探测器捕捉静态光照信息

00:22:52.005 --> 00:22:56.210
该信息可以被很简单地传入探测器

00:22:56.276 --> 00:22:59.513
只需用到这个API的
Xcode场景编辑器

00:23:00.781 --> 00:23:06.854
我们看了如何利用IBL或光照探测器

00:23:06.920 --> 00:23:09.256
在场景中进行间接照明

00:23:09.823 --> 00:23:12.125
当然也需要直接照明

00:23:12.192 --> 00:23:14.595
还是可以访问任何别的光照

00:23:15.762 --> 00:23:19.867
如全向 定向或聚光灯

00:23:19.933 --> 00:23:21.668
都可以运用在基于物理渲染中

00:23:21.735 --> 00:23:26.507
实际上我们还有［听不清］
可以进行更好的设置

00:23:28.075 --> 00:23:30.844
比如
添加“intensity”属性

00:23:31.879 --> 00:23:37.050
光照强度通过每千瓦的流明数表示

00:23:37.117 --> 00:23:39.553
和灯泡是一个量级

00:23:40.587 --> 00:23:45.392
我们还添加了温度属性 单位是开尔文

00:23:45.459 --> 00:23:47.361
可以用该单位区分颜色

00:23:48.795 --> 00:23:52.999
一个新的性能
我们添加了新的光照种类 IES光照

00:23:54.401 --> 00:23:59.306
IES光照 即光度学光照
可以用于任何衰减形状

00:24:00.574 --> 00:24:03.610
当聚光灯或全向光

00:24:03.677 --> 00:24:07.080
有一个非常对称的衰减曲线

00:24:07.147 --> 00:24:11.718
IES光照可以更好积累剧场光照的行为

00:24:12.653 --> 00:24:15.222
比如可以照一个锥形

00:24:15.289 --> 00:24:16.857
也可以照一个阴影

00:24:17.391 --> 00:24:19.726
如此种种 根据光源的形状

00:24:20.794 --> 00:24:24.498
在SceneKit里
建立光度学光照很简单

00:24:24.865 --> 00:24:26.300
同样 新建光照

00:24:26.366 --> 00:24:27.568
修改类型属性

00:24:28.402 --> 00:24:32.573
最后提供一个URL 放入配置文件中

00:24:32.639 --> 00:24:36.810
可以比如 从生产商网站上直接下载

00:24:38.812 --> 00:24:43.517
快速复习一下
我们看到在SceneKit中

00:24:43.584 --> 00:24:45.953
新建基于物理材料多么简单

00:24:46.019 --> 00:24:50.190
所有这些属性都是
从表面属性中衍生出来

00:24:50.257 --> 00:24:52.392
非常容易理解

00:24:52.459 --> 00:24:56.096
以及如何利用光照在
基于物理的材料之上

00:24:57.397 --> 00:25:01.969
请欢迎Jean-Baptiste
和Sebastien做精彩的演示

00:25:04.104 --> 00:25:05.205
谢谢你 Amaury

00:25:05.272 --> 00:25:10.811
为大家做了关于SceneKit的
全新渲染技术的演讲

00:25:12.746 --> 00:25:16.950
我们在实际操作中看一下
Xcode场景编辑器

00:25:17.718 --> 00:25:21.154
如大家所见
Amaury演示的几乎一切

00:25:21.221 --> 00:25:26.760
都可以在Xcode
场景编辑器里直接可用

00:25:27.961 --> 00:25:33.333
可以调整属性 实时观察结果

00:25:34.067 --> 00:25:40.908
这里有一个很简单的场景
卡车上只有一个光照

00:25:41.608 --> 00:25:45.112
打开材料检查器

00:25:47.314 --> 00:25:50.083
该对象只有两个材料

00:25:50.717 --> 00:25:53.120
一个车身 一个配件 等等

00:25:53.187 --> 00:25:55.489
选中这两个材料

00:25:56.623 --> 00:25:58.926
继续采用布林光照模型

00:25:58.992 --> 00:26:01.862
切换到基于物理光照模型

00:26:01.929 --> 00:26:05.966
把两个材料设成金属

00:26:07.167 --> 00:26:09.102
可以看到有一个问题

00:26:09.169 --> 00:26:13.140
因为我们没看到环境反射

00:26:13.540 --> 00:26:17.110
打开场景检查器

00:26:18.312 --> 00:26:20.781
我们必须要为项目设置光照环境

00:26:21.448 --> 00:26:24.218
为此我要使用立方体映射图

00:26:25.719 --> 00:26:30.290
比如 该停车场立方体映射图

00:26:33.160 --> 00:26:34.494
作为光照环境

00:26:41.768 --> 00:26:45.138
接下来将集中讲解这三个主要的

00:26:45.205 --> 00:26:47.241
基于物理光照模型的属性

00:26:48.208 --> 00:26:50.410
现在来看粗糙度值

00:26:51.445 --> 00:26:54.982
粗糙度显示表面有多光滑

00:26:55.182 --> 00:26:58.719
可以看到

00:27:00.554 --> 00:27:05.559
表面越粗糙 显示越模糊

00:27:06.994 --> 00:27:10.831
如果把粗糙度值调到近1

00:27:12.833 --> 00:27:14.568
反射很模糊

00:27:14.635 --> 00:27:17.604
当值到达1时 几乎没有反射

00:27:20.474 --> 00:27:24.645
如果调回0 表面就非常光滑

00:27:27.881 --> 00:27:30.651
如你所见 一切

00:27:30.717 --> 00:27:33.287
整个环境都在金属里反射

00:27:36.290 --> 00:27:40.661
我只用一个常量值代表粗糙度

00:27:41.662 --> 00:27:46.667
然后为对象的每一个部分指定一个值

00:27:46.733 --> 00:27:48.802
因此我需要一张粗糙度映射图

00:27:49.136 --> 00:27:51.271
为车体提供一张粗糙度映射图

00:27:59.847 --> 00:28:01.748
以及一张配件粗糙度映射图

00:28:02.449 --> 00:28:05.219
对于金属度也是一样操作

00:28:05.285 --> 00:28:08.856
我们需要指定对象的哪些部分是金属
哪些不是

00:28:08.922 --> 00:28:10.858
所以我们需要提供金属度映射图

00:28:11.291 --> 00:28:15.696
设定配件金属度映射图

00:28:17.698 --> 00:28:18.599
还有不同的图

00:28:22.803 --> 00:28:23.670
给车体

00:28:24.404 --> 00:28:29.076
如你所见 对象的车体部分是非金属

00:28:29.142 --> 00:28:33.847
前面的散热器格则完全是金属

00:28:38.619 --> 00:28:40.354
最后是添加反照率

00:28:49.296 --> 00:28:50.197
就完成了

00:28:55.335 --> 00:28:59.072
就这样 我们为该卡车进行了
完整的基于物理渲染

00:28:59.139 --> 00:29:03.577
现在切换到场景编辑器
修改立方体映射图

00:29:04.211 --> 00:29:08.749
比如
这个都是树的光照环境的立方体地图

00:29:09.216 --> 00:29:10.784
可以设定为背景

00:29:13.554 --> 00:29:14.388
就这样

00:29:15.222 --> 00:29:18.025
如你所見

00:29:18.091 --> 00:29:22.963
新SceneKit场景细节的
使用十分简单

00:29:23.330 --> 00:29:26.867
为了说明这种渲染操作

00:29:26.934 --> 00:29:30.504
我们编写了一个很酷的演示
现在放给大家

00:29:31.872 --> 00:29:34.241
Sebastien将进行讲解

00:29:34.741 --> 00:29:35.576
大家好

00:29:38.145 --> 00:29:39.179
谢谢

00:29:40.647 --> 00:29:44.184
很高兴为大家介绍
今年的新的毛茸茸朋友

00:29:44.451 --> 00:29:45.986
Bub Bub是一头獾

00:29:46.086 --> 00:29:47.487
它开着一台采矿车

00:29:47.921 --> 00:29:52.292
它要采集珠宝 用于加速

00:29:54.394 --> 00:29:57.331
你看到的所有场景都采用了新的
SceneKit渲染技术

00:29:58.332 --> 00:30:01.268
所有的材料都是基于物理 光照也是

00:30:02.202 --> 00:30:04.338
我们还采用了平常的

00:30:05.038 --> 00:30:11.845
SceneKit的属性
比如动作 动画

00:30:11.912 --> 00:30:15.082
和以前有的对象

00:30:17.251 --> 00:30:21.555
这是Swift应用 可在macOS
iOS和tvOS上运行

00:30:22.689 --> 00:30:27.394
都完全用Swift编写
大概有700行的代码

00:30:28.462 --> 00:30:31.331
沿着轨道我们安置了光照探测器

00:30:31.798 --> 00:30:34.835
考虑到局部照明的改变

00:30:36.036 --> 00:30:40.674
请注意光照改变 当进入山洞或隧道时

00:30:41.942 --> 00:30:48.949
还加入了新的特效 比如运动模糊

00:30:49.283 --> 00:30:53.220
当Bub像这样抓到一个加速奖品时
就可以看到

00:30:55.622 --> 00:30:59.793
我们有一个HGI相机
这就是为什么光照发生改变

00:30:59.860 --> 00:31:02.896
当有亮光或环境改变时

00:31:03.931 --> 00:31:08.101
我们还采用IDL（交互式数据语言）
编写光照环境

00:31:09.469 --> 00:31:13.006
还有一些新的 我们喜欢的运动模糊

00:31:14.274 --> 00:31:18.645
当有亮光时 会有绽放效果

00:31:20.781 --> 00:31:23.951
所有的材料 你所看到的
都完全是PBR效果

00:31:24.384 --> 00:31:26.553
对水晶是全自由反射

00:31:26.620 --> 00:31:29.423
对所有的奖品和宝石也是如此

00:31:30.724 --> 00:31:32.492
在这里又看到了照明变化

00:31:34.094 --> 00:31:36.964
色调映射实现了这一切 谢谢

00:31:42.135 --> 00:31:43.770
我们现在来看幻灯片

00:31:45.172 --> 00:31:47.040
我会再讲解一些关于这个演示的内容

00:31:48.141 --> 00:31:52.346
首先 今年我们十分高兴告诉大家的是

00:31:52.412 --> 00:31:54.948
和往年一样 该演示是一个简单代码

00:31:55.382 --> 00:31:57.784
是的 谢谢

00:32:00.187 --> 00:32:04.358
大家可以在开发者网站上下载所有代码

00:32:04.625 --> 00:32:08.896
调试它 检查场景代码
看我们如何编写

00:32:09.129 --> 00:32:12.065
大约700行的Swift代码

00:32:12.132 --> 00:32:16.003
我们认为代码很容易理解
希望你们能够欣赏所见

00:32:16.069 --> 00:32:18.572
并从中学到一些东西

00:32:20.174 --> 00:32:25.679
今年我们决定 关于演示
我们和美术师们进行了讨论

00:32:26.380 --> 00:32:32.653
我们拟定了一些草稿
考虑已有的设计理念

00:32:33.353 --> 00:32:36.990
当我们就设计理念和流程达成一致时

00:32:37.057 --> 00:32:39.860
美术师开始构建模型世界

00:32:40.360 --> 00:32:44.898
这是一个互动的过程 我们非常需要

00:32:45.165 --> 00:32:48.035
能够在模型正在构建时取得其信息

00:32:48.101 --> 00:32:52.940
并马上开始编程
而不用等待最终的资产

00:32:54.107 --> 00:32:56.043
所以在SceneKit中
我们有一个自定义工具

00:32:56.109 --> 00:33:00.747
在命令行工具里
充分利用SceneKit的强大

00:33:01.215 --> 00:33:06.687
为了采用DAE文件里的工具
单位转换为米

00:33:06.753 --> 00:33:09.923
且它们可在场景里自动放置光照探测器

00:33:09.990 --> 00:33:11.792
因为有200多个光照探测器

00:33:11.859 --> 00:33:16.530
我们不想每一次场景转换时
需要手动安置它们

00:33:19.633 --> 00:33:21.802
我们采用了基于图像光照

00:33:22.202 --> 00:33:25.239
所以我们有立方体映射图作为背景图片

00:33:25.305 --> 00:33:27.808
另一张立方体映射图作为光照环境

00:33:27.875 --> 00:33:30.310
我们采用了光照环境添加反射

00:33:30.377 --> 00:33:32.713
如你所见 对于户外场景效果非常好

00:33:34.648 --> 00:33:36.483
我们还采用了光照探测器

00:33:36.550 --> 00:33:40.087
它们显示在Xcode当中
你可以看到它们

00:33:40.354 --> 00:33:41.822
我们对它们进行了高亮显示

00:33:41.889 --> 00:33:44.625
可以看到只从这个视图上就已经有
很多光照探测器

00:33:44.691 --> 00:33:46.994
可以想象整个场景中用了多少

00:33:47.594 --> 00:33:52.399
自定义工具把它们放入环境 开始计算

00:33:53.300 --> 00:33:55.402
也可以在Xcode中手动实现

00:33:55.702 --> 00:33:59.573
但是 当然 光照探测器用的越多
就会越沉闷

00:34:00.440 --> 00:34:01.542
它对室内场景很重要

00:34:01.608 --> 00:34:05.879
但它也为户外场景视图
添加了很好的触摸效果

00:34:05.946 --> 00:34:08.916
来检测场景中的微小变化

00:34:11.217 --> 00:34:13.853
我们还对室内场景添加了光照映射图

00:34:13.920 --> 00:34:17.623
因为它覆盖了光照环境

00:34:17.690 --> 00:34:21.094
这对山洞非常重要
因为光照在山洞里非常不同

00:34:21.161 --> 00:34:23.730
我们采用探测器和光照映射图

00:34:23.797 --> 00:34:26.567
在该场景中改变了光照和氛围

00:34:28.034 --> 00:34:32.371
当然我们也采用了正常的映射图
为模型添加细节

00:34:33.639 --> 00:34:36.710
我们还采用了环境闭合映射图

00:34:36.777 --> 00:34:40.880
产生效果更好的光照视图和渲染

00:34:42.815 --> 00:34:45.918
我们采用了一个点光源来模拟太阳

00:34:46.186 --> 00:34:48.021
在场景中天空的高处

00:34:48.088 --> 00:34:51.891
我们利用它建立动态阴影
并加强全局光照

00:34:54.293 --> 00:34:59.399
所有在演示中看到的材料都是
100%的基于物理材料

00:35:00.067 --> 00:35:05.205
所以有椰子树在环境反射下的逼真效果
水晶也是如此

00:35:06.073 --> 00:35:09.076
讲到水晶
这是我们编写非常简单的材料

00:35:09.476 --> 00:35:12.779
它没有纹理映射 创建非常简单

00:35:13.180 --> 00:35:16.183
它是全金属 完全没有粗糙度

00:35:16.450 --> 00:35:18.185
只是一个漫反射色彩

00:35:18.418 --> 00:35:21.088
所以它是创建宝石的非常好的方法

00:35:21.154 --> 00:35:23.257
宝石几乎对环境全反射

00:35:24.491 --> 00:35:27.661
光谱另一端 可以看到这座塔

00:35:27.728 --> 00:35:32.533
该对象既有金属部分又有非金属部分

00:35:32.699 --> 00:35:38.105
采用金属度 粗糙度映射图
和纹理映射图来创建它

00:35:38.672 --> 00:35:42.576
如你所见 我们还是在普通映射图上
采用漫反射色彩来添加细节

00:35:45.078 --> 00:35:48.815
基本上该演示使用了
所有SceneKit的新功能

00:35:49.449 --> 00:35:54.087
基于物理着色 所有材料和
光照的SceneKit API

00:35:54.154 --> 00:35:55.856
我们采用了Xcode集成

00:35:56.623 --> 00:36:01.228
以及为流程新建的自定义工具

00:36:01.628 --> 00:36:04.965
我们认为这是今年新特性的
非常精彩的展示

00:36:05.032 --> 00:36:08.035
也是非常好的示例代码
能让大家学到新知识

00:36:08.101 --> 00:36:09.837
希望你们喜欢

00:36:12.039 --> 00:36:13.073
谢谢

00:36:17.377 --> 00:36:19.580
如你们所见

00:36:19.646 --> 00:36:24.184
今年我们对材料和光照进行了重大升级

00:36:24.718 --> 00:36:28.121
我们也因此必须改变相机的表现

00:36:28.188 --> 00:36:30.624
我们已经有了优秀的材料和光照

00:36:31.291 --> 00:36:32.926
我们也需要更好的相机

00:36:33.594 --> 00:36:37.397
现在我们了现实光照

00:36:37.464 --> 00:36:40.934
我们需要有一个HDR相机
或高动态范围

00:36:41.802 --> 00:36:44.972
因为普通的相机是低动态范围

00:36:45.272 --> 00:36:46.707
是每组件8比特

00:36:46.773 --> 00:36:49.176
我们采用浮点组件

00:36:49.243 --> 00:36:54.681
所以可以有非常亮的光照
比如蜡烛或灯泡

00:36:54.748 --> 00:36:58.552
还可以有比如说 太阳
是非常非常亮的光照

00:36:59.152 --> 00:37:00.754
这样形成了非常高动态范围

00:37:00.821 --> 00:37:04.358
需要对屏幕上的动态范围进行重映射

00:37:04.925 --> 00:37:06.527
我们采用色调映射

00:37:06.593 --> 00:37:10.163
色调映射是把部分渲染重映射

00:37:10.230 --> 00:37:12.399
到低设置设备

00:37:14.835 --> 00:37:16.703
所以我们需要启用HDR相机

00:37:16.770 --> 00:37:20.574
它不是默认设置里自动设好的
可以在API或者Xcode里设置

00:37:21.808 --> 00:37:23.210
可以调试色调映射

00:37:23.277 --> 00:37:25.279
可以改变灰点 白点

00:37:25.445 --> 00:37:27.681
以及曝光的范围

00:37:28.015 --> 00:37:30.384
还可以固定曝光偏移

00:37:30.484 --> 00:37:33.654
举例说明 这个场景显示得很好

00:37:33.720 --> 00:37:38.692
但是你可以进行曝光不足渲染
低调显示 也可以过度曝光

00:37:38.759 --> 00:37:41.094
只需要改变偏移值 很简单

00:37:43.263 --> 00:37:46.900
因为有HDR相机
我们还添加了很棒的视觉效果

00:37:47.334 --> 00:37:49.269
首先是绽放效果

00:37:49.703 --> 00:37:53.073
绽放是模拟很强的光照造成的刺眼效果

00:37:53.340 --> 00:37:55.075
来自场景里或反射

00:37:55.676 --> 00:38:00.581
可以通过散开

00:38:00.647 --> 00:38:02.482
光照附近的放射像素

00:38:02.749 --> 00:38:04.785
在这个例子可以看到 非常好的效果

00:38:04.852 --> 00:38:09.723
可以看看在塔顶上的反射绽放效果

00:38:10.457 --> 00:38:15.295
这是一种很好的方法
使光照附近的像素晕开

00:38:16.296 --> 00:38:18.699
让渲染润色不少

00:38:21.702 --> 00:38:23.937
接着我们添加了运动模糊
已经在演示中看到了

00:38:24.671 --> 00:38:26.139
它让相机运动变得平滑

00:38:27.007 --> 00:38:30.210
如果把运动模糊加入整个场景

00:38:30.277 --> 00:38:31.111
就变成这个样子

00:38:31.211 --> 00:38:34.047
有时我们并不想让所有对象都模糊

00:38:34.114 --> 00:38:39.286
比如 我想让獾和矿车显示清晰利落

00:38:39.686 --> 00:38:45.926
所以有一个新API
可以从运动模糊中排出某些对象

00:38:46.493 --> 00:38:50.430
结果带来目标对象显示清晰利落的效果

00:38:53.534 --> 00:38:59.806
今年我们在现实生活相机中
加了几个变化

00:39:00.440 --> 00:39:02.142
首先是渐晕

00:39:02.442 --> 00:39:07.181
渐晕是现实生活镜头的误差

00:39:07.247 --> 00:39:09.816
在图像角落上形成阴影

00:39:10.417 --> 00:39:14.988
所以你可以把这张图像换到这张

00:39:15.055 --> 00:39:18.091
也可以改变环境对象 把滤镜

00:39:18.158 --> 00:39:21.361
从图像中间调到图像边缘

00:39:22.396 --> 00:39:26.633
今年模拟的另一个误差是彩色边纹

00:39:26.767 --> 00:39:30.337
彩色边纹是实际镜头中发生的折射

00:39:30.404 --> 00:39:32.005
实际镜头的玻璃上

00:39:32.706 --> 00:39:39.613
所以它会在渲染中产生
光照的紫红色和黄褐色阴影

00:39:39.680 --> 00:39:41.248
就会看到这个样子变成这个样子

00:39:41.315 --> 00:39:42.850
这个例子很极端

00:39:43.083 --> 00:39:45.485
可以更加温和细致 取得好的效果

00:39:47.521 --> 00:39:50.858
我们还加入了一个
可以改变场景氛围的好办法

00:39:50.924 --> 00:39:52.059
就是色彩校正

00:39:52.326 --> 00:39:56.263
可以改变饱和度 达到几乎黑白效果

00:39:56.330 --> 00:39:58.065
如果你想 也可以让色彩更夸张

00:39:58.131 --> 00:40:00.634
还可以改变场景对比度

00:40:01.201 --> 00:40:05.539
就会产生正常的图像或不饱和的

00:40:06.974 --> 00:40:09.643
或过度饱和的图像 然后改变对比度

00:40:13.146 --> 00:40:17.851
最后一个 有着非常非常棒的效果

00:40:18.018 --> 00:40:19.219
就是调色

00:40:19.286 --> 00:40:22.322
调色让我们完全重映射

00:40:22.389 --> 00:40:25.259
场景的颜色 变为完全不同的颜色

00:40:25.692 --> 00:40:28.662
我们采用正方形条形图片

00:40:28.829 --> 00:40:32.065
构建3D颜色立方体 当作查找表

00:40:32.533 --> 00:40:35.035
来重映射本来的颜色到全新的

00:40:35.102 --> 00:40:37.771
举个例子 我们重映射

00:40:37.838 --> 00:40:41.475
上面这条的普通颜色 到褐色调

00:40:41.942 --> 00:40:46.680
这就是褐色调的效果

00:40:46.747 --> 00:40:49.616
操作很简单 我们觉得很棒

00:40:49.683 --> 00:40:50.717
看上去很不错

00:40:52.486 --> 00:40:55.055
这就是今年对HDR相机的更新

00:40:55.322 --> 00:40:58.125
我们觉得这是非常棒的升级

00:40:58.559 --> 00:41:00.127
期待看到大家使用后的结果

00:41:00.194 --> 00:41:03.764
我们把所有的新效果都集中整合
供用户使用

00:41:03.830 --> 00:41:06.500
你不用在比如绽放或运动模糊之间选择

00:41:06.667 --> 00:41:08.168
可以同时使用所有效果

00:41:08.368 --> 00:41:09.269
当然这些是需要付费的

00:41:09.336 --> 00:41:14.875
但是你可以用来做出非常棒的图片和
看上去非常酷的场景

00:41:15.876 --> 00:41:19.913
现在我把讲台让给Nick
来讲解今年Model I/O的改进

00:41:20.080 --> 00:41:20.981
非常感谢

00:41:28.322 --> 00:41:29.723
好的 大家好

00:41:29.823 --> 00:41:32.025
首先我将稍微讲解

00:41:32.092 --> 00:41:37.731
今年模块输入输出和
SceneKit上的改进

00:41:39.166 --> 00:41:43.537
今年SceneKit可以导入模块

00:41:43.604 --> 00:41:49.042
到自定义格式比如
不一定和以前一样的三角形

00:41:49.109 --> 00:41:53.747
而是四边形或任意多边形的拓扑

00:41:53.814 --> 00:41:57.050
作者最初新建内容的地方

00:41:57.551 --> 00:42:00.320
SceneKit 如果需要
会自动进行三角测量

00:42:00.387 --> 00:42:02.589
从而完成渲染

00:42:02.990 --> 00:42:08.495
问题是如果想要采用全新的镶嵌设备

00:42:08.562 --> 00:42:12.633
你需要让镶嵌有精确的形状

00:42:12.699 --> 00:42:16.403
所以你需要修改代码 采用
“preservedOriginalTopology”标识

00:42:16.770 --> 00:42:19.206
该标识和Model I/O标识一致

00:42:19.439 --> 00:42:22.509
把它带入资产 进行指定

00:42:22.576 --> 00:42:25.479
它将保留所有的孔 折线
以及所有重要的东西

00:42:25.546 --> 00:42:27.915
为了对象的正确再现

00:42:29.016 --> 00:42:33.620
今年我们还改进了细分算法

00:42:33.754 --> 00:42:37.624
成为新的体系 来自Pixar的
OpenSubdiv 3

00:42:37.925 --> 00:42:39.293
可以看到在这个例子中

00:42:39.359 --> 00:42:43.130
有之前以三角形方式导入的对象
当进行镶嵌时

00:42:43.197 --> 00:42:47.334
我们想进行平滑细分的盒子
显得有点凹凸不平

00:42:47.901 --> 00:42:50.504
如果取出该对象 保持其拓扑结构

00:42:50.771 --> 00:42:57.044
可以看到四边形形成了均匀的圆形表面

00:42:57.110 --> 00:42:58.111
看上去效果很好

00:42:58.612 --> 00:43:02.583
这是一种非常好的方法 让轻量对象

00:43:02.649 --> 00:43:06.386
可以根据场景缩放分辨率 诸如此类

00:43:06.854 --> 00:43:12.159
输入输出的另一方面 我想要强调的

00:43:12.226 --> 00:43:17.097
是去年我们在Model I/O里
引入了基于物理材料等

00:43:17.331 --> 00:43:21.235
它们自然连接了
所有SceneKit的内容

00:43:21.301 --> 00:43:25.939
如果在Model I/O里
指定了高动态范围相机

00:43:26.006 --> 00:43:28.609
它会四处可用 不会失去任何属性

00:43:30.711 --> 00:43:32.880
来看Model I/O

00:43:32.946 --> 00:43:34.081
快速复习一下

00:43:34.748 --> 00:43:38.485
如［听不清］所说
模块输入输出

00:43:38.552 --> 00:43:40.654
在框架和系统里

00:43:42.289 --> 00:43:45.459
显然需要它们 把数据在应用之间

00:43:45.526 --> 00:43:48.595
新建对象的地方 以及翻译对象

00:43:48.662 --> 00:43:52.032
在框架之间 比如SceneKit
和MetalKit 等等

00:43:52.466 --> 00:43:56.670
我们支持很多标准文件格式

00:43:57.004 --> 00:44:01.308
文件格式是一种方法 让内容

00:44:01.375 --> 00:44:03.310
从成品输出到工具

00:44:03.377 --> 00:44:05.312
以前存在的格式

00:44:05.379 --> 00:44:08.015
专业范围很窄

00:44:08.215 --> 00:44:10.651
比如 只是一个模型

00:44:10.717 --> 00:44:12.486
或者只是一大堆数据

00:44:12.986 --> 00:44:18.125
今年很激动人心的是

00:44:18.192 --> 00:44:21.895
我们和Pixar联袂合作

00:44:21.962 --> 00:44:25.432
引入了对全局场景描述工具的支持

00:44:26.466 --> 00:44:32.105
现在全局场景描述是全新的公开标准

00:44:32.806 --> 00:44:36.877
关于它非常有趣和令人激动的是

00:44:36.944 --> 00:44:41.949
它不仅仅是一个文件系统
和一种格式

00:44:42.182 --> 00:44:47.120
很容易以ASCII读取
或足够以二进制加载

00:44:47.588 --> 00:44:51.091
它还包含了一个场景组合引擎

00:44:51.525 --> 00:44:55.262
这让它真正
从以前的其他格式中区分开来

00:44:55.729 --> 00:44:58.599
它凝聚了多年来的实际操作经验

00:44:58.665 --> 00:45:00.667
Pixar采用它制作电影

00:45:01.034 --> 00:45:06.840
明天上映的“海底总动员2”
完全从USD文件产生

00:45:07.374 --> 00:45:10.878
现在USD有专门用于场景的数据类型

00:45:11.278 --> 00:45:16.383
并且再一次
除了将此格式作为开放格式

00:45:16.450 --> 00:45:19.520
还有文件分层 实现并发流程

00:45:19.920 --> 00:45:23.757
并发工作流程非常棒

00:45:25.192 --> 00:45:29.096
这是一个例子 可能在

00:45:29.162 --> 00:45:32.132
在全局场景描述中取得的
关于电影中某个典型场景

00:45:32.699 --> 00:45:37.037
我们有一个取景层
取景被分层

00:45:37.104 --> 00:45:39.439
从组件 从背景 从角色

00:45:39.506 --> 00:45:42.042
角色本身可能包含很多组件

00:45:42.609 --> 00:45:45.913
可以看到该取景层图片有很多分层

00:45:46.046 --> 00:45:49.349
因为你不止可以新建一个场景

00:45:49.416 --> 00:45:51.051
由所有这些内容构成的

00:45:51.118 --> 00:45:52.986
你还可以做出改变

00:45:53.053 --> 00:45:57.257
场景描述可以让你知道 这是第四镜

00:45:57.324 --> 00:46:00.427
角色可能出来快了些或慢了些

00:46:00.827 --> 00:46:05.732
可以把所有这些变化存入一个文件
为了审阅

00:46:09.403 --> 00:46:13.941
另一个全局场景描述的特点是

00:46:14.007 --> 00:46:16.710
据我所知 它是唯一的开源文件格式

00:46:17.077 --> 00:46:22.316
允许在对象变化中对类进行指定

00:46:22.716 --> 00:46:26.453
可以想象 可能出现一种情况

00:46:26.520 --> 00:46:28.856
有很多野兽 都想闯进大学

00:46:28.922 --> 00:46:30.090
之类的 那里有书本

00:46:30.524 --> 00:46:34.261
在传统的工作流程中 你大概会

00:46:34.328 --> 00:46:37.130
发现自己在编写书本 编写程序

00:46:37.231 --> 00:46:39.733
为每本小书都新建无数文件

00:46:39.800 --> 00:46:44.071
然后把它们放在书架上
然后一本一本取出进行渲染

00:46:44.605 --> 00:46:46.440
真的很枯燥

00:46:46.640 --> 00:46:49.877
在游戏里 有一种角色团队

00:46:49.943 --> 00:46:52.779
可能各个角色有所不同
比如发型和T恤

00:46:53.180 --> 00:46:55.449
你可能不得不把它们都删除

00:46:55.516 --> 00:46:57.351
而现在全局场景描述

00:46:57.417 --> 00:47:01.955
允许你在对象的一个单一文件类中
进行指定

00:47:02.022 --> 00:47:05.192
所以一个类在这里显然代表了了一本书

00:47:07.761 --> 00:47:08.595
所以

00:47:09.329 --> 00:47:15.068
文件可以代表很多不同几何形状的书

00:47:15.335 --> 00:47:18.872
显然有一本宽的 长的 还有一本厚的

00:47:19.506 --> 00:47:23.777
当你把书实例化 放入书架时

00:47:23.844 --> 00:47:25.746
你可以告诉全局场景描述

00:47:26.013 --> 00:47:29.483
我想要这本书 想让它这么宽这么长

00:47:29.750 --> 00:47:31.618
它会提供你想要的信息

00:47:31.685 --> 00:47:36.723
实例化进入运行 或照片 都可以

00:47:39.526 --> 00:47:46.133
你在一个单一文件内的
改变可以是很多轴上的

00:47:46.433 --> 00:47:48.869
在本例中 我将修改一些着色属性

00:47:49.002 --> 00:47:51.004
刚才我有所有这些书

00:47:51.071 --> 00:47:52.840
我可以给它们着任何我想要的颜色

00:47:53.340 --> 00:47:58.312
神奇的地方是 我把书放好
最后我问

00:47:58.412 --> 00:47:59.580
为了渲染

00:47:59.646 --> 00:48:02.616
在这个地方的书是什么颜色的？

00:48:02.683 --> 00:48:07.221
它会找出来
根据所有的场景组合的逻辑

00:48:07.287 --> 00:48:11.892
文件和引擎包含的
它应该被表达的方式

00:48:13.060 --> 00:48:18.465
除此以外 你还可以在一个单一文件内

00:48:18.532 --> 00:48:19.666
表达不同的功能

00:48:19.933 --> 00:48:23.537
我将要展示的是在非常低的终端

00:48:23.604 --> 00:48:27.741
比如某个可穿戴设备
可能只显示低多边形版本

00:48:27.841 --> 00:48:31.578
同样的文件可以展示出合适的效果

00:48:32.312 --> 00:48:35.282
在已有功能的最高渲染上

00:48:36.149 --> 00:48:39.820
我们集成了全局场景描述

00:48:39.887 --> 00:48:42.222
跨越所有系统和框架

00:48:42.856 --> 00:48:46.460
所以 在最底层

00:48:46.627 --> 00:48:50.330
如果把一个全局场景描述文件
导入Model I/O

00:48:50.397 --> 00:48:51.965
我不期待你们可以读懂

00:48:52.165 --> 00:48:55.736
可以获得一个熟悉的
Model I/O对象层次

00:48:55.802 --> 00:48:58.605
含有所有在全局场景描述文件中的属性

00:48:58.672 --> 00:49:01.441
精确地表现 所以可以使用我们的工具

00:49:01.508 --> 00:49:05.546
Model I/O所提供的
比如 放置光照探测器

00:49:05.612 --> 00:49:08.048
并且评估它们的最佳位置

00:49:10.284 --> 00:49:15.689
然而 除此之外 比如有一个项目

00:49:15.756 --> 00:49:18.258
你的美术团队给了你一个
包含很多内容的文件夹

00:49:19.126 --> 00:49:22.596
你可以在Finder里打开窗口
包含所有内容

00:49:22.663 --> 00:49:25.766
Finder会准备好缩略图

00:49:25.832 --> 00:49:26.900
因此可以看见里面有什么

00:49:27.334 --> 00:49:29.102
快速查找也适用

00:49:29.169 --> 00:49:32.172
你可以选中其中一个对象 按下空格键

00:49:32.239 --> 00:49:34.174
它会跳出 你可将其翻来翻去

00:49:34.374 --> 00:49:38.145
当然快速查找一次只能显示一个对象

00:49:38.312 --> 00:49:40.848
如果你想保留一个对象以进行比较

00:49:40.914 --> 00:49:44.117
或者你的USD文件有多台相机
或多项内容

00:49:44.184 --> 00:49:48.121
你想逐个检查 可以用预览打开

00:49:48.188 --> 00:49:51.792
全局场景描述在那里实现地非常好

00:49:53.093 --> 00:49:57.331
如果把全局场景文件读入Xcode

00:49:57.397 --> 00:50:00.667
它通过Model I/O
导入SceneKit

00:50:00.734 --> 00:50:03.136
含有该文件内完全相同的属性表达

00:50:03.270 --> 00:50:06.507
所以可以在层次浏览器上进行查看

00:50:06.673 --> 00:50:07.908
可以查看属性

00:50:08.141 --> 00:50:11.011
可以移动对象 可以添加相机

00:50:11.078 --> 00:50:13.547
修改场景 返回给USD

00:50:13.614 --> 00:50:16.216
然后你把它发回给美术师们说

00:50:16.283 --> 00:50:17.885
你知道 我做了点修改

00:50:17.951 --> 00:50:19.486
你能不能 你知道该怎么做

00:50:20.454 --> 00:50:25.325
最后 它归入SceneKit

00:50:25.392 --> 00:50:30.063
Pixar的朋友为我们提供了
“海底总动员2”里的雷先生

00:50:30.631 --> 00:50:33.967
这是SceneKit
最直接可用的功能

00:50:34.034 --> 00:50:37.571
用最新的基于物理着色方法
你刚才已经全部听过

00:50:38.005 --> 00:50:43.710
我们只在电影资产中
播放了3秒动画

00:50:43.777 --> 00:50:45.312
看上去效果非常非常好

00:50:47.147 --> 00:50:50.817
你还需要插件

00:50:50.884 --> 00:50:53.620
才能把全局场景描述集成到工作流程中

00:50:54.087 --> 00:50:57.758
从而激活资产的动作 在人物

00:50:57.958 --> 00:51:00.561
内容创作节目 编写的应用之间

00:51:01.094 --> 00:51:04.698
所有插件 开源信息

00:51:04.765 --> 00:51:07.801
可用性 时间表等等等等

00:51:07.868 --> 00:51:12.773
都可以在openusd.org
网站上找到 我建议大家访问

00:51:12.840 --> 00:51:16.777
找出可以在你的管道和进程中
可用到的内容

00:51:18.612 --> 00:51:20.447
这就是全局场景描述

00:51:28.088 --> 00:51:29.089
快速总结一下

00:51:29.923 --> 00:51:34.528
SceneKit在我们的所有系统
和平台上可用

00:51:34.795 --> 00:51:36.096
这非常令人赞叹

00:51:36.396 --> 00:51:39.833
我们有基于物理渲染
针对任何美术外观状态

00:51:39.900 --> 00:51:43.704
以及美术表现状态 看上去非常美

00:51:43.904 --> 00:51:47.608
HDR相机和效果让你

00:51:47.674 --> 00:51:51.011
控制如何表现对象
以及外观 非常高质量

00:51:51.612 --> 00:51:56.049
我们还提供全局场景描述的支持

00:51:56.116 --> 00:51:58.852
我们非常高兴能在背后进行支持

00:51:58.919 --> 00:52:01.922
并且认为将在工作流程里大显身手

00:52:01.989 --> 00:52:04.191
在未来的日子里

00:52:06.760 --> 00:52:10.797
关于本次演讲609
更多信息 都可以在网站上找到

00:52:13.534 --> 00:52:15.802
相关演讲还有

00:52:15.869 --> 00:52:19.173
Xcode中可视化调试和广色域
游戏技术和Apple Watch

00:52:19.239 --> 00:52:22.142
今天和明天可以参加

00:52:22.209 --> 00:52:23.477
非常感谢大家