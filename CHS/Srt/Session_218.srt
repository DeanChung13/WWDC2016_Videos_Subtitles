00:00:19.453 --> 00:00:24.892
让Watch应用保持更新

00:00:32.566 --> 00:00:33.400
好的

00:00:33.467 --> 00:00:37.337
大家好 欢迎参加我们的演讲
“让Watch应用保持更新”

00:00:37.771 --> 00:00:41.642
我叫Eric Lanz 今天跟我
一起的还有Austen Green

00:00:41.808 --> 00:00:44.545
我们都是watchOS团队的工程师

00:00:46.346 --> 00:00:49.349
这是一个日历应用的截屏

00:00:49.516 --> 00:00:52.619
当你听到应用这个词时
你脑海中很可能会浮现这个画面

00:00:53.554 --> 00:00:57.724
但watchOS还有很多超出
标准应用之外的互动方式

00:00:58.025 --> 00:01:01.428
比如 你的用户认为通知

00:01:01.495 --> 00:01:03.463
是你应用的一个重要部分

00:01:04.464 --> 00:01:07.534
如果你有complication
你的用户会认为

00:01:07.601 --> 00:01:09.636
那也是你应用的一个重要部分

00:01:10.971 --> 00:01:14.808
在watchOS 3中
我们引入了一个新的应用dock

00:01:15.175 --> 00:01:17.611
这个功能允许用户添加多达十个

00:01:17.678 --> 00:01:21.348
应用到一个总是可见的dock中

00:01:21.682 --> 00:01:23.116
他们可以滑动浏览dock

00:01:23.183 --> 00:01:25.719
从dock中快速获得所有数据

00:01:26.286 --> 00:01:28.755
这个现在已经成为
应用的一个部分了

00:01:29.489 --> 00:01:31.959
人们以很多不同的方式使用你应用的数据

00:01:32.025 --> 00:01:34.828
并且希望所有这些方式

00:01:34.895 --> 00:01:37.664
都能一直同步和更新

00:01:38.165 --> 00:01:41.535
听起来像是个不可能的任务
但不要担心

00:01:41.602 --> 00:01:42.569
我们可以帮你们实现

00:01:44.438 --> 00:01:46.874
今天 我们要讲五个话题

00:01:46.940 --> 00:01:50.911
第一 这个API的概述以及
它在watchOS上的使用

00:01:51.411 --> 00:01:55.315
第二 用真实代码
演示一个示例应用

00:01:55.983 --> 00:01:57.918
第三 Austen将上台

00:01:57.985 --> 00:02:00.888
演示预约在后台是如何运行的

00:02:01.421 --> 00:02:03.590
第四 我们将分享一些最佳范例

00:02:03.657 --> 00:02:06.460
把这个API应用到你自己的应用中

00:02:06.894 --> 00:02:09.863
第五 我们将演示一个案例分析

00:02:09.930 --> 00:02:13.433
阐述我们是如何把这个API
应用到我们自己的股票应用中的

00:02:15.669 --> 00:02:19.573
首先 我们要思考的是我们
如何使用手机和表

00:02:19.640 --> 00:02:21.341
每天以不同的方式

00:02:22.876 --> 00:02:26.180
早上 你排队买咖啡
开始新的一天

00:02:26.246 --> 00:02:28.849
你可以在手机上看几分钟新闻

00:02:29.483 --> 00:02:31.585
离开商店前 查一下天气情况

00:02:31.652 --> 00:02:35.055
用表盘上的complication
这是个两秒钟任务

00:02:36.456 --> 00:02:39.393
午饭时 再用地图找一个不错的餐厅

00:02:39.459 --> 00:02:42.462
几分钟后 你选好餐厅 收起电话

00:02:43.530 --> 00:02:46.033
在去餐厅的路上
你收到一条通知

00:02:46.099 --> 00:02:48.302
你快速地瞥了一眼手腕
你知道你的朋友们

00:02:48.368 --> 00:02:51.505
会晚几分钟到
这是另一个两秒钟任务

00:02:53.307 --> 00:02:57.144
在今天结束的时候 你再次使用
地图规划一下路线 你可能会改道

00:02:58.612 --> 00:03:01.582
你收到一条iMessage
询问你今晚何时到家

00:03:02.115 --> 00:03:05.452
你使用watchOS 3的
快速回复功能回信息

00:03:05.519 --> 00:03:08.522
“在路上” 又一个两秒钟任务

00:03:10.057 --> 00:03:12.960
几乎不可能在几秒钟之内

00:03:13.026 --> 00:03:15.696
把用户即将传给我们的数据准备好

00:03:15.762 --> 00:03:16.897
我们需要更长的时间

00:03:17.297 --> 00:03:19.399
在后台进行刷新

00:03:19.900 --> 00:03:23.203
你可以通过这个强大的
新API预约运行时间

00:03:23.270 --> 00:03:26.507
这样 在用户需要这些数据之前
数据能提前准备好

00:03:30.511 --> 00:03:34.314
要了解这个新API的功能
让我们仔细看一下

00:03:34.381 --> 00:03:36.416
在watchOS上查询天气情况

00:03:36.884 --> 00:03:40.687
这里 我们看到查询天气
complication的前台活动

00:03:41.221 --> 00:03:44.057
在查询发生之前
我们就要准备好数据

00:03:44.992 --> 00:03:49.129
让我们用这个API来预约查询
发生之前的某个时间来更新UI

00:03:49.830 --> 00:03:52.366
但是 没有数据该如何更新UI呢

00:03:52.766 --> 00:03:56.203
我们需要更多时间从服务器上
获取最新的天气数据

00:03:56.270 --> 00:03:57.838
为此 我们要计划一个任务

00:03:58.572 --> 00:04:01.308
但是 我们要怎么着手
处理这一系列的事件呢？

00:04:01.675 --> 00:04:06.046
我们需要一种方式
使系统在后台唤醒我们的应用

00:04:07.714 --> 00:04:11.818
在watchOS上 系统通过
给应用分配任务唤醒应用

00:04:12.386 --> 00:04:15.055
系统所能分配的任务有限

00:04:15.122 --> 00:04:17.357
所以你要充分利用
你得到的每一个任务

00:04:18.625 --> 00:04:20.928
当系统要唤醒你的应用时

00:04:20.994 --> 00:04:23.830
它会交付一个或几个任务对象

00:04:24.198 --> 00:04:25.766
请一定要守住这个任务

00:04:25.832 --> 00:04:27.901
直到完成数据处理

00:04:29.169 --> 00:04:30.604
系统 交付任务

00:04:30.671 --> 00:04:33.607
通过调用已处理的
新后台任务方法

00:04:33.674 --> 00:04:35.509
在WK扩展委托上

00:04:36.176 --> 00:04:38.712
稍后我们将演示
这个方法的一个示例

00:04:40.147 --> 00:04:41.882
当你完成后台工作后

00:04:41.949 --> 00:04:44.818
完成任务并把任务返回给系统

00:04:44.885 --> 00:04:46.553
这就是基本流程

00:04:46.620 --> 00:04:49.756
你可以通过这个流程
在watchOS上获得后台运行时间

00:04:51.725 --> 00:04:54.361
现在 我们要从一个更高的层次
来了解任务系统

00:04:54.428 --> 00:04:57.130
让我们再深入地看一下
具体的任务类型

00:04:57.197 --> 00:04:59.066
系统可以创建的

00:05:00.100 --> 00:05:02.402
首先 这是个应用任务

00:05:02.803 --> 00:05:05.806
这是个通用的运行时间任务
你可以预约

00:05:05.873 --> 00:05:08.442
在将来某一个日期唤醒应用

00:05:10.043 --> 00:05:14.214
在应用任务的运行时间内
你可以进行任何形式的本地处理

00:05:14.648 --> 00:05:17.217
你可能想
更新complication时间线

00:05:17.284 --> 00:05:20.320
或用URLSession
从服务器上下载数据

00:05:21.355 --> 00:05:23.757
URLSession任务是如何得知

00:05:23.824 --> 00:05:26.760
数据已下载完成并等待处理

00:05:27.794 --> 00:05:31.398
由于watchOS是个共享的
生态系统 没有任何意义

00:05:31.465 --> 00:05:34.468
在数据下载时使应用保持运行

00:05:34.968 --> 00:05:37.371
最好是让应用休眠

00:05:37.437 --> 00:05:39.506
那么就让系统替我们实现吧

00:05:41.008 --> 00:05:44.478
快照是watchOS上的一个
非常重要的部分

00:05:45.045 --> 00:05:46.613
它们既是你的启动画面

00:05:47.114 --> 00:05:49.316
又是在dock中运行时的预览画面

00:05:50.050 --> 00:05:52.986
如果用户停留在你的应用上
你的应用将再次苏醒并运行

00:05:53.053 --> 00:05:56.823
关键是你的快照要持续更新

00:05:58.692 --> 00:06:02.196
快照任务是如何
获得在后台准备UI的运行时间

00:06:02.262 --> 00:06:05.098
并获取新快照

00:06:08.368 --> 00:06:09.837
当你完成这个任务后

00:06:09.903 --> 00:06:12.606
系统会自动给UI创建快照

00:06:13.140 --> 00:06:16.810
请记住 完成数据处理后
一定要预约一个任务

00:06:16.877 --> 00:06:19.346
否则用户就看不到
你刚刚所做的工作

00:06:20.614 --> 00:06:23.417
当通知到达时 用户会看到通知

00:06:23.483 --> 00:06:26.854
然后他们会期待
你的complication和快照

00:06:26.920 --> 00:06:28.922
更新并显示最新数据

00:06:29.523 --> 00:06:33.627
用户喜欢那些感觉像是OS
密不可分的一部分一样的应用

00:06:33.694 --> 00:06:36.396
并且他们把那些应用
放进dock中的可能性更大

00:06:38.599 --> 00:06:42.669
如果用户有一个小时以上
不跟你的应用进行互动

00:06:42.736 --> 00:06:44.972
系统就会给你一个机会

00:06:45.038 --> 00:06:46.640
来修复你的缺省状态

00:06:47.841 --> 00:06:50.511
缺省状态对于不同的应用来说
含义不同

00:06:50.577 --> 00:06:53.313
有些应用没有缺省状态的概念

00:06:56.216 --> 00:07:00.687
在watchOS 3上设计精美快照
是个很大、很重要的话题

00:07:01.021 --> 00:07:03.423
我们建议你参加一些
其他相关的演讲

00:07:03.490 --> 00:07:07.294
了解如何创建优秀
快照的一些设计建议

00:07:09.263 --> 00:07:12.099
最后一个任务类型是表连通性

00:07:12.633 --> 00:07:16.036
在watchOS 3上
我们整合了表连通性

00:07:16.103 --> 00:07:18.305
和后台刷新API

00:07:19.072 --> 00:07:22.442
意思是 你现在可以使用
表连通性消息

00:07:22.509 --> 00:07:26.313
把数据更新到应用中
当应用在后台运行时

00:07:28.582 --> 00:07:31.885
complication推送
应用情境、发送文件

00:07:31.952 --> 00:07:35.522
或发送用户信息
都将在后台唤醒应用

00:07:36.123 --> 00:07:37.858
我们希望这个版本会带给

00:07:37.925 --> 00:07:41.161
我们的用户更丰富的体验

00:07:42.663 --> 00:07:46.133
当应用通过表连通性任务
被唤醒时

00:07:46.934 --> 00:07:49.303
使用标准API来获取数据

00:07:49.736 --> 00:07:52.005
首先 确保会话是激活的

00:07:53.373 --> 00:07:54.908
一旦会话被重新激活

00:07:54.975 --> 00:07:58.378
就开始监控
新的hasContentPending属性

00:07:59.046 --> 00:08:02.449
只要这个属性为真
就表示仍有数据要处理

00:08:02.950 --> 00:08:04.384
确保要一直守住这个任务

00:08:04.451 --> 00:08:06.553
直到完成数据处理

00:08:07.754 --> 00:08:10.290
完成时 你有责任将任务

00:08:10.357 --> 00:08:12.292
返回给系统

00:08:12.860 --> 00:08:15.963
如果你不这样做
你将不会再获得后台运行时间

00:08:16.029 --> 00:08:17.998
并且我们会给你一个崩溃报告

00:08:19.099 --> 00:08:21.902
Austen稍后会提供详细信息

00:08:21.969 --> 00:08:23.837
是关于运行时间警告的信息

00:08:25.405 --> 00:08:29.977
让我们快速回顾一下
新后台刷新API的使用流程

00:08:30.344 --> 00:08:33.013
首先 预约一个任务

00:08:33.847 --> 00:08:36.015
然后 接收系统任务

00:08:36.917 --> 00:08:38.619
现在你就可以进行后台工作了

00:08:38.885 --> 00:08:42.121
一定要守住这个任务
直到完成后台工作

00:08:42.890 --> 00:08:45.526
你可以利用这个运行时间
预约后续工作

00:08:45.592 --> 00:08:48.395
比如使用URLSession
从服务器获取数据

00:08:49.863 --> 00:08:54.134
结束后 完成任务
并把任务返回给系统

00:08:56.803 --> 00:09:01.775
在继续演讲之前 我想强调一件
非常重要的事儿 就是做一个好公民

00:09:03.243 --> 00:09:07.147
watchOS是一个共享的生态系统
有许多应用

00:09:07.214 --> 00:09:10.984
和系统进程争夺CPU时间
和电池寿命

00:09:11.451 --> 00:09:15.022
在这个生态系统中
我们作为开发人员有责任

00:09:15.088 --> 00:09:18.058
尽最大努力有效地使用这些资源

00:09:18.825 --> 00:09:21.628
假如用户在下午3点
启动了你的应用

00:09:22.563 --> 00:09:25.899
你想确保在一个小时内有机会
跟服务器进行核对

00:09:25.966 --> 00:09:27.901
那你就预约一个下午4点的任务

00:09:28.735 --> 00:09:32.072
嗯 如果用户在下午3点50分
启动了应用会怎么样呢？

00:09:33.073 --> 00:09:35.909
我们可以立即更新数据

00:09:35.976 --> 00:09:39.046
四点钟当任务运行时再次更新数据 但这对于
我来说并不是最理想的方案

00:09:40.280 --> 00:09:43.450
最好的方法是在3点50分
利用运行时间

00:09:43.517 --> 00:09:47.254
重新预约一个小时后的后台任务
也就是4点50分的任务

00:09:48.088 --> 00:09:49.256
每个应用都不一样

00:09:49.323 --> 00:09:53.260
但我们希望你们能找到一个
这样的模式 使资源最大化

00:09:54.995 --> 00:09:56.897
好了 让我们看点儿代码吧

00:09:57.865 --> 00:09:59.466
为了帮助设计示例代码

00:09:59.533 --> 00:10:02.636
我们将按照时间线
逐步演示一个示例应用

00:10:02.703 --> 00:10:04.505
并展示如何写代码

00:10:04.571 --> 00:10:07.274
来响应所有生命周期事件

00:10:07.808 --> 00:10:09.610
让我们看一个足球应用

00:10:09.810 --> 00:10:13.881
假如今晚7点到9点
有一场重要比赛

00:10:14.882 --> 00:10:17.284
我们知道用户最钟爱的球队
会参加比赛

00:10:17.351 --> 00:10:20.187
并且我们认为他们一定
会频繁地查看比分

00:10:20.587 --> 00:10:24.358
让我们给后台活动选定一个
三十分钟的节奏

00:10:25.626 --> 00:10:29.463
后台刷新API只能允许
每种类型有一个任务

00:10:29.530 --> 00:10:31.765
是执行状态 在任何特定时间内

00:10:32.299 --> 00:10:36.103
一开始 我们预约第一个任务的
时间是7点半

00:10:37.171 --> 00:10:41.341
在7点半 我们将使用所得到的运行
时间预约下一个任务 时间为8点

00:10:42.142 --> 00:10:46.480
8点时 我们将再次使用所得到的运行
时间预约下一个事件 时间是8点半

00:10:46.914 --> 00:10:50.284
一直确保预约未来任务非常重要

00:10:50.350 --> 00:10:53.287
否则你就不知道什么时候
才能有机会再运行

00:10:55.355 --> 00:10:59.793
在此 我们看到了在watchOS上
预约应用任务的代码

00:11:00.227 --> 00:11:03.397
首先 让我们把任务时间
设定为三十分钟以后

00:11:04.565 --> 00:11:08.936
使用userInfo对象来存储某些
关于为何做出请求的数据

00:11:09.369 --> 00:11:12.706
在这个例子中
我存了发起请求的日期

00:11:12.773 --> 00:11:16.810
和当任务返回时
能稍后查看原因的一个字符串

00:11:17.377 --> 00:11:18.745
这个属性是可选的

00:11:18.812 --> 00:11:22.082
可以在这里存储任何
安全编码的兼容数据

00:11:23.951 --> 00:11:26.587
这个完成日志是获知

00:11:26.653 --> 00:11:30.324
系统是否已经成功预约任务的

00:11:31.058 --> 00:11:33.093
请注意 正因为这里没有报错

00:11:33.160 --> 00:11:36.663
但这也并不意味着任务
会按所请求的时间运行

00:11:37.598 --> 00:11:41.902
Austen将为大家解释何时及为何
系统触发指定任务

00:11:43.837 --> 00:11:47.007
预约应用任务后
让我们把重点放在时间线上

00:11:47.074 --> 00:11:50.811
看这个只有五分钟的窗口
预约任务将在这个窗口中运行

00:11:52.546 --> 00:11:53.847
当系统唤醒应用时

00:11:53.914 --> 00:11:56.817
我们优先考虑的是
从服务器获取最新比分数据

00:11:57.084 --> 00:11:58.452
让我们看一下代码

00:11:58.519 --> 00:12:01.588
在watchOS上
开始后台URLSession的

00:12:06.193 --> 00:12:09.329
首先 创建一个
URLSession配置对象

00:12:09.696 --> 00:12:11.765
重点是把这个对象配置为

00:12:11.832 --> 00:12:14.801
后台会话 因为我们要在后台运行

00:12:16.236 --> 00:12:20.007
同时设置一个标识符
稍后用来获取数据

00:12:22.075 --> 00:12:25.546
接下来 用这个配置
创建一个URL会话

00:12:26.847 --> 00:12:31.251
我们要求URLSession提供
一个或多个下载任务对象

00:12:31.919 --> 00:12:35.589
可以给会话关联多个下载任务
想关联多少就关联多少

00:12:35.889 --> 00:12:40.661
请谨记 系统只能在完成所有
关联任务后才会唤醒应用

00:12:42.863 --> 00:12:45.966
要开始下载数据
请不要忘记调用重新启动

00:12:48.602 --> 00:12:51.672
返回时间线
我们在过程中下载了URL

00:12:51.738 --> 00:12:55.375
所以完成任务
和使应用休眠是很安全的

00:12:56.076 --> 00:12:58.445
系统将继续下载数据

00:12:58.512 --> 00:12:59.813
当我们被挂起时

00:13:01.248 --> 00:13:04.351
当数据下载完成后
URLSession会创建一个任务

00:13:04.418 --> 00:13:06.253
并再次唤醒应用

00:13:06.720 --> 00:13:09.489
但是 到底什么是唤醒应用呢？

00:13:10.791 --> 00:13:14.061
具体地说 唤醒应用的意思就是

00:13:14.127 --> 00:13:18.932
在WKExtensionDelegate上调用
新的处理后台任务方法

00:13:20.400 --> 00:13:21.635
除了这个调用

00:13:21.702 --> 00:13:25.239
我们还将收到是否在可见视图
控制器上激活调用

00:13:26.673 --> 00:13:30.344
系统合并任务
并提交给我们一个任务集

00:13:30.777 --> 00:13:33.247
我们需要处理
这个任务集中的所有任务

00:13:33.313 --> 00:13:35.349
让我们开始依次处理吧

00:13:36.283 --> 00:13:39.253
对于每个任务来说
我们可以使用一个内联任务

00:13:39.319 --> 00:13:41.622
来得到我们想得到的类型的对象

00:13:42.823 --> 00:13:45.425
在这个例子中 要处理一个
URLSession任务

00:13:45.492 --> 00:13:50.430
那么我们需要使用
和任务关联的标识符再次加入会话

00:13:52.232 --> 00:13:55.202
URLSession
是一个高度异步API

00:13:55.269 --> 00:13:57.571
我们一定要注意守住任务

00:13:57.638 --> 00:13:59.773
直到完成数据处理

00:14:00.474 --> 00:14:03.076
我们建议你把任务存在一个集合中

00:14:03.143 --> 00:14:04.945
完成后再遣散集合

00:14:05.012 --> 00:14:08.315
完成每个任务
并把它返回给系统

00:14:10.517 --> 00:14:13.654
一定要完成那些
未特别处理的任务类型

00:14:14.188 --> 00:14:16.657
请记住 系统的任务数量有限

00:14:16.757 --> 00:14:18.525
所以要完成你得到的每个任务

00:14:20.327 --> 00:14:22.596
我们已经得到了数据
让我们更新模型吧

00:14:22.863 --> 00:14:26.099
你可能会考虑
在这个时候一起更新UI

00:14:26.166 --> 00:14:29.203
但我们建议你充分利用
这个快照任务的运行时间

00:14:29.269 --> 00:14:30.437
进行数据处理这样的工作

00:14:31.271 --> 00:14:33.574
因此 在完成URL任务之前

00:14:33.640 --> 00:14:35.576
要先确保预约创建快照

00:14:37.344 --> 00:14:40.514
预约创建快照后再完成URL任务
就安全了

00:14:40.581 --> 00:14:42.783
并允许应用再次休眠

00:14:44.351 --> 00:14:49.223
很快 系统将通过我们刚预约的
快照任务再次唤醒应用

00:14:49.957 --> 00:14:52.159
现在是时候更新UI了

00:14:52.226 --> 00:14:54.728
并准备好创建新快照所需的东西

00:14:56.597 --> 00:14:59.266
快照有一个独特的完成处理器

00:14:59.333 --> 00:15:01.435
让我们来看看这个
完成处理器

00:15:01.502 --> 00:15:03.136
在watchOS上处理快照

00:15:05.005 --> 00:15:08.709
无论什么时候
每个应用都必须有一个快照

00:15:09.142 --> 00:15:12.012
这是因为快照既是启动画面

00:15:12.346 --> 00:15:14.548
又是在dock中运行时的预览画面

00:15:15.415 --> 00:15:17.885
这个规则的意思是当创建快照后

00:15:18.619 --> 00:15:21.555
我们要通知系统
这个快照的有效期

00:15:22.356 --> 00:15:26.159
要考虑数据及数据与用户
相关性的时间长度

00:15:26.994 --> 00:15:29.663
在这个例子中
我们在八点有一个预约事件

00:15:29.730 --> 00:15:32.399
让我们把有效时间设为三十分钟

00:15:35.235 --> 00:15:37.704
可以在用户信息中随意存储一些
这样的信息

00:15:37.771 --> 00:15:39.473
比如为何发起这次请求

00:15:39.740 --> 00:15:43.043
那个数据将为我们返回
下一个快照任务

00:15:45.746 --> 00:15:48.882
watchOS将给应用提供
的机会

00:15:48.949 --> 00:15:52.452
还原缺省状态 在休止一个小时后

00:15:53.020 --> 00:15:55.522
你可以告诉系统跳过那个事件

00:15:55.589 --> 00:15:58.825
通过把restoredDefaultState
属性的值设为真

00:15:59.626 --> 00:16:03.197
这样就会使系统了解
你已经是缺省状态了

00:16:03.263 --> 00:16:05.098
不需要额外任务了

00:16:06.066 --> 00:16:08.502
没有缺省状态概念的应用

00:16:08.569 --> 00:16:11.405
应该考虑一直把这个属性设为真

00:16:13.106 --> 00:16:17.010
完成快照任务后 系统将挂起应用

00:16:17.444 --> 00:16:19.880
然后自动抓取UI

00:16:19.947 --> 00:16:21.682
并用作新的启动画面

00:16:22.349 --> 00:16:25.118
这将不会唤醒你的应用

00:16:27.554 --> 00:16:30.257
我们通过 端对端示例实现

00:16:30.324 --> 00:16:34.194
常见后台刷新模式
和所关联代码

00:16:34.862 --> 00:16:36.163
提醒一下

00:16:36.230 --> 00:16:39.099
虽然我们看到时间线上是五分钟

00:16:39.533 --> 00:16:43.070
我们的应用总共
也只能活跃15秒

00:16:44.037 --> 00:16:45.205
通过任务链

00:16:45.272 --> 00:16:48.675
我们可以最大限度地
利用系统资源

00:16:49.977 --> 00:16:53.580
现在 你应该对这个新API
是什么有了更好的理解

00:16:54.581 --> 00:16:56.183
为什么要使用它

00:16:56.250 --> 00:16:58.252
以及怎么使用它

00:16:59.720 --> 00:17:02.422
接下来 让我们欢迎
Austen Green上台

00:17:02.489 --> 00:17:04.023
给大家深入介绍

00:17:04.090 --> 00:17:06.393
预约是如何在后台运作的

00:17:09.396 --> 00:17:10.430
祝你好运

00:17:13.834 --> 00:17:15.569
大家好
我是Austen Green

00:17:15.636 --> 00:17:17.104
我是一名watchOS工程师

00:17:17.337 --> 00:17:21.675
今天上午 我要跟大家分享一些
的信息

00:17:21.742 --> 00:17:24.243
关于预约如何在后台运作

00:17:24.645 --> 00:17:27.948
我会提供一些
精挑细选的最佳范例

00:17:28.015 --> 00:17:30.817
我们在我们自己的应用中
使用后台刷新时

00:17:31.151 --> 00:17:33.554
最后 结束之前
还要做一个快速的案例分析

00:17:33.620 --> 00:17:36.356
是关于如何 应用后台刷新的

00:17:36.423 --> 00:17:37.691
在我们的股票应用中

00:17:38.859 --> 00:17:39.860
让我们开始吧

00:17:42.763 --> 00:17:45.499
我要讲的第一点是运行时间

00:17:46.233 --> 00:17:49.069
应用在前台

00:17:50.037 --> 00:17:51.605
一直是运行状态

00:17:51.939 --> 00:17:55.175
意思是会开始执行你的代码

00:17:55.242 --> 00:17:59.146
你可以进行像更新模型
和绘制UI这样的工作

00:17:59.213 --> 00:18:02.082
以及应用可能需要
进行的其他各种任务

00:18:03.317 --> 00:18:05.886
当你的应用进入后台时

00:18:05.953 --> 00:18:08.655
系统一般会挂起你的应用

00:18:08.889 --> 00:18:12.526
意思是 你的应用不再有机会
执行任何代码了

00:18:13.927 --> 00:18:16.964
有时候 当应用在后台时

00:18:17.030 --> 00:18:20.734
系统可能希望应用
能实施一项特定的任务

00:18:20.801 --> 00:18:23.971
此时系统将唤醒应用

00:18:24.037 --> 00:18:27.541
并要求应用实施
它想要应用实施的特定任务

00:18:27.975 --> 00:18:29.276
在watchOS 2中

00:18:29.843 --> 00:18:32.713
系统有许多方式来唤醒应用

00:18:32.779 --> 00:18:36.316
比如处理需要仔细看的通知

00:18:37.017 --> 00:18:39.686
或也许ClockKit会要求应用

00:18:39.753 --> 00:18:41.154
更新complication

00:18:41.788 --> 00:18:44.191
在watchOS 3中
我们增加了更多的方式

00:18:44.258 --> 00:18:46.126
使应用在后台运行

00:18:50.063 --> 00:18:54.301
系统要限制 时间

00:18:54.368 --> 00:18:56.403
在后台运行的

00:18:58.071 --> 00:19:00.707
时间的单位是秒

00:19:01.041 --> 00:19:04.578
系统会考虑你所使用的时间

00:19:04.645 --> 00:19:06.980
以及你所使用的CPU

00:19:07.047 --> 00:19:10.050
所以 尽快、
完成工作才能获得最大利益

00:19:10.117 --> 00:19:11.852
尽可能有效地

00:19:13.053 --> 00:19:16.190
在随后的种子中
如果你超出了限制

00:19:16.323 --> 00:19:18.125
系统将会扼杀你的应用

00:19:18.525 --> 00:19:19.693
你将得到一份崩溃报告

00:19:19.760 --> 00:19:22.429
从而了解是否超出CPU限制

00:19:22.663 --> 00:19:26.733
或时间限制
根据崩溃报告中的异常码

00:19:28.435 --> 00:19:32.706
我们意识到 不同的任务
可能有不同的需要

00:19:32.840 --> 00:19:34.708
所以ApplicationRefresh任务

00:19:34.775 --> 00:19:38.612
和URLSession任务
的时间限制要长

00:19:38.946 --> 00:19:41.548
比表连通性和快照任务

00:19:52.359 --> 00:19:56.496
那么在watchOS 2中
complication是

00:19:56.563 --> 00:19:58.932
应用在后台获得运行时间的主要方式

00:19:59.967 --> 00:20:01.168
watchOS 3中

00:20:01.235 --> 00:20:04.204
我们要确保你继续每小时
进行多次更新

00:20:04.271 --> 00:20:06.173
若是带complication应用

00:20:06.240 --> 00:20:08.709
与在watchOS 2上一样

00:20:09.510 --> 00:20:13.413
然而 如果你提前向系统
请求运行时间

00:20:13.480 --> 00:20:15.249
更新complication数据

00:20:15.549 --> 00:20:18.118
你现在可请求通过
WKExtension进行更新了

00:20:18.185 --> 00:20:19.987
稍后我会讲一下如何实现

00:20:20.988 --> 00:20:22.789
另外 watchOS 3的新功能是

00:20:22.856 --> 00:20:26.493
我们确保有来自
父类iPhone的五十次push

00:20:27.494 --> 00:20:29.229
如果你使用表连通性的话

00:20:29.530 --> 00:20:32.699
利用这个信息可以很简单地

00:20:32.766 --> 00:20:36.036
确保提供很棒的
complication体验

00:20:36.103 --> 00:20:38.105
全天候为你的用户

00:20:38.639 --> 00:20:40.107
让我们来看一些代码

00:20:41.975 --> 00:20:45.646
假如你正运行一个iPhone应用

00:20:46.046 --> 00:20:47.881
并且你注意到模型发生了变更

00:20:48.582 --> 00:20:50.884
你可以查询WCSession

00:20:50.951 --> 00:20:53.153
remainingComplication
UserInfoTransfers

00:20:53.220 --> 00:20:56.823
来了解
你还剩多少高优先级的push

00:20:56.890 --> 00:20:58.725
今天剩下的时间

00:20:59.793 --> 00:21:01.228
你可以利用这个信息

00:21:01.295 --> 00:21:03.564
打造complication体验

00:21:03.630 --> 00:21:07.100
决定何时是发送
complication数据的最佳时间

00:21:08.035 --> 00:21:09.970
比如说在默认情况下

00:21:10.604 --> 00:21:12.105
你有足够多的push

00:21:12.673 --> 00:21:14.341
那就立即发送数据

00:21:14.408 --> 00:21:18.478
用户几乎会立即看到最相关的数据

00:21:19.479 --> 00:21:21.882
假如你已经push了很多次

00:21:21.949 --> 00:21:24.551
并且运行有点儿慢 传输有点儿慢

00:21:24.751 --> 00:21:30.090
你可能会考虑节制发送给表的数据
从而确保

00:21:30.157 --> 00:21:34.061
你的用户得到
complication的数据更新

00:21:34.127 --> 00:21:35.596
在当天剩余的时间内

00:21:36.864 --> 00:21:40.801
最后 如果你没有任何
高优先级的传输了

00:21:40.868 --> 00:21:43.971
仍然可以尝试和发送数据 但是

00:21:44.037 --> 00:21:46.406
数据会以较低的优先级发送

00:21:49.076 --> 00:21:50.711
接下来 我要讲

00:21:50.777 --> 00:21:53.247
一些CLKComplication
DataSource方法

00:21:53.313 --> 00:21:56.383
我们想要搬到WatchKit中去的

00:21:57.117 --> 00:22:00.787
如果你
提前向系统请求运行时间

00:22:00.854 --> 00:22:03.056
通过getNextRequestedUpdateDate

00:22:05.926 --> 00:22:10.564
你应该希望系统预约后台刷新

00:22:10.631 --> 00:22:14.835
的日期跟你之前
通知ClockKit的日期相同

00:22:16.136 --> 00:22:19.706
类似的
当ClockKit想让你的应用运行时

00:22:19.773 --> 00:22:21.909
它会调用
requestedUpdateDidBegin

00:22:22.676 --> 00:22:25.946
现在 我们希望在应用层级来实现

00:22:26.013 --> 00:22:29.049
通过刷新处理后台或
处理backgroundTasks

00:22:29.149 --> 00:22:30.617
你会得到一个应用任务

00:22:31.118 --> 00:22:35.189
处理complication
更新和应用更新

00:22:37.658 --> 00:22:41.361
在watchOS 3中
我们引入了dock

00:22:41.428 --> 00:22:45.899
我们认为这很棒 可以使用户快速
获取他们所喜欢的应用的数据

00:22:45.966 --> 00:22:49.436
并方便地查看
他们所关注的所有信息

00:22:50.637 --> 00:22:53.574
我们希望dock中的应用数据
保持最新

00:22:53.640 --> 00:22:56.476
因此我们要保证每小时
至少更新一次

00:22:56.543 --> 00:23:00.113
这适用于快照任务和应用刷新任务

00:23:01.181 --> 00:23:05.719
现在这个预算分散到了
dock中的所有应用

00:23:06.186 --> 00:23:09.122
用户可以选择
在dock中放多少应用

00:23:09.623 --> 00:23:12.893
结果就是如果用户的dock中
应用的数量少

00:23:13.327 --> 00:23:16.163
那么你的应用某特定小时内就有更多

00:23:16.230 --> 00:23:18.665
在后台运行的机会

00:23:19.700 --> 00:23:22.269
另外 我们会把应用留在内存中

00:23:22.736 --> 00:23:26.306
可以迅速重新启动 用户还可以
跟你的应用互动

00:23:26.373 --> 00:23:28.809
如果用户停留在你的应用上
尽可能快地

00:23:30.878 --> 00:23:34.281
另外在dock中 我们有一个
最近使用的应用的概念

00:23:35.582 --> 00:23:38.051
这个应用占据了dock的
最后一个位置

00:23:38.485 --> 00:23:41.555
并且用户有机会
把它放进dock中

00:23:42.222 --> 00:23:43.257
通过按按钮

00:23:44.157 --> 00:23:48.695
对这个应用的处理跟
应用的处理方式完全相同

00:23:48.762 --> 00:23:51.031
用户明确添加到dock中的

00:23:52.065 --> 00:23:55.035
意思就是这个应用

00:23:55.102 --> 00:23:58.138
将收到后台刷新任务和快照任务

00:23:58.205 --> 00:24:00.073
就像dock中的其他应用一样

00:24:00.574 --> 00:24:02.976
所以你要确保一直 预约

00:24:03.043 --> 00:24:04.978
跟系统预约 任何应用、

00:24:05.045 --> 00:24:07.681
任何后台刷新请求 你可能需要的

00:24:09.483 --> 00:24:12.986
有些主屏幕应用不需要定期预约

00:24:14.021 --> 00:24:15.455
请记住这一点

00:24:18.125 --> 00:24:21.828
刚才Eric也提到了
你应用的快照

00:24:22.663 --> 00:24:27.467
对于watchOS 3上的
dock中的应用体验来说至关重要

00:24:28.902 --> 00:24:32.506
有时候 系统需要应用快照

00:24:33.340 --> 00:24:34.708
的原因各种各样

00:24:35.943 --> 00:24:38.111
如果系统要求你的应用

00:24:38.178 --> 00:24:40.714
创建快照是因为我们认为
我们需要一个快照

00:24:41.181 --> 00:24:43.016
这些快照将不会计入你的预算中

00:24:43.383 --> 00:24:46.320
并且不含在
所请求的快照数量之内

00:24:46.386 --> 00:24:47.821
你向系统

00:24:48.455 --> 00:24:51.458
有五个触发器可以导致系统

00:24:51.525 --> 00:24:53.293
向应用要求创建快照

00:24:54.761 --> 00:24:56.797
complication时间线更新

00:24:57.764 --> 00:25:00.300
用户与你的其中一条通知互动

00:25:00.701 --> 00:25:03.704
意思是通知被积极地解除

00:25:03.770 --> 00:25:06.373
并且 如果通知进入通知中心
将不计数

00:25:07.808 --> 00:25:10.077
当应用从前台进入到后台时

00:25:10.143 --> 00:25:13.347
然后再一次 一个小时之后再
提供给应用一个返回 的机会

00:25:13.413 --> 00:25:15.549
到缺省状态 如果适用的话

00:25:16.550 --> 00:25:19.286
最后 为了让一切开始运作

00:25:19.353 --> 00:25:22.523
系统会要求你的应用在启动时
创建一个快照

00:25:23.023 --> 00:25:24.191
这是你的机会

00:25:24.258 --> 00:25:27.628
可以开始预约系统的
其他后台刷新任务

00:25:31.798 --> 00:25:36.069
现在 我想花点儿时间
分享一些最佳范例

00:25:36.136 --> 00:25:37.638
是我们精心挑选的

00:25:37.704 --> 00:25:40.807
在自己的应用上应用后台刷新

00:25:43.410 --> 00:25:46.380
首先 系统想要了解

00:25:46.446 --> 00:25:48.649
与你的需求相关的
尽可能多的信息

00:25:48.715 --> 00:25:50.751
所以 如果需要 就频繁地预约

00:25:51.418 --> 00:25:53.720
应用每获得一个运行的机会

00:25:53.787 --> 00:25:56.990
你都应该考虑重新评估
后台刷新需求

00:25:57.057 --> 00:25:59.793
并适当地预约系统任务

00:26:01.328 --> 00:26:03.764
然而 你不应该觉得
你有义务这样做

00:26:03.830 --> 00:26:06.900
如果系统把你的应用调回来
进行后台刷新任务

00:26:07.334 --> 00:26:10.204
并没有任何意义
也许你刚更新过数据

00:26:10.604 --> 00:26:13.540
需要进行其他工作 要尽快完成

00:26:13.974 --> 00:26:14.808
或者最好是

00:26:16.276 --> 00:26:18.111
当你完成那项工作后

00:26:18.178 --> 00:26:22.816
考虑推迟你已经跟系统预约好的
其他任务

00:26:24.218 --> 00:26:26.520
你应该考虑你得到的所有运行时间

00:26:26.587 --> 00:26:29.690
并确保使应用保持最新数据

00:26:29.756 --> 00:26:32.025
意思是 更新模型和UI

00:26:32.092 --> 00:26:34.528
并预约系统的后台任务

00:26:34.962 --> 00:26:37.598
因此是为了dock
和前台激活、通知、

00:26:37.664 --> 00:26:39.499
complication更新
和后台刷新

00:26:39.566 --> 00:26:43.170
应用获得运行时间的原因
有很多很多

00:26:43.237 --> 00:26:45.305
你应该全部都考虑到

00:26:45.372 --> 00:26:47.241
当你尝试和保持应用数据最新时

00:26:48.942 --> 00:26:54.715
应用刷新后台任务
就是你的切入点

00:26:54.948 --> 00:26:58.118
切入通用的意图运行时间
当你在后台时

00:26:58.452 --> 00:27:00.721
我们认为有一些非常不错的用例

00:27:00.787 --> 00:27:03.824
你可以执行如
拉动系统数据库这样的操作

00:27:04.725 --> 00:27:08.595
也许你想定期读取HealthKit数据库
或日历数据库

00:27:09.396 --> 00:27:11.565
你可以预约未来的URL会话

00:27:11.632 --> 00:27:13.734
这正是我们在股票应用中所执行的

00:27:14.434 --> 00:27:16.170
如果你已经知道时间过渡

00:27:16.236 --> 00:27:19.039
你可以告诉系统你认为

00:27:19.106 --> 00:27:21.542
运行应用最佳的确切日期

00:27:21.742 --> 00:27:25.512
比如 日历应用或旅行应用可能有

00:27:25.712 --> 00:27:28.982
定义良好的时间过渡

00:27:29.816 --> 00:27:32.986
最后 如果你
提前得到后台运行时间

00:27:33.053 --> 00:27:35.789
通过ClockKit API
我们希望你能进入

00:27:35.856 --> 00:27:39.059
WatchKit API触发
complication更新

00:27:42.563 --> 00:27:45.599
现在让我们讲一些快照的最佳范例

00:27:47.668 --> 00:27:50.437
快照是一个系统自有的 缓存

00:27:50.504 --> 00:27:53.273
应用数据 跟普通的缓存一样

00:27:54.107 --> 00:27:55.576
数据也会失效

00:27:55.776 --> 00:27:58.378
因此 系统想了解
数据什么时候会失效

00:27:59.146 --> 00:28:02.816
你可以 通知系统快照需要更新

00:28:02.883 --> 00:28:05.319
通过预约新快照请求

00:28:06.653 --> 00:28:09.556
现在 你应该考虑重大的内容变更

00:28:09.623 --> 00:28:11.525
当你尝试使快照无效时

00:28:11.892 --> 00:28:15.028
你并不想频繁失效

00:28:15.529 --> 00:28:19.366
比如 在倒计时应用中

00:28:19.433 --> 00:28:22.369
你一定不想每秒钟都更新快照

00:28:22.436 --> 00:28:23.537
那样没有任何意义

00:28:23.604 --> 00:28:26.673
相反 你肯定希望通知系统
更新你的快照

00:28:26.740 --> 00:28:29.643
当发生重大事件时 比如计时结束时

00:28:32.746 --> 00:28:34.081
我知道这很复杂

00:28:34.147 --> 00:28:38.919
我想分享一个我认为很棒的
数据流

00:28:38.986 --> 00:28:40.521
关于如何管理这种复杂性

00:28:41.622 --> 00:28:44.024
假如你有一些外部事件

00:28:44.324 --> 00:28:47.027
也许是表连通性
也许是NSURLSession

00:28:47.194 --> 00:28:49.596
也许应用碰巧在前台运行

00:28:49.663 --> 00:28:51.365
因为用户启动了你的应用

00:28:51.665 --> 00:28:55.035
基本上是导致你更新
模型的所有事件

00:28:57.137 --> 00:28:59.907
我们想要你为后台刷新做的所有操作

00:29:00.274 --> 00:29:03.410
是为了回应模型的变更

00:29:03.977 --> 00:29:06.046
比如 更新complication

00:29:06.113 --> 00:29:07.614
请求创建新快照

00:29:08.081 --> 00:29:10.884
然后评估下一次后台刷新需求

00:29:10.951 --> 00:29:12.853
无论是后台URLSession

00:29:12.920 --> 00:29:15.989
或者仅仅是跟后台刷新API
预约任意一个运行时间

00:29:21.495 --> 00:29:24.131
现在watchOS 3中
有了dock

00:29:24.598 --> 00:29:26.967
我们认为用户会

00:29:28.202 --> 00:29:31.872
我们认为用户会出入很多应用

00:29:31.939 --> 00:29:34.107
比watchOS 2上要频繁地多

00:29:34.675 --> 00:29:37.511
在watchOS 2中 你必须准备

00:29:37.578 --> 00:29:40.848
随时进入前台或后台

00:29:41.014 --> 00:29:43.750
但我们认为现在这些转换
发生的频率要高得多

00:29:45.185 --> 00:29:48.121
因此你应该确保
完成所有后台任务

00:29:48.188 --> 00:29:50.724
当处于前台激活状态时尽快

00:29:52.159 --> 00:29:54.094
当应用在前台被激活时

00:29:54.161 --> 00:29:56.864
你一定不想实施任何额外的工作

00:29:56.930 --> 00:29:59.132
你只想做一些有用的工作

00:29:59.199 --> 00:30:01.134
向用户显示UI

00:30:01.702 --> 00:30:05.706
类似的 当应用从前台进入后台时

00:30:05.939 --> 00:30:09.543
你应该尽快完成所有的前台工作

00:30:09.877 --> 00:30:13.046
现在我们意识到
你可能需要一点儿时间

00:30:13.113 --> 00:30:14.581
来完成所有的前台工作

00:30:14.648 --> 00:30:18.619
你可以通过使用NSProcessInfo
.performExpiringActivity实现

00:30:19.386 --> 00:30:24.291
去年的WWDC有一场不错的演讲
是“WatchKit技巧与陷阱”

00:30:24.358 --> 00:30:28.529
教你如何使用NSProcessInfo
.performExpiringActivity

00:30:29.296 --> 00:30:32.299
最后 我还要提一下数据保护

00:30:33.100 --> 00:30:37.137
一般来说
用户是早晨戴上表

00:30:37.604 --> 00:30:40.307
解锁 然后表一整天都是解锁状态

00:30:40.374 --> 00:30:43.177
直到晚上再脱下表 放回充电器

00:30:45.345 --> 00:30:48.749
完全不能获取到
表上某些类型的数据

00:30:48.815 --> 00:30:50.717
当设备为锁定状态时

00:30:50.984 --> 00:30:54.588
比如 其中一个最著名的案例是
HealthKit数据库

00:30:55.222 --> 00:30:58.959
因此 你一定要考虑
你有什么解决方案

00:30:59.026 --> 00:31:01.695
如果数据不可用
不能创建快照的话

00:31:05.766 --> 00:31:08.402
然后我想分享一些测试技巧

00:31:09.636 --> 00:31:12.573
模拟器对于迭代开发来说
是个不错的工具

00:31:12.639 --> 00:31:15.042
我之前提过 我们有一些预算

00:31:15.108 --> 00:31:17.845
但在模拟器中
我们不会强制实施任何预算

00:31:17.911 --> 00:31:21.615
所以 你一般会根据
你想要调用任务的日期

00:31:21.682 --> 00:31:23.584
在模拟器中调用任务

00:31:25.252 --> 00:31:27.154
类似的 当在设备上时

00:31:27.621 --> 00:31:29.456
我们可能仍然需要应用一些预算

00:31:29.523 --> 00:31:31.391
但 你将获得最佳体验

00:31:31.458 --> 00:31:32.526
当在充电器上时

00:31:35.395 --> 00:31:38.298
你要确保你对启动路径和重新启动
路径都进行了测试

00:31:38.365 --> 00:31:41.168
系统会尽可能
把你的应用放在内存中

00:31:42.102 --> 00:31:43.770
但如果有引导程序

00:31:43.837 --> 00:31:45.806
系统将启动你的应用

00:31:45.873 --> 00:31:48.342
以便请求初始快照

00:31:49.843 --> 00:31:51.912
要验证已完成所有任务

00:31:52.446 --> 00:31:54.615
在随后的种子中
你将得到一个崩溃报告

00:31:54.681 --> 00:31:56.617
如果你不能按时完成任务的话

00:31:57.084 --> 00:31:59.853
超级重要的一点是
你的应用并不会崩溃

00:31:59.920 --> 00:32:03.357
因为我们希望你的应用
尽可能地响应用户

00:32:04.691 --> 00:32:06.760
最后 一旦你认为你已经

00:32:06.827 --> 00:32:09.096
实现了后台刷新策略

00:32:09.162 --> 00:32:10.264
你的应用应该已经被激活了

00:32:10.364 --> 00:32:11.798
确保你得到了 体验

00:32:11.865 --> 00:32:13.500
你希望你的用户能得到的

00:32:14.134 --> 00:32:17.304
你应该改变dock中的应用数量

00:32:18.739 --> 00:32:21.575
确保对最好的和最坏的情况
进行充分测试

00:32:21.642 --> 00:32:22.943
当你得到预约时

00:32:23.277 --> 00:32:27.514
现在 我想分享一个案例研究
关于我们如何 应用后台刷新

00:32:27.581 --> 00:32:28.882
在我们的股票应用中

00:32:30.817 --> 00:32:33.620
在我们开始写代码之前

00:32:34.288 --> 00:32:38.425
我们先退一步思考一下

00:32:38.492 --> 00:32:40.627
进行后台刷新的有趣特征

00:32:40.694 --> 00:32:41.995
为我们的股票应用

00:32:43.764 --> 00:32:47.067
我们使用URLSession
取回服务器数据

00:32:49.570 --> 00:32:51.338
且要做一个complication

00:32:51.772 --> 00:32:54.141
意思就是 我们知道 有多个视图

00:32:54.208 --> 00:32:55.843
系统中的数据

00:32:55.909 --> 00:32:58.145
通过complication、快照

00:32:58.745 --> 00:33:01.281
以及激活应用

00:33:04.084 --> 00:33:08.255
我们知道 我们想要周期性地运行

00:33:08.755 --> 00:33:11.592
我们要定期更新应用

00:33:12.659 --> 00:33:14.728
然后 我们了解了数据中一些有趣的东西

00:33:14.795 --> 00:33:19.233
就是一旦股市关闭 我们的数据
在当天剩余的时间内是没什么问题的

00:33:19.299 --> 00:33:20.767
根本不会发生变化

00:33:21.201 --> 00:33:24.037
嗯 让我们讲一下应用的运行

00:33:25.005 --> 00:33:27.741
假如我们的设备启动

00:33:27.808 --> 00:33:30.978
系统会要求
我们的应用创建一个快照

00:33:31.712 --> 00:33:34.348
因此 我们加载最新数据
并准备好UI

00:33:34.414 --> 00:33:36.383
但在完成快照任务之前

00:33:36.450 --> 00:33:39.453
我们要预约一个
后台的URLSession任务

00:33:40.420 --> 00:33:43.724
这是我们开始后台刷新周期
的机会

00:33:44.691 --> 00:33:48.128
并确保为用户下载最新数据

00:33:49.496 --> 00:33:53.300
现在 我们要使用
NSURLSessionDownloadTask

00:33:53.634 --> 00:33:58.472
给系统提供我们想要下载
哪种数据的信息

00:33:58.539 --> 00:34:01.175
系统可以让我们的应用休眠

00:34:01.241 --> 00:34:02.843
并在后台下载数据

00:34:04.077 --> 00:34:08.949
URLSessionDataTask
的确能在后台会话中运行

00:34:09.248 --> 00:34:11.518
然而 如果应用在后台

00:34:11.585 --> 00:34:15.889
或当应用被挂起时 它会失败

00:34:17.424 --> 00:34:19.893
因为后台刷新有时间限制

00:34:19.960 --> 00:34:23.964
你的应用很可能会在
得到数据之前就被挂起了

00:34:24.031 --> 00:34:26.667
所以我们建议使用下载任务

00:34:28.402 --> 00:34:32.239
稍后 系统会唤醒我们的应用

00:34:32.306 --> 00:34:33.873
因为我们已经完成了下载

00:34:34.908 --> 00:34:38.011
我们会更新我们的模型
因为我们已经更新了模型

00:34:38.078 --> 00:34:39.612
我们有三件事要去做

00:34:39.913 --> 00:34:41.982
触发complication更新

00:34:43.250 --> 00:34:46.954
通过请求
通知系统快照已经失效

00:34:47.020 --> 00:34:48.487
立即创建新快照

00:34:49.556 --> 00:34:53.025
并评估
下一次后台刷新需求

00:34:54.460 --> 00:34:56.964
计划好下一次的运行时间

00:34:57.030 --> 00:34:58.432
并把这个时间通知给系统

00:35:00.033 --> 00:35:03.337
稍后 我们开始运行后台刷新

00:35:03.403 --> 00:35:06.940
我们所要做的就是预约
下一次的URLSession下载

00:35:07.741 --> 00:35:11.745
我们一天之内要完成多个
这样的周期

00:35:12.746 --> 00:35:15.649
就是为了保证应用的数据
是最新的 系统会创建快照

00:35:15.716 --> 00:35:17.451
若用户在dock中
浏览我们快照

00:35:17.518 --> 00:35:21.288
我们的快照会显示最新的数据

00:35:22.956 --> 00:35:25.526
嗯 假如用户从dock中
激活了我们的应用

00:35:26.093 --> 00:35:27.361
我们应用会变成全屏显示

00:35:28.061 --> 00:35:30.764
并且我们想确保我们的用户
有最新的数据

00:35:30.831 --> 00:35:34.368
所以我们将再次下载最新数据

00:35:34.434 --> 00:35:35.936
因为我们已经进入前台

00:35:37.237 --> 00:35:40.707
一旦完成模型的更新
我们仍然要完成三件事

00:35:40.774 --> 00:35:42.676
我们要请求
complication更新

00:35:42.910 --> 00:35:44.278
还要请求创建新快照

00:35:44.978 --> 00:35:47.915
然后还要再次预约
稍后的后台刷新

00:35:48.182 --> 00:35:49.883
在这里 我要指出两点

00:35:50.250 --> 00:35:53.854
首先 虽然我们已经进入前台
但我们仍然正在请求创建新快照

00:35:54.354 --> 00:35:57.724
这绝对没问题
而且我们也期待你们这样做

00:35:57.791 --> 00:36:00.727
我们希望只要模型发生变更
就请求创建新快照

00:36:00.794 --> 00:36:03.964
系统非常智能
它知道你的应用何时处于前台

00:36:04.031 --> 00:36:07.267
以及何时不适合
给你发送快照任务

00:36:08.335 --> 00:36:11.271
第二点 因为我们是在前台运行

00:36:11.905 --> 00:36:13.106
并更新了模型

00:36:13.407 --> 00:36:16.443
我们得评估
下一次的后台刷新需求

00:36:16.910 --> 00:36:19.913
如果我们知道
我们很可能会在十分钟后运行

00:36:19.980 --> 00:36:21.648
但我们只下载了数据

00:36:22.416 --> 00:36:26.653
我们可以推迟创建快照
或者推迟后台刷新请求

00:36:26.720 --> 00:36:30.791
使运行时间最大化

00:36:32.326 --> 00:36:34.728
要使应用运行的几率最大化

00:36:37.264 --> 00:36:40.100
最后 股市关闭之前
做最后一次更新

00:36:41.301 --> 00:36:43.303
我们知道 当天的数据将不会再发生变化

00:36:44.304 --> 00:36:45.973
但是我们会像往常一样完成更新

00:36:46.039 --> 00:36:48.008
意思是更新complication

00:36:48.542 --> 00:36:49.977
请求创建新快照

00:36:50.577 --> 00:36:53.113
然后评估后台刷新需求

00:36:54.882 --> 00:36:57.718
因为我们知道
当天的数据会停止更新

00:36:57.784 --> 00:37:01.154
我们不能在complication
或快照中保留失效的数据

00:37:02.623 --> 00:37:05.025
我们可以等待
直到股市下一次开市

00:37:05.092 --> 00:37:07.160
获得下一次后台刷新的机会

00:37:08.762 --> 00:37:12.432
这就使我们的应用避开系统

00:37:12.499 --> 00:37:14.668
并且不用完成任何不必要的工作

00:37:15.002 --> 00:37:16.870
意思就是
会获得更多的刷新任务

00:37:16.937 --> 00:37:18.539
系统上的其他应用

00:37:21.208 --> 00:37:25.312
总之 一定要完成任务

00:37:25.412 --> 00:37:27.748
完成任务非常重要

00:37:27.814 --> 00:37:29.483
如果没有完成任务
在随后的种子中

00:37:29.550 --> 00:37:31.652
系统会扼杀你的应用

00:37:31.718 --> 00:37:33.654
如果系统扼杀了你的应用

00:37:33.720 --> 00:37:38.825
用户在dock中就不会得到
他们所期待的快速响应时间

00:37:38.959 --> 00:37:41.061
并且用户将
把你的应用从dock中移除

00:37:42.763 --> 00:37:45.132
要有效地利用运行时间

00:37:45.199 --> 00:37:48.468
考虑前台激活、
通知、ClockKit

00:37:48.535 --> 00:37:51.738
当然还有后台刷新机会

00:37:52.039 --> 00:37:53.540
无论什么时候获得运行时间

00:37:53.774 --> 00:37:56.877
都一定要考虑保持最新的模型

00:37:56.944 --> 00:37:59.580
并评估后台刷新需求

00:38:01.281 --> 00:38:03.383
当数据发生变更时要通知系统

00:38:04.218 --> 00:38:06.887
你的complication
和你的应用快照

00:38:06.954 --> 00:38:11.558
都是系统自有的应用数据缓存

00:38:12.659 --> 00:38:16.129
系统需要了解何时数据失效

00:38:16.496 --> 00:38:19.132
以便我们不会
给用户显示错误的数据

00:38:19.600 --> 00:38:22.269
用户期待看到一致的数据

00:38:22.636 --> 00:38:25.038
无论他们用什么方式
浏览应用数据

00:38:26.673 --> 00:38:29.076
最后 你需要 来决定应用策略

00:38:29.142 --> 00:38:30.744
具体分析

00:38:30.811 --> 00:38:32.513
没有适合所有情况的解决方案

00:38:32.579 --> 00:38:36.016
你一定要考虑用户
是如何使用应用的

00:38:36.283 --> 00:38:38.352
以及数据的有趣性特征

00:38:38.418 --> 00:38:40.721
从而决定如何计划后台刷新策略

00:38:42.122 --> 00:38:44.858
要了解更多信息
你可以访问这个网站

00:38:45.392 --> 00:38:49.796
今天下午3点还有一场
非常不错的演讲

00:38:49.863 --> 00:38:55.068
构造watchOS 3上的性能
我们将具体阐述股票应用的实现

00:38:55.135 --> 00:38:56.270
谢谢大家