00:00:19.586 --> 00:00:22.222
利用现代最佳实践优化现有应用

00:00:25.659 --> 00:00:26.527
大家好

00:00:29.229 --> 00:00:30.097
好啦

00:00:32.031 --> 00:00:34.434
我叫Woody
在Apple做软件工程

00:00:34.501 --> 00:00:37.804
欢迎大家参加本次大会
欢迎在座的各位

00:00:37.871 --> 00:00:40.574
还有在家在线观看的各位

00:00:41.875 --> 00:00:45.312
在接下来的40分钟里
我想跟大家讲几点内容

00:00:45.579 --> 00:00:48.048
我们来看看通过一些方式 你今后可以

00:00:48.115 --> 00:00:49.750
开始减少你的技术负债

00:00:49.983 --> 00:00:51.985
我们再来看看
资源目录

00:00:52.686 --> 00:00:54.321
看看新的设计模式

00:00:54.388 --> 00:00:56.156
不完全是新的 但是设计模式

00:00:56.223 --> 00:00:59.126
希望你们使用依赖注入

00:00:59.660 --> 00:01:01.795
讲座的后半段会更新一下

00:01:01.862 --> 00:01:05.232
我去年关于Live
Playgrounds的讲座

00:01:06.033 --> 00:01:07.034
那么我们就开始吧

00:01:08.068 --> 00:01:10.137
去年的讲座 在一个实验室中

00:01:10.337 --> 00:01:11.538
我见到其中一个观众...

00:01:12.306 --> 00:01:13.907
在描述一个场景

00:01:13.974 --> 00:01:18.378
描述一件我想你们中许多人都熟悉的事

00:01:18.946 --> 00:01:23.150
你的老大给了你一堆功能的要求

00:01:23.217 --> 00:01:27.020
这些功能会产生收入 你想获得报酬
于是你照做

00:01:27.721 --> 00:01:28.889
然后你有客户

00:01:28.956 --> 00:01:31.258
他们想要修补让他们头疼的错误

00:01:31.692 --> 00:01:34.294
你以你的工作为傲
所以你也想做那个

00:01:35.128 --> 00:01:36.763
有些技术负债要解决

00:01:36.830 --> 00:01:38.799
有时我认为开发软件

00:01:38.866 --> 00:01:40.934
就像搭Jenga积木

00:01:41.001 --> 00:01:44.605
第一个版本比较稳定
你开始往它上面叠加东西

00:01:44.671 --> 00:01:47.274
然后它开始变得不稳定
之后就崩溃了

00:01:47.341 --> 00:01:48.775
所以 你得退一步

00:01:48.842 --> 00:01:51.078
可能要先解决一些低层次的问题

00:01:53.013 --> 00:01:54.114
带着这些问题

00:01:55.949 --> 00:01:57.184
你才来参加WWDC

00:01:58.185 --> 00:01:59.853
我们叠加在新的API上

00:02:02.890 --> 00:02:06.326
我们给你一个新的Swift版本
它打破源代码的兼容性

00:02:06.393 --> 00:02:07.928
但引入了一些新的功能

00:02:08.328 --> 00:02:11.265
而且有提醒你
所以不要抱怨它

00:02:12.966 --> 00:02:17.237
然后我们引入了新平台和新扩展点

00:02:17.304 --> 00:02:19.873
及一些现有的应用
例如Siri和Messages

00:02:20.274 --> 00:02:23.844
如果你想把自己的角色定位为开发者
作为一个运行循环

00:02:23.911 --> 00:02:25.812
所有这些事都被挤进去

00:02:26.113 --> 00:02:28.415
你知道会发生什么
有太多东西了

00:02:28.482 --> 00:02:30.384
那么你要做什么？

00:02:30.450 --> 00:02:32.553
有些什么事是你可以开始

00:02:32.619 --> 00:02:34.521
为今年秋季做准备？

00:02:34.988 --> 00:02:40.127
首先 如果你支持
iOS 8和9的部署目标

00:02:40.494 --> 00:02:42.563
你会覆盖95%的设备

00:02:42.763 --> 00:02:46.166
真的没必要把那些部署目标设置在7

00:02:46.600 --> 00:02:47.634
不要它了

00:02:47.701 --> 00:02:49.603
事实上 大概的想法是

00:02:49.670 --> 00:02:53.240
你采用当前的推送版本 即9.3

00:02:53.740 --> 00:02:57.845
然后将你的部署目标设定在
上一个版本 也许是8.4

00:02:58.345 --> 00:03:00.881
但不要再到8.3或8.2了

00:03:00.948 --> 00:03:03.183
因为你的客户不会得益于

00:03:03.250 --> 00:03:06.587
我们对8.4的下行版本所执行的优化

00:03:07.487 --> 00:03:09.790
当我们在今秋公布iOS X时

00:03:10.958 --> 00:03:12.559
将你的部署目标设置为9.3

00:03:15.028 --> 00:03:17.531
下一个 问题导航

00:03:19.399 --> 00:03:20.667
解决那些问题

00:03:20.734 --> 00:03:22.135
检查然后修正它们

00:03:23.003 --> 00:03:25.372
当我们告诉你...有...

00:03:25.939 --> 00:03:28.041
当我们告诉你有不建议使用的API

00:03:28.108 --> 00:03:30.043
不建议使用API
是出于一系列原因

00:03:30.110 --> 00:03:32.546
包括实现更好的错误处理

00:03:32.613 --> 00:03:36.750
或作出更好的报告 或允许更多性能

00:03:36.817 --> 00:03:39.486
或只是增加灵活度
在参数返回值中

00:03:39.686 --> 00:03:41.688
而且真的没有理由不升级

00:03:42.189 --> 00:03:43.023
到

00:03:43.790 --> 00:03:45.759
新的API
因为我们就告诉你

00:03:45.826 --> 00:03:46.994
我们告诉你用什么

00:03:47.261 --> 00:03:48.896
那么 就用它 转到那些

00:03:50.030 --> 00:03:52.833
接下来 你可能要决定
你要将警报视为错误

00:03:53.233 --> 00:03:55.536
我们已用Objective-C
有一阵子了

00:03:55.936 --> 00:03:58.539
但现在我们在Xcode 8中
对Swift也有了

00:04:00.174 --> 00:04:01.074
没错

00:04:02.910 --> 00:04:04.912
我想我是第一个告诉你们这个信息的人

00:04:06.146 --> 00:04:08.048
我非常喜欢这个想法 很棒

00:04:08.115 --> 00:04:11.818
将警报视为错误 这样它就会
强迫你和你的团队去解决问题

00:04:12.019 --> 00:04:14.488
太容易会忽略那些黄色的警报

00:04:14.555 --> 00:04:16.790
而且过后再回来处理它们
然后你没有

00:04:16.857 --> 00:04:18.659
那整个就成技术负债了

00:04:20.427 --> 00:04:21.361
而且

00:04:22.095 --> 00:04:24.031
你觉得这样有用吗 如果你...

00:04:24.998 --> 00:04:27.067
搭建也许一个1.0版的新项目

00:04:27.134 --> 00:04:30.304
一个新应用 然后你对你的团队说
我们要发布1.0

00:04:30.370 --> 00:04:32.439
但我们没有绘图
还没有

00:04:32.506 --> 00:04:33.907
上面没有任何图标

00:04:33.974 --> 00:04:36.610
我们要发布它 然后将
那些在.1版本里做补充

00:04:37.077 --> 00:04:40.681
那根本行不通 没人会那样做
这就是用户如何与你的应用互动

00:04:41.715 --> 00:04:45.118
嗯 实际上是许多但不是
所有用户与你的应用互动

00:04:45.485 --> 00:04:48.355
许多人利用辅助功能
与你的应用互动

00:04:48.422 --> 00:04:50.190
该功能已嵌入操作系统

00:04:50.991 --> 00:04:53.760
所以 你为什么要发布你的应用

00:04:54.094 --> 00:04:57.831
为需要它或使用它的人带绘图
但里面又没有辅助功能？

00:04:57.898 --> 00:04:58.866
那不公平

00:04:59.466 --> 00:05:02.169
解决关于辅助功能的技术负债

00:05:02.236 --> 00:05:04.838
为其添加支持辅助功能

00:05:04.905 --> 00:05:08.208
是你的用户界面的一部分
和绘图一样

00:05:12.546 --> 00:05:13.547
它是嵌入Xcode的

00:05:13.780 --> 00:05:17.384
对此你可使用Interface
Builder编程也容易

00:05:19.686 --> 00:05:21.955
我们有许多能识别区域的API

00:05:22.523 --> 00:05:25.225
你应该用那些 你可以少写些代码

00:05:25.492 --> 00:05:27.027
尽管那个不算新的

00:05:27.561 --> 00:05:28.829
但这些是

00:05:29.730 --> 00:05:32.866
Dimension和MeasurementFormatter
若你有菜谱或健康类应用

00:05:32.933 --> 00:05:35.536
你一直在metric和
imperial之间转换

00:05:35.602 --> 00:05:36.670
在你自己的代码上

00:05:36.737 --> 00:05:39.873
不要那些了 用我们秋季将发布的代码

00:05:41.108 --> 00:05:43.844
我们想要你支持Peek Pop
和Quick Actions

00:05:44.745 --> 00:05:45.712
好吗？

00:05:47.214 --> 00:05:49.349
你知道吗
如果你现在有iPhone 6S

00:05:51.418 --> 00:05:54.254
你可能已经习惯...
我们来按这个看看它会做什么

00:05:54.321 --> 00:05:56.657
没有 我们按那个看看它做什么

00:05:56.723 --> 00:05:58.892
那个会做点什么
很难察觉

00:05:58.959 --> 00:06:01.261
那会有多棒
如果我们的每个应用

00:06:01.328 --> 00:06:04.798
已经支持Peek Pop和
Push及3D触摸？

00:06:05.832 --> 00:06:06.667
接下来

00:06:12.773 --> 00:06:16.109
要运行Swift Migrator
用Xcode 8开发者预览

00:06:16.877 --> 00:06:19.880
如果没有迁移你的代码
提交错误报告并告诉我们

00:06:20.347 --> 00:06:22.216
那我们就有机会修正它

00:06:22.282 --> 00:06:24.484
等你在秋季实际运行Migrator

00:06:24.785 --> 00:06:26.320
在Xcode 8最终版本上

00:06:27.087 --> 00:06:28.155
它就很可能可以用

00:06:29.623 --> 00:06:30.624
如果它不能用

00:06:30.691 --> 00:06:32.793
我们用API解决我们自己的技术负债

00:06:32.860 --> 00:06:34.294
公共界面是一样的

00:06:34.361 --> 00:06:36.730
但执行可能会在不同版本之间有变化

00:06:36.797 --> 00:06:39.199
可能是你使用任何API的方式

00:06:40.434 --> 00:06:43.170
不是我们所预期的

00:06:43.904 --> 00:06:45.005
你就有一个边缘案例

00:06:45.572 --> 00:06:48.542
那你也将其告诉我们
这就是为什么我们做这些预览版

00:06:50.777 --> 00:06:52.246
我们想要你提交错误报告

00:06:52.779 --> 00:06:55.716
报告并不只是走廊的玩笑

00:06:55.782 --> 00:06:57.851
不只是在开发者论坛写文章

00:06:58.185 --> 00:07:00.354
也不只是发送电邮给Apple

00:07:00.888 --> 00:07:02.523
提交错误报告的恰当方式是...

00:07:03.457 --> 00:07:05.659
是这个
BugReport.Apple.com

00:07:05.792 --> 00:07:06.760
填写空白处

00:07:08.295 --> 00:07:11.198
你填完后会获得一个号码
用那个号码你进入

00:07:11.265 --> 00:07:12.699
并发帖到开发者论坛

00:07:12.766 --> 00:07:15.169
有很多Apple工程师
浏览开发者论坛

00:07:15.235 --> 00:07:16.703
我们想听听你的意见

00:07:17.337 --> 00:07:19.506
但当你在那些组里提交或报告一个问题

00:07:19.573 --> 00:07:23.010
你没附上错误报告号码

00:07:23.076 --> 00:07:26.547
我们很难在内部跟进和追踪它

00:07:26.613 --> 00:07:27.581
所以 得那样做

00:07:29.983 --> 00:07:30.918
接下来

00:07:32.419 --> 00:07:33.487
你可能...

00:07:35.622 --> 00:07:37.724
不是非常喜欢向我们提交错误报告

00:07:39.560 --> 00:07:40.894
因为你提交它们了之后...

00:07:41.395 --> 00:07:43.397
然后你等啊等 石沉大海

00:07:43.730 --> 00:07:44.865
你没得到任何回应

00:07:45.399 --> 00:07:48.769
用Whitney Houston的歌词说
孤单的错误报告去哪儿？

00:07:49.203 --> 00:07:52.840
它们好像进入一个巨大无比的黑洞
因为你永远得不到任何回应

00:07:53.440 --> 00:07:55.008
或者你觉得也许

00:07:55.576 --> 00:07:57.811
你在一个工程师面前得到回应
而那个工程师

00:07:57.878 --> 00:07:59.980
有点不理会你所说的

00:08:01.815 --> 00:08:04.318
我只是想和你们保证
不是那样的

00:08:04.384 --> 00:08:07.221
我加入Apple后的第一件事就是
我搜索了一下

00:08:07.287 --> 00:08:10.457
错误追踪系统
问题追踪系统

00:08:10.824 --> 00:08:14.328
以寻找我当时作为一个外部开发者时
提交的所有问题

00:08:14.394 --> 00:08:17.564
当中许多问题都有跟踪
我只是从未得到来自它们的任何反馈

00:08:17.631 --> 00:08:20.467
我想跟各位说 如果你的确提交了错误
我们的确会查看它们

00:08:21.635 --> 00:08:24.671
另一件事是 你可能花很多时间提交错误

00:08:25.305 --> 00:08:27.541
很多时间你可能是在做一些样本代码

00:08:28.208 --> 00:08:30.677
你在试不同的设备
检查回归

00:08:30.744 --> 00:08:31.979
这样做很好

00:08:32.078 --> 00:08:34.147
你花了可能半个小时或一个小时

00:08:34.581 --> 00:08:37.183
然后你提交它 然后它回来
说是个复本

00:08:37.851 --> 00:08:40.386
然后你就觉得 刚浪费了
生命的半个、一个小时

00:08:40.453 --> 00:08:41.922
为了别人做过的事情

00:08:43.724 --> 00:08:45.659
我只想简单讲讲复本

00:08:46.560 --> 00:08:49.563
因为复本首先不是表决系统

00:08:49.630 --> 00:08:51.999
不像是 如果你复制
别人的错误 一字不漏

00:08:52.132 --> 00:08:54.434
然后你用同样的东西提交一个新错误

00:08:54.501 --> 00:08:56.603
我们说 对此有一个表决
我们会先修正它

00:08:56.670 --> 00:08:58.038
不太像是那样子

00:08:58.906 --> 00:09:01.241
我们怎么处理它们
即使它们是复本

00:09:01.308 --> 00:09:02.910
只是意味这这两个是相关的

00:09:03.477 --> 00:09:06.046
我们也需要复本
不是为了表决的目的

00:09:06.346 --> 00:09:10.817
但因为我们可以有五个人提交
相同的根错误 相同的根问题

00:09:11.718 --> 00:09:12.786
前四个

00:09:14.555 --> 00:09:16.523
没有给我们足够的信息去找到它

00:09:16.957 --> 00:09:19.426
但也许是你的报告
也许是你的第五个

00:09:20.093 --> 00:09:21.295
尽管是个复本

00:09:22.029 --> 00:09:24.932
但是当中的信息是我们所需的
让我们找到问题

00:09:26.333 --> 00:09:27.167
事实上

00:09:27.968 --> 00:09:31.104
一个在Apple待了几十年的工程师

00:09:31.638 --> 00:09:32.840
说了一句很风趣的话

00:09:35.509 --> 00:09:36.710
在几个星期前

00:09:36.777 --> 00:09:40.647
Paul说每个错误报告
跟一片雪花一样独特

00:09:40.714 --> 00:09:41.548
应该是这样的

00:09:42.349 --> 00:09:44.685
好 那么小结一下
今天先讲的部分是

00:09:44.885 --> 00:09:47.054
修正你的警报
替代不建议使用的API

00:09:47.287 --> 00:09:49.022
本地化你的应用 如果还没的话

00:09:49.923 --> 00:09:51.291
使用辅助功能

00:09:52.192 --> 00:09:54.828
或支持辅助功能获取Peek和Pop

00:09:54.928 --> 00:09:56.997
然后看看下一个版本的Xcode

00:09:57.231 --> 00:09:58.966
给我们一些关于它的反馈

00:09:59.666 --> 00:10:01.568
接着讲资源目录

00:10:04.004 --> 00:10:07.841
是时候为各位讲讲
资源目录

00:10:07.908 --> 00:10:10.577
如果你还没有文件
在你的文件导航里 像这样

00:10:12.579 --> 00:10:14.915
去获取它们放在资源目录里
像那样

00:10:15.849 --> 00:10:16.683
方法...

00:10:17.985 --> 00:10:20.521
是你从文件菜单中
添加一个目录

00:10:22.289 --> 00:10:23.991
你无须只添加一个目录

00:10:24.057 --> 00:10:26.393
你可在项目中添加许多目录

00:10:26.527 --> 00:10:30.030
也许你正在做一个应用是个卡片游戏

00:10:31.798 --> 00:10:34.535
那么 你有个目录
用于卡片的正面图像

00:10:34.601 --> 00:10:37.571
第二个目录用于卡片的
背面图像 我们可以做到

00:10:38.238 --> 00:10:40.607
举个例子 你可能让你的图形设计师

00:10:40.674 --> 00:10:42.609
从App Store
免费下载Xcode

00:10:44.178 --> 00:10:45.812
为你创建资源目录

00:10:46.547 --> 00:10:49.550
然后发送给你
或在代码库里检查

00:10:49.917 --> 00:10:50.817
我们也能做到

00:10:51.652 --> 00:10:55.289
复制文件到资源目录时
它们正是复本

00:10:55.422 --> 00:10:57.624
我们从不参考原始位置

00:10:57.691 --> 00:10:59.660
那么 它们的确参与版本控制

00:11:03.096 --> 00:11:05.432
为了迁移你的项目
你点击big plus键

00:11:05.732 --> 00:11:07.334
选择“从项目导入”

00:11:09.369 --> 00:11:11.505
我们会给你一列合资格的资源

00:11:11.572 --> 00:11:15.442
从文件导航迁移
到资源目录

00:11:18.512 --> 00:11:20.747
像这样
你迁移了你的图像资源

00:11:21.915 --> 00:11:23.050
如果你之前...

00:11:23.817 --> 00:11:27.187
习惯使用bundle API
pathForResource等等

00:11:27.254 --> 00:11:29.656
那已经不能再用了
因为一旦我们编写了应用

00:11:29.723 --> 00:11:32.726
图像不是周围自由浮动的
所以你找不到任何东西

00:11:32.793 --> 00:11:33.794
但如果你使用...

00:11:36.029 --> 00:11:37.030
已被命名的图像

00:11:37.598 --> 00:11:39.633
我们可找到它们
若其在资源目录里

00:11:39.700 --> 00:11:42.669
而且我们可以找到它们
如果它们只是自由浮动

00:11:42.736 --> 00:11:44.071
仍在你的文件导航里

00:11:44.238 --> 00:11:48.208
这个API出来已有一阵了
API图像名有许多优点

00:11:48.275 --> 00:11:51.411
超越仅仅只能从
图像目录中找到内容

00:11:52.079 --> 00:11:53.280
资源目录

00:11:53.380 --> 00:11:55.115
例如 它内部缓冲

00:11:55.182 --> 00:11:57.217
第一次你以名称找一个图像

00:11:57.284 --> 00:11:58.752
我们加载它
我们给一个参考

00:11:58.819 --> 00:12:00.721
第二次你以名称找同样那个图像

00:12:00.787 --> 00:12:02.723
我们对同一个东西返回另一个参考

00:12:03.290 --> 00:12:06.059
那不是文件内容的API如何运作的

00:12:06.126 --> 00:12:08.128
每一次文件内容会加载新图像

00:12:08.562 --> 00:12:09.630
它更加高性能

00:12:09.696 --> 00:12:12.833
尤其当你滚动表格
使用已被命名图像时

00:12:14.735 --> 00:12:16.970
我们支持一个资源的多个表现

00:12:17.037 --> 00:12:18.472
所以 使用已被命名图像

00:12:19.072 --> 00:12:20.073
你给它一个名称

00:12:20.507 --> 00:12:21.341
API名称

00:12:22.109 --> 00:12:25.145
你让框架考虑你正在运行的设备

00:12:26.380 --> 00:12:28.882
考虑显示屏的分辨率 视网膜

00:12:28.949 --> 00:12:30.784
非视网膜 Plus设备上的视网膜

00:12:33.954 --> 00:12:35.956
而且可能有其他区别因素

00:12:36.056 --> 00:12:39.092
对于媒体资源例如
设备中的内存容量

00:12:39.493 --> 00:12:42.529
或者设备所支持的Metal的版本

00:12:44.998 --> 00:12:46.099
你得到一个图像返回

00:12:47.267 --> 00:12:50.771
有两大类资源类型
对于你可以考虑的图像

00:12:50.838 --> 00:12:52.139
我们有缩放图像

00:12:52.206 --> 00:12:53.440
例如PNG

00:12:54.708 --> 00:12:55.642
JPEG

00:12:56.143 --> 00:12:59.112
然后我们有单矢量图像

00:12:59.179 --> 00:13:01.682
比如PDF或SPG

00:13:03.717 --> 00:13:05.452
我们对待它们有点不同

00:13:05.986 --> 00:13:07.421
在逐个资源的基础上

00:13:07.487 --> 00:13:09.690
你可以说这个资源会变成矢量型

00:13:09.756 --> 00:13:11.291
那个资源会变成缩放

00:13:12.392 --> 00:13:14.294
你通过指定比例因子来实现

00:13:16.363 --> 00:13:18.532
我讲讲一些缩放图像

00:13:18.599 --> 00:13:20.567
然后再讲讲矢量图像

00:13:21.301 --> 00:13:22.302
对于缩放图像

00:13:23.003 --> 00:13:27.207
在这个例子中我们已经叫你们
提供三个不同版本的绘图

00:13:27.274 --> 00:13:30.244
从1X设备非视网膜
到2X和3X

00:13:31.078 --> 00:13:33.447
如果我们找不到
由于你没有包括

00:13:34.381 --> 00:13:37.317
2X和3X 我们拿1X的图像
将它放大

00:13:37.384 --> 00:13:38.519
它就变成

00:13:39.186 --> 00:13:42.890
在更高端设备上或
更高密度设备上使用的图像

00:13:46.360 --> 00:13:47.261
同样

00:13:47.761 --> 00:13:51.298
如果你只是提供给我们3X的绘图
我们在运行时间将它缩放

00:13:52.232 --> 00:13:54.501
这两个情况不是那么理想

00:13:54.568 --> 00:13:58.839
这个情况中 若我拿1X图像将它放大
用于iPhone 6S Plus

00:13:58.906 --> 00:14:00.207
它看上去非常凹凸不平

00:14:00.274 --> 00:14:02.342
它会有一种视觉上的效果
叫图形失真

00:14:02.409 --> 00:14:03.644
它不是很理想

00:14:04.378 --> 00:14:06.013
嗯 你的客户不会喜欢它

00:14:07.447 --> 00:14:09.449
这个 初看时你能会想 哦

00:14:09.516 --> 00:14:12.052
我只是提供3X绘图让你缩放

00:14:12.686 --> 00:14:14.655
但那样有个巨大的问题 因为

00:14:14.755 --> 00:14:17.591
要缩放一个3X图像
我们要打开一个3X图像

00:14:18.125 --> 00:14:19.092
它非常大

00:14:19.693 --> 00:14:20.527
然后...

00:14:21.295 --> 00:14:24.865
我们提取像素 为它创建一个缩放版本

00:14:26.733 --> 00:14:29.403
它可能是一、两个数量级更大

00:14:30.404 --> 00:14:31.438
所以 想想这个

00:14:32.406 --> 00:14:35.475
你在使用一个设备 比如5S、5C

00:14:36.210 --> 00:14:40.013
上面没必要用3X图像
但你只提供3X图像

00:14:40.814 --> 00:14:43.050
那么 我们从使用的内存的基准线开始

00:14:43.851 --> 00:14:46.954
没问题
但是然后我们得加载3X图像

00:14:47.221 --> 00:14:50.958
转换它 去掉3X图像
然后留下这个缩放的版本

00:14:51.225 --> 00:14:54.494
这样临时造成一个内存峰值
如果你行的话

00:14:54.561 --> 00:14:56.363
可能会没问题

00:14:56.430 --> 00:14:59.633
如果你行 我的意思是如果你幸运的话
可能会没问题

00:15:01.235 --> 00:15:03.403
但 假设你滚动表格视图

00:15:03.604 --> 00:15:05.706
你在滚动时
我们得不断做这个

00:15:05.772 --> 00:15:08.442
突然你应用的内存使用一下子膨胀了

00:15:08.809 --> 00:15:10.878
知道当你使用过多内存
会发生什么事吗？

00:15:11.044 --> 00:15:12.579
有谁知道的 大声说出来

00:15:13.380 --> 00:15:15.282
对 没错
我们终止它

00:15:15.349 --> 00:15:17.117
它死机了

00:15:17.184 --> 00:15:19.853
由于你没有提供绘图
所以 请提供绘图

00:15:19.920 --> 00:15:23.090
事实上 你可以非常轻松地
用进程来实现这个 或者

00:15:23.156 --> 00:15:25.192
不是用进程 而是
Automator工作流程

00:15:25.726 --> 00:15:28.495
你给它一个3X图像
让它缩放 给它个名称

00:15:28.562 --> 00:15:30.097
缩放它 给它个名称 很好

00:15:30.163 --> 00:15:31.865
把那些扔进
你的资源目录

00:15:31.932 --> 00:15:33.700
而如果你想要 你可以

00:15:35.302 --> 00:15:38.105
这是另外一个最佳实践
使用这个命名惯例

00:15:38.505 --> 00:15:41.708
非视网膜的只是
Align Justify.PNG

00:15:42.209 --> 00:15:44.478
然后添加2X、添加3X和其他两个

00:15:44.845 --> 00:15:48.048
然后当你拖放它们三个
到资源目录

00:15:48.115 --> 00:15:49.383
我们找到一个命名惯例

00:15:49.449 --> 00:15:52.186
我们创建一个资源
用三种不同的呈现

00:15:52.252 --> 00:15:54.154
相对于三个不同的资源

00:15:54.955 --> 00:15:56.290
对于矢量资源

00:15:56.356 --> 00:15:58.559
矢量资源很神奇
因为文件包括

00:15:58.625 --> 00:16:00.761
一套如何绘图的指示

00:16:01.628 --> 00:16:03.463
相对于让它预先栅格化

00:16:04.198 --> 00:16:08.001
它是同一个图像 不是三个版本
同一个图像缩放到不同的大小

00:16:09.503 --> 00:16:11.305
当你指明你要使用

00:16:11.371 --> 00:16:14.208
单矢量缩放
提供一个矢量图像

00:16:14.274 --> 00:16:17.544
在构建时间 我们将它栅格化成
我们需要的不同大小

00:16:18.612 --> 00:16:19.913
对你来说更简单

00:16:20.214 --> 00:16:22.883
这像是你可能会对工具栏图像会做的事

00:16:22.950 --> 00:16:24.284
以及导航栏图像

00:16:25.919 --> 00:16:27.788
看 缩放因子 单矢量

00:16:28.455 --> 00:16:30.591
也可能二者结合

00:16:31.758 --> 00:16:35.963
你可以设置缩放因子为矢量和比例

00:16:36.496 --> 00:16:38.298
你提供给我们一个矢量图像

00:16:38.365 --> 00:16:40.534
好像方框里那个叫做All

00:16:41.668 --> 00:16:45.405
然后 如果你想覆盖任何其他比例因子

00:16:45.472 --> 00:16:48.008
你只要提供那些作为其他矢量图像

00:16:48.075 --> 00:16:50.777
或PNG、JPEG缩放图像

00:16:52.212 --> 00:16:54.948
然后当我们创建它
如果你丢失某些资源

00:16:55.015 --> 00:16:57.417
我们会根据矢量图像将那些栅格化

00:16:57.484 --> 00:16:59.987
在那个All方框或目标

00:17:00.988 --> 00:17:03.490
否则 我们会使用所提供的缩放图像

00:17:05.592 --> 00:17:08.295
Xcode 8中新的功能是
你可以调整压缩

00:17:11.164 --> 00:17:12.065
快出来

00:17:12.132 --> 00:17:14.935
你可以调整压缩
那么 比如对于一个JPEG图像

00:17:15.002 --> 00:17:17.738
你想用有损数据压缩
但也许对于一个PNG

00:17:17.804 --> 00:17:20.073
我们不想要任何压缩
因为它将是

00:17:20.140 --> 00:17:21.141
工具栏上的一个项目

00:17:21.208 --> 00:17:23.176
我们不想看到它有任何伪影

00:17:23.944 --> 00:17:26.280
你可解决的一个问题
通过用资源目录

00:17:26.346 --> 00:17:28.382
以防如果栅距还不够强

00:17:28.448 --> 00:17:32.419
是修正该问题或为我们解决一些问题

00:17:32.486 --> 00:17:35.155
我们指的是圆角

00:17:36.823 --> 00:17:39.493
圆角的问题是我们有自适应的UI

00:17:39.860 --> 00:17:40.694
那么

00:17:41.662 --> 00:17:44.598
你的按钮可能包含文字标签
契合得非常好

00:17:45.399 --> 00:17:47.701
直到应用在另一种语言中运行

00:17:47.768 --> 00:17:49.036
然后它改变了大小

00:17:49.536 --> 00:17:52.005
当我们改变按钮大小时
我们会想保留

00:17:52.072 --> 00:17:53.707
它漂亮的圆角

00:17:55.676 --> 00:17:58.278
你获得圆角按钮的方式首先是

00:17:58.345 --> 00:18:02.115
Interface Builder
里面 选择一按钮并指定一背景图像

00:18:02.916 --> 00:18:04.718
然后我们将其应用为背景

00:18:07.287 --> 00:18:10.991
在这个例子中
我有一个资源叫做圆角矩形

00:18:12.459 --> 00:18:14.661
我将它应用为我的背景矩形

00:18:14.728 --> 00:18:17.731
但你可要看到在两个不同大小的按钮中
当它拉伸之后

00:18:17.931 --> 00:18:19.333
看上去非常糟糕

00:18:22.603 --> 00:18:24.171
那么 你可修正的一种方式是

00:18:24.238 --> 00:18:27.407
你一直都在用的方法
就是使用可拉伸图像

00:18:28.141 --> 00:18:31.111
你说 我想在两边都保留X数量的像素

00:18:32.079 --> 00:18:34.915
行 但是今天讲座的一个主题是

00:18:34.982 --> 00:18:37.518
你写更少的代码而更多地依靠框架

00:18:37.584 --> 00:18:38.919
以及我们提供的工具

00:18:39.553 --> 00:18:42.389
所以 这个是被嵌入
资源编辑器

00:18:42.656 --> 00:18:43.991
叫做资源切片器

00:18:44.458 --> 00:18:46.460
你可以使用它去指定

00:18:47.094 --> 00:18:49.363
红色的部分 不要拉伸这些

00:18:49.997 --> 00:18:50.964
不要使它们变形

00:18:52.332 --> 00:18:54.935
照亮的部分 重复这些像素

00:18:56.003 --> 00:18:57.204
通过那样做 你得到

00:18:57.271 --> 00:19:00.073
完美的圆角
而且你不必为它写任何代码

00:19:00.641 --> 00:19:02.676
这是你的图形设计师可以做到的事

00:19:02.743 --> 00:19:04.545
作为资源目录
的一部分

00:19:05.112 --> 00:19:06.313
好的 接下来

00:19:06.580 --> 00:19:09.616
讲讲设计模式 叫做
依赖注入

00:19:10.484 --> 00:19:12.886
首先讲讲我们想要修正

00:19:12.953 --> 00:19:14.788
或尝试改变的 透过引入这个

00:19:16.356 --> 00:19:18.625
我们有UITextField
它用代理

00:19:18.692 --> 00:19:20.994
代理叫做
UITextFieldDelegate

00:19:21.128 --> 00:19:23.964
好 当中它包含关于文本框的方法

00:19:24.031 --> 00:19:25.799
比如
textFieldShouldBeginEditing

00:19:26.133 --> 00:19:26.967
OK？

00:19:27.501 --> 00:19:29.903
我们有WCSession

00:19:30.504 --> 00:19:31.538
WCSession代理

00:19:31.605 --> 00:19:34.374
代理中有什么？
关于WCSession的方法

00:19:34.675 --> 00:19:35.943
你可以看到这当中的模式

00:19:36.076 --> 00:19:38.679
我们用这个来打破

00:19:40.581 --> 00:19:42.916
我们有应用代理 当然它有方法

00:19:42.983 --> 00:19:44.718
关于应用程序对象

00:19:45.252 --> 00:19:47.054
但我们在当中也插入其他东西

00:19:47.487 --> 00:19:51.258
比如数据库 实际上最后什么都有

00:19:51.325 --> 00:19:53.227
包括厨房水槽 堆叠起来

00:19:53.360 --> 00:19:55.262
我们这样做因为很容易

00:19:55.329 --> 00:19:57.564
通过应用程序对象返回

00:19:57.631 --> 00:19:59.833
获得共享对象
计算它然后检索它

00:19:59.900 --> 00:20:02.002
但它是太过强的耦合

00:20:02.069 --> 00:20:04.605
在你的视图控制器和应用代理之间

00:20:04.671 --> 00:20:07.941
而你的应用代理
不是真的需要在那个位置

00:20:08.242 --> 00:20:09.209
反而...

00:20:10.477 --> 00:20:14.348
像这样的一个模式 当中每个
视图控制器指向某些共同的对象

00:20:14.414 --> 00:20:16.517
也许是你储存在你的应用代理中

00:20:17.050 --> 00:20:17.985
你可以转换它

00:20:19.086 --> 00:20:21.855
利用依赖注入
你将模型对象

00:20:22.122 --> 00:20:24.191
那个视图控制器所有的
然后你将它向前传递

00:20:24.258 --> 00:20:27.427
给下一个视图控制器
当视图控制器呈现时

00:20:27.494 --> 00:20:31.899
目的是你给视图控制所需的一切去运作

00:20:33.967 --> 00:20:36.470
那么 对于Mail
你有一系列邮箱

00:20:36.904 --> 00:20:38.705
显示一系列邮箱的一个视图控制器

00:20:38.772 --> 00:20:41.642
会有一个模型对象
代表一系列邮箱

00:20:41.708 --> 00:20:43.577
你点击当中的一个邮箱

00:20:45.479 --> 00:20:48.348
另一个视图控制器会显示
那个邮箱中的信息

00:20:48.582 --> 00:20:49.516
中间那个

00:20:49.583 --> 00:20:51.251
然后你向前传递那个邮箱

00:20:51.318 --> 00:20:53.520
它显示那些
然后你继续向前传递

00:20:54.888 --> 00:20:57.624
你那样做的方式 以一个Segue

00:20:57.691 --> 00:21:00.127
是覆盖prepareForSegue
然后将它传送至repair

00:21:01.361 --> 00:21:03.997
你那样做的方式
如果你是在做编程展示

00:21:04.064 --> 00:21:06.500
是对实例化中所见按钮的行为中

00:21:06.567 --> 00:21:08.969
视图控制器将模型对象传递到那

00:21:10.737 --> 00:21:11.805
该技术好处是...

00:21:12.806 --> 00:21:15.609
你的视图控制器现在是独立的

00:21:15.676 --> 00:21:17.845
他们没有这些强烈的联系和依赖

00:21:17.911 --> 00:21:19.213
你可以不断重复使用它们

00:21:23.283 --> 00:21:25.085
返回的话 你有一些选择

00:21:25.152 --> 00:21:27.955
你可以做我们所做的
通常是写一个协议

00:21:28.021 --> 00:21:29.323
执行它

00:21:29.389 --> 00:21:31.425
于是有通知返回
说视图控制器被撤消

00:21:31.491 --> 00:21:34.228
然后也许更新你的模型
你可以传递一个闭包

00:21:34.728 --> 00:21:36.964
你可以按参考传递对象模型

00:21:37.030 --> 00:21:38.432
或者 你可以

00:21:38.932 --> 00:21:40.400
如果你使用在线segue

00:21:40.467 --> 00:21:42.603
与覆盖prepare
ForSegue是一样的

00:21:42.669 --> 00:21:45.772
以两种方式发生
前进和后退

00:21:46.807 --> 00:21:48.475
我们喜欢这个的另一个原因是...

00:21:49.309 --> 00:21:52.179
因为视图控制器很像乐高积木

00:21:52.813 --> 00:21:55.916
它们可以单独地重新排列

00:21:55.983 --> 00:21:57.518
以创造新的结构

00:21:57.718 --> 00:22:01.288
在此情况下
iPhone SE的整体用户体验

00:22:01.355 --> 00:22:02.990
对于你的应用将是不同的

00:22:03.056 --> 00:22:07.060
不同于iPad 12英寸
iPadPro 12英寸

00:22:08.061 --> 00:22:10.864
如果你的视图控制器是独立的
要做到那样很容易

00:22:12.099 --> 00:22:12.966
好的

00:22:13.033 --> 00:22:16.203
那么 去年在 WWDC

00:22:16.270 --> 00:22:18.238
我做了一个演讲 是关于...

00:22:19.540 --> 00:22:22.576
Playgrounds、现代化UI

00:22:23.443 --> 00:22:26.346
及Objective-C
和Swift互操作性

00:22:27.981 --> 00:22:31.285
自从那以后 我们添加东西
到Playgrounds

00:22:31.552 --> 00:22:34.888
是我们去年还做不到的东西
我想向大家展示其中一些

00:22:35.289 --> 00:22:36.223
用那

00:22:36.924 --> 00:22:38.325
我们来做个演示

00:22:39.860 --> 00:22:43.297
那么 这是那个元素周期表应用
我去年向你们展示过

00:22:43.363 --> 00:22:45.065
从那之后 它被更新了一点

00:22:45.132 --> 00:22:46.200
例如

00:22:48.035 --> 00:22:49.369
颜色有点变化

00:22:49.436 --> 00:22:51.638
不是按物质的状态
气态 液态

00:22:51.705 --> 00:22:55.309
现在它是按物体的种类
像过渡金属 金属 卤素

00:22:55.375 --> 00:22:56.243
那类的东西

00:22:57.377 --> 00:23:00.113
我们还添加了支持以将它展开
于是它实际看上去

00:23:00.581 --> 00:23:03.650
就像个元素周期表
那样是个集合视图

00:23:06.286 --> 00:23:07.754
我要给大家展示部分代码

00:23:13.594 --> 00:23:16.063
这个代码库改动的其中一项
自从上次你看到它之后

00:23:16.129 --> 00:23:19.733
是数据模型已移至Swift

00:23:20.734 --> 00:23:24.505
现在我有一类
代表原子元素

00:23:24.805 --> 00:23:26.440
像是氮或氧

00:23:27.074 --> 00:23:29.943
还有一类代表一个集合

00:23:30.010 --> 00:23:32.980
所谓的 不好意思 周期元素

00:23:34.314 --> 00:23:37.417
这个类将元素实例化

00:23:37.484 --> 00:23:38.952
单独的原子元素

00:23:39.319 --> 00:23:40.888
通过在属性表中读取

00:23:41.488 --> 00:23:43.891
我将其也储存在我的应用这里

00:23:46.527 --> 00:23:48.529
但既然我已将数据模型移到Swift

00:23:48.595 --> 00:23:50.898
我可向大家展示
Playground中的数据模型

00:23:52.132 --> 00:23:54.701
去年我做这个时 先打开一个
新的Playground

00:23:55.502 --> 00:23:56.937
新建文档 playground

00:23:59.673 --> 00:24:04.678
去年我做这个时 我只是在代码和
Playground之间复制粘贴

00:24:06.280 --> 00:24:07.447
当你不断这样做时

00:24:07.514 --> 00:24:09.950
你的Playground变得很大
有很多代码

00:24:10.017 --> 00:24:13.086
于是 现在Playground
有子文件夹

00:24:14.021 --> 00:24:15.822
用于源代码和资源

00:24:17.824 --> 00:24:19.693
我可以将我的模型对象

00:24:20.494 --> 00:24:22.129
放进源文件夹

00:24:23.964 --> 00:24:26.133
然后我们在幕后编写它们

00:24:26.667 --> 00:24:29.236
然后隐式导入其所有公用符号

00:24:29.303 --> 00:24:31.572
到Playground中
使其供你们使用

00:24:33.774 --> 00:24:34.675
这意味着...

00:24:35.542 --> 00:24:37.678
如果我将这个资源文件 我的属性列表

00:24:37.744 --> 00:24:39.680
将其放入资源文件夹

00:24:39.746 --> 00:24:41.748
使其对Playground可用

00:24:43.717 --> 00:24:45.586
我可以到Playground这里

00:24:49.223 --> 00:24:51.725
实例化一个原子元素的例子

00:24:53.060 --> 00:24:54.027
这是锎

00:24:56.864 --> 00:24:57.698
像那样

00:24:58.398 --> 00:25:01.668
所以 能够将这些源文件

00:25:02.002 --> 00:25:04.872
自动导入你的项目中

00:25:05.572 --> 00:25:08.675
从源文件夹或资源文件夹中

00:25:08.742 --> 00:25:10.043
我认为是个强大的方法

00:25:10.110 --> 00:25:13.113
使你的Playground本身
保持小而精

00:25:13.180 --> 00:25:15.249
同时当中又能含有更多内容

00:25:16.783 --> 00:25:19.820
那么 除此之外
自从去年以来还发生了其他事...

00:25:22.389 --> 00:25:24.024
影响了这个应用

00:25:24.825 --> 00:25:28.128
国际纯粹与应用化学联合会

00:25:29.530 --> 00:25:32.766
确认发现了4种新的元素

00:25:33.734 --> 00:25:37.070
于是一下子 我在应用中嵌入的
这个属性列表文件

00:25:37.137 --> 00:25:39.139
看似不再是个好主意了

00:25:41.208 --> 00:25:43.844
我想我们可以修正它
我们就把它放上线

00:25:44.845 --> 00:25:46.547
于是我建立一个小小的网页服务器

00:25:47.347 --> 00:25:49.816
这次放一个JSON文件
包含所有元素

00:25:51.118 --> 00:25:53.754
然后想法是 当我的应用开启时

00:25:54.221 --> 00:25:56.757
起初它会使用嵌入的数据文件

00:25:57.224 --> 00:25:58.792
那样如果没有网络连接的话

00:25:58.859 --> 00:26:01.028
仍然会有东西让客户看

00:26:01.094 --> 00:26:03.397
这也是我们推荐你用的模式

00:26:04.932 --> 00:26:06.400
然后我们做个背景检查

00:26:06.600 --> 00:26:09.102
在其中我们会检查是不是有文件的更新

00:26:09.169 --> 00:26:10.871
如果有 我们将它放进缓冲文件夹

00:26:10.938 --> 00:26:13.173
然后我们在应用里指向它

00:26:14.741 --> 00:26:16.743
我要在Playground里
作出网络请求

00:26:18.312 --> 00:26:21.148
为此 我们有一个类
之前称为NSURL Session

00:26:21.215 --> 00:26:23.116
现在称作URL Session

00:26:23.984 --> 00:26:26.420
显示在这里

00:26:28.589 --> 00:26:29.890
我们抓住这个Session...

00:26:30.290 --> 00:26:35.162
我喜欢这个Session的原因是
当我在第24行唤起它时

00:26:36.263 --> 00:26:37.831
我给它一个完成处理程序

00:26:38.599 --> 00:26:40.968
因为这个在背景中异步运行

00:26:41.368 --> 00:26:43.804
去到网络请求让我的代码继续运行

00:26:44.771 --> 00:26:47.508
当请求要么超时

00:26:47.574 --> 00:26:50.210
要么数据进入时
做这个回调

00:26:50.644 --> 00:26:52.679
在第28行的回调中

00:26:53.580 --> 00:26:56.016
你可以看到我打印出一个元素在这里

00:26:59.353 --> 00:27:01.388
但你实际上看不到它在那儿

00:27:02.289 --> 00:27:03.323
那是个问题

00:27:09.096 --> 00:27:10.831
所以 想想这里在干什么

00:27:10.898 --> 00:27:14.301
我们有一运行中Playground
我们让它实施背景操作

00:27:14.735 --> 00:27:16.737
在未来一个不确定的时间

00:27:17.237 --> 00:27:19.606
我们得到回调
说这是我们想做的

00:27:19.873 --> 00:27:22.109
但Playground
通常像脚本一样运行

00:27:22.176 --> 00:27:24.945
从第一行一直到末尾 然后结束

00:27:26.046 --> 00:27:28.415
关键词是“通常”
但不一定是这样

00:27:28.815 --> 00:27:30.117
我们可发起一个运行循环

00:27:30.184 --> 00:27:32.619
在Playground中
执行异步操作

00:27:33.187 --> 00:27:36.223
为此 我们导入一个新模块叫做
PlaygroundSupport

00:27:39.860 --> 00:27:42.729
然后你让Playground
做无限运行

00:27:44.131 --> 00:27:46.366
然后它永不停止
一直在处理

00:27:47.367 --> 00:27:49.670
那么 现在如果我往下滚动到这个部分

00:27:51.238 --> 00:27:52.840
你会看到我得到回调

00:27:53.140 --> 00:27:54.141
那是镉

00:27:57.311 --> 00:27:58.178
好了

00:27:59.213 --> 00:28:02.749
接下来我要扩展去年的内容

00:28:02.816 --> 00:28:07.788
去年我展示了一个绘图
一个圆角的“核心图像”的图像

00:28:08.889 --> 00:28:10.624
这次我不想绘制一个图像预览它

00:28:10.691 --> 00:28:13.327
在Playground中
做一个全表格视图控制器

00:28:16.530 --> 00:28:19.499
Playground中有些新功能
可以让我们做到

00:28:20.133 --> 00:28:21.435
我们就打开一些空白

00:28:22.503 --> 00:28:23.337
在我的应用中

00:28:26.907 --> 00:28:27.941
叫做View

00:28:30.143 --> 00:28:33.480
我要做一个UI表格视图控制器的子类

00:28:36.583 --> 00:28:37.684
这就是

00:28:39.987 --> 00:28:40.954
选中的区域

00:28:41.021 --> 00:28:42.990
我执行那两个方法
是每个表格视图

00:28:43.056 --> 00:28:45.158
和表格视图控制器都需要有的

00:28:45.225 --> 00:28:47.194
对象数量 或者 抱歉 而是...

00:28:48.295 --> 00:28:52.032
项目数量 自写的索引路径
和返回本身

00:28:53.800 --> 00:28:55.302
我想看到它变实时

00:28:56.303 --> 00:28:59.773
所以这次我们要做的是...
我们实例化视图控制器

00:29:00.674 --> 00:29:02.976
然后使用PlaygroundSupport模块

00:29:03.043 --> 00:29:06.146
是我已经导入的
就在第4行的那个

00:29:08.715 --> 00:29:11.685
我抓住Playground
的实时视图

00:29:14.454 --> 00:29:15.956
将那个视图

00:29:16.023 --> 00:29:19.726
变成Assistant Editor
它已不再为Assistant Editor

00:29:21.061 --> 00:29:22.529
而是实时视图

00:29:29.703 --> 00:29:31.071
看到没？是实时表格视图

00:29:31.672 --> 00:29:32.906
它可以滚动 是活动的

00:29:36.877 --> 00:29:38.679
谢谢
它不只是个静止图像

00:29:39.179 --> 00:29:40.380
它是个真正互动的表格视图

00:29:40.447 --> 00:29:42.716
如果你想尝试我们的部分新代理方法

00:29:42.783 --> 00:29:44.184
或现有的代理方法

00:29:44.251 --> 00:29:46.753
可将其丢进Playground
然后和它们互动

00:29:46.820 --> 00:29:50.257
无需再把这个放入模拟器中

00:29:51.692 --> 00:29:53.627
现在我把它们放在一起

00:29:54.661 --> 00:29:57.898
具体来说 我有了这个背景网络请求
正在发生

00:29:57.965 --> 00:30:00.701
在我检索数据后
我要重新加载表格视图

00:30:00.767 --> 00:30:01.969
我给大家展示看看

00:30:09.309 --> 00:30:11.545
首先 注释这个

00:30:13.146 --> 00:30:16.517
为了向你们证明它
完全从那个网站加载数据

00:30:17.050 --> 00:30:19.319
我要更改这个...

00:30:19.620 --> 00:30:21.889
于是我有一个空白的元素列表

00:30:26.827 --> 00:30:27.661
好

00:30:27.728 --> 00:30:30.330
我有一个空白的元素列表

00:30:30.797 --> 00:30:35.102
当网络请求返回
它是回调 它被指定了

00:30:35.402 --> 00:30:37.971
我刚拉进的新元素列表

00:30:38.438 --> 00:30:39.907
然后我们重新加载表格视图

00:30:42.075 --> 00:30:43.844
好的 继续

00:30:51.084 --> 00:30:52.419
那是你所期待的吗？

00:30:52.853 --> 00:30:54.855
不是我第一次看到时所期待的

00:30:54.922 --> 00:30:56.223
那肯定是Xcode中的错误

00:30:56.290 --> 00:30:58.125
我在Apple.com提交错误报告

00:30:58.625 --> 00:30:59.626
但它实际上不是

00:31:00.928 --> 00:31:03.130
它是我代码中的一个错误 不管信不信

00:31:03.397 --> 00:31:05.933
它是我代码中的错误
现在看发生什么

00:31:06.900 --> 00:31:09.636
我们有这个背景操作进来

00:31:10.437 --> 00:31:12.639
这个背景操作有一个背景操作

00:31:12.706 --> 00:31:13.740
不是在主线程上

00:31:14.174 --> 00:31:15.375
UI在主线程上

00:31:16.043 --> 00:31:16.877
那么

00:31:17.477 --> 00:31:19.780
在我的闭包中
完成处理程序

00:31:19.847 --> 00:31:22.015
我不能从那里更新主线程

00:31:22.082 --> 00:31:25.252
当我重新加载表格视图时我尝试这么做

00:31:26.486 --> 00:31:27.921
当我点击单元格

00:31:29.056 --> 00:31:32.192
我们使其无效
这就是为什么它们会刷新

00:31:32.259 --> 00:31:33.694
然后你可以在当时看见它们

00:31:36.230 --> 00:31:39.032
这个东西我们可以修正
我们在Swift 3有新的东西

00:31:39.099 --> 00:31:42.269
是Swift API
用于Grand Central Dispatch

00:31:44.204 --> 00:31:45.172
所以

00:31:45.839 --> 00:31:47.941
不用我们之前有的C API

00:31:50.577 --> 00:31:53.380
现在我可以说一个调度队列
排在主队列

00:31:53.447 --> 00:31:55.482
什么类型的操作？
异步的

00:31:55.716 --> 00:31:56.917
我们不再需要那个

00:31:57.117 --> 00:31:58.719
现在是我要在主线程上做的

00:31:58.785 --> 00:32:00.454
现在它弹回主线程

00:32:03.657 --> 00:32:04.491
就在那儿

00:32:06.927 --> 00:32:10.831
调度队列 谢谢
Swift中的调度队列

00:32:11.598 --> 00:32:14.434
Swift中的实时视图
和无限运行

00:32:15.736 --> 00:32:17.671
让我们转回到幻灯片

00:32:20.974 --> 00:32:22.943
谢谢
那么 小结一下

00:32:23.010 --> 00:32:25.612
前面所讲的

00:32:25.679 --> 00:32:27.014
或者刚才演示的重点

00:32:29.616 --> 00:32:30.584
一些其他小建议

00:32:30.651 --> 00:32:32.753
当我拖动那些文件到源文件夹

00:32:32.819 --> 00:32:35.789
或资源文件夹时
它们是被复制而不是被参考

00:32:37.057 --> 00:32:40.294
而且 只有标志为公用的方法

00:32:40.360 --> 00:32:42.663
标志为公用的方法、属性、数据类型等

00:32:42.729 --> 00:32:45.032
才会在Playground中
可供你使用

00:32:45.098 --> 00:32:46.900
你可能添加公用说明符 因为

00:32:46.967 --> 00:32:50.637
Swift中默认的可见性说明符
是内部的 不是公用的

00:32:53.473 --> 00:32:55.709
我提到使用缓冲文件夹

00:32:56.543 --> 00:33:00.914
现在 我们仍然有些设备是容量受限的

00:33:01.648 --> 00:33:04.451
客户尝试查看操作系统的新版本的更新

00:33:04.518 --> 00:33:06.453
他们发现不够容量

00:33:07.087 --> 00:33:09.756
所以 在那种情况下
当设备容量不足时 我们所做的是

00:33:09.823 --> 00:33:11.458
我们查看缓冲文件夹

00:33:11.525 --> 00:33:14.428
删除在全部应用程序缓冲文件夹里
找到的任何东西

00:33:14.494 --> 00:33:15.929
这样我们就释放了空间

00:33:16.964 --> 00:33:18.165
我们需要你帮忙做这个

00:33:18.398 --> 00:33:22.536
如果你正临时下载数据
你没存放在缓冲文件夹

00:33:22.603 --> 00:33:23.904
请存放在缓冲文件夹

00:33:25.873 --> 00:33:26.707
接下来

00:33:28.175 --> 00:33:29.810
我觉得会很干净利落的是将

00:33:31.912 --> 00:33:32.846
又这样

00:33:32.913 --> 00:33:33.981
将...

00:33:36.984 --> 00:33:39.052
使用依赖注入的视图控制器

00:33:39.119 --> 00:33:42.523
重新排列使之适合不同平台

00:33:44.324 --> 00:33:45.959
那么 我要转回到演示

00:33:48.562 --> 00:33:49.696
打开Bluetooth

00:33:55.669 --> 00:33:58.839
将视图控制器放在tvOS上

00:34:15.222 --> 00:34:16.156
好 就是这样

00:34:19.693 --> 00:34:23.397
我已匹配Siri遥控器到我的Mac
所以我可以通过模拟器来使用它

00:34:24.731 --> 00:34:26.500
和之前的代码是一模一样的

00:34:26.567 --> 00:34:29.101
一样的视图 一样的表格视图
所有的东西都在那

00:34:30.938 --> 00:34:32.339
我可以翻过去 看到...

00:34:34.041 --> 00:34:35.442
周期表 像这样

00:34:35.509 --> 00:34:37.777
我得到漂亮的电视效果
当我滑动表格单元

00:34:37.844 --> 00:34:38.978
及其集合视图

00:34:39.246 --> 00:34:41.348
是相同的布局代码和视图控制器

00:34:41.415 --> 00:34:43.317
和我之前有的一模一样

00:34:44.618 --> 00:34:45.452
呃

00:34:46.620 --> 00:34:47.454
几乎一样

00:34:56.196 --> 00:34:58.031
我添加这行代码 这样当我...

00:34:58.465 --> 00:35:02.035
选择集合视图单元时
你可以获得重点那个项目

00:35:02.636 --> 00:35:06.039
且我使用OS Compiler指示

00:35:06.106 --> 00:35:07.541
说明这仅适用于tvOS

00:35:08.308 --> 00:35:09.910
除此之外 都是相同的代码

00:35:10.544 --> 00:35:13.514
这有点让我想到一点
如果你有想过你

00:35:13.580 --> 00:35:16.783
将一个应用从一个平台
拖动到另一个平台

00:35:16.850 --> 00:35:20.320
但没有任何实际改动
你可能是做错了什么

00:35:20.754 --> 00:35:22.890
然后检查人机界面指南

00:35:22.956 --> 00:35:25.325
只为了看你如何让那个平台
和那个应用

00:35:25.392 --> 00:35:27.728
在那个平台上更自然 感觉上更...

00:35:29.596 --> 00:35:30.964
更像它是属于那里的

00:35:33.667 --> 00:35:34.535
我们来举个例子

00:35:34.601 --> 00:35:38.138
假设你开发了一个应用
是做类似基于云的会计

00:35:38.705 --> 00:35:41.542
然后也许你有一个iPad版本
在这个iPad版本上

00:35:41.608 --> 00:35:42.976
用户填写发票

00:35:43.477 --> 00:35:44.411
合理

00:35:45.913 --> 00:35:48.615
不合理的是 在我看来

00:35:49.416 --> 00:35:52.419
要在60英寸的电视上填写发票

00:35:52.819 --> 00:35:54.855
你不会那样做
你怎么会那样做？

00:35:54.922 --> 00:35:58.592
这不是个你会在tvOS开启的应用

00:35:59.226 --> 00:36:03.263
但是你的应用的iPad版本
也许有一些很棒的可视化效果

00:36:03.330 --> 00:36:04.598
关于公司是如何运作的

00:36:04.665 --> 00:36:06.667
也许你有一些图形或图表

00:36:07.434 --> 00:36:08.769
那些在电视上会很棒

00:36:09.002 --> 00:36:10.871
你可以有一个应用版本

00:36:11.772 --> 00:36:14.875
具备实时状态面板显示公司的运作

00:36:15.242 --> 00:36:17.311
也许在公司的会议室

00:36:17.377 --> 00:36:19.680
它就放映出来 播放动画
显示更新信息

00:36:19.746 --> 00:36:22.449
它是相同的数据模型
是相同的数据访问

00:36:22.850 --> 00:36:25.986
但你将数据转化得让它更适用于

00:36:26.053 --> 00:36:27.788
它运行的平台

00:36:28.088 --> 00:36:30.724
思考一下
如何将我们拥有的相同的数据

00:36:30.791 --> 00:36:33.160
转化成可用于那个平台？

00:36:36.530 --> 00:36:37.364
总结

00:36:37.898 --> 00:36:40.400
将你的应用现代化
是个不断进行的过程

00:36:40.467 --> 00:36:42.836
我们希望你尽可能多地依靠框架

00:36:44.071 --> 00:36:45.405
若你可摆脱你应用中的代码

00:36:45.472 --> 00:36:48.175
使用我们在框架中提供的代码

00:36:48.242 --> 00:36:49.877
你可以维护更少的代码

00:36:50.377 --> 00:36:51.445
我们希望你那样做

00:36:52.145 --> 00:36:54.548
我们希望你今天开始
查找Xcode的问题

00:36:54.615 --> 00:36:56.183
用Swift转换器

00:36:57.451 --> 00:37:00.053
希望你用更少的对象间依赖关系
来设计打造你的应用

00:37:00.120 --> 00:37:02.356
这样你会更容易重新编排你的应用

00:37:04.758 --> 00:37:09.730
最后 我们希望你考虑将你的应用
引入我们的其他平台

00:37:14.368 --> 00:37:15.636
通过转化你的数据模型

00:37:16.436 --> 00:37:18.672
有一些相关的讲座你可以查看

00:37:18.739 --> 00:37:19.706
就是这些

00:37:22.209 --> 00:37:23.844
除此之外 你可以查看

00:37:25.012 --> 00:37:28.081
这场讲座的链接
我就讲到这

00:37:28.148 --> 00:37:29.082
谢谢各位