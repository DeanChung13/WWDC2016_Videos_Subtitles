00:00:19.920 --> 00:00:23.924
GameplayKit的新特性

00:00:27.961 --> 00:00:28.795
大家早上好

00:00:30.163 --> 00:00:31.164
我是Bruno Sommer

00:00:31.231 --> 00:00:33.066
我是Apple的游戏技术工程师

00:00:33.133 --> 00:00:35.235
“GameplayKit的新特性”

00:00:37.070 --> 00:00:38.872
去年 我们介绍了
GameplayKit

00:00:38.939 --> 00:00:41.008
是Apple的一个高级游戏框架

00:00:41.642 --> 00:00:43.110
GameplayKit是一个集合

00:00:43.177 --> 00:00:47.214
包含一些常用的架构模式
数据结构和算法

00:00:47.781 --> 00:00:49.917
这允许我们的开发者
开发很棒的

00:00:49.983 --> 00:00:52.119
引人入胜的玩法
在他们开发的游戏中

00:00:53.287 --> 00:00:56.156
GameplayKit
作为你的工具箱

00:00:56.223 --> 00:00:57.357
为了很棒的游戏体验

00:00:57.758 --> 00:00:59.359
所以不管你要开发
什么类型的游戏

00:00:59.426 --> 00:01:02.629
不管它是游戏平台
还是RPG或城市建设者

00:01:03.864 --> 00:01:07.000
你总可以在GameplayKit中
找到能方便开发的东西

00:01:07.100 --> 00:01:08.869
并让你的游戏更加健壮

00:01:11.271 --> 00:01:12.973
去年我们引入了
GameplayKit

00:01:13.040 --> 00:01:14.908
它由七个主要系统构成

00:01:14.975 --> 00:01:17.744
比如实体和组件 状态机

00:01:17.911 --> 00:01:19.646
以及我们的游戏质量无规源

00:01:21.181 --> 00:01:25.118
今年 我们在寻路 代理
和游戏AI方面进行了提升

00:01:26.386 --> 00:01:29.690
还向GameplayKit中引入
三个新的主要系统

00:01:30.257 --> 00:01:32.659
我们有一个很强大的
区域分割系统

00:01:32.726 --> 00:01:34.394
这将允许你获得很好的表现

00:01:34.461 --> 00:01:36.730
在游戏的运行时查询中

00:01:38.298 --> 00:01:40.434
你必须有一个很强大的
过程生成系统

00:01:40.501 --> 00:01:43.070
来制作引人入胜
的运行时内容

00:01:44.538 --> 00:01:46.840
今年 我们也集成了

00:01:46.907 --> 00:01:48.876
GameplayKit
在Xcode游戏编辑器中

00:01:48.942 --> 00:01:51.678
所以许多曾经只能在代码中
使用的工作流

00:01:51.778 --> 00:01:55.349
现在可以直接在数据编辑器中使用
不需要重新编译

00:01:56.950 --> 00:01:58.185
所以我们今天内容很多

00:01:58.252 --> 00:02:01.421
我打算直接说寻路中的新功能

00:02:03.390 --> 00:02:05.425
去年 我们介绍了障碍物图

00:02:05.492 --> 00:02:07.528
这些是我们的图类型
它们负责处理

00:02:07.594 --> 00:02:09.596
你的游戏世界中
不可同行的障碍物的集合

00:02:10.430 --> 00:02:12.633
在名字之下 我们使用
了一系列视野算法

00:02:12.699 --> 00:02:14.968
来在障碍物之间
绘制可通行区域

00:02:16.236 --> 00:02:17.738
现在这个方法很强大

00:02:17.804 --> 00:02:19.640
它生成了质量很高的路径

00:02:20.174 --> 00:02:21.875
但是对较大的游戏世界而言

00:02:21.942 --> 00:02:24.044
以及障碍物数量较大的游戏世界

00:02:24.111 --> 00:02:26.513
计算过程强度很高

00:02:26.780 --> 00:02:29.283
在计算并保存结果时

00:02:30.517 --> 00:02:32.519
所以今年 我们提供给
大家另一个选择

00:02:32.586 --> 00:02:34.588
我们要引入GKMeshGraph

00:02:35.589 --> 00:02:37.391
现在 这很类似
我们的障碍物图

00:02:37.457 --> 00:02:40.661
再一次 我们要处理
游戏世界中不可通过的障碍物

00:02:40.727 --> 00:02:43.730
但是现在我们不再使用
视野直线来计算可通行区域

00:02:43.797 --> 00:02:45.065
在这些障碍物之间

00:02:45.132 --> 00:02:47.201
我们要将这个区域分成三角形

00:02:47.267 --> 00:02:49.036
我们由之计算出
一个三角形网状图

00:02:49.136 --> 00:02:50.571
这样每一个可通行的点

00:02:50.637 --> 00:02:53.807
在你的游戏世界中
由仅仅一个三角形代表

00:02:55.409 --> 00:02:58.812
这个新的三角化方法
一样会生成很高质量的路径

00:02:58.879 --> 00:03:01.748
而且附加好处是
计算起来很快

00:03:01.815 --> 00:03:05.319
保存起来成本很低
尤其是对很大的游戏世界

00:03:06.653 --> 00:03:08.488
此外 它的灵活性很高
在计算节点

00:03:08.555 --> 00:03:10.757
应该处在网状图的哪个位置时

00:03:10.958 --> 00:03:13.861
你可以把它们放在三教中心
三角的定点上

00:03:13.927 --> 00:03:16.296
与三角形的边上
以及所有存在的组合

00:03:18.465 --> 00:03:20.100
让我们看一个小代码示例

00:03:20.200 --> 00:03:22.603
展示GameplayKit中
用网状图的样子

00:03:22.970 --> 00:03:24.638
你们会对它的样子很熟悉

00:03:24.705 --> 00:03:25.906
和曾经的障碍物图相较

00:03:25.973 --> 00:03:28.075
它们都在以不同方式解决同样的问题

00:03:29.376 --> 00:03:31.812
在这里的最上端
我要制作我的网状图

00:03:31.879 --> 00:03:33.814
我要传入的缓存半径为10

00:03:33.881 --> 00:03:36.984
这里的缓存半径关联于
你的代理的尺度

00:03:37.050 --> 00:03:39.152
它们负责在你的世界中
进行寻路工作

00:03:39.219 --> 00:03:42.589
我们要手工的在后台
提高你的障碍物的尺寸

00:03:42.656 --> 00:03:44.424
来弥补代理尺寸

00:03:45.926 --> 00:03:49.062
现在我要传入两点(0, 0)
和(1000, 1000)

00:03:49.129 --> 00:03:52.566
这是我的网状图要代表的
游戏世界的跨度

00:03:54.701 --> 00:03:57.571
下一步 我要设置我的网状图
的三角化模式

00:03:57.671 --> 00:03:59.640
这就是节点放置的灵活性所在

00:03:59.706 --> 00:04:01.074
即我刚才所提到的

00:04:01.475 --> 00:04:03.911
现在我要具体地
将节点放在

00:04:03.977 --> 00:04:06.480
三角形的定点上
以及三角形的中心

00:04:08.382 --> 00:04:10.751
最后 我们要将
障碍物集合添加到网状图中

00:04:10.851 --> 00:04:13.120
我们有一个障碍物集合
与我们的游戏世界关联

00:04:13.520 --> 00:04:14.988
而后我们要调用三角化

00:04:15.255 --> 00:04:17.391
这会将这些障碍图托付给图

00:04:17.724 --> 00:04:19.892
它负责运行背后的
三角化算法

00:04:20.194 --> 00:04:21.428
而后就完成了

00:04:21.495 --> 00:04:24.164
这个图已经可以
在我们的游戏中进行寻路了

00:04:27.167 --> 00:04:28.335
除了我们的网状图之外

00:04:28.402 --> 00:04:30.871
今年我们还介绍了寻路中
定制节点类别

00:04:31.839 --> 00:04:34.508
我们的一些图会
自动的实例化它们的节点

00:04:34.575 --> 00:04:37.778
这就是我们的格子图
障碍图和网状图

00:04:38.579 --> 00:04:39.813
在实例化的时候

00:04:39.880 --> 00:04:43.550
你可以选择指定一个
自定义节点类别来让它们实例化

00:04:44.084 --> 00:04:46.420
这将会大有用处
如果你需要附加任何自定义数据

00:04:46.486 --> 00:04:48.355
或逻辑在你的节点上
这有时会很有用

00:04:48.422 --> 00:04:49.890
取决于你想要制作的游戏

00:04:51.191 --> 00:04:52.192
我们要调用合适的init()

00:04:52.259 --> 00:04:54.795
在我们生成了我们的
原始节点类型时

00:04:55.729 --> 00:04:58.498
还有 这些所有类型的图现都支持
Object-C和Swift属性

00:04:58.565 --> 00:05:02.002
所以你在访问自定义节点
时不需要类型转换

00:05:04.972 --> 00:05:07.140
这就是今年寻路中的新特性

00:05:07.708 --> 00:05:09.710
现在让我们继续说说
代理中的新特性

00:05:11.612 --> 00:05:14.581
说些GameplayKit中
有关代理的令人振奋的事情

00:05:14.648 --> 00:05:16.550
他们是自动运动的实体

00:05:17.351 --> 00:05:19.453
被一系列的目标和行为控制

00:05:19.520 --> 00:05:22.289
它们也被一系列现实的
物理限制所局限

00:05:22.356 --> 00:05:26.960
比如速度 质量 躲避障碍和寻路

00:05:28.395 --> 00:05:29.863
在此右侧 你看到一系列目标

00:05:29.930 --> 00:05:32.900
供你使用 来达到你在
你的游戏中想要的行为

00:05:32.999 --> 00:05:36.803
比如寻找与躲避或者漫游与逃跑

00:05:39.573 --> 00:05:41.808
原来 代理是纯2D的

00:05:41.875 --> 00:05:44.611
今年 我们很激动地宣布
我们要将其带入3D

00:05:45.345 --> 00:05:47.114
相关类叫GKAgent3D

00:05:47.814 --> 00:05:50.551
用户界面与2D的变形很像

00:05:50.617 --> 00:05:53.687
主要的区别在于
其位置是三个浮点

00:05:54.121 --> 00:05:57.057
旋转也是三阶矩阵流

00:05:57.324 --> 00:05:59.593
所有的目标和行为都被支持

00:06:00.661 --> 00:06:02.663
有关这次改变要提到几点

00:06:02.796 --> 00:06:06.400
我们改了GKPath来同时
支持2D和3D点

00:06:06.466 --> 00:06:08.669
考虑到遵从路径的目标

00:06:09.903 --> 00:06:12.639
考虑到躲避障碍物目标
中的障碍物

00:06:12.706 --> 00:06:16.143
如果你要使用3D的障碍
它们依然存在于一个平面上

00:06:16.210 --> 00:06:18.712
所以你要选择一个平面
对你的游戏有意义

00:06:20.581 --> 00:06:22.349
除了将代理带入3D以外

00:06:22.416 --> 00:06:24.985
今年我们还引入了行为成分

00:06:25.586 --> 00:06:29.089
我们引入新类GKCompositeBehavior
它是GKBehavior的子类

00:06:29.790 --> 00:06:31.658
这是一个行为的加权集合

00:06:31.725 --> 00:06:35.996
这和刚才行为与目标
的关系很像

00:06:36.063 --> 00:06:37.898
行为是一个目标的加权合集

00:06:39.533 --> 00:06:41.034
它是完全可嵌套的
所以你现在可以完成

00:06:41.101 --> 00:06:44.638
很有趣的嵌套行为
在你的游戏中的行为

00:06:44.705 --> 00:06:47.140
这也使得它们更易于维护
尤其当你在完成

00:06:47.207 --> 00:06:49.877
你的游戏中的很多的行为时

00:06:51.512 --> 00:06:55.082
让我们很快地看看代码示例
关于实际情况下的行为成分

00:06:55.282 --> 00:06:57.718
在这里的最上
我要创建一个群聚行为

00:06:58.018 --> 00:07:00.954
通过结合队列 黏合
与分离这三个目标

00:07:02.689 --> 00:07:04.892
下一步 我要些障碍物
和敌人添加到游戏中

00:07:04.958 --> 00:07:06.393
我需要我的代理来躲避

00:07:06.460 --> 00:07:07.861
我们要制作一个躲避行为

00:07:07.928 --> 00:07:11.131
通过结合avoidObstacles
和avoidEnemies目标

00:07:13.133 --> 00:07:16.403
然后我要结合这两个行为
成为一个新的合并行为

00:07:16.470 --> 00:07:18.205
很高效地合二为一

00:07:19.973 --> 00:07:21.542
最终 我要制作我的代理

00:07:21.608 --> 00:07:24.711
我要将我的组合行为
设置为代理的行为

00:07:25.279 --> 00:07:26.113
现在可以运行了

00:07:26.180 --> 00:07:29.449
下一次我们更新这个代理时
它同时会正确地尝试

00:07:29.516 --> 00:07:32.252
来达到这两个子目标
或是子行为

00:07:35.923 --> 00:07:37.591
这就是今年代理的新特性了

00:07:37.658 --> 00:07:40.327
让我们继续说说
我们的全新空间分割系统

00:07:43.397 --> 00:07:45.299
先介绍一点空间分割的背景知识

00:07:45.365 --> 00:07:47.034
可能对你的游戏很重要

00:07:47.367 --> 00:07:50.337
经常在我们完成高级游戏编程时

00:07:50.571 --> 00:07:52.973
我们会问好多有关
游戏世界的空间问题

00:07:53.240 --> 00:07:55.642
比如 有多少敌人离玩家较近？

00:07:55.709 --> 00:07:58.145
或是 在我的世界中
所有的物品都在哪里？

00:07:58.478 --> 00:08:00.747
或是在这一帧中
哪个抛射体会击中玩家？

00:08:02.082 --> 00:08:03.550
尤其对于更大的游戏世界

00:08:03.617 --> 00:08:06.286
或是有大量游戏物体的游戏世界

00:08:06.587 --> 00:08:08.956
回答这类问题可能开销很大

00:08:10.324 --> 00:08:13.227
在游戏编程中 我们往往
加速这一类的空间查询

00:08:13.293 --> 00:08:16.296
通过使用一种叫空间分割的缓存

00:08:18.665 --> 00:08:20.534
总览我们所提供的

00:08:20.601 --> 00:08:22.302
在我们的空间分割系统中

00:08:22.402 --> 00:08:24.838
这是一个树状数据
结构集合 能让你

00:08:24.905 --> 00:08:26.807
基于空间缓存游戏物体

00:08:26.940 --> 00:08:28.775
你将物体添加到
这些树状数据结构中

00:08:28.842 --> 00:08:31.912
它们在底层会聚集为
层级与桶

00:08:32.212 --> 00:08:35.315
然后未来查询这些物体时
效率就会高得多

00:08:36.582 --> 00:08:39.186
今年 我们引入了
三个这样的数据结构

00:08:39.253 --> 00:08:40.988
供大家进行空间划分所需

00:08:41.188 --> 00:08:43.924
我们有R-trees、
quadtrees和octrees

00:08:45.759 --> 00:08:47.361
让我们深入这些数据结构分析

00:08:47.427 --> 00:08:48.695
先说R-tree

00:08:50.230 --> 00:08:52.366
R-tree是一个树状数据结构

00:08:52.432 --> 00:08:54.668
内有一系列的层级桶

00:08:55.202 --> 00:08:59.673
每当你向一个R-tree添加
一个对象时 它会进入其中一个桶

00:09:00.107 --> 00:09:03.343
所有这些桶都
附带一个包围盒与之关联

00:09:04.044 --> 00:09:08.248
它是该桶中所有的子对象
的包围盒的总和

00:09:09.216 --> 00:09:10.450
R-tree有一个特定的规则

00:09:10.517 --> 00:09:13.253
每当这些桶变得太大时
就需要被分割

00:09:13.954 --> 00:09:17.591
这些桶的最大尺寸
是一个由用户配置的参数

00:09:18.358 --> 00:09:20.527
我们还有一系列策略供使用

00:09:20.594 --> 00:09:22.462
来决定这些桶应当如何分割

00:09:22.829 --> 00:09:25.265
我们可以很简单的分割
或是尝试进行线性优化

00:09:25.332 --> 00:09:29.636
与二次的距离
或是尝试降低桶之间的重叠

00:09:30.938 --> 00:09:32.606
我将给大家一个
很快的视觉样例

00:09:32.673 --> 00:09:34.374
关于构建简单的
R-tree是什么样子的

00:09:34.441 --> 00:09:38.245
比如说 我有一个太空游戏
里面有一些宇宙飞船和小行星

00:09:38.745 --> 00:09:42.082
我要将一个宇宙飞船添加到
R-tree中 它进入了一个桶

00:09:42.149 --> 00:09:44.351
它就是那个飞船的包围盒

00:09:45.018 --> 00:09:47.020
然后我要添加两个
小行星到桶中

00:09:47.087 --> 00:09:50.090
你可以看到它变大了
来容纳这些物体

00:09:51.758 --> 00:09:53.760
我在这个R-tree中指定了规则

00:09:53.827 --> 00:09:56.697
当这些桶超过三个物体时
需要进行分割

00:09:57.097 --> 00:09:59.299
所以我要再向这个桶中
添加第四个物体

00:09:59.499 --> 00:10:01.835
现在这个桶太大了
它需要被分割

00:10:02.302 --> 00:10:04.471
我们要进行一个
简单的线性距离分割

00:10:04.538 --> 00:10:06.373
最后结果是两个桶

00:10:07.708 --> 00:10:10.210
再一次 我向右侧的桶
中添加了两个物体

00:10:12.312 --> 00:10:14.248
这个桶又变得太大
需要被分割开

00:10:14.314 --> 00:10:17.484
再一次 我们要完成一次
线性分割 得到两个桶

00:10:17.718 --> 00:10:20.087
这就是R-tree在
底层的运作模式了

00:10:24.424 --> 00:10:26.860
让我们继续说
quadtree和octree

00:10:27.227 --> 00:10:28.629
我将这两个一起说

00:10:28.695 --> 00:10:31.965
因为它们都在解决同样的问题
只不过quadtree解决2D

00:10:32.032 --> 00:10:33.100
而octree解决3D

00:10:33.166 --> 00:10:34.568
界面是一样的

00:10:35.702 --> 00:10:39.273
这些有一系列等级和层次
的树状数据结构

00:10:39.606 --> 00:10:41.942
在每一层中
空间也被均等的分割

00:10:42.009 --> 00:10:44.244
在右侧
我有一个quadtree的示例

00:10:44.545 --> 00:10:47.314
你可以在左上侧看到
我已经将这个扇形区域细分过了

00:10:47.381 --> 00:10:51.185
在新的被分割扇形的左上侧
我再一次进行分割

00:10:52.819 --> 00:10:55.556
所以quadtree和octree
都有个与之关联最大单元扇形尺寸

00:10:55.622 --> 00:10:58.258
这控制了这些树的
最大成长深度

00:10:58.325 --> 00:11:00.394
以及这些单元扇形的细分极限

00:11:01.461 --> 00:11:03.397
现在 当你向quadtree
与octree中添加对象时

00:11:03.463 --> 00:11:06.867
它会被放在一个
它能占满的最小隔间中

00:11:08.235 --> 00:11:10.070
关于该最大隔间尺寸
给大家一小贴士

00:11:10.137 --> 00:11:13.073
它的关联度很高
这个值很重要 尤其关于

00:11:13.140 --> 00:11:15.242
这些数据结构的表现性能

00:11:15.309 --> 00:11:16.910
所以你应该选择一个隔间尺寸

00:11:17.244 --> 00:11:19.079
或一个最大隔间尺寸
对游戏最有意义

00:11:19.146 --> 00:11:20.581
一般来说 这个关联于

00:11:20.647 --> 00:11:23.317
你的游戏世界中
一些较小的游戏物体

00:11:24.451 --> 00:11:26.820
我给大家一个
构建quadtree的视觉示例

00:11:27.321 --> 00:11:29.089
同样的示例 宇宙飞船和小行星

00:11:29.156 --> 00:11:31.158
我向quadtree中
插入一宇宙飞船

00:11:31.258 --> 00:11:34.294
被放置在两层下的
左边的扇形区域中

00:11:35.362 --> 00:11:38.365
我要添加一些更大的物体
它们被放置在更上一层

00:11:39.600 --> 00:11:41.101
这里注意左边的小行星

00:11:41.168 --> 00:11:43.470
它有些跨越了扇形的边界

00:11:43.537 --> 00:11:44.872
它事实上需要处在更高一层

00:11:44.938 --> 00:11:47.608
因为它不能很好地
安放在任何一个隔间中

00:11:48.842 --> 00:11:50.444
最终 我再添加一些更小的物体

00:11:50.511 --> 00:11:52.846
你可以看到
它们处在向下三层的位置

00:11:55.382 --> 00:11:57.818
这就是底层的运作模式了

00:11:57.918 --> 00:11:59.920
当你使用quadtree
或是octree时

00:12:01.188 --> 00:12:03.390
实际情况中
quadtree的代码示例

00:12:04.525 --> 00:12:06.460
最上部
我要创造我的quadtree

00:12:06.527 --> 00:12:09.363
我要传入一个quad
这是我的游戏世界中的区域

00:12:09.429 --> 00:12:10.964
我想让这quadtree代表

00:12:11.031 --> 00:12:16.003
我们要覆盖游戏世界中(0, 0)
和(1000, 1000)间的区域

00:12:17.137 --> 00:12:19.273
我要指定最小隔间尺寸为100

00:12:19.339 --> 00:12:22.242
这个quadtree中没
哪个隔间可以小于100个单位

00:12:24.278 --> 00:12:25.746
我在游戏世界中还有一些敌人

00:12:25.812 --> 00:12:28.115
我要将它们添加到
我的quadtree中

00:12:28.382 --> 00:12:31.285
要注意这些敌人也有
一个quad与他们关联

00:12:31.351 --> 00:12:33.520
这就是我们的游戏世界
中的敌人所处的地方

00:12:33.587 --> 00:12:35.923
也是它们将在quadtree中
终止的地方

00:12:37.658 --> 00:12:40.060
最后 我要在quadtree
中进行一次查询

00:12:40.160 --> 00:12:42.229
我要让quadtree
给我所有的物体

00:12:42.296 --> 00:12:46.066
在quadtree的(0, 0)
和(1000, 1000)之间

00:12:46.133 --> 00:12:47.801
在我的游戏世界中

00:12:47.868 --> 00:12:50.370
结果我的三个敌人
都在这个范围中

00:12:50.504 --> 00:12:52.806
我要在查询后获得
这所有三个敌人

00:12:54.374 --> 00:12:56.677
这就是GameplayKit中
空间划分了

00:12:56.977 --> 00:12:59.746
让我们继续说说
我们的过程生成系统

00:13:02.082 --> 00:13:04.184
先说说一点背景知识
有关为什么过程生成

00:13:04.251 --> 00:13:05.519
可能对你很重要

00:13:06.854 --> 00:13:09.356
我相信大家都很熟悉
游戏中的预制内容

00:13:09.423 --> 00:13:11.758
这是我们在游戏运行前
我们制作的内容

00:13:11.825 --> 00:13:13.360
甚至是在游戏上市之前

00:13:13.627 --> 00:13:16.730
这些包括 艺术家设计
或是设计师设计的水平

00:13:16.797 --> 00:13:19.333
或艺术家开发的
结构或特质

00:13:20.801 --> 00:13:23.470
这些是很棒的资产
它们对许多游戏很有好处

00:13:23.537 --> 00:13:26.373
但对于其他的游戏
以及特定的题材

00:13:27.207 --> 00:13:30.244
你会遇到一些问题
因为这些资产是静态的

00:13:30.310 --> 00:13:32.212
它们在运行时不怎么变化

00:13:32.279 --> 00:13:34.781
所以尤其当我在寻找
一种随机的感觉时

00:13:34.848 --> 00:13:36.750
需要每次玩游戏时
都感觉到新

00:13:37.818 --> 00:13:40.187
我就不能使用这种
静态的资产了

00:13:40.521 --> 00:13:42.089
所以我需要的是过程内容

00:13:42.155 --> 00:13:44.124
比如随机生成的世界

00:13:44.391 --> 00:13:47.027
过程生成的结构或高度地图

00:13:50.297 --> 00:13:53.100
我们要制作游戏中的
这些过程内容

00:13:53.433 --> 00:13:56.670
我们真正需要的是
一种连贯的随机性的来源

00:13:56.737 --> 00:13:59.606
我所尝试制作的许多这种
随机元素都存在于自然中

00:13:59.673 --> 00:14:02.643
比如世界 结构和高度地图

00:14:03.911 --> 00:14:06.046
我们需要一种随机性
能在空间上具有意义

00:14:06.113 --> 00:14:08.549
能有一个潜在的
空间模式与之对应

00:14:09.850 --> 00:14:10.684
现在 你可能对自己说

00:14:10.751 --> 00:14:12.486
可以直接使用随机数生成器对吗？

00:14:12.586 --> 00:14:14.922
我可以从随机数生成器中获取一些数值

00:14:14.988 --> 00:14:17.090
来制作我的随机内容
然后就完成了

00:14:18.025 --> 00:14:21.094
所有尝试这么做的人
很快就会遇到障碍

00:14:21.728 --> 00:14:24.364
随机数生成器的输出波动很大

00:14:24.431 --> 00:14:28.101
连续的调用结果很难有
空间上有意义的联系

00:14:28.435 --> 00:14:30.604
尝试决定论也是很有挑战性的

00:14:30.671 --> 00:14:34.808
每当我随机生成内容时
我希望它能展示同样的内容

00:14:34.875 --> 00:14:36.210
如果我给它同样的种子

00:14:37.544 --> 00:14:39.246
我们要的来源应提供一致的随机性

00:14:39.313 --> 00:14:42.049
有一种这样的来源叫噪声

00:14:43.650 --> 00:14:48.222
噪声是一个函数
它接收一个输入 并输出数值

00:14:48.555 --> 00:14:50.524
但这个关联之间
还有一些规则

00:14:51.158 --> 00:14:53.827
对于输入中的微小变化
输出的变化也很小

00:14:54.361 --> 00:14:56.930
如果输入变化很大
我就会得到随机的

00:14:56.997 --> 00:15:00.234
但依然在空间上
有意义的输出变化

00:15:00.300 --> 00:15:03.070
在这个噪声来源中
有一些隐含的模式

00:15:04.037 --> 00:15:07.040
噪声函数对于整个
输入域来说是无穷的

00:15:07.107 --> 00:15:09.443
它无穷地伸展
而且它们具有确定性

00:15:09.510 --> 00:15:11.612
给定同样的输入
我总是会获得同样的输出

00:15:13.847 --> 00:15:16.984
所以一旦你使用这个噪声函数
我们可以在特定间隔处取样

00:15:17.050 --> 00:15:20.220
间隔与我要制作的游戏
与其内容类型相关

00:15:20.287 --> 00:15:21.922
所以如果我要随机生成世界时

00:15:21.989 --> 00:15:25.359
它可能是坐标或是瓦片索引
或是生物指数

00:15:25.726 --> 00:15:27.327
如果我要随机生成材质时

00:15:27.394 --> 00:15:29.696
它可以是贴图像素
或是像素等等

00:15:33.100 --> 00:15:34.701
概述一下我们所提供的

00:15:34.768 --> 00:15:38.005
通过我们的过程生成系统
和我们的噪声系统

00:15:39.006 --> 00:15:42.676
你有一系列的噪声来源
供你使用与取样

00:15:42.743 --> 00:15:44.077
来制作游戏中有意义的内容

00:15:44.144 --> 00:15:45.913
这些是类似于比较
随机的噪声

00:15:45.979 --> 00:15:48.315
比如Perlin噪声
和Voronoi噪声

00:15:48.549 --> 00:15:50.884
还有几何噪声源
比如巨浪

00:15:50.951 --> 00:15:53.187
与球体 脊与圆柱

00:15:54.321 --> 00:15:56.924
以及一些常量噪声源
比如西洋棋跳盘模式

00:15:56.990 --> 00:15:58.859
或是常量噪声函数

00:16:00.427 --> 00:16:03.030
然后你就可以组合这些
噪声源成为一个噪声物体

00:16:03.096 --> 00:16:05.299
并在其上展示一系列的变换

00:16:05.832 --> 00:16:07.634
这些包括结合噪声源

00:16:07.701 --> 00:16:10.304
或是转化 度量 旋转噪声源

00:16:11.905 --> 00:16:15.209
一旦我们以某种有意义的
方式将它们结合成一个噪声物体时

00:16:15.275 --> 00:16:19.046
我们而后可以对隐含的
一个区域的噪声地图 噪声函数取样

00:16:19.346 --> 00:16:23.550
在噪声地图中 我们获取采样
然后制作我们的游戏内容

00:16:25.452 --> 00:16:28.355
让我们再深入一下
聊聊我们的噪声源

00:16:29.056 --> 00:16:32.793
现在 我们所有的噪声源
输出值在负1与1之间

00:16:32.926 --> 00:16:35.162
我们一会针对这个再多说一些

00:16:36.263 --> 00:16:39.032
它们接收参数来调整
它们的不同的噪声输出

00:16:39.099 --> 00:16:40.934
在这些噪声函数之下

00:16:41.068 --> 00:16:44.104
所以对于我们随机性与一致性
较强的噪声源 如Perlin和Voronoi

00:16:44.171 --> 00:16:46.507
它们可以使用
GKRandomSource作为种子

00:16:46.573 --> 00:16:49.943
它们可以接收一系列参数
来调整它们隐含的模式

00:16:50.711 --> 00:16:53.981
对于偏几何的噪声源
可以接收参数来修改形状

00:16:54.047 --> 00:16:58.852
比如球体和圆柱体的尺寸
或是脊与巨浪的频率

00:17:00.954 --> 00:17:02.556
一旦我们有了合适的噪声源

00:17:02.623 --> 00:17:04.758
我们就可将它们结合
为一个GKNoiseObject

00:17:05.659 --> 00:17:10.063
它拥有所有必要的函数
以进行变换 组合和修改

00:17:10.130 --> 00:17:12.398
我们的噪声源
以及许多常用的数学

00:17:12.465 --> 00:17:14.535
与支持的逻辑操作

00:17:14.867 --> 00:17:18.571
如果我尝试组合噪声源
我可以做加法 乘法 取最大最小值

00:17:19.439 --> 00:17:21.040
但若我要变换单一的噪声源时

00:17:21.108 --> 00:17:23.410
我可以缩放、旋转、变换

00:17:23.477 --> 00:17:27.013
或者我可以通过取绝对值
取极限 取相反数来进行修改

00:17:29.383 --> 00:17:31.351
一旦我们找到了喜欢的噪声

00:17:31.418 --> 00:17:34.188
而后我们可以对该噪声的
一个区域进行取样

00:17:34.254 --> 00:17:37.357
对隐含的噪声函数
通过一个GKNoiseMap对象

00:17:38.258 --> 00:17:39.893
你指定一个起源与尺度

00:17:39.960 --> 00:17:43.096
这就是我们要取样的
隐含的噪声图的区域

00:17:43.163 --> 00:17:44.731
你还需要指定一个样本数量

00:17:44.798 --> 00:17:47.301
我们要在这个区域中
对该噪声函数进行几次取样？

00:17:47.367 --> 00:17:49.770
我取样的保真度是多高？

00:17:51.171 --> 00:17:53.207
当我们对区域完成取样后

00:17:53.273 --> 00:17:56.343
我们就可以获得该噪声图
上任意位置的值

00:17:56.410 --> 00:17:59.880
再说一次 我刚才提到了
范围是负1到1

00:18:00.314 --> 00:18:02.816
在运行时 你可以选择
按需覆盖某些值

00:18:02.883 --> 00:18:03.984
若你的游戏世界改变

00:18:05.886 --> 00:18:07.120
这些理解起来并不轻松

00:18:07.187 --> 00:18:10.224
我认为解释清楚这些的
最佳方式是给出视觉例子

00:18:11.191 --> 00:18:13.727
假设我要为我的游戏
随机生成一个地图

00:18:14.094 --> 00:18:16.797
我要根据地球的生物
群系来对其建立模型

00:18:16.930 --> 00:18:18.432
我想让它看起来很真实

00:18:18.498 --> 00:18:21.668
沙漠 树林 北极区
诸如此类

00:18:23.437 --> 00:18:25.772
第一 这是你为了完成需求
可以使用的一种方法

00:18:25.839 --> 00:18:28.075
这里我生成了两个Perlin噪声图

00:18:29.843 --> 00:18:31.512
我将左边的称为湿度图

00:18:31.578 --> 00:18:33.981
在我的游戏世界的任何一点
我都可以找到这张图

00:18:34.047 --> 00:18:37.017
来决定我的游戏世界应有
多潮湿或说多干燥

00:18:37.885 --> 00:18:39.753
我将右边的图称为温度图

00:18:39.820 --> 00:18:42.656
在我的游戏世界的任意一点
我可以找到这张图

00:18:43.056 --> 00:18:45.626
来决定我的游戏世界
有多热或说有多冷

00:18:47.294 --> 00:18:49.229
在这里需要提到
我们将来还要回到这里

00:18:49.296 --> 00:18:53.133
在湿度图中 你可以看到
我在右侧有一个很干燥的点

00:18:53.200 --> 00:18:56.170
那就是黑斑
是左侧的一个很干燥的区域

00:18:56.470 --> 00:18:59.206
再说一次 这些颜色
代表我所说的输出

00:18:59.273 --> 00:19:03.610
这里黑色是负1
白色是正1

00:19:05.045 --> 00:19:07.214
在右侧 注意到我
在顶部有一个很冷的点

00:19:07.281 --> 00:19:08.415
那又是一个黑斑

00:19:08.482 --> 00:19:11.885
还有一个很热的
在我的噪声图的右侧

00:19:13.720 --> 00:19:16.423
我要指定在组合这些
时的一些规则

00:19:16.490 --> 00:19:18.158
以对我的游戏产生意义

00:19:18.992 --> 00:19:20.294
这里我有一个简单2D图

00:19:20.360 --> 00:19:25.532
在纵轴中 我有湿度
在横轴中是温度

00:19:26.166 --> 00:19:30.103
我可以使用这些规则
来决定这两个图的交界

00:19:30.170 --> 00:19:33.140
如果我有一个点
它有很高的温度和很低的湿度

00:19:33.207 --> 00:19:35.242
我就会获得一个沙漠

00:19:35.576 --> 00:19:38.078
或者如果我有一个点
温度很高 湿度很高

00:19:38.145 --> 00:19:39.913
我就会获得一个热带雨林

00:19:40.314 --> 00:19:42.449
所以在这里
在冷的那一端

00:19:42.516 --> 00:19:44.351
我有冻土和北极区

00:19:44.551 --> 00:19:47.187
在中间 我有更加温和的地带

00:19:47.254 --> 00:19:49.623
比如森林 大草原和牧场

00:19:51.525 --> 00:19:54.695
这两个图一起使用
我基于这些规则将它们组合

00:19:56.029 --> 00:19:57.364
就获得了这样的东西

00:19:58.532 --> 00:20:02.336
你可以看到它有一个
很好很真实的感觉 还有一点

00:20:02.402 --> 00:20:04.304
在右侧 可以看到我们有很大的沙漠

00:20:04.371 --> 00:20:07.708
渐渐变为牧场
而后变为森林地区

00:20:08.108 --> 00:20:10.811
这与我们湿度图的干燥点相符

00:20:10.911 --> 00:20:13.080
以及在我们的温度图
中的那个很热的点

00:20:13.814 --> 00:20:15.649
在左上方 你看到我们有

00:20:15.716 --> 00:20:17.651
一个很大的冻土与冰冷的点

00:20:18.151 --> 00:20:21.522
在右上方与左下方
我们有一些小的热带雨林

00:20:21.588 --> 00:20:24.391
与很高的温度与湿度相符

00:20:26.260 --> 00:20:29.029
所以这只是很基本的例子
有关你可以完成的很酷的东西

00:20:29.096 --> 00:20:30.264
通过过程生成

00:20:30.330 --> 00:20:32.165
这里我们只使用了两个简单的噪声图

00:20:32.232 --> 00:20:36.170
并通过很简单的规则将它们组合
获得了很漂亮很好的结果

00:20:38.438 --> 00:20:40.374
我想邀请同事
Michael Brennan上台

00:20:40.440 --> 00:20:42.342
来向大家分享游戏AI中的新特性

00:20:42.442 --> 00:20:43.277
Michael？

00:20:49.950 --> 00:20:51.084
谢谢 Bruno

00:20:51.718 --> 00:20:53.453
大家好
我是Michael Brennan

00:20:53.520 --> 00:20:56.023
我是Apple的游戏技术工程师

00:20:56.190 --> 00:20:57.558
我很高兴今天能与大家分享

00:20:58.091 --> 00:21:00.794
我们为游戏AI在
GameplayKit中进行更新

00:21:03.497 --> 00:21:06.900
去年与GameplayKit一起
我们介绍了Minmax策略

00:21:07.367 --> 00:21:10.103
这是一个对于各种游戏的
很棒的AI方案

00:21:10.537 --> 00:21:13.907
可以保证对你的游戏状态
有最佳的搜索

00:21:15.309 --> 00:21:18.445
它之所以能保证
是通过对状态空间进行大量搜索

00:21:18.879 --> 00:21:24.051
同时组合你对游戏中每种状态
所提供的得分函数

00:21:24.117 --> 00:21:28.088
来提供给你你的一个实体
在某一点的最佳行为

00:21:29.089 --> 00:21:31.024
但是Minmax策略的高消耗本质

00:21:31.091 --> 00:21:35.262
使它对于那些状态空间较大
的游戏并不合适

00:21:35.362 --> 00:21:37.297
比如围棋和象棋

00:21:38.832 --> 00:21:43.237
这就是为何今年我很高兴向大家
介绍Monte Carlo策略

00:21:44.505 --> 00:21:48.041
Monte Carlo策略是一个对
状态空间的最佳首次搜索

00:21:48.108 --> 00:21:51.044
与对状态空间的随机取样结合

00:21:51.111 --> 00:21:53.780
来计算出你的对手的最佳行为

00:21:55.015 --> 00:21:57.718
它完成这一点
是通过首先选择一个玩家行为

00:21:58.151 --> 00:22:02.122
使用勘探开采算法
来选择该行为

00:22:02.789 --> 00:22:05.392
然后从该行为开始
模拟新的游戏

00:22:05.692 --> 00:22:09.596
直到它达到结束状态
不论是胜利 失败或是平局

00:22:10.097 --> 00:22:12.533
而后继续沿着树迭代

00:22:15.202 --> 00:22:18.939
它不能保证如Minmax一样
的最佳行为

00:22:19.006 --> 00:22:21.308
但是它趋近于最佳行为

00:22:23.877 --> 00:22:25.612
Monte Carlo策略速度快

00:22:25.746 --> 00:22:28.615
它能保证很好的表现
即使是对一些游戏

00:22:28.682 --> 00:22:31.585
有很大的状态空间
比如说围棋

00:22:32.319 --> 00:22:34.821
由于它只需要最终情况

00:22:35.322 --> 00:22:37.491
这需要让你的游戏提供

00:22:37.691 --> 00:22:39.793
这在你的游戏中很容易实现

00:22:40.460 --> 00:22:41.895
它几乎是最佳的

00:22:41.962 --> 00:22:45.098
虽然它可能不是Minmax
所找到的最佳行为

00:22:45.165 --> 00:22:49.002
它们几乎是一样的
并且会随着时间增加越来越趋近

00:22:52.139 --> 00:22:54.041
让我们说说你需要
用到的元素

00:22:54.208 --> 00:22:56.076
来在你的游戏中集成这一点

00:22:57.144 --> 00:22:59.913
使用GKMonteCarloStrategist时
你需要提供一个预算

00:23:00.180 --> 00:23:03.317
这是它完成我们刚才说到的
四个步骤所要花费的时间

00:23:03.951 --> 00:23:06.687
你需要提供探索参数

00:23:06.753 --> 00:23:10.157
现在 这是一个在0与1之间
的值 代表要不要

00:23:10.224 --> 00:23:13.794
选择一个行为时
探索没有到达过的节点

00:23:14.461 --> 00:23:18.932
或是你想让它开拓
它去过与发现的节点来最大化优势

00:23:19.833 --> 00:23:21.635
你当然还需要提供游戏模型

00:23:21.702 --> 00:23:25.539
若你使用过GKMinmaxStrategist
你就应该对这很熟悉了

00:23:26.874 --> 00:23:28.475
现让我们看一很简单的代码示例

00:23:29.543 --> 00:23:31.745
获取了游戏模型
GoGameModel

00:23:31.812 --> 00:23:33.547
我们要持有它的一个引用

00:23:33.614 --> 00:23:34.948
及我们的Monte Carlo策略

00:23:35.015 --> 00:23:37.384
我们要将其实例化
并持有一个引用

00:23:37.918 --> 00:23:40.387
我们先设置Monte Carlo
策略游戏模型

00:23:40.454 --> 00:23:42.256
来指向我们的游戏模型

00:23:43.590 --> 00:23:45.359
下一步 我们要对其指定预算

00:23:45.626 --> 00:23:46.727
设置在100左右

00:23:46.793 --> 00:23:51.231
这意味着它要完成四个步骤
模拟与迭代100次

00:23:51.565 --> 00:23:53.467
然后我们要将探索
参数设置为1

00:23:53.534 --> 00:23:56.203
这意味着我们想让它
尽可能地探索

00:23:58.438 --> 00:24:01.842
然后我们只需要获取
活动玩家的最佳行为

00:24:01.909 --> 00:24:06.346
在该游戏状态中 找到最佳行为
并将其应用到游戏模型中

00:24:06.613 --> 00:24:07.748
就是这么简单

00:24:09.850 --> 00:24:12.019
今年 我很激动地告诉大家
我们还允许

00:24:12.085 --> 00:24:13.554
制作自己自定义的策略

00:24:14.488 --> 00:24:16.890
我们实现了新协议
叫GKStrategist

00:24:16.957 --> 00:24:19.560
你只需要遵守它
给出游戏模型

00:24:19.626 --> 00:24:21.728
游戏模型更新与游戏模型玩家

00:24:22.829 --> 00:24:25.766
并实现找到玩家的最佳行为

00:24:25.999 --> 00:24:30.637
你可以使用这个策略
就像你使用我我们提供的策略一样

00:24:32.639 --> 00:24:33.941
这就是我们在策略方面提供的新功能

00:24:34.007 --> 00:24:35.542
现在让我们说点别的

00:24:36.243 --> 00:24:37.244
决策制定

00:24:40.113 --> 00:24:42.149
有许多方法来对你的
游戏中的逻辑建模

00:24:42.316 --> 00:24:44.818
其中许多已经被
GameplayKit所支持

00:24:45.552 --> 00:24:49.356
你的敌人需要制定决策
来考虑大量的状态

00:24:49.423 --> 00:24:51.825
他们需要能很快的
制定决策

00:24:53.126 --> 00:24:55.762
你可以在这里看到
我们有这个很小的按钮跳跃游戏

00:24:56.230 --> 00:24:59.099
就算是在这个简单的游戏中
你的对手需要考虑

00:24:59.199 --> 00:25:02.469
你的位置 其他敌人的位置
和按钮的位置

00:25:02.703 --> 00:25:04.638
在某个时间点谁
拥有按钮

00:25:04.705 --> 00:25:07.174
他们是否在跳跃
敌人是否在跳跃

00:25:07.608 --> 00:25:08.809
他们在一层的哪个位置

00:25:08.876 --> 00:25:10.444
还是要考虑不少事情的

00:25:12.980 --> 00:25:16.250
一个简单的制定决策的
方法是决策树

00:25:16.817 --> 00:25:20.420
它们是树状的数据结构
使决策更易于观察与除错

00:25:20.954 --> 00:25:22.923
它们可以是制作的
或是学习得到的

00:25:25.859 --> 00:25:30.130
GKDecisionTree让你在
决定行为时能有较小的开销

00:25:30.797 --> 00:25:32.900
它是完全可序列化的
灵活性也很强

00:25:33.300 --> 00:25:34.735
允许你创造节点

00:25:34.801 --> 00:25:38.105
能随机进行决策
并对分支委派权重

00:25:38.172 --> 00:25:41.675
或是基于特定分支的值
如果这个值是真或假的话

00:25:41.742 --> 00:25:43.544
或是均等的满足描述

00:25:43.610 --> 00:25:46.180
它非常的灵活
允许你完成许多事情

00:25:48.382 --> 00:25:49.983
让我们看一个简单的代码示例

00:25:50.851 --> 00:25:52.452
你可以在这里看到
我们有一个树

00:25:52.519 --> 00:25:54.821
我们要通过一个根元素
对它进行初始化

00:25:54.888 --> 00:25:56.557
查询是否我们接近按钮

00:25:57.724 --> 00:26:00.327
然后我们要获取该根元素节点
的引用以备后用

00:26:01.962 --> 00:26:05.432
在此之后 我们只需要从
该根元素出发创建分支

00:26:05.499 --> 00:26:11.004
一个是我们接近该按钮的情况
这种情况下我们就要跳

00:26:11.138 --> 00:26:14.708
另一个是我们并不接近的情况
这种情况下我们要选择游走

00:26:14.942 --> 00:26:17.578
我们也要获取到该
游走节点的引用

00:26:19.179 --> 00:26:21.582
通过那个游走节点
我们就可以创建一些分支

00:26:21.782 --> 00:26:25.185
一个权重是9
意为在该点向左走

00:26:25.252 --> 00:26:26.620
另一权重是1
意为我们要向右走

00:26:26.687 --> 00:26:27.554
现在 这个权重是叠加的

00:26:27.621 --> 00:26:31.625
意思是对于左侧分支而言
我们走的权重是9

00:26:31.692 --> 00:26:35.329
因为总权重是10
所以向左走的概率是90%

00:26:35.696 --> 00:26:38.599
向右走则有10%的概率发生

00:26:40.801 --> 00:26:43.637
然后我们要将状态
打包到字典中

00:26:43.770 --> 00:26:47.608
并将其传入树的findActionForAnswers
方法来获得我们的行为

00:26:49.510 --> 00:26:51.311
决策树也可以被建模

00:26:51.678 --> 00:26:53.714
你只需要提供游戏数据

00:26:54.114 --> 00:26:56.817
它就会在数据中寻找到
进行决策的行为

00:26:56.884 --> 00:26:59.853
并对该制定决策的行为
找到一个合适的树

00:27:01.922 --> 00:27:05.392
在我们的方阵中你可以看到
最上的一行是深灰色的

00:27:05.559 --> 00:27:06.793
那就是属性

00:27:07.294 --> 00:27:09.663
内部的矩阵是我们的样例

00:27:10.063 --> 00:27:12.999
那就是我们在游戏中
不同的游戏点的样子

00:27:13.433 --> 00:27:16.303
在右侧 我们有进行的动作

00:27:16.470 --> 00:27:19.406
这只是我们在游戏的不同点
中进行的操作

00:27:20.574 --> 00:27:23.210
你将它传入GKDecisionTree
的构造方法中

00:27:23.377 --> 00:27:26.980
它就会找到一个决策树
来适应你所记录的游戏数据

00:27:28.815 --> 00:27:30.851
让我们看看这在游戏中的样子

00:27:33.053 --> 00:27:37.357
这里我有一个玩家
浅绿色到青绿色的玩家

00:27:37.424 --> 00:27:38.792
对抗深蓝色玩家

00:27:38.859 --> 00:27:41.094
使用我们刚才展示的
手动创建的决策树

00:27:41.195 --> 00:27:43.130
如你所见 它遗漏掉了一些

00:27:43.197 --> 00:27:45.032
我们进行的操作
这样我们表现会变好

00:27:47.167 --> 00:27:48.902
让我们看另一个例子

00:27:49.670 --> 00:27:53.841
这里你可以看到它的行为
更像我们刚才的行为

00:27:54.308 --> 00:27:56.476
如我所说 你只需要记录
你的游戏数据

00:27:56.543 --> 00:27:59.947
将其传入 你就能模拟行为
就像你自己的行为一样

00:28:02.082 --> 00:28:04.751
即在GameplayKit中
今年新引入的游戏AI

00:28:05.219 --> 00:28:07.054
它很棒
我很激动能与大家分享

00:28:07.120 --> 00:28:10.123
现在我要邀请我的同事
Sri Nair上台

00:28:10.190 --> 00:28:13.093
介绍更多有关Xcode
集成Gameplay

00:28:13.727 --> 00:28:14.595
Sri？

00:28:18.765 --> 00:28:19.766
谢谢Michael

00:28:22.236 --> 00:28:23.136
大家好

00:28:23.770 --> 00:28:24.838
我是Sri Nair

00:28:24.905 --> 00:28:27.608
我是Apple的一个游戏技术工程师

00:28:30.110 --> 00:28:32.446
去年介绍GameplayKit时

00:28:32.946 --> 00:28:35.082
它只能由代码驱动

00:28:36.016 --> 00:28:38.485
你需要创建构造器
完成所有的连接工作

00:28:39.353 --> 00:28:42.289
并改变属性和值
全在代码中完成

00:28:43.257 --> 00:28:46.193
这可能会很低效
原因显而易见

00:28:47.628 --> 00:28:51.031
我很高兴能告诉大家
我们对这个问题进行了优化

00:28:51.398 --> 00:28:55.102
通过向GameplayKit引入
更加由数据驱动的工作流

00:28:56.003 --> 00:28:59.173
通过在Xcode和
SpriteKit编辑器中集成它

00:29:00.707 --> 00:29:04.545
如你所知 编辑器整合
可以更快的提高

00:29:04.611 --> 00:29:06.647
你的游戏功能的体验

00:29:07.881 --> 00:29:10.384
它们还有助于分离
工程师工作流

00:29:10.551 --> 00:29:11.952
和设计工作流

00:29:14.388 --> 00:29:17.324
所以现在编辑器有
四个主要的新特性

00:29:17.457 --> 00:29:19.826
帮大家加速
GameplayKit开发

00:29:21.295 --> 00:29:23.764
第一个 实体和组件编辑器

00:29:24.765 --> 00:29:26.767
第二个 导航图编辑器

00:29:27.301 --> 00:29:29.236
第三个 场景轮廓视图

00:29:29.970 --> 00:29:32.005
第四个 状态机快速查看

00:29:32.940 --> 00:29:35.375
让我们细说这四个特性

00:29:35.909 --> 00:29:37.511
什么是组件编辑器呢？

00:29:38.545 --> 00:29:42.516
让我们回想一下
实体和组件系统是一个设计模式

00:29:43.417 --> 00:29:45.986
其中一个游戏物体是通过实体展示

00:29:46.520 --> 00:29:51.225
而它们的行为则是通过
更小的独立组件展示

00:29:52.025 --> 00:29:55.395
这能提供更好的代码架构
与代码易用性

00:29:56.463 --> 00:30:00.334
它们也会更易于维护和扩展

00:30:01.502 --> 00:30:06.440
所以现在通过组件编辑器
你可以将实体与组件赋给

00:30:06.507 --> 00:30:08.308
在编辑器中的节点

00:30:10.177 --> 00:30:13.280
并在编辑器中修改属性
编辑器提供

00:30:13.380 --> 00:30:15.916
一个基于编辑器的
数据驱动的工作流

00:30:17.918 --> 00:30:21.255
编辑器与代码紧密整合

00:30:21.321 --> 00:30:24.992
并支持组件类和属性的自动查找

00:30:25.559 --> 00:30:28.996
举个例子 假设你要写一个
运动组件类

00:30:29.296 --> 00:30:31.965
它派生自GKComponent
添加了几个属性

00:30:32.199 --> 00:30:36.136
并由新引入的
GKInspectableKeyword注解

00:30:36.537 --> 00:30:38.472
来展示在UI中

00:30:39.907 --> 00:30:43.710
组件编辑器会自动探测到

00:30:43.777 --> 00:30:46.280
这些你已经添加并展示在
UI中的组件

00:30:46.346 --> 00:30:49.683
现在你只需要选择你需要的组件

00:30:49.750 --> 00:30:51.285
并赋给节点

00:30:52.085 --> 00:30:56.023
一旦你添加了组件
属性就被自动填充了

00:30:57.291 --> 00:30:59.126
基于相应的数据类型

00:30:59.993 --> 00:31:03.530
现在你只需修改这些属性
并在编辑器中直接预览变更

00:31:03.864 --> 00:31:06.133
无需退出编辑器

00:31:06.200 --> 00:31:09.136
或是重新编辑代码
来使遍历更快

00:31:11.538 --> 00:31:16.677
并且这些所有的更新
都保存在SKS文件下的一个JKC中

00:31:18.145 --> 00:31:21.815
所有未被改变的属性值
都使用默认设置代码

00:31:23.784 --> 00:31:27.788
与节点连接相关联的GKEntity
是在后台生成的

00:31:27.855 --> 00:31:29.790
通过一个GKSKComponent

00:31:31.491 --> 00:31:34.628
UI支持所有的
常用属性类型

00:31:34.862 --> 00:31:37.631
比如浮点 整形 布尔等等

00:31:40.067 --> 00:31:41.235
这就是组件编辑器了

00:31:41.301 --> 00:31:44.004
现在 让我们继续说
导航图编辑器

00:31:45.172 --> 00:31:46.607
Bruno刚才提到了

00:31:46.673 --> 00:31:50.410
导航图 也就是GKGraph
是用于寻路的目的

00:31:51.011 --> 00:31:54.848
来找到一个物体从A到B的最佳路径

00:31:56.884 --> 00:31:59.353
通过导航图编辑器

00:31:59.820 --> 00:32:02.556
现在你可以直接在
编辑器中创建GKGraph

00:32:03.490 --> 00:32:08.095
你可以添加或修改节点
在其间添加连接

00:32:08.161 --> 00:32:10.831
只需要在一个窗口中
点击并拖拽

00:32:12.032 --> 00:32:15.569
这些GKGraph保存在
GKScene中

00:32:15.636 --> 00:32:18.672
你可以在之后通过代码获取
并用于寻路

00:32:21.441 --> 00:32:25.646
还有一个我们在SpriteKit编辑器中
一个很有用的特性

00:32:25.712 --> 00:32:28.749
对Gameplay Kit
开发也很有用

00:32:28.815 --> 00:32:30.484
叫做场景轮廓视图

00:32:33.220 --> 00:32:37.257
它绘出场景元素的轮廓
它们的父子层级关系

00:32:39.226 --> 00:32:42.729
这里支持大多数
标准的操作

00:32:42.796 --> 00:32:47.534
比如添加 编辑 重排 删除等等

00:32:49.736 --> 00:32:53.440
你在你的场景中添加的导航图
也会在这里展示

00:32:53.507 --> 00:32:55.075
在场景轮廓图中

00:32:56.743 --> 00:33:00.914
它还可以用于锁定节点
与修改可见性

00:33:01.415 --> 00:33:05.752
它同时附带一个上下文菜单
来进行选项特定的操作

00:33:06.153 --> 00:33:07.187
很好用

00:33:08.622 --> 00:33:11.859
最后同样重要的
状态机快速查看

00:33:13.427 --> 00:33:16.630
回忆一下 我们去年
引入了GKStateMachine

00:33:16.697 --> 00:33:21.168
它允许你在游戏中
表示一种执行流

00:33:21.401 --> 00:33:23.537
它在游戏中有许多应用

00:33:23.604 --> 00:33:27.841
比如AI、动画、UI、
等级序列等等

00:33:29.510 --> 00:33:32.980
直到现在
你都不能预览

00:33:33.046 --> 00:33:35.082
这些状态机的样子

00:33:36.316 --> 00:33:39.553
很难理解这些状态之间的关联

00:33:39.620 --> 00:33:43.757
执行流 或是其当前所在的状态

00:33:44.324 --> 00:33:48.428
为了解决这个问题
我们整合了一个状态机预览工具

00:33:49.263 --> 00:33:52.299
直接在Xcode Debugger
的快速查看功能中

00:33:53.800 --> 00:33:55.802
这允许你在代码中设置断点

00:33:56.103 --> 00:34:01.942
在你想查看状态机的地方
并点击快速查看图标

00:34:02.109 --> 00:34:06.313
就会弹出一个当前状态机
的视觉展示

00:34:06.847 --> 00:34:08.982
它会展示状态
以及其间关联

00:34:09.049 --> 00:34:11.083
当前的状态被高亮

00:34:13.387 --> 00:34:17.958
这里有几个关于快速查看
状态机的例子

00:34:21.594 --> 00:34:26.733
通过这些 我想演示
GameplayKit中 基于编辑器的工作流

00:34:35.108 --> 00:34:40.080
这里我要搭建一个简单的游戏

00:34:40.147 --> 00:34:45.752
其中一个玩家捡起气球
将其涂色并扔到敌人那里

00:34:45.819 --> 00:34:51.358
这是由游戏AI模拟的
敌人也可以做同样的事

00:34:51.425 --> 00:34:54.127
所以我们有一个基本的场景

00:34:54.194 --> 00:34:56.196
你可以在场景轮廓视图中看到

00:34:56.463 --> 00:35:00.534
我们有一个背景和一个玩家
和一些气球

00:35:02.903 --> 00:35:07.407
所以首先 我们要尝试添加
这很简单 没有进行什么行为

00:35:08.141 --> 00:35:09.443
这是一个很静态的场景

00:35:09.510 --> 00:35:13.747
我们通过使用键盘向玩家
添加一些行为作为开始

00:35:14.281 --> 00:35:16.950
对于这一点 我已经添加了一些组件

00:35:17.050 --> 00:35:20.621
我们要看看刚才提到的
行动组件

00:35:20.687 --> 00:35:24.758
有几个属性来帮助行动
比如速度

00:35:25.392 --> 00:35:26.960
摩擦 加速等等

00:35:27.160 --> 00:35:30.764
你使用GKInspectable
对其注解

00:35:30.831 --> 00:35:34.168
这样你就可以在以后
在UI中处理这些属性

00:35:35.202 --> 00:35:37.738
类似的 我又一个玩家输入组件

00:35:38.338 --> 00:35:43.911
我们要将这些赋值给玩家

00:35:43.977 --> 00:35:47.781
通过进入场景
并在组件编辑器中寻找

00:35:47.848 --> 00:35:50.517
在右侧检查区中

00:35:50.584 --> 00:35:53.187
我有一个新引入的组件编辑器

00:35:53.487 --> 00:35:57.991
现在 我可以选择玩家
并点击加按钮

00:35:58.058 --> 00:36:00.494
来将这些组件添加到节点

00:36:00.561 --> 00:36:04.498
我们下面要添加用户输入组件

00:36:04.831 --> 00:36:06.633
与运动组件

00:36:09.703 --> 00:36:12.973
而后我们会看到结果

00:36:13.040 --> 00:36:18.278
我期待用户可以通过键盘移动

00:36:18.345 --> 00:36:23.317
太棒了 它可以在任何方向运动

00:36:23.851 --> 00:36:26.453
除了可以之外
你还能发现它不会在边界停下来

00:36:26.520 --> 00:36:29.790
因为我没有对玩家
添加任何碰撞

00:36:30.324 --> 00:36:32.759
但我的确添加了一个
碰撞组件

00:36:32.826 --> 00:36:36.263
它主要是给玩家节点
添加了物理躯体

00:36:36.330 --> 00:36:41.168
我下面要将其赋给玩家

00:36:41.768 --> 00:36:45.072
在完成这一点的同时
我还要赋一个战斗组件

00:36:45.138 --> 00:36:49.109
我已经添加过了
能允许你捡起气球并扔出

00:36:49.710 --> 00:36:53.747
让我们看看它的样子

00:36:57.217 --> 00:37:00.354
太好了 现在我可以捡起气球
而且它在边界处停止了

00:37:00.420 --> 00:37:01.488
这很棒

00:37:02.589 --> 00:37:04.258
我们下面要对敌人
进行同样的操作

00:37:04.324 --> 00:37:08.996
未完成这一点
我在场景中创建了一个敌人物体

00:37:09.062 --> 00:37:11.965
但我将其设为不可见了

00:37:12.032 --> 00:37:15.235
所以我要在场景轮廓视图中
设其为可见

00:37:15.969 --> 00:37:19.473
而后将组件赋值给敌人

00:37:19.606 --> 00:37:22.743
在这里 区别在于
它是一个敌人输入组件

00:37:22.809 --> 00:37:25.712
这样它就使用游戏AI
而不是使用键盘

00:37:26.513 --> 00:37:30.984
类似地 运动组件 碰撞组件

00:37:31.051 --> 00:37:32.686
以及战斗组件

00:37:34.855 --> 00:37:39.092
有了这些 我会期待敌人也会

00:37:39.159 --> 00:37:44.097
捡起气球并

00:37:45.999 --> 00:37:47.367
啊 它赢了我

00:37:47.434 --> 00:37:49.636
这对它太简单了

00:37:49.703 --> 00:37:52.506
但我们要让游戏更加有趣

00:37:52.573 --> 00:37:58.278
通过一个绘制的物体
向场景中投落一些气球

00:37:58.345 --> 00:38:05.085
所以我有一个绘制的物体
我要将其在场景中设为可见

00:38:06.553 --> 00:38:09.389
而后添加绘制组件

00:38:09.590 --> 00:38:16.597
能沿一个确定的路径
投落气球

00:38:16.830 --> 00:38:20.534
我想要向场景中
添加一个导航图

00:38:21.034 --> 00:38:23.437
这就像进入物体库并输入

00:38:23.504 --> 00:38:26.340
“导航图”一样简单

00:38:26.607 --> 00:38:31.111
现在 你可以简单的将
导航图拖拽到场景中

00:38:31.178 --> 00:38:37.017
我们要把导航图稍稍放大
来解释这个新特性

00:38:38.051 --> 00:38:40.120
这就是导航图编辑器

00:38:45.058 --> 00:38:48.262
在我们操作它的同时
我们要修改一些属性

00:38:49.329 --> 00:38:55.369
我们要设置玩家的健康为2
还要设置运动

00:38:57.070 --> 00:39:01.708
稍稍加速 让玩家稍稍占优势
只是一个第一等级

00:39:02.176 --> 00:39:06.914
你好歹也是有了一些优势
敌人的健康值也是2

00:39:08.215 --> 00:39:12.853
让我们看看结果

00:39:16.490 --> 00:39:19.526
你知道 你可以看到飞机
扔下的气球

00:39:19.593 --> 00:39:21.662
比如能捡起来扔出去的多

00:39:24.031 --> 00:39:27.301
他赢了我一次 我也赢了一次
让我们看看

00:39:28.769 --> 00:39:30.137
好 好了

00:39:30.971 --> 00:39:34.308
我确定我的儿子
玩这个游戏时会很高兴

00:39:35.475 --> 00:39:37.578
这解释了

00:39:38.478 --> 00:39:41.181
GameplayKit中新的
基于编辑器的工作流

00:39:41.315 --> 00:39:42.983
让我们切换回幻灯片

00:39:45.953 --> 00:39:47.387
来回放一下本期

00:39:51.225 --> 00:39:53.493
今年 我们介绍了很多引人入胜的

00:39:53.727 --> 00:39:55.629
有用的GameplayKit特性

00:39:56.763 --> 00:40:00.567
在最开始 Bruno分享了
新的空间划分系统

00:40:00.634 --> 00:40:02.903
来在你的游戏中进行
高效的空间查询

00:40:04.271 --> 00:40:08.909
新的过程生成系统
使用不同的噪声函数

00:40:08.976 --> 00:40:11.345
来在你的游戏中创建
更加动态的内容

00:40:11.745 --> 00:40:16.617
同时对诸如寻路与代理
等现存系统也有提升

00:40:18.285 --> 00:40:21.488
Michael分享了有关
游戏AI的新特性

00:40:21.755 --> 00:40:25.459
通过游戏策略和决策树

00:40:26.527 --> 00:40:30.397
最后我介绍了新引入的
基于编辑器的工作流

00:40:30.664 --> 00:40:32.799
在GameplayKit中
带来更快遍历

00:40:33.667 --> 00:40:35.335
希望大家认为这些新特性很有用处

00:40:35.402 --> 00:40:38.071
我们已经等不及看到
大家下一步的成果了

00:40:39.606 --> 00:40:43.410
这是以后再看这段分享的URL

00:40:43.577 --> 00:40:45.879
608就是本场演讲的编号

00:40:47.247 --> 00:40:50.384
还有相关技术的其它演讲

00:40:50.450 --> 00:40:51.818
你可能感兴趣参加

00:40:51.885 --> 00:40:55.923
SpriteKit、SceneKit、
Rendering、Game Center的新特性

00:40:55.989 --> 00:40:58.058
及Apple Watch的游戏技术

00:40:59.593 --> 00:41:00.427
感谢大家前来

00:41:00.494 --> 00:41:02.629
我们希望大家在余下的演讲中
度过愉快时光