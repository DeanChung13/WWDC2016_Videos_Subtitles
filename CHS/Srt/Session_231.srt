00:00:19.353 --> 00:00:24.625
CloudKit最佳实践

00:00:29.796 --> 00:00:31.865
早上好
谢谢你们来参加本次演讲

00:00:31.932 --> 00:00:35.002
我叫Dave Browning
今天和我一起的还有Nihar Sharma

00:00:35.169 --> 00:00:37.538
我们是CloudKit团队的工程师

00:00:37.604 --> 00:00:40.140
今天我们跟你们谈一些最佳实践

00:00:40.207 --> 00:00:42.609
来用CloudKit构建你应用

00:00:43.210 --> 00:00:44.978
那么 我们具体会谈些什么呢？

00:00:48.382 --> 00:00:52.286
这个 首先我要介绍在Apple
我们怎么使用CloudKit

00:00:53.020 --> 00:00:56.190
我会说一下整个工作流程
还有我们用的一些API

00:00:56.256 --> 00:00:58.625
我们用这些API给顾客们
提供流畅的体验

00:00:58.692 --> 00:01:01.562
我指的是让他们可以
一直访问相同的数据

00:01:01.628 --> 00:01:04.063
在他们所有设备的应用里

00:01:05.098 --> 00:01:07.668
接着 Nihar会细说

00:01:07.734 --> 00:01:09.837
CKOperation API
的使用

00:01:09.903 --> 00:01:12.973
以及使用时的可配置性和灵活性

00:01:13.774 --> 00:01:17.344
然后 他会聊一下数据建模时
需要考虑的一些东西

00:01:17.444 --> 00:01:20.948
你在CloudKit存什么 怎样存
怎样建立你数据库的架构

00:01:22.482 --> 00:01:24.384
接下来 他会讨论错误处理

00:01:24.451 --> 00:01:27.221
我们说过 这对于
CloudKit应用来说至关重要

00:01:27.287 --> 00:01:31.258
他的讲话会涵盖你在用API时
可能会遇到的不同类型的错误

00:01:31.558 --> 00:01:35.229
还有怎样根据你应用的使用情况
考虑应对之策

00:01:36.263 --> 00:01:38.932
给各位提个醒 我们在Apple
创建了CloudKit

00:01:38.999 --> 00:01:41.502
还创建了很多
基于CloudKit的应用

00:01:42.202 --> 00:01:44.404
所以你们应有信心
你们的应用会成长和扩张

00:01:44.471 --> 00:01:47.007
因为我们已把应用扩展到
拥有数亿用户的规模

00:01:47.708 --> 00:01:50.544
我还想给你们
快速回顾一下概念模型

00:01:50.677 --> 00:01:53.013
在最高层 我们有所谓的容器

00:01:53.080 --> 00:01:55.816
这个一般跟应用一一对应起来

00:01:56.149 --> 00:02:00.320
Photos、Notes和你应用
在CloudKit有一个容器

00:02:01.555 --> 00:02:03.857
在一个容器里
你有一个公用数据库

00:02:04.124 --> 00:02:06.760
你可以将所有用户
可以看到的数据存在这儿

00:02:07.060 --> 00:02:09.196
所以 其中一个实例是WWDC应用

00:02:09.263 --> 00:02:11.832
或iOS里的News应用
都由CloudKit创建

00:02:11.899 --> 00:02:14.735
它们用公用数据库来储存文章、新闻

00:02:14.801 --> 00:02:16.670
这些所有人都能看到的东西

00:02:17.404 --> 00:02:19.072
我们还有私人数据库

00:02:19.273 --> 00:02:21.642
你在这儿给
一个特定用户储存数据

00:02:22.142 --> 00:02:24.711
这个用户可以在
所有设备上看到其数据

00:02:24.778 --> 00:02:26.313
但别的用户都看不见

00:02:27.047 --> 00:02:29.616
而今年我们新增了共享数据库

00:02:29.983 --> 00:02:33.520
关于这个 如果你想了解更多
一定要看昨天演讲的视频

00:02:33.587 --> 00:02:34.855
“CloudKit的新特性”

00:02:34.922 --> 00:02:36.890
深入探讨了共享

00:02:37.724 --> 00:02:40.594
接着 在一个数据库里
你有一个地带

00:02:40.661 --> 00:02:43.463
在公用和私人数据库里
都有一个默认地带

00:02:43.730 --> 00:02:46.834
如果你把档案默认搁在数据库里
这就是档案会去到的地方

00:02:46.934 --> 00:02:51.104
你在私人数据库里可以选择
创建一个或多个自定义地带

00:02:51.471 --> 00:02:53.307
你便可以在那些地带储存东西

00:02:53.707 --> 00:02:56.810
而当一个用户
分享内容给另一个用户时

00:02:57.110 --> 00:02:59.813
这份内容就会呈现为
他们共享数据库里的一个共享地带

00:03:00.113 --> 00:03:01.982
你可以把它的本质想成是一个代理

00:03:02.149 --> 00:03:04.818
是所有者私人数据库和自定义地带
的一个代理

00:03:05.586 --> 00:03:08.922
当然 如果多个用户在
多个自定义地带跟你分享东西

00:03:08.989 --> 00:03:11.758
你就会见到很多共享地带

00:03:11.825 --> 00:03:12.960
在共享数据库里

00:03:13.227 --> 00:03:17.698
而在整个工作流程中 我演讲的重点
会在自定义和共享地带上

00:03:17.965 --> 00:03:19.633
就是我们刚在这儿谈的

00:03:19.733 --> 00:03:22.002
最后在最低级 你有档案

00:03:22.069 --> 00:03:24.438
这是键值结构数据存储

00:03:24.505 --> 00:03:27.107
一份档案永远存在于一个特定地带

00:03:29.309 --> 00:03:33.046
好 我快速地回顾一下
在高层使用CloudKit的好处

00:03:33.113 --> 00:03:36.650
你可以专注于构建你的应用
而无需为搭建后台服务操心

00:03:36.717 --> 00:03:37.551
我们帮你做了这步

00:03:38.385 --> 00:03:41.154
你的用户能够进行
所谓的自动认证

00:03:41.488 --> 00:03:44.091
是指若他们在一台设备上
登录了iCloud

00:03:44.157 --> 00:03:46.527
你就不用提示他们
注册、登录

00:03:46.593 --> 00:03:49.196
或者任何常常会
造成阻碍的东西

00:03:49.263 --> 00:03:50.464
妨碍他们使用你的应用

00:03:50.697 --> 00:03:52.699
他们若用CloudKit
登录iCloud

00:03:52.766 --> 00:03:56.103
你马上就有这个用户的
唯一标识码

00:03:56.303 --> 00:03:58.372
你就可以替他们
储存数据了

00:03:59.339 --> 00:04:02.743
最后 也是今天值得强调的
就是你可以得到同样的数据

00:04:02.809 --> 00:04:05.579
不对 是你用户可以在
他们所有的设备上得到同样数据

00:04:05.646 --> 00:04:06.813
若你将数据存于CloudKit

00:04:08.115 --> 00:04:11.018
好 我们现在来说一下
我们看到的常用案例

00:04:11.084 --> 00:04:13.253
以CloudKit为基础
构建应用时

00:04:13.787 --> 00:04:16.156
我们看到 你有一个用户
在运行一个应用

00:04:16.223 --> 00:04:17.991
此案例里
谈论的主角是Notes

00:04:18.058 --> 00:04:19.526
Notes是
基于CloudKit构建的

00:04:19.593 --> 00:04:23.430
假设用户在iPhone上创建了
一个note并存到了云端

00:04:23.964 --> 00:04:27.501
当用户在第二台设备 比如iPad上
第一次打开Notes的时候

00:04:28.035 --> 00:04:30.404
会感觉数据
神一样地推送出来

00:04:30.470 --> 00:04:31.872
它已在iPad里了

00:04:32.105 --> 00:04:33.674
而且 如果他们在iPad编辑

00:04:33.874 --> 00:04:36.343
也会感觉数据神一样地
向另一个方向推送

00:04:36.410 --> 00:04:39.313
这就是我们想提供给
我们用户的使用案例

00:04:40.581 --> 00:04:44.751
我们应该这样想
iCloud服务器是真实数据的来源

00:04:45.319 --> 00:04:48.121
你的设备有这个
真实数据的本地缓存

00:04:48.388 --> 00:04:51.124
而CloudKit API就是
两者之间的桥梁

00:04:53.427 --> 00:04:55.362
好 所以这个实际上
到底是怎么运作的呢

00:04:57.264 --> 00:04:59.800
这个基本上就是
当你的应用启动的时候

00:04:59.867 --> 00:05:04.071
我们推荐的工作流程是
你从服务器获取数据的变化

00:05:04.304 --> 00:05:05.839
特别是在你应用首次启动时

00:05:05.906 --> 00:05:08.342
因为你不知道
有没有东西已经存在

00:05:08.509 --> 00:05:10.310
用户从另一台设备写了一些东西

00:05:10.410 --> 00:05:13.847
对吧 所以你连接到服务器
获取任何你还没有的数据

00:05:14.348 --> 00:05:17.718
然后你确保订阅了
未来的数据变化

00:05:18.051 --> 00:05:21.455
通过订阅未来的数据变化
你告诉CloudKit让服务器

00:05:21.522 --> 00:05:23.023
推送通知

00:05:23.223 --> 00:05:25.526
到用户其它设备上的你的应用

00:05:26.026 --> 00:05:28.562
接着 当然若你收到一个推送
你应再获取数据变化

00:05:28.629 --> 00:05:31.965
把用户其它设备上
产生的新变化下载下来

00:05:33.267 --> 00:05:35.302
好 我们来挖掘
关于这个的更多细节

00:05:35.736 --> 00:05:37.070
订阅数据变化

00:05:37.171 --> 00:05:40.641
它是这样运作的
当你的应用第一次运行时

00:05:40.707 --> 00:05:43.710
我们一会儿会探讨为什么
不过现在 当它第一次运行时

00:05:43.777 --> 00:05:46.280
你设定好订阅告诉服务器

00:05:46.346 --> 00:05:48.982
这些是我关心和订阅的数据

00:05:49.283 --> 00:05:51.685
当这些数据发生改变时
服务器就会告诉你

00:05:51.852 --> 00:05:54.555
当你的应用在
另一台设备上第一次启动时

00:05:54.621 --> 00:05:57.624
给用户的订阅可能
已经存在于服务器上了

00:05:57.691 --> 00:06:00.260
但你的应用并不知道这个
因为这是它第一次启动

00:06:00.327 --> 00:06:01.962
所以你要保证
这个订阅确实存在

00:06:02.262 --> 00:06:05.265
你接下来要做的跟你之前
在另一台设备做的一样

00:06:06.433 --> 00:06:10.437
现在 既然你订阅了数据变更
并且CloudKit会推送通知

00:06:10.504 --> 00:06:13.540
你就要侦听这些通知
我们来具体看一个例子

00:06:14.141 --> 00:06:15.475
用户写一个新笔记

00:06:15.776 --> 00:06:17.978
应用将它存于服务器上

00:06:18.045 --> 00:06:20.647
服务器看了看说
啊哈 这个用户有订阅

00:06:20.714 --> 00:06:23.016
当有新数据的时候
它们想第一时间知道

00:06:23.817 --> 00:06:26.987
它说它来自iPhone
所以不用打扰iPhone

00:06:27.054 --> 00:06:28.622
但这个用户还有一台iPad

00:06:28.922 --> 00:06:31.992
服务器于是就查找合适的
Apple推送通知服务标记

00:06:32.226 --> 00:06:36.697
帮你跟APNS连接
并且告诉后者发一个推送给iPad

00:06:36.763 --> 00:06:39.099
你于是就用不着
亲自在后台发推送了

00:06:39.166 --> 00:06:41.301
你的iPad终于收到推送

00:06:41.368 --> 00:06:43.170
iPad接着干嘛呢
我们之前提到

00:06:43.237 --> 00:06:45.873
现在它会向服务器
索取这些新的数据更改

00:06:46.273 --> 00:06:48.909
具体就是iPad经CloudKit
下载新的数据

00:06:48.976 --> 00:06:51.778
更新自己的本地缓存
然后用户在iPad上打开Notes

00:06:51.845 --> 00:06:54.481
瞧 用户看到刚在
iPhone上写的同样的东西

00:06:56.016 --> 00:06:57.851
好 我们来实践一下
搭建这个系统

00:06:57.918 --> 00:07:00.587
我们深入到代码里
到我们专门用的API里

00:07:00.654 --> 00:07:01.855
实现一切

00:07:02.189 --> 00:07:04.658
我们首先看到订阅数据改动

00:07:05.792 --> 00:07:06.827
记得我说过的话

00:07:06.894 --> 00:07:10.564
这是那些只在你应用第一次启动时
你才需要做的一件事

00:07:10.631 --> 00:07:13.934
所以 你会注意到
在我们代码顶部有一步审查

00:07:14.001 --> 00:07:16.103
查看我们在这台设备上
是否本地缓存

00:07:16.170 --> 00:07:18.438
既然我们都已经
设置了这个订阅

00:07:18.505 --> 00:07:21.341
我们不用每次应用启动
都执行后面的程序

00:07:21.508 --> 00:07:24.945
你为自己节省了网络请求
你也为用户节省了一些网络操作

00:07:25.412 --> 00:07:29.383
好 那么如果我们之前没有订阅
我们来看看代码是怎么设置订阅的

00:07:29.750 --> 00:07:31.151
今年 iOS 10新特性

00:07:31.385 --> 00:07:34.054
CKDatabaseSubscription API

00:07:34.288 --> 00:07:37.758
让你可以订阅整个数据库的任何改动

00:07:37.824 --> 00:07:40.327
而且它可以用在私人数据库
可以用在共享数据库

00:07:40.694 --> 00:07:43.330
在这个例子里
我们来关注新的共享数据库

00:07:43.630 --> 00:07:48.569
所以你给订阅赋予一个ID
方便之后查找 我稍后也会谈这个ID

00:07:48.635 --> 00:07:51.138
在这个案例里 因为我们的对象是
一个共享数据库

00:07:51.205 --> 00:07:52.639
我们称数据改动为共享改动

00:07:53.774 --> 00:07:57.811
接着 你要告诉CloudKit
你想要发送的推送类型

00:07:58.011 --> 00:07:59.580
在订阅触发的时候发送

00:07:59.813 --> 00:08:02.115
我们来深入聊聊
你可以用的不同类型

00:08:02.583 --> 00:08:06.053
第一个类型实际上我们用得很多
而且对于大多数用例我们都很推荐

00:08:06.119 --> 00:08:07.688
这是一个静默推送通知

00:08:08.155 --> 00:08:12.025
要做到这点 在我们的API里要
关注到一个订阅对象

00:08:12.092 --> 00:08:16.496
你可以用一个CKNotificationInfo对象
设置notificationInfo

00:08:16.563 --> 00:08:19.700
然后 如果你将should
SendContentAvailable属性设为真

00:08:19.766 --> 00:08:22.402
并且只设置这个属性
你就可以静默推送了

00:08:22.469 --> 00:08:25.706
后台就会替你
给这个订阅发一个静默推送

00:08:26.440 --> 00:08:30.611
而这个关键的一点是
你不需要提示用户并取得同意

00:08:30.677 --> 00:08:34.648
过去我们有开发者抱怨“嘿
我们有这个订阅 但它会弹出窗口”

00:08:34.715 --> 00:08:37.384
你们也见过这种情况
对这个应用允许推送通知

00:08:37.451 --> 00:08:39.086
很多人会选不

00:08:39.152 --> 00:08:41.321
没得推送的话
你就只能靠下载数据了

00:08:41.421 --> 00:08:44.591
如果你这样做的话
基本上你怎么样都不能引起用户注意

00:08:44.658 --> 00:08:46.460
所以 你不需要征求用户接受

00:08:47.594 --> 00:08:51.064
最后 你侦听这些通知的地方是在
AppDelegate里的

00:08:51.131 --> 00:08:52.599
RegisterForRemoteNotifications

00:08:53.333 --> 00:08:56.370
而如果你确实想发送一个UI推送
你其实想要的是标记

00:08:56.436 --> 00:09:00.407
横幅或者发出声响
你可设置三个设置中的任何一个

00:09:00.974 --> 00:09:04.111
这会告诉CloudKit
给你的用户发一个UI推送

00:09:04.845 --> 00:09:08.615
而在这个案例里 因为你要提醒用户
所以你需要征得他们的同意

00:09:08.882 --> 00:09:12.152
你跟以前用一样的方法登记远程通知

00:09:13.187 --> 00:09:14.521
一些要注意的细节

00:09:14.588 --> 00:09:16.757
如果你去读APNS文档

00:09:16.823 --> 00:09:21.128
它们会告诉你说
推送可以根据设备条件进行合并

00:09:21.728 --> 00:09:25.666
这个指的是 如果一个订阅触发了
并且一个推送发到你用户的设备上

00:09:25.732 --> 00:09:28.368
有很多情况 比如低电量
网络不稳定等等

00:09:28.435 --> 00:09:29.970
这些情况下
不一定收到推送

00:09:30.304 --> 00:09:33.941
这个合并协定的目的
就是要至少实现其中一个推送

00:09:34.708 --> 00:09:35.676
这意味着

00:09:35.742 --> 00:09:39.613
你不应该认为推送就是要
告诉你的应用具体“什么”数据改变了

00:09:39.680 --> 00:09:41.815
因为如果发了五个推送
而你错过其中四个

00:09:41.882 --> 00:09:43.617
你只是错过了
其中四个“什么”

00:09:43.684 --> 00:09:47.120
取而代之 你应该将推送想作是
告诉你“有些”数据改变了

00:09:47.187 --> 00:09:48.155
一个或多个东西

00:09:48.222 --> 00:09:51.291
这就是为什么我们要从服务器那儿
找出哪些数据改变了

00:09:51.358 --> 00:09:53.961
好消息是CloudKit API

00:09:54.027 --> 00:09:56.763
给你提供了一个途径
询问哪些东西改变了

00:09:56.830 --> 00:09:59.533
所以你不用下载
你服务器已经有的所有东西

00:10:00.534 --> 00:10:03.570
我们回到我们的程序
记得我们还在创建一个订阅

00:10:03.637 --> 00:10:06.073
在这个案例中
我们设定了一个静默推送通知

00:10:06.406 --> 00:10:09.076
通过把
shouldSendContentAvailable设为真

00:10:09.843 --> 00:10:11.478
现在 我们需要拿这个订阅

00:10:11.545 --> 00:10:14.014
让CloudKit客户端
把它存到服务器上

00:10:14.414 --> 00:10:16.083
你可能熟悉这个

00:10:16.149 --> 00:10:18.485
但你做所有东西
都要用到操作

00:10:18.819 --> 00:10:22.356
而在这个例子里 我们用到
CKModifySubscriptionsOperation

00:10:22.422 --> 00:10:25.058
我们把刚创建的订阅告诉它

00:10:25.125 --> 00:10:26.460
而这就是我想储存的
那个订阅

00:10:27.895 --> 00:10:31.765
有了CloudKit 因为客户端要
通过网络跟服务器连接

00:10:31.832 --> 00:10:34.568
这可能会耗很多时间
所有东西都是非同步的

00:10:34.635 --> 00:10:37.471
这意味着所有操作
都有完成模块

00:10:37.538 --> 00:10:40.541
一旦有一个响应回来
这些模块就会被调用

00:10:40.607 --> 00:10:44.111
在这儿 我们有一个
modifySubscriptionsCompletionBlock

00:10:44.645 --> 00:10:46.647
所有完成模块里
你首先要做的是

00:10:46.713 --> 00:10:49.116
检查错误
我知道我们总是说这个

00:10:49.216 --> 00:10:52.319
Nihar会跟你们
更详细地讲解

00:10:52.386 --> 00:10:54.888
不过 在这个案例里
假设如果我们没有错误

00:10:54.955 --> 00:10:56.924
那我们就知道
订阅已经储存好了

00:10:56.990 --> 00:10:59.493
而我可以在本地缓存
我们已经做了这一步的记录

00:10:59.560 --> 00:11:02.296
这样下一次我们就不用做了
多亏有程序顶部的错误检查

00:11:03.830 --> 00:11:05.899
顺便讲一下
Nihar也会谈这个

00:11:05.966 --> 00:11:09.736
CKOperation继承了NSOperation
即Swift 3里的操作

00:11:10.037 --> 00:11:12.806
所以你可以设置
这个服务质量属性

00:11:12.873 --> 00:11:14.074
默认值是.utility

00:11:14.141 --> 00:11:16.743
他会讲一些设置这个时
要切记的东西

00:11:17.277 --> 00:11:18.145
而最后

00:11:18.412 --> 00:11:22.316
拿这个操作
让客户端发送回来的方法

00:11:22.382 --> 00:11:25.385
就是把它加进数据库的
操作队列里

00:11:25.452 --> 00:11:28.555
既然这个例子里我们做的是
共享数据库的订阅

00:11:28.622 --> 00:11:30.891
就把操作加到共享数据库的
操作队列里

00:11:30.958 --> 00:11:32.826
客户端于是就会把
操作发送到服务器

00:11:34.328 --> 00:11:36.697
好 我们现在订阅了数据变化

00:11:37.164 --> 00:11:40.067
下一步就是侦听推送了

00:11:40.434 --> 00:11:44.037
既然CloudKit在另一台设备的
数据改变时会发推送给我们

00:11:45.672 --> 00:11:48.408
你要确保在Xcode里
你打开了背景模式

00:11:48.675 --> 00:11:51.411
你要在远程通知的选项打钩

00:11:51.478 --> 00:11:52.746
可能还要选后台获取

00:11:52.813 --> 00:11:55.349
如果当你应用在背景的时候
你想做这个

00:11:56.016 --> 00:11:59.553
这一步后 AppDelegate
有一个你可能知道的方法

00:11:59.620 --> 00:12:02.122
application
didReceiveRemoteNotification

00:12:02.189 --> 00:12:03.524
fetchCompletionHandler

00:12:04.525 --> 00:12:06.994
你给这方法一个用户信息字典

00:12:07.594 --> 00:12:09.563
CloudKit就可以让你很方便地

00:12:09.630 --> 00:12:13.333
看能否从这个字典对象里获取
一个CKNotification

00:12:14.835 --> 00:12:17.371
记得推送还可能有别的各种原因

00:12:17.437 --> 00:12:21.175
但若它来自一个CloudKit订阅
就会有CKNotification

00:12:21.341 --> 00:12:23.677
现在我们可以查订阅ID

00:12:24.344 --> 00:12:28.615
这一步很重要 因为你可能会有
一个数据库订阅

00:12:28.682 --> 00:12:31.585
在私人或者共享数据库
可能还有别的东西

00:12:31.852 --> 00:12:35.389
这一步让你辨别哪个订阅
触发了这个推送

00:12:35.689 --> 00:12:38.125
在这个案例里 我们假设
推送来自我们的共享改动

00:12:38.192 --> 00:12:40.561
现在我们可以去
获取这些共享数据

00:12:40.894 --> 00:12:42.229
这个流程我们待会儿会探讨

00:12:42.362 --> 00:12:44.631
这步完成后 我们调用
完成处理程序

00:12:44.698 --> 00:12:46.166
这个方法的参数之一

00:12:47.534 --> 00:12:50.571
好 现在我们设置好侦听推送了

00:12:51.004 --> 00:12:53.874
我们假设一段时间后
你的应用收到一个推送

00:12:54.141 --> 00:12:56.076
我们该怎么办呢
记得我们刚讲的东西

00:12:56.176 --> 00:12:57.578
我们要获取新的数据变化

00:12:57.811 --> 00:13:00.614
我们来看图说话
看看这个是怎么运作的

00:13:01.148 --> 00:13:02.583
我们的设备收到一个推送

00:13:02.649 --> 00:13:04.718
我们说了这个是
共享数据库的推送

00:13:04.785 --> 00:13:06.753
你需要做下面两步

00:13:07.087 --> 00:13:10.290
一
你询问服务器

00:13:10.490 --> 00:13:13.560
共享数据库里哪些地带变动了

00:13:13.927 --> 00:13:15.696
记得我们之前谈过地带

00:13:15.762 --> 00:13:19.132
可能还会有
新地带出现而你甚至都不知道

00:13:19.199 --> 00:13:21.201
因为有人跟你分享了一些东西

00:13:21.735 --> 00:13:23.971
你接着发一个服务器变动标记

00:13:24.037 --> 00:13:26.106
告诉服务器你在
数据历史的哪个位置

00:13:26.173 --> 00:13:27.941
这个我们一会儿也会深入讲解

00:13:28.242 --> 00:13:32.312
有了地带的数字后 第二步就是
你又询问服务器说 好

00:13:32.379 --> 00:13:35.749
请告诉我在那些具体地带里
哪些档案有改动

00:13:35.983 --> 00:13:38.218
同样地
对于每个地带你都有改动标记

00:13:38.285 --> 00:13:40.854
标明你本地的设备缓存在
数据历史里的位置

00:13:42.756 --> 00:13:45.459
好 我们来更详细地
讲讲这个改动标记

00:13:46.059 --> 00:13:49.563
假设你的用户有一台设备
就我们之前说的那台iPhone吧

00:13:49.630 --> 00:13:52.666
用户用你的应用
发送了一些改动到服务器

00:13:52.866 --> 00:13:56.236
改动得到认可
服务器在历史上标明这一点

00:13:56.303 --> 00:13:58.071
这要用到服务器改动标记

00:13:58.138 --> 00:14:00.974
在这个例子里 为了简便
我们标明为字母A

00:14:01.041 --> 00:14:04.344
这台设备又发送
另一些得到认可的改动

00:14:04.411 --> 00:14:06.346
这些标为B 等等 接着就是C

00:14:06.780 --> 00:14:09.983
一段时间后 用户在
第二台设备运行你的应用

00:14:10.050 --> 00:14:12.186
假设是我们之前说到的那台iPad

00:14:12.252 --> 00:14:14.988
iPad首先要做的
记得在应用启动时

00:14:15.055 --> 00:14:17.291
要做的是索要
任何它没有的改动

00:14:17.824 --> 00:14:20.827
于是它说
“我想从服务器获取改动”

00:14:20.894 --> 00:14:23.197
服务器说“拿去吧
这些是我有的”

00:14:23.263 --> 00:14:26.834
最后它说
“你现在位于服务器改动标记C”

00:14:27.100 --> 00:14:29.503
所以二号设备自己
记好了它在历史上的位置

00:14:30.137 --> 00:14:32.606
现在假设二号设备
接着写了一些数据

00:14:32.773 --> 00:14:34.908
写的过程中 一号设备收到推送

00:14:35.342 --> 00:14:37.244
一号设备下载新的变动

00:14:37.311 --> 00:14:40.581
最后 服务器说
“你现在位于改动标记E”

00:14:40.647 --> 00:14:42.916
好 二号设备又改了一些东西

00:14:42.983 --> 00:14:45.919
一号设备收到推送
下载东西

00:14:46.019 --> 00:14:47.554
现在它位于改动标记I

00:14:48.755 --> 00:14:51.592
你会意识到二号设备
还在改动标记C

00:14:51.925 --> 00:14:55.095
你写数据的时候
你是不会得到改动标记的

00:14:55.195 --> 00:14:57.297
除非你去索取
你是不会得到标记的

00:14:57.364 --> 00:14:59.700
我们假设在二号设备
应用重启

00:15:00.000 --> 00:15:02.803
或者用户重启iPad还是别的什么
你的应用启动了

00:15:02.870 --> 00:15:04.071
你去要数据改动

00:15:04.171 --> 00:15:06.840
服务器就会发给你
你从设备写了的东西

00:15:06.907 --> 00:15:09.977
它不知道你会不会
因为各种原因而没有本地缓存

00:15:10.043 --> 00:15:12.312
如果你见到类似的情况
也不要惊讶

00:15:12.379 --> 00:15:15.816
这么做让你可以确认
你有这一部分数据

00:15:15.883 --> 00:15:19.319
最后 服务器会
告诉你位于改动标记I

00:15:19.553 --> 00:15:23.390
注意两台设备都在同样的状态
都有同样的服务器改动标记

00:15:23.724 --> 00:15:25.893
这就是展示系统
如何运作的一个例子

00:15:27.261 --> 00:15:30.797
好 我们来看看真正写代码来
获取这些变化

00:15:31.231 --> 00:15:34.101
这个案例里
我们要讲解数据库

00:15:34.301 --> 00:15:38.872
iOS 10一个新API叫
CKFetchDatabaseChangesOperation

00:15:39.373 --> 00:15:42.609
如我们所说 你把我们刚提到的
服务器改动标记作为参数

00:15:42.776 --> 00:15:46.880
你第一次用它时
它会告诉服务器你啥都没有

00:15:46.947 --> 00:15:49.516
服务器也会把它的所有东西给你

00:15:50.350 --> 00:15:54.288
接下来
在API以前的版本里

00:15:54.354 --> 00:15:57.691
在这个操作最后
你通常要检查一个旗标

00:15:57.891 --> 00:16:00.694
看服务器有没有说
之后还有更多的数据

00:16:01.128 --> 00:16:02.896
我们一会儿也会谈论这个

00:16:02.963 --> 00:16:06.533
但通常如果这个设为真的话
你就要负责在客户端

00:16:06.600 --> 00:16:08.302
重新触发这个操作

00:16:09.002 --> 00:16:11.438
但我们加了一个新属性

00:16:11.638 --> 00:16:13.907
到这些操作里
叫获取所有改动

00:16:13.974 --> 00:16:15.175
其默认值为真

00:16:15.409 --> 00:16:18.045
它做的是
让CloudKit客户端

00:16:18.111 --> 00:16:20.814
替你做这个
所以你不用亲自动手

00:16:20.881 --> 00:16:22.950
运行了其中一个操作后

00:16:23.016 --> 00:16:25.252
如果客户端看到
服务器还有更多数据

00:16:25.452 --> 00:16:28.222
它又会帮你自动把
你的操作加入队列

00:16:28.422 --> 00:16:30.490
当然 顺便调用你的回调方法

00:16:30.691 --> 00:16:32.960
所以你再也不用担心

00:16:33.427 --> 00:16:35.696
然后 你要实现这个
完成模块

00:16:35.762 --> 00:16:37.965
recordZoneWithIDChangedBlock

00:16:38.232 --> 00:16:40.567
在这里 你会得知哪些地带

00:16:40.634 --> 00:16:42.269
在共享服务器里改动了

00:16:42.736 --> 00:16:44.671
你有收集这些地带ID

00:16:44.738 --> 00:16:47.007
我们等会儿会讲
怎么处理它们

00:16:47.074 --> 00:16:50.310
再接下来是
recordZoneWithIDWasDeletedBlock

00:16:50.377 --> 00:16:53.146
这个告诉你哪些地带在
服务器里已经不复存在

00:16:53.213 --> 00:16:55.716
还可以让你清理
任何本地缓存数据

00:16:56.049 --> 00:16:57.684
之前位于那些
现在不再存在的地带里的缓存

00:16:58.352 --> 00:16:59.686
你会在下面的情形看到这个

00:16:59.753 --> 00:17:02.456
就是有些东西
没有跟你的用户分享

00:17:02.656 --> 00:17:05.192
因为在他们的共享数据库里
没有这个地带

00:17:05.259 --> 00:17:08.127
另一个新事物是
changedTokenUpdatedBlock

00:17:08.194 --> 00:17:09.363
我们来看一下

00:17:09.730 --> 00:17:14.034
记得之前我们一号设备
写了一些东西到服务器

00:17:14.401 --> 00:17:16.737
二号设备写了一些东西

00:17:16.904 --> 00:17:20.207
过了一会儿 这个用户的
三号设备也加入进来了

00:17:20.406 --> 00:17:21.808
它首先要做的

00:17:21.875 --> 00:17:24.077
是跟服务器连接
并且获取任何改动

00:17:24.444 --> 00:17:27.580
因为获取所有改动为真
它要下载所有数据

00:17:28.182 --> 00:17:30.551
但我们可能有很多数据
比如这个案例里面

00:17:30.617 --> 00:17:34.488
服务器会觉得没必要只在
一个响应里就将所有数据传过来

00:17:34.555 --> 00:17:35.656
我们分段来进行

00:17:36.924 --> 00:17:38.859
服务器发给你一部分数据

00:17:39.626 --> 00:17:42.663
CloudKit服务器会看到
服务器还有更多数据

00:17:42.729 --> 00:17:45.666
所以它要替你去设立
另外一个操作

00:17:45.899 --> 00:17:48.836
但它在做这步前
要调用changeTokenUpdated

00:17:48.902 --> 00:17:51.271
并且告诉你
你现在在改动标记C

00:17:52.172 --> 00:17:54.141
这让你可以跟客户端配合

00:17:54.208 --> 00:17:55.576
随之设立操作

00:17:55.642 --> 00:17:57.311
你更新你的本地改动标记

00:17:57.377 --> 00:17:59.346
就用不着重复
你已经做了的一些事情

00:17:59.813 --> 00:18:02.349
比如说这个客户端替你说

00:18:02.416 --> 00:18:05.385
“还有更多数据要从服务器传过来
我们去获取吧

00:18:05.452 --> 00:18:06.286
下载一些新数据”

00:18:06.353 --> 00:18:08.455
结束后再调用
changeTokenUpdated

00:18:08.522 --> 00:18:10.858
看还有没有新数据
然后又跟服务器连接

00:18:10.924 --> 00:18:12.359
不过这一次会有一个错误

00:18:12.893 --> 00:18:16.363
你处理错误时可能最终还是
重新调用获取改动

00:18:16.864 --> 00:18:18.832
但你就不用从头从A开始了

00:18:18.999 --> 00:18:21.134
因为你有一个
changeTokenUpdatedBlock

00:18:21.201 --> 00:18:22.803
你的本地改动标记
现在E

00:18:23.070 --> 00:18:24.338
当你调用下一个时

00:18:24.404 --> 00:18:26.139
服务器说
“你只需从F到I的数据”

00:18:26.206 --> 00:18:28.842
你不需要
你已经处理的旧东西

00:18:29.209 --> 00:18:32.246
这就是实现
changeTokenUpdatedBlock的重要性

00:18:32.312 --> 00:18:35.082
你就像正常情况那样
缓存服务器改动标记

00:18:36.817 --> 00:18:38.452
我们有
完成模块

00:18:38.519 --> 00:18:41.688
在这个例子里是 fetchDatabase
ChangesCompletionBlock

00:18:41.989 --> 00:18:43.724
同样地 你首先要做错误处理

00:18:43.790 --> 00:18:45.158
Nihar也会谈这个

00:18:45.993 --> 00:18:47.661
然后你会得到
一个最后的改动标记

00:18:47.728 --> 00:18:51.331
如果我们没有错误 最后就会是I

00:18:51.532 --> 00:18:53.200
像正常情况一样缓存这个标记

00:18:53.400 --> 00:18:57.070
现在我们收集了
在数据库有变动的地带

00:18:57.237 --> 00:18:59.306
我们要去获取有变动的档案

00:18:59.373 --> 00:19:01.208
这也就是之前
那个图表的第二步

00:19:01.475 --> 00:19:03.177
我们通过一个新API
来完成这步

00:19:03.243 --> 00:19:06.213
CKFetchRecordZone
ChangesOperation

00:19:06.380 --> 00:19:08.849
它接受地带ID的集合作为参数

00:19:09.049 --> 00:19:11.785
所以你不用担心要根据不同
带有改动的地带来调取档案

00:19:11.852 --> 00:19:14.388
你只需调用一个方法
赋给它所有有变动的地带

00:19:14.788 --> 00:19:16.990
我们不细看代码了
不过它大概看起来是这样

00:19:17.057 --> 00:19:20.694
在处理档案而非地带的地方
你会有一些完成模块

00:19:20.761 --> 00:19:23.063
而且在这个过程中
你会收到改动标记

00:19:24.665 --> 00:19:26.900
好 快速回顾一下
我们讲了什么

00:19:27.601 --> 00:19:31.505
你订阅了数据改动
告诉CloudKit你想接收推送

00:19:31.572 --> 00:19:33.674
一旦用户在另一台设备上
改动了数据

00:19:34.174 --> 00:19:36.143
你侦听了推送通知

00:19:36.243 --> 00:19:38.645
当你收到推送时
你连接服务器

00:19:38.712 --> 00:19:40.314
获取变动了的数据

00:19:40.547 --> 00:19:44.051
这么做的话 你的应用就能提供
流畅的体验

00:19:44.117 --> 00:19:46.520
给你的用户使用他们所有的设备

00:19:48.088 --> 00:19:51.792
好 现在Nihar要上来
讲一些特别的最佳实践

00:19:57.097 --> 00:19:58.065
谢谢 Dave

00:19:58.131 --> 00:19:59.933
大家早上好
谢谢大家的到来

00:20:00.400 --> 00:20:03.403
我是Nihar Sharma
CloudKit团队工程师

00:20:03.470 --> 00:20:07.708
我很高兴能够跟你们
分享一些CloudKit最佳实践

00:20:07.774 --> 00:20:10.577
我们过去几年在Apple
领悟到这些操作

00:20:10.644 --> 00:20:13.046
你也可以在你的应用里利用它们

00:20:13.447 --> 00:20:15.349
我们先来看看
我们要谈些什么

00:20:16.683 --> 00:20:19.920
首先 我想说一下自动认证

00:20:20.120 --> 00:20:23.891
Dave提了一点点
我想更详细地讲讲它是什么

00:20:23.957 --> 00:20:25.526
你怎么用它

00:20:26.860 --> 00:20:29.830
接着 我要讲到
CKOperation API

00:20:29.897 --> 00:20:32.633
这是我们原生CloudKit框架
主要用到的API

00:20:34.635 --> 00:20:37.137
然后 我们会谈
你可以牢记的一些点子

00:20:37.204 --> 00:20:39.006
在设计你应用的
数据库框架时可以用

00:20:39.072 --> 00:20:42.442
它们让你更有效地利用
CloudKit API

00:20:43.377 --> 00:20:45.345
最后 如我们之前告诉过你们的

00:20:45.412 --> 00:20:49.249
错误处理对编写
一个CloudKit应用至关重要

00:20:49.316 --> 00:20:52.119
我今天在这儿想重申一遍

00:20:52.186 --> 00:20:54.688
并且探讨几个不同类型的错误

00:20:54.755 --> 00:20:56.957
还有你的应用应该如何处理它们

00:20:57.090 --> 00:20:58.192
那么 我们开始吧

00:20:58.659 --> 00:21:01.128
首先是自动认证

00:21:02.062 --> 00:21:05.499
你可能熟悉这样的一个UI

00:21:05.566 --> 00:21:10.137
第一次启动时
应用向用户索要很多私人信息

00:21:10.637 --> 00:21:13.106
用户甚至都没开始用这个应用

00:21:13.874 --> 00:21:16.343
而我们觉得在CloudKit
我们有很好的方法

00:21:16.410 --> 00:21:19.646
让你增加和用户互动的机会

00:21:19.713 --> 00:21:22.282
不需要开门见山
索要任何私人信息

00:21:23.350 --> 00:21:26.687
我们通过CloudKit用户记录
做到这一点

00:21:28.856 --> 00:21:33.627
我提醒你们一下 我们给每个用户都
自动创建用户记录

00:21:33.694 --> 00:21:38.065
用户第一次用你的应用时
就记录到了你的iCloud账户

00:21:39.399 --> 00:21:42.636
这样的话 它在每个
CloudKit容器里都具有唯一性

00:21:43.437 --> 00:21:46.673
也给你提供用户的
一个可靠的标识符

00:21:47.174 --> 00:21:50.744
对于应用重启 OS更新等等
都非常可靠

00:21:51.178 --> 00:21:53.313
所以你可以将这个标识符
存在你的服务器上

00:21:53.380 --> 00:21:55.716
并且可以马上开始
给用户建立一个档案

00:21:55.782 --> 00:21:59.219
而当你发现他们
跟你的应用有更多互动时

00:21:59.286 --> 00:22:02.055
你这时就可以向他们征求
更多信息来充实他们的档案

00:22:03.257 --> 00:22:05.893
你找到当前用户的
用户记录ID的方法

00:22:05.959 --> 00:22:10.430
是用CKContainer里的fetchUser
RecordIDcompletionHandler API

00:22:11.131 --> 00:22:13.567
这就是CloudKit自动认证

00:22:15.435 --> 00:22:17.137
我们谈谈CKOperation

00:22:18.939 --> 00:22:20.674
回顾一下 有两种主要的方法

00:22:20.741 --> 00:22:24.244
来让CloudKit框架
将操作呈现给你的应用

00:22:24.845 --> 00:22:29.449
一个是通过调用便利API
它一次针对一个东西

00:22:31.451 --> 00:22:33.687
二则通过
相对应的CKOperation

00:22:33.754 --> 00:22:37.024
这样 我们呈现的每个
便利API调用

00:22:37.090 --> 00:22:40.360
一次只针对一个东西
都有相对应的CKOperation

00:22:41.495 --> 00:22:43.564
后者则是批量处理

00:22:43.764 --> 00:22:47.534
比如说 我们有
fetchWithRecordID API

00:22:47.601 --> 00:22:49.837
在CKDatabase里
一次获取一份档案

00:22:50.170 --> 00:22:52.806
我们有它对应的
CKFetchRecordsOperation

00:22:52.873 --> 00:22:56.410
它接受一个档案ID列表
并且批量获取档案

00:22:57.945 --> 00:23:00.581
用这个CKOperation API
有一定的优势

00:23:00.647 --> 00:23:02.850
相对调用
便利API

00:23:03.016 --> 00:23:04.985
我今天要讲其中的很多优势

00:23:05.052 --> 00:23:06.920
首先

00:23:07.654 --> 00:23:10.457
CKOperation是
NSOperation子类

00:23:11.124 --> 00:23:14.294
这意味着
你有全套设备的

00:23:14.361 --> 00:23:17.197
NSOperation API
让你可以免费使用

00:23:18.432 --> 00:23:21.768
你可以做比如建立你的
CKOperation之间依赖关系

00:23:23.403 --> 00:23:25.205
你可以给它们的
服务质量属性赋值

00:23:25.272 --> 00:23:27.975
让系统知道那个
操作对你有多重要

00:23:28.175 --> 00:23:29.610
甚至是管理队列的优先性

00:23:29.676 --> 00:23:32.145
在你的NSOperation
队列安排它们时

00:23:33.514 --> 00:23:35.816
你还可以取消
CKOperation

00:23:35.883 --> 00:23:37.618
就是那些已经开始执行的

00:23:39.720 --> 00:23:44.525
我推荐你们回去读
NSOperation的参考文档

00:23:44.591 --> 00:23:47.060
来很好地利用
CKOperation API

00:23:47.461 --> 00:23:50.664
一个很好的参考资料是
我们的进阶NSOperation

00:23:50.731 --> 00:23:52.966
即我们去年WWDC的演讲

00:23:55.235 --> 00:23:57.404
既然我们讲到
CloudKit操作

00:23:57.471 --> 00:23:59.740
还有更多东西值得一提

00:23:59.806 --> 00:24:03.043
今天我谈其中三个比较重要的

00:24:03.710 --> 00:24:07.447
第一个是CKOperation
给你的可配置性

00:24:08.315 --> 00:24:11.952
第二个是它让你可以优化资源

00:24:12.019 --> 00:24:14.855
针对系统还有
作为开发者的你们

00:24:16.857 --> 00:24:19.226
最后 我想说一下寿命管理

00:24:19.293 --> 00:24:21.295
这是我们新开的一个东西
让你可以

00:24:21.361 --> 00:24:23.530
在iOS 9.3使用

00:24:26.333 --> 00:24:30.437
首先 快速回顾你可以给一个
CKOperation配置些什么

00:24:31.338 --> 00:24:34.575
操作让你
可以精确调节使用权利

00:24:34.641 --> 00:24:38.045
调节你想不想让这个
操作的网络活动

00:24:38.111 --> 00:24:39.313
通过手机网络来进行

00:24:40.147 --> 00:24:44.985
你还可以给从服务器下载东西的
操作设置关键词

00:24:45.052 --> 00:24:48.522
如果你想下载部分档案
而不是全部的档案

00:24:48.689 --> 00:24:50.824
社区的API不让你做这个

00:24:52.926 --> 00:24:54.595
你可以限制响应结果的数目

00:24:54.661 --> 00:24:56.630
一个操作
返回的结果

00:24:58.532 --> 00:25:01.869
最后 持续运行的
操作还会给你进度更新

00:25:01.935 --> 00:25:04.204
你可以用这个来
驱动一些UI元素

00:25:05.806 --> 00:25:07.908
现在 我们来说一下资源优化

00:25:09.243 --> 00:25:12.479
你的操作在系统中
用得最多的资源

00:25:12.546 --> 00:25:13.881
是网络请求

00:25:15.148 --> 00:25:17.084
现在每个
便利API调用

00:25:17.150 --> 00:25:20.087
都转为系统中至少一个网络请求

00:25:21.488 --> 00:25:24.091
所以 当你使用
CKOperation批量API

00:25:24.625 --> 00:25:28.061
你让系统可以去
最小化所需要的请求数

00:25:28.128 --> 00:25:30.097
来将你的改动发到服务器

00:25:31.031 --> 00:25:33.333
比如 如果你想保存一批档案

00:25:33.433 --> 00:25:35.802
并且你用的是
CKModifiedRecordsOperation

00:25:35.936 --> 00:25:40.274
系统会拿这批档案
并且优化需要的请求

00:25:40.340 --> 00:25:41.608
来把这批档案发到服务器

00:25:44.778 --> 00:25:48.382
这样 这不仅对系统资源是一件好事

00:25:48.448 --> 00:25:53.887
还帮作为开发者的你们
优化你们的网络请求限额

00:25:57.057 --> 00:26:02.863
更进一步 CKOperation
默认让你的网络活动

00:26:02.930 --> 00:26:04.364
酌情进行

00:26:05.599 --> 00:26:09.770
我们指的是你让你的系统
决定一个合适的时间

00:26:09.837 --> 00:26:11.338
来安排你的请求

00:26:12.773 --> 00:26:16.243
欲知更多详情 推荐看看
酌情处理属性

00:26:16.310 --> 00:26:18.445
它在
NSURLSessionConfiguration里

00:26:19.079 --> 00:26:21.448
我们在CKOperation
把它呈现给你的方法

00:26:21.515 --> 00:26:23.617
是通过服务质量属性

00:26:23.784 --> 00:26:27.554
CKOperation有一个
默认值为实用的服务质量

00:26:28.622 --> 00:26:30.557
任何是实用或以下的服务质量

00:26:30.624 --> 00:26:32.793
会默认选择这个酌情进行的行为

00:26:32.860 --> 00:26:34.962
所以如果你注意到
CKOperation

00:26:35.028 --> 00:26:38.298
花了比你预计的
还要长很多的时间来执行

00:26:38.365 --> 00:26:40.067
很可能就是因为系统

00:26:40.133 --> 00:26:43.136
觉得现在还不是一个让你的请求
发出去的好时间

00:26:45.072 --> 00:26:48.008
还有切记的其它几个行为

00:26:48.408 --> 00:26:50.444
当你选择了酌情进行的行为

00:26:50.844 --> 00:26:53.947
网络错误就会重新尝试

00:26:55.048 --> 00:26:59.052
与此同时 你默认有一个
七天的资源超时

00:26:59.253 --> 00:27:02.022
你的操作执行的
每个请求都有这个默认超时

00:27:03.457 --> 00:27:05.425
这就是资源优化

00:27:05.826 --> 00:27:08.695
现在 我们来说说
CKOperation寿命管理

00:27:09.696 --> 00:27:10.664
在我们的平台

00:27:10.731 --> 00:27:14.067
你的应用退出
可能有多重原因

00:27:14.801 --> 00:27:17.671
比如 你的应用在背景可能被中止

00:27:17.738 --> 00:27:20.908
或删除 或者被用户强行退出

00:27:21.875 --> 00:27:25.846
当这些事情发生的时候
你可能有一些更新正在运行

00:27:25.913 --> 00:27:27.514
这些更新可能是用户发起的

00:27:27.581 --> 00:27:30.450
你就应该把它们存到服务器

00:27:30.517 --> 00:27:33.387
不管你的应用是否已经退出

00:27:33.921 --> 00:27:36.190
这些更新也可能因为
你有更新的运行时间比较长

00:27:36.323 --> 00:27:38.725
但优先度比较低
你想尽快完成它们

00:27:38.792 --> 00:27:40.527
不管你的应用还在不在

00:27:41.662 --> 00:27:44.631
在iOS 9.3里
为了达到这个目的

00:27:44.698 --> 00:27:48.168
我们引进了CloudKit
长寿命操作的概念

00:27:49.670 --> 00:27:53.740
这些操作
一旦让你标为长寿命

00:27:53.807 --> 00:27:57.077
系统就会替你的应用执行

00:27:57.144 --> 00:27:58.846
不管你的应用还在不在

00:28:00.714 --> 00:28:04.651
我们会缓存从这个操作
得到的任何服务器响应

00:28:04.718 --> 00:28:08.188
并且会给你提供一个
API来重新处理这些响应

00:28:08.255 --> 00:28:09.389
一旦你的应用再回来

00:28:11.458 --> 00:28:14.728
我们来看看我们呈现的API
它能做到这点

00:28:15.929 --> 00:28:18.298
对于CKOperation
这个非常直截了当

00:28:18.465 --> 00:28:20.067
你有一个
isLongLived旗标

00:28:20.334 --> 00:28:22.469
像正常那样建
一个CKOperation

00:28:22.569 --> 00:28:23.804
一旦你设置了这个旗标

00:28:23.871 --> 00:28:25.939
它就成了一个长寿命操作

00:28:26.974 --> 00:28:29.343
与此同时 你有一个
操作ID

00:28:29.977 --> 00:28:31.945
它是一个系统指定的字符串

00:28:32.112 --> 00:28:34.681
唯一地标识每个
CKOperation

00:28:35.582 --> 00:28:38.385
我们等会儿会看看
为什么这个很重要

00:28:39.620 --> 00:28:43.190
下面我们讲你怎样运行一个
长寿命操作的大体架构

00:28:43.557 --> 00:28:46.026
你像正常那样
初始化一个操作

00:28:46.093 --> 00:28:47.628
设isLongLived旗标

00:28:47.694 --> 00:28:50.797
再加上你的参数和回调来
运行这个操作

00:28:51.298 --> 00:28:52.866
现在 当你想
重新运行它的话

00:28:54.067 --> 00:28:57.938
你可以从CKContainer类
获取这个长寿命操作

00:28:58.005 --> 00:28:59.573
通过操作ID

00:29:00.741 --> 00:29:03.677
如果你想留意运行的情况
你可以设置回调

00:29:03.844 --> 00:29:05.779
可以再运行一次
这个操作

00:29:06.813 --> 00:29:08.182
我们来看一个例子

00:29:08.649 --> 00:29:12.085
假设我们运行一个长寿命
fetchRecordsOperation

00:29:12.953 --> 00:29:16.156
我们像正常那样用参数
设置这个操作

00:29:16.657 --> 00:29:18.825
但要记得设置
isLongLived旗标

00:29:19.459 --> 00:29:22.663
并且将操作ID属性
存入我们的本地缓存

00:29:22.796 --> 00:29:25.599
这样我们就会记得
这个操作代表了什么

00:29:27.301 --> 00:29:29.670
我们设置回调
且把操作加入队列

00:29:29.937 --> 00:29:31.605
现在 当你想要重新运行时

00:29:31.939 --> 00:29:36.476
就用CKContainer里的
fetchLongLivedOperationwithID API

00:29:36.543 --> 00:29:37.744
获取操作

00:29:38.812 --> 00:29:40.814
因为你知道
操作所代表的东西

00:29:40.881 --> 00:29:43.083
通过缓存
所以你可以安全地执行它

00:29:43.650 --> 00:29:45.552
并且设置合适的回调

00:29:46.386 --> 00:29:50.190
你不用再设置参数
或调节其它的操作属性

00:29:50.257 --> 00:29:51.758
你之前可能设置过

00:29:52.159 --> 00:29:53.794
这样重启了操作

00:29:55.095 --> 00:29:59.066
现在 CloudKit会重新处理
我们有的所有缓存响应

00:29:59.132 --> 00:30:00.267
给操作

00:30:00.400 --> 00:30:02.002
让你跟上进度

00:30:02.069 --> 00:30:04.505
达到你的应用不在时
操作所取得的进度

00:30:04.571 --> 00:30:08.141
或者给你
操作所有的结果

00:30:09.076 --> 00:30:11.945
这也意味着这些操作
会被清理

00:30:12.012 --> 00:30:13.080
这是一个重要的信号

00:30:13.313 --> 00:30:16.016
正常情况下发生在
完成模块

00:30:16.083 --> 00:30:17.351
被操作调用

00:30:18.619 --> 00:30:22.322
你要记住你的应用
有至少24小时

00:30:22.523 --> 00:30:25.592
重新运行任何他们可能加入队列的
长寿命操作

00:30:30.330 --> 00:30:33.100
这就是关于CKOperation
API的全部内容

00:30:33.700 --> 00:30:36.270
现在我们转移到数据建模的话题

00:30:37.437 --> 00:30:39.907
今天我想给你三条主要的点子

00:30:40.174 --> 00:30:42.676
第一条是关于数据库架构的冗余

00:30:42.743 --> 00:30:43.944
你可以怎样利用它们

00:30:44.011 --> 00:30:46.980
还有它们怎样帮你
更有效利用CloudKit API

00:30:47.648 --> 00:30:50.717
第二条是如何用引用

00:30:50.784 --> 00:30:53.420
来避免你可能遇到的一类错误

00:30:53.487 --> 00:30:54.821
在你CloudKit应用中

00:30:55.522 --> 00:30:58.091
最后 我想谈一下父级引用

00:30:58.225 --> 00:31:01.361
是我们在这次发布里
新加的一种引用

00:31:01.428 --> 00:31:02.963
来支持CloudKit分享

00:31:04.431 --> 00:31:06.533
那么 我们来说说
数据库架构的冗余

00:31:07.568 --> 00:31:11.238
我们用开发照片分享应用的例子

00:31:11.972 --> 00:31:14.708
现在对于这个应用 你在服务器
可能有的第一个东西

00:31:14.775 --> 00:31:16.877
就是给照片的档案类型

00:31:17.311 --> 00:31:20.747
你可以储存用户的高像素照片

00:31:20.814 --> 00:31:25.652
是在我们某款iOS设备上照的
储存为CKAsset

00:31:27.955 --> 00:31:30.557
现在 假设用户第一次启动应用

00:31:30.624 --> 00:31:33.594
当你像Dave之前
推荐的那样获取改动时

00:31:33.660 --> 00:31:36.363
你可能想展示一个缩略图

00:31:36.430 --> 00:31:38.465
囊括用户所有最近的照片

00:31:38.732 --> 00:31:41.134
就像这样
Photos应用就有这个功能

00:31:42.269 --> 00:31:44.805
这样一来
可能会造成网络带宽的巨大浪费

00:31:44.872 --> 00:31:48.175
的一种情形就是
下载全部的高清资源

00:31:48.242 --> 00:31:50.410
每次你打开这个页面时都下载

00:31:51.211 --> 00:31:54.181
那你该怎么办
答案非常简单

00:31:54.882 --> 00:31:58.285
你可以考虑在档案里
加入一个冗余的域

00:31:58.352 --> 00:32:00.654
代表缩小的资产

00:32:02.856 --> 00:32:07.594
而这可以让你
配合使用CKOperation

00:32:08.629 --> 00:32:10.998
和我们讲过的
所需关键词的属性

00:32:11.064 --> 00:32:13.200
让你可以获取部分档案

00:32:13.267 --> 00:32:17.137
你现在可以只获取那些
你需要的关键词 用来驱动UI

00:32:17.204 --> 00:32:18.639
你用户感兴趣的UI

00:32:20.274 --> 00:32:22.342
甚至能用
结果限制的属性

00:32:22.576 --> 00:32:26.280
来限制你在
一个页面上显示的结果数

00:32:28.549 --> 00:32:31.785
这样 你就可以把
一个优化的下载加入队列

00:32:32.186 --> 00:32:34.922
能够将一个动态UI
呈现给你的用户

00:32:35.255 --> 00:32:38.125
你只在需要的时候取需要的东西

00:32:39.927 --> 00:32:43.163
能用所需关键词属性的还有新的

00:32:43.230 --> 00:32:45.632
CKFetchRecordZone
ChangesOperation

00:32:45.699 --> 00:32:47.668
和CKFetchRecordsOperation

00:32:47.734 --> 00:32:49.837
两者都从Cloud给你获取东西

00:32:51.538 --> 00:32:55.142
我提醒一点 就是这些API
在网上也可以用

00:32:55.209 --> 00:32:56.543
通过CloudKit JS

00:32:58.679 --> 00:33:00.814
通过利用这些工具
你让你的用户可以

00:33:00.881 --> 00:33:03.217
在你的应用里
有更为动态的体验

00:33:03.283 --> 00:33:06.286
因为他们不必
等你完成操作

00:33:06.553 --> 00:33:09.056
来下载他们会用到的数据

00:33:10.757 --> 00:33:15.629
接着 讨论CKReferences
我提醒你们这些是什么

00:33:16.663 --> 00:33:21.034
CloudKit让你的档案
可以指向其它档案

00:33:21.768 --> 00:33:24.938
比如 如果我这儿有两份档案
档案A和档案B

00:33:25.339 --> 00:33:27.574
我们把引用存在档案A上

00:33:28.108 --> 00:33:29.743
用档案B来给它初始化

00:33:30.277 --> 00:33:31.979
创建了CKReference

00:33:33.547 --> 00:33:36.617
现在假设我们想给
我们的照片分享应用添加相册

00:33:37.050 --> 00:33:38.952
可以涵括多张照片

00:33:39.019 --> 00:33:42.389
我们怎样可以给
这个一对多的关系建模呢？

00:33:44.424 --> 00:33:46.293
简单地

00:33:46.360 --> 00:33:49.663
而又天真地 你会觉得
下面的建模方法比较好

00:33:50.264 --> 00:33:54.034
储存档案ID
档案ID用来引用照片档案

00:33:54.101 --> 00:33:57.738
把ID作为一个数组直接存在
照片所属相册的相册档案里

00:33:59.339 --> 00:34:00.807
这就是概念图

00:34:02.142 --> 00:34:06.380
现在 我们来瞧瞧当你用户的多个设备

00:34:06.446 --> 00:34:09.949
尝试添加照片到
相同的相册会发生些什么

00:34:12.152 --> 00:34:14.221
假设我们在Cloud
有一个相册档案

00:34:14.288 --> 00:34:15.822
相册还没有照片

00:34:17.424 --> 00:34:20.427
现在 记得你的用户会有多台设备

00:34:21.762 --> 00:34:23.397
它们都获取这个相册记录

00:34:24.231 --> 00:34:26.733
看到相册没有照片
它们很满意

00:34:28.969 --> 00:34:29.969
设备现在都有了新照片

00:34:30.036 --> 00:34:32.706
它们各自有想加到
同一个相册的照片

00:34:34.208 --> 00:34:36.476
所以它们把档案更新加入队列

00:34:37.110 --> 00:34:38.812
假设iPhone档案
最先到相册

00:34:38.879 --> 00:34:41.014
服务器现在知道有一张照片

00:34:41.081 --> 00:34:43.050
对其中一张照片的引用

00:34:44.184 --> 00:34:48.021
当别的新设备加入进来
并且尝试更新时

00:34:48.121 --> 00:34:51.291
它们更新的不再是
最新的服务器档案

00:34:52.259 --> 00:34:56.263
所以 在这个案例里
两台设备都会出现错误

00:34:56.330 --> 00:34:58.465
CKError
serverRecordChanged

00:34:59.366 --> 00:35:02.970
现在 我推荐你们去看我们的
进阶CloudKit演讲

00:35:03.036 --> 00:35:07.040
是2014年的WWDC
你会学到更多如何处理这个错误的细节

00:35:07.608 --> 00:35:11.211
不过 现在我们来看
可不可以完全避免它

00:35:13.680 --> 00:35:17.618
在这个例子里 我们知道我们的
相册档案会有频繁的写操作

00:35:17.985 --> 00:35:21.255
所以 取而代之 如果我们
一对多关系的建模

00:35:21.321 --> 00:35:26.059
用的是一个反向指针
把引用存在照片档案上

00:35:26.994 --> 00:35:28.428
照片归属这个相册

00:35:28.762 --> 00:35:30.063
这样我们就彻底排除了

00:35:30.130 --> 00:35:32.766
我们在相册档案上的
写操作纠纷

00:35:34.268 --> 00:35:36.670
在这个情况下
每当你加入新的照片时

00:35:37.004 --> 00:35:40.307
你就设置它引用所属的相册的档案

00:35:40.374 --> 00:35:41.742
并且保存照片档案

00:35:43.977 --> 00:35:47.781
这么做的话 你就可以完全
排除掉你之前有的纠纷

00:35:48.415 --> 00:35:50.984
你还会想知道
我怎样可以获取所有照片

00:35:51.051 --> 00:35:52.886
这就是我们一开始遇到的问题

00:35:53.187 --> 00:35:55.556
为了达到这个目的 你可以用请求

00:35:58.559 --> 00:36:02.763
你要获取归属
这个相册的所有照片记录

00:36:02.829 --> 00:36:03.997
这非常简单直白

00:36:04.064 --> 00:36:07.134
你要的就是相册的引用域

00:36:07.201 --> 00:36:09.236
那儿有你所有的照片档案

00:36:12.005 --> 00:36:14.074
下面 我们来讲父级引用

00:36:15.509 --> 00:36:16.910
今年 在CKRecord

00:36:16.977 --> 00:36:20.214
我们加了新的一类引用
叫父级引用

00:36:20.280 --> 00:36:22.316
帮你给数据建模

00:36:22.382 --> 00:36:24.585
并且更好地支持
CloudKit分享

00:36:25.752 --> 00:36:27.454
我们推荐的是

00:36:27.521 --> 00:36:31.124
如果你的应用支持分享
你就用父级引用

00:36:31.325 --> 00:36:33.627
来建立一个等级制数据模型

00:36:34.695 --> 00:36:36.830
规定好你应用分享的单元

00:36:36.897 --> 00:36:38.799
并且根据情况来设置父级引用

00:36:38.866 --> 00:36:41.268
我们来看看一个例子
来解释我刚说的内容

00:36:43.971 --> 00:36:47.541
我们的照片和相册档案是一个
父级引用的很棒的例子

00:36:48.509 --> 00:36:51.578
相册很明显是照片档案的父亲

00:36:51.879 --> 00:36:54.147
我们只需设置父母属性

00:36:54.515 --> 00:36:57.150
在照片档案上
指向我们相册档案的ID

00:36:58.085 --> 00:36:59.553
并且保存照片档案

00:37:02.823 --> 00:37:05.526
现在 假设我们在我们
应用里都用这个模型

00:37:05.826 --> 00:37:08.128
我们有一个像这样的等级分配

00:37:08.529 --> 00:37:11.732
现在 一个用户想分享整个相册

00:37:12.432 --> 00:37:14.134
这种情况下你需要做的只是

00:37:14.201 --> 00:37:17.871
创建一个CKShare
附上相册档案作为组档案

00:37:18.172 --> 00:37:20.841
你一下子便可以分享整个等级分层

00:37:20.908 --> 00:37:22.876
你就是用父级引用来建立的这个等级

00:37:24.511 --> 00:37:27.781
现在 CloudKit还支持
部分分享的等级制

00:37:28.615 --> 00:37:33.353
这种情况下
比如用户只想分享照片C

00:37:34.188 --> 00:37:36.557
你可以创建一个分享
只附上照片C

00:37:36.823 --> 00:37:38.025
这样

00:37:39.193 --> 00:37:42.963
只有照片C
还有它的所有子代

00:37:43.030 --> 00:37:45.566
通过父级设置将加入这个分享

00:37:47.367 --> 00:37:48.969
以上就是数据建模

00:37:50.604 --> 00:37:52.072
我们来谈谈错误处理

00:37:52.873 --> 00:37:55.442
现在 我们有不同类型的错误

00:37:55.509 --> 00:37:57.611
而你的应用应该处理它们

00:37:57.678 --> 00:38:00.280
通过几个主要的不同方法

00:38:00.347 --> 00:38:01.982
我们来看看它们各是什么样的

00:38:03.183 --> 00:38:04.685
我们有一个简单的例子

00:38:04.751 --> 00:38:06.587
假设你的设备

00:38:06.653 --> 00:38:08.689
选择一个
CKModifyRecordsOperation

00:38:08.755 --> 00:38:10.157
尝试跟服务器连接

00:38:10.624 --> 00:38:13.760
服务器有可能响应
两种主要的东西

00:38:14.061 --> 00:38:18.131
它可以说
我一点儿也不喜欢这个请求

00:38:18.198 --> 00:38:19.800
别再试着跟我连接

00:38:20.901 --> 00:38:24.037
或者它可以说你的请求什么都好

00:38:24.171 --> 00:38:28.208
就是现在的时间不太合适
等会儿再试一次吧

00:38:29.476 --> 00:38:32.412
你们的应用需要
处理这两种错误

00:38:32.479 --> 00:38:35.516
而且要用很不同的方法
我们来仔细看看到底是什么

00:38:36.884 --> 00:38:39.052
第一种错误是致命错误

00:38:39.386 --> 00:38:40.621
你基本上无能为力

00:38:41.922 --> 00:38:44.725
我们有几个错误代码
表明你遇到的错误是严重的

00:38:45.425 --> 00:38:49.263
比如内部错误
服务器拒绝请求

00:38:50.197 --> 00:38:53.567
非法参数
或者权限失败

00:38:54.801 --> 00:38:59.273
你要在你的应用里
给你的用户显示合适的UI

00:38:59.339 --> 00:39:02.442
让他们知道出错误了
重试也没辙

00:39:04.545 --> 00:39:06.513
然而 另外一种错误

00:39:06.880 --> 00:39:10.184
服务器让你歇一会儿再重试

00:39:10.417 --> 00:39:13.954
我们会告诉你
服务器想让你等的时间

00:39:15.022 --> 00:39:19.526
下面是一系列错误代码
每个里面都嵌入了时间值

00:39:20.894 --> 00:39:26.066
zoneBusy serviceUnavailable
和requestRateLimited

00:39:27.334 --> 00:39:29.303
当你收到这些错误代码中的
任意一个时

00:39:29.369 --> 00:39:32.372
你要找到
CKErrorRetryAfterKey

00:39:32.439 --> 00:39:34.441
在错误的用户信息字典里面

00:39:34.908 --> 00:39:39.246
你要等上面说明的时间并且重新初始化
同一个CKOperation

00:39:39.313 --> 00:39:43.283
用相同的参数
并重试这个操作

00:39:44.151 --> 00:39:46.386
下面是一个简单的例子
还有你需要的所有代码

00:39:46.453 --> 00:39:48.355
如何等一段时间

00:39:48.422 --> 00:39:51.225
而CKErrorRetryAfterValue
代表了这个时间值

00:39:51.525 --> 00:39:53.894
如何重新初始化
同一个CKOperation

00:39:56.330 --> 00:39:58.565
注意 如果有些时候

00:39:58.632 --> 00:40:01.001
你的操作可能
在设备上出现错误

00:40:01.068 --> 00:40:02.703
而甚至还没连到服务器
怎么办？

00:40:03.737 --> 00:40:06.006
我今天讲解两种主要的情况

00:40:06.073 --> 00:40:08.475
CloudKit可能完全用不了

00:40:09.376 --> 00:40:11.845
第一种是设备处于下线状态

00:40:13.680 --> 00:40:15.549
这种情况下 我们推荐

00:40:15.916 --> 00:40:19.720
你监测可能连到的网络
就像

00:40:19.786 --> 00:40:21.455
在别的基于网络的
应用里做的一样

00:40:22.923 --> 00:40:26.960
若你用的服务质量
是用户发起或者更高等级

00:40:27.127 --> 00:40:31.632
而网络错误不会自动为你重试

00:40:31.698 --> 00:40:35.002
你会看到这个错误代码
CKErrorNetworkUnavailable

00:40:35.903 --> 00:40:37.671
一旦你监测可连接的网络

00:40:37.738 --> 00:40:40.674
你可以通过SCNetworkReachability
API 做到这点

00:40:40.741 --> 00:40:43.210
比如在系统配置框架里

00:40:44.578 --> 00:40:46.213
这样你就可以让你的用户知道

00:40:46.280 --> 00:40:50.017
“嘿 这些改动现还传不到服务器上”

00:40:50.484 --> 00:40:55.122
但我们推荐你让你的用户
保持跟应用的互动

00:40:55.189 --> 00:40:56.590
即便设备处于下线状态

00:40:56.823 --> 00:40:59.626
你应该把这些改动
存在你的本地缓存中

00:40:59.960 --> 00:41:03.330
当可连接性API
告诉你设备重新上线时

00:41:03.530 --> 00:41:07.100
你就可把CloudKit操作
加入队列并把档案存到服务器上了

00:41:10.070 --> 00:41:14.208
另一种主要的情况是
当你想给用户用私人数据库

00:41:14.274 --> 00:41:16.677
而用户没有登录到
一个iCloud账户的时候

00:41:17.411 --> 00:41:21.548
此情况下 返回错误代码
CKErrorNotAuthenticatedTo

00:41:22.816 --> 00:41:25.419
我们推荐的是 对于你所有的应用

00:41:25.485 --> 00:41:30.357
在首次启动一定要登记侦听
CKAccountChange通知

00:41:31.892 --> 00:41:36.129
当它触发时 用 accountStatus
completionHandler API

00:41:36.396 --> 00:41:38.899
来重新获取
当前用户的账户状态

00:41:39.266 --> 00:41:42.503
告知他们
一些操作会失败

00:41:42.569 --> 00:41:44.738
因为他们没有登录
一个iCloud账号

00:41:47.007 --> 00:41:49.543
我来总结一下
我们今天都看了哪些内容

00:41:51.144 --> 00:41:53.947
我们学习了如何订阅并且获取改动

00:41:54.014 --> 00:41:56.283
来高效地和服务器同步

00:41:57.718 --> 00:42:01.522
我们领略了使用批量
CKOperation API优势

00:42:02.022 --> 00:42:04.424
我们推荐你
所有的应用都采用它

00:42:06.126 --> 00:42:08.695
我们也研究了几个点子
如何设计你的数据库架构

00:42:08.762 --> 00:42:11.031
来完全避免一类错误

00:42:11.098 --> 00:42:13.300
或更有效利用
CloudKit API

00:42:14.935 --> 00:42:18.605
最后 我们探讨了
如何处理一些类型的错误

00:42:18.672 --> 00:42:20.541
还有如何分辨它们

00:42:21.742 --> 00:42:24.211
还有服务器的意图 当它返回

00:42:24.278 --> 00:42:26.446
一些特定错误代码 而不是其它代码

00:42:28.182 --> 00:42:31.051
我们昨天有一个相关演讲
如果你没有去

00:42:31.118 --> 00:42:33.520
我推荐你回去在网上补看回来

00:42:34.254 --> 00:42:37.357
这儿有更多的信息
谢谢你们 祝你们有很棒的一天