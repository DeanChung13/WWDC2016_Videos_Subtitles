00:00:19.353 --> 00:00:23.190 
Swift入门

00:00:23.257 --> 00:00:25.926 
大家好欢迎参加Swift入门

00:00:26.426 --> 00:00:29.563 
我是Dave Addey
和同事Brian和Alex一起

00:00:29.630 --> 00:00:33.033 
我想要给你们一个Swift编程语言
的快速概览

00:00:33.800 --> 00:00:36.970 
在之后60分钟里
你们会获得足够的Swift 3知识

00:00:37.037 --> 00:00:40.774 
来能够阅读Swift代码
最好还能开始写代码

00:00:42.309 --> 00:00:46.180 
让我们看看这个语言的一些基础

00:00:46.680 --> 00:00:48.916 
这是一些我两年前写的代码

00:00:49.383 --> 00:00:51.418 
我写了一个常量
用let来表明

00:00:51.718 --> 00:00:54.188 
这被叫做language
是一个字符串类型

00:00:54.721 --> 00:00:57.491 
这中间的冒号我们会经常
在Swift中看见

00:00:57.558 --> 00:00:58.992 
它表明是类型

00:00:59.059 --> 00:01:00.994 
language是一个字符串类型

00:01:01.562 --> 00:01:04.730 
我在swift代码里用字符串给它赋值

00:01:05.966 --> 00:01:06.934 
让我们做更多

00:01:07.301 --> 00:01:09.403 
假设有个整数称为
introduced

00:01:09.469 --> 00:01:10.904 
我们将它赋值为2014

00:01:11.305 --> 00:01:13.307 
及一个布尔型被称为
isAwesome

00:01:13.473 --> 00:01:14.675 
把它设为真

00:01:16.043 --> 00:01:19.413 
你注意到这些值都无需改变

00:01:19.713 --> 00:01:21.515 
名字language不会改变

00:01:21.582 --> 00:01:23.183 
或者它出现的年份

00:01:23.684 --> 00:01:26.486 
两年了Swift还是很好

00:01:26.553 --> 00:01:28.355 
所以这也可以是一个常量

00:01:28.989 --> 00:01:30.924 
这是Swift中的一般原则

00:01:31.258 --> 00:01:34.027 
如果一些量不需要被改变
我们申明它为常量

00:01:35.329 --> 00:01:38.131 
现在你可能还注意到了命名习惯

00:01:38.565 --> 00:01:41.902 
常量和变量是小写开始的驼峰式
命名法

00:01:41.969 --> 00:01:45.372 
像字符串、取整和布尔
类型是大写驼峰式命名法

00:01:47.174 --> 00:01:49.209 
现在如果我们看右边的这些

00:01:49.276 --> 00:01:50.644 
很明显

00:01:50.711 --> 00:01:54.314 
我想要的是字符串 整数 布尔型

00:01:55.215 --> 00:01:58.385 
在这种情况下
Swift会推断这些类型

00:01:58.452 --> 00:02:00.754 
我们不需要写出来

00:02:00.821 --> 00:02:03.323 
你仍然得到明确申明了类型的变量

00:02:03.390 --> 00:02:04.992 
但是你不用写那么多代码

00:02:06.426 --> 00:02:07.861 
这是一些常量

00:02:07.928 --> 00:02:10.797 
那么对于变量呢？
它们有时候会改变

00:02:10.864 --> 00:02:12.799 
这是一个变量
被用var表明

00:02:12.866 --> 00:02:14.401 
这是为了语言的版本

00:02:14.468 --> 00:02:17.838 
它被改变了
让我们更新它到2016年的情况

00:02:19.239 --> 00:02:21.608 
现在如果我试着对常量这样做

00:02:21.675 --> 00:02:23.977 
如果我试着给
isAwesome赋值为假

00:02:24.645 --> 00:02:25.979 
Swift告诉我有个错误

00:02:26.046 --> 00:02:27.047 
这是对的

00:02:28.982 --> 00:02:31.285 
编程时常做的一件事

00:02:31.351 --> 00:02:33.320 
是通过其它值生成字符串

00:02:33.387 --> 00:02:36.089 
我们可以把字符串连接在一起

00:02:36.156 --> 00:02:39.393 
像这里展示的这样
但是Swift有一个更整洁的方法

00:02:39.459 --> 00:02:42.162 
被称为字符串插入
它看起来是这样的

00:02:42.930 --> 00:02:46.233 
我们可以把字符串和值放进
一个更大的字符串

00:02:46.300 --> 00:02:49.403 
通过用括号包裹并在前面加一个
反斜杠

00:02:49.469 --> 00:02:52.005 
我们在这想生成消息
“Hello WWDC”

00:02:53.207 --> 00:02:54.908 
我们并不只用字符串

00:02:54.975 --> 00:02:56.443 
我们还可以添加其他值

00:02:56.510 --> 00:02:58.478 
像是这里的整数
加入年

00:02:59.079 --> 00:03:01.582 
我们还可以加入表达式

00:03:01.648 --> 00:03:04.751 
我们可以让年加1
为了可能是明年的代码

00:03:06.520 --> 00:03:09.756 
现在Swift中的字符串
对于Unicode编码是完全兼容的

00:03:09.823 --> 00:03:14.127 
它可以是ASCII
也可以是猫 狗 国旗

00:03:14.828 --> 00:03:16.530 
这都是相同的

00:03:16.597 --> 00:03:19.066 
不论是常量还是变量

00:03:19.132 --> 00:03:20.868 
你几乎可以使用任何字符

00:03:20.934 --> 00:03:23.036 
在常量和变量名中

00:03:24.338 --> 00:03:26.373 
说到标准字符

00:03:26.440 --> 00:03:29.409 
Swift做了很多工作来解决这意味
什么

00:03:29.476 --> 00:03:30.844 
做为一个单独字符

00:03:31.311 --> 00:03:33.780 
无论你的字符串是怎样在幕后编码的

00:03:33.847 --> 00:03:35.349 
或者怎么显示在屏幕上

00:03:36.683 --> 00:03:38.785 
我有一个字符串
叫做dogString

00:03:39.353 --> 00:03:42.689 
你可能认为它有6个字符

00:03:42.756 --> 00:03:46.627 
D O G ？！狗脸

00:03:47.194 --> 00:03:48.495 
但你错了

00:03:48.562 --> 00:03:51.098 
这里只有5个字符而不是6个

00:03:51.765 --> 00:03:55.302 
这里有一个特殊符号
被称为问号惊叹号

00:03:55.369 --> 00:03:59.106 
很好的用来形容狗

00:04:00.374 --> 00:04:02.910 
如果你不相信我
让Swift来证明这点

00:04:03.744 --> 00:04:06.146 
每个字符串都有一属性
叫characters

00:04:06.213 --> 00:04:08.382 
它给我们字符串中的字符的集合

00:04:08.448 --> 00:04:11.051 
我们可以访问这个集合的计数属性

00:04:11.118 --> 00:04:12.653 
来看有多少字符

00:04:13.253 --> 00:04:14.922 
如果把那传递给Print函数

00:04:14.988 --> 00:04:17.558 
我们发现我们实际上有5个字符

00:04:18.725 --> 00:04:20.793 
如果你仍然不相信我

00:04:20.861 --> 00:04:23.197 
让我们一个个遍历那些字符

00:04:23.263 --> 00:04:24.865 
用for-in循环

00:04:24.932 --> 00:04:26.767 
把每一个打印在它们自己的一行中

00:04:26.834 --> 00:04:29.403 
你可以看到我们实际上有5个字符

00:04:29.736 --> 00:04:33.240 
D O G ？！和狗脸

00:04:35.943 --> 00:04:39.012 
除了基本类型外

00:04:39.079 --> 00:04:41.181 
我们还有一些内置的集合

00:04:41.248 --> 00:04:43.217 
我们有数组和字典

00:04:43.584 --> 00:04:47.221 
你可能知道字典在别的语言里
是哈希或者映射表

00:04:47.955 --> 00:04:51.191 
最简单的创造数组或字典的方法
是使用字面值

00:04:51.258 --> 00:04:54.361 
这是一个数组字面值
用方括号包围

00:04:54.428 --> 00:04:55.762 
并用逗号分隔每个值

00:04:56.663 --> 00:04:59.933 
这里我们有一个数组包含4个名字
4个字符串

00:05:00.968 --> 00:05:02.436 
字典看起来类似

00:05:02.503 --> 00:05:05.172 
它们的键和值被冒号分开

00:05:05.239 --> 00:05:08.542 
我们有一个字典
它的键是名字是字符串类型

00:05:08.609 --> 00:05:10.143 
它的值是整数

00:05:11.912 --> 00:05:15.782 
现在你可能注意到在数组中

00:05:15.849 --> 00:05:17.718 
它们都是相同的类型
都是字符串

00:05:18.318 --> 00:05:21.188 
在名字数组中插入其它类型是
没有意义的

00:05:21.255 --> 00:05:24.224 
有一个整数 布尔型或自行车

00:05:24.725 --> 00:05:26.126 
这会很奇怪

00:05:26.760 --> 00:05:29.029 
对于名字
我们总是希望它们是字符串

00:05:29.530 --> 00:05:30.664 
我们可在Swift中表达它

00:05:30.731 --> 00:05:33.166 
我们可以说我们想要一个字符串
数组

00:05:33.233 --> 00:05:35.369 
当我们从中取出值时

00:05:35.435 --> 00:05:37.271 
我们可以把它当成字符串处理

00:05:38.038 --> 00:05:39.273 
这就是我们为何这样写

00:05:39.339 --> 00:05:42.442 
这是我们怎么写一个字符串数组
用方括号包围一个字符串

00:05:43.443 --> 00:05:44.611 
但是我们早前看到

00:05:45.479 --> 00:05:49.183 
如果右手边明显的表明了我们
想要的类型

00:05:49.583 --> 00:05:52.319 
Swift会为我们做推断
在这也会发生

00:05:52.386 --> 00:05:54.021 
我们不需要写下类型

00:05:54.321 --> 00:05:57.057 
很清楚我们想要字符串数组

00:05:57.791 --> 00:05:59.126 
对字典也是同样的

00:05:59.193 --> 00:06:02.329 
这里很明显我们想要键是字符串
值是整数

00:06:02.396 --> 00:06:06.099 
Swift可以为我们推断这些
所有东西都有清楚的类型

00:06:08.335 --> 00:06:11.638 
Swift有所以你在别的语言里知道
循环种类

00:06:11.705 --> 00:06:15.509 
我们有在执行循环体之前
检查条件用的While循环

00:06:16.043 --> 00:06:18.545 
一repeat-while循环
执行循环体一次

00:06:18.612 --> 00:06:21.081 
在检查条件前
来决定是否继续

00:06:22.015 --> 00:06:24.384 
我们先前看过我们有for-in循环

00:06:24.451 --> 00:06:26.653 
用来在字符串中遍历所有字符

00:06:27.421 --> 00:06:30.424 
这不是for-in唯一能做的事

00:06:31.258 --> 00:06:34.061  
我们能用它遍历一个范围

00:06:34.127 --> 00:06:36.864  
这里我们有一个从1到5的范围

00:06:36.930 --> 00:06:38.565  
包括这些数字

00:06:38.632 --> 00:06:41.602  
我们用来打印5个入口
在乘以4表中

00:06:42.302 --> 00:06:46.473  
我们把它写成1... 5
这被称为闭合范围

00:06:46.540 --> 00:06:47.908  
因为它包括2边的数字

00:06:48.675 --> 00:06:50.511  
有时我们需要

00:06:50.577 --> 00:06:54.014  
一个范围
运行到比最后的数字少1

00:06:54.548 --> 00:06:55.949  
这是一个它很有用的例子

00:06:56.717 --> 00:06:59.987  
我有一个整数数组
但我只想打印前5个

00:07:00.621 --> 00:07:05.058  
因为数组的索引从0开始
我希望索引从0到4

00:07:05.792 --> 00:07:08.362  
所以我们想要用半闭合范围运算符

00:07:08.428 --> 00:07:09.429  
点 点 小于

00:07:09.496 --> 00:07:12.566  
因为它运行到比最终的数字
在这是5小1

00:07:14.835 --> 00:07:17.037  
我们可以对数组使用for-in循环

00:07:17.104 --> 00:07:19.773  
这里我们为数组里的每个名字
打印一条信息

00:07:20.541 --> 00:07:22.376  
我们也可以对字典使用它

00:07:22.943 --> 00:07:26.613  
现在注意我们要遍历键和值

00:07:26.680 --> 00:07:28.682  
名字和年龄
在同一时间

00:07:29.383 --> 00:07:32.486  
这在Swift里被称为元组

00:07:32.553 --> 00:07:34.454  
让你把多个值组合在一起

00:07:34.521 --> 00:07:35.789  
同时使用它们

00:07:35.856 --> 00:07:38.225  
我们晚点会看到另一个例子

00:07:38.425 --> 00:07:41.595  
这使代码遍历一个字典时清楚很多

00:07:43.497 --> 00:07:45.699  
我们要怎么修改这些集合？

00:07:46.366 --> 00:07:49.303  
这是我今年 WWDC 的装箱单

00:07:49.369 --> 00:07:51.905  
我把它申明我一个变量
所以我可以改变它

00:07:51.972 --> 00:07:55.042  
我包括了基本的袜子和鞋子

00:07:56.677 --> 00:08:00.147  
在 WWDC 2014

00:08:00.214 --> 00:08:03.984  
我忘记了我的袜子
这是一个恶梦

00:08:04.051 --> 00:08:05.853 
我不会再犯同样的错误

00:08:06.186 --> 00:08:10.057 
所以我们检查数组的第一项是袜子

00:08:10.123 --> 00:08:12.960 
2014后如果我把它放在列表里它
会是第一个

00:08:13.527 --> 00:08:15.295 
我们通过下标来这样做

00:08:15.362 --> 00:08:18.565 
在数组名后写一个在方括号里的
索引

00:08:18.632 --> 00:08:21.802 
如果我们打印这个值
我实际上记得添加袜子

00:08:23.070 --> 00:08:26.039 
袜子和鞋子还不够
但是为了一星期的会议

00:08:26.106 --> 00:08:28.809 
我还需要其他东西
让我们添加一个新物品

00:08:28.876 --> 00:08:31.245  
让我们把裤子加入数组

00:08:31.311 --> 00:08:33.145  
我们使用append方法

00:08:34.448 --> 00:08:35.782  
但是这有一个问题

00:08:36.683 --> 00:08:39.852  
这个会议是在美国
他们不叫裤子“trousers”

00:08:40.787 --> 00:08:42.121  
他们叫裤子“pants”

00:08:42.188 --> 00:08:44.591  
这会引起很多误解

00:08:44.791 --> 00:08:46.727 
所以让我们修改数组中的一个值

00:08:47.094 --> 00:08:49.062 
让我们把它改成牛仔裤

00:08:49.129 --> 00:08:52.432  
我们又用下标来这样做
改变在索引2的项目

00:08:52.799 --> 00:08:55.536  
牛仔裤在哪都一样
因此不会招致误解

00:08:57.371 --> 00:09:00.641  
这个会议在加利福尼亚州
这里总是晴天很热

00:09:01.208 --> 00:09:02.476  
让我们再加一些东西

00:09:02.543 --> 00:09:06.446  
让我们加一些短裤 拖鞋 防晒霜

00:09:07.147 --> 00:09:09.716  
我们可用append
contentsOf方法

00:09:09.783 --> 00:09:12.452  
并传递一个兼容的数组
另一个字符串数组

00:09:13.120 --> 00:09:15.022  
它们在同一时间都被添加

00:09:16.523 --> 00:09:21.094  
这个会议是在加利福尼亚州的
旧金山

00:09:21.628 --> 00:09:23.163  
这里并不总是天晴并且炎热

00:09:23.764 --> 00:09:25.566  
所以让我们修改一下这三项

00:09:25.632 --> 00:09:28.302 
用连帽衫和围巾来代替

00:09:29.069 --> 00:09:31.738 
我们可以通过传递一个下标范围
来这么做

00:09:32.005 --> 00:09:33.974 
注意我们要修改三项中的两项

00:09:34.041 --> 00:09:35.943  
这在Swift中是合法的

00:09:37.811 --> 00:09:40.214  
那对于字典呢？
让我们修改一个字典

00:09:40.547 --> 00:09:44.117  
这里是我的年龄字典

00:09:44.184 --> 00:09:46.520  
我想加入其他人

00:09:46.587 --> 00:09:51.191  
我们通过用下标的办法
来为一个还没有值的键加一个值

00:09:51.258 --> 00:09:52.659  
我加入了Justyn

00:09:53.660 --> 00:09:56.129  
但是仔细想想
上周是Justyn的生日

00:09:56.196 --> 00:09:57.397  
所以这个值现在不对

00:09:57.464 --> 00:10:00.901  
我需要更新它
我还是用一样的方法

00:10:00.968 --> 00:10:02.936  
我给同一个键赋不同的值

00:10:03.003 --> 00:10:04.404  
现在我的字典是对的了

00:10:06.607 --> 00:10:09.576 
如果我想要从字典里取出一个值

00:10:10.077 --> 00:10:12.246 
如果我想知道是否有Devon的年龄

00:10:12.312 --> 00:10:15.382 
或者Daryl
或者Daniel

00:10:16.650 --> 00:10:19.319 
可能在字典对这些人有一个值

00:10:19.386 --> 00:10:22.189 
也可能没有
我们需要一个方式来应对这种情况

00:10:22.956 --> 00:10:26.226 
这是Swift的被称为可选的一个
功能的好的使用案例

00:10:27.294 --> 00:10:31.532  
如果我们试着对Amy这样做
我们可能期望有个值是40

00:10:32.299 --> 00:10:34.768  
如果我们对Daryl这么做
我们应该得到什么？

00:10:34.835 --> 00:10:36.236  
这里对Daryl没有值

00:10:37.938 --> 00:10:39.239 
这样考虑这个问题

00:10:39.907 --> 00:10:43.677 
或者在字典里Amy有一个整数值

00:10:44.244 --> 00:10:47.915 
或者没有一个整数值
像例子里的Daryl

00:10:49.216 --> 00:10:54.087 
所以这里我们有一个可选的整数
我们写成Int问号

00:10:54.788 --> 00:10:56.823 
问号表示这里可能有值

00:10:56.890 --> 00:10:57.991 
也可能没有

00:10:59.860 --> 00:11:02.196 
我们看看我们是否找到一个值

00:11:02.262 --> 00:11:03.897 
通过把它和nil比较

00:11:03.964 --> 00:11:06.834 
nil是一种特殊情况
是没有值的简写

00:11:07.401 --> 00:11:09.870 
如果对Daryl这么做
没有值

00:11:09.937 --> 00:11:11.071 
我们会打印这个信息

00:11:12.406 --> 00:11:13.240 
年龄没有找到

00:11:14.041 --> 00:11:16.743 
如果我们试着对Amy这样做
我们找到一个值

00:11:16.810 --> 00:11:19.479 
所以它不等于nil
我们不打印这个消息

00:11:21.014 --> 00:11:23.183 
一般我们不仅仅查看一个值是否
存在

00:11:23.250 --> 00:11:25.319 
当它存在时我们想使用它

00:11:25.385 --> 00:11:27.955 
Swift有一种简单的写法

00:11:28.288 --> 00:11:29.456 
写下“if let”

00:11:30.858 --> 00:11:35.195 
它是说如果字典含有Amy的值

00:11:36.129 --> 00:11:38.832 
让一个新的常量age等于那个值

00:11:39.533 --> 00:11:42.135  
我们就可以在if语句里使用那个值

00:11:42.970 --> 00:11:45.072  
请注意在此我们把它当成
真正的整数使用

00:11:45.138 --> 00:11:46.373  
它不再是可选的

00:11:47.307 --> 00:11:50.110  
if语句查看它的值并解包

00:11:50.177 --> 00:11:53.447  
给我们一个普通的整数
我们可以对它做整数的操作

00:11:55.649 --> 00:11:57.818 
我们看了一些if语句

00:11:57.885 --> 00:11:59.987 
这是另一个
用来打印生日消信

00:12:00.721 --> 00:12:03.056 
有两件事需要注意

00:12:04.057 --> 00:12:07.895 
首先我们不需要在条件附近有括号
只需要写下条件

00:12:09.029 --> 00:12:13.133 
第二我们给每一部分的语句加
大括号

00:12:13.200 --> 00:12:15.936 
加表明哪部分代码会被执行

00:12:18.071 --> 00:12:21.508 
此外我们还有switch语句

00:12:21.575 --> 00:12:24.378 
可以用来写更复杂更强大的匹配

00:12:25.345 --> 00:12:28.949 
它转换一个常量或者变量的当前值

00:12:29.016 --> 00:12:30.817 
和一系列可能的情况匹配

00:12:31.552 --> 00:12:33.554 
比如我们有这种情况

00:12:33.620 --> 00:12:36.623 
如果年龄值是1

00:12:36.690 --> 00:12:39.426 
我们想要打印第一个生日快乐的
消息

00:12:40.127 --> 00:12:42.062 
我们也可以匹配范围

00:12:42.262 --> 00:12:44.831 
匹配任意值使一些人是青少年

00:12:45.666 --> 00:12:48.936 
我们可以匹配更复杂的模式
比如这一个

00:12:49.002 --> 00:12:52.139 
一个叫decade的临时常量

00:12:52.606 --> 00:12:54.641 
等于我们当前要匹配的值

00:12:55.309 --> 00:12:57.377 
检查是否能被10整除

00:12:58.245 --> 00:13:01.815 
如果可以
用它打印一条特殊的生日消息

00:13:01.882 --> 00:13:06.220 
为任何人刚满30或40岁或其他
重要的年龄

00:13:07.788 --> 00:13:10.424 
但这有一个问题

00:13:11.525 --> 00:13:15.062 
如果我们想要为以下年龄的人打印
消息 比如41

00:13:15.462 --> 00:13:17.664 
97或56

00:13:18.632 --> 00:13:20.200 
它们不会得到一个消息

00:13:20.267 --> 00:13:23.070 
听起来很不幸
特别是在它们的生日上

00:13:25.038 --> 00:13:26.640 
坦白说Swift在这帮助我们

00:13:27.040 --> 00:13:30.277 
Swift确保switch语句
是完整的

00:13:30.344 --> 00:13:33.780 
你不会偶然的忘记你需要的情况

00:13:34.448 --> 00:13:37.084 
在这个例子里
我们可以加一个default语句

00:13:37.317 --> 00:13:40.888  
捕获每一个我们之前没有捕获的
情况

00:13:40.954 --> 00:13:43.357  
说无聊的生日快乐

00:13:45.559 --> 00:13:47.261  
这里有另一个switch语句

00:13:48.095 --> 00:13:51.932 
它获得一个字符串值用户名
和一个布尔型值

00:13:51.999 --> 00:13:54.735 
指示用户密码是否合法

00:13:55.469 --> 00:13:57.771 
我们会一起用这两个值

00:13:57.838 --> 00:14:00.073 
来产生一个合适的消息用来显示

00:14:00.140 --> 00:14:02.509 
当用户要登录一个受限的区域

00:14:03.777 --> 00:14:07.481 
要这样做 我们可以同时switch
两个值

00:14:08.015 --> 00:14:09.783 
用一个元组
像之前做过的那样

00:14:10.918 --> 00:14:13.620 
这表明我们可以写一些非常非常
有趣的case

00:14:13.687 --> 00:14:15.455 
有趣的switch case

00:14:15.522 --> 00:14:17.524 
可有一个case
是用户名为admin

00:14:17.591 --> 00:14:19.126 
密码为真

00:14:19.193 --> 00:14:21.328 
然后打印消息来欢迎管理员回来

00:14:22.863 --> 00:14:24.598 
现在如果是一个客人

00:14:24.665 --> 00:14:27.234 
我们永远都不希望客人进入受限
区域

00:14:27.301 --> 00:14:28.936 
即使密码是合法的

00:14:29.436 --> 00:14:32.706 
我们可以用下划线来忽略密码

00:14:33.273 --> 00:14:35.742 
它的意思是匹配任意可能的值

00:14:36.977 --> 00:14:38.478 
对所有其他用户

00:14:38.545 --> 00:14:41.782 
我们不关心用户名是什么
我们只关心密码

00:14:41.849 --> 00:14:43.617 
我们可以忽略用户名

00:14:44.184 --> 00:14:47.054 
我们切换到我们想要做的

00:14:47.120 --> 00:14:48.655 
检查密码合法性

00:14:48.922 --> 00:14:51.892 
要这么做我们创建一个叫做
IsValid的临时常量

00:14:52.459 --> 00:14:55.562 
然后我们用三元条件运算符

00:14:55.629 --> 00:14:57.998 
就是这个问号和冒号

00:14:59.166 --> 00:15:01.602 
来说如果是合法的
用这个消息

00:15:01.668 --> 00:15:03.871 
否则用这个消息

00:15:05.005 --> 00:15:06.707 
如果我们浏览一些例子

00:15:07.774 --> 00:15:10.010 
如果使用管理员并且密码有效

00:15:10.077 --> 00:15:12.679 
他们将得到一个管理员消息
就像我预期的那样

00:15:13.614 --> 00:15:16.817 
如果我们试着用客人
即使密码有效

00:15:16.884 --> 00:15:19.720 
他们得到对不起你不能进入的消息

00:15:20.320 --> 00:15:22.823 
如果我们用Bob并且密码有效

00:15:22.890 --> 00:15:25.058 
他获得预期的欢迎消息

00:15:25.592 --> 00:15:28.428 
但如果他的密码无效
他得到访问被拒绝的消息

00:15:30.664 --> 00:15:34.268 
现在关于这个switch语句
有最后一个需要注意的点

00:15:35.068 --> 00:15:37.437 
它没有默认这个情况

00:15:38.305 --> 00:15:40.374 
它没有的原因是它不需要

00:15:40.440 --> 00:15:42.042 
它已经是完整的

00:15:42.109 --> 00:15:46.346 
如果我们看一下后这个case

00:15:46.713 --> 00:15:49.850 
实际上它包括了所有可能的情况

00:15:49.917 --> 00:15:51.451 
我们没有在上面匹配到的

00:15:51.518 --> 00:15:53.921 
所以switch语句不需要default
就已经完整了

00:15:56.023 --> 00:15:58.926 
这就是Swift语言的一些基本知识

00:15:58.992 --> 00:16:00.994 
现在我想把演讲交给
我的同事Brian

00:16:01.061 --> 00:16:03.463 
来介绍Swift中的函数和闭包

00:16:08.802 --> 00:16:11.038 
好的 谢谢Dave
就像我已经说过的

00:16:11.104 --> 00:16:13.974 
让我从怎样在Swift中
定义函数开始

00:16:14.675 --> 00:16:17.110 
你用func关键字定义函数

00:16:17.177 --> 00:16:19.513 
然后你在大括号里实现它

00:16:19.580 --> 00:16:22.416 
我们定义了一个简单的函数
叫做sendMessage

00:16:22.482 --> 00:16:24.251 
打印消息到控制台

00:16:25.419 --> 00:16:27.821 
然后你可以用一个直观的方式
调用这个函数

00:16:27.888 --> 00:16:32.392  
通过写下其名sendMessage
接着是一对空括号

00:16:33.293 --> 00:16:34.962  
让我们给这个函数加上参数

00:16:35.028 --> 00:16:38.198  
来表明消息是否应该吼叫

00:16:39.366 --> 00:16:41.802 
你写下参数的名称
接着是冒号

00:16:41.869 --> 00:16:43.070 
然后是参数的类型

00:16:43.136 --> 00:16:46.406 
就像你申明一个常量或变量
所做的那样

00:16:46.940 --> 00:16:50.110 
我们添加了一个叫做shouting
的参数 它是布尔类型

00:16:50.844 --> 00:16:52.079 
当你调用这个函数时

00:16:52.145 --> 00:16:55.716 
参数的名称为你传入的参数提供
一个标签

00:16:57.618 --> 00:17:00.287  
给参数加标签使代码更易读

00:17:00.354 --> 00:17:03.056  
使参数的目的清楚

00:17:03.757 --> 00:17:06.193  
在这个情况下
如果没有shouting标签

00:17:06.260 --> 00:17:09.229  
一些阅读你的代码的人可能以为
那个真是表明

00:17:09.296 --> 00:17:11.565  
是否发送这条消息

00:17:12.965 --> 00:17:14.233  
所以你可以喊出一个消息

00:17:14.300 --> 00:17:15.836  
但是你要把消息发给谁？

00:17:16.403 --> 00:17:17.738  
让我们加入另一个参数

00:17:17.804 --> 00:17:19.873  
使我们把消息发给特定的人

00:17:21.308 --> 00:17:23.343 
在这我们添加一个参数叫做接收人

00:17:23.410 --> 00:17:24.877 
是一个字符串类型

00:17:24.944 --> 00:17:28.982 
我们还通过字符串插入将接收人
姓名加入我们的消息中

00:17:30.417 --> 00:17:33.654  
当你调用函数时你可以传入接收人
姓名

00:17:34.555 --> 00:17:37.291  
现在虽然这个消息按你期待的
那样打印

00:17:37.357 --> 00:17:39.526  
它读起来不是很好

00:17:40.127 --> 00:17:43.497 
发送消息接收人
Morgan读起来很怪

00:17:43.964 --> 00:17:46.233 
当你调用函数时你希望它读起来
自然

00:17:46.300 --> 00:17:48.335 
在这个例子中你希望读起来像

00:17:48.402 --> 00:17:52.206 
发送消息给Morgan
这形成一个有好的语法的短语

00:17:52.806 --> 00:17:55.475 
你可以通过改变参数名称来这样做

00:17:55.542 --> 00:17:58.212 
这也会改变参数的标签名

00:17:58.278 --> 00:18:00.981 
这使得函数被调用时读起来好一些

00:18:01.048 --> 00:18:02.883 
发送消息给Morgan

00:18:02.950 --> 00:18:06.153 
但是这在函数内部工作的不好

00:18:07.187 --> 00:18:11.091 
在函数体里你希望参数是一个名词
而不是一个介词

00:18:11.158 --> 00:18:13.560 
嘿给听起来不好

00:18:14.461 --> 00:18:17.197 
但是有时没有一个单词能工作良好

00:18:17.264 --> 00:18:21.368 
既在函数体内
又在调用函数的标签

00:18:21.969 --> 00:18:24.104 
在Swift中你不用放弃其中的一个

00:18:24.605 --> 00:18:26.406 
当一个参数的名称不合适时

00:18:26.473 --> 00:18:29.710 
参数的标签

00:18:29.776 --> 00:18:31.778 
你可以明确地提供一个更合适的
名称

00:18:33.080 --> 00:18:36.817 
你把这个明确的参数标签写在
参数名前

00:18:36.884 --> 00:18:39.520 
在这我们添加to作为明确的参数标签

00:18:39.586 --> 00:18:41.622 
在接收者参数的之上

00:18:41.688 --> 00:18:43.524 
这表示你可以用“to”

00:18:43.590 --> 00:18:46.093 
当你调用函数发送消息给Morgan

00:18:46.159 --> 00:18:49.630 
然后你仍然可以在函数体内
使用接收者

00:18:51.098 --> 00:18:53.634 
让我们添加另一个参数到函数中

00:18:53.700 --> 00:18:55.802 
使你调用它时能提供一个定制消息

00:18:57.504 --> 00:19:00.174 
这里我们添加了一个消息参数
是字符串类型

00:19:00.240 --> 00:19:03.010 
现在我们调用函数
你可以传递你自己的消息

00:19:04.745 --> 00:19:07.481  
再一次的
代码如预期一样运行

00:19:07.548 --> 00:19:09.516  
但是读起来还是不好

00:19:10.050 --> 00:19:12.686  
发送消息消息是重复的

00:19:13.587 --> 00:19:17.824 
消息标签无助于澄清第一个
参数的作用

00:19:17.891 --> 00:19:20.394 
因为函数名中已经说清楚了

00:19:20.460 --> 00:19:21.461 
发送消息

00:19:22.329 --> 00:19:24.998 
在这里参数标签使代码更难读

00:19:25.732 --> 00:19:26.834 
在这种情况

00:19:26.900 --> 00:19:29.469 
你可以在参数名前写一个下划线

00:19:30.304 --> 00:19:32.840 
这表明你不给参数提供标签

00:19:32.906 --> 00:19:34.174 
当你调用函数时

00:19:37.277 --> 00:19:39.513 
这时我们的函数读起来自然

00:19:39.580 --> 00:19:41.548 
发送消息 在Bash见
给Morgan

00:19:43.784 --> 00:19:46.420 
我们不常需要喊出我们的消息

00:19:46.486 --> 00:19:49.523 
我们通常传递假给这个参数

00:19:50.157 --> 00:19:51.825 
在Swift你可以捕获这个行为

00:19:51.892 --> 00:19:54.027 
在函数申明中

00:19:54.695 --> 00:19:57.631 
当参数有一个常用到的值时

00:19:57.698 --> 00:19:59.900 
你可以把它作为default值

00:20:01.001 --> 00:20:04.438 
你能过赋一个default值
在这个情况下是假

00:20:04.505 --> 00:20:06.340 
在参数的类型的后面

00:20:07.074 --> 00:20:08.442 
当你调用函数时

00:20:08.509 --> 00:20:10.677 
你可以忽略相应的参数

00:20:10.744 --> 00:20:12.346 
default值被使用

00:20:15.015 --> 00:20:18.752  
当你决定是否使用 怎样使用
明确的参数标签

00:20:18.819 --> 00:20:22.990  
什么时候忽略一个参数或者提供
一个default值

00:20:23.056 --> 00:20:25.826  
记得函数只被申明一次

00:20:25.893 --> 00:20:27.361  
但是被重复使用

00:20:27.427 --> 00:20:29.296  
最重要的事是

00:20:29.363 --> 00:20:32.232  
函数被调用时读起来清楚准确

00:20:33.467 --> 00:20:34.701  
现在让我们学习更多

00:20:34.768 --> 00:20:36.436  
你需要考虑的事

00:20:36.503 --> 00:20:38.238  
当编写优秀Swift API时

00:20:38.939 --> 00:20:41.141  
请去看Swift API指导演讲

00:20:42.309 --> 00:20:44.811 
我们已经看了很多种函数获得
值的方式

00:20:45.312 --> 00:20:48.015 
让我们看看让它们返回值的方法

00:20:48.815 --> 00:20:50.250 
假设你想写一个函数

00:20:50.317 --> 00:20:53.453 
返回数组里第一个有给定前缀的
字符串

00:20:54.588 --> 00:20:56.423 
函数获得一个字符串前缀

00:20:57.391 --> 00:20:58.692 
一个字符串数组

00:20:59.660 --> 00:21:02.196 
返回一个有给定前缀的字符串

00:21:02.262 --> 00:21:03.797 
如你所见 你用一个箭头

00:21:03.864 --> 00:21:06.433 
来表明函数值的类型

00:21:06.500 --> 00:21:07.668 
在这里是字符串

00:21:08.735 --> 00:21:10.137 
让我们看看这是怎么工作的

00:21:11.438 --> 00:21:14.575 
首先用一个for-in循环来遍历
数组中的每一个字符串

00:21:15.375 --> 00:21:17.711 
然后检测字符串是否有给定的前缀

00:21:19.413 --> 00:21:21.515 
你需要检测字符串
是否有给定的前缀

00:21:21.582 --> 00:21:23.550 
使用string.hasprefix方法

00:21:23.917 --> 00:21:27.020 
如果它有 那么完成了
你只需要返回这个字符串

00:21:27.087 --> 00:21:28.889 
通过将它写进返回语句

00:21:30.724 --> 00:21:31.859 
但是你要返回什么

00:21:31.925 --> 00:21:34.261 
如果数组不含有你在找的字符串？

00:21:35.128 --> 00:21:37.564 
因为这个函数申明了会返回字符串

00:21:37.631 --> 00:21:40.734 
唯一的选项是一些合法的字符串

00:21:40.801 --> 00:21:42.236 
在这个情况下是空字符串

00:21:43.003 --> 00:21:44.304 
但这不是好的Swift代码

00:21:45.405 --> 00:21:48.041 
但是像Dave演示过的
可选是完美的

00:21:48.108 --> 00:21:50.410 
用来表明值有可能不存在

00:21:51.712 --> 00:21:54.181 
所以你只需要改变函数返回类型

00:21:54.248 --> 00:21:57.184 
为可选字符串
通过在字符串后写一个问号

00:21:57.584 --> 00:22:00.487 
现在你可以返回nil
当字符串没有找到时

00:22:01.388 --> 00:22:04.124  
因为函数返回可选的字符串

00:22:04.191 --> 00:22:06.560  
你可以在一个if-let语句里安全
地使用它

00:22:07.528 --> 00:22:10.497  
请注意Swift推断函数的返回类型

00:22:10.564 --> 00:22:12.666 
所以不需要明确的写出来

00:22:14.434 --> 00:22:16.003 
我们看了一些方法

00:22:16.069 --> 00:22:19.072 
函数能获得和返回不同类型

00:22:19.139 --> 00:22:22.943 
比如字符串 整数 数组
和可选类型

00:22:23.243 --> 00:22:25.913 
让我们看看怎么写另一种函数

00:22:28.015 --> 00:22:30.651 
假设你要写一个函数过滤一个
数字数组

00:22:30.717 --> 00:22:32.085 
基于一些条件

00:22:33.120 --> 00:22:34.988 
让我们想想这个函数需要做什么

00:22:36.223 --> 00:22:37.925  
它要获得一个数字数组

00:22:38.358 --> 00:22:39.927  
对数组中的每一个数字

00:22:39.993 --> 00:22:43.330  
函数判断是否将它包含在被过滤
的结果中

00:22:44.364 --> 00:22:48.635  
比如你想要一个数组
被过滤成只含有偶数

00:22:49.469 --> 00:22:51.772  
你可以测试每个数是否能被2整除

00:22:52.339 --> 00:22:56.210  
4当然是偶数
所以它被包括在结果数组里

00:22:57.978 --> 00:23:00.180  
如果一个数不是偶数
比如17

00:23:01.114 --> 00:23:03.884  
过滤函数转而检测下一个数

00:23:03.951 --> 00:23:05.886  
然后继续 遍历剩下的数组

00:23:06.920 --> 00:23:08.822  
让我们看看写这个函数的代码

00:23:10.858 --> 00:23:13.227 
函数申明是你想要的

00:23:13.493 --> 00:23:16.230 
但是你要把什么类型放在
这个包括数字参数这里？

00:23:16.964 --> 00:23:21.101 
你刚刚看到
决定是否把数字包括进结果里

00:23:21.668 --> 00:23:23.570 
是一个函数

00:23:23.637 --> 00:23:26.139 
不是一个简单的值比如字符串
或者一个数字

00:23:27.241 --> 00:23:31.245 
在Swift里函数可以接收其他函数
做为参数

00:23:31.912 --> 00:23:34.014 
那么函数类型看起来是怎样的？

00:23:35.182 --> 00:23:37.684 
所有的函数类型在Swift中
都有基本的形式

00:23:38.085 --> 00:23:40.521 
函数参数类型
如果有的话

00:23:40.587 --> 00:23:43.757 
在括号里
跟随的是一个箭头

00:23:43.824 --> 00:23:44.858 
然后是函数返回类型

00:23:46.326 --> 00:23:49.663 
比如说我们早前的发送消息函数

00:23:50.163 --> 00:23:52.266 
它有空的括号

00:23:52.332 --> 00:23:55.169 
因为它不需要任何参数
箭头空

00:23:55.836 --> 00:23:58.405 
这里空表示它不返回任何值

00:23:59.406 --> 00:24:01.575 
在Swift中如果你的函数不返回
任何值

00:24:01.642 --> 00:24:04.478 
你不需要明确的写箭头空

00:24:08.715 --> 00:24:11.218 
这是第一个字符串函数

00:24:11.385 --> 00:24:13.353 
它的签名复杂一些

00:24:13.420 --> 00:24:15.489 
但是它的类型还是遵循基本的形式

00:24:16.256 --> 00:24:19.793 
它获得一个字符串一个数组
一个字符串参数并返回一个可选字符串

00:24:20.327 --> 00:24:23.096 
你们已经知道了函数类型的语法

00:24:23.163 --> 00:24:26.767 
所以很清楚你要怎么完成过滤
整数这个函数的申明

00:24:27.768 --> 00:24:29.169 
这个包括数字参数

00:24:29.236 --> 00:24:33.207 
可以是任何函数获得一个整数
返回一个布尔型

00:24:33.273 --> 00:24:37.511 
你把类型Int写在括号里
箭头布尔

00:24:38.212 --> 00:24:40.380 
让我们来完成函数的剩余部分

00:24:41.915 --> 00:24:44.151 
你需要生成一个过滤过的数字
的数组

00:24:44.218 --> 00:24:46.019 
这有一个变量叫做结果

00:24:46.086 --> 00:24:48.755 
它被初始化为一个整数数组

00:24:49.423 --> 00:24:52.392 
随着你遍历传给这个函数的数组

00:24:52.559 --> 00:24:55.796 
检查每个数字是否应该包括在
结果数组里

00:24:56.830 --> 00:25:00.501 
要这么做 你把每个数字传递给
包括数字函数

00:25:00.567 --> 00:25:02.636 
注意在过滤整数函数体内

00:25:02.703 --> 00:25:07.441 
包括数字参数被当成被传入的函数
的名字

00:25:07.908 --> 00:25:09.009 
那说明你可以调用它

00:25:09.076 --> 00:25:11.311 
和调用其实函数相同的方式

00:25:12.412 --> 00:25:13.780 
这就是你怎么写一个函数

00:25:13.847 --> 00:25:15.949 
获得另一个函数做为一个参数

00:25:16.450 --> 00:25:18.452 
但是你怎么调用这类函数？

00:25:19.720 --> 00:25:22.689 
首先你需要把一些值传递给过滤
整数函数

00:25:22.756 --> 00:25:24.458 
这是一个数字数组

00:25:24.525 --> 00:25:26.927 
和一个简单的函数叫做可被2整除

00:25:26.994 --> 00:25:28.896 
表明一个整数是否是偶数

00:25:31.465 --> 00:25:34.334 
你可以看到能被2整除的类型

00:25:34.401 --> 00:25:37.104 
和包括数字参数的类型匹配

00:25:37.671 --> 00:25:42.676 
这表明我们可以传递能被2整除
函数

00:25:43.143 --> 00:25:45.145 
给过滤整数函数做为一个参数

00:25:46.346 --> 00:25:50.284 
你通过简单地传递能被2整除
函数的名字

00:25:51.218 --> 00:25:53.854  
现在你得到一个数组只含有偶数

00:25:54.788 --> 00:25:57.057  
注意你没有包括括号

00:25:57.124 --> 00:25:59.793  
当传递能被2整除函数时

00:25:59.860 --> 00:26:02.362  
这是因为你现在并没有调用它

00:26:02.429 --> 00:26:05.299  
它在晚些时候在过滤整数函数体
内被调用

00:26:07.201 --> 00:26:10.037  
还要注意我们传递了数组的名字

00:26:11.238 --> 00:26:14.007  
我们也可以传递数组字面值

00:26:14.474 --> 00:26:16.910  
比如如果你只需要传递少量值

00:26:16.977 --> 00:26:19.746  
不需要创建一个常量
为了等会的重用

00:26:21.081 --> 00:26:24.184  
传递函数参数也可以这样

00:26:26.653 --> 00:26:29.323  
很可能能被2整除函数

00:26:29.389 --> 00:26:30.757  
不会被重用

00:26:31.291 --> 00:26:33.794  
新建一个函数很麻烦

00:26:33.861 --> 00:26:37.231  
每次你想要传递不同的过滤函数
条件

00:26:38.565 --> 00:26:41.368  
如果你看看能被2整除的重要部分

00:26:41.668 --> 00:26:43.637  
你可以看到给它一个名字

00:26:43.704 --> 00:26:46.573  
仅仅是为了方便重用

00:26:47.941 --> 00:26:50.210 
能被2整除仅仅是一个名字

00:26:50.277 --> 00:26:52.679 
针对你所看重的功能

00:26:54.715 --> 00:26:58.552 
在Swift中像你可以写
一个字面值字符串或字面值数组

00:26:58.619 --> 00:27:01.522 
你也可以写一个
没有名字的字面值函数

00:27:01.588 --> 00:27:04.224 
被称为闭包表达式
并在你的代码中被传递

00:27:05.325 --> 00:27:06.860 
写一个闭包表达示的语法

00:27:06.927 --> 00:27:09.363 
和函数申明很像

00:27:09.429 --> 00:27:10.898 
除了它没有名字

00:27:11.832 --> 00:27:15.903 
把整个闭包的函数写在大括号中

00:27:15.969 --> 00:27:20.741 
用in关键字把闭包函数体和
签名区分开

00:27:20.807 --> 00:27:23.777 
用数字参数类型是整数

00:27:23.844 --> 00:27:26.280 
在闭包的函数体内返回一个布尔型

00:27:28.649 --> 00:27:31.752 
这是最明确和最完整的定义闭包
的方式

00:27:32.452 --> 00:27:33.720 
但是你之前见过了

00:27:33.787 --> 00:27:37.157 
Swift可以推断很多信息
从代码的上下文中

00:27:39.393 --> 00:27:42.829 
比如闭包的函数类型已知

00:27:42.896 --> 00:27:45.566 
从包括数字这个参数的类型中

00:27:46.099 --> 00:27:48.202 
所以你不需要明确的写出来

00:27:49.670 --> 00:27:53.207 
如果整个闭包的体只是一个
返回语句

00:27:53.273 --> 00:27:56.777 
像这里一样你不需要明确的写
出return关键字

00:27:58.345 --> 00:28:02.382 
这是更干净的语法
但是因为闭包很短

00:28:02.649 --> 00:28:05.652 
看起来这个参数数字都显得有点
多余

00:28:06.186 --> 00:28:09.790 
像这种情况
Swift提供暗示的变量名

00:28:09.857 --> 00:28:13.460 
所以不需要写出参数名或者in
关键字

00:28:14.928 --> 00:28:16.230 
这个暗示的文件名

00:28:16.296 --> 00:28:18.732 
用一个美元符号开始
以及一个从0开始的数字

00:28:18.799 --> 00:28:23.136 
$0表示第一个闭包参数
$1是第二个 等等

00:28:24.238 --> 00:28:27.574 
虽然这可以在任何闭包表达式中
使用

00:28:28.275 --> 00:28:31.979 
使用它们不会使你的代码变得
难以阅读

00:28:33.714 --> 00:28:37.818  
现在你看到Swift提供很多方便的
编写闭包的方式

00:28:37.985 --> 00:28:41.255  
但是直接在一个函数的括号中
传递它们

00:28:41.688 --> 00:28:43.457  
看起来有很多符号

00:28:44.258 --> 00:28:47.060  
一个关闭大括号紧邻一个关闭括号

00:28:47.327 --> 00:28:48.428  
看起来很怪

00:28:50.030 --> 00:28:53.100  
但是当闭包是最后一个参数时

00:28:53.166 --> 00:28:54.401  
这种情况就是

00:28:55.002 --> 00:28:57.371  
你可以写一个尾随闭包

00:28:57.437 --> 00:28:59.139  
就在括号外面

00:29:00.307 --> 00:29:04.278  
你接下来会看到如果一个闭包是
一个函数的唯一参数

00:29:04.678 --> 00:29:06.713  
你可以移除这个括号

00:29:07.814 --> 00:29:09.983  
这时尾随闭包看起来很好

00:29:10.317 --> 00:29:12.886  
当闭包含有多于一行代码时

00:29:13.820 --> 00:29:16.323 
比如这个更复杂的闭包

00:29:16.390 --> 00:29:19.860 
它判断一个数每一位相加的和
是否是偶数

00:29:21.328 --> 00:29:22.563 
尾随闭包语法

00:29:22.629 --> 00:29:27.034 
确保即使是复杂的有多行的闭包

00:29:27.100 --> 00:29:28.836 
看起来也很自然很好

00:29:30.671 --> 00:29:33.273 
现在过滤整数函数很有用

00:29:33.340 --> 00:29:35.642 
如果你想要过滤整数

00:29:36.376 --> 00:29:39.313 
但是要怎么过滤其他类型的数组
比如类型数组？

00:29:40.514 --> 00:29:42.816 
例如假设你有一个名字数组

00:29:42.883 --> 00:29:45.352 
你想要一个过滤了的数组
只含有名字

00:29:45.419 --> 00:29:47.354 
含有少于给定的字符数

00:29:48.755 --> 00:29:50.757  
你可以写一个过滤字符串函数

00:29:50.824 --> 00:29:52.259  
像你看到的这个

00:29:52.726 --> 00:29:55.262  
因为你已经写好了一个过滤整数
函数

00:29:55.329 --> 00:29:57.764  
让我们来看看你能否重用一些逻辑

00:29:59.499 --> 00:30:01.568 
首先你当然想要做一些簿记

00:30:01.635 --> 00:30:05.372 
把所有涉及数字的地方改成字符串

00:30:06.507 --> 00:30:11.278 
下一步把所有整型改成字符串类型

00:30:13.447 --> 00:30:15.382 
因为实际上这2个函数的行为

00:30:15.449 --> 00:30:18.318 
是一样的
对整数和字符串

00:30:18.385 --> 00:30:19.786 
没有什么别的要做

00:30:19.853 --> 00:30:21.421 
它们实际上是同样的函数

00:30:22.422 --> 00:30:25.025 
你现在有函数过滤字符串数组

00:30:26.393 --> 00:30:30.197 
现在如果你想要一个函数过滤
其他类型

00:30:30.464 --> 00:30:33.534 
你可以重复这个步骤

00:30:33.600 --> 00:30:34.601 
为每种类型

00:30:34.935 --> 00:30:37.638 
但是这显然很无聊

00:30:38.505 --> 00:30:41.141 
实际上你可以写一个函数

00:30:41.208 --> 00:30:43.977 
可以处理任意类型的数组

00:30:44.044 --> 00:30:45.546 
这被称为泛型函数

00:30:46.346 --> 00:30:47.948 
我们来看看怎么写一个

00:30:48.682 --> 00:30:52.152 
写一个这种函数和你已经看到的
没有很大不同

00:30:52.753 --> 00:30:54.988 
首先你把名字改得更通用

00:30:55.055 --> 00:30:57.925 
比如函数叫过滤

00:30:57.991 --> 00:31:00.594 
而不是过滤整数或过滤字符串

00:31:01.495 --> 00:31:04.164 
接下来更重要的是你需要填写
占位符

00:31:04.231 --> 00:31:07.234 
你在这里看到的
元素的类型

00:31:07.835 --> 00:31:10.137 
但是你现在还不知道元素的类型

00:31:10.971 --> 00:31:13.640 
所以你希望是一个类型参数

00:31:14.007 --> 00:31:16.844 
实际的类型会在函数被调用时确定

00:31:18.378 --> 00:31:20.247 
这里我们填写了占位符

00:31:20.314 --> 00:31:22.649 
用一个通用类型参数叫做元素

00:31:23.650 --> 00:31:26.720 
所以你能看到区别
在类型参数

00:31:26.787 --> 00:31:30.190 
和实际存在的类型比如字符串
或者整数

00:31:30.624 --> 00:31:34.528 
你把类型参数写在尖括号中

00:31:34.595 --> 00:31:36.163 
紧跟函数名后面

00:31:36.730 --> 00:31:38.632 
现在你有一个泛型函数

00:31:38.699 --> 00:31:42.035 
作用于一个数组包含任意类型的值

00:31:44.571 --> 00:31:47.374 
你和以前一样调用这种函数

00:31:47.441 --> 00:31:50.611 
你不需要指定你想要这个函数
处理的类型

00:31:50.677 --> 00:31:53.247 
因为可以通过你传入的值推断

00:31:54.681 --> 00:31:58.352  
过滤是如此有用的操作
所以Swift标准库

00:31:58.418 --> 00:32:02.256  
有一个过滤方法可用用于任何
种类的序列或集合

00:32:03.257 --> 00:32:07.160 
你和你看到的过滤函数以同样的
方式工作

00:32:07.227 --> 00:32:10.531 
除了这是一个方法
你需要用点号来调用它

00:32:10.597 --> 00:32:12.900 
names.filter像你看到的

00:32:14.668 --> 00:32:17.037  
Swift标准库实际上有很多其他
方法

00:32:17.104 --> 00:32:19.339  
接受闭包作为一个参数

00:32:19.907 --> 00:32:22.643  
另一个很有用的是映射方法

00:32:22.709 --> 00:32:25.212  
它也作用于任何序列或集合

00:32:26.013 --> 00:32:27.981  
映射返回一个新的数组

00:32:28.048 --> 00:32:30.884  
包含对每个元素进行闭包的结果

00:32:31.251 --> 00:32:34.888  
这是一个例子在对上面得到的
包含短名字的数组调用映射方法

00:32:35.088 --> 00:32:38.625  
它传递一个闭包把每个字符串
转成大写

00:32:40.527 --> 00:32:44.598  
你可以把它们链起来强行多个操作

00:32:44.665 --> 00:32:45.666 
比如

00:32:45.732 --> 00:32:49.102 
你可以在同一个表达式里过滤
并大写

00:32:49.169 --> 00:32:51.672 
通过把两个方法形成一个链

00:32:51.738 --> 00:32:53.073 
使用点号

00:32:53.140 --> 00:32:54.875 
过滤先进行

00:32:54.942 --> 00:32:56.977 
然后映射在被过滤过的数组上
被调用

00:32:57.044 --> 00:32:59.613 
最终返回大写的字符串

00:33:01.381 --> 00:33:02.516  
这读起来很棒

00:33:02.583 --> 00:33:04.918  
即使你用尾随闭包语法

00:33:06.587 --> 00:33:10.324  
所以使用闭包和函数接收闭包
作为参数的这个组合

00:33:10.390 --> 00:33:15.362  
使它有可能写一些复杂强大的代码

00:33:15.929 --> 00:33:18.498  
用一个简明但是很有表现力的方式

00:33:19.099 --> 00:33:22.936 
我们已经看了函数和闭包
以及一点泛型函数

00:33:23.003 --> 00:33:27.274 
我想邀请Alex上台告诉你们
所有关于Swift数据类型的事

00:33:34.314 --> 00:33:35.148 
谢谢Brian

00:33:36.083 --> 00:33:38.886 
你们看到了Swift中的数据类型

00:33:39.286 --> 00:33:43.123 
现在让我们看看怎样创建
你自己的数据类型

00:33:44.525 --> 00:33:46.126 
让我们从结构开始

00:33:46.627 --> 00:33:48.595 
你创建一个像这样

00:33:48.662 --> 00:33:52.799 
你写下struct关键字
跟随的是结构的名字

00:33:52.866 --> 00:33:54.568 
矩形

00:33:56.170 --> 00:33:58.172 
然后在大括号里

00:34:00.374 --> 00:34:02.543 
你写下结构的属性

00:34:04.478 --> 00:34:06.213 
属性使用相同的语法

00:34:06.280 --> 00:34:09.382 
和你在前面见过的变量和常量一样

00:34:11.083 --> 00:34:12.652 
这里有两个属性

00:34:12.719 --> 00:34:15.656 
做为申明的一部分被赋值

00:34:15.989 --> 00:34:20.293 
所以你可以新建一个矩形
通过只写下矩形这个名字

00:34:21.027 --> 00:34:23.197 
跟随一对括号

00:34:24.197 --> 00:34:27.601 
要访问属性
你使用点号

00:34:30.137 --> 00:34:33.139 
你不需要为属性提供值

00:34:33.206 --> 00:34:35.442 
在类型申明中

00:34:35.509 --> 00:34:37.844 
实际上大部分时候你不这么做

00:34:38.277 --> 00:34:40.581 
更常见的 你只写类型

00:34:41.648 --> 00:34:44.818 
然后你在建立实例时赋值

00:34:46.520 --> 00:34:51.458 
矩形除了尺寸的另一个属性是面积

00:34:52.525 --> 00:34:54.895 
虽然你不想储存面积

00:34:55.062 --> 00:34:58.665 
你需要在每次尺寸变化时更新它

00:34:59.533 --> 00:35:01.602 
你想要的是一个属性

00:35:01.668 --> 00:35:05.172 
它的值当你需要的时候被计算出

00:35:05.639 --> 00:35:08.675 
你可以用一个被计算属性

00:35:10.077 --> 00:35:11.778 
要创建一个被计算属性

00:35:12.513 --> 00:35:17.885 
在属性的名称和类型后面
你写一个函数体

00:35:18.118 --> 00:35:21.321 
用来计算并返回

00:35:21.588 --> 00:35:23.590 
函数的当前值

00:35:24.658 --> 00:35:27.628 
虽然它是被计算的而不是被储存的

00:35:27.694 --> 00:35:30.197 
你还是可以用点号访问它

00:35:31.665 --> 00:35:33.967 
你还可以用属性做更多

00:35:34.334 --> 00:35:36.870 
你可以有设置者和监视者

00:35:38.038 --> 00:35:40.507  
你可以获得更多信息

00:35:40.574 --> 00:35:45.445  
在Swift编程语言的属性章节

00:35:48.215 --> 00:35:51.051 
就像你在结构中定义属性

00:35:51.218 --> 00:35:53.120 
你还可以定义方法

00:35:54.154 --> 00:35:57.691 
和你已经看过的函数一样的语法

00:35:59.159 --> 00:36:03.597  
和属性一样
你用点号访问方法

00:36:03.664 --> 00:36:05.132  
当你需要调用它们时

00:36:08.435 --> 00:36:12.339  
你看到几次新建矩形的语法了

00:36:12.906 --> 00:36:15.943  
我们看看它做了什么的更多细节

00:36:17.377 --> 00:36:21.815 
这看起来像调用函数因为这个括号

00:36:22.049 --> 00:36:24.351 
实际上它是在调用初始化者

00:36:25.319 --> 00:36:28.889 
我们一直在用一个特殊的初始化者

00:36:28.956 --> 00:36:31.291 
称为成员初始化者

00:36:31.358 --> 00:36:34.995 
Swift为你的结构实现

00:36:35.662 --> 00:36:37.130 
这是它看起来的样子

00:36:37.197 --> 00:36:40.033  
如果你明确的写这个初始化者

00:36:41.134 --> 00:36:43.370  
你写init关键字

00:36:43.437 --> 00:36:47.641  
然后在里面你为矩形的属性设值

00:36:48.942 --> 00:36:52.012  
注意有两个宽度

00:36:52.513 --> 00:36:54.815  
一个是属性另一个是参数

00:36:55.516 --> 00:37:00.654  
你写下self点来明确的参考属性

00:37:01.855 --> 00:37:04.424  
这就是你怎么写初始化者

00:37:06.894 --> 00:37:10.097  
矩形结构有足够多的代码

00:37:10.163 --> 00:37:13.100  
值得进行一些组织

00:37:13.166 --> 00:37:16.970  
Swift中这样做的一个方法是
使用扩展

00:37:18.372 --> 00:37:22.676 
一个扩展让你向一个已有的类型
添加功能

00:37:23.911 --> 00:37:28.682 
在Swift里你可以用扩展来分离
你的代码

00:37:29.816 --> 00:37:33.487 
核心功能可以在结构的申明中

00:37:34.588 --> 00:37:39.193 
辅助的功能可以在一个或多个
扩展中

00:37:40.427 --> 00:37:43.263 
你可以不受限地扩展你自己的类型

00:37:43.830 --> 00:37:47.768 
如果你需要你可以扩展从其他
地方来的类型

00:37:47.835 --> 00:37:51.538 
比如foundation 或者标准库

00:37:53.140 --> 00:37:56.643 
你早前看到怎么创建范型函数

00:37:56.710 --> 00:38:01.215 
在不同的类型上进行相同的操作

00:38:01.982 --> 00:38:07.554 
你还可以创建泛型结构
它包含不同类型的数据

00:38:08.255 --> 00:38:10.424 
语法看起来很相似

00:38:10.490 --> 00:38:15.863 
你仍然有泛型类型参数在名字
后面的尖括号里

00:38:16.730 --> 00:38:21.935 
这个例子把名字附加给一些种类
的元素的数组

00:38:22.970 --> 00:38:26.440 
这会是个有用的数据结构
比如

00:38:26.507 --> 00:38:31.178 
来填充一个表视图
有不同的部分有标题名

00:38:31.678 --> 00:38:35.215 
你创建一个泛型结构实例

00:38:35.282 --> 00:38:37.684 
就像另一个类型的实例

00:38:39.586 --> 00:38:43.123 
你在这看到如果你写下类型标注

00:38:44.424 --> 00:38:48.028 
棋盘游戏和质数有不同的类型

00:38:49.029 --> 00:38:53.433 
一个是字符串数组
另一个是整数数组

00:38:54.301 --> 00:38:58.739 
它们有不同的元素类型
所以它们是不同的类型

00:39:00.174 --> 00:39:02.209 
你不需要写数组

00:39:02.709 --> 00:39:06.146 
Swift自动推测是什么元素

00:39:08.182 --> 00:39:09.650 
这就是结构

00:39:11.518 --> 00:39:14.621 
在Swift中另一个数据类型是类

00:39:15.689 --> 00:39:18.392 
你在名称前写下类别关键字

00:39:18.458 --> 00:39:21.161 
但是关于结构的一切都仍然有效

00:39:21.695 --> 00:39:24.998 
属性 方法 初始化者等等

00:39:26.099 --> 00:39:29.169 
那么为什么你想要创建一个类？

00:39:30.804 --> 00:39:36.176 
一个原因是你的代码可以引用
一个类的同一个实例

00:39:36.243 --> 00:39:38.045 
从不同的地方

00:39:38.679 --> 00:39:41.982 
这和结构的行为不同

00:39:43.083 --> 00:39:46.019 
一个结构的行为像一个大的值

00:39:46.787 --> 00:39:51.058 
比如 在游戏中 你让玩家1有
一个分数

00:39:52.359 --> 00:39:58.031 
你给玩家2一个一样的分数
你有两个独立的分数

00:39:58.899 --> 00:40:03.837 
改变玩家2的分数不会改变
玩家1的分数

00:40:05.072 --> 00:40:10.477 
但是两个玩家需要引用硬盘上
的同一个文件

00:40:10.544 --> 00:40:12.446 
当他们记录他们的高分的时候

00:40:13.914 --> 00:40:17.150 
因为这是一个类
这就是你想要的行为

00:40:18.652 --> 00:40:23.991 
当玩家2得到一个新的高分
并把它记录到文件中

00:40:24.658 --> 00:40:26.960 
两个玩家都看到改变

00:40:29.062 --> 00:40:31.999 
如果你是从另一个面向对象语言
中过来

00:40:32.065 --> 00:40:35.402 
你可能习惯于写很多类

00:40:35.469 --> 00:40:40.040 
在Swift中你不需要经常写它们

00:40:41.208 --> 00:40:45.746 
任何时候你想要检查是否相等
或进行复制

00:40:46.780 --> 00:40:49.917 
你通常只需要一个值类型像是结构

00:40:51.518 --> 00:40:55.822  
要知道更多为什么以及怎么
用值类型的信息

00:40:55.889 --> 00:40:58.492  
你可以看一个很有用的演讲

00:40:59.726 --> 00:41:02.095  
另一个用类的原因是

00:41:02.162 --> 00:41:05.065  
你想从已有的类中派生一个子类

00:41:06.934 --> 00:41:09.670 
比如假设你有一个框架

00:41:09.736 --> 00:41:14.741 
给你鱼类包含一些核心的鱼的功能

00:41:15.976 --> 00:41:22.049  
你可以创建子类来添加功能
像是飞鱼可以添加飞方法

00:41:23.050 --> 00:41:27.654  
你标明这是一个子类通过写冒号鱼

00:41:28.789 --> 00:41:34.394  
子类还可以覆盖方法来提供它们
自己的实现

00:41:35.462 --> 00:41:37.664  
像抱怨鱼

00:41:37.731 --> 00:41:41.835  
它像普通鱼一样游泳
只是会先报怨

00:41:44.838 --> 00:41:49.610  
你写super.swim
来调用父类的实现

00:41:50.611 --> 00:41:53.046  
这个代码还不能被编译

00:41:54.014 --> 00:41:56.617  
当你在Swift中覆盖方法

00:41:56.683 --> 00:42:00.854  
你需能写覆写关键字来明确标明

00:42:01.455 --> 00:42:03.257  
现在代码工作

00:42:04.725 --> 00:42:08.862  
像是一个错误
偶然覆盖了一些东西

00:42:08.929 --> 00:42:14.568  
这也是一个错误
写了覆写却不覆盖任何东西

00:42:15.736 --> 00:42:20.474  
这就是说如果你拼错了一个
想要覆盖的方法的名字

00:42:20.974 --> 00:42:24.545  
Swift会在编译时告诉你这个错误

00:42:26.346 --> 00:42:29.249  
一个赛格威也可以提供初始化者

00:42:30.684 --> 00:42:35.189  
比如鱼有初始化者接收一个名字

00:42:35.889 --> 00:42:41.361  
抱怨鱼的初始化者需要名字和报怨

00:42:42.663 --> 00:42:46.900  
在初始化者中你设置初始值

00:42:46.967 --> 00:42:50.370  
为子类申明的属性

00:42:51.471 --> 00:42:53.907  
然后你调用super.init

00:42:54.808 --> 00:42:58.011  
让父类完成初始化

00:42:59.613 --> 00:43:04.017  
你可以用初始化者做更多
特别是围绕类

00:43:05.752 --> 00:43:09.389  
你可以在初始化者这一章知道更多

00:43:09.456 --> 00:43:11.425  
在Swift编程语言中

00:43:13.193 --> 00:43:15.562 
你看过了怎么用子类

00:43:15.629 --> 00:43:18.632 
让我们谈谈子类编程

00:43:20.868 --> 00:43:25.772 
继续游戏的例子
假设你有玩家基类

00:43:26.473 --> 00:43:30.511 
因为每个玩家轮流行动
你有一种方法这样做

00:43:31.411 --> 00:43:33.680 
你有两类玩家

00:43:34.348 --> 00:43:36.383 
你有人类玩家类

00:43:36.450 --> 00:43:39.887 
通过显示UI给用户来完成一轮

00:43:40.554 --> 00:43:43.190  
你有电脑玩家类

00:43:43.257 --> 00:43:46.960  
通过进行最好的合法的移动来
完成一轮

00:43:48.161 --> 00:43:53.400  
问题就是什么进入基类的实现中？

00:43:54.768 --> 00:44:00.307  
人类和电脑玩家没有共享的行为

00:44:01.008 --> 00:44:04.211 
没有共享的代码可以移出

00:44:05.145 --> 00:44:07.681 
在附近的代码

00:44:07.748 --> 00:44:12.019 
你永远都不会想要一个
玩家基类实例

00:44:12.553 --> 00:44:15.122 
所以这个方法永远都不应该被调用

00:44:16.757 --> 00:44:19.626 
这里能写的唯一合理的东西

00:44:19.693 --> 00:44:23.931  
是一些严重错误来帮助你捕获失误

00:44:23.997 --> 00:44:26.466  
在开发的早期阶段

00:44:27.534 --> 00:44:33.240  
所有玩家类在做的是描述
做为一个玩家意味着什么

00:44:33.640 --> 00:44:36.243  
每个玩家进行一轮

00:44:36.844 --> 00:44:39.847  
它是玩家的蓝图

00:44:41.181 --> 00:44:46.286  
在Swift中你用协议表达这种关系

00:44:47.321 --> 00:44:51.725  
协议规定要求像是方法和属性

00:44:52.960 --> 00:44:56.296 
他们就像接口或者抽象类

00:44:56.363 --> 00:44:58.332 
你可能在别的语言里知道

00:44:59.700 --> 00:45:03.003 
你使用protocol关键字
来创建一个

00:45:03.637 --> 00:45:08.308  
因为它描述其他类型要实现的要求

00:45:09.042 --> 00:45:11.044  
你不提供一个实现

00:45:12.779 --> 00:45:17.417  
类型通过提供那些实际来遵守协议

00:45:18.418 --> 00:45:22.456  
你通过写：Player来申明符合性

00:45:22.956 --> 00:45:25.325  
就像你对父类做的那样

00:45:26.960 --> 00:45:30.297  
这样你不再使用子类

00:45:30.364 --> 00:45:33.467  
这些方法不覆盖任何东西

00:45:34.868 --> 00:45:36.970  
你不写覆写关键字

00:45:39.406 --> 00:45:43.243  
没有理由它再是一个类

00:45:43.343 --> 00:45:44.978  
让我们把它变为结构

00:45:46.847 --> 00:45:50.384  
让我们仔细看看人类玩家

00:45:52.286 --> 00:45:56.023 
它还有一些其它的属性比如
名字和分数

00:45:56.757 --> 00:46:00.194 
如果你创建一个玩家实例
你可以打印它

00:46:02.329 --> 00:46:07.000  
你得到一个default的描述
因为标准库

00:46:07.267 --> 00:46:10.404  
可以把任何类型转化成字符串

00:46:12.306 --> 00:46:15.042  
但是如果你想要定制这个转化

00:46:15.108 --> 00:46:17.511  
来打印一个更好的描述

00:46:18.445 --> 00:46:23.450  
该标准库还有一个协议
叫CustomStringConvertible

00:46:23.984 --> 00:46:26.453  
使你提供自己的描述

00:46:27.154 --> 00:46:29.456 
这是这个协议的样子

00:46:30.090 --> 00:46:33.594 
它有一个要求
一个描述属性

00:46:34.962 --> 00:46:39.700 
任何遵守这个协议的类型
使用定制描述

00:46:40.467 --> 00:46:45.239 
你要在哪实现这个描述属性？

00:46:46.340 --> 00:46:49.710 
记住你可以整理你的代码

00:46:49.776 --> 00:46:54.982 
使用扩展
核心功能在函数申明中

00:46:55.048 --> 00:46:58.185 
附加功能在扩展中

00:46:59.186 --> 00:47:04.291 
有一个字符串转换功能是第二类

00:47:04.358 --> 00:47:08.896 
它不是核心功能
所以把它放在扩展里

00:47:09.396 --> 00:47:13.500 
这是你如何扩展一个类型
来遵守协议

00:47:14.468 --> 00:47:18.872 
你在第一行写下
“: CustomStringConvertible”

00:47:20.007 --> 00:47:24.144 
然后你在扩展体内实现要求

00:47:26.113 --> 00:47:30.417  
现在你可以调用打印
你获得定制的字符串转换

00:47:31.818 --> 00:47:36.657  
你可以在Swift里用协议和扩展
做很多

00:47:36.757 --> 00:47:39.693  
来组织你的代码并建立抽象

00:47:40.827 --> 00:47:43.864  
要知道更多信息请看

00:47:43.931 --> 00:47:47.901  
2015年的面向协议编程

00:47:49.436 --> 00:47:54.575  
那带来Swift最后的一个数据类型
枚举

00:47:55.576 --> 00:47:58.912 
你在有一个值列表时使用枚举

00:47:58.979 --> 00:48:00.881 
当你提前知道

00:48:01.582 --> 00:48:06.587 
这是一个枚举支持左或右对齐
的文本

00:48:07.588 --> 00:48:12.893 
当你用一个枚举时
你用点号来访问它的案例

00:48:14.027 --> 00:48:16.463 
这里只有两个案例

00:48:16.530 --> 00:48:19.600 
所以你把它们写在一行还是可读的

00:48:21.101 --> 00:48:25.138 
因为枚举是一个可能值的列表

00:48:25.205 --> 00:48:27.808 
经常把它和switch一起用

00:48:28.709 --> 00:48:32.212  
一个switch case
对应一个枚举案例

00:48:33.714 --> 00:48:37.751  
一遍遍写对齐有点重复

00:48:37.818 --> 00:48:39.853  
在这并不需要

00:48:40.921 --> 00:48:47.261  
switch考虑文本对齐
所以需要检查的仅有的可能值

00:48:47.461 --> 00:48:50.397  
是枚举的案例

00:48:51.164 --> 00:48:54.535  
所以你可以省略枚举名称

00:48:54.601 --> 00:48:56.803  
只用写“.left”

00:48:58.438 --> 00:49:01.742  
还要注意这里没有default

00:49:02.843 --> 00:49:05.379  
和你已经看到的原因一样

00:49:05.979 --> 00:49:10.417  
switch已经覆盖了所有可能的
对齐值

00:49:10.584 --> 00:49:14.087  
没有东西留下给default来处理

00:49:15.489 --> 00:49:18.892  
省略default有一个好处

00:49:19.493 --> 00:49:23.597  
如果你晚些回来增加一个枚举案例

00:49:23.664 --> 00:49:26.200  
但是忘记更新switch

00:49:26.266 --> 00:49:30.504  
Swift会高亮这个错误直到你添加
遗失的代码

00:49:32.673 --> 00:49:38.011  
让我们快速看一看
你能对枚举做的其他两件事

00:49:40.681 --> 00:49:44.718 
你可以给每个枚举案例关联一个值

00:49:45.652 --> 00:49:51.124 
比如对齐可以指定要用多少填充

00:49:52.793 --> 00:49:58.332  
你可以获得那个填充值
在switch case中

00:50:00.601 --> 00:50:07.441 
你也可以给每个枚举案例
一个原始值从其他类型中

00:50:07.508 --> 00:50:09.877 
比如字符串或者整数

00:50:11.578 --> 00:50:14.882  
来让你提升代码的类型安全

00:50:14.948 --> 00:50:18.752  
通过用枚举取代字符串常量

00:50:21.154 --> 00:50:24.258  
你今天下午看了很多Swift

00:50:24.758 --> 00:50:27.127  
但是没有时间展示所有的

00:50:28.028 --> 00:50:31.532  
最后一个我想展示的是错误处理

00:50:34.134 --> 00:50:39.173 
在Swift中你可以用枚举来描述
错误

00:50:40.741 --> 00:50:44.912 
你用throws关键字标记一个函数
可以抛出错误

00:50:47.047 --> 00:50:51.752 
你在必须要运行的代码块前
写defer关键字

00:50:51.818 --> 00:50:53.720 
无论是否发生错误

00:50:54.087 --> 00:50:58.258 
它都会在退出作用域前被运行

00:50:58.325 --> 00:51:00.294 
比如从一个函数返回

00:51:03.630 --> 00:51:06.633 
在调用可能抛出错误的代码前

00:51:06.700 --> 00:51:08.402 
你用try关键字标记它

00:51:09.970 --> 00:51:14.675  
你可以捕获和抛出错误
用catch和throw关键字

00:51:16.243 --> 00:51:21.582  
关于所有细节请看错误处理章节

00:51:21.648 --> 00:51:23.717  
在Swift编程语言中

00:51:25.452 --> 00:51:29.389 
你可以在这找到这本书和其他资源
的链接

00:51:31.592 --> 00:51:36.964  
有很多很好的Swift演讲
可以在这周晚些时间参加或者看视频

00:51:37.698 --> 00:51:38.532 
谢谢