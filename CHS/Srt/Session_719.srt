00:00:19.386 --> 00:00:21.788
性能和电池寿命的I/O优化

00:00:24.758 --> 00:00:25.692
大家好 欢迎

00:00:27.561 --> 00:00:31.365
我叫Kushal Dalmia
我的同事Terry Long

00:00:31.431 --> 00:00:33.800
我将为大家讲解I/O优化

00:00:33.901 --> 00:00:35.469
为性能和电池寿命

00:00:36.470 --> 00:00:39.139
在本次演讲中 我们将讲解
什么是I/O

00:00:39.806 --> 00:00:41.208
它会如何影响你的应用

00:00:41.708 --> 00:00:43.877
以及如何提高应用的性能

00:00:44.144 --> 00:00:45.913
通过提高其I/O性能

00:00:46.980 --> 00:00:47.848
我们现在开始

00:00:49.716 --> 00:00:53.120
众所周知 每年设备越变越大
越变越好

00:00:54.321 --> 00:00:58.759
屏幕分辨率增加 在过去十年
增加了16倍

00:01:00.160 --> 00:01:02.362
在相机领域也有类似提高

00:01:02.429 --> 00:01:04.864
已经可以拍摄4K HD视频

00:01:05.065 --> 00:01:08.135
还可以从我们的移动设备里
拍出令人惊艳的的高画质相片

00:01:10.137 --> 00:01:14.041
所有这些改进造就
更为丰富的媒体每天被生产

00:01:14.174 --> 00:01:15.242
和消费

00:01:17.778 --> 00:01:19.146
为了关注它们的前景

00:01:19.213 --> 00:01:22.382
我们来看看iPhone
壁纸大小的趋势

00:01:24.251 --> 00:01:27.888
如果跨越设备和时代
来看iPhone壁纸

00:01:28.188 --> 00:01:30.390
可以发现其呈指数增长

00:01:31.458 --> 00:01:34.228
iPhone 6s Plus上的
壁纸大小

00:01:34.428 --> 00:01:37.965
是对应的iPhone 3G的14倍

00:01:38.665 --> 00:01:41.368
所有手机数据都有相似的趋势

00:01:41.735 --> 00:01:43.770
我们编写和使用复杂的应用

00:01:43.837 --> 00:01:46.440
在游戏 信息和社交网络领域

00:01:47.474 --> 00:01:50.811
我们工作和存储丰富的文件 如PDF

00:01:52.379 --> 00:01:56.049
我们分享和捕捉
高品质音频和视频文件

00:01:59.486 --> 00:02:01.388
现在为了管理这种数据爆炸

00:02:01.488 --> 00:02:04.725
应用需要在系统资源利用方面
做到非常高效

00:02:05.626 --> 00:02:11.732
主要系统资源有CPU 内存和I/O

00:02:13.967 --> 00:02:17.204
关于CPU和内存 我推荐大家观看
去年的WWDC演讲

00:02:17.271 --> 00:02:19.173
“iOS和watchOS上的性能”

00:02:20.107 --> 00:02:22.009
今天我们将来讲解I/O

00:02:24.077 --> 00:02:29.283
I/O 即输入输出
是和本地文件存储进行互动的操作

00:02:29.349 --> 00:02:30.784
或和基于网络的服务器

00:02:32.553 --> 00:02:35.222
和文件系统互动的操作

00:02:35.289 --> 00:02:38.492
以及处理文件读写的操作
都被认为是一个I/O

00:02:40.727 --> 00:02:44.331
和网络服务器交流是
基于网络I/O的很好的范例

00:02:46.834 --> 00:02:49.203
I/O如此有趣的其中一个原因是

00:02:49.269 --> 00:02:52.105
在I/O技术上发生了巨大的变化

00:02:52.406 --> 00:02:54.141
性能特征上也是如此

00:02:55.809 --> 00:02:58.378
考虑一兆字节的延迟

00:02:58.445 --> 00:03:00.380
当写入最平常的I/O媒介时

00:03:00.914 --> 00:03:05.986
如SSD 硬盘和普通Wi-Fi网络

00:03:07.487 --> 00:03:09.656
你可能会注意到 同样的操作

00:03:09.723 --> 00:03:13.126
大概耗时几毫秒到几百毫秒之间

00:03:13.193 --> 00:03:15.429
根据互动的媒介不同

00:03:17.998 --> 00:03:19.566
I/O之所以如此重要的原因

00:03:19.900 --> 00:03:24.204
是应用上I/O性能直接影响用户体验

00:03:26.073 --> 00:03:28.976
应用性能的延迟时间的改变

00:03:29.042 --> 00:03:31.011
可以表现为响应问题

00:03:32.913 --> 00:03:35.182
由于I/O是系统中的共享资源

00:03:35.315 --> 00:03:38.552
你的应用的I/O性能
可能会影响整体系统性能

00:03:40.020 --> 00:03:41.622
我们一会儿将会看到

00:03:41.989 --> 00:03:44.791
I/O也会显著影响设备上的电池寿命

00:03:47.194 --> 00:03:50.430
为了帮你们了解应用上I/O使用情况

00:03:50.731 --> 00:03:52.833
我们提出了自己的I/O哲学

00:03:54.001 --> 00:03:56.503
该I/O哲学有四个主要支柱

00:03:59.006 --> 00:04:01.141
减少应用里的I/O用量

00:04:02.876 --> 00:04:05.112
用正确的线程完成这些I/O

00:04:07.181 --> 00:04:10.751
采用合适和高效API完成这些I/O

00:04:11.118 --> 00:04:14.688
最后 对应用中I/O性能测试和测量

00:04:16.223 --> 00:04:17.591
当我们通读剩下的文档时

00:04:17.658 --> 00:04:19.860
我们会了解其中每一项的更多细节

00:04:23.363 --> 00:04:26.133
提高应用中I/O效率的最好方法

00:04:26.200 --> 00:04:28.268
是减少I/O用量

00:04:30.103 --> 00:04:33.407
每一个I/O操作都和
多个硬件功能相互作用

00:04:33.473 --> 00:04:34.408
在设备上

00:04:35.876 --> 00:04:38.812
这是一个现代设备的简单框图

00:04:38.879 --> 00:04:41.915
包含部分功能及它们对电池寿命的影响

00:04:43.784 --> 00:04:47.554
当应用使用I/O时
会在CPU上运行代码

00:04:48.922 --> 00:04:50.257
访问内存

00:04:51.091 --> 00:04:53.660
最后从硬盘上读取或写入数据

00:04:55.429 --> 00:04:56.830
如果还涉及到网络

00:04:57.164 --> 00:04:59.700
基于网络收音机也参与到互动中

00:05:01.502 --> 00:05:04.104
所有这些组件联合起来的能量消耗

00:05:04.304 --> 00:05:07.341
让I/O在电池使用方面操作非常沉重

00:05:09.109 --> 00:05:12.412
由于I/O对设备电池寿命的负面影响

00:05:12.746 --> 00:05:15.516
我们来看看可以使用的最好的实践技巧

00:05:15.716 --> 00:05:17.818
来减少应用上的I/O用量

00:05:19.920 --> 00:05:21.388
首先是缓存

00:05:22.923 --> 00:05:26.426
基本理念是 建立数据的内存副本

00:05:26.627 --> 00:05:29.229
而不是每次操作都访问磁盘

00:05:31.431 --> 00:05:34.868
为了决定应用里的数据是否应该
在内存中建立缓存

00:05:35.202 --> 00:05:37.504
你应该查看数据的访问模式

00:05:39.239 --> 00:05:41.942
被频繁写入或更新的数据

00:05:42.009 --> 00:05:44.545
也许是在应用中建立缓存的好对象

00:05:46.880 --> 00:05:50.951
还有 当从磁盘中读取
需要昂贵处理步骤的数据

00:05:51.285 --> 00:05:53.153
比如 解压缩一个图片文件

00:05:53.220 --> 00:05:55.756
可能是应该缓存的一个好例子

00:05:58.158 --> 00:06:02.062
即便如此 应该注意内存和I/O平衡

00:06:03.363 --> 00:06:07.067
和I/O一样 内存也是系统中
共享和有限的资源

00:06:07.134 --> 00:06:09.236
应该格外小心用户需求

00:06:10.304 --> 00:06:12.873
如果决定在应用里建立缓存

00:06:13.473 --> 00:06:15.843
我们推荐使用NSCache API

00:06:16.543 --> 00:06:19.713
因为它们可以很好地处理内存压力条件

00:06:24.451 --> 00:06:27.087
下一个实践技巧是合并I/O

00:06:28.589 --> 00:06:29.823
基本理念是

00:06:29.890 --> 00:06:33.627
把系统里的I/O推迟到之后
更为合适的时间

00:06:35.128 --> 00:06:37.164
由于I/O技术的工作方式

00:06:37.397 --> 00:06:40.534
更大更少的I/O
对系统来说总是更为有效

00:06:42.269 --> 00:06:43.403
其中一种实现方法是

00:06:43.470 --> 00:06:46.373
是采用应用状态改变通知

00:06:46.540 --> 00:06:49.910
比如 后台应用数据来安排I/O

00:06:51.778 --> 00:06:55.449
在macOS 你可以使用
集中任务计划 API

00:06:55.516 --> 00:06:57.618
来安排维护和备份任务

00:06:57.851 --> 00:07:00.988
系统会找出运行这些任务的最佳时间

00:07:03.590 --> 00:07:05.125
想了解更多这些API的信息

00:07:05.192 --> 00:07:08.095
我们推荐观看2014年WWDC演讲

00:07:08.428 --> 00:07:10.297
“编写节能高效的代码”

00:07:12.132 --> 00:07:14.434
我们已经看过一些最佳时间技巧

00:07:14.501 --> 00:07:16.703
来减少应用中的I/O用量

00:07:17.304 --> 00:07:21.108
我想为大家介绍我们的示例应用
是Terry和我编写的

00:07:21.575 --> 00:07:23.944
在剩下的演讲中
我们会一直使用这个应用

00:07:24.011 --> 00:07:27.414
来演示最佳实践技巧的实际影响

00:07:28.649 --> 00:07:30.551
这个应用叫ImageBox

00:07:31.485 --> 00:07:35.189
ImageBox是iOS和
macOS上很棒的应用

00:07:35.722 --> 00:07:37.591
让你可以添加和浏览图片

00:07:39.960 --> 00:07:42.396
对于每一个图片 它将显示其缩略图

00:07:43.363 --> 00:07:46.099
显示相关标识 比如喜欢

00:07:47.134 --> 00:07:49.970
或者某张特定图片是否有相关注释

00:07:51.905 --> 00:07:54.942
当你点击某特定图片 将进入详细视图

00:07:55.542 --> 00:07:59.079
可以让你把图片标记为喜欢 取消喜欢

00:07:59.646 --> 00:08:00.881
或者为它添加注释

00:08:03.116 --> 00:08:04.852
我们编写了这个应用

00:08:04.918 --> 00:08:07.221
我们想要知道它是否I/O高效

00:08:07.287 --> 00:08:09.189
并且在I/O性能方面也表现良好

00:08:10.123 --> 00:08:12.159
我将来介绍可以使用的工具

00:08:12.226 --> 00:08:14.027
来决定是否在你自己的应用上使用

00:08:15.495 --> 00:08:17.531
该工具叫做Xcode调试仪表

00:08:18.565 --> 00:08:19.900
来看看它如何使用

00:08:21.101 --> 00:08:24.805
为了使用该工具
只需从Xcode UI中运行项目

00:08:26.240 --> 00:08:29.610
这会在设备或模拟器上
启动项目或应用

00:08:30.077 --> 00:08:32.145
点击Xcode调试导航器

00:08:33.947 --> 00:08:37.284
它显示了应用里的实时数据

00:08:37.351 --> 00:08:40.419
关于应用正在使用的所有系统资源

00:08:41.154 --> 00:08:45.893
有CPU 内存 能量 网络和磁盘

00:08:47.628 --> 00:08:51.398
由于我们对应用中I/O活动或
I/O性能感兴趣

00:08:51.665 --> 00:08:53.100
我们选中磁盘

00:08:54.735 --> 00:08:57.371
一旦选中 可以注意到会显示实时数据

00:08:57.437 --> 00:09:00.040
应用中发生的读取和写入数据

00:09:00.641 --> 00:09:04.511
看上去该应用每几秒都进行大量读写入

00:09:04.578 --> 00:09:06.680
即使没有用户活动时

00:09:06.847 --> 00:09:10.918
为了进一步调查
我们想进入Instrument

00:09:11.018 --> 00:09:13.287
用Instrument来找出原因

00:09:13.687 --> 00:09:16.156
继续在Instrument里
点击配置

00:09:16.623 --> 00:09:17.858
点击重启按钮

00:09:19.793 --> 00:09:22.763
如此操作时
Instruments提供了组模板

00:09:22.829 --> 00:09:25.999
你可以从中选择分析应用

00:09:27.167 --> 00:09:29.937
因为我们对应用里I/O活动感兴趣

00:09:30.070 --> 00:09:34.474
继续选择系统使用情况 然后点击选择

00:09:36.810 --> 00:09:39.313
将打开新的Instrument模板

00:09:39.479 --> 00:09:42.282
准备记录应用中的I/O活动

00:09:43.016 --> 00:09:44.718
继续开始记录

00:09:48.388 --> 00:09:50.424
注意到在详细显示区

00:09:50.624 --> 00:09:54.127
该模板显示了应用里所有的系统调用

00:09:54.194 --> 00:09:56.230
为你进行I/O操作

00:09:57.030 --> 00:10:00.934
还显示了其他有用信息 比如
实际和请求的字节数

00:10:01.001 --> 00:10:04.705
对于那些读写操作以及相关的文件路径

00:10:05.706 --> 00:10:07.574
现在我将停止记录

00:10:09.343 --> 00:10:11.912
为了找到刚才看到的大量写入

00:10:11.979 --> 00:10:13.413
在Xcode调试仪表

00:10:13.480 --> 00:10:16.884
我们按照实际读写的字节数进行排序

00:10:17.084 --> 00:10:20.020
找出大量写入 在最上方

00:10:21.955 --> 00:10:25.359
有了这个之后 可以进入扩展详细视图

00:10:25.659 --> 00:10:27.261
查看确切的回溯

00:10:27.327 --> 00:10:29.930
关于应用中执行这些I/O的代码部分

00:10:30.964 --> 00:10:33.400
看上去是应用的委托方法

00:10:35.202 --> 00:10:38.372
双击进入源代码检查器r

00:10:38.438 --> 00:10:41.408
将显示执行I/O操作的准确代码块

00:10:42.709 --> 00:10:45.078
在源代码检查器中点击Xcode图标

00:10:45.345 --> 00:10:47.114
将会回到Xcode项目

00:10:47.481 --> 00:10:50.117
并为你高亮显示执行该I/O操作代码

00:10:51.985 --> 00:10:54.588
来看看这段代码更详细的情况

00:10:55.789 --> 00:10:59.059
问题出在应用中的实现部分

00:10:59.126 --> 00:11:01.495
委托方法didFinishLaunchingApp

00:11:02.796 --> 00:11:04.131
作为实现的一部分

00:11:04.198 --> 00:11:06.466
我们新建了一个计时器
DispatchSource

00:11:07.301 --> 00:11:09.603
让它每5秒记录一次

00:11:11.271 --> 00:11:13.507
且对于该计时器作为事件处理的一部分

00:11:13.740 --> 00:11:15.475
我们写出整个数据存储

00:11:16.910 --> 00:11:19.646
我们中很多人这样写代码 因为我们想确保

00:11:19.713 --> 00:11:23.417
应用数据可以持续定期地保存

00:11:24.551 --> 00:11:27.621
然而 还有更为I/O高效的方法实现

00:11:28.789 --> 00:11:29.990
为了修改代码

00:11:30.057 --> 00:11:33.727
首先我们删除计时器的重复部分

00:11:35.362 --> 00:11:36.430
把这部分删除

00:11:37.564 --> 00:11:41.034
取而代之 新建一个方法叫
dataStoreDidChange

00:11:41.335 --> 00:11:43.804
在应用中不同的地方被调用

00:11:43.871 --> 00:11:45.772
只要数据存储发生任何变化

00:11:47.541 --> 00:11:49.076
作为该实现的一部分

00:11:49.643 --> 00:11:53.247
我们把计时器的调度源往后推15秒

00:11:54.615 --> 00:11:59.086
用这种方法
我们收集应用数据存储的所有更新

00:11:59.453 --> 00:12:02.155
往后推一段时间 合并写入

00:12:03.323 --> 00:12:04.958
当计时器最终过期时

00:12:05.259 --> 00:12:08.428
它收集了我们频繁采用的更新

00:12:08.495 --> 00:12:10.931
我们把其作为单一的I/O操作写出

00:12:12.666 --> 00:12:15.335
来看这些代码在应用中的功能

00:12:16.436 --> 00:12:20.040
再次点击Xcode UI中的
运行按钮启动应用

00:12:21.008 --> 00:12:25.445
进入调试导航仪 选择磁盘仪表
找到I/O活动

00:12:27.714 --> 00:12:31.552
可以发现应用已经不再进行那些写入了

00:12:32.152 --> 00:12:34.955
现它完全空闲 用户也没和它进行互动

00:12:35.022 --> 00:12:36.590
这就是我们的预期效果

00:12:37.558 --> 00:12:40.794
我们高效地合并了应用中I/O用量

00:12:41.195 --> 00:12:43.263
提高了I/O效率

00:12:45.566 --> 00:12:46.466
使用正确的线程

00:12:46.533 --> 00:12:50.671
在看过了一些最佳实践技巧
可以减少I/O用量之后

00:12:51.171 --> 00:12:54.875
我们来看看利用这些I/O实践的趋势

00:12:55.409 --> 00:12:57.878
我想请Terry上台为大家演讲

00:12:58.111 --> 00:12:58.946
Terry

00:13:04.518 --> 00:13:05.352
谢谢 Kushal

00:13:05.919 --> 00:13:09.823
我们刚看了一些
可以减少应用中I/O用量的好方法

00:13:09.890 --> 00:13:11.925
避免对电池寿命产生不良影响

00:13:12.860 --> 00:13:15.896
继续讲解我们的哲学的第二大支柱

00:13:16.630 --> 00:13:21.068
我会讲解一些方法 可以在应用中
有效使用线程和队列

00:13:21.435 --> 00:13:23.637
达到更好的I/O性能和效率

00:13:26.206 --> 00:13:31.011
系统中每一个线程或每一个应用
都从一个线程开始 叫做主线程

00:13:31.979 --> 00:13:35.782
该线程很特别 有几个主要功能

00:13:35.849 --> 00:13:39.186
主线程的第一个功能是处理输入

00:13:40.254 --> 00:13:42.489
如果点击应用里的一个按钮

00:13:43.156 --> 00:13:45.859
主线程负责处理该输入

00:13:46.426 --> 00:13:47.528
并作出响应

00:13:49.062 --> 00:13:52.599
此外 主线程还负责
更新界面

00:13:53.300 --> 00:13:57.638
这适用于比如绘制视图
操作布局 或动画

00:13:59.339 --> 00:14:05.779
当主线程空闲时 它随时备用
响应输入和更新用户界面

00:14:07.247 --> 00:14:09.683
但是如果在主线程上执行其他操作

00:14:10.117 --> 00:14:12.819
比如执行长任务

00:14:12.886 --> 00:14:15.856
比如昂贵的图片处理

00:14:16.423 --> 00:14:18.825
这类的工作将会一直占用主线程

00:14:19.393 --> 00:14:20.994
也就是说它不会空闲

00:14:21.061 --> 00:14:24.331
则无法响应输入或更新界面

00:14:25.866 --> 00:14:27.935
此外 我们今天关注的是

00:14:28.402 --> 00:14:30.637
应该避免在主线程上进行I/O

00:14:31.805 --> 00:14:35.609
我们已看到I/O是系统中的昂贵资源

00:14:35.943 --> 00:14:37.578
需要对其正确管理

00:14:38.979 --> 00:14:40.714
如果在主线程上进行I/O操作

00:14:41.215 --> 00:14:44.117
使用应用的用户会发现问题

00:14:45.686 --> 00:14:48.121
第一个例子是在macOS上

00:14:48.755 --> 00:14:50.390
用户可能会看到旋转光标

00:14:51.558 --> 00:14:54.194
旋转光标意味着主线程繁忙

00:14:54.695 --> 00:14:57.364
则无法和应用进行互动

00:14:58.966 --> 00:15:00.734
此外 在iOS上

00:15:01.168 --> 00:15:05.939
繁忙的主线程可能会造成
应用发生冻结或无法响应

00:15:08.408 --> 00:15:12.479
最后 在主线程上进行I/O
会造成动画出现问题

00:15:13.347 --> 00:15:16.917
比如 如果在视图表格里大幅度滚动

00:15:17.317 --> 00:15:19.987
然后在主线程上进行I/O
加载更多的数据

00:15:21.121 --> 00:15:23.857
应用在做这些操作时

00:15:24.091 --> 00:15:26.593
就无法继续显示动画

00:15:26.860 --> 00:15:28.595
就会造成诸如卡屏的问题

00:15:29.396 --> 00:15:32.132
我想再提一次
Kushal刚才指出的演讲

00:15:32.666 --> 00:15:34.601
iOS和watchOS的性能

00:15:35.335 --> 00:15:39.173
该演讲有很多关于
如何有效使用主线程的信息

00:15:41.475 --> 00:15:44.411
现在来看看ImageBox示例应用

00:15:44.645 --> 00:15:46.146
这次在macOS上运行

00:15:47.114 --> 00:15:51.318
我发现 当主集合视图想添加图片时
会产生问题

00:15:52.052 --> 00:15:53.353
来看一下

00:15:54.788 --> 00:15:56.924
首先从Xcode 点击运行按钮

00:15:58.392 --> 00:15:59.960
Xcode启动应用

00:16:00.727 --> 00:16:03.263
然后点击工具栏右边的添加按钮

00:16:05.499 --> 00:16:10.003
从打开的面板选中一张图片 点击打开

00:16:12.706 --> 00:16:15.242
如你所见 打开的面板并没有消失

00:16:15.642 --> 00:16:17.010
我们看到了旋转的光标

00:16:18.812 --> 00:16:21.982
终于 打开的面板消失了

00:16:22.916 --> 00:16:26.119
我们选中的图片显示在主集合视图中

00:16:27.621 --> 00:16:29.022
这里出了什么问题？

00:16:32.025 --> 00:16:33.327
我们已经知道

00:16:33.994 --> 00:16:36.697
旋转光标意味着主线程繁忙

00:16:36.930 --> 00:16:38.765
所以主线程上一定有操作在运行

00:16:38.832 --> 00:16:41.735
让它无法空闲

00:16:41.935 --> 00:16:44.104
所以我们无法和应用互动

00:16:44.838 --> 00:16:46.473
我们需要找出问题

00:16:46.940 --> 00:16:49.243
因此需要用到Instruments

00:16:50.577 --> 00:16:53.580
回到Xcode 可在“产品”菜单里
选择“配置”

00:16:55.182 --> 00:16:57.684
Xcode重新编译配置文件

00:16:57.818 --> 00:16:59.253
启动Instruments

00:17:00.254 --> 00:17:02.956
这次我选择Instruments里
时间分析器模板

00:17:04.290 --> 00:17:07.426
时间分析器是非常好的工具
用来观察耗费的时间

00:17:07.493 --> 00:17:09.530
每一部分代码执行时需要的

00:17:10.030 --> 00:17:12.665
所以我们可以利用它找出
为什么主线程繁忙

00:17:14.401 --> 00:17:15.602
点击选择

00:17:16.136 --> 00:17:19.806
Instruments打开
全新空白的时间分析器文件

00:17:24.444 --> 00:17:26.880
默认情况下
Instruments时间分析器

00:17:26.946 --> 00:17:30.551
只在CPU活跃执行代码时显示耗时

00:17:31.818 --> 00:17:35.556
其他诸如I/O的操作
并没有在CPU上活跃执行

00:17:36.323 --> 00:17:38.358
CPU会等待I/O结束

00:17:39.493 --> 00:17:43.764
若想在Instruments回溯中
看到此类操作

00:17:44.031 --> 00:17:46.466
首先点击“记录等待线程”选项

00:17:46.667 --> 00:17:47.868
在记录设置目录下

00:17:48.735 --> 00:17:51.038
现在Instruments也会显示耗时

00:17:51.104 --> 00:17:53.140
当我们进行其他操作时
比如等待I/O

00:17:54.241 --> 00:17:57.177
我们开始 点击Instruments中
“记录”按钮

00:18:00.013 --> 00:18:03.650
Instruments启动应用
我会做同样的操作

00:18:03.717 --> 00:18:05.385
和之前一样 来重现问题

00:18:07.254 --> 00:18:10.791
首先 点击“添加”按钮
选中一张图片 点击“打开”

00:18:12.226 --> 00:18:13.393
问题又出现了

00:18:13.527 --> 00:18:15.629
在Instruments里
点击“停止”

00:18:15.963 --> 00:18:17.564
看看问题所在

00:18:19.233 --> 00:18:22.503
在继续讲解之前 我想整理一下输出

00:18:22.903 --> 00:18:25.005
通过只关注我编写的代码

00:18:25.305 --> 00:18:26.940
而不是其他系统库

00:18:27.808 --> 00:18:30.711
要做到这点 首先 点击显示选项

00:18:30.811 --> 00:18:32.312
在Instruments右边

00:18:33.881 --> 00:18:36.350
然后点击“隐藏系统库”

00:18:37.484 --> 00:18:40.187
Instruments只显示
我编写的代码

00:18:40.521 --> 00:18:43.223
而不显示其他可能会调用的系统库

00:18:45.225 --> 00:18:48.028
现在我们来看
Instruments的主详细视图

00:18:48.529 --> 00:18:51.365
Instruments显示了
应用中所有不同线程

00:18:51.431 --> 00:18:53.834
和它们执行时不同的耗时数

00:18:54.968 --> 00:18:57.804
在本例中 我们只对主线程感兴趣

00:18:58.205 --> 00:19:00.307
所以我可以展开主线程部分

00:19:02.376 --> 00:19:03.877
找到最繁忙的栈

00:19:07.281 --> 00:19:12.052
本例中 我看到应用里有一个
打开的面板回调

00:19:12.119 --> 00:19:14.621
它在数据存储里调用一个添加方法

00:19:15.522 --> 00:19:18.926
该添加方法之后
把所有数据存储存到磁盘上

00:19:20.961 --> 00:19:25.065
Instruments显示
该存储操作耗时几乎为7秒

00:19:25.632 --> 00:19:26.834
这非常糟糕

00:19:29.136 --> 00:19:32.906
而我刚好知道该存储方法
正在写出一个很大的Plist

00:19:33.207 --> 00:19:34.842
这会让问题更为严重

00:19:36.109 --> 00:19:38.145
Kushal在之后的演讲
会提到一些方法

00:19:38.212 --> 00:19:40.681
来优化数据存储操作

00:19:40.814 --> 00:19:42.316
将使操作速度变得很快

00:19:42.683 --> 00:19:46.420
但现在 我只想关注如何解决这个问题

00:19:46.486 --> 00:19:48.689
使得无论该操作进行多久

00:19:49.223 --> 00:19:51.592
我们的应用响应度都非常高

00:19:53.160 --> 00:19:54.761
为了实现 来看一下代码

00:19:56.964 --> 00:19:58.565
这里是打开的面板回调

00:19:59.933 --> 00:20:01.201
它在等待一个响应

00:20:02.002 --> 00:20:03.871
当接受到该响应

00:20:03.937 --> 00:20:07.341
它将验证响应是否有一个
指向有效图片的URL

00:20:09.243 --> 00:20:12.980
然后它为图片的集合视图
新建一个项目

00:20:13.347 --> 00:20:14.948
并试图把它添加到数据存储

00:20:17.150 --> 00:20:18.452
如果成功了

00:20:18.852 --> 00:20:21.154
它会告诉主集合视图重新加载数据

00:20:21.755 --> 00:20:24.858
使得我们可以看见选中的图片

00:20:27.094 --> 00:20:28.262
如我们之前所见

00:20:28.529 --> 00:20:30.497
Instruments
也验证了这一点/b&gt;

00:20:30.797 --> 00:20:32.566
调用该添加方法非常昂贵

00:20:32.900 --> 00:20:34.968
因为它把所有的数据都存到磁盘

00:20:36.803 --> 00:20:38.639
看看如何进行修复

00:20:40.707 --> 00:20:43.810
回忆一下 应用有一个主线程

00:20:44.778 --> 00:20:47.080
主线程正在执行打开面板回调

00:20:48.682 --> 00:20:51.618
该回调在数据存储中调用添加方法

00:20:51.785 --> 00:20:53.754
这时我们看到旋转光标

00:20:55.622 --> 00:20:56.723
当所有操作完成

00:20:56.990 --> 00:20:58.959
才终于可以更新主集合视图

00:21:00.727 --> 00:21:02.529
这显然不是我们想要的

00:21:03.030 --> 00:21:05.599
在这整个过程中 主线程都是繁忙的

00:21:06.033 --> 00:21:09.636
我们无法和应用进行互动
也无法更新任何界面

00:21:11.939 --> 00:21:16.009
一种解决此问题的方法是
采用中央调度 即GCD

00:21:17.578 --> 00:21:19.913
利用GCD 可以新建调度队列

00:21:21.448 --> 00:21:22.649
调度队列

00:21:22.716 --> 00:21:25.152
是在主线程上同时运行代码的方法

00:21:26.186 --> 00:21:30.524
可以把昂贵的I/O相关操作
移动到该队列中

00:21:31.024 --> 00:21:32.392
让主线程空闲

00:21:33.560 --> 00:21:36.396
为了实现 我们可以
在该队列上调用async方法

00:21:36.797 --> 00:21:38.298
然后把昂贵的操作推入

00:21:38.799 --> 00:21:40.868
队列而不是主线程

00:21:43.403 --> 00:21:46.874
最后 由于UI相关操作
必须要返回主线程

00:21:47.808 --> 00:21:52.079
我们可以异步调度返回
最终更新集合视图

00:21:54.414 --> 00:21:56.016
现在 正是我们想要的

00:21:57.417 --> 00:22:00.521
昂贵的I/O操作正另一个队列中进行

00:22:00.921 --> 00:22:02.723
因此主线程空闲

00:22:02.789 --> 00:22:05.292
也就是说我们可以跟应用进行互动

00:22:05.359 --> 00:22:06.393
并继续使用

00:22:08.028 --> 00:22:10.697
来看看在代码中实现是什么样子

00:22:12.833 --> 00:22:15.302
我还使用了之前同样的
openPanel回调

00:22:16.336 --> 00:22:20.541
首先新建GCD调度队列

00:22:21.074 --> 00:22:22.543
并提供一个描述标签

00:22:24.111 --> 00:22:25.846
本例中 我建立了一个队列

00:22:25.913 --> 00:22:28.515
可以重用所有数据存储操作

00:22:30.617 --> 00:22:32.486
接下来 把昂贵的操作

00:22:32.553 --> 00:22:34.555
当添加图片时 移动到这个队列

00:22:35.022 --> 00:22:39.593
在调度队列中
把代码块提供给async方法

00:22:42.729 --> 00:22:47.868
最后 要更新UI时 可以调用
dispatchqueue.main.async

00:22:48.769 --> 00:22:51.772
传入包含所有UI相关操作的代码块

00:22:54.374 --> 00:22:56.443
完成之后 来看结果

00:22:56.510 --> 00:22:58.779
如果在Xcode里重新编译运行

00:23:00.080 --> 00:23:01.615
首先点击“运行”按钮

00:23:03.183 --> 00:23:04.785
等待应用启动

00:23:05.352 --> 00:23:06.920
再次尝试添加图片操作

00:23:08.121 --> 00:23:11.425
点击“添加”按钮
从打开面板上选中一张图片

00:23:12.392 --> 00:23:13.360
点击“打开”

00:23:14.962 --> 00:23:17.965
可以看到 打开面板立即消失

00:23:18.298 --> 00:23:20.667
我们可以继续和应用进行互动

00:23:20.934 --> 00:23:22.603
添加更多的图片

00:23:23.904 --> 00:23:27.241
你还会发现 在主视图上
我添加了一些占位图片

00:23:27.307 --> 00:23:30.744
这只是表示 我们正在处理该数据

00:23:30.811 --> 00:23:31.945
并存到磁盘

00:23:33.413 --> 00:23:35.916
当所有数据完成添加和存储

00:23:36.517 --> 00:23:38.785
所有的图片都会显示在主集合视图

00:23:38.952 --> 00:23:42.389
在整个过程中 主线程都是空闲

00:23:42.689 --> 00:23:44.958
也就是说应用响应极为迅速

00:23:45.626 --> 00:23:46.960
这个结果正是我们想要的

00:23:49.563 --> 00:23:53.233
现在我们把操作从主线程移到
调度队列中

00:23:53.567 --> 00:23:57.004
应该考虑告诉系统该操作的内容

00:23:57.070 --> 00:23:59.406
使系统可以为我们管理资源

00:24:00.407 --> 00:24:03.577
为了实现 可以采用一种叫
“服务质量”的方法

00:24:05.112 --> 00:24:07.814
服务质量是一种方法 可以告诉系统

00:24:07.881 --> 00:24:09.616
正在执行的操作的内容

00:24:09.983 --> 00:24:13.954
使系统可以正确地管理资源
比如CPU或I/O

00:24:16.356 --> 00:24:17.858
系统管理这些资源

00:24:18.125 --> 00:24:20.527
在系统不同的运行中进程之间

00:24:20.761 --> 00:24:22.896
以及应用内部不同的线程之间

00:24:24.831 --> 00:24:26.667
当使用服务质量时

00:24:26.900 --> 00:24:30.370
请记住正在执行的工作的三个属性

00:24:31.538 --> 00:24:34.141
可见性 重要性和期待值

00:24:35.776 --> 00:24:37.144
问问自己三个问题

00:24:38.412 --> 00:24:41.949
正在执行的工作
是否对使用应用的用户可见？

00:24:43.817 --> 00:24:46.286
其次 该工作的重要性是什么？

00:24:47.087 --> 00:24:51.291
该工作是否必须完成
在别人可以继续使用应用之前？

00:24:52.726 --> 00:24:56.263
最后 该工作预计需要多久

00:24:56.930 --> 00:25:01.935
是否是立即发生的
还是估计需要很长时间的？

00:25:03.904 --> 00:25:07.774
在继续之前 我想推荐
去年WWDC上的一个演讲

00:25:08.075 --> 00:25:10.978
叫作 用GCD建立响应式
和高效的应用

00:25:11.645 --> 00:25:14.481
该演讲讲解了很多GCD的细节

00:25:14.748 --> 00:25:16.283
以及如何使用服务质量

00:25:16.550 --> 00:25:18.519
我大力推荐大家观看

00:25:20.988 --> 00:25:24.191
当我们思考完这三个属性

00:25:24.658 --> 00:25:28.095
我们准备从四个服务质量类里选择一个

00:25:29.796 --> 00:25:31.331
第一个服务质量类

00:25:31.598 --> 00:25:32.766
是用户互动

00:25:34.001 --> 00:25:36.703
用户互动被指派给主线程

00:25:37.671 --> 00:25:40.741
为了完成比如响应输入和动画的操作

00:25:42.776 --> 00:25:45.913
所有其他和主线程异步发生的操作

00:25:46.246 --> 00:25:49.750
都应该使用其他三个服务质量类之一

00:25:50.951 --> 00:25:53.687
其中第一个是用户启动

00:25:55.055 --> 00:25:58.392
用户启动工作对应用用户可见

00:25:58.458 --> 00:26:01.028
用户期望得到立竿见影的效果

00:26:01.595 --> 00:26:03.730
用户可能也需要该工作结束

00:26:04.064 --> 00:26:06.800
在他们可以继续与应用互动之前

00:26:07.734 --> 00:26:09.002
一个好例子是

00:26:09.069 --> 00:26:12.039
如果我点击一个按钮 切换到新视图

00:26:12.606 --> 00:26:15.309
可能需要在不同的队列中加载资源

00:26:15.676 --> 00:26:17.010
为了显示该视图

00:26:17.511 --> 00:26:19.913
该工作应该在用户启动中进行

00:26:21.648 --> 00:26:23.917
服务类的第三个质量是实用工具

00:26:25.085 --> 00:26:27.855
实用工具服务质量通常和

00:26:27.921 --> 00:26:31.291
有进度条或其他活动显示器的工作相关

00:26:32.159 --> 00:26:34.461
该工作通常耗费很长的时间

00:26:35.362 --> 00:26:38.532
它也对应用用户可见

00:26:39.399 --> 00:26:41.335
这方面一个很好的例子是渲染电影

00:26:41.869 --> 00:26:44.538
它不会阻挡任何人

00:26:44.605 --> 00:26:46.607
继续使用你的应用

00:26:46.773 --> 00:26:49.309
但是它也耗费很长的时间才能完成

00:26:50.911 --> 00:26:53.313
最后一个服务质量类是后台

00:26:54.047 --> 00:26:57.050
后台操作对用户不可见

00:26:57.918 --> 00:27:00.354
其实 用户甚至根本不知道它正在进行

00:27:01.288 --> 00:27:03.290
这方面的一个好例子就是索引

00:27:03.991 --> 00:27:06.760
索引通常对应用性能十分重要

00:27:07.461 --> 00:27:10.764
但一般用户不会注意到

00:27:12.866 --> 00:27:16.003
所有这些服务质量类都很重要

00:27:16.770 --> 00:27:19.640
因为当你选择服务质量类

00:27:19.706 --> 00:27:22.543
它会帮助通知系统该如何管理资源

00:27:22.976 --> 00:27:26.880
使不太重要的工作 如后台操作和索引

00:27:27.181 --> 00:27:30.551
不会消极影响重要的工作 如动画

00:27:31.051 --> 00:27:33.887
即使该工作在不同的进程上进行

00:27:36.056 --> 00:27:38.926
当选择了一个服务质量类时

00:27:39.426 --> 00:27:40.527
有两种方法

00:27:40.594 --> 00:27:43.564
可以在应用中指定服务质量

00:27:44.298 --> 00:27:48.368
第一种方法是提供一个可选QOS参数

00:27:48.435 --> 00:27:50.404
给调度队列的async方法

00:27:51.505 --> 00:27:54.508
本例中 我指定了qos:.background

00:27:55.576 --> 00:27:58.912
也就是说当提供的代码块异步运行时

00:27:59.446 --> 00:28:01.748
它将使用后台服务质量

00:28:03.517 --> 00:28:07.487
此外 若正使用操作队列或操作API

00:28:07.955 --> 00:28:11.291
这两者都有一个服务质量属性
可以对其进行设置

00:28:11.358 --> 00:28:12.226
比如实用工具

00:28:15.863 --> 00:28:18.031
现在我们已经初步了解服务质量

00:28:18.098 --> 00:28:19.566
以及如何指定

00:28:19.766 --> 00:28:21.869
让我们回到ImageBox应用

00:28:22.135 --> 00:28:25.706
看能否为添加图片选择合适的服务质量

00:28:27.040 --> 00:28:30.077
为了实现这一点 我们可以思考
这项工作的三个属性

00:28:30.377 --> 00:28:33.514
可见性 重要性和期望值

00:28:35.516 --> 00:28:37.751
添加属性是可见的操作

00:28:37.818 --> 00:28:39.386
对应用用户来说

00:28:40.587 --> 00:28:43.156
但它不一定需要完成

00:28:43.457 --> 00:28:45.292
在我们可以继续做其他事之前

00:28:45.359 --> 00:28:47.928
比如浏览图片或添加更多图片

00:28:49.563 --> 00:28:52.466
此外 因为还显示了占位图片

00:28:52.799 --> 00:28:55.269
我们给出了指示 该操作

00:28:55.335 --> 00:28:57.237
可能会耗费较长时间

00:28:58.772 --> 00:29:01.842
出于以上种种原因 服务质量

00:29:02.109 --> 00:29:04.011
可能是该项工作合适的选择

00:29:07.114 --> 00:29:09.950
现在我们知道了一些方法
可以移动昂贵工作

00:29:10.117 --> 00:29:14.154
比如I/O 让它们离开主线程
进入另一个调度队列

00:29:14.621 --> 00:29:17.658
以及如何利用服务质量指定该工作内容

00:29:18.559 --> 00:29:21.495
让我们来看哲学的第三支柱

00:29:22.229 --> 00:29:24.064
采用适当的API

00:29:25.332 --> 00:29:29.069
首先我要提到的就是 资产目录

00:29:30.938 --> 00:29:33.307
如果你还不知道 资产目录是一种方法

00:29:33.373 --> 00:29:36.944
可以简单地管理应用里的资源 如图片

00:29:37.578 --> 00:29:40.480
它们被用来存储
比如应用图标和启动图片

00:29:41.181 --> 00:29:43.483
以及所支持的不同设备上的所有图片

00:29:43.550 --> 00:29:47.588
以及比例系数
比如retina或非retina

00:29:49.256 --> 00:29:50.757
用SpriteKit编写游戏时

00:29:50.824 --> 00:29:54.294
资产目录也用来编写
Sprite Atlases

00:29:55.562 --> 00:29:58.265
可以利用资产目录来标注资源

00:29:58.465 --> 00:30:00.567
以服务按需资源功能

00:30:02.436 --> 00:30:04.972
另一个使用资产目录的例子是

00:30:05.038 --> 00:30:07.975
在watch complications里存储资源

00:30:10.244 --> 00:30:12.813
为什么资产目录对I/O来说很棒？

00:30:14.481 --> 00:30:17.684
资产目录有一些很棒的存储效率性质

00:30:19.052 --> 00:30:22.422
首先 因为资产目录存储所有图片

00:30:22.489 --> 00:30:24.091
用同一种优化格式

00:30:24.391 --> 00:30:26.593
而不是许多单个文件

00:30:27.928 --> 00:30:31.131
你可以通过使用资产目录
得到较低的磁盘占用

00:30:33.267 --> 00:30:36.436
此外 通过iOS上的
如应用切片等功能

00:30:37.004 --> 00:30:39.206
当从App Store下载应用时

00:30:39.640 --> 00:30:41.875
它将利用资产目中的元数据

00:30:42.176 --> 00:30:45.445
决定该下载什么资源到设备上

00:30:46.680 --> 00:30:49.316
比如
若我下载一个应用到iPhone

00:30:50.083 --> 00:30:52.753
App Store知道
不需要下载任何资源

00:30:52.819 --> 00:30:56.557
准备给iPad或其他
不同屏幕分辨率的iPhone的

00:30:56.924 --> 00:30:59.126
这会在设备上省下不少空间

00:31:01.461 --> 00:31:04.631
此外 资产目录对性能也很有帮助

00:31:05.566 --> 00:31:08.135
因为它们存储用的优化格式

00:31:08.569 --> 00:31:09.870
图片加载将变得更快

00:31:11.171 --> 00:31:14.141
如果利用它们为游戏
编写Sprite Atlases

00:31:15.142 --> 00:31:18.579
由于用户可以很好地管理
一个大一点的资源

00:31:18.812 --> 00:31:20.781
而不是很多小的资源

00:31:21.415 --> 00:31:24.351
这些Sprite Atlases
可以加快纹理渲染时间

00:31:25.986 --> 00:31:29.022
最后 如果使用资产目录

00:31:29.356 --> 00:31:31.391
在运行macOS的硬盘机上

00:31:32.326 --> 00:31:34.228
还可以加快应用的启动时间

00:31:35.362 --> 00:31:38.665
实际上 我们看过高达百分之十的提高

00:31:38.832 --> 00:31:43.103
在这些机器上的应用启动时间
只需要切换到资产目录

00:31:45.772 --> 00:31:49.443
你可能会认为
要得到这么大的性能提高

00:31:49.810 --> 00:31:53.280
切换到资产目录一定很难
或很耗费时间

00:31:54.014 --> 00:31:55.883
而事实上 如果已经使用了

00:31:55.949 --> 00:31:58.852
标准NS图片和基于UI图片的API

00:31:59.286 --> 00:32:01.321
切换到资产目录很简单

00:32:01.889 --> 00:32:04.658
现在我想为大家
用一个示例项目来演示

00:32:06.293 --> 00:32:09.363
这里有一个还没采用资产目录的项目

00:32:10.430 --> 00:32:15.068
要开始 首先可从文件菜单选择新文件

00:32:17.237 --> 00:32:23.977
然后从资源类别 选择资产目录
点击下一步

00:32:25.946 --> 00:32:27.748
Xcode新建了一个 抱歉

00:32:29.049 --> 00:32:32.386
系统提示时 为资产目录
添加一个名称和地址

00:32:33.153 --> 00:32:34.121
然后点击新建

00:32:34.788 --> 00:32:38.759
现在Xcode为项目新建了
一个空白的资产目录

00:32:41.094 --> 00:32:43.163
要移动所有已存资产

00:32:43.230 --> 00:32:45.566
从项目到该新资产目录

00:32:46.533 --> 00:32:48.869
首先打开屏幕底部的添加菜单

00:32:48.936 --> 00:32:50.504
选择“从项目导入”

00:32:52.639 --> 00:32:56.009
Xcode会显示项目中所有图片列表

00:32:56.577 --> 00:32:57.845
点击“导入”

00:32:58.645 --> 00:33:02.049
它会把所有这些图片都移到
全新的空白资产目录中

00:33:02.683 --> 00:33:04.351
Xcode自动找出

00:33:04.585 --> 00:33:07.621
哪些图片为哪些设备准备
以及以什么比例系数

00:33:09.323 --> 00:33:14.061
现在当重新编译应用时
它将使用该全新资产目录

00:33:14.628 --> 00:33:15.462
就这样

00:33:16.063 --> 00:33:17.197
用了不到一分钟

00:33:17.497 --> 00:33:19.867
并且不用修改任何一行代码

00:33:20.467 --> 00:33:22.703
真的很简单 所以我强烈鼓励

00:33:22.769 --> 00:33:26.039
大家采用资产目录 就在今天
如果你还没用

00:33:28.509 --> 00:33:31.011
关于资产目录 我还想提一点

00:33:31.078 --> 00:33:34.214
今年有一个新的功能是 图片压缩

00:33:36.049 --> 00:33:39.152
默认情况下 资产目录的图片
是无损画质

00:33:40.354 --> 00:33:41.522
但今年新的改变是

00:33:41.588 --> 00:33:45.292
可以选择一种有损图片压缩格式

00:33:46.760 --> 00:33:49.429
这些格式拥有硬件快速解压

00:33:49.830 --> 00:33:50.931
所以非常快

00:33:51.899 --> 00:33:53.700
因为有了这些压缩格式

00:33:53.967 --> 00:33:55.936
可以降低内存占用

00:33:57.504 --> 00:33:59.573
如果应用中有很多资产

00:34:00.340 --> 00:34:03.377
会在潜在内存和空间节省方面受益良多

00:34:03.443 --> 00:34:04.745
通过使用图片压缩

00:34:06.280 --> 00:34:08.014
来看看如何使用图片压缩

00:34:08.382 --> 00:34:11.652
回到刚转化到资产目录的项目

00:34:13.187 --> 00:34:15.322
首先 点击目录里的一张图片

00:34:16.857 --> 00:34:19.693
打开右边的实用工具侧栏

00:34:21.128 --> 00:34:23.096
点击属性检查器

00:34:24.565 --> 00:34:27.134
Xcode新包含了一个压缩弹出菜单

00:34:28.202 --> 00:34:29.303
选中它时

00:34:29.735 --> 00:34:32.706
它会显示所有可用的图片压缩格式

00:34:34.842 --> 00:34:37.411
本例中 我选择自动有损

00:34:37.777 --> 00:34:40.880
让Xcode为我选择一个好格式

00:34:43.417 --> 00:34:47.420
这是关于如何在应用中
利用资产目录的一点介绍

00:34:47.487 --> 00:34:50.389
采用它们 使用新的图片压缩功能

00:34:51.792 --> 00:34:53.627
现在我把讲台还给Kushal

00:34:54.127 --> 00:34:56.396
他将为大家讲解其他更多的API

00:34:56.463 --> 00:34:58.632
可以用来存储数据

00:35:06.240 --> 00:35:07.074
谢谢 Terry

00:35:07.574 --> 00:35:09.843
资产目录是既简单又高效的方法

00:35:09.910 --> 00:35:11.278
来管理应用中的资产

00:35:12.679 --> 00:35:14.715
我们很多人还会想到的另一件事

00:35:14.781 --> 00:35:17.918
是应用数据在设备上如何存储
和存储位置

00:35:20.153 --> 00:35:22.890
我们很多人对序列数据格式很熟悉

00:35:22.956 --> 00:35:25.659
如 Plists XML和JSON

00:35:26.860 --> 00:35:28.795
这些数据格式流行的原因

00:35:29.062 --> 00:35:31.331
是因为它们简单好用

00:35:31.865 --> 00:35:35.002
而且它们作为数据交换格式也流行多年

00:35:35.335 --> 00:35:36.870
在很多基于网络的服务中

00:35:38.639 --> 00:35:41.842
这些数据格式对少量只读数据很有用

00:35:41.909 --> 00:35:44.878
比如Info.plist文件中的
配置信息

00:35:46.146 --> 00:35:48.282
然而 它们不是数据库

00:35:49.349 --> 00:35:51.418
而它们不是数据库的最大原因

00:35:51.485 --> 00:35:53.420
是这些文件的微小更新

00:35:53.487 --> 00:35:56.356
都会导致整个数据文件写出到磁盘上

00:35:56.557 --> 00:35:58.425
这非常影响I/O效率

00:35:59.693 --> 00:36:01.195
为了所有数据的存储需要

00:36:01.395 --> 00:36:05.065
建议使用Apple SQLite
数据库框架的核心数据

00:36:07.234 --> 00:36:11.905
核心数据是Cocoa应用开发框架

00:36:12.172 --> 00:36:13.907
用于管理应用数据

00:36:17.644 --> 00:36:21.648
它将通过采用SQLite作为
后备存储来处理数据持久化

00:36:23.450 --> 00:36:28.422
它自动管理对象 对象图形
和对象之间的关系

00:36:28.956 --> 00:36:32.092
让你更简单高效地管理数据

00:36:34.228 --> 00:36:35.696
它还进行修改跟踪

00:36:35.762 --> 00:36:38.899
可以让你在数据模型中
进行撤销和恢复操作

00:36:40.968 --> 00:36:44.037
核心数据完全集合在Xcode工具链

00:36:44.104 --> 00:36:48.275
因此可以建立和可视化数据模型
直接从Xcode UI

00:36:51.545 --> 00:36:56.416
现在我们知道这个优秀的工具和框架
可以用来设计或编写数据模型

00:36:56.717 --> 00:36:58.952
让我们思考该如何设计数据模型

00:37:00.053 --> 00:37:04.458
最好的方法是把数据模型
基于应用的UI需求

00:37:05.993 --> 00:37:07.227
回到ImageBox

00:37:07.294 --> 00:37:09.630
它到现在一直使用巨大的Plist

00:37:09.696 --> 00:37:11.899
来写出所有文件和所有图片

00:37:11.965 --> 00:37:13.901
和应用相关的

00:37:14.902 --> 00:37:16.870
现在用核心数据模型来替换它

00:37:18.405 --> 00:37:22.075
仔细思考该应用
ImageBox有两个实体

00:37:23.010 --> 00:37:25.913
第一个是集合视图里的项目列表

00:37:27.047 --> 00:37:30.050
第二个是其中每一项的相关注释

00:37:31.151 --> 00:37:33.520
我们来把它们放入各自的一张表里

00:37:35.956 --> 00:37:37.558
第一张表是BoxItem

00:37:37.624 --> 00:37:40.160
表示集合视图里的某些特定项目

00:37:40.494 --> 00:37:43.397
第二张表是注释 表示注释本身

00:37:44.464 --> 00:37:46.567
BoxItem表格含有一个布尔项

00:37:46.767 --> 00:37:49.236
表示图片是喜欢还是不喜欢

00:37:49.870 --> 00:37:55.309
还含有全分辨率图片 你想表示的图片

00:37:56.643 --> 00:38:00.981
Notes表包含BoxItem里
所有相关注释的主体

00:38:01.315 --> 00:38:04.651
我们把这两张表用
简单的一对多关系连接起来

00:38:06.587 --> 00:38:10.290
当使用该数据模型时
看看应用的性能表现

00:38:10.357 --> 00:38:13.093
我们发现应用启动性能非常慢

00:38:14.127 --> 00:38:15.929
我们用Instruments
调查原因

00:38:16.230 --> 00:38:18.832
发现应用耗费了绝大部分时间

00:38:18.899 --> 00:38:21.401
在启动面板上获取核心数据模型

00:38:22.536 --> 00:38:25.272
所以我们需要查看应用启动性能

00:38:25.506 --> 00:38:26.840
从核心数据的角度

00:38:27.875 --> 00:38:30.544
幸运的是核心数据让我们做到这一点

00:38:31.545 --> 00:38:33.580
它有一个工具集合 帮助你调查

00:38:33.647 --> 00:38:35.582
核心数据运行情况

00:38:36.783 --> 00:38:40.020
比如 你可在应用上设置一个启动参数

00:38:40.087 --> 00:38:43.023
即com.Apple.CoreData.SQLDebug

00:38:43.090 --> 00:38:46.593
带着速度级别
让你观察核心数据是如何

00:38:46.660 --> 00:38:48.395
和其SQLite后备存储进行互动的

00:38:50.364 --> 00:38:54.501
核心数据Instruments模板
让你观察任何模式

00:38:54.568 --> 00:38:56.937
关于获取和加载太多的数据

00:38:59.640 --> 00:39:03.210
最后 SQLite查询分析工具的
标准集合

00:39:03.377 --> 00:39:05.546
比如 解释查询可用

00:39:05.679 --> 00:39:07.848
让你更深入到某个特定查询

00:39:07.915 --> 00:39:09.249
查看其性能

00:39:11.652 --> 00:39:13.086
想了解这些工具更详细信息

00:39:13.320 --> 00:39:16.356
我推荐大家查看去年WWDC文件

00:39:16.423 --> 00:39:17.891
“核心数据的全新功能”

00:39:19.426 --> 00:39:21.528
我们有了这些工具 来使用其中一个

00:39:21.595 --> 00:39:23.597
找到数据模型的问题

00:39:25.032 --> 00:39:27.301
为了实现这一点 点击项目

00:39:28.135 --> 00:39:29.169
点击编辑方案

00:39:36.310 --> 00:39:39.279
在打开的窗口中 选中参数面板

00:39:41.682 --> 00:39:45.986
添加一个新参数
com.Apple.CoreData.SQLDebug

00:39:46.053 --> 00:39:47.921
速度级别选择最高3

00:39:53.694 --> 00:39:56.597
完成后 继续点击关闭

00:39:58.966 --> 00:40:01.702
现在我们从Xcode UI启动应用

00:40:04.004 --> 00:40:07.674
这样做将重编译项目加载并启动应用

00:40:10.077 --> 00:40:13.013
如你所见 控制台显示了各种日志

00:40:13.080 --> 00:40:16.350
关于数据模型性能的核心数据

00:40:17.584 --> 00:40:18.785
还会注意到的另个地方

00:40:18.852 --> 00:40:21.088
是该应用用了几秒的时间启动

00:40:21.154 --> 00:40:22.956
现在还没有结束启动

00:40:25.959 --> 00:40:29.062
在日志输出中 我们看到更多核心数据

00:40:29.596 --> 00:40:31.398
终于 应用启动完成

00:40:33.066 --> 00:40:36.270
回到Xcode UI
你可以深入挖掘所有日志

00:40:36.336 --> 00:40:38.572
找出数据模型的问题所在

00:40:39.206 --> 00:40:41.408
让我们继续 在应用中实践一下

00:40:44.044 --> 00:40:45.846
你在这里看到的最开始的日志之一

00:40:45.913 --> 00:40:48.649
是核心数据对所有行进行读取

00:40:48.882 --> 00:40:52.319
从SQLite数据库
在BoxItem表格

00:40:52.386 --> 00:40:54.421
这是我们想要的

00:40:55.889 --> 00:41:00.060
然而 下一个日志告诉我们
该读取操作耗费了大概9秒

00:41:00.661 --> 00:41:01.595
这非常糟糕

00:41:01.662 --> 00:41:04.731
是应用启动速度慢的最大原因

00:41:06.366 --> 00:41:09.903
回到之前执行读取所有这些数据的查询

00:41:10.137 --> 00:41:11.238
会注意到一点

00:41:11.471 --> 00:41:13.507
我们在读取全像素图片

00:41:13.574 --> 00:41:15.876
对于BoxItem表格的每一项

00:41:16.176 --> 00:41:19.079
尽管在启动屏幕上显示的只是缩略图

00:41:20.914 --> 00:41:24.918
继续 我们还发现
核心数据在进行一个合并操作

00:41:24.985 --> 00:41:27.421
在BoxItem表和Notes表间

00:41:27.654 --> 00:41:30.157
在从BoxItem表里读取每一项时

00:41:31.258 --> 00:41:32.593
这么做的原因是

00:41:32.659 --> 00:41:34.561
因为是一对多的关系

00:41:34.628 --> 00:41:35.963
在这两个实体之间

00:41:36.463 --> 00:41:38.999
而且我们需要
在启动屏幕上显示一个UI批处理

00:41:39.066 --> 00:41:41.935
来表示BoxItem是否有相关注释

00:41:44.104 --> 00:41:46.139
让我们继续修改数据模型

00:41:48.008 --> 00:41:51.612
首先要修改的是避免两张表的合并操作

00:41:52.613 --> 00:41:54.948
核心数据又做了合并操作的原因

00:41:55.015 --> 00:41:58.218
是因为我们需要显示UI

00:41:58.285 --> 00:42:00.521
对于BoxItem的注释是否出现

00:42:01.989 --> 00:42:03.090
所以为了改进该模型

00:42:03.156 --> 00:42:05.926
可以简单地在
BoxItem表里添加一个字段

00:42:05.993 --> 00:42:07.394
叫notesPresent

00:42:08.428 --> 00:42:12.799
该特定字段False值存在与否

00:42:12.866 --> 00:42:16.236
告诉我们是否需要
在启动屏幕上加入UI批处理

00:42:18.872 --> 00:42:20.474
数据模型的下一个问题

00:42:20.707 --> 00:42:22.809
是我们读取的是全像素图片

00:42:22.876 --> 00:42:23.844
在启动屏幕上

00:42:24.811 --> 00:42:26.046
让我们来修复它

00:42:26.880 --> 00:42:29.082
我们把图片数据替换为缩略图数据

00:42:29.449 --> 00:42:31.752
不再把全像素图片数据移动到

00:42:31.818 --> 00:42:33.453
它本身的表格

00:42:33.887 --> 00:42:36.890
而是把这两张表通过
一个简单的一对一关系连接起来

00:42:38.759 --> 00:42:42.095
如很多人知道的那样
这些图片会变得很大

00:42:42.863 --> 00:42:45.132
可能会是个好主意 来把这些图片

00:42:45.199 --> 00:42:47.234
作为单独的文件存储在文件系统

00:42:47.301 --> 00:42:49.570
而不是把它们放入SQLite数据库

00:42:51.004 --> 00:42:53.006
所以我们将把全像素图片

00:42:53.073 --> 00:42:56.944
作为数据库本身的一部分
取代为图片URL

00:42:57.010 --> 00:42:59.046
并把图片直接存在磁盘上

00:43:00.747 --> 00:43:04.218
现在来看看应用的启动性能
在修改完之后

00:43:05.352 --> 00:43:07.354
从Xcode UI运行项目

00:43:07.421 --> 00:43:11.792
采用新的数据模型 编译 启动

00:43:15.229 --> 00:43:16.096
如你所见

00:43:16.163 --> 00:43:18.565
应用启动速度快了四到五倍

00:43:18.632 --> 00:43:20.100
只是修改了数据模型

00:43:21.034 --> 00:43:23.136
所以让你的数据模型基于UI需求

00:43:23.203 --> 00:43:26.707
可以明显影响应用的运行和整体性能

00:43:29.776 --> 00:43:32.613
我们已经讲解了减少并优化

00:43:32.679 --> 00:43:34.581
应用I/O用量的方法

00:43:34.882 --> 00:43:37.951
我们接下来讲解如何测试I/O性能

00:43:40.420 --> 00:43:44.091
其中一点建议是在不同设备上测试应用

00:43:45.259 --> 00:43:47.694
如果应用发生改变 在多个平台上

00:43:47.961 --> 00:43:50.297
将会是一个好方法 测试你的应用

00:43:50.364 --> 00:43:53.033
在不同的设备 在所有这些平台上

00:43:54.034 --> 00:43:56.069
即使应用只在一个平台上发生改变

00:43:56.270 --> 00:43:58.972
跨代测试也是一个好方法

00:43:59.039 --> 00:44:01.241
因为I/O特性有很大不同

00:44:04.411 --> 00:44:05.646
另一个可能改变的部分

00:44:05.712 --> 00:44:08.682
在你的环境 和应用用户的环境之间

00:44:08.749 --> 00:44:10.250
是网络条件

00:44:10.851 --> 00:44:12.853
为了帮你测试网络条件

00:44:12.920 --> 00:44:14.688
或者最坏情况的网络条件

00:44:15.055 --> 00:44:17.357
我们提供了一个工具
叫做网络连接调节器

00:44:19.193 --> 00:44:21.161
打开网络连接调节器的方法是

00:44:21.228 --> 00:44:22.229
打开设置应用

00:44:24.932 --> 00:44:28.001
滚动到最底部 找到开发者设置

00:44:31.305 --> 00:44:34.074
点击开发者设置 进入这个菜单

00:44:35.275 --> 00:44:37.911
可以看到在这里 是网络连接调节器

00:44:38.612 --> 00:44:41.348
点击 打开这个菜单

00:44:41.415 --> 00:44:44.518
显示了可安装在设备上的各种配置文件

00:44:45.185 --> 00:44:50.591
有3G 高延迟DNS
以及我最喜欢的 非常糟糕的网络

00:44:52.559 --> 00:44:55.429
让我们来看看使用它的情况
选中“非常糟糕的网络”

00:44:55.896 --> 00:44:58.599
用上方的滑动按钮开启它

00:45:00.467 --> 00:45:01.301
就这样

00:45:01.568 --> 00:45:04.238
现在你的设备会表现的
好像处于非常糟糕的网络中

00:45:04.304 --> 00:45:06.340
你可以这样进行测试

00:45:09.176 --> 00:45:12.679
另一个需要记住的事实是
I/O是系统中的共享资源

00:45:13.413 --> 00:45:16.650
应用的I/O性能可能会受到

00:45:16.717 --> 00:45:20.387
其他系统资源的影响
或者其他设备上进行的I/O

00:45:23.290 --> 00:45:27.160
比如 由于多任务
还有其他应用正在运行

00:45:27.394 --> 00:45:29.596
你的应用的I/O性能可能会受到影响

00:45:30.197 --> 00:45:33.634
所以最好能够测试应用
在有其他应用的情况下

00:45:35.602 --> 00:45:38.505
并且 系统试图维持公平的平衡

00:45:38.572 --> 00:45:40.674
在内存和I/O使用之间

00:45:41.341 --> 00:45:45.546
在内存紧张情况下
I/O延迟也可能受到影响

00:45:46.413 --> 00:45:49.683
所以我们也建议
在内存紧张情况下测试应用

00:45:51.685 --> 00:45:56.456
最后 系统默认情况下
为你保留了很多缓存

00:45:56.523 --> 00:45:58.592
为了让你更好地访问和存储数据

00:45:59.826 --> 00:46:04.798
这些缓存的状态也可能影响系统
以及应用的I/O性能

00:46:05.632 --> 00:46:07.701
为了检测其最坏情况

00:46:07.935 --> 00:46:10.938
我们会建议重启iOS设备

00:46:11.638 --> 00:46:13.874
及macOS设备
可使用purge命令

00:46:14.141 --> 00:46:18.645
将会刷新所有缓存
为应用模拟最坏情况

00:46:19.980 --> 00:46:21.081
为了确保你的应用

00:46:21.148 --> 00:46:24.318
在所有这些环境变化中
保持性能良好

00:46:24.651 --> 00:46:28.155
我们建议遵循I/O哲学
减少和优化I/O

00:46:30.023 --> 00:46:31.992
这里是本次演讲的几点关键

00:46:33.260 --> 00:46:38.232
减少应用的I/O用量
因为它显著影响电池寿命

00:46:40.267 --> 00:46:45.706
把繁重的I/O工作量从主线程中移开
让主线程为UI和动画保持空闲

00:46:47.641 --> 00:46:51.812
指定正确的服务质量
为了指定正在进行的工作内容

00:46:53.947 --> 00:46:57.084
切换到资产目录
因为它们是最简单高效的方法

00:46:57.150 --> 00:46:58.685
来管理应用资产

00:47:00.621 --> 00:47:03.023
为数据库需求使用核心数据

00:47:03.924 --> 00:47:06.894
最后 测试和测量应用的I/O性能

00:47:08.562 --> 00:47:10.931
想了解更多信息
请访问www.developer.apple.com

00:47:10.998 --> 00:47:12.966
本场演讲编号为719

00:47:14.968 --> 00:47:17.171
本周内还会有这些相关演讲

00:47:17.237 --> 00:47:20.841
你可以参考更多
我们提到过的API和工具的细节

00:47:21.575 --> 00:47:22.709
谢谢大家