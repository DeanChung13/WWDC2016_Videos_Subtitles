00:00:19.019 --> 00:00:21.622 
关于国际化的实践

00:00:21.922 --> 00:00:22.756 
好的

00:00:25.325 --> 00:00:26.159 
大家好

00:00:29.830 --> 00:00:30.664 
大家好

00:00:40.941 --> 00:00:44.144 
你们好 欢迎大家来到 WWDC

00:00:44.211 --> 00:00:46.446 
这应该是你们今早的第一个会话

00:00:47.181 --> 00:00:50.284 
如果你听不懂我刚开始所说的

00:00:50.350 --> 00:00:51.618 
那你就来对了

00:00:52.052 --> 00:00:52.886 
那么

00:00:54.321 --> 00:00:56.490 
我们会讨论一些关于国际化的问题

00:00:57.925 --> 00:00:58.959 
你应该知道

00:00:59.459 --> 00:01:01.728 
Apple面向全世界发售其产品

00:01:03.597 --> 00:01:07.701 
三分之二Apple用户是不在美国的

00:01:08.602 --> 00:01:10.537 
这也是为什么它这么重要的原因

00:01:10.604 --> 00:01:13.707 
为了确保你应用中的语言体验没有问题

00:01:14.141 --> 00:01:18.879 
我们的用户涵盖了从旧金山到米兰
再到迪拜

00:01:18.946 --> 00:01:20.447 
还有像是从新德里到香港

00:01:21.315 --> 00:01:22.149 
当然了

00:01:22.916 --> 00:01:27.654 
这些用户很可能是
使用你的或者Apple的应用

00:01:27.988 --> 00:01:29.323 
通过他们的母语

00:01:31.892 --> 00:01:34.294 
他们也可能会使用这些应用

00:01:34.361 --> 00:01:37.331 
用你想象不到的
跟那个地区根本无关的语种

00:01:37.397 --> 00:01:38.899 
例如英语

00:01:38.966 --> 00:01:41.435 
你可能会感到奇怪
这可是个相当全球化的语言

00:01:43.036 --> 00:01:48.242 
今天我会跟你们谈谈有什么新的东西

00:01:48.342 --> 00:01:52.412 
我们近年关于国际化的探索

00:01:54.047 --> 00:01:57.084 
一些关于本地化的基础知识

00:01:57.918 --> 00:02:00.454 
还有国际化你的应用

00:02:01.688 --> 00:02:05.993 
有些技巧令你将代码稍作修改
就能变成一个不错的应用

00:02:06.059 --> 00:02:07.494 
对于全球的用户

00:02:08.695 --> 00:02:12.099 
最后是一些设计层面的东西

00:02:12.599 --> 00:02:13.433 
还有就是

00:02:14.668 --> 00:02:17.204 
从心理层面分析你该怎么做你的应用

00:02:18.038 --> 00:02:19.740 
我们从新的特性开始讲起吧

00:02:21.341 --> 00:02:23.677 
我很兴奋的向你们介绍

00:02:24.211 --> 00:02:27.714 
iOS 10中新加入的多语言键盘

00:02:28.782 --> 00:02:31.418 
如果你们左右环顾一下

00:02:31.752 --> 00:02:33.554 
你可能正好挨着

00:02:33.620 --> 00:02:36.490 
会讲多种语言的人

00:02:37.124 --> 00:02:39.893 
美国是个十分多语种的地方

00:02:39.960 --> 00:02:41.828 
加州尤其如此

00:02:42.696 --> 00:02:47.100 
在iOS10中我们提供了多语言键盘
来处理这种环境

00:02:47.401 --> 00:02:51.972 
你们从这若干种语言中任选出两种

00:02:52.706 --> 00:02:55.275 
或是屏幕这边的任意两种

00:02:55.342 --> 00:02:58.912 
你可以在同样的布局中打字了
而不需要用地球键来切换

00:02:59.046 --> 00:03:00.781 
你还有自动改错功能

00:03:01.181 --> 00:03:02.916 
以及两种语言的预测拼写功能

00:03:07.087 --> 00:03:11.124 
我们所做的另一个改进是
加入了拉美西班牙语

00:03:11.725 --> 00:03:15.162 
其被加入了iOS
watchOS还有tvOS

00:03:15.662 --> 00:03:16.930 
这可能是头一次

00:03:17.164 --> 00:03:21.401 
你的应用会碰到语言变体

00:03:21.635 --> 00:03:25.539 
其不是给特定国家设计的

00:03:25.606 --> 00:03:29.243 
我待会儿会从代码层面
来解释下这有多重要

00:03:31.178 --> 00:03:34.314 
另一个很棒的改进是新的计量格式器

00:03:34.515 --> 00:03:36.316  
其被加入到foundation中

00:03:36.817 --> 00:03:40.187  
它会处理一种语言中的单位转换

00:03:40.254 --> 00:03:43.357  
以及在后台处理该区域
要注意的风俗习惯问题

00:03:43.790 --> 00:03:46.126  
它已经支持了超过20种不同的单位

00:03:46.527 --> 00:03:51.064  
像是温度 能量 压力等等

00:03:51.431 --> 00:03:52.266  
在此

00:03:52.533 --> 00:03:55.836  
我不会深入展开来讲

00:03:55.903 --> 00:03:59.273  
周五有个专门讲这个专题会话

00:03:59.339 --> 00:04:00.707  
请去参加那个会话吧

00:04:03.210 --> 00:04:06.880 
我们近年也本地化了数字键盘

00:04:07.281 --> 00:04:10.984 
因此当你请求数字键盘的时候

00:04:11.084 --> 00:04:12.653 
你会自动得到

00:04:12.719 --> 00:04:15.222 
支持不同编号体系的键盘

00:04:15.322 --> 00:04:17.057 
例如支持阿拉伯数字和印度语数字

00:04:18.858 --> 00:04:20.427 
当你处于当前状态时

00:04:20.494 --> 00:04:23.697 
你会看到键盘的左下角有一个123键

00:04:23.764 --> 00:04:26.500 
来让你在不同的计数系统间进行切换

00:04:28.468 --> 00:04:29.703  
在这些情况下

00:04:30.070 --> 00:04:34.041  
你可能想要能带ASCII数字的键盘

00:04:34.107 --> 00:04:37.411  
当你确定你要进行的输入

00:04:37.477 --> 00:04:39.613  
必须限定为ASCII数字时

00:04:39.947 --> 00:04:44.051  
比如要输入信用卡号和IP地址时

00:04:44.117 --> 00:04:46.720  
这些是特殊的例子
但是你应该考虑到这些情况

00:04:50.290 --> 00:04:54.194 
在macOS Sierra中的
一个重要新特性

00:04:54.261 --> 00:04:59.733 
就是支持像是阿拉伯语和希伯来语
本地化从右向左输入

00:05:00.033 --> 00:05:03.237 
macOS重新设计了
从右向左读写的语言

00:05:05.205 --> 00:05:08.141 
当然macOS加入了我们已有的家庭

00:05:08.208 --> 00:05:11.945 
其中像是iOS和watchOS
这类产品已经支持了

00:05:12.279 --> 00:05:13.914 
本地化的从右向左读写的语言

00:05:15.115 --> 00:05:18.151  
这个是挺大的主题 我不会就此展开

00:05:18.552 --> 00:05:20.287  
有个专门讲这个主题的演讲

00:05:20.354 --> 00:05:24.258  
会在中午上午九点举行
叫做国际用户界面的新特性

00:05:24.324 --> 00:05:26.026  
你们应该去听一下

00:05:27.494 --> 00:05:30.631 
我们从一些基本概念开始讲起吧

00:05:31.565 --> 00:05:34.001 
都是关于国际化所需要知道的概念

00:05:34.935 --> 00:05:38.839 
让我们看一个iOS预装的应用
时钟应用

00:05:38.906 --> 00:05:41.708 
它的界面重新设计了
不过你们应该看着还会眼熟

00:05:42.843 --> 00:05:44.444 
那么有哪些方面

00:05:44.511 --> 00:05:46.680 
你需要进行国际化

00:05:46.747 --> 00:05:49.349 
来让这个应用适应不同的语言和国家呢

00:05:51.118 --> 00:05:53.820 
首先 你需要本地化所有的字符串

00:05:53.887 --> 00:05:59.726 
也就是任何有字符串的按钮
标签或是视图

00:05:59.793 --> 00:06:01.461 
你得保证它被翻译成

00:06:01.528 --> 00:06:03.997 
所有你要支持的语言

00:06:05.832 --> 00:06:09.770 
接下来还有另一类的字符串
需要被本地化

00:06:09.837 --> 00:06:13.540 
但它是格式化的内容
因此你应该使用格式器

00:06:14.241 --> 00:06:15.809 
来实现

00:06:16.109 --> 00:06:17.778 
这会节省你大量的工作

00:06:20.547 --> 00:06:22.916 
最后 你需要国际化整个布局

00:06:23.183 --> 00:06:25.686 
以便它可以在从右向左的语言环境下
运转良好

00:06:26.720 --> 00:06:29.389 
而对于会产生更长或
更短翻译结果的语言

00:06:29.456 --> 00:06:31.024 
这是与源语言相比较而言

00:06:32.326 --> 00:06:36.029 
如果我们所有都弄对了
那么我们就把这个英文应用

00:06:36.530 --> 00:06:39.633 
翻译成中文应用吧 它看起来不错

00:06:40.334 --> 00:06:44.071 
注意在中文环境下
上午/下午标示是在

00:06:44.137 --> 00:06:46.540 
数字之前而英文环境下正好相反

00:06:48.008 --> 00:06:51.411 
它在诸如阿拉伯语这类从右向左读写的
语言环境下效果也不错

00:06:51.612 --> 00:06:54.815 
注意看现在整个应用的布局
是如何呈现从右向左的

00:06:55.749 --> 00:07:01.088 
在这个例子中 看看在阿拉伯语环境下
是如何使用阿拉伯-印度语数字的

00:07:01.154 --> 00:07:03.056 
这和英语环境下的运行是不同的

00:07:03.123 --> 00:07:05.526 
如果你用的是格式器
这些就不用你操心了

00:07:07.361 --> 00:07:11.231 
这些就是开发方面的一些基础知识

00:07:11.298 --> 00:07:14.134 
让我们也来看看用户角度的基础知识

00:07:14.201 --> 00:07:19.206 
当用户获得一个新的Apple设备
像是iPhone 他会做什么呢

00:07:20.541 --> 00:07:22.843 
当你打开每个Apple设备

00:07:22.910 --> 00:07:25.145 
首次都会让你选择一种语言

00:07:26.313 --> 00:07:28.982 
深入探究的话其实就是

00:07:29.049 --> 00:07:32.953 
每种语言都有与其对应的编码

00:07:33.120 --> 00:07:36.089 
当然了 每个区域也有相应的编码

00:07:36.723 --> 00:07:40.561 
我们假定一个用户选择的是
西班牙语 美国

00:07:42.596 --> 00:07:46.800 
其实最后生成的语言编码是es-US

00:07:49.203 --> 00:07:50.137  
你可能不知道的是

00:07:50.204 --> 00:07:53.307  
语言编码也是有体系结构的

00:07:53.674 --> 00:07:55.976  
例如 西班牙语 美国

00:07:56.043 --> 00:07:58.245  
实际上是继承于拉美西班牙语

00:07:58.312 --> 00:08:00.247  
而其又继承于原生西班牙语

00:08:00.848 --> 00:08:02.015  
这非常的重要

00:08:02.082 --> 00:08:07.621  
因为不是每个应用都会被本地化为
西班牙语 美国

00:08:07.688 --> 00:08:08.956  
所以我们想要知道

00:08:09.022 --> 00:08:11.725  
用户倾向的次选语言是什么

00:08:11.792 --> 00:08:13.927  
如果我们不支持他们最喜欢的语言

00:08:13.994 --> 00:08:15.229  
显示在系统上

00:08:17.965 --> 00:08:20.501  
而且这个体系结果不仅是针对西班牙语

00:08:20.567 --> 00:08:23.203  
甚至是像英语都
是有这样的体系结构的

00:08:23.270 --> 00:08:25.005  
例如 印度英语

00:08:25.939 --> 00:08:31.945  
其拼写体系是要更接近于
英式英语 相比美式英语来说

00:08:32.011 --> 00:08:36.250  
因此它就是继承于英式英语的
体系结构的一部分

00:08:36.884 --> 00:08:41.288 
英语和西班牙语只不过是其中两种语言
对于这种体系结构来说

00:08:42.054 --> 00:08:45.692 
我们还有其他语言像是汉语
法语 葡萄牙语

00:08:45.759 --> 00:08:47.194 
也有类似的体系结构

00:08:47.261 --> 00:08:51.365 
所以我希望你们把这些要点都记下来

00:08:51.431 --> 00:08:52.366 
当然不用了

00:08:52.766 --> 00:08:54.468 
我提到这些点的原因就是

00:08:54.535 --> 00:08:56.570 
因为我们会帮助你们解决这类问题

00:08:56.637 --> 00:08:58.472 
而你根本就不用操心这个

00:08:58.672 --> 00:09:02.876 
我会在下面告诉你们要怎么实现

00:09:04.278 --> 00:09:06.513 
我们首先要做什么呢

00:09:06.580 --> 00:09:08.115 
我们需要本地化所有的字符串

00:09:08.348 --> 00:09:09.917  
还要进行一些设置

00:09:09.983 --> 00:09:13.187  
这些设置挺简单的 不过确实要做

00:09:13.253 --> 00:09:15.856  
我不打算在这细说

00:09:15.923 --> 00:09:18.859  
因为有很多的文档可供参考

00:09:18.926 --> 00:09:22.563  
而且还有另外一个讲座
专门是讲如何设置你的应用的

00:09:22.896 --> 00:09:25.832  
假设你已经完成了你的本地化设置

00:09:25.899 --> 00:09:28.302  
那么此时你的应用里
就有了一些本地化的字符串

00:09:30.604 --> 00:09:32.272 
若你使用storyboard

00:09:32.573 --> 00:09:35.008 
并使用其中的国际化基板 你就完成了

00:09:35.576 --> 00:09:37.411 
你不用再做什么 启动你的应用吧

00:09:37.477 --> 00:09:38.745 
字符串成功加载

00:09:38.912 --> 00:09:39.780 
你都完成啦

00:09:42.149 --> 00:09:45.385 
如果你要在代码中创建或载入字符串

00:09:45.452 --> 00:09:47.754 
你需要调用
NSLocalizedString

00:09:47.855 --> 00:09:51.058 
NSLocalizedString
会运用非常好的逻辑

00:09:51.124 --> 00:09:52.926 
来处理我刚才提过的体系结构

00:09:53.026 --> 00:09:55.395 
它会为你加载最恰当的字符串

00:09:55.562 --> 00:09:58.999 
注意给你的翻译器加上个注释

00:09:59.066 --> 00:10:03.637 
因为根据不同的语境
同样的单词经常会有不同的意思

00:10:03.704 --> 00:10:05.739 
而注释会帮助理清它

00:10:08.475 --> 00:10:10.744 
让我们看个更复杂些的场景

00:10:10.811 --> 00:10:13.247 
假如说你是从远程服务获取字符串的

00:10:13.313 --> 00:10:16.149 
像是从服务器或是另一个进程

00:10:16.450 --> 00:10:19.152 
在这种情况下 你可能想让服务器

00:10:19.219 --> 00:10:20.420 
或是其他进程知道

00:10:20.487 --> 00:10:22.890 
这就是我的应用的启动语言

00:10:22.956 --> 00:10:24.791 
请给我相匹配的字符串

00:10:25.192 --> 00:10:26.560 
为了实现这个功能

00:10:26.627 --> 00:10:30.631 
你可以在你启动的Bundle上
调用喜欢的本地化

00:10:30.931 --> 00:10:34.635 
以此获得第一种语言
并将其发给你的远程服务

00:10:38.272 --> 00:10:41.675 
如果你还有更多参与的设置

00:10:41.742 --> 00:10:44.678 
出于某种原因你有一个列表的可选语言

00:10:44.745 --> 00:10:47.214 
而在服务器上没有正好匹配

00:10:47.281 --> 00:10:48.849 
你在客户端上列表里的语言

00:10:48.916 --> 00:10:51.151 
假如说你在服务器端有一个更大的集

00:10:51.351 --> 00:10:56.123 
那么你可以调用
preferredLocalizations方法

00:10:56.423 --> 00:10:58.025 
并传给它你所拥有的备选集

00:10:58.091 --> 00:11:00.294 
它会给你匹配最合适的语言

00:11:01.728 --> 00:11:05.766  
我提到Bundle语言匹配逻辑

00:11:05.832 --> 00:11:08.235  
在上面几张幻灯片好多次了

00:11:08.535 --> 00:11:09.570  
那它到底是什么呢

00:11:09.636 --> 00:11:11.738  
Bundle在底层为你做了什么呢

00:11:12.573 --> 00:11:16.376  
Bundle为你做的就是
它在思考一些事情 比如

00:11:16.443 --> 00:11:20.280  
恩 用户喜欢英语 美国

00:11:20.514 --> 00:11:23.283  
但是我们没有英语 美国的本地化配置

00:11:23.350 --> 00:11:26.920  
不过我们有英语的配置
在此它就会给你英语的配置

00:11:27.120 --> 00:11:29.623  
它会弄明白 你想要印度式英语

00:11:29.690 --> 00:11:33.560  
我们有英式的而不是印度式的
那我们就给你英式的

00:11:33.927 --> 00:11:37.197  
在拉美西班牙语的例子中

00:11:37.497 --> 00:11:40.100  
如果你说我喜欢墨西哥式英语

00:11:40.167 --> 00:11:43.270  
它会试着给你最好的匹配结果

00:11:43.337 --> 00:11:45.839  
从列表中看就是拉美西班牙语

00:11:46.340 --> 00:11:49.142  
类似的 有关于汉语还有很多其他语言

00:11:49.209 --> 00:11:52.212  
这种本地化的语言体系逻辑非常复杂

00:11:52.513 --> 00:11:55.082 
你应该不想在你的应用中执行

00:11:55.148 --> 00:11:57.684 
如果你的代码是可以实现

00:11:57.751 --> 00:11:59.286 
使用语言识别器

00:11:59.353 --> 00:12:01.889 
通过连字符分割它
或者诸如此类的代码

00:12:01.955 --> 00:12:04.992 
请把代码删除 因为你不应该这么做

00:12:06.960 --> 00:12:10.464 
现在你已经本地化了你的所有字符串
也使用了正确API

00:12:11.064 --> 00:12:13.233  
你应该再检查一下你所做的

00:12:13.300 --> 00:12:14.601  
是否真的把应用本地化了

00:12:14.668 --> 00:12:18.272  
为了实现这个目的
你可使用Xcode 8新静态分析器

00:12:18.539 --> 00:12:22.543  
它会帮你找到本地化中出现的任何问题

00:12:22.609 --> 00:12:25.712  
你把非本地化的字符串放到UI的位置

00:12:28.015 --> 00:12:29.883 
这就是所有关于本地化字符串的内容了

00:12:30.751 --> 00:12:32.286 
接下来我们谈一下格式器

00:12:34.588 --> 00:12:37.257 
现如今你能看到很多这类应用

00:12:37.324 --> 00:12:39.393 
关于送达服务的

00:12:39.793 --> 00:12:43.964 
但是你这里看到的这个可不怎么样

00:12:44.331 --> 00:12:46.233 
它上面写着AM9:41

00:12:46.300 --> 00:12:49.736 
英语用户会觉得这写的根本不对

00:12:50.637 --> 00:12:53.273 
但相信我
我在实际的应用中看到过这种格式

00:12:54.675 --> 00:12:58.045 
你可能会发现在中文里是正好相反的

00:12:58.111 --> 00:13:01.114 
中文里把a.m./p.m.
记号放在数字后面的话

00:13:01.181 --> 00:13:02.983 
是完全错误的

00:13:03.750 --> 00:13:06.987 
那我们应该如何避免这样的错误呢

00:13:09.122 --> 00:13:13.493 
其实问题是在于我们使用了一个方法

00:13:13.560 --> 00:13:17.497 
方法叫做formatter.dateFormat
还通过它设置了一个固定的格式

00:13:17.564 --> 00:13:19.266 
似乎看上去这么做是对的

00:13:19.366 --> 00:13:23.237 
其在代码中很整洁
但实际上是错的方法

00:13:24.404 --> 00:13:27.941 
尽管在英语环境下
它显示的是正确的结果

00:13:28.008 --> 00:13:29.743 
它会显示9:41 a.m.

00:13:29.810 --> 00:13:32.946 
但如果你是在中文环境下
结果就是错误的

00:13:33.013 --> 00:13:34.948 
为什么呢
因为它设定的是固定的格式

00:13:35.015 --> 00:13:38.018 
而不管你运行的是哪种语言

00:13:40.087 --> 00:13:41.688 
正确的方法应该是

00:13:41.755 --> 00:13:45.526 
在日期格式器上使用预定义的短风格

00:13:45.592 --> 00:13:48.095 
它会为你显示正确的结果
无论是在英语环境

00:13:48.962 --> 00:13:52.299 
汉语环境
还是你应用可能本地化的其他语言

00:13:54.201 --> 00:13:55.736 
当然还有其他更多风格供选择

00:13:55.802 --> 00:13:58.405 
有我刚刚演示给你的短风格

00:13:58.739 --> 00:14:01.842 
也有稍微长一点的风格 它带有秒数

00:14:01.942 --> 00:14:04.178 
还有带时区的风格

00:14:04.645 --> 00:14:05.812  
或带完整时区名显示的

00:14:05.946 --> 00:14:08.282  
对于不同的需要有着对应的不同风格

00:14:09.917 --> 00:14:11.485 
当然了 不仅仅是有关于时间的

00:14:11.718 --> 00:14:13.020 
也有关于日期的

00:14:13.153 --> 00:14:16.223 
从短期到长期的风格一应俱全

00:14:17.758 --> 00:14:19.092 
你可能会找到我说

00:14:19.159 --> 00:14:21.895 
这些是挺好的
但是没有一种风格是我的设计师想要的

00:14:21.962 --> 00:14:25.933 
他们只想要整年的
或者光要这个 光要那个

00:14:26.400 --> 00:14:27.234 
没问题

00:14:27.334 --> 00:14:30.103 
你可以用一个格式

00:14:30.671 --> 00:14:32.739 
重要的是要使用它的话

00:14:32.873 --> 00:14:36.877 
要用到setLocalizedDateFormat
FromTemplate方法

00:14:37.144 --> 00:14:40.647 
这会保证它接受你的格式

00:14:40.714 --> 00:14:43.350 
解释当前引号中的语言

00:14:43.584 --> 00:14:47.187 
然后给你该语言对应的正确本地化格式

00:14:51.024 --> 00:14:53.961 
还有两个你可能没有用过的类

00:14:54.161 --> 00:14:56.263 
尽管不是今年刚出的不过还是很新

00:14:56.363 --> 00:15:00.200 
日期控件 它可以让你生成格式

00:15:00.267 --> 00:15:02.503 
一个区间段 像是4小时25分钟

00:15:03.537 --> 00:15:08.976  
或是日期间隔 像是这个讲座的时间
上午9点到9点40

00:15:09.743 --> 00:15:14.014 
使用这些类的优势在于

00:15:14.481 --> 00:15:17.050 
它会为你负责所有的本地化工作

00:15:20.921 --> 00:15:24.391 
接下来我们谈谈另一种
你可以格式化的数据类型

00:15:24.691 --> 00:15:25.592 
名称

00:15:27.628 --> 00:15:28.462 
现在...

00:15:29.096 --> 00:15:32.165 
如果你是这么显示你的用户名字的

00:15:32.232 --> 00:15:35.602 
或者是他们朋友的名字
当他们打开你的应用时

00:15:36.170 --> 00:15:38.705 
这会让他们对你的应用
留下一个非常坏的印象

00:15:39.072 --> 00:15:40.841 
我们不该这么做

00:15:42.242 --> 00:15:46.346 
你应该正确显示这些名字

00:15:47.247 --> 00:15:49.249 
为给定的语言和脚本

00:15:50.384 --> 00:15:51.318 
我们应该怎么做呢

00:15:53.420 --> 00:15:54.888 
其实挺简单的

00:15:55.989 --> 00:15:58.992 
你需要创建一个
PersonNameComponents对象

00:15:59.059 --> 00:16:03.096 
将其填入一些名字的组件
然后就像其他的格式器

00:16:03.163 --> 00:16:06.433 
你就从组件中请求字符串即可

00:16:06.500 --> 00:16:08.335 
你想要什么风格都可以

00:16:08.402 --> 00:16:12.206 
我们有很多的风格可供选择
从长的 像是全名

00:16:12.272 --> 00:16:15.475 
到缩略的 你可以用首字母缩写

00:16:17.411 --> 00:16:20.147 
当然了 它也支持多语种

00:16:22.149 --> 00:16:26.153 
近年所出的新特性是名称语法分析支持

00:16:26.353 --> 00:16:30.290 
你既能分析一个全名
也能分析一系列的部件

00:16:31.124 --> 00:16:33.227 
而且实现它就像
创建一个格式器那样容易

00:16:33.694 --> 00:16:36.830 
发给它一个字符串 然后看下组件

00:16:37.264 --> 00:16:39.967 
如果返回nil 那么就没有成功分析

00:16:41.001 --> 00:16:43.036 
组件构造

00:16:43.670 --> 00:16:45.072 
有个挺酷的事是

00:16:45.138 --> 00:16:50.377 
这不是个检查某个静态规则集合的
静态API

00:16:50.444 --> 00:16:53.380 
它其实是个统计数据模型

00:16:53.614 --> 00:16:56.817 
所以即使你是以相反的顺序传入名字的

00:16:56.884 --> 00:16:59.720 
它也知道
在John Appleseed中

00:16:59.786 --> 00:17:02.923 
John更可能是名

00:17:02.990 --> 00:17:04.625 
而Appleseed是姓

00:17:04.691 --> 00:17:06.627 
而它仍将正确分析语法

00:17:08.628 --> 00:17:11.798 
它也支持多个语种

00:17:14.468 --> 00:17:16.603 
有很多个格式器

00:17:17.671 --> 00:17:18.505 
我着重说了

00:17:19.039 --> 00:17:24.411 
Date和
PersonNameComponents格式器

00:17:25.112 --> 00:17:29.616 
简单说明了关于日期的
components和interval格式器

00:17:30.050 --> 00:17:32.586 
有些格式器我没有提到

00:17:32.653 --> 00:17:36.023 
它们都是系统中现有的格式器

00:17:37.124 --> 00:17:40.260  
这个是全新的
measurement格式器

00:17:40.894 --> 00:17:43.397  
这也是新发布的一个格式器

00:17:43.630 --> 00:17:46.333  
请用下这些格式器

00:17:46.466 --> 00:17:49.503 
无论在你代码的哪个地方
因为使用它们是正确的

00:17:49.570 --> 00:17:51.772 
你也会减少使用本地化字符串

00:17:53.307 --> 00:17:55.342 
这是你在这些例子中应该避免使用的

00:17:56.210 --> 00:17:57.044 
那么

00:17:57.811 --> 00:17:59.913 
就是这么多了

00:18:00.480 --> 00:18:03.116 
在字符串方面
你整个的UI就是本地化的

00:18:03.317 --> 00:18:06.253 
那么让我们来看下
在布局方面应该做些什么

00:18:06.720 --> 00:18:10.257 
以确保UI是和那些字符串正常工作的

00:18:12.092 --> 00:18:16.263 
这里的关键字是Auto Layout

00:18:16.630 --> 00:18:20.801 
它要做的正如其名

00:18:20.868 --> 00:18:22.769 
就是要实现自动布局

00:18:23.237 --> 00:18:25.439 
不管你是在左还是右优先的应用

00:18:26.740 --> 00:18:29.009 
若你使用“自动布局”
你都会得到

00:18:29.209 --> 00:18:33.013 
自动生成一个基于从右向左语言
的用户界面

00:18:34.181 --> 00:18:37.284  
自动布局是一个重要的话题

00:18:37.417 --> 00:18:41.321  
我不会展开讲
你应该如何使用自动布局

00:18:41.388 --> 00:18:44.191  
因为有很多的会话 不仅是今年

00:18:44.258 --> 00:18:48.328  
还有往年的 介绍了其相当多的细节

00:18:49.763 --> 00:18:53.100  
你应该使用UIStackView

00:18:53.166 --> 00:18:59.473 
和NSStackView 尽量多用
因其是非常容易使用的API

00:18:59.540 --> 00:19:03.744 
是用自动布局的API
这会让你的视图

00:19:03.810 --> 00:19:06.513 
跳转为从右向左语言显示

00:19:06.580 --> 00:19:09.950 
并且当它们得到长和短的字符串时
会进行恰当的调整

00:19:11.785 --> 00:19:13.754 
我们会给你们一些示例代码

00:19:13.820 --> 00:19:19.259 
向你展示如何使用Stack Views
来实现一个时钟应用

00:19:23.030 --> 00:19:26.200 
对于布局你要牢记一点

00:19:26.266 --> 00:19:29.102 
就是有时候你得有点创造性

00:19:29.703 --> 00:19:31.438 
当前的屏幕内容是以英文显示的

00:19:31.672 --> 00:19:33.540 
你确定你不想用Apple ID么

00:19:34.241 --> 00:19:37.744 
你在这有两个选项
用或者不用Apple ID

00:19:37.845 --> 00:19:39.947 
你可以想象在某些语言环境中

00:19:40.013 --> 00:19:43.617 
翻译可能会长一点
就放不到这两个紧挨着的按钮中

00:19:44.618 --> 00:19:45.752 
那你该怎么做呢

00:19:46.153 --> 00:19:50.424 
在这种情况下
你会发现整个视图进行了切换

00:19:50.490 --> 00:19:53.594 
从左右适应变成了上下适应

00:19:54.194 --> 00:19:59.199 
诸如此类的创造性UI元素
是你应该记住的

00:19:59.266 --> 00:20:02.603 
在你的应用中

00:20:03.070 --> 00:20:07.140 
你向翻译器请求缩短一个字符串

00:20:07.207 --> 00:20:10.410 
甚至在该语言环境下都不能明确表意时

00:20:14.481 --> 00:20:16.216 
接下来要介绍的是竖直灵活性

00:20:16.283 --> 00:20:21.922 
你们的应用可能以前都没有考虑过这点

00:20:22.923 --> 00:20:23.757 
恩

00:20:24.391 --> 00:20:27.227 
我们在OS中有很多的脚本

00:20:27.294 --> 00:20:30.464 
为了支持像是越南语 泰语
阿拉伯语和印地语

00:20:30.531 --> 00:20:34.434 
或高或低或兼有

00:20:34.501 --> 00:20:37.938 
与书写英文所用的基础拉丁字母相比

00:20:39.339 --> 00:20:44.378 
我们经常会碰到一个错误

00:20:44.444 --> 00:20:48.248  
就是有人可能把标签的
clipsToBounds设为true

00:20:48.749 --> 00:20:52.119  
它会将两边的文本剪切

00:20:52.786 --> 00:20:57.624  
这会让布局变得很丑

00:20:58.091 --> 00:21:00.527  
在那种语言环境下看起来很糟糕

00:21:01.128 --> 00:21:04.231  
你会丢失重要的语义信息

00:21:04.298 --> 00:21:05.766  
像是变音符

00:21:06.366 --> 00:21:11.572  
在这个例子中
右边所有词的发音都变了

00:21:11.872 --> 00:21:13.373  
当你像这样剪切它们的时候

00:21:14.575 --> 00:21:16.643  
想要修复它很容易

00:21:16.710 --> 00:21:20.113  
如果有标签的话不要将
clipsToBounds设为true

00:21:20.714 --> 00:21:23.317  
这样就能解决这个问题

00:21:26.086 --> 00:21:29.690 
更有趣的是 如果你有个多行的标签

00:21:30.524 --> 00:21:32.860 
你也需要考虑行内间距

00:21:33.694 --> 00:21:35.329 
我们来看下这里

00:21:35.395 --> 00:21:38.732 
左侧有印地语 而右侧有英语

00:21:40.133 --> 00:21:43.370 
抱歉这里弄反了
是英文在左边 印地语在右边

00:21:43.904 --> 00:21:44.738 
不过

00:21:45.539 --> 00:21:47.841 
看看如果我们挤占的话会怎么样

00:21:48.108 --> 00:21:51.812 
将印地语挤占到
跟英语有着相同的竖直空间

00:21:52.513 --> 00:21:54.147 
这看起来很难认

00:21:55.115 --> 00:21:58.552 
任何一个印地语读者都会告诉你

00:21:58.619 --> 00:22:02.523 
这简直太难读了 看起来一点都不好

00:22:04.024 --> 00:22:05.526 
因此你要做的就是

00:22:05.592 --> 00:22:08.795 
给予每个脚本充足的空间

00:22:08.862 --> 00:22:11.832 
使其在屏幕看起来既美观又易读

00:22:12.366 --> 00:22:14.668 
好消息是这很容易实现

00:22:15.936 --> 00:22:17.671 
当你用多行标签的时候

00:22:18.138 --> 00:22:21.108 
其实大部分情况都是默认的
不过你还是确认

00:22:21.175 --> 00:22:23.544 
你正确设置了定制的字体

00:22:23.844 --> 00:22:27.247 
也就是你通过UI字体API
获得了想要的字体

00:22:28.549 --> 00:22:31.051  
你也许会说

00:22:31.118 --> 00:22:34.621  
我有一个定制字体但是我用不了

00:22:34.922 --> 00:22:39.059  
这其实是可以解决的 你应该

00:22:39.760 --> 00:22:43.063  
你应该看下周三关于字体和排版的讲座

00:22:43.130 --> 00:22:45.699  
它深入的讲了如何保证

00:22:45.766 --> 00:22:50.470  
定制字体如何贴合动态类型

00:22:54.074 --> 00:22:58.912 
接下来对于table views
我们所做的很巧妙

00:22:58.979 --> 00:23:01.715 
如果你所选的语言是
带有较高的书写字母

00:23:02.015 --> 00:23:06.453 
我们会把表格的行高给调大

00:23:06.520 --> 00:23:09.122 
比起其在其他语言中的效果 像是英语

00:23:09.790 --> 00:23:12.526 
这是给了书写字母足够的空间

00:23:12.593 --> 00:23:15.929 
这会让那些语言整体看上去更加自然

00:23:17.731 --> 00:23:21.134 
要发挥这个优势的话
你要在代码中使用

00:23:21.201 --> 00:23:23.570 
标准UITableViewCell
风格

00:23:24.071 --> 00:23:26.874 
你可能会说 我用的是定制的cell

00:23:26.940 --> 00:23:28.642 
这样就不能正常工作了

00:23:28.709 --> 00:23:30.711 
这可不是有个标签就能实现的

00:23:30.777 --> 00:23:32.012 
它不像你想的那么简单

00:23:32.079 --> 00:23:33.113 
好吧

00:23:33.680 --> 00:23:35.249 
我同意 不过

00:23:35.782 --> 00:23:39.953 
至少我发现若你使用
UITableViewCell

00:23:40.020 --> 00:23:42.556 
它是可高度定制化的

00:23:42.856 --> 00:23:45.058 
它有很多的过载方法可供你使用

00:23:45.192 --> 00:23:47.427 
总能得到你想要的外观效果

00:23:47.694 --> 00:23:51.398 
所以先试试它吧
在你实现一个完全定制的

00:23:51.899 --> 00:23:53.767 
UITableViewCell之前

00:23:57.204 --> 00:24:01.175 
我想介绍的小的代码改进就是这么多

00:24:01.241 --> 00:24:04.511 
它们会让你的应用
面向国际用户时表现更加出色

00:24:04.912 --> 00:24:09.183 
让我们谈一些别的吧
更抽象 更以设计为基础的东西

00:24:10.184 --> 00:24:12.920 
还有些从心理层面你要记住的东西

00:24:13.320 --> 00:24:14.855 
继而做出很棒的应用

00:24:16.924 --> 00:24:18.859 
首先就是图标学

00:24:19.726 --> 00:24:23.931 
当你进入App Store
想要找一款应用时

00:24:23.997 --> 00:24:26.600 
头一个你会注意到的东西就是图标

00:24:26.934 --> 00:24:28.869 
很多时候 至少对于我来说

00:24:28.936 --> 00:24:32.773 
如果图标不好看我就不会买
因为它会显示在我的主屏幕上

00:24:33.340 --> 00:24:35.809 
我可不想在那显示一个不好看的应用

00:24:36.376 --> 00:24:38.245 
所以图标是很重要的

00:24:38.312 --> 00:24:41.548 
还有一点也很重要
就是你所选择的图标

00:24:41.949 --> 00:24:44.251 
要对于不同的语言都适用

00:24:44.318 --> 00:24:48.422 
还有对于不同布局方向的语言

00:24:48.488 --> 00:24:50.190 
不管是从左向右的还是从右向左的

00:24:50.490 --> 00:24:53.193 
Photos有一个不错的图标

00:24:53.260 --> 00:24:55.963 
这就是一个不错的图标案例

00:24:56.530 --> 00:25:02.069 
它不包含文字或者数字
使其拘泥于某种特定的语言

00:25:02.569 --> 00:25:05.973 
它也没有从左往右
或是从右往左的方向性

00:25:06.206 --> 00:25:10.677 
所以它在日语 英语
阿拉伯语下都表现出色

00:25:12.846 --> 00:25:15.883  
如果你要做一个从右向左的本地化

00:25:16.316 --> 00:25:19.486  
而且你想保证你的UI看起来不错

00:25:19.553 --> 00:25:20.921  
对于从右向左的语言来说

00:25:21.688 --> 00:25:23.857  
你就得检查一下你所用的插图

00:25:24.191 --> 00:25:27.160  
如果你所使用的插图是带有方向性的

00:25:27.327 --> 00:25:29.830  
你需要把它变为适配从右向左语言的

00:25:30.030 --> 00:25:33.834  
你可能需要创造专门的插图

00:25:33.901 --> 00:25:35.102  
为从右向左的语言来使用

00:25:35.469 --> 00:25:39.907  
这里有个例子是
你不能直接水平翻转这个插图

00:25:39.973 --> 00:25:43.644  
如果你要用从右向左语言的话
你需要创作专门的插图

00:25:44.978 --> 00:25:47.781 
不过如果你有只需要翻转的插图的话

00:25:47.848 --> 00:25:49.082 
有一个API可以实现

00:25:49.149 --> 00:25:51.218 
而你就不需要再单独做一张插图了

00:25:51.818 --> 00:25:53.520 
对此更多的信息

00:25:53.587 --> 00:25:56.523 
在“国际用户界面的新特性”
的会话中有

00:25:56.590 --> 00:26:00.060 
这个会话将在周五举行
但是关键是资源目录

00:26:03.864 --> 00:26:07.201 
另一个你可能想到 可能想不到的

00:26:07.267 --> 00:26:08.468 
是你应用的名字

00:26:09.770 --> 00:26:12.906 
当你看全世界
不同的App Store时

00:26:13.173 --> 00:26:16.777 
我们最习以为常的就是

00:26:16.944 --> 00:26:19.513 
用户更喜欢买的应用

00:26:19.847 --> 00:26:21.648 
就是用母语写的应用

00:26:21.949 --> 00:26:24.351 
这点对于应用的名字来说同样适用

00:26:24.918 --> 00:26:27.921 
因为如果他们能够一目了然的

00:26:27.988 --> 00:26:31.525 
通过一行应用的名字和描述
就知道这个应用是干什么用的

00:26:31.825 --> 00:26:33.760 
那他们就更有可能

00:26:34.061 --> 00:26:37.231 
点进应用界面去看一下

00:26:40.434 --> 00:26:42.970 
当然了 这个世界

00:26:43.504 --> 00:26:47.040 
全世界用户越来越会多种语言

00:26:47.241 --> 00:26:48.876 
或者他们至少会双语

00:26:49.409 --> 00:26:52.913 
因此你的应用不应该假设

00:26:53.013 --> 00:26:58.585 
UI所用的语言以及其与内容的关联

00:26:58.785 --> 00:26:59.887 
用户所输入的

00:27:00.254 --> 00:27:02.489 
例如 一个常见的例子是

00:27:02.556 --> 00:27:07.961 
像亚洲的国家 比如印度
和东南亚地区

00:27:08.028 --> 00:27:10.898 
人们会把手机语言设为英文

00:27:11.331 --> 00:27:14.501 
但是他们也会用当地语言写成的内容

00:27:14.568 --> 00:27:15.802 
就像是本例子中的印地语

00:27:16.803 --> 00:27:20.107 
因此当你的应用运行在英文环境时

00:27:20.174 --> 00:27:22.709 
不要想当然的认为用户会输入英文

00:27:22.776 --> 00:27:26.813 
特别是要用中文和日文键盘
来测试你的应用

00:27:26.880 --> 00:27:29.049 
确保其是正常工作的

00:27:33.720 --> 00:27:37.257 
在此我想给你们展示一个应用

00:27:37.724 --> 00:27:42.362 
我们觉得完全证明我刚才所说的

00:27:43.530 --> 00:27:44.731 
那就是Evernote

00:27:45.299 --> 00:27:47.835 
首先你看下程序图标

00:27:48.535 --> 00:27:50.404 
它没有任何的字母 符号或是其他什么

00:27:50.470 --> 00:27:53.440 
可能与单一语种有关联的东西

00:27:54.608 --> 00:27:55.843 
这很不错

00:27:58.045 --> 00:28:03.483 
他们还将应用的名字本地化成了中文

00:28:03.550 --> 00:28:05.485 
如果你讲中文的话

00:28:05.552 --> 00:28:09.990 
你就会发现他们做了一个很棒的双关语

00:28:10.090 --> 00:28:13.360 
因为他们所选择的中文词汇

00:28:13.427 --> 00:28:16.997 
同时也包含了他们的图标中象这个字

00:28:17.064 --> 00:28:18.765 
这挺酷的

00:28:20.834 --> 00:28:23.470 
你会发现他们也本地化了程序截图

00:28:24.238 --> 00:28:29.276 
这些截图做的非常的细致

00:28:29.376 --> 00:28:32.012 
例如你会发现 在这张本地化的截图中

00:28:32.279 --> 00:28:34.748 
他们要创建一个note

00:28:35.516 --> 00:28:37.518 
屏幕上显示的是中文键盘

00:28:37.584 --> 00:28:39.119 
所以用户所看到的

00:28:39.520 --> 00:28:43.857 
从截图中所看到就是他们能得到的
当他们下载这个应用的时候

00:28:43.924 --> 00:28:45.792 
而这正是用户所希望看到的

00:28:46.159 --> 00:28:48.262 
所以充分利用这些优势吧
你可以上传

00:28:48.595 --> 00:28:51.999 
本地化的名字 描述 截图
到App Store

00:28:55.035 --> 00:28:59.173 
最后 我想要谈下惊喜和亮点

00:28:59.306 --> 00:29:03.010 
你想做出伟大产品的加分项

00:29:03.277 --> 00:29:07.314 
为使用特定语言的人

00:29:07.381 --> 00:29:08.549 
或是特定国家的人

00:29:09.850 --> 00:29:10.951 
我会举几个例子

00:29:11.385 --> 00:29:15.689 
一个就是如果你有任何预定义的内容

00:29:15.789 --> 00:29:18.959 
像是模板和页面

00:29:20.194 --> 00:29:21.228 
你就可以创建

00:29:22.396 --> 00:29:25.632 
不同的定制化内容来给不同的语言

00:29:26.066 --> 00:29:27.868 
例如 在Pages中

00:29:27.935 --> 00:29:32.039 
你有针对几种语言定制的卡片模板

00:29:33.974 --> 00:29:37.444 
我要举的另外一个例子是

00:29:37.511 --> 00:29:40.747 
对于更高级的特性 假如说你要支持

00:29:41.148 --> 00:29:44.251 
你要做个日历应用 你想把它做好

00:29:44.351 --> 00:29:48.455 
专门给中东和大量的亚洲国家使用

00:29:48.722 --> 00:29:51.792 
像是使用农历的中国

00:29:51.992 --> 00:29:54.094 
你就可以支持农历显示

00:29:54.194 --> 00:29:58.232 
在你的日历应用中
就如iOS和OS X所做的那样

00:29:58.932 --> 00:30:04.004 
因为这样做会给那些用户
带来更加丰富的用户体验

00:30:05.105 --> 00:30:09.343 
你能改进的地方取决于
你的应用是做什么的

00:30:09.610 --> 00:30:11.812 
你需要审视一下你自己的应用

00:30:11.879 --> 00:30:16.617 
来看看你能在哪里给用户带来惊喜

00:30:18.252 --> 00:30:21.054 
这就是我今天想说的全部内容

00:30:21.154 --> 00:30:22.723 
总结一下就是

00:30:24.491 --> 00:30:25.425 
本地化你的应用

00:30:27.828 --> 00:30:31.465 
使用标准系统API
如Formatter和Bundle

00:30:33.967 --> 00:30:36.703 
确保应用的布局是具有灵活性的

00:30:36.770 --> 00:30:39.573 
让不同的语言完美的工作
不管是有更短翻译

00:30:39.640 --> 00:30:41.508 
更长翻译

00:30:42.242 --> 00:30:45.078 
标准尺寸 不标准尺寸
英文的书写字母

00:30:45.145 --> 00:30:47.447 
还是更高的书写字母

00:30:50.517 --> 00:30:53.921 
当为你的应用设计图标时

00:30:54.321 --> 00:30:56.757 
要确保它是基于世界的设计

00:30:56.823 --> 00:31:00.961 
不要太为某个特定语言服务

00:31:04.131 --> 00:31:05.098 
最后

00:31:06.033 --> 00:31:09.203 
恰当的本地化你的应用名称

00:31:09.469 --> 00:31:10.637 
还有截图

00:31:12.906 --> 00:31:16.443 
更多的内容 你可以点击这条链接

00:31:16.510 --> 00:31:18.679 
来获得其它有用的链接

00:31:18.745 --> 00:31:21.381 
关于国际化和本地化的

00:31:23.050 --> 00:31:25.786  
还有其他一些很酷的讲座

00:31:25.853 --> 00:31:30.891  
就是我在演讲中提到过的

00:31:30.958 --> 00:31:33.961  
例如“国际用户界面的新特性”

00:31:35.062 --> 00:31:37.231  
还有“自动布局的新特性”

00:31:38.799 --> 00:31:43.904  
还有一个我想特别提一下的是
内嵌式应用设计

00:31:43.971 --> 00:31:47.975  
它讲的都是我最后提到的那些内容

00:31:48.041 --> 00:31:53.413  
如何考虑包容性设计因素

00:31:53.480 --> 00:31:55.148  
既是为了国际化

00:31:55.215 --> 00:31:59.353  
也是为了需要特殊支持的用户

00:32:00.254 --> 00:32:01.088 
要说的就是这些了

00:32:01.421 --> 00:32:02.422 
非常感谢