00:00:20.020 --> 00:00:22.923 
用SiriKit扩展你的应用

00:00:28.595 --> 00:00:29.429 
大家好

00:00:29.563 --> 00:00:31.098 
我是Vineet Khosla

00:00:31.198 --> 00:00:34.868 
今天我将与Diana Huang
和Scott Andrus一起

00:00:35.402 --> 00:00:39.640 
向你们展示如何利用SiriKit
扩展你们的应用程序

00:00:42.309 --> 00:00:43.944 
在简介的部分

00:00:44.011 --> 00:00:47.414 
大家了解了一款支持SiriKit
的应用由三个核心部分组成

00:00:48.448 --> 00:00:51.919 
你们有意图扩展

00:00:52.519 --> 00:00:54.855 
你们有意图
用户界面扩展

00:00:54.922 --> 00:00:57.057 
当然 还有你们的应用程序

00:00:58.692 --> 00:01:01.862 
在意图扩展下
我们有三个主要的方法

00:01:01.929 --> 00:01:04.665 
它们分别是解析和
确认还有处理

00:01:05.999 --> 00:01:10.971 
在这个部分
我们将探索三个内容

00:01:11.238 --> 00:01:15.843 
首先 我们会聊一下如何让
你们的应用适用SiriKit

00:01:16.410 --> 00:01:21.949 
然后 我们会聊如何添加
你们的第一个意图扩展

00:01:22.482 --> 00:01:26.386 
最后 我们会聊一下
如何将你们的应用程序

00:01:26.453 --> 00:01:30.190 
UI和样式集成到
Siri experience

00:01:30.490 --> 00:01:33.727 
通过编写I意图用户界面扩展

00:01:35.596 --> 00:01:41.802 
在这个部分 我们将使用最爱的
聊天应用独角兽快信

00:01:42.603 --> 00:01:44.505 
你们有些人一定知道这款应用

00:01:44.605 --> 00:01:48.008 
它是一款人见人爱的应用
被Siri团队内部用来

00:01:48.075 --> 00:01:49.843 
与我们的独角兽们聊天

00:01:50.177 --> 00:01:54.615 
这是一款标准的消息应用
是可以用来收发信息

00:01:54.681 --> 00:01:58.318 
但它具备一些特有的不完美之处

00:01:58.385 --> 00:02:00.420 
它的特殊使得它能为我们的目的服务

00:02:00.487 --> 00:02:03.090 
今天我们将会让它支持SiriKit

00:02:06.093 --> 00:02:09.128 
SiriKit是构建在扩展之上的

00:02:09.729 --> 00:02:12.766 
但是 在你们的应用与扩展集成之前

00:02:12.833 --> 00:02:16.937 
可为其与SiriKit相适做些准备

00:02:17.671 --> 00:02:20.507 
我先介绍一些涉及到的地方

00:02:21.308 --> 00:02:26.280 
我们将会聊一下如何准备你们的应用
通过转移一些你们的代码

00:02:26.346 --> 00:02:28.148 
至embedded
frameworks

00:02:28.215 --> 00:02:30.951 
Embedded frameworks
是一个很好的重用代码的方式

00:02:31.018 --> 00:02:33.420 
在应用与扩展之间

00:02:34.321 --> 00:02:37.357 
转移一些代码至
embedded frameworks

00:02:37.424 --> 00:02:42.129 
也将会提供给我们一个
很好的单元测试的机会

00:02:42.563 --> 00:02:48.235 
然后 最后我们将简单介绍一下
什么是合理的总体结构

00:02:48.535 --> 00:02:50.704 
用于构建你们的扩展

00:02:50.771 --> 00:02:54.341 
基于你们的应用所关联的意图

00:02:55.375 --> 00:02:59.446 
现在 让我们进一步得看一下
embedded frameworks

00:03:01.548 --> 00:03:05.052 
你们的扩展需要
执行和应用一样的任务

00:03:05.118 --> 00:03:06.820 
它要能操控意图

00:03:06.887 --> 00:03:10.891 
还有当需要时也能渲染UI

00:03:11.191 --> 00:03:14.661 
利用embedded frameworks
是很好的重用代码方式

00:03:14.728 --> 00:03:17.898 
在应用之间 同样也在扩展之间

00:03:17.965 --> 00:03:21.935 
因为你们要保证用户有一个统一的体验

00:03:22.002 --> 00:03:24.071 
无论他们是从你的应用

00:03:24.137 --> 00:03:27.975 
或者是通过SiriKit进入程序

00:03:29.576 --> 00:03:32.980 
以独角兽快信为例
我们找到了一些地方

00:03:33.046 --> 00:03:36.817 
应该可以被移到
embedded frameworks

00:03:36.884 --> 00:03:41.355 
我们看了一下独角兽快信的网络层

00:03:41.421 --> 00:03:43.757 
这是所有关于传送

00:03:43.824 --> 00:03:45.993 
和接收信息的部分

00:03:46.059 --> 00:03:50.397 
我们意识到这一部分代码

00:03:50.464 --> 00:03:52.533 
很适合被全部移至
embedded frameworks

00:03:52.599 --> 00:03:56.637 
进而 它能被我的
应用和扩展重复调用

00:03:57.738 --> 00:04:00.807 
在完成以上的移动后
我们看了一下数据模型

00:04:01.175 --> 00:04:06.513 
你们的应用和扩展应该使用
同一个数据模型

00:04:06.580 --> 00:04:10.350 
在我们的聊天应用里 它是一个数据库

00:04:10.417 --> 00:04:13.420 
和其读写方法

00:04:13.487 --> 00:04:15.923 
它同样可以被移到一个
embedded framework里

00:04:16.223 --> 00:04:19.159 
被应用和扩展调用

00:04:20.527 --> 00:04:26.633 
在完成上述的移动后
我们看了一下决策逻辑

00:04:27.267 --> 00:04:29.603 
这是你们应用的业务逻辑

00:04:29.770 --> 00:04:31.438 
在早些时候我们已经提过

00:04:31.505 --> 00:04:34.341 
我们有解析和
确认还有处理方法

00:04:34.842 --> 00:04:39.546 
这三个方法将与你们
应用的实际业务逻辑一一对应

00:04:39.613 --> 00:04:43.116 
你们应该确保应用

00:04:43.517 --> 00:04:46.320 
和意图扩展

00:04:46.386 --> 00:04:49.623 
提供给你们用户一致的体验
当他们尝试着去

00:04:49.690 --> 00:04:53.660 
完成一个任务
无论他们从哪里开始

00:04:53.727 --> 00:04:58.532 
所以我们也将决策逻辑移到了
一个embedded framework里

00:04:59.466 --> 00:05:03.170 
最后若你的应用与意图关联

00:05:03.237 --> 00:05:07.908 
需要让UI返回至SiriKit

00:05:08.308 --> 00:05:11.912 
那部分代码也应该被移至
embedded framework

00:05:11.979 --> 00:05:14.147 
那样 你可以重复调用代码
同样

00:05:14.214 --> 00:05:18.519 
提供给你们用户一个一致的体验

00:05:18.585 --> 00:05:20.521 
无论你们用户的入口点是
你们的应用

00:05:20.587 --> 00:05:23.257 
或是一个意图扩展

00:05:26.727 --> 00:05:30.330 
我建议大家观看一个2015年的讲座

00:05:30.397 --> 00:05:31.965 
应用拓展最佳实践

00:05:32.032 --> 00:05:34.301 
我看了这个讲座
我感到很受益

00:05:36.537 --> 00:05:41.441 
在转移了大部分我们的代码至
embedded frameworks之后

00:05:41.909 --> 00:05:46.280 
这给我们提供了一个很好的机会
去写一些高质量的单元测试

00:05:46.847 --> 00:05:49.550 
我知道大家会觉得这是
一个老生常谈的问题

00:05:49.616 --> 00:05:54.121 
我们在座的所有工程师
都十分会写单元测试

00:05:54.188 --> 00:05:55.989 
我们都遵循测试驱动开发

00:05:56.056 --> 00:05:57.824 
我相信每一次都是这样的

00:05:58.425 --> 00:06:00.994 
但我们转移这些代码

00:06:01.094 --> 00:06:02.863 
至一个embedded
framework将会提供给你们

00:06:02.930 --> 00:06:05.933 
一个新的机会去写一些
高质量的单元测试

00:06:06.500 --> 00:06:09.570 
特别是针对SiriKit

00:06:09.803 --> 00:06:13.006 
你们可创建一些模拟的意图

00:06:13.073 --> 00:06:16.610 
然后写一些测试
确保你们的应用

00:06:16.677 --> 00:06:20.047 
和扩展有正确的响应

00:06:20.347 --> 00:06:22.449 
你们无需实时的和Siri进行沟通

00:06:22.516 --> 00:06:26.854 
你们可以模拟期望中从Siri那里
接收到的意图对象

00:06:26.920 --> 00:06:29.756 
然后 你们可以写一些线下的测试

00:06:31.692 --> 00:06:35.829 
最后 让我们来思考一下
怎样构建你们的应用

00:06:36.029 --> 00:06:37.998 
使其有合理的扩展的数量

00:06:38.932 --> 00:06:42.236 
一般来说 一个应用
会与多个意图关联

00:06:42.302 --> 00:06:44.404 
因为 应用要会执行多个任务

00:06:44.471 --> 00:06:49.610 
例子里独角兽快信使用
SendMessageIntent

00:06:49.676 --> 00:06:52.946 
但让我们假想一下
我们想添加一个新的功能

00:06:53.013 --> 00:06:55.349 
我们可以用它来进行视屏和音频通话

00:06:55.782 --> 00:06:59.319 
那问题是我们如何构建我们的扩展？

00:06:59.553 --> 00:07:03.590 
是否该把操控所有意图的
意图放在一个扩展里？

00:07:03.824 --> 00:07:07.594 
但这样会使我们的代码体积变得庞大
进而难以管理

00:07:08.929 --> 00:07:10.797 
我们可以使用另一种构建

00:07:10.864 --> 00:07:12.299 
虽然不是那么的简洁

00:07:12.366 --> 00:07:17.037 
把所有意图的操控分开
放在独立的扩展里

00:07:17.671 --> 00:07:20.007 
那看起来不错 但你也许会

00:07:20.807 --> 00:07:22.609 
重复写些模版式的代码

00:07:22.676 --> 00:07:25.546 
也会创建一些多余的扩展

00:07:25.612 --> 00:07:28.148 
导致对内存施加不必要的压力

00:07:29.249 --> 00:07:31.385 
那在独角兽快信里

00:07:31.451 --> 00:07:33.987 
我的宗旨是

00:07:34.054 --> 00:07:38.659 
考虑如何将有关系的意图分类到一起

00:07:39.126 --> 00:07:44.531 
在我们的例子里
我们觉得视频和音频的意图

00:07:44.598 --> 00:07:47.568 
可以被自然地分类到同一个扩展里

00:07:47.634 --> 00:07:52.439 
因为这样可以让我们
最大限度地利用代码

00:07:53.307 --> 00:07:58.612 
同时 消息发送的意图
可以被放在一个分开独立的扩展里

00:08:00.147 --> 00:08:03.717 
总而言之 没有一个一劳永逸的办法

00:08:03.784 --> 00:08:05.552 
你们是最了解你们的应用的人

00:08:05.619 --> 00:08:09.223 
你们知道你们的应用
会使用哪些意图

00:08:09.289 --> 00:08:12.659 
那你们需要选择一种构件
它能确保

00:08:12.726 --> 00:08:15.729 
你们的代码容易被管理 同时

00:08:15.796 --> 00:08:19.466 
不会创建过多的扩展
进而 对内存施加不必要的压力

00:08:21.568 --> 00:08:24.238 
经过以上的讨论之后

00:08:24.338 --> 00:08:28.175 
你的应用已准备好采用SiriKit

00:08:28.242 --> 00:08:31.445 
为了帮助我们写我们的第一个意图扩展

00:08:31.512 --> 00:08:33.480 
我邀请Diana上台

00:08:42.990 --> 00:08:43.857 
谢谢Vineet

00:08:48.395 --> 00:08:49.463 
大家好

00:08:49.530 --> 00:08:53.367 
我是Diana Huang
我想在这里和你们聊一下

00:08:53.433 --> 00:08:57.771 
如何创建第一个能与Siri交流
的意图扩展

00:08:57.838 --> 00:09:01.542 
在你们的应用已经完全
准备好采用SiriKit的情况下

00:09:02.342 --> 00:09:07.915 
我也将会用Xcode向你们展示
独角兽快信的例子

00:09:09.416 --> 00:09:15.422 
那让我们现在开始
你们需要遵循有三个步骤

00:09:16.490 --> 00:09:20.761 
首先 你们要添加一个I
意图扩展 target到你的应用

00:09:21.428 --> 00:09:26.433 
接下来 你们要设置这个扩展的
Info.plist

00:09:27.334 --> 00:09:31.972 
最后 你们需要看一下这个扩展的
principal类

00:09:33.006 --> 00:09:35.943 
让我们来分别看一下这三个步骤

00:09:37.778 --> 00:09:40.214 
要添加一个I意图扩展 target

00:09:40.280 --> 00:09:44.818 
你需要依次进入Xcode文件
新建Target

00:09:45.752 --> 00:09:48.989 
然后从列表里选择意图扩展

00:09:49.790 --> 00:09:52.659 
对于你们曾经使用过扩展的人

00:09:52.726 --> 00:09:55.729 
就和创建其它的扩展
targets方式一样

00:09:57.631 --> 00:10:02.002 
现在 让我们来看一下扩展的
Info.plist

00:10:03.737 --> 00:10:06.907 
我们看到现有的
NSExtension关键值

00:10:07.508 --> 00:10:11.078 
然后 在里面我们看到
NSExtensionAttributes

00:10:11.912 --> 00:10:13.480 
在字典里面

00:10:13.547 --> 00:10:17.184 
我们引进两个新的iOS X的关键值

00:10:18.151 --> 00:10:22.189 
分别是IntentsSupported和
IntentsRestricted WhileLocked

00:10:23.624 --> 00:10:27.794 
IntentsSupported
是一个必要的关键值

00:10:27.861 --> 00:10:30.631 
为描述你们的扩展的具体功能

00:10:31.231 --> 00:10:35.202 
换句话说 你们需要将一组
意图类的名字添加到

00:10:35.269 --> 00:10:40.607 
在IntentsSupported
下的一个数组进而才能被扩展支持

00:10:42.309 --> 00:10:46.213 
IntentsRestricted WhileLocked
是一个可选的关键值

00:10:46.280 --> 00:10:48.582 
为描述锁屏状态的行为

00:10:50.250 --> 00:10:54.855 
在默认的情况下
Siri限制了一些特定的域

00:10:54.922 --> 00:10:57.724 
为在锁屏状态下不被随意调用

00:10:58.258 --> 00:11:02.396 
例子有 付款域或图片搜索域

00:11:03.330 --> 00:11:07.568 
但如果你们的应用有比Siri
更高的安全要求

00:11:07.634 --> 00:11:11.905 
那你们可以把想限制的意图类
加入到一个数组

00:11:11.972 --> 00:11:14.174 
在IntentsRestricted
WhileLocked之下

00:11:15.042 --> 00:11:17.945 
这样就可以指示Siri
请提示用户

00:11:18.011 --> 00:11:22.916 
先解除锁屏
再调用你们的扩展来操控意图

00:11:25.152 --> 00:11:28.989 
现在我们扩展的Info.plist
也已经被设置好了

00:11:30.224 --> 00:11:32.559 
接着让我们看看principal类

00:11:33.760 --> 00:11:36.930 
意图扩展的principal类

00:11:36.997 --> 00:11:40.300 
必须是INExtension的子类

00:11:41.034 --> 00:11:45.439 
这样符合INIntentHandlerProviding协议

00:11:46.440 --> 00:11:50.444 
这个协议只有一个叫
handlerForintent的方法

00:11:52.346 --> 00:11:55.215 
这个方法的名字
清楚地解释了它的用途

00:11:55.749 --> 00:12:00.053 
你们有一个意图对象
你们需要返回一个Handler对象

00:12:00.821 --> 00:12:04.558 
请注意返回的Handler对象
必须符合

00:12:04.625 --> 00:12:06.994 
具体的意图操控协议

00:12:08.462 --> 00:12:12.966 
以独角兽快信为例
我们想支持INSendMessageIntent

00:12:13.934 --> 00:12:18.505 
那当任何时候我们传递一个
INSendMessageIntent的实例

00:12:18.939 --> 00:12:24.178 
我们将返回一个符合
INSendMessageIntent操控协议的handler

00:12:26.180 --> 00:12:29.016 
现在我们已经讨论过了所有的三个步骤

00:12:29.383 --> 00:12:33.187 
接下来让我们根据以上的步骤
将独角兽快信在Xcode里打开

00:12:35.556 --> 00:12:40.093 
这里有我们已经在Xcode里
打开了的独角兽快信项目

00:12:40.694 --> 00:12:45.199 
时间关系 我已创建好了意图扩展

00:12:45.799 --> 00:12:48.202 
让我们直接来看一下第二步

00:12:48.402 --> 00:12:51.104 
设置Info.plist

00:12:53.440 --> 00:12:57.911 
首先 让我们将它放大些
那样可以看得更清楚

00:13:02.082 --> 00:13:02.916 
好的

00:13:02.983 --> 00:13:05.786 
在这里我们看见
NSExtension字典

00:13:06.820 --> 00:13:11.859 
如果我们将它展开 你会看到
NSExtensionAttributes字典

00:13:12.726 --> 00:13:15.662 
如果我们进一步地展开这个字典

00:13:15.729 --> 00:13:18.265 
你会看见那两个
我们之前介绍的新关键值

00:13:19.099 --> 00:13:22.970 
IntentsSupported和
IntentsRestricted WhileLocked

00:13:24.505 --> 00:13:28.041 
首先 为了支持
INSentMessageIntent

00:13:28.442 --> 00:13:31.912 
在IntentSupported
数组下添加一个项目

00:13:32.913 --> 00:13:35.148 
我们加入意图类的名字

00:13:35.415 --> 00:13:38.118 
INSendMessageIntent

00:13:39.887 --> 00:13:42.956 
然后 让我们看一下锁屏状态的行为

00:13:44.024 --> 00:13:49.263 
因为独角兽快信
是一款聊天应用

00:13:49.329 --> 00:13:52.132 
被用于独角兽之间的私密交流

00:13:52.199 --> 00:13:54.635 
独角兽们很注重隐私

00:13:54.701 --> 00:13:56.570 
所以 我们决定将它锁定

00:13:56.637 --> 00:13:59.640 
用户需要先将设备解锁

00:13:59.706 --> 00:14:03.110 
才能通过Siri发送
独角兽快信消息

00:14:04.311 --> 00:14:11.151 
为达到效果 我们将在IntentRestricted
WhileLocked的数组下添加一个项目

00:14:11.752 --> 00:14:14.755 
同样的 添加意图类的名字

00:14:15.289 --> 00:14:16.890 
INSendMessageIntent

00:14:18.325 --> 00:14:21.828 
这样我们就完成了对扩展的
Info.plist的设置

00:14:23.630 --> 00:14:29.903 
在第三个步骤里我们看看
扩展的principal类

00:14:31.338 --> 00:14:33.707 
当你们创建意图扩展 target时

00:14:33.974 --> 00:14:37.010 
一个principal类
会被自动地创建

00:14:37.444 --> 00:14:42.449 
我重命名了我的principal类
为UCIntentHandler

00:14:42.716 --> 00:14:45.385 
它是INExtension一个子类

00:14:47.421 --> 00:14:50.290 
这里我们还有意图方法
的handler

00:14:51.859 --> 00:14:55.662 
你可以看到默认的实现返回self

00:14:56.296 --> 00:15:00.934 
它返回一个principal类
本身的实例

00:15:02.202 --> 00:15:04.738 
但为了让我们的代码更清晰

00:15:05.205 --> 00:15:07.074 
更容易被扩张

00:15:07.140 --> 00:15:11.879 
如果我们想将来让这个扩展支持
更多的意图

00:15:12.312 --> 00:15:16.316 
那我们要创建一个独立的
intent handler类

00:15:17.651 --> 00:15:19.219 
我们现在就建立这个类

00:15:20.821 --> 00:15:22.356 
通过创建一个新的文件

00:15:24.758 --> 00:15:27.794 
取名为UCSentMessage
IntentHandler

00:15:30.564 --> 00:15:35.569 
我们也将导入一些框架
然后加入一些类别的声明

00:15:37.571 --> 00:15:40.440 
这里我们导入意图框架

00:15:40.908 --> 00:15:43.343 
它包含许多SiriKit API

00:15:45.345 --> 00:15:48.081 
我们也将UnicornCore
框架导入

00:15:48.515 --> 00:15:51.185 
那是我们创建的embedded
framework

00:15:51.251 --> 00:15:56.089 
通过在应用与扩展之间分享代码

00:15:57.658 --> 00:16:01.395 
这就是我们的
UCSentMessage IntentHandler类

00:16:01.461 --> 00:16:05.065 
它符合
INSentMessage IntentHandling协议

00:16:06.433 --> 00:16:09.269 
好的
现在然我们回到principal类

00:16:09.636 --> 00:16:11.839 
取代这里现有的实现

00:16:12.706 --> 00:16:18.912 
让它为传递进来的意图返回一个
UCSentMessageIntentHandler的实例

00:16:18.979 --> 00:16:21.882 
类型仅限为
INSentMessageIntent

00:16:22.916 --> 00:16:26.119 
至于其它的意图
我们将返回nil

00:16:28.455 --> 00:16:29.356 
大功告成

00:16:29.423 --> 00:16:31.325 
我们的三个步骤

00:16:31.391 --> 00:16:34.761 
用来添加和设置你们的第一个意图扩展

00:16:35.662 --> 00:16:37.831 
现在让我们来看一下应用逻辑

00:16:41.335 --> 00:16:45.472 
希望从SiriKit的简介部分

00:16:45.539 --> 00:16:47.741 
和Vineet的重述

00:16:48.141 --> 00:16:53.480 
意图扩展和Siri的互动
会被分成三个阶段

00:16:53.847 --> 00:16:56.984 
解析和确认
还有处理

00:16:58.318 --> 00:17:00.454 
让我们先来聊一下解析

00:17:02.122 --> 00:17:06.292 
在解析阶段你要确认

00:17:06.359 --> 00:17:11.265 
和理清每一个意图参数值

00:17:12.532 --> 00:17:16.435 
所以 我们给每一个
意图的参数提供了

00:17:16.603 --> 00:17:20.540 
解析方法在意图操控协议里

00:17:21.742 --> 00:17:25.012 
那你们或许会问我们应该
实现它们之间的哪一个？

00:17:25.846 --> 00:17:27.414 
试想

00:17:27.981 --> 00:17:32.019 
你是否需要在Siri的帮助下获取

00:17:32.186 --> 00:17:34.855 
意图参数值的最终值？

00:17:36.023 --> 00:17:37.591 
如果回答是

00:17:37.658 --> 00:17:42.496 
那你或许应该要实现
这个参数的解析方法

00:17:44.231 --> 00:17:48.101 
让我们来看一下
独角兽快信的例子

00:17:49.803 --> 00:17:53.373 
发送消息时 我们需要收件人

00:17:54.341 --> 00:17:58.045 
为了决定最终收件人的值

00:17:58.111 --> 00:18:04.551 
我们需要在独角兽快信
地址簿里查询联系人

00:18:05.819 --> 00:18:09.022 
查询结果可能是多样的

00:18:10.257 --> 00:18:12.426 
在最简单的情况下

00:18:12.492 --> 00:18:14.962 
我们只找到一个联系人

00:18:16.463 --> 00:18:17.598 
任务完成

00:18:18.565 --> 00:18:23.370 
然而 也有可能我们找到
两个或多个联系人

00:18:24.171 --> 00:18:26.340 
在这样的情况下 将会很便捷

00:18:26.406 --> 00:18:31.712 
如果Siri能帮助询问用户
从候选名单里挑出联系人

00:18:33.046 --> 00:18:36.817 
同样也有可能我们没有找到任何联系人

00:18:37.784 --> 00:18:42.189 
在这个情况下
我们也想让Siri告知用户

00:18:42.356 --> 00:18:45.392 
那样用户或许会选一个其它的收件人

00:18:48.061 --> 00:18:53.033 
在选好了一个收件人之后
我们还需要关联的信息

00:18:53.867 --> 00:18:58.272 
在这个情况下
我们只需要获取一个值来继续

00:18:59.473 --> 00:19:02.609 
如果用户没能提供关联的信息

00:19:02.676 --> 00:19:07.548 
那我们希望Siri能帮助
询问关联的信息

00:19:09.183 --> 00:19:11.285 
考虑到以上所有情况

00:19:11.351 --> 00:19:16.523 
听起来好像 我们应该要为
收件人和信息实现解析方法

00:19:16.623 --> 00:19:20.861 
我们的确需要通过Siri的帮助
从用户那取得进一步的输入

00:19:20.928 --> 00:19:25.599 
才能最终决定
这些参数的最后的值

00:19:27.835 --> 00:19:30.771 
现在参数已经成功地决定了

00:19:31.805 --> 00:19:33.774 
我们到了确认阶段

00:19:34.842 --> 00:19:37.878 
在这个阶段你们有必要做一下情景模拟

00:19:38.846 --> 00:19:42.749 
试想若你们正在操控这个意图

00:19:43.050 --> 00:19:44.685 
你们是否有了所有需要的信息？

00:19:45.252 --> 00:19:48.355 
或者 你们是否能够成功地操控它？

00:19:48.989 --> 00:19:52.459 
你们要得到问题的答案外加
一些额外的信息

00:19:52.526 --> 00:19:56.129 
你们可收集这些信息在为
Siri的意图做准备同时

00:19:56.763 --> 00:19:58.832 
那样Siri才会适时地

00:19:58.999 --> 00:20:01.735 
传达这些信息给用户

00:20:02.469 --> 00:20:04.938 
最终用户才能做出相应的决定

00:20:05.005 --> 00:20:09.142 
关于是否想继续他们的活动

00:20:10.310 --> 00:20:11.845 
在独角兽快信里

00:20:11.912 --> 00:20:14.948 
由于我们的安全要求

00:20:15.015 --> 00:20:19.019 
我们需要用户时不时地
重新验证身份

00:20:19.853 --> 00:20:22.122 
所以确认是最合适的阶段

00:20:22.189 --> 00:20:25.659 
让我们检验用户的身份状态

00:20:26.693 --> 00:20:31.665 
不管如何 我们都想告诉Siri
状态检验的结果

00:20:31.732 --> 00:20:36.203 
这样Siri就可以
让用户在Siri内部继续

00:20:36.270 --> 00:20:41.642 
或许调出应用结束本次Siri操作

00:20:43.510 --> 00:20:46.413 
好的
现在意图也已经被确认

00:20:47.014 --> 00:20:50.651 
我们来到了最后阶段
操控它

00:20:51.018 --> 00:20:54.688 
但愿这是简单直接的 对你们来说
最好理解的阶段

00:20:55.289 --> 00:20:59.193 
你只需执行行动
然后告诉Siri结果

00:21:00.827 --> 00:21:02.796 
在独角兽快信里

00:21:02.863 --> 00:21:05.232 
我们就只要发送消息

00:21:05.299 --> 00:21:09.636 
然后 报告消息是否被成功发送

00:21:11.071 --> 00:21:17.711 
讲了解析和确认
还有处理方法与有关的概念

00:21:18.045 --> 00:21:20.614 
让我们用Xcode实现它们

00:21:31.959 --> 00:21:36.363 
这次我们将直接从
IntentHandler类开始

00:21:37.731 --> 00:21:40.767 
在开始之前 一个提醒

00:21:40.834 --> 00:21:44.338 
所有这些简单的代码都会上传

00:21:44.404 --> 00:21:47.841 
如果我跳过一些细节
那或许意味着

00:21:47.908 --> 00:21:50.143 
对于你们 那部分代码
相对来说没那么重要

00:21:50.210 --> 00:21:52.412 
目前 无需看懂那部分的每行代码

00:21:52.746 --> 00:21:55.616 
但如果你们感兴趣
你们一直都可以回到网上

00:21:55.782 --> 00:21:58.652 
然后自己查阅这简单的项目

00:21:59.486 --> 00:22:00.320 
好的

00:22:00.687 --> 00:22:02.523 
像之前所提及的

00:22:02.589 --> 00:22:06.727 
我们将实现解析和
确认和处理方法

00:22:07.528 --> 00:22:13.200 
我们将为收件人和
信息实现解析方法

00:22:14.434 --> 00:22:17.004 
让我们从resolveRecipients入手

00:22:19.840 --> 00:22:24.378 
在这个方法里我们要注意
recipients这个参数

00:22:24.678 --> 00:22:28.015 
它由一个INPerson的数组代表

00:22:29.149 --> 00:22:31.885 
你们也可以从这个方法的签名看出

00:22:31.952 --> 00:22:37.724 
你们需要使用这一个数组的
解决结果进行回调

00:22:38.992 --> 00:22:41.929 
所以 有一个一一对应的映射关系

00:22:42.296 --> 00:22:46.567 
在recipients数组与
解决结果数组之间

00:22:47.201 --> 00:22:52.673 
这意味着为每一个收件人 你们要创建一个
PersonResolutionResult

00:22:53.473 --> 00:22:54.942 
这里唯一的特例是

00:22:55.008 --> 00:22:58.779 
当你想创建
ResolutionResultNeedsValue

00:22:58.846 --> 00:23:00.747 
或ResolutionResultNotRequired的时候

00:23:01.315 --> 00:23:05.118 
这两类型的
resolutionResults

00:23:05.185 --> 00:23:11.692 
是在参数层面的解析 而其他的
resolutionResults

00:23:11.758 --> 00:23:16.396 
是更多的注重于个别参数值

00:23:17.998 --> 00:23:21.068 
那在这个方法里
首先我们要

00:23:22.569 --> 00:23:25.672 
试着打开Recipients对象

00:23:26.740 --> 00:23:30.310 
然后我们将循环依次获取
每一个收件人

00:23:30.811 --> 00:23:34.348 
然后调出在UnicornCore
框架里的 API

00:23:34.615 --> 00:23:37.451 
根据名字寻找相应的联系人

00:23:39.686 --> 00:23:44.691 
接下来我们将用一个switch语句
在核对查找联系人的数量上

00:23:45.926 --> 00:23:50.998 
如之前所提到的
我们将考虑不同的查找情况

00:23:51.899 --> 00:23:54.635 
两个或多个相符的联系人

00:23:54.701 --> 00:23:57.471 
只有一个相符的联系人

00:23:57.638 --> 00:24:00.307 
没有相符的联系人

00:24:02.676 --> 00:24:06.547 
如果我们找到了两个或更多的联系人

00:24:07.014 --> 00:24:11.919 
我们将创建一个PersonResolution
Result.disambiguation

00:24:11.985 --> 00:24:13.954 
用我们所找到的结果

00:24:16.190 --> 00:24:19.593 
如果我们只找到了一个联系人

00:24:19.993 --> 00:24:21.028 
我们就可以继续

00:24:21.094 --> 00:24:26.233 
我们可以告诉Siri通过创建一个
PersonResolutionResult.success

00:24:26.533 --> 00:24:28.735 
用那一个我们找到的人

00:24:31.071 --> 00:24:34.374 
如果我们没有找到联系人

00:24:35.042 --> 00:24:38.278 
我们将创建一个PersonResolution
Result.unsupported

00:24:41.248 --> 00:24:43.884 
我们switch语句在此结束

00:24:46.153 --> 00:24:49.656 
你们或许感觉到
我讲解这些代码的速度很快

00:24:49.723 --> 00:24:53.093 
以至于你没有机会读每一行代码

00:24:53.360 --> 00:24:55.062 
那没有什么问题

00:24:55.128 --> 00:24:57.931 
因为只要你能明白

00:24:57.998 --> 00:25:01.568 
我们有不同的
resolutionResults

00:25:01.635 --> 00:25:04.738 
它们适用于不同的情况

00:25:05.239 --> 00:25:10.577 
当你们自己为结果方法实现
你们的代码逻辑

00:25:10.644 --> 00:25:13.447 
你们可以上网查阅关于
resolutionResults的资料

00:25:13.514 --> 00:25:16.383 
完整的关于
resolutionResults的列表

00:25:16.817 --> 00:25:19.152 
然后还有它们的用途

00:25:20.521 --> 00:25:21.421 
好的

00:25:21.855 --> 00:25:25.359 
现在我们有了所有的
resolutionResults

00:25:25.425 --> 00:25:28.428 
那些我们为
recipients所创建的

00:25:29.263 --> 00:25:33.834 
至此 我们完成了对
resolutionResults数组的构建

00:25:35.702 --> 00:25:39.806 
这样我们也就完成了最后一行代码
给在我们能

00:25:39.873 --> 00:25:42.276 
从意图获取一些收件人的情况

00:25:43.377 --> 00:25:48.215 
但在如果用户根本没有收件人

00:25:49.349 --> 00:25:53.587 
那我们将创建一个
PersonResolution Result.needsValue

00:25:53.820 --> 00:25:59.726 
然后结束流程 告诉Siri
请提示用户输入收件人

00:26:02.029 --> 00:26:05.299 
以上就是我们result recipients的方法

00:26:06.700 --> 00:26:10.137 
接下来 我们来实现
resolveContent方法

00:26:10.204 --> 00:26:14.107 
我将检查值是否存在

00:26:14.174 --> 00:26:15.442 
如果不存在

00:26:15.509 --> 00:26:19.947 
我们指示Siri
请帮助我们提示用户

00:26:25.519 --> 00:26:28.088 
我们在resolveContent
里首先做的

00:26:28.155 --> 00:26:32.025 
还是试着拆包
这个content属性

00:26:32.893 --> 00:26:35.529 
然后查看它
是否真的不为空

00:26:36.463 --> 00:26:39.066 
如果content确实已经给定

00:26:39.533 --> 00:26:42.102 
建立ResolutionResult.success

00:26:42.503 --> 00:26:43.971 
通过已有的content

00:26:45.672 --> 00:26:50.310 
否则 我们就创建
ResolutionResult.needsValue

00:26:50.377 --> 00:26:52.980 
就像我们在之前那个
解析方法里做的一样

00:26:54.414 --> 00:26:56.550 
并以它为参数
调用completion函数

00:26:59.286 --> 00:27:02.389 
现在我们两个解析方法
都已经领略了

00:27:03.023 --> 00:27:05.726 
下面我们来看确认方法

00:27:05.792 --> 00:27:09.730 
我们用它来查看
用户的认证状态

00:27:17.237 --> 00:27:18.739 
在确认方法里

00:27:19.139 --> 00:27:24.511 
我们就调用Unicorn Core framework
里的shared API来查看

00:27:24.578 --> 00:27:27.981 
用户是否还有
有效的认证状态

00:27:29.082 --> 00:27:30.551 
如果他/她有的话

00:27:30.617 --> 00:27:34.621 
那我们就创建一个
INSentMessageIntentResponse

00:27:35.022 --> 00:27:38.759 
其code参数为success
而userActivity参数是nil

00:27:39.860 --> 00:27:43.363 
我一会儿会讲解
怎么用这个userActivity

00:27:45.332 --> 00:27:47.034 
不过我们先来看这个情况

00:27:47.100 --> 00:27:49.536 
用户不再是已认证的状态

00:27:50.437 --> 00:27:54.408 
在这种情况下 我们就创建一个
IntentResponse

00:27:54.474 --> 00:27:57.678 
code是
.failureRequiringAppLaunch

00:27:58.612 --> 00:28:02.850 
所以这就是要告诉Siri
Siri应该提供一个选项

00:28:03.050 --> 00:28:06.720 
让用户可以进入到
我们的主应用

00:28:06.787 --> 00:28:10.591 
来登录并完成
这个发送操作

00:28:15.963 --> 00:28:19.132 
好的 以上这些就是
我们的确认方法

00:28:19.900 --> 00:28:23.837 
最后 我们一起来实现处理方法

00:28:29.676 --> 00:28:32.713 
在处理里
我们就调用

00:28:32.779 --> 00:28:36.650 
UnicornCore框架里的
shared API

00:28:37.017 --> 00:28:41.421 
来用给定的content和
recipients发送信息

00:28:42.556 --> 00:28:45.993 
我们还要获取
发送操作的状态

00:28:47.561 --> 00:28:50.230 
如果信息成功发送

00:28:50.531 --> 00:28:54.801 
创建一IntentResponse
并以success作为code参数

00:28:55.536 --> 00:28:59.673 
否则就以failure作为code
参数来创建response对象

00:29:00.407 --> 00:29:03.911 
调用completion并
赋给它IntentResponse

00:29:06.647 --> 00:29:12.152 
至此 我们一起讨论了解析
确认和处理方法

00:29:13.453 --> 00:29:18.158 
现在我履行之前的承诺
来讲解NSUserActivity

00:29:18.225 --> 00:29:21.762 
那些IntentResponse
的初始化方法会用到它

00:29:24.565 --> 00:29:26.967 
我们暂时先抛开
Xcode

00:29:36.944 --> 00:29:38.979 
说到NSUserActivity

00:29:40.247 --> 00:29:42.583 
在SiriKit的背景下

00:29:42.649 --> 00:29:47.688 
NSUserActivity被用来
帮你的应用恢复状态

00:29:47.855 --> 00:29:51.558 
用于它被Siri或者用户
启用的时候

00:29:52.860 --> 00:29:57.064 
默认情况下 Siri会给你创建
一个NSUserActivity

00:29:57.431 --> 00:30:02.402 
这是在你决定把nil赋给
IntentResponse的初始化方法时的情况

00:30:04.137 --> 00:30:09.009 
并且 Siri在创建它时会以
ActivityType作为intent的类名

00:30:10.277 --> 00:30:13.280 
你还可以选择用
你自己的UserActivity

00:30:13.580 --> 00:30:15.849 
比如你想要加入一些自定义数据

00:30:17.518 --> 00:30:22.523 
但不论如何 Siri都会将
INInteraction属性设定

00:30:22.589 --> 00:30:24.725 
在NSUserActivity
对象上

00:30:25.259 --> 00:30:28.228 
这个属性是在iOS X里新引进的

00:30:29.463 --> 00:30:35.402 
而且这个对象有意图
IntentResponse

00:30:35.469 --> 00:30:37.871 
还有意图处理的状态

00:30:38.372 --> 00:30:42.109 
Scott一会儿会更详细讲这个对象

00:30:43.377 --> 00:30:49.283 
现在我们再来看看NSUserActivity
在我们程序里的用法

00:30:50.751 --> 00:30:53.120 
如果你比较细心地看了这段程序的话

00:30:53.587 --> 00:30:56.990 
你可能会发现在确认
和处理方法里

00:30:57.057 --> 00:30:58.959 
我们一直把nil

00:30:59.426 --> 00:31:04.031 
作为userActivity参数赋给我们的
IntentResponse初始化方法

00:31:04.398 --> 00:31:05.933 
这样做完全没问题

00:31:06.233 --> 00:31:09.970 
这是在假设我们的主应用会处理
UserActivity的情况下

00:31:10.070 --> 00:31:15.342 
就是Siri用INInteraction对象
帮我们创建的UserActivity

00:31:16.944 --> 00:31:19.680 
不过在一些情况下 比较有用的做法是

00:31:19.780 --> 00:31:25.519 
给我们的应用加入
一些扩展过程中的自定义字符串

00:31:26.520 --> 00:31:28.055 
比如说

00:31:29.823 --> 00:31:31.358 
在确认方法里

00:31:31.592 --> 00:31:36.597 
当我们发现用户不再是
已登录或已认证的状态时

00:31:37.397 --> 00:31:41.935 
我们便需要将一些显示错误的
字符串加入到我们的主应用里

00:31:42.236 --> 00:31:45.572 
具体做法是我们创建自己的
userActivity

00:31:46.907 --> 00:31:49.343 
并在.userInfo字典里设定

00:31:50.577 --> 00:31:54.982 
我们想要给我们主应用
加入的显示错误的自定义字符串

00:31:55.716 --> 00:31:59.052 
然后我们把nil删掉 取而代之的是
userActivity

00:31:59.152 --> 00:32:00.554 
就是我们刚创建的那个

00:32:02.656 --> 00:32:03.857 
好的 很好

00:32:03.924 --> 00:32:07.961 
所以现在我的
独角兽快信主应用有了

00:32:08.028 --> 00:32:13.433 
这些显示错误的自定义字符串
并且会提示用户登录

00:32:13.500 --> 00:32:18.305 
这是在用户或者Siri此时
要启动应用的情况下

00:32:19.706 --> 00:32:22.910 
现在我们完成了
意图扩展的所有编程

00:32:23.343 --> 00:32:25.779 
我们来看看它真正在设备上
运行的效果

00:32:28.849 --> 00:32:32.419 
用独角兽快信给Scott发一条短信

00:32:32.486 --> 00:32:35.155 
说
你准备好你的演示了吗

00:32:41.428 --> 00:32:42.296 
没错

00:32:48.468 --> 00:32:49.436 
好的
谢谢

00:32:49.636 --> 00:32:51.205 
是的 这个非常振奋人心

00:32:51.271 --> 00:32:55.342 
我们刚用Siri发送了第一条
独角兽快信信息

00:32:55.442 --> 00:32:56.944 
这绝对是棒棒哒

00:33:00.280 --> 00:33:01.114 
谢谢

00:33:05.319 --> 00:33:08.622 
不过 在独角兽快信的主应用里

00:33:08.822 --> 00:33:11.391 
当我给我的独角兽小伙伴们
发短信时

00:33:11.458 --> 00:33:14.695 
我会经常用
他们的独角兽昵称

00:33:15.295 --> 00:33:17.397 
所以我实际上想跟Siri说

00:33:17.464 --> 00:33:21.134 
给Sparkle Sparkly
发一条短信说你准备好演讲了吗

00:33:21.702 --> 00:33:24.972 
显然Sparkle Sparkly
是Scott的独角兽昵称

00:33:25.939 --> 00:33:29.776 
要实现这个功能
我们就要进入我们下一个话题

00:33:29.910 --> 00:33:32.212 
就是用户特定词汇

00:33:34.481 --> 00:33:35.315 
是的

00:33:35.382 --> 00:33:36.884 
用户特定词汇

00:33:38.252 --> 00:33:39.086 
那么

00:33:39.720 --> 00:33:45.726 
这是一些自定义单词或短语
它们对于你的应用独一无二

00:33:45.792 --> 00:33:48.295 
并且因人而异

00:33:49.129 --> 00:33:50.931 
在我刚给的例子中

00:33:50.998 --> 00:33:54.001 
Sparkle Sparkly
以及其他独角兽昵称

00:33:54.067 --> 00:33:57.337 
在这儿都可以作为
用户特定词汇

00:33:58.872 --> 00:34:03.410 
而要让Siri
理解用户

00:34:03.477 --> 00:34:06.346 
所说的
这些自定义词汇

00:34:06.413 --> 00:34:08.215 
你需要把它们提供给Siri

00:34:08.982 --> 00:34:15.255 
你要从你的主应用调用
INVocabulary API

00:34:15.856 --> 00:34:17.123 
我重复一遍

00:34:17.190 --> 00:34:20.127 
你要调用
INVocabulary API

00:34:20.194 --> 00:34:23.397 
从你的主应用里调用
而不是从你的扩展里调用

00:34:25.299 --> 00:34:29.036 
好我们来看看我们在独角兽快信
怎么做到的

00:34:31.338 --> 00:34:35.141 
在独角兽快信里我们有
UCAddressBookManager

00:34:35.609 --> 00:34:38.545 
它管理独角兽快信
自己的联系记录

00:34:39.413 --> 00:34:41.215 
而我们创建了这个方法

00:34:41.748 --> 00:34:45.351 
来更新Siri
让Siri知道独角兽昵称

00:34:45.985 --> 00:34:50.757 
而一旦哪个联系记录被添加 删除
或更新时 这个方法就会被调用

00:34:52.125 --> 00:34:54.594 
在这个方法里我们
首先想做的是

00:34:54.728 --> 00:34:58.131 
获得一个排好序的
独角兽昵称列表

00:34:59.032 --> 00:35:02.970 
并且 我们把更重要的独角兽昵称
列在前面

00:35:03.570 --> 00:35:07.207 
把相对不重要的
放在列表后面

00:35:08.275 --> 00:35:12.212 
像这样优先处理 我们就能帮Siri

00:35:12.279 --> 00:35:17.017 
更好地对独角兽昵称进行
优先学习和配对处理

00:35:18.519 --> 00:35:21.855 
在整理好
这个独角兽昵称的有序列表后

00:35:22.122 --> 00:35:26.760 
我们调用INVocabulary
API来把它们提供给Siri

00:35:27.761 --> 00:35:31.765 
我们还要给它提供
这些字符串的词汇类别

00:35:31.965 --> 00:35:35.969 
在这个例子里独角兽昵称的类别是
Type.contentName

00:35:38.071 --> 00:35:42.376 
关于这段程序 我想最后提一点
让你们注意

00:35:43.277 --> 00:35:48.015 
就是我们要将所有这些操作
分派到不同的任务队列里

00:35:49.283 --> 00:35:54.555 
这是因为
像获取你整个联系列表这样的操作

00:35:54.621 --> 00:35:58.926 
会特别昂贵
而你不想因为这个来阻碍你的主线程

00:35:59.793 --> 00:36:03.096 
所以请务必用GCD

00:36:03.397 --> 00:36:08.368 
分派这些昂贵的操作
到不同的任务队列

00:36:09.269 --> 00:36:10.204 
好的

00:36:10.270 --> 00:36:15.342 
现在 在我们采用了
用户特定词汇API后

00:36:15.409 --> 00:36:19.379 
我可以发信息给
Sparkle Sparkly和Celestra

00:36:19.446 --> 00:36:22.683 
还有Buttercup
以及我所有的独角兽小伙伴们

00:36:22.749 --> 00:36:24.785 
这绝对是棒棒哒

00:36:27.788 --> 00:36:31.525 
现在我又有另外一个功能请求

00:36:32.226 --> 00:36:34.862 
在独角兽快信里

00:36:34.928 --> 00:36:37.698 
这个应用的画风

00:36:37.764 --> 00:36:42.803 
实际上比你在Siri这儿看到的
还要五彩斑斓 像彩虹一样

00:36:43.971 --> 00:36:47.274 
那么 我能让我在Siri里的
独角兽快信体验

00:36:47.341 --> 00:36:52.613 
和在独角兽快信
主应用里的一样色彩缤纷吗

00:36:53.347 --> 00:36:56.984 
关于这个话题 我现在邀请我的队友

00:36:57.050 --> 00:37:00.521 
Scott也就是Sparkle Sparkly上台

00:37:03.390 --> 00:37:04.424 
下午好

00:37:04.625 --> 00:37:07.528 
我是Scott Andrus
SiriKit的工程师

00:37:08.662 --> 00:37:10.998 
现在我们来讲讲
如何让这个过程

00:37:11.064 --> 00:37:13.233 
感觉更像是跟独角兽快信互动

00:37:14.101 --> 00:37:18.172 
要做到这一点我们要用SiriKit
来建立一个用户界面扩展

00:37:19.239 --> 00:37:23.110 
在iOS X里 我们引进了
意图用户界面扩展点

00:37:23.644 --> 00:37:26.246 
它能让你创建
很赞的用户界面扩展

00:37:26.313 --> 00:37:30.117 
来在Siri体验里
提供自定义的用户界面

00:37:30.817 --> 00:37:32.252 
那么 让我们开始吧

00:37:33.353 --> 00:37:35.122 
你可能想这么做的原因是

00:37:35.622 --> 00:37:39.760 
用户界面扩展能增加你的应用
对用户的影响

00:37:40.627 --> 00:37:42.963 
通过引入一个用户界面扩展

00:37:43.564 --> 00:37:46.967 
你可以在Siri体验的基础上
展示你的视图

00:37:47.301 --> 00:37:50.103 
然后 你可以融入自定义的体验

00:37:50.170 --> 00:37:54.174 
这些体验相对Siri通常显示而言
对你的应用更为独特

00:37:55.375 --> 00:37:58.345 
这会给开发你的应用
带来很多很好的机会

00:37:58.679 --> 00:38:02.149 
这些机会具有独特性
能让你的应用脱颖而出

00:38:03.951 --> 00:38:06.687 
你还可以提供用户定制

00:38:06.920 --> 00:38:10.224 
让你可以跟用户一对一互动

00:38:11.959 --> 00:38:15.495 
最后 你可以显示
Siri不会显示的信息

00:38:15.996 --> 00:38:18.232 
这是你的工具库里很好的帮手

00:38:20.701 --> 00:38:22.102 
还有 它长这个样儿

00:38:24.338 --> 00:38:29.109 
那么首先 你要做的就是
添加一个意图用户界面扩展

00:38:30.143 --> 00:38:31.912 
把它加到你的项目里

00:38:34.448 --> 00:38:36.617 
并把它嵌入你应用的包裹里

00:38:38.952 --> 00:38:42.089 
你便会看到Xcode给你
生成的Info.plist文件

00:38:43.090 --> 00:38:46.560 
在里面 你需要找到新的
IntentsSupported关键词

00:38:46.727 --> 00:38:49.696 
和你在意图扩展看到的类似

00:38:50.264 --> 00:38:52.466 
在里面 你要设置一个意图

00:38:52.533 --> 00:38:56.370 
用它来在Siri体验中
展示自定义的用户界面

00:38:59.806 --> 00:39:03.477 
用户界面扩展在SiriKit中的
结构其实很简单

00:39:04.945 --> 00:39:08.015 
SiriKit针对你的用户界面扩展

00:39:08.081 --> 00:39:10.450 
用互动配置

00:39:10.517 --> 00:39:13.987 
这个SiriKit 用户界面扩展里
很关键的方法

00:39:15.322 --> 00:39:17.291 
你的用户界面扩展有一个主要类

00:39:17.824 --> 00:39:22.663 
它是UIViewController
遵循INUIHostedViewControlling协议

00:39:24.264 --> 00:39:26.900 
它会将一个
INInteraction对象

00:39:27.234 --> 00:39:29.870 
在配置这一步赋给
你的用户界面扩展

00:39:32.139 --> 00:39:33.607 
现正如Diana提到的那样

00:39:34.408 --> 00:39:37.211 
INInteraction类
定义一个对象

00:39:37.411 --> 00:39:39.746 
它涵盖三个重要的属性

00:39:40.347 --> 00:39:43.617 
第一个是意图对象
它要经过确认

00:39:43.684 --> 00:39:46.053 
或者被你的意图扩展处理

00:39:47.154 --> 00:39:47.988 
第二个属性就是

00:39:48.055 --> 00:39:52.759 
Intent response对象
你的意图扩展把它传给Siri 通过

00:39:52.826 --> 00:39:55.596 
确认和处理的
completion

00:39:56.663 --> 00:40:00.067 
最后一个属性是意图处理状态
一个enum值

00:40:00.400 --> 00:40:02.469 
它描述互动的状态

00:40:02.569 --> 00:40:04.538 
是你的应用和Siri间的互动

00:40:05.772 --> 00:40:08.375 
这些实现起来
都是非常有用的属性

00:40:08.742 --> 00:40:11.578 
对你给Siri制作用户界面很有帮助

00:40:15.148 --> 00:40:20.487 
你的视图控制器是操纵用户界面扩展的
途径 它作为一个主要类

00:40:20.554 --> 00:40:22.789 
你要用到它来创建你的用户界面
它作为

00:40:24.191 --> 00:40:26.126 
UIViewController子类

00:40:26.527 --> 00:40:30.564 
你就可以用你可能习惯用的
所有UIKit的强大功能

00:40:30.631 --> 00:40:34.067 
就像创建Cocoa Touch
应用的用户界面一样

00:40:36.036 --> 00:40:38.038 
接着 用“互动”
对象给它配置

00:40:38.105 --> 00:40:40.607 
对象由Siri经“互动配置”传给你

00:40:42.876 --> 00:40:43.944 
此外 还有别的一些参数

00:40:44.011 --> 00:40:46.346 
在这个方法里可能值得你注意

00:40:46.413 --> 00:40:49.650 
其中一个是
providedViewContext参数

00:40:50.584 --> 00:40:54.321 
而在iOS X里 这是一个enum值
它在两个可能值中取其一

00:40:55.022 --> 00:40:57.558 
Siri snippet或
maps card

00:40:58.559 --> 00:41:01.094 
所以你可以给你的界面
进行不同的配置

00:41:01.161 --> 00:41:03.830 
针对这些模态视图跟用户间
不同的互动方式

00:41:04.531 --> 00:41:08.001 
而且如果你要做一个订车扩展
这个会对你很有帮助

00:41:10.571 --> 00:41:11.505 
最后

00:41:11.905 --> 00:41:14.908 
你会有一个completion
你调用它来让Siri知道

00:41:14.975 --> 00:41:18.212 
你已经完成对用户界面的配置

00:41:18.278 --> 00:41:20.280 
你要返回一个
desiredSize

00:41:20.647 --> 00:41:23.517 
告诉Siri怎样在Siri
snippet调节视图的大小

00:41:24.952 --> 00:41:26.820 
我想我们已经知道
所有要知道的东西

00:41:27.354 --> 00:41:31.692 
示范如何给独角兽快信建立
一个SiriKit 用户界面扩展

00:41:32.893 --> 00:41:33.727 
好

00:41:34.161 --> 00:41:38.031 
我们回到Diana给我们铺垫的
这个很棒的项目

00:41:38.098 --> 00:41:42.536 
项目用到了我们的Siri扩展
它让我们能将应用嵌入Siri体验中

00:41:43.070 --> 00:41:45.873 
我们在意图用户界面扩展上
更进一步

00:41:46.740 --> 00:41:49.643 
当Diana创建她的
Siri扩展对象时

00:41:49.977 --> 00:41:53.580 
我们可以配套创建一个
意图用户界面扩展对象

00:41:54.181 --> 00:41:56.183 
Xcode建了个分组
专门在左边这儿的

00:41:56.250 --> 00:41:58.752 
项目导航器建给Siri
用户界面扩展

00:41:59.853 --> 00:42:00.921 
我们打开它

00:42:01.321 --> 00:42:05.025 
可看到一些很赞的文件让我们
能开始编意图用户界面扩展

00:42:06.326 --> 00:42:08.328 
首先是
IntentViewController类

00:42:08.562 --> 00:42:10.697 
它是我们扩展的主要类

00:42:12.032 --> 00:42:13.967 
还有给这个类的storyboard

00:42:14.968 --> 00:42:17.571 
以及Info.plist
我们先来研究这个

00:42:17.804 --> 00:42:20.140 
用它来设定我们支持的意图

00:42:22.643 --> 00:42:23.810 
在这里面

00:42:25.145 --> 00:42:28.749 
NSExtension字典里有个
IntentsSupported列表

00:42:30.217 --> 00:42:32.152 
我直接在这儿加一个条目

00:42:32.653 --> 00:42:35.455 
现在 关于意图用户界面扩餐
我们想做的

00:42:35.789 --> 00:42:39.560 
是在Siri显示结果时
给用户展示一个用户界面

00:42:40.160 --> 00:42:42.563 
用来给其他独角兽发信息

00:42:43.397 --> 00:42:44.398 
而当显示这个界面时

00:42:44.464 --> 00:42:46.834 
我们希望它是
一个聊天记录界面

00:42:47.234 --> 00:42:51.071 
希望它能彰显我们应用的
“独角兽性质”

00:42:52.940 --> 00:42:59.379 
所以在这里面 我要给
INSendMessageIntent添加支持

00:42:59.847 --> 00:43:02.583 
声明我们要
展示一个用户界面

00:43:02.749 --> 00:43:05.052 
在Siri给我们的应用
处理意图时显示

00:43:06.787 --> 00:43:08.589 
好 编好Info.plist后

00:43:08.655 --> 00:43:10.991 
我们来实现
IntentViewController

00:43:12.693 --> 00:43:13.861 
我缩小页面回来

00:43:14.461 --> 00:43:16.430 
这儿有我们的IntentViewController类

00:43:17.231 --> 00:43:20.200 
注意到这是一个
UIViewController的子类

00:43:20.267 --> 00:43:23.170 
遵循INUIHostedViewControlling协议

00:43:23.704 --> 00:43:26.507 
既然遵循协议
就要相应地对它进行配置

00:43:26.573 --> 00:43:29.443 
要用“互动”
这儿程序把它作为模块提供给我

00:43:31.011 --> 00:43:32.813 
现在我首先要做的

00:43:33.180 --> 00:43:38.252 
是把UnicornCore框架
作为模块导入我的Swift文件

00:43:39.086 --> 00:43:41.021 
值得重申的是
这个UnicornCore框架

00:43:41.154 --> 00:43:43.624 
是我们给我们应用
实现的框架

00:43:43.690 --> 00:43:47.327 
所有独角兽应用都用到它
如Unicorn Pay或Unicorn Rides

00:43:47.394 --> 00:43:52.766 
这是给我们的应用和扩展
共享程序的很好的方法

00:43:53.133 --> 00:43:57.171 
我们在Diana的演示中已经
很好地用了它来共享

00:43:57.237 --> 00:44:00.741 
扩展中解析 确认
和处理的业务逻辑

00:44:01.208 --> 00:44:03.644 
现在我们想用它来共享用户界面

00:44:03.744 --> 00:44:05.879 
针对我们的用户界面扩展和应用

00:44:06.013 --> 00:44:08.348 
以此达到我们会有熟悉感觉的效果

00:44:08.415 --> 00:44:11.318 
不论我们在哪儿发送
独角兽快信信息

00:44:16.256 --> 00:44:19.059 
我们来开始实现“互动配置”方法

00:44:21.495 --> 00:44:22.930 
在这里面

00:44:22.996 --> 00:44:25.065 
我直接设置一个size变量

00:44:25.132 --> 00:44:28.202 
一旦我完成配置后
就把它返回给Siri

00:44:30.037 --> 00:44:33.207 
现在我要查看
interaction.representsSendMessageIntent是否为真

00:44:33.941 --> 00:44:36.877  
这儿的用法很方便
因为我已把它实现为类扩展

00:44:36.944 --> 00:44:39.880  
以UnicornCore framework里的
INinteraction为基础

00:44:44.117 --> 00:44:46.486  
然后 我建一个
chatViewController实例

00:44:46.854 --> 00:44:50.157 
我们用它来代表
一个信息发送界面

00:44:50.224 --> 00:44:51.825 
我们两个独角兽快信
应用都用上

00:44:51.892 --> 00:44:54.328 
而且我们也要在我们的
用户界面扩展这儿使用

00:44:57.631 --> 00:44:59.132  
我们来配置chatViewController

00:44:59.199 --> 00:45:01.835  
用“配置”的
messageContent

00:45:01.902 --> 00:45:05.038  
我还是用类扩展从“互动”中获取它

00:45:08.008 --> 00:45:10.511  
建一个UCContact模型对象

00:45:10.844 --> 00:45:13.046  
它基于“互动”的属性

00:45:13.347 --> 00:45:16.283  
接着 我把模型对象
赋给chatViewController

00:45:16.350 --> 00:45:18.519  
来显示信息的收件人

00:45:21.588 --> 00:45:23.056  
最后 我用switch语句

00:45:23.123 --> 00:45:25.225  
判断“互动”的
intentHandlingStatus

00:45:25.626 --> 00:45:28.595 
我们可以以此对我们的
用户界面进行不同的配置

00:45:28.662 --> 00:45:30.864 
以信息是否已经
发送出去作为基础

00:45:31.398 --> 00:45:34.935 
比如在这个例子中
如果信息未发送

00:45:35.002 --> 00:45:39.473  
即intentHandlingStatus
是unspecified inProgress或ready

00:45:39.973 --> 00:45:43.277  
就把chatViewController的
isSent设为假

00:45:43.710 --> 00:45:47.681  
这说明我应该设定一个草稿式界面
显示给用户

00:45:48.515 --> 00:45:51.218  
否则 如果发送已经完成
我可以将isSent

00:45:51.285 --> 00:45:53.020  
在chatViewController里设为真

00:45:53.320 --> 00:45:56.390  
表明我已经发了信息
而且要让用户也知道

00:46:00.093 --> 00:46:02.963  
最后我就呈现chatViewController
它是一个子控制器

00:46:03.030 --> 00:46:05.199  
其母控制器是这个
IntentViewController主要类

00:46:05.499 --> 00:46:06.800  
这是一个很有用的方法

00:46:07.100 --> 00:46:09.102  
来实现不同的视图控制器

00:46:09.169 --> 00:46:11.672  
针对我用户界面扩展里的
不同意图

00:46:14.341 --> 00:46:15.175  
最后

00:46:15.442 --> 00:46:19.947  
我可以用iOS X里用户界面扩展的
NSExtensionContext

00:46:20.981 --> 00:46:22.249 
来得到一个最大的大小

00:46:22.316 --> 00:46:25.853 
然后我默认地把它用在
我的独角兽快信里

00:46:28.288 --> 00:46:30.624  
如因某些原因
得不到extensionContext

00:46:30.858 --> 00:46:33.994  
我就用chatViewController的
desiredSize

00:46:34.061 --> 00:46:34.995  
它对我来说够好了

00:46:38.866 --> 00:46:40.200 
这是比较乐观的一种情形

00:46:40.467 --> 00:46:43.337 
假如什么出了错
给我们意想不到的“互动”

00:46:44.104 --> 00:46:45.772 
我们可以设大小为0

00:46:45.839 --> 00:46:50.110 
让Siri不要在Siri snippet里
画我们用户界面扩展的视图

00:46:52.479 --> 00:46:53.313  
好

00:46:53.714 --> 00:46:55.048  
我最后要做的

00:46:55.115 --> 00:46:58.752  
是告诉Siri我已经完成实现

00:46:58.819 --> 00:47:00.821  
和配置我的用户界面

00:47:01.188 --> 00:47:03.690  
这样它就会在Siri
snippet里给我们展示

00:47:05.859 --> 00:47:06.693 
好

00:47:06.760 --> 00:47:09.229 
我有这段程序的一个版本
在我的设备上运行

00:47:09.596 --> 00:47:10.998 
我们现在来看看它是怎么样的

00:47:16.737 --> 00:47:18.939 
你可以看到
我有独角兽快信应用

00:47:19.673 --> 00:47:21.375 
我准备发信息给Diana

00:47:23.744 --> 00:47:27.347 
用独角兽快信
发信息给Diana说

00:47:27.414 --> 00:47:29.116 
“你的演示很棒！”

00:47:40.794 --> 00:47:43.363 
于是我们这儿有一个很棒的
自定义用户界面

00:47:43.764 --> 00:47:46.166 
但你还会注意到有些东西不太对

00:47:46.567 --> 00:47:48.135 
我们现在来看看是怎么回事

00:47:56.710 --> 00:47:58.478 
我们刚给你们展示了

00:47:58.545 --> 00:48:00.981 
如何用SiriKit构建
你的用户界面扩展

00:48:01.548 --> 00:48:02.716 
这非常好

00:48:03.984 --> 00:48:04.952 
但你会意识到

00:48:05.018 --> 00:48:06.887 
有些东西还是有点不妥

00:48:06.954 --> 00:48:09.890 
特别是我们在Siri展示给
用户的用户界面

00:48:10.624 --> 00:48:14.027 
于是我们弄了一个复制版聊天记录界面

00:48:14.094 --> 00:48:15.896 
在Siri snippet里展示

00:48:16.830 --> 00:48:21.802 
默认地 Siri对不同
意图都显示用户界面

00:48:21.869 --> 00:48:23.704 
如SentMessageIntent

00:48:23.770 --> 00:48:26.707 
刚用它在独角兽快信
给Diana发了信息

00:48:27.941 --> 00:48:31.345 
同理 对于我们
的独角兽快信用户 我们想做的

00:48:31.411 --> 00:48:33.914 
是真正展示我们的
自定义用户界面

00:48:33.981 --> 00:48:37.417 
让用户们对“独角兽性质”
比较好的感觉

00:48:37.518 --> 00:48:39.820 
就在他们用独角兽快信
发信息时

00:48:41.555 --> 00:48:44.725 
我们在iOS X可以做到这一点
用一个可选的新协议

00:48:45.592 --> 00:48:50.197 
通过实现
INUIHostedViewSiriProviding协议

00:48:50.664 --> 00:48:51.965 
你可以让Siri知道

00:48:52.232 --> 00:48:54.835 
你在把信息还是地图画在

00:48:55.068 --> 00:48:56.637 
你的用户界面扩展视图

00:48:57.137 --> 00:48:59.506 
所以你可以选择显示

00:48:59.573 --> 00:49:03.377 
不同的特定内容
到你的用户界面上

00:49:03.844 --> 00:49:06.680 
并代替Siri操控
这个界面

00:49:07.514 --> 00:49:08.916 
最后 当你这么做了

00:49:09.483 --> 00:49:11.552 
Siri便会调节你视图的内容

00:49:12.019 --> 00:49:15.722 
所以你要确认画出来的
这些属性准确

00:49:16.123 --> 00:49:17.324 
代表了用户意愿

00:49:20.127 --> 00:49:21.428 
我们来看IntentViewController

00:49:21.495 --> 00:49:23.897 
我们刚在我们的用户界面扩展里用了它

00:49:24.932 --> 00:49:26.133 
你可以在这儿看到

00:49:26.200 --> 00:49:30.904 
如果我们实现
INUIHostedViewSiriProviding协议

00:49:31.638 --> 00:49:35.642 
我们就可以实现displaysMessage
属性并返回真值

00:49:35.876 --> 00:49:40.380 
告诉Siri我们正在
独角兽快信显示信息内容

00:49:43.784 --> 00:49:48.455 
而这就是实现你自己的用户界面
所需要的一切

00:49:48.522 --> 00:49:49.356 
在Siri里面

00:49:50.624 --> 00:49:53.327 
我们来看看这个在
设备上运行的效果

00:49:53.560 --> 00:49:56.964 
我设备上有这个应用的一个
一模一样的版本

00:49:59.266 --> 00:50:00.567 
我们回到我的设备上

00:50:01.535 --> 00:50:03.270 
我们来发另一条信息给Diana

00:50:05.739 --> 00:50:09.376 
用独角兽快信
发信息给Diana说

00:50:09.877 --> 00:50:13.547 
“用独角兽的蹄子
很难打演示的代码”

00:50:19.520 --> 00:50:22.189  
现在我们看到跟我们预期
一模一样的界面

00:50:22.356 --> 00:50:23.957  
也跟我们想展示给用户的一样

00:50:34.535 --> 00:50:38.405 
我们的界面不会被
Siri默认显示的界面所阻碍

00:50:38.772 --> 00:50:42.276 
这给我们一个很好的窗口
来展示一个自定义的用户界面

00:50:42.342 --> 00:50:46.480 
来真正反映我们应用的
“独角兽性质”的画风

00:50:49.950 --> 00:50:51.685 
现在 我最后分享一些点子

00:50:51.852 --> 00:50:54.421 
在我们今天离开之前
再谈谈用户界面扩展

00:50:55.856 --> 00:50:57.758 
我想首先留给你们的

00:50:58.158 --> 00:51:01.962 
是你对待用户界面扩展时
应注意考虑存储量

00:51:02.963 --> 00:51:05.332 
因为扩展是默认为暂时性的

00:51:05.399 --> 00:51:08.135 
仅仅在很短时间内展示给用户

00:51:08.535 --> 00:51:11.004 
所以系统有一个强制的
比较低的存储量限制

00:51:11.071 --> 00:51:13.774 
比你在你一般的应用里
可能习惯的存储量还要低

00:51:14.341 --> 00:51:19.479 
所以像MKMapView这样的视图
用起来特别耗存储量

00:51:19.780 --> 00:51:23.050 
在建立你的用户界面扩展时
你们要谨慎地使用这些视图

00:51:25.953 --> 00:51:29.623 
正如我们所看到的
我们可以获得最小和最大的视图大小

00:51:29.923 --> 00:51:33.026 
在用户界面扩展里通过
NSExtensionContext获得

00:51:33.660 --> 00:51:37.231 
这会对你特别有用
特别是当你设计你的应用

00:51:37.297 --> 00:51:41.134 
而你的用户界面扩展要在很多
不同大小的配置下显示的时候

00:51:41.768 --> 00:51:45.472 
但你返回给Siri的
desiredSize正是你想要的

00:51:45.539 --> 00:51:46.607 
你想要的大小

00:51:47.241 --> 00:51:49.943 
所以 如果你要用不同的布局

00:51:50.410 --> 00:51:52.513 
你要确保你的程序有很强的适应性

00:51:52.579 --> 00:51:54.748 
无论如何它的外观都不错
不管大小是最小

00:51:54.882 --> 00:51:57.951 
还是最大
不管Siri怎么画它

00:52:02.022 --> 00:52:04.625 
总之 我们看到了几个关键点

00:52:04.725 --> 00:52:08.161 
关于延伸我们的应用
来适应SiriKit

00:52:09.062 --> 00:52:12.366 
而首先要做的就是
妥当地准备好你的应用

00:52:12.900 --> 00:52:15.936 
通过很好地利用共享的程序

00:52:16.003 --> 00:52:20.374 
比如嵌入框架
还有实现单元测试

00:52:20.674 --> 00:52:24.611 
来正确地测试 Siri可能
传给我们的不同的意图

00:52:25.746 --> 00:52:29.283 
并且规划好我们的应用
来使用合适数量的扩展

00:52:31.685 --> 00:52:34.154 
我们解决了添加
第一个意图扩展的问题

00:52:34.688 --> 00:52:38.358 
并实现了解析
确认和处理的业务逻辑

00:52:38.892 --> 00:52:41.328 
它让我们的应用跟Siri
实现很好的对接

00:52:44.164 --> 00:52:47.334 
最后 我们展示了如何
在Siri里提供一个用户界面

00:52:47.701 --> 00:52:52.706 
来将我们应用自定义的独特体验
融入到Siri体验之中

00:52:55.776 --> 00:52:57.377 
我们这个展示会的样本代码

00:52:57.444 --> 00:53:00.480 
以及关于SiriKit的幻灯片和
一些很棒的参考文档

00:53:00.848 --> 00:53:02.349 
都会公布在我们的网站上

00:53:04.518 --> 00:53:06.553 
而且我们昨天也有一个很棒的会

00:53:06.887 --> 00:53:08.589 
叫“SiriKit入门”

00:53:08.722 --> 00:53:12.693 
我们谈了我们对SiriKit的期望
以及如何将它融入iOS

00:53:14.194 --> 00:53:16.864 
我们也有关于应用扩展最佳实践的
一个很棒的会

00:53:16.964 --> 00:53:20.400 
是WWDC 2015里的会
我强烈推荐你们去看

00:53:20.467 --> 00:53:22.603 
特别是如果你想实现
SiriKit扩展

00:53:23.237 --> 00:53:26.640 
我希望你会觉得实现你的
SiriKit扩展

00:53:26.707 --> 00:53:30.844 
及你的应用能像我们实现
独角兽快信一样简单有趣

00:53:31.245 --> 00:53:32.112 
谢谢