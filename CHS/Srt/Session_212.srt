00:00:19.620 --> 00:00:23.891 
使用TVMLKit开发应用

00:00:28.362 --> 00:00:30.230 
下午好 欢迎大家

00:00:30.764 --> 00:00:33.667 
我是Nurinder Manj
目前是一名TVMLKit团队

00:00:33.734 --> 00:00:34.701 
软件开发经理

00:00:35.469 --> 00:00:40.774 
在此我和Parry Panesar一起
谈论如何使用TVMLKit构建大型应用

00:00:42.109 --> 00:00:46.313 
你们中的大多数都开发过一个
或者多个原生应用

00:00:46.813 --> 00:00:50.350 
在此过程中你们要
痛苦的调试性能

00:00:50.417 --> 00:00:52.052 
并且不断优化用户界面

00:00:54.121 --> 00:00:57.891 
通常这些过程牺牲了新特性开发
或者会导致延迟交付

00:00:58.959 --> 00:01:00.694 
你们中有人可能开发过web应用

00:01:01.662 --> 00:01:03.197 
web应用通常有很强可塑性

00:01:03.263 --> 00:01:07.034 
而且要不断的更新
但是用户体验却不是很好

00:01:08.535 --> 00:01:13.173 
TVMLKit作为一个新的框架
已经引入到tvOS中

00:01:13.574 --> 00:01:16.410 
作为桥梁连接web和原生应用

00:01:17.778 --> 00:01:22.249 
当你使用TVMLKit构建应用时
应用将看起来

00:01:22.716 --> 00:01:25.819 
感觉起来和使用起来
就和Apple应用一模一样

00:01:26.954 --> 00:01:27.855 
我们开始吧

00:01:29.623 --> 00:01:34.194 
今天 首先我准备讲一下
这个框架可以为大家提供哪些东西

00:01:35.896 --> 00:01:40.133 
然后 我们为大家准备了一些应用

00:01:40.200 --> 00:01:43.904 
这些应用将为大家展示
一个TVMLKit应用的全部特性

00:01:44.805 --> 00:01:49.109 
但是在此之前 我要先大致介绍下
这个框架的信息

00:01:51.044 --> 00:01:54.915 
在这段视频的后半段
我会讲一下

00:01:54.982 --> 00:01:59.319 
新的令人兴奋的新特性
该特性将在tvOS 10中引入进来

00:02:01.522 --> 00:02:04.324 
我带大家
看一下一些用户交互界面

00:02:06.593 --> 00:02:08.794 
这app store应用
且是专门 为Apple TV定制

00:02:11.565 --> 00:02:13.333 
一款常规的iTunes 电影应用

00:02:16.036 --> 00:02:17.905 
借鉴了Search应用的特性

00:02:20.307 --> 00:02:22.075 
另一款应用是Apple Music

00:02:25.045 --> 00:02:31.385 
所有这些移植到Apple TV
的应用都是基于TVMLKit开发的

00:02:33.554 --> 00:02:38.258 
并且如果你回过头来思考
这些应用都有什么特点的时候

00:02:39.126 --> 00:02:40.527 
会发现他们都有同一个目的

00:02:41.862 --> 00:02:45.098 
他们可以让人们浏览 交互

00:02:45.165 --> 00:02:47.301 
并且都包含内容分类信息

00:02:48.635 --> 00:02:52.105 
这些内容都将以一种简单而独特的方式
被呈现出来

00:02:54.474 --> 00:02:56.076 
那这个框架究竟带来了什么？

00:02:58.045 --> 00:03:02.349 
这个框架为开发者提供
基于模板的原生交互界面

00:03:03.350 --> 00:03:06.286 
而且性能方面都已经过了优化和改善

00:03:07.087 --> 00:03:10.157 
为开发者节省了大量的
时间和精力

00:03:12.960 --> 00:03:16.063 
这些复杂而丰富的交互界面正
如大家刚才所见

00:03:17.030 --> 00:03:20.033 
是通过
是用一个标记性的API来定义实现的

00:03:21.368 --> 00:03:23.704 
并且使用JavaScript
驱动这些应用

00:03:26.773 --> 00:03:28.342 
这些模板的可定制性很强

00:03:29.142 --> 00:03:33.213 
你可以改变它的外观、
它的行为和样式

00:03:37.184 --> 00:03:41.421 
而且 这个框架没有局限于
我们提供的既有模板

00:03:42.623 --> 00:03:45.158 
你可根据现有的
Apple模板进行改造

00:03:45.225 --> 00:03:47.961 
只要添加自己的视图
和这些视图的控制器就可以了

00:03:49.129 --> 00:03:51.365 
甚至 你可以从头创建自己的模板

00:03:53.166 --> 00:03:55.669 
你也可以扩展
JavaScript的功能性

00:03:55.736 --> 00:03:57.304 
当然是根据你的应用场景来定制

00:04:00.107 --> 00:04:02.776 
我可以向你保证
这不是一个web浏览器

00:04:03.944 --> 00:04:08.749 
它是一个优化了的
为tvOS定制的原生交互体验

00:04:11.585 --> 00:04:12.986 
我们开始构建应用吧

00:04:14.555 --> 00:04:17.958 
这些是主要的控件
待会儿我会详细介绍

00:04:18.392 --> 00:04:20.994 
我们需要
构建我们自己的应用

00:04:22.529 --> 00:04:27.000 
首先在Xcode里创建
并配置客户端项目

00:04:29.236 --> 00:04:31.872 
接下来我会讲关于标记

00:04:32.539 --> 00:04:35.642 
和样式来配置项目

00:04:37.578 --> 00:04:40.547 
最后 我会讲下
JavaScript API

00:04:40.848 --> 00:04:42.549 
是如何驱动这个应用的

00:04:44.418 --> 00:04:46.253 
现在在我们研究细节之前

00:04:46.486 --> 00:04:49.656 
我来给大家展示下
从架构的角度来分析这个项目

00:04:51.158 --> 00:04:55.162 
典型的TVMLKit应用是基于
client server架构模型

00:04:56.864 --> 00:04:59.867 
客户端应用是基于UIKit的应用

00:04:59.933 --> 00:05:01.702 
它可以运行在tvOS设备上

00:05:01.768 --> 00:05:06.206 
而server端保存有媒体文件
和JavaScript文件

00:05:08.375 --> 00:05:11.445 
这框架提供了application
controller API

00:05:12.212 --> 00:05:15.215 
它可以下载
关键的JavaScript文件

00:05:15.282 --> 00:05:17.284 
还会搭建一个JavaScript环境

00:05:17.351 --> 00:05:20.120 
且负责控制JavaScript行为

00:05:21.722 --> 00:05:23.490 
一旦行为可控

00:05:24.124 --> 00:05:30.797 
JavaScript就负责下载
任何需要的文件

00:05:31.665 --> 00:05:33.600 
来展示用户看的模板

00:05:35.769 --> 00:05:39.473 
并且JavaScript还负责
处理用户所有的事件

00:05:39.540 --> 00:05:41.275 
并且正确的响应事件

00:05:46.480 --> 00:05:49.349 
第一步
打开Xcode

00:05:50.751 --> 00:05:53.654 
Xcode提供了TVML
类型的应用模板

00:05:53.720 --> 00:05:56.089 
这是你
开发的应用的起点

00:05:59.026 --> 00:06:01.929 
这是部分代码
由模板生成

00:06:04.364 --> 00:06:08.135 
这里的第一步骤是
修改JavaScript URL

00:06:08.202 --> 00:06:10.137 
指向主要的JavaScript文件

00:06:12.773 --> 00:06:16.310 
下一步是创建application
controller上下文

00:06:16.810 --> 00:06:18.712 
关联javaScript URL

00:06:19.713 --> 00:06:23.083 
你也可以指定启动选项

00:06:23.150 --> 00:06:26.019 
这些选项会在启动时
传递给JavaScript

00:06:28.255 --> 00:06:30.958 
最后一个步骤是创建一个
application controller实例

00:06:31.024 --> 00:06:32.726 
基于之前的上下文和窗口

00:06:33.760 --> 00:06:37.464 
下载你的关键JavaScript
文件并执行该文件

00:06:37.865 --> 00:06:40.133 
然后控制权交给JavaScript

00:06:41.768 --> 00:06:44.638 
你也可以指定一个代表...

00:06:46.206 --> 00:06:48.175 
来监控你的controller状态

00:06:49.977 --> 00:06:53.146 
比如
启动项目的时候提示是成功还是失败了

00:06:57.084 --> 00:06:58.886 
接下来我们讨论下模板

00:07:04.525 --> 00:07:06.894 
TVML是一个Markup规范

00:07:07.427 --> 00:07:09.897 
用于定义符合Apple-TV
规范的模板

00:07:12.266 --> 00:07:16.036 
当Markup展示在导航栏的时候

00:07:16.103 --> 00:07:19.039 
从JavaScript编译成UI

00:07:20.374 --> 00:07:24.178 
一旦展示完成
你可以继续更改XML

00:07:25.379 --> 00:07:29.383 
这些更改也会动态渲染到用户界面

00:07:31.885 --> 00:07:34.755 
外面的模板看上去还是正常的

00:07:35.656 --> 00:07:38.025 
你不必做额外的样式化工作

00:07:38.792 --> 00:07:41.295 
只需要填充内容就行
然后就可以继续往下操作

00:07:43.363 --> 00:07:46.433 
但是你可以更改外观

00:07:46.500 --> 00:07:50.871 
和行为 通过使用样式化工具
来适配 [inaudible]

00:07:53.674 --> 00:07:55.075 
关于标记Markup

00:07:55.809 --> 00:07:59.213 
文档是一个实体
用来包装模板

00:08:00.747 --> 00:08:03.317 
这是XML结构树
展示了文档结构

00:08:04.151 --> 00:08:05.752 
它有两个子元素

00:08:06.386 --> 00:08:09.723 
第一个是head元素
具有自己的样式

00:08:09.790 --> 00:08:13.160 
封装了
所有你定义的样式

00:08:15.028 --> 00:08:17.664 
第二个元素是
templateName

00:08:18.866 --> 00:08:20.167 
以及它的内容

00:08:22.669 --> 00:08:26.440 
每个模板的名字唯一
并且具有功能性

00:08:28.709 --> 00:08:30.744 
我们来看一下其中的一个
模板

00:08:33.447 --> 00:08:36.683 
这是iTunes Movies应用
的Top Movies页面

00:08:39.785 --> 00:08:42.688 
这个模板允许你滚动
所有的内容栈

00:08:44.191 --> 00:08:46.793 
在Markup面板
称之为stackTemplate

00:08:48.629 --> 00:08:50.030 
在这个例子里

00:08:51.431 --> 00:08:54.301 
它的模板
使用XML展示

00:08:55.602 --> 00:08:58.438 
在模板的根节点是一个
collectionList元素

00:08:58.505 --> 00:09:02.009 
封装了各种
集合类型 比如carousel

00:09:02.075 --> 00:09:04.811 
shelves grids
以及其他支持的类型

00:09:09.750 --> 00:09:12.286 
现在这里的top的控制器是
carousel control

00:09:13.153 --> 00:09:15.556 
这支持水平的内容浏览

00:09:16.490 --> 00:09:18.258 
基于中间内容的浏览

00:09:22.496 --> 00:09:26.567 
这种控制器类型在空白状态下
会自动滚动内容

00:09:28.836 --> 00:09:33.841 
而创建这个控制器Markup很简单

00:09:35.576 --> 00:09:40.547 
你只要定义一个section并且
列出list可预见lockup情况

00:09:41.248 --> 00:09:43.584 
不需要进行额外的配置

00:09:46.620 --> 00:09:49.456 
在这个carousel下面是
一个shelf

00:09:50.424 --> 00:09:53.193 
它也可控制
水平滚动内容

00:09:55.395 --> 00:09:58.832 
而展示这个的Markup
和carousel很相似

00:10:00.534 --> 00:10:03.337 
但是shelf允许你指定一个标头

00:10:04.037 --> 00:10:06.073 
且可以包含一个或多个section

00:10:06.874 --> 00:10:09.309 
每个section也可以自带
一个标头

00:10:09.676 --> 00:10:11.645 
而且必须包含一个或多个lockup

00:10:13.814 --> 00:10:14.882 
那么lockup又是什么呢？

00:10:16.083 --> 00:10:17.918 
lockup是一个UI控制器

00:10:19.486 --> 00:10:22.523 
封装了图片
和文字元素

00:10:26.193 --> 00:10:27.728 
这是一个[inaudible]

00:10:30.597 --> 00:10:32.299 
回到我们的例子应用

00:10:32.999 --> 00:10:36.236 
若你留意
只有当前聚焦的lockup

00:10:36.303 --> 00:10:38.038 
的文档元素是可见的

00:10:39.273 --> 00:10:41.375 
这不是默认的
框架行为

00:10:43.076 --> 00:10:47.314 
这是一个例子告诉你
如何定制样式

00:10:48.215 --> 00:10:49.683 
我来演示下具体怎么做

00:10:51.785 --> 00:10:53.587 
我在这定义了一个类

00:10:54.188 --> 00:10:56.190 
我把它的高亮属性设置为

00:10:56.823 --> 00:11:00.394 
为选取框的值
并且在高亮的时候才显示

00:11:01.328 --> 00:11:02.563 
然后设置这个类

00:11:02.629 --> 00:11:04.765 
的文字元素
和lockup不匹配

00:11:05.599 --> 00:11:07.167 
然后你就可以看到这个行为了

00:11:09.169 --> 00:11:12.840 
但是 这只是一个简单
的定制化例子

00:11:13.140 --> 00:11:14.975 
我再给大家
演示一些其他例子

00:11:16.910 --> 00:11:18.312 
这又是一个
stackTemplate

00:11:20.047 --> 00:11:23.750 
我们现在有一个banner
并且指定了它的背景图片

00:11:23.817 --> 00:11:25.919 
banner就在collectionList的相邻位置

00:11:27.221 --> 00:11:29.957 
这是背景颜色
为模板而设定

00:11:30.023 --> 00:11:32.559 
这个模板无缝隙的
协调了背景颜色

00:11:32.626 --> 00:11:34.895 
和banner的背景图片颜色
我们可以看到是这个效果

00:11:36.330 --> 00:11:39.032 
banner标题的结构

00:11:39.099 --> 00:11:42.035 
以及按钮的结构
都是可以定制和配置的

00:11:45.305 --> 00:11:48.542 
另一个熟悉的例子
是一个movie bundle例子

00:11:49.009 --> 00:11:50.544 
这也是一个
stackTemplate

00:11:54.715 --> 00:11:56.850 
这个模板的背景图片是

00:11:57.117 --> 00:12:01.154 
有框架生成的
你只要指定一个图片

00:12:01.221 --> 00:12:02.523 
设置为英雄形象图片元素

00:12:04.458 --> 00:12:08.962 
再一次的
标题 shelf

00:12:09.029 --> 00:12:11.532 
以及按钮的布局也定制化了

00:12:14.601 --> 00:12:18.405 
而且还有丰富的模板
可供大家选择

00:12:19.840 --> 00:12:21.241 
使用样式工具

00:12:22.009 --> 00:12:24.578 
可以创建独特的用户体验

00:12:24.645 --> 00:12:26.046 
符合大家品牌的特色

00:12:28.715 --> 00:12:34.087 
TVML Catalogue是一个
资源库可以浏览模板和与模板交互

00:12:35.222 --> 00:12:36.190 
请检查一下

00:12:39.660 --> 00:12:41.528 
就像我之前所说

00:12:42.429 --> 00:12:46.033 
TVMLKit搭建了
原生和web应用的关联

00:12:47.434 --> 00:12:50.971 
你会发现可以很简单的创建

00:12:51.038 --> 00:12:54.942 
丰富和复杂的用户界面
只要使用简单的Markup就可以了

00:12:56.310 --> 00:12:59.580 
我给大家演示下JavaScript
驱动应用的原理

00:13:02.883 --> 00:13:07.888 
它所提供的JavaScript引擎

00:13:08.188 --> 00:13:10.691 
由框架的
JavaScriptCore驱动

00:13:12.292 --> 00:13:14.728 
而内置的Web Inspector

00:13:14.795 --> 00:13:17.831 
也提供给了打击调试和优化

00:13:21.001 --> 00:13:22.803 
并且从tvOS 10开始

00:13:22.870 --> 00:13:25.672 
JavaScriptCore
对ES6有很好的兼容了

00:13:32.212 --> 00:13:35.182 
TVMLKit添加了
基于平台的API

00:13:35.249 --> 00:13:37.084 
辅助驱动应用

00:13:39.052 --> 00:13:42.623 
现在标准的web API
像XMLHttpRequest

00:13:42.689 --> 00:13:44.892 
是传输
客户端和服务器端的数据

00:13:45.959 --> 00:13:49.396 
DOM是分析
转换和操作[inaudible]

00:13:49.463 --> 00:13:52.466 
监听用户时间 本地存储

00:13:52.533 --> 00:13:55.269 
会话存储
都是由框架提供的

00:13:57.237 --> 00:14:01.942 
另外TVMLKit
也是提供了平台相关的API

00:14:02.409 --> 00:14:04.578 
比如管理
导航栈

00:14:05.812 --> 00:14:07.147 
获取系统信息

00:14:09.449 --> 00:14:13.353 
播放[inaudible]
图片轮播还有其他功能

00:14:15.255 --> 00:14:16.423 
除此之外

00:14:17.491 --> 00:14:21.228 
框架也为大家提供了简单的API

00:14:21.295 --> 00:14:22.629 
处理媒体文件的播放功能

00:14:25.766 --> 00:14:28.602 
现在有个重要的事情
我要指出来

00:14:28.669 --> 00:14:31.772 
有一个单独的
JavaScript上下文

00:14:31.839 --> 00:14:33.340 
针对每个controller
都有一个

00:14:33.774 --> 00:14:36.310 
你可以你管理所有的document

00:14:36.376 --> 00:14:37.845 
这个单独的上下文中

00:14:40.948 --> 00:14:44.418 
我来讲解下
一些关键类

00:14:47.621 --> 00:14:49.456 
第一个是应用对象

00:14:50.057 --> 00:14:53.060 
应用对象提供了回调方法
而且是必须注册的方法

00:14:53.560 --> 00:14:55.829 
最重要的调用是onLaunch方法

00:14:56.997 --> 00:14:59.766 
指示你所有
JavaScript应用的起点

00:15:02.703 --> 00:15:06.273 
另一个 API 我要提到的是
关于处理错误的方法

00:15:08.242 --> 00:15:09.276 
叫做onError

00:15:09.343 --> 00:15:11.378 
你必须提供良好的回调函数

00:15:11.445 --> 00:15:13.680 
处理那些异常
和失败的情况

00:15:15.449 --> 00:15:18.585 
一旦控制
交给JavaScript

00:15:19.686 --> 00:15:22.689 
你第一个要做的事情是
展示一个文档

00:15:24.191 --> 00:15:25.192 
为了实现这个

00:15:25.559 --> 00:15:28.829 
NavigationDocument类
就需要大家好好处理了

00:15:29.897 --> 00:15:33.934 
这个类等同于和UINavigationController
在TVMLKit这个框架里

00:15:35.502 --> 00:15:38.005 
里面有一个全局的
预置的实例

00:15:38.071 --> 00:15:40.007 
你现在可以创建更多的实例了

00:15:41.341 --> 00:15:44.344 
现在你只要负责
添加document

00:15:44.945 --> 00:15:46.647 
把他们弹出

00:15:46.713 --> 00:15:49.283 
是由Menu手势操作负责
也是属于框架处理的情形

00:15:52.419 --> 00:15:56.156 
还有三个主要的API
你们会经常用到

00:15:57.257 --> 00:16:01.328 
头两个是pushDocument
和replaceDocument

00:16:02.930 --> 00:16:04.131 
他们是一起出现的

00:16:05.065 --> 00:16:08.035 
我来演示下推荐的
操作方法

00:16:11.104 --> 00:16:13.607 
只是一个代码段
创建一个模板

00:16:16.310 --> 00:16:19.646 
通常当你处理
处理用户请求或者启动应用的时候

00:16:20.314 --> 00:16:22.249 
你会展现一个Spinner

00:16:23.217 --> 00:16:25.752 
以便于用户知道
当前是什么情况

00:16:27.621 --> 00:16:30.490 
一旦你创建了
这个loading文档

00:16:30.557 --> 00:16:33.327 
你应该使用pushDocument
把它放到栈顶

00:16:35.128 --> 00:16:37.798 
当你等待
获取到远程数据的时候

00:16:38.899 --> 00:16:39.967 
并且已经准备好

00:16:40.434 --> 00:16:44.037 
之后你会替换
掉当前的loading文档

00:16:44.104 --> 00:16:45.439 
成期望的新内容

00:16:46.807 --> 00:16:49.643 
为做到这个 要用
replaceDocument方法

00:16:51.144 --> 00:16:52.846 
这是一个常见的模式

00:16:53.780 --> 00:16:56.817 
我们鼓励
你用正确的方式展示Spinner

00:16:56.884 --> 00:16:59.086 
当你准备从
远端获取数据的时候

00:17:04.858 --> 00:17:06.827 
最后一个API
是presentModal

00:17:07.461 --> 00:17:10.329 
是用来展示警告和错误信息的

00:17:10.396 --> 00:17:12.699 
或者以不覆盖的形式
展示其他的模板

00:17:15.469 --> 00:17:19.006 
现在影响TV观看体验的关键
是视频播放器功能

00:17:19.740 --> 00:17:21.642 
我们对此进行了简化

00:17:22.576 --> 00:17:24.011 
让我来演示给大家

00:17:25.579 --> 00:17:27.481 
只需要10行不到的代码

00:17:27.948 --> 00:17:32.252 
你就可以配置完成具有全部特性的
视频播放器模块

00:17:33.620 --> 00:17:35.255 
我带大家看下
这段代码

00:17:36.390 --> 00:17:39.826 
首先 创建一个MediaItem
它的类型是video

00:17:39.893 --> 00:17:41.662 
并且设置视频流的URL

00:17:43.664 --> 00:17:47.968 
你也可以指定标题
艺术家URL描述

00:17:48.035 --> 00:17:49.770 
使得其信息完整些

00:17:49.837 --> 00:17:52.239 
我们可在信息面板里
看到视频播放器模块体验信息

00:17:54.875 --> 00:17:58.946 
接下来 创界一个播放列表
添加一个或多个视频

00:18:00.314 --> 00:18:02.950 
最后一步是创建
一个player实例

00:18:03.350 --> 00:18:06.053 
用于操作播放列表
和展示播放器

00:18:07.621 --> 00:18:11.325 
完成之后 我们就实现了一个完整的
视频播放器提供丰富的用户体验

00:18:15.028 --> 00:18:16.396 
另外

00:18:19.333 --> 00:18:24.404 
所有特性像 处理
空隙 内容保护

00:18:25.105 --> 00:18:27.608 
章节分组 时间
[inaudible]

00:18:28.375 --> 00:18:30.611 
以及其他很多API
都已经提供了

00:18:30.677 --> 00:18:32.379 
在该JavaScript环境里

00:18:33.881 --> 00:18:35.282 
和之前视频播放器模块一样

00:18:36.283 --> 00:18:39.086 
我们扩展了音频播放功能

00:18:40.654 --> 00:18:43.123 
并且使用起来一样很方便

00:18:44.658 --> 00:18:47.728 
唯一变化的是需要绑定的是音频

00:18:47.794 --> 00:18:49.296 
以及音频文件的URL

00:18:51.965 --> 00:18:53.200 
这个可以提供

00:18:53.767 --> 00:18:56.970 
漂亮而功能完整的Audio
Now Playing体验

00:18:57.638 --> 00:18:59.406 
就和Apple Music一样

00:19:01.074 --> 00:19:03.577 
如果你正在构建一个音乐应用程序

00:19:05.345 --> 00:19:07.347 
你还需要做一件事情

00:19:07.848 --> 00:19:09.716 
就是配置你的应用

00:19:10.184 --> 00:19:12.986 
这样你的音频文件就可以支持倒带

00:19:13.053 --> 00:19:14.888 
现在是处于休眠状态

00:19:16.156 --> 00:19:19.259 
这样很类似
就和在iOS上操作一样

00:19:20.661 --> 00:19:25.499 
设置一个支持倒带的category
在AV会话面板上

00:19:26.433 --> 00:19:29.269 
并且添加背景
模式到info.plist

00:19:29.970 --> 00:19:31.772 
剩下的事情就由框架去完成

00:19:33.607 --> 00:19:37.010 
这样之后 我想邀请
Jeff上台

00:19:37.077 --> 00:19:39.413 
来演示构建
TVMLKit应用

00:19:40.013 --> 00:19:40.848 
谢谢大家

00:19:46.820 --> 00:19:47.888 
谢谢你Nurinder

00:19:47.955 --> 00:19:48.789 
大家好

00:19:48.856 --> 00:19:49.857 
我是Jeff

00:19:49.923 --> 00:19:52.659 
我在这为大家演示TVML应用

00:19:52.726 --> 00:19:55.495 
我要先强调下
我们目前已经讨论的内容

00:19:56.763 --> 00:20:01.235 
你就会发现
构建一个原生应用是多么简单

00:20:01.301 --> 00:20:03.804 
只要使用TVMLKit构建
支持Apple TV的应用

00:20:05.305 --> 00:20:09.576 
为了这次演示 我们会演示
WWDC 的一个简单版本

00:20:10.811 --> 00:20:12.346 
关于用户界面

00:20:12.412 --> 00:20:14.414 
我们有多个shelf内

00:20:15.182 --> 00:20:17.184 
每个shelf
会包含会话视频

00:20:17.251 --> 00:20:18.886 
跟踪会议

00:20:20.320 --> 00:20:23.490 
所以想象下你可为每一个
开发者工具提供一个shelf

00:20:23.557 --> 00:20:26.360 
还可以提供给应用框架 设计等等

00:20:26.727 --> 00:20:27.761 
我们开始吧

00:20:35.636 --> 00:20:38.238 
这是一个Xcode项目
我们之前就已经准备好了

00:20:39.072 --> 00:20:42.242 
我们先从AppDelegate开始
这也是我们应用的入口

00:20:45.646 --> 00:20:48.081 
在应用里
didFinishLaunchingWithOptions

00:20:49.249 --> 00:20:51.852 
正如你看到的
这几行代码

00:20:52.953 --> 00:20:56.089 
我们已经启动了
运行这个TVML应用

00:20:59.026 --> 00:21:01.962 
我们有在这指定了
JavaScriptApplicationURL

00:21:02.029 --> 00:21:04.998 
指向一个server
已经运行在这个Mac上

00:21:06.967 --> 00:21:08.869 
所以如果你看下
这里的目录

00:21:09.636 --> 00:21:12.506 
这就是我配置
提供文件服务的服务器位置

00:21:14.408 --> 00:21:17.110 
你也看到 这里有个文件
名为application.js

00:21:17.644 --> 00:21:20.881 
这个JavaScript文件
驱动TVML应用

00:21:23.217 --> 00:21:26.753 
这里有一个JSON文件
包含了所有数据

00:21:26.820 --> 00:21:28.121 
这次演示需要的数据

00:21:29.489 --> 00:21:31.692 
我们来看看这个
application.js文件

00:21:34.695 --> 00:21:38.365 
在这个文件的顶部
我们声明了一些变量

00:21:38.432 --> 00:21:39.800 
来保存我们的数据

00:21:42.603 --> 00:21:46.640 
在App.onLaunch
这个方法里我们调用一个方法

00:21:46.707 --> 00:21:48.909 
当TVML启动的时候

00:21:50.677 --> 00:21:54.314 
所以我们在这主要做的事情是
获取我们的JSON文件

00:21:54.381 --> 00:21:56.950 
然后创建一个用户界面
并使用我们之前提到的数据

00:21:58.252 --> 00:21:59.920 
在我们继续往下之前

00:21:59.987 --> 00:22:02.823 
我们应该展示一个
loading提示在屏幕上

00:22:03.323 --> 00:22:05.893 
在通过网络平台获取想要的信息时
这种方法通常会被推荐

00:22:05.959 --> 00:22:08.128 
可以为用户带来更好的用户体验

00:22:09.196 --> 00:22:10.797 
所以我在这添加了一些代码

00:22:14.101 --> 00:22:19.039 
在TVMLKit做这些操作时是为了
展示一个loading模板文档

00:22:19.573 --> 00:22:22.843 
这些都是在这个方法里完成的
叫做createLoadingDocument

00:22:24.244 --> 00:22:25.979 
我们调到这个方法

00:22:29.316 --> 00:22:33.253 
你会看到我们基本上给loading
模板创建了Markup

00:22:34.288 --> 00:22:38.492 
然后创建一个DOM文档对象
使用的是DOMParser

00:22:40.894 --> 00:22:42.596 
现在回到launch方法

00:22:44.231 --> 00:22:46.066 
在创建loading文档后

00:22:46.133 --> 00:22:48.502 
我们现在使用
navigationDocument对象

00:22:48.569 --> 00:22:50.037 
把文档推送到屏幕上

00:22:50.804 --> 00:22:53.907 
这就好像在UIKit里使用
UINavigationController一样

00:22:56.410 --> 00:22:59.213 
现在我们有了loading
Spinner显示在屏幕上

00:22:59.746 --> 00:23:02.449 
我们现在回调用一个方法
我创建的叫做...

00:23:04.985 --> 00:23:05.986 
request JSON

00:23:06.386 --> 00:23:09.857 
它会使用内置的
XMLHttpRequest对象

00:23:09.923 --> 00:23:14.361 
为了获取JSON文件 然后
在回调函数里响应

00:23:17.965 --> 00:23:18.832 
接下来

00:23:19.833 --> 00:23:22.236 
我们要转换JSON文本
就是我们刚刚获得的

00:23:22.302 --> 00:23:24.338 
到我们的JavaScript
数据结构里

00:23:26.673 --> 00:23:29.209 
现在我们的UI调用
一个shelves栈

00:23:29.276 --> 00:23:31.945 
我们会创建
一个stackTemplate文档

00:23:33.780 --> 00:23:35.349 
现在让我在这里贴一段代码

00:23:39.520 --> 00:23:42.489 
然后跳到
我们的createStackDocument方法

00:23:45.158 --> 00:23:46.226 
现在你可以看到

00:23:46.827 --> 00:23:50.163 
和我们创建Markup类似
为了早些创建loading模板

00:23:50.664 --> 00:23:53.333 
我们在创建Markup
为这里的stackTemplate

00:23:54.868 --> 00:23:57.237 
在这个stackTemplate
的Markup里

00:23:57.571 --> 00:23:59.540 
我们已在此
添加了顶部banner图片

00:24:01.275 --> 00:24:03.110 
在collectionList里

00:24:03.577 --> 00:24:06.980 
我们实际上在浏览
会议里的每一个触控项目

00:24:07.047 --> 00:24:09.449 
并且创建一个shelf元素
每一个都创建一个

00:24:09.983 --> 00:24:12.586 
这些都通过使用
createShelfElement方法

00:24:12.653 --> 00:24:13.620 
我们现在看到了

00:24:16.456 --> 00:24:18.025 
现在我进入这个方法里面

00:24:19.593 --> 00:24:23.363 
我们再一次为单独一个shelf
创建Markup

00:24:25.065 --> 00:24:30.070 
在这个方法体里面 为每个会话视频
创建一个lockup元素

00:24:33.006 --> 00:24:35.742 
我们跳到
createLockupElement方法

00:24:38.278 --> 00:24:40.447 
你会发现
我们正在创建的Markup

00:24:40.514 --> 00:24:43.083 
给这个单独的lockup元素
描述了会话的信息

00:24:43.851 --> 00:24:48.188 
在这个处理情形里 我们捕获
sessionId作为定制的属性

00:24:49.256 --> 00:24:53.427 
我们也在添加图片 设置
宽体 高度 和 标题

00:24:55.128 --> 00:24:58.732 
我们回顾下 我们创建了
一个stackTemplate文档

00:24:58.799 --> 00:25:02.469 
包含了多个shelf元素
在美国shelf元素里

00:25:02.536 --> 00:25:04.304 
我们有多个lockup元素

00:25:04.905 --> 00:25:06.974 
我们再回到刚才那个launch方法

00:25:12.246 --> 00:25:14.214 
在我们创建
stackDocument后

00:25:14.281 --> 00:25:16.817 
我们会使用
navigationDocument对象

00:25:16.884 --> 00:25:19.853 
来替换loading文档
目前这个文档是可见的

00:25:19.920 --> 00:25:21.922 
使用我们的
stackDocument

00:25:27.661 --> 00:25:29.663 
这样之后我们已经准备好运行

00:25:30.264 --> 00:25:31.698 
我们再切换到Apple TV

00:25:42.776 --> 00:25:43.844 
然后继续

00:25:43.911 --> 00:25:46.914 
我们现在拥有一个漂亮的UI
供shelve栈使用

00:25:52.619 --> 00:25:55.489 
美国shelf包含图片
lockup或会话视频

00:25:57.090 --> 00:25:59.526 
如你所见 只要少量代码

00:25:59.593 --> 00:26:02.062 
我们就可以创建一个应用
一个非常棒的应用

00:26:02.129 --> 00:26:04.031 
在家里的Apple TV上看棒极了

00:26:05.799 --> 00:26:08.335 
下一件需要做的事情

00:26:08.402 --> 00:26:10.871 
是在我们点击lockup时
能够播放视频

00:26:11.405 --> 00:26:12.940 
现在什么都没做

00:26:13.874 --> 00:26:16.443 
所以我们回到Xcode
然后添加这个功能

00:26:22.916 --> 00:26:24.418 
回到我们的launch方法

00:26:26.653 --> 00:26:28.422 
我会添加这两行代码

00:26:35.996 --> 00:26:38.799 
这会注册选择和播放事件

00:26:39.266 --> 00:26:41.502 
选择事件在
你按住触控板的时候触发

00:26:41.568 --> 00:26:44.104 
Siri Remote触控板
播放事件触发的是

00:26:44.171 --> 00:26:45.639 
在你按住
Play按钮的时候

00:26:46.106 --> 00:26:47.241 
在这两种情形下

00:26:48.075 --> 00:26:50.444 
我的playSelectedLockup
方法会被调用

00:26:51.845 --> 00:26:53.380 
我们进入这个方法

00:26:54.581 --> 00:26:55.516 
然后实现它

00:26:57.451 --> 00:26:59.520 
所以我们第一个要做的是...

00:27:02.856 --> 00:27:04.958 
获取lockup元素
在这个时间里获取

00:27:07.027 --> 00:27:10.998 
我们可以获取会话信息通过
定制属性里的sessionId

00:27:14.001 --> 00:27:16.904 
下一步 我们会创建一个
新的mediaItem对象

00:27:22.910 --> 00:27:27.281 
给嵌入的视频创建并且初始化它
使用视频的URL

00:27:28.182 --> 00:27:29.149 
就像这里一样

00:27:31.318 --> 00:27:34.454 
我们也会提取其他的
关于会话的信息

00:27:34.521 --> 00:27:38.125 
比如标题 描述
轨道和艺术品

00:27:41.061 --> 00:27:44.164 
接着我们会创建一个播放列表对象

00:27:45.999 --> 00:27:48.001 
并且把mediaItem
对象推送进去

00:27:49.903 --> 00:27:52.973 
最后 我们
会创建一个新的player对象

00:27:54.842 --> 00:27:56.009 
设置播放列表

00:27:56.810 --> 00:28:00.480 
只要简单的调用play方法
就可以全屏播放了

00:28:02.082 --> 00:28:04.484 
回顾下 我们现在
创建了一个player对象

00:28:05.185 --> 00:28:07.888 
这个对象有一个播放列表
包含有一个视频对象

00:28:09.389 --> 00:28:11.124 
有了这些 我们来试试这个

00:28:14.761 --> 00:28:15.963 
回到UI

00:28:16.029 --> 00:28:18.866 
我们会使用 Siri Remote
并且点击这个锁

00:28:18.932 --> 00:28:21.335 
然后播放器就开始播放了
而且是在全屏模式下

00:28:31.812 --> 00:28:32.646 
谢谢

00:28:32.713 --> 00:28:35.349 
你可以点击Menu按钮
然后退出视频

00:28:37.184 --> 00:28:39.520 
所以这就是
TVMLKit产生的播放器

00:28:40.220 --> 00:28:41.989 
谢谢大家的宝贵时间
接下来交给你了Nurinder

00:28:50.097 --> 00:28:51.865 
谢谢Jeff精彩的演示

00:28:54.034 --> 00:28:56.270 
只要少量的代码

00:28:57.504 --> 00:29:01.742 
你就能创建一个功能完整的应用
并且有良好性能和外观

00:29:05.879 --> 00:29:08.615 
这个空白在lockup行

00:29:09.683 --> 00:29:12.152 
阴影处理 文字处理

00:29:12.719 --> 00:29:14.154 
看起来合适

00:29:15.789 --> 00:29:19.193 
在我们继续之前
概括一下你们刚才所看到的

00:29:20.093 --> 00:29:24.064 
用Xcode里面的TVML应用模版

00:29:24.364 --> 00:29:26.366 
创建并配置你的客户端项目

00:29:28.902 --> 00:29:31.538 
你们学习了如何以JSON
创建一个简单的加载文件

00:29:31.605 --> 00:29:35.275 
和一个复杂堆文件

00:29:36.243 --> 00:29:39.213 
且你们也学习了如何使用
NavigationDocument

00:29:39.279 --> 00:29:41.582 
来推送或者替换堆栈里的文件

00:29:43.784 --> 00:29:46.820 
JavaScript
用来处理用户事件

00:29:48.188 --> 00:29:53.160 
在这个例子中
我们处理选择和播放事件

00:29:54.361 --> 00:29:58.899 
并且根据对应的
lockup来配置视频播放

00:30:03.804 --> 00:30:06.139 
当我们介绍完了TVMLKit

00:30:06.206 --> 00:30:07.941 
你已经可以创建强大的应用

00:30:10.611 --> 00:30:12.012 
你们中很多人已经这么做了

00:30:12.079 --> 00:30:13.080 
谢谢

00:30:17.918 --> 00:30:21.555 
你们已提供了一些很好的反馈
而且我们想做的更好

00:30:23.624 --> 00:30:25.292 
我们已经在这方面做了很多的努力

00:30:26.026 --> 00:30:28.829 
并且正在加入一些令人激动的新功能

00:30:29.530 --> 00:30:31.565 
它们是非常容易使用的

00:30:31.632 --> 00:30:34.034 
能使你的应用提高到更高的水准

00:30:35.435 --> 00:30:38.505 
为了更好地阐述这些
现在我想邀请Parry上台

00:30:39.373 --> 00:30:40.207 
谢谢

00:30:46.079 --> 00:30:46.947 
下午好

00:30:47.748 --> 00:30:50.817 
我叫Parry
我将带你们一起来体验一些新功能

00:30:50.884 --> 00:30:54.521 
这些功能是在tvOS 10
的TVMLKit中引进的

00:30:55.923 --> 00:31:00.794 
TVMLKit提供了非常适宜的
应用级别的功能

00:31:01.495 --> 00:31:04.198 
通过简单而灵活的界面

00:31:05.999 --> 00:31:10.270 
我们在tvOS 10中的
新功能也是一样的

00:31:11.071 --> 00:31:12.072 
比如

00:31:12.739 --> 00:31:14.842 
只要增加一个属性

00:31:14.908 --> 00:31:17.144 
在搜索文件的搜索结果中

00:31:17.611 --> 00:31:20.380 
你就能让结果有淡入淡出的动画效果

00:31:20.447 --> 00:31:21.715 
在用户输入的时候

00:31:28.889 --> 00:31:32.426 
这给用户提供了着迷的体验

00:31:33.327 --> 00:31:35.462 
当他们试着去缩小结果范围

00:31:39.166 --> 00:31:40.701 
或者如果你有一个音乐应用

00:31:42.202 --> 00:31:46.173 
只要在菜单栏顶层增加一个菜单项

00:31:46.940 --> 00:31:51.478 
你就能在那里展示
Now Playing的音频体验

00:31:52.980 --> 00:31:54.915 
这些都是由TVMLKit来管理的

00:31:54.982 --> 00:31:58.418 
所以它就会随着播放
开始和停止而进来和出去

00:32:01.054 --> 00:32:04.191 
这给你们的用户提供了一种方便的办法

00:32:04.992 --> 00:32:08.595 
来返回到播放列表和继续听音乐

00:32:11.465 --> 00:32:15.068 
所有这些功能是非常强大的

00:32:16.403 --> 00:32:18.972 
但同时它们又是非常容易实现的

00:32:20.908 --> 00:32:22.075 
为了向你们展示这个

00:32:24.011 --> 00:32:25.746 
我想选择其中的三个

00:32:27.814 --> 00:32:28.949 
来聊聊它们

00:32:30.417 --> 00:32:33.754 
在最后
实现你们在演示中所看到的功能

00:32:38.592 --> 00:32:39.793 
让我们开始吧

00:32:41.395 --> 00:32:43.297 
我想讲的第一个功能

00:32:43.864 --> 00:32:46.200 
亮色和暗色外观

00:32:48.235 --> 00:32:53.907 
在tvOS 10中有一个
新的系统级别的暗色外观

00:32:54.541 --> 00:32:56.210 
所有的应用都要采用它

00:32:58.879 --> 00:33:02.382 
你的TVMLKit应用也要应用它

00:33:02.916 --> 00:33:05.853 
通过设置应用的
info.plist文件

00:33:06.520 --> 00:33:07.888 
这是一件同样你需要做的事

00:33:07.955 --> 00:33:10.123 
在你用UIKit写应用的时候

00:33:12.125 --> 00:33:15.529 
所以你可以指定你的应用的外观

00:33:16.964 --> 00:33:18.665 
你可以选择亮色

00:33:19.833 --> 00:33:22.169 
暗色或者自动

00:33:22.569 --> 00:33:24.771 
这种情况下它会选择系统的设置

00:33:28.575 --> 00:33:30.744 
但是无论你选了哪种

00:33:31.178 --> 00:33:35.382 
你的标准TVMLKit应用
会运行地非常好

00:33:35.716 --> 00:33:37.484 
而不需要更多的改动

00:33:40.454 --> 00:33:43.357 
我们所有的模版都配置了样式

00:33:43.423 --> 00:33:45.425 
对亮色和暗色两种外观

00:33:46.793 --> 00:33:49.997 
需要时TVMLKit
会在两者之间切换

00:33:50.397 --> 00:33:51.665 
所以你能方便地得到这个效果

00:33:56.637 --> 00:33:57.504 
但是

00:33:59.006 --> 00:34:02.809 
如果你在你的文件中有明确的样式

00:34:04.745 --> 00:34:08.982 
那么你需要选择两种外观的样式

00:34:09.882 --> 00:34:10.984 
举个例子

00:34:12.418 --> 00:34:15.755 
这是一个含有标题的模版

00:34:16.690 --> 00:34:18.659 
它的颜色被设置成黑色

00:34:19.560 --> 00:34:22.094 
使用一个明确样式

00:34:24.630 --> 00:34:26.867 
这个可能在暗色主题下不起作用

00:34:28.034 --> 00:34:29.136 
为了能让它工作

00:34:29.203 --> 00:34:32.206 
你需要定义类

00:34:32.739 --> 00:34:35.342 
对于这样的外观

00:34:38.178 --> 00:34:41.447 
为了在tvOS 10中实现这个

00:34:41.949 --> 00:34:45.886 
我们新增了一个名为
tv-template的多媒体功能

00:34:47.554 --> 00:34:49.556 
它有个功能称为tv-theme

00:34:51.891 --> 00:34:54.761 
你可以用它来创建一个多媒体查询

00:34:55.228 --> 00:34:57.631 
对应于一种外观

00:34:59.733 --> 00:35:03.370 
只要将你所有的样式合在一起

00:35:04.171 --> 00:35:06.707 
按照它们的多媒体查询分组

00:35:07.875 --> 00:35:09.209 
将它们放在文件中

00:35:09.977 --> 00:35:13.614 
TVMLKit将会为你
挑选正确的样式

00:35:16.817 --> 00:35:20.153 
所以只需要一丁点的样式配置

00:35:21.054 --> 00:35:22.589 
和零行代码

00:35:23.657 --> 00:35:27.828 
你的应用就实现了暗色主题

00:35:32.833 --> 00:35:37.938 
现在让我继续谈
另外一些能提高用户体验的东西

00:35:38.539 --> 00:35:39.706 
但是要通过一种不同的方

00:35:40.707 --> 00:35:43.443 
让我们聊聊内嵌式视频

00:35:48.549 --> 00:35:49.883 
公平地讲

00:35:50.450 --> 00:35:55.556 
视频是电视观看体验中很重要的一部分

00:35:56.990 --> 00:36:00.027 
如果你有丰富的视频资源

00:36:01.128 --> 00:36:04.765 
你就会想让你的用户感受到它

00:36:05.098 --> 00:36:06.466 
当他们一打开你的应用时

00:36:09.002 --> 00:36:11.004 
你的应用当中的内嵌式视频

00:36:12.005 --> 00:36:13.407 
发挥了重要的作用

00:36:14.308 --> 00:36:18.111 
为了给大家展示
这会给你们的应用带来什么不同

00:36:19.713 --> 00:36:23.050 
我们创建了
你们刚刚看到的那个预览演示

00:36:23.917 --> 00:36:25.485 
但是有内嵌式视频在里面

00:36:27.087 --> 00:36:27.988 
让我们来看一下

00:36:43.237 --> 00:36:44.404 
这是流畅的

00:36:44.838 --> 00:36:48.242 
不但浏览体验毫不突兀

00:36:48.609 --> 00:36:49.776 
而且迎合的非常好

00:36:50.444 --> 00:36:51.845 
这使人身临其境

00:36:55.015 --> 00:36:59.520 
正如你所料
TVMLKit帮你做了大部分的工作

00:37:00.287 --> 00:37:04.258 
你只需要与这个上层接口打交道

00:37:05.225 --> 00:37:06.493 
让我们来看一下

00:37:11.698 --> 00:37:15.202 
在TVMLKit中

00:37:15.569 --> 00:37:18.071 
你要嵌入一个播放器

00:37:18.672 --> 00:37:21.208 
和一个播放区域在你的文件中

00:37:21.875 --> 00:37:24.811 
很可能 它会在一个lockup里面

00:37:30.184 --> 00:37:32.719 
TVMLKit会帮你处理播放

00:37:33.387 --> 00:37:34.922 
你所需要做的所有事情就是

00:37:35.656 --> 00:37:38.492 
指定你希望的开始时间

00:37:39.860 --> 00:37:43.497 
所以你可以说它应该开始 或者

00:37:44.031 --> 00:37:46.400 
当包含的lockup得到关注的时候

00:37:47.901 --> 00:37:49.970 
抑或是一旦它出现在屏幕上的时候

00:37:53.040 --> 00:37:57.477 
你可以控制让内嵌式视频变成全屏播放

00:38:00.180 --> 00:38:03.350 
如果你有高级用户案例

00:38:04.218 --> 00:38:06.353 
比如要用FairPlay进行加密

00:38:07.955 --> 00:38:11.291 
那么你可以用
JavaScript控制嵌入播放器

00:38:12.326 --> 00:38:13.961 
通过它的API

00:38:14.862 --> 00:38:16.430 
你可以实现这个

00:38:20.701 --> 00:38:26.974 
现在你可用TVMLKit内嵌式视频
只需要简单的三个步骤

00:38:28.408 --> 00:38:30.844 
第一 配置模版

00:38:33.847 --> 00:38:37.618 
第二 设置

00:38:40.821 --> 00:38:45.692 
第三 你想要处理触发切换全屏模式

00:38:46.593 --> 00:38:49.363 
让我们再深入地看一下这些

00:38:53.467 --> 00:38:56.637 
我们已经将模版配置的非常直观

00:38:57.471 --> 00:39:02.209 
我们在TVML中增加了一个新的元素
称为mediaContent

00:39:03.443 --> 00:39:08.248 
你可以用它在lockup中包裹图片

00:39:08.315 --> 00:39:10.150 
如果你想嵌入视频的话

00:39:13.120 --> 00:39:16.390 
这会使lockup
拥有一致的功能和外观

00:39:17.291 --> 00:39:18.825 
在视频播放开始之前

00:39:23.130 --> 00:39:26.867 
lockup里面的图片提供了边界

00:39:26.934 --> 00:39:28.468 
视频在其中播放

00:39:31.805 --> 00:39:36.443 
也可通过mediaContent的
属性来指定播放模式

00:39:36.510 --> 00:39:40.180 
一旦lockup得到了焦点
或者当它出现在屏幕上时

00:39:40.581 --> 00:39:41.882 
或者是当它出现在屏幕

00:39:43.383 --> 00:39:44.484 
举个例子

00:39:46.086 --> 00:39:47.321 
这是lockup

00:39:49.122 --> 00:39:50.791 
这是mediaContent

00:39:52.826 --> 00:39:54.862 
包含了lockup的图片

00:39:58.332 --> 00:40:01.068 
图片的宽度和高度

00:40:04.137 --> 00:40:06.707 
设置了视频播放的边界

00:40:11.044 --> 00:40:14.081 
第二步 配置播放器

00:40:15.215 --> 00:40:18.585 
现在mediaContent中的
每一个元素

00:40:19.286 --> 00:40:21.221 
有着它自己的播放器

00:40:23.423 --> 00:40:26.360 
而且你可以用JavaScript
控制播放器

00:40:29.596 --> 00:40:32.299 
只要查询播放器功能

00:40:32.399 --> 00:40:34.701 
从mediaContent
的DOMElement

00:40:36.370 --> 00:40:39.840 
在播放列表中
配置你想嵌入的多媒体项目

00:40:42.142 --> 00:40:43.477 
这是一小段对应的代码

00:40:47.414 --> 00:40:48.849 
请仔细注意

00:40:50.083 --> 00:40:51.652 
播放器的配置

00:40:51.718 --> 00:40:54.021 
和你们刚才在演示中
看到的没什么太大的区别

00:40:54.955 --> 00:40:56.089 
你创建了一个播放列表

00:40:56.323 --> 00:40:58.325 
添加了多媒体条目
并在播放器中设置它

00:41:00.460 --> 00:41:01.929 
但是有两点不同之处

00:41:02.963 --> 00:41:03.864 
第一

00:41:05.098 --> 00:41:07.100 
你不需要创建一个新的播放器

00:41:08.335 --> 00:41:09.970 
你只要使用内嵌播放器

00:41:12.206 --> 00:41:13.040 
第二

00:41:14.107 --> 00:41:17.511 
你需要提前就将它设置好而非等到
用户选择lockup时才去处理它

00:41:19.112 --> 00:41:20.848 
你在提前做了

00:41:22.216 --> 00:41:26.119 
实际上 在推送文件之前你就做了

00:41:28.889 --> 00:41:30.757 
这让我想起了一个重点

00:41:32.893 --> 00:41:34.695 
为了更好的用户体验

00:41:35.062 --> 00:41:39.600 
在推送文件之前 你必须设置好播放器

00:41:41.435 --> 00:41:43.170 
一旦文件被加载

00:41:43.237 --> 00:41:45.906 
你可以在任意时间改变播放列表

00:41:51.812 --> 00:41:53.380 
最后一步

00:41:54.548 --> 00:41:56.149 
转换到全屏

00:41:59.353 --> 00:42:00.988 
值得注意的是

00:42:01.054 --> 00:42:04.992 
TVMLKit不会为你触发转换

00:42:06.360 --> 00:42:09.663 
这是期望你们实现的灵活性之一

00:42:12.199 --> 00:42:16.270 
所以你需增加
一个事件监听器来选择和播放

00:42:17.204 --> 00:42:18.472 
为lockup

00:42:20.407 --> 00:42:22.509 
并且使用嵌入式播放器

00:42:22.576 --> 00:42:25.312 
来触发转换到全屏

00:42:27.447 --> 00:42:28.715 
举个简单的例子

00:42:30.017 --> 00:42:33.987 
这儿 我在选择事件中
已经增加了一个事件监听器...

00:42:35.756 --> 00:42:36.757 
在文件中

00:42:40.661 --> 00:42:45.632 
我将从事件目标子树获取
mediaContentElement

00:42:45.699 --> 00:42:46.900 
这将成为lockup

00:42:46.967 --> 00:42:49.303 
因为所有事件在lockup里被分配

00:42:51.638 --> 00:42:53.874 
最后调用现有的

00:42:54.741 --> 00:42:57.444 
嵌入式播放器来触发转换

00:43:00.514 --> 00:43:03.617 
现在当你想做这件事情时
你已经能完全胜任

00:43:05.385 --> 00:43:10.691 
但是通过菜单动作
可以自动转换回嵌入模式

00:43:15.462 --> 00:43:16.363 
就是那样

00:43:17.064 --> 00:43:19.299 
通过这三个简单的步骤

00:43:20.300 --> 00:43:23.370 
可以使你的应用的用户界面

00:43:23.437 --> 00:43:26.340 
更逼真

00:43:29.343 --> 00:43:30.410 
但下一步会发生什么？

00:43:34.047 --> 00:43:37.885 
当用户已经在全屏模式会发生什么呢？

00:43:38.285 --> 00:43:39.720 
他们在看你的内容

00:43:42.222 --> 00:43:45.526 
怎样能使这个过程更有趣呢？

00:43:48.262 --> 00:43:51.398 
这引出了今天我想谈论的第三个功能

00:43:51.465 --> 00:43:53.367 
让你能完全地实现它

00:43:55.002 --> 00:43:57.771 
交互式视频叠加层

00:44:00.541 --> 00:44:04.378 
在某种意义上 这和内嵌式视频很相似

00:44:04.978 --> 00:44:08.549 
它让你丰富你的内容

00:44:08.615 --> 00:44:10.384 
通过在顶层使用一个用户界面

00:44:12.519 --> 00:44:14.354 
你可以用它来做很多事情

00:44:15.389 --> 00:44:16.290 
比如

00:44:17.724 --> 00:44:20.761 
你可以推荐更多的选项给用户

00:44:21.028 --> 00:44:24.231 
使得他们能选择选项 并且继续观看

00:44:25.666 --> 00:44:29.069 
你能让他们浏览之前的广告和片尾

00:44:29.870 --> 00:44:32.673 
给他们带来完美的一口气看完的体验

00:44:37.644 --> 00:44:41.982 
或者你可以在
内容的顶部实现应用内购买

00:44:43.417 --> 00:44:46.620 
当用户沉浸在这个体验中时

00:44:50.390 --> 00:44:51.658 
甚至当你实现

00:44:52.960 --> 00:44:54.895 
一些东西简单的像

00:44:55.295 --> 00:44:58.232 
互动元数据 比如投影

00:45:00.434 --> 00:45:05.572 
让你的内容变得
更加引人入胜和具有互动性

00:45:10.811 --> 00:45:14.381 
与你已经看到的其它功能一样
实现起来是非常简单的

00:45:18.051 --> 00:45:22.689 
你只需要使用任意一个模版来创建文件

00:45:23.957 --> 00:45:25.092 
将它设定在播放器中

00:45:27.027 --> 00:45:30.364 
TVMLKit会展示这个文件

00:45:32.266 --> 00:45:34.034 
当视频全屏播放时

00:45:36.436 --> 00:45:37.571 
这是对应的代码

00:45:38.272 --> 00:45:41.508 
在tvOS 10中
我们给播放器添加了一个新的属性

00:45:42.042 --> 00:45:43.810 
称为modalOverlayDocument

00:45:45.279 --> 00:45:48.215 
所以当你设置了文件的这个属性

00:45:49.683 --> 00:45:53.654 
我们会在全屏视频的顶部展现它

00:45:57.691 --> 00:45:59.993 
如果播放器已经在全屏模式下播放了

00:46:00.060 --> 00:46:02.296 
你的文件立即就会被展示了

00:46:04.932 --> 00:46:06.700 
但是如果播放器没有在播放

00:46:07.467 --> 00:46:09.203 
或者说它是在嵌入模式下播放的

00:46:11.104 --> 00:46:14.842 
当视频被全屏的时候它们就会被展示

00:46:15.242 --> 00:46:19.012 
所以这对你来说是非常方便的
只要在任意你想要的时间设置它

00:46:24.051 --> 00:46:26.920 
好了 让我们看一下演示

00:46:27.754 --> 00:46:33.193 
让我们来实现你们刚才
在演示中看到的这些功能

00:46:33.794 --> 00:46:34.795 
为了做它

00:46:35.162 --> 00:46:37.097 
让我们欢迎Jeff上台

00:46:37.598 --> 00:46:38.465 
Jeff

00:46:43.604 --> 00:46:45.172 
谢谢 Parry
大家好 又见面了

00:46:45.239 --> 00:46:46.640 
我来给大家展示一下新东西

00:46:48.909 --> 00:46:50.110 
所以回到Apple TV

00:46:52.079 --> 00:46:53.914 
这就是我们刚才给你们看的演示

00:46:55.716 --> 00:46:56.750 
现在让我们回到主页

00:46:58.485 --> 00:46:59.820 
进入到设置应用

00:47:02.422 --> 00:47:05.225 
进入外观设置

00:47:06.260 --> 00:47:08.195 
将外观设为暗色

00:47:10.230 --> 00:47:11.298 
回到主页

00:47:12.332 --> 00:47:15.636 
因为我们是用Xcode 8创建的
这个演示应用

00:47:16.036 --> 00:47:18.372 
我们在info.plist文件中
可以设置

00:47:18.438 --> 00:47:21.008 
来支持自动的用户界面工具栏

00:47:21.575 --> 00:47:23.343 
这意味着我们的演示应用

00:47:23.410 --> 00:47:25.746 
就会自动地支持工具栏的外观

00:47:26.780 --> 00:47:27.881 
让我们来看看这会长什么样子

00:47:31.218 --> 00:47:32.286 
看吧

00:47:36.957 --> 00:47:39.660 
我们的UI看起来是多么漂亮

00:47:40.627 --> 00:47:42.896 
而且 不需要一行代码就能实现

00:47:44.898 --> 00:47:46.934 
现在让我们聊聊嵌入视频

00:47:49.002 --> 00:47:50.537 
对于我们的演示
我们想让视频

00:47:50.604 --> 00:47:53.440 
在lockup中自动地开始播放

00:47:54.474 --> 00:47:55.442 
正如Parry刚刚提过的那样

00:47:55.509 --> 00:47:57.277 
需要三个步骤来实现这个

00:47:57.444 --> 00:48:00.380 
第一步是使用mediaContentElement
这个标志

00:48:01.148 --> 00:48:03.917 
第二步是配置内嵌式播放器

00:48:04.518 --> 00:48:06.753 
第三步是处理全屏播放

00:48:07.321 --> 00:48:08.589 
让我们回到Xcode

00:48:15.028 --> 00:48:17.264 
进入到createLockup函数

00:48:24.071 --> 00:48:27.040 
不同于创建标准的图片lockup

00:48:28.575 --> 00:48:32.045 
我现在要添加一个新的
mediaContent元素标志

00:48:36.850 --> 00:48:38.318 
用它来包裹我们的图片

00:48:39.019 --> 00:48:40.521 
就是这样
这就是第一步

00:48:40.854 --> 00:48:41.688 
非常简单

00:48:42.823 --> 00:48:43.957 
然后来到第二步

00:48:45.559 --> 00:48:47.327 
Parry刚才也提到了

00:48:47.394 --> 00:48:50.264 
每一个mediaContent
元素会内置

00:48:50.330 --> 00:48:51.431 
一个内嵌式播放器

00:48:51.965 --> 00:48:55.903 
所以我们要做的就是
配置这些内嵌式播放器

00:48:55.969 --> 00:48:59.139 
配置对应的播放列表
在我们展示文件之前

00:49:00.274 --> 00:49:02.242 
回到启动功能

00:49:05.512 --> 00:49:07.147 
在我们展示这个文件之前

00:49:07.214 --> 00:49:09.616 
我需要调用一个我创建的函数 称为

00:49:11.218 --> 00:49:12.920 
configureMediaLockupElements

00:49:15.556 --> 00:49:16.790 
在这个函数内部

00:49:19.927 --> 00:49:22.429 
我们首先取出所有的
mediaContent元素

00:49:22.496 --> 00:49:23.497 
从这个文件中

00:49:25.999 --> 00:49:27.668 
对于每一个mediaContentElement

00:49:28.435 --> 00:49:30.037 
和前面的演示类似

00:49:30.103 --> 00:49:32.573 
我们要创建一个新的
mediaItem对象

00:49:34.308 --> 00:49:37.978 
一个新的播放列表对象包含
我们的mediaItem对象

00:49:39.479 --> 00:49:41.982 
但是我们在这里不创建一个新的播放器

00:49:42.416 --> 00:49:44.484 
我们使用getFeature函数

00:49:45.586 --> 00:49:47.020 
来获取内嵌式播放器

00:49:47.654 --> 00:49:49.389 
然后在播放列表中设置好它

00:49:51.358 --> 00:49:52.359 
这就是第二步了

00:49:53.460 --> 00:49:55.929 
最后一步是处理全屏播放

00:49:57.097 --> 00:49:59.466 
我们来看一下playSelectedLockup
这个函数

00:50:01.635 --> 00:50:04.671 
你应该记得它是从选择和
播放事件中触发的

00:50:09.343 --> 00:50:13.480 
这些代码我们都不需要把它们替换掉

00:50:17.384 --> 00:50:19.987 
首先从事件中提取lockup元素

00:50:21.855 --> 00:50:24.925 
再从lockup元素中
提取mediaContent元素

00:50:26.159 --> 00:50:29.997 
使用getFeature函数
来访问内嵌式播放器

00:50:31.498 --> 00:50:34.968 
我们只要调用播放让它变成全屏

00:50:37.738 --> 00:50:39.039 
看一下它的样子

00:50:54.688 --> 00:50:57.324 
正如你看到的一样 视频现在会开始

00:50:57.391 --> 00:50:59.593 
在lockup里面自动地播放

00:51:01.728 --> 00:51:04.331 
当我点击lockup 你会切换

00:51:04.398 --> 00:51:06.233 
视频到全屏模式

00:51:06.300 --> 00:51:09.369 
欢迎来到2015年
Apple设计大奖

00:51:10.003 --> 00:51:11.905 
欢迎今晚大家的到来

00:51:11.972 --> 00:51:12.840 
非常酷的东西

00:51:12.906 --> 00:51:16.143 
你也可以按菜单键来退出全屏模式

00:51:20.414 --> 00:51:21.682 
这就是内嵌式视频

00:51:22.382 --> 00:51:25.853 
我们想展示的下一个
新功能是互动的视频叠加

00:51:26.420 --> 00:51:30.157 
这个新功能能让你把一个UI

00:51:30.224 --> 00:51:31.859 
置于视频上 当视频在播放时

00:51:32.659 --> 00:51:36.330 
在我们的演示中
我们会展示一个列表包含

00:51:36.396 --> 00:51:39.099 
相关的视频在播放视频的顶部

00:51:40.267 --> 00:51:41.768 
回到Xcode

00:51:42.636 --> 00:51:44.505 
在playSelectedLockup函数中

00:51:46.106 --> 00:51:48.275 
调用我刚才创建的一个函数

00:51:48.342 --> 00:51:52.679 
来创建一个叠加 函数名为
createInteractiveVideoOverlay

00:51:54.615 --> 00:51:55.782 
在这个函数内部

00:52:00.287 --> 00:52:03.991 
我们创建了另一个
stackTemplate

00:52:06.894 --> 00:52:07.995 
只有一个shelf

00:52:09.730 --> 00:52:12.733 
在shelt里面
有多个lockup元素

00:52:15.135 --> 00:52:17.604 
我们改变一下
stackTemplate的样式

00:52:18.872 --> 00:52:20.674 
我们添加一个模糊的背景

00:52:22.643 --> 00:52:24.845 
顶部增加一些空白

00:52:24.912 --> 00:52:27.681 
这样shelf会在播放器的底部

00:52:30.417 --> 00:52:32.920 
回到playSelectedLockup函数

00:52:34.555 --> 00:52:36.623 
创建了叠加文件之后

00:52:37.057 --> 00:52:41.428 
我们将它设置在播放器的
新模态叠加文件属性

00:52:41.495 --> 00:52:43.230 
这样播放器就能对它进行展示

00:52:43.764 --> 00:52:47.768 
实际上 播放器会展示任意一个
使用了这个属性的TVMLKit文件

00:52:49.536 --> 00:52:51.138 
现在我们也能展示这个叠加了

00:52:51.205 --> 00:52:53.841 
当视频处于全屏模式时

00:52:54.474 --> 00:52:55.943 
比如 我们可能会想展示

00:52:56.009 --> 00:52:58.912 
这个叠加 在视频结束前30秒的时候

00:52:59.746 --> 00:53:02.850 
但是为了这个演示 我们展示这个叠加

00:53:02.916 --> 00:53:06.153 
一旦视频进入全屏模式
所以我们在这里调用它

00:53:07.254 --> 00:53:08.322 
让我们运行一下

00:53:10.791 --> 00:53:13.727 
同样 视频会在lockup里
自动开始播放

00:53:16.630 --> 00:53:20.634 
当我把视频切换到全屏模式
你能在屏幕上看到叠加层

00:53:23.136 --> 00:53:24.071 
掌声

00:53:29.877 --> 00:53:32.713 
而且这个叠加层还是能互动的
所以你可以随便移动它

00:53:32.779 --> 00:53:34.381 
在这个lockup里面

00:53:36.950 --> 00:53:38.852 
这就是交互式的视频叠加层

00:53:39.720 --> 00:53:41.688 
希望这个演示对大家有所帮助

00:53:41.889 --> 00:53:43.156 
谢谢大家

00:53:43.390 --> 00:53:44.391 
还给你 Parry

00:53:44.791 --> 00:53:46.693 
谢谢Jeff 多么精彩的一个演示

00:53:47.094 --> 00:53:50.030 
让我们快速回顾一下
我们在演示中看到的内容

00:53:50.797 --> 00:53:54.134 
你们看到了亮色和暗色的外观

00:53:54.601 --> 00:53:57.838 
能直接应用于TVMLKit应用

00:53:59.606 --> 00:54:04.845 
你们看到了利用三个简单的步骤
就能非常方便地嵌入视频

00:54:07.414 --> 00:54:11.518 
最后 你们看到了
一个长时间观看体验的例子

00:54:12.186 --> 00:54:16.390 
通过交互式视频叠加层实现

00:54:18.458 --> 00:54:19.359 
到这里

00:54:20.894 --> 00:54:23.797 
我想要总结一下我们今天学到的内容

00:54:27.668 --> 00:54:29.002 
有一件事情

00:54:29.703 --> 00:54:32.673 
我请大家离开一下这个演示文稿

00:54:34.541 --> 00:54:35.409 
就是这个

00:54:37.444 --> 00:54:42.916 
TVMLKit是一种非常简单的
创建TV上应用的方法

00:54:44.351 --> 00:54:46.320 
它给了你们本地化的体验

00:54:48.121 --> 00:54:52.226 
看上去和用起来都像Apple应用

00:54:56.363 --> 00:55:01.134 
类似于Markup和
JavaScript这样的网页技术

00:55:02.603 --> 00:55:04.905 
能让你们快速开发应用

00:55:06.540 --> 00:55:08.208 
减少投放到市场的时间

00:55:12.846 --> 00:55:14.414 
利用这些新功能

00:55:15.516 --> 00:55:17.985 
和你们看到的TVMLKit

00:55:18.986 --> 00:55:20.521 
的例子

00:55:21.188 --> 00:55:22.723 
来编辑用户界面

00:55:25.125 --> 00:55:29.663 
你可以把你的时间 金钱

00:55:30.430 --> 00:55:31.999 
和聪明的精力

00:55:33.934 --> 00:55:36.136 
放在功能和内容上

00:55:37.371 --> 00:55:41.275 
让你的应用独一无二和功能强大

00:55:45.379 --> 00:55:49.149 
我强烈建议大家去看一下开发者网站

00:55:49.216 --> 00:55:52.586 
浏览一下文档和下载一些例子的代码

00:55:52.653 --> 00:55:55.656 
那里有大量的信息

00:55:58.058 --> 00:56:00.827 
我也推荐一些相关的会议

00:56:01.128 --> 00:56:03.130 
包括tvOS的新特性

00:56:04.031 --> 00:56:06.767 
特别是明天将要开的

00:56:06.834 --> 00:56:08.769 
是TVMLKit第二部分

00:56:09.970 --> 00:56:13.574 
我们会介绍如何混合你们自己的视图

00:56:13.640 --> 00:56:17.644 
视图控制器和TVMLKit中的
JavaScript API

00:56:19.313 --> 00:56:20.414 
最后

00:56:21.348 --> 00:56:22.950 
我想要感谢大家

00:56:23.917 --> 00:56:25.118 
前来

00:56:26.153 --> 00:56:31.859 
希望大家在接下来的
WWDC16 上有着很好的体验

00:56:32.226 --> 00:56:33.060 
谢谢大家