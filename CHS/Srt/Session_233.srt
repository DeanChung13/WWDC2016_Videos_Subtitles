00:00:19.453 --> 00:00:25.325
令应用自适应 第二部分

00:00:27.394 --> 00:00:30.330
早上好
我叫David Duncan

00:00:30.564 --> 00:00:33.333
和Kurt Revis一起
今天我们要讲讲

00:00:33.400 --> 00:00:35.769
如何使应用自适应

00:00:36.737 --> 00:00:41.241
那么 第一部分你们会看到
Interface Builder加入了的

00:00:41.308 --> 00:00:43.343
工具

00:00:43.610 --> 00:00:47.981
以及做自适应布局的基础

00:00:48.815 --> 00:00:50.784
这个部分中
我们会跟你讲更多

00:00:50.851 --> 00:00:55.155
能帮助你做自适应应用的技巧

00:00:56.156 --> 00:00:57.791
以及自己定制想要的体验

00:00:57.858 --> 00:01:01.261
同时保持自适应性
所需要写的代码

00:01:02.062 --> 00:01:04.164
那么 看看今天的议程

00:01:05.065 --> 00:01:07.100
我们要谈的第一个

00:01:07.167 --> 00:01:11.805
只是一些尺寸和屏幕分类的基础
帮助大家温习一下

00:01:12.940 --> 00:01:18.478
我们还要讲讲在UIKit工具中已经
有的一些东西

00:01:18.545 --> 00:01:24.117
能够帮助你用Interface Builder
最有效利用UIKit

00:01:25.018 --> 00:01:28.021
最后 Kurt会上来讲

00:01:28.088 --> 00:01:32.526
怎样跨屏幕构造自定义体验

00:01:33.327 --> 00:01:35.329
那么 让我们从尺寸开始

00:01:37.364 --> 00:01:39.099
好 尺寸

00:01:39.600 --> 00:01:41.802
如果直接拿过来所有的设备

00:01:41.869 --> 00:01:44.805
和它们的设备方向
和它们在屏幕上的适配

00:01:44.872 --> 00:01:48.308
这样看起来是很复杂的一些东西呢

00:01:48.609 --> 00:01:51.245
我不认为任何人会想把这些问题都
连根拔起

00:01:51.478 --> 00:01:53.981
搞清楚它们的布局看上去怎么样
使它工作

00:01:54.047 --> 00:01:57.551
让我们看看是否可以
将需简化的所有这些做个图表

00:02:00.254 --> 00:02:04.091
好吧 还是挺复杂的

00:02:04.157 --> 00:02:07.628
你不必读它
这些文本很难看清楚

00:02:07.694 --> 00:02:11.665
看看把文字和颜色去掉会不会简单些

00:02:12.232 --> 00:02:15.235
并没有什么帮助
那么我们还可以怎么做？

00:02:16.003 --> 00:02:21.942
好吧 我们在UIKit考虑该问题时
我们会想可以怎样

00:02:22.042 --> 00:02:26.747
分配空间
给用户创造好的体验？

00:02:28.215 --> 00:02:32.252
正如你已经猜到的
我们在讲的是屏幕分类

00:02:32.920 --> 00:02:38.592
用网格分开 分成紧凑宽度
和常规宽度

00:02:38.659 --> 00:02:40.394
紧凑高度和常规高度

00:02:40.794 --> 00:02:44.264
我们决定 当你在紧凑型时

00:02:44.331 --> 00:02:48.068
你会有更接近iPhone的体验
更好运用空间

00:02:48.702 --> 00:02:53.507
但当在常规型时
你可以做到一些更高级的事

00:02:53.574 --> 00:02:57.110
真正利用空间做到更有趣的一些事

00:02:58.011 --> 00:03:02.850
那么从中学到的就是
当你看到常规尺寸时

00:03:03.183 --> 00:03:07.054
就是给了你机会给用户
提供更好的用户体验

00:03:07.120 --> 00:03:08.288
利用空间

00:03:08.355 --> 00:03:11.291
超越能在紧凑型尺寸办到的

00:03:12.292 --> 00:03:16.897
那么 看看基于屏幕分类 UIKit
已经能办到的

00:03:18.298 --> 00:03:21.001
大部分视图和控制实际上并没有变

00:03:21.768 --> 00:03:23.237
如果你看一下开关

00:03:23.303 --> 00:03:25.639
它在紧凑型还是常规型是一样的

00:03:25.806 --> 00:03:28.709
导航条在紧凑型还是常规型也是一样的

00:03:28.976 --> 00:03:30.577
但什么会变呢？

00:03:31.812 --> 00:03:33.413
好吧 这里有个展示

00:03:33.780 --> 00:03:37.284
看上去是个全屏展示
在iPhone 6s Plus上

00:03:37.784 --> 00:03:42.122
如果我们旋转设备 把它放在紧凑型时
我们看到一个表单

00:03:42.756 --> 00:03:45.492
所以在展示中看到的一件事是

00:03:45.626 --> 00:03:49.263
如果你在常规型尺寸展示表单

00:03:49.329 --> 00:03:52.966
转而到紧凑型尺寸
不会有足够的空间来展示

00:03:53.033 --> 00:03:55.636
所以会把它改成全屏展示

00:03:56.937 --> 00:04:00.908
现在在UIKit中做着最复杂的适配

00:04:00.974 --> 00:04:03.210
基于屏幕分类和有限空间

00:04:03.510 --> 00:04:05.179
的是UISplitViewController

00:04:05.679 --> 00:04:10.918
在iPhone 6s Plus上看
紧凑型宽度的观看体验

00:04:11.318 --> 00:04:14.021
会看到 如同你常常体验到的

00:04:14.087 --> 00:04:17.224
只能看到一个能够推送、弹出东西
的导航控制器

00:04:17.658 --> 00:04:20.627
我们再旋转到紧凑型宽度时

00:04:21.028 --> 00:04:22.462
就引入了边栏

00:04:22.629 --> 00:04:27.868
在iPhone 6s Plus上
我们认为所有常规型尺寸的空间

00:04:27.935 --> 00:04:32.539
有边栏比没有带来的用户体验更好

00:04:32.973 --> 00:04:36.243
尽管我们只有这么些空间来加上它

00:04:37.211 --> 00:04:41.348
跟在iPad上相似
横屏9.7英寸iPad

00:04:41.415 --> 00:04:44.551
你会看到也有边栏

00:04:44.618 --> 00:04:47.120
让你更方便切换于不同邮件之间

00:04:47.788 --> 00:04:49.823
如果换到竖屏怎么办？

00:04:50.691 --> 00:04:53.393
记住 在iPad上还是常规型尺寸

00:04:54.061 --> 00:04:57.598
但是我们觉得在iPad上通常有内容

00:04:57.731 --> 00:05:00.234
更大、更有趣的内容

00:05:00.300 --> 00:05:04.104
内联图像等等
你需要多余空间

00:05:04.471 --> 00:05:07.374
来和内容交互

00:05:08.041 --> 00:05:11.411
然而 我们允许你在边栏切换

00:05:11.478 --> 00:05:14.681
这样你还是能方便切换于不同邮件之间

00:05:15.415 --> 00:05:19.620
这就是UIKit的一些

00:05:19.686 --> 00:05:24.525
基于两种屏幕分类
提供最好体验的功能

00:05:24.591 --> 00:05:26.660
和有限的实际空间

00:05:27.528 --> 00:05:31.832
为了更好利用它
让我们看看UIKit的一些实践

00:05:32.232 --> 00:05:35.802
充分利用现有功能

00:05:36.870 --> 00:05:40.908
讲讲Xcode工具里UIKit的

00:05:41.074 --> 00:05:42.943
第一部分中

00:05:43.010 --> 00:05:46.713
你们看过了Interface Builder的用来做自适应
应用的增强功能

00:05:47.181 --> 00:05:50.684
为了在所有范围轻易做调试
基于屏幕分类

00:05:50.751 --> 00:05:51.652
和特征

00:05:52.519 --> 00:05:55.689
但是 Xcode还提供了资源目录

00:05:55.756 --> 00:05:59.293
资源目录很棒
不仅用来整理图像

00:05:59.359 --> 00:06:02.663
还指定了什么时候该用这些图像

00:06:03.931 --> 00:06:06.466
当然UIKit有很多技术

00:06:06.600 --> 00:06:08.735
让构建自适应应用变得简单

00:06:09.403 --> 00:06:11.738
我们讨论自动布局很多年了

00:06:11.805 --> 00:06:14.007
有很多相关演讲
如果你想了解

00:06:14.074 --> 00:06:15.309
可以去回顾它们

00:06:15.475 --> 00:06:18.879
当然今天稍晚些有个演讲
关于自动布局的新进展

00:06:20.013 --> 00:06:22.850
特征集合在第一部分回顾过了

00:06:23.684 --> 00:06:26.153
但还有别的东西比如动态字体

00:06:26.486 --> 00:06:29.756
让你的应用适应不同字体大小

00:06:29.823 --> 00:06:31.158
基于用户想使用的

00:06:32.426 --> 00:06:36.163
布局导引是个很好的方式
用于传递自动布局信息

00:06:36.230 --> 00:06:37.331
向层级下

00:06:37.431 --> 00:06:40.701
我们会讨论一些UIKit默认提供的
一些布局导引

00:06:41.835 --> 00:06:44.505
最后UIAppearance能很好

00:06:44.571 --> 00:06:48.342
声明指定你想让你的应用

00:06:48.408 --> 00:06:49.843
控制和视图看上去怎样

00:06:51.178 --> 00:06:53.380
让我们从资源目录开始

00:06:54.581 --> 00:06:58.919
资源目录让你自动适应图像

00:06:59.052 --> 00:07:02.022
基于图像所在展示的特征环境

00:07:02.890 --> 00:07:04.391
这里有个小例子

00:07:04.958 --> 00:07:07.427
这里是些Sophia宝宝的图片

00:07:07.594 --> 00:07:11.231
有1x 2x 3x版本的图像

00:07:11.565 --> 00:07:16.537
不管你在iPad 2
还是iPhone 6s Plus上

00:07:16.703 --> 00:07:20.741
你会得到那个设备下最好分辨率
的图像

00:07:21.842 --> 00:07:23.377
另一个优点是

00:07:23.443 --> 00:07:27.314
资源目录可以为应用瘦身设计

00:07:27.648 --> 00:07:32.553
这意味着如果我指定这个应用
给iPhone 6s

00:07:32.619 --> 00:07:36.356
一个2x设备
我不用付出空间损失

00:07:36.423 --> 00:07:38.859
给携带1x和3x的图片

00:07:39.693 --> 00:07:43.197
同样的 还压缩了图像基于屏幕分类

00:07:43.263 --> 00:07:44.298
和其他一些东西

00:07:44.431 --> 00:07:46.266
那么 用资源目录

00:07:46.333 --> 00:07:49.036
可以给图像做最好的细分

00:07:49.136 --> 00:07:50.671
让你用尽量少的容量

00:07:50.737 --> 00:07:52.706
部署给用户设备的时候

00:07:54.541 --> 00:07:57.644
另外 资源目录提供了元数据信息

00:07:57.711 --> 00:08:00.647
为了各种理由添加到图像上的

00:08:00.914 --> 00:08:03.717
第一件要讨论的是对齐嵌入物

00:08:03.851 --> 00:08:05.552
把Sophia宝宝弄回来

00:08:06.153 --> 00:08:07.988
比如有个应用

00:08:08.055 --> 00:08:12.025
有时我们要剪裁这张图片成正方形

00:08:12.726 --> 00:08:15.329
如果随便取中间部分

00:08:15.395 --> 00:08:16.830
会看不见她大部分的脸

00:08:16.997 --> 00:08:20.667
真正要的部分是在她脸上画个正方形

00:08:21.768 --> 00:08:23.504
现在你该怎么办？

00:08:23.570 --> 00:08:25.405
要引入一些度量

00:08:25.472 --> 00:08:28.041
搞清楚从边到正方形的距离

00:08:29.009 --> 00:08:33.046
不用把这些写入代码和资源相连

00:08:33.447 --> 00:08:36.049
你可以直接在资源目录完成这些

00:08:36.582 --> 00:08:40.254
UIImage会在你需要时
提供这些数值

00:08:40.419 --> 00:08:43.023
类似的 你可以用这些数值创建图像

00:08:43.090 --> 00:08:44.958
把图像放进资源目录

00:08:45.025 --> 00:08:48.495
意味着你无需巨大的表格关联资源名字

00:08:48.729 --> 00:08:49.630
和元数据

00:08:51.164 --> 00:08:56.136
类似的 比如表格视图有个背景

00:08:56.203 --> 00:08:58.472
之类的 你需要调整大小

00:08:58.539 --> 00:09:01.208
来适应展示尺寸

00:09:01.708 --> 00:09:06.046
你可以创建一个分成9部分的图片
创建切割边缘

00:09:06.513 --> 00:09:08.882
储存这些进资源目录

00:09:09.416 --> 00:09:12.152
然后当这张图片改成
最终状态下的尺寸时

00:09:13.120 --> 00:09:16.356
它不需要大尺寸图像就能调整大小

00:09:16.423 --> 00:09:18.892
而且特定的根据你在工作的设备大小

00:09:20.527 --> 00:09:22.429
好 这些是资源目录

00:09:22.496 --> 00:09:26.066
讲讲其他可以给应用做的适配

00:09:26.333 --> 00:09:27.301
使用动态字体

00:09:28.635 --> 00:09:29.803
我们喜欢动态字体

00:09:30.437 --> 00:09:33.207
它给用户提供了指定字体大小的能力

00:09:33.273 --> 00:09:37.044
给用户一些视野上的帮助

00:09:37.110 --> 00:09:41.081
指定很大的字体大小来更方便阅读

00:09:41.782 --> 00:09:42.950
今年

00:09:43.417 --> 00:09:47.387
我们让你在应用上用动态字体更加简单

00:09:47.788 --> 00:09:49.256
用两种方法

00:09:49.790 --> 00:09:52.526
第一种 把它放在特征目录其中

00:09:52.960 --> 00:09:55.963
就不用等着听通知了

00:09:56.163 --> 00:10:00.234
它就在那儿给你使用来自定义文本
如果你需要它

00:10:00.801 --> 00:10:04.538
但我们发现你在常规型文本视图下
应该不需要做这些

00:10:04.605 --> 00:10:07.040
给标签 文本框和文本视图

00:10:08.008 --> 00:10:10.210
我们把这些变得非常简单

00:10:10.544 --> 00:10:14.615
你只要指定想要的字体样式

00:10:14.982 --> 00:10:18.485
给内容尺寸类别
设置调整尺寸的标志

00:10:18.852 --> 00:10:21.355
所有标签 文本框和文本视图

00:10:21.421 --> 00:10:24.124
都自动适配成当前动态字体尺寸

00:10:24.191 --> 00:10:25.826
你不用做任何事

00:10:31.899 --> 00:10:33.834
当然 如果你用了这个方法

00:10:33.901 --> 00:10:37.771
确定在所有动态字体尺寸下测试应用

00:10:37.838 --> 00:10:40.040
如我提到的有些很大的字体

00:10:40.107 --> 00:10:43.810
Mac的无障碍检查器会连接你的应用

00:10:43.877 --> 00:10:45.345
你可以动态调回来

00:10:45.412 --> 00:10:47.548
而不用来回设置

00:10:48.015 --> 00:10:50.918
如果你要在表格或集合视图展示

00:10:50.984 --> 00:10:54.788
回顾一下“集合视图的新特性”演讲

00:10:54.855 --> 00:10:58.659
其中有些很好的信息关于性能和行为
的增强功能

00:10:58.725 --> 00:11:02.196
在集合视图中可以很好利用的

00:11:03.630 --> 00:11:05.933
那么讨论讨论布局导引

00:11:06.967 --> 00:11:10.370
UIView提供两种布局导引

00:11:10.571 --> 00:11:13.006
边距导引 和可读内容导引

00:11:13.073 --> 00:11:14.608
我们会依次说

00:11:15.075 --> 00:11:17.377
这两种都源于视图

00:11:18.045 --> 00:11:19.913
不管要放什么内容

00:11:20.280 --> 00:11:25.786
边距导引由UIView中的
一项属性定义

00:11:26.153 --> 00:11:27.554
那就是布局边距

00:11:27.921 --> 00:11:29.990
定义了插入物的所有边

00:11:31.391 --> 00:11:33.594
那么 接下来怎么创建布局导引呢

00:11:33.861 --> 00:11:37.764
那只是由视图指定的一个长方形而已

00:11:38.432 --> 00:11:42.503
边距导引 当然 提供自动布局对象

00:11:42.569 --> 00:11:44.638
给你生成自定义约束

00:11:45.205 --> 00:11:46.039
简单

00:11:46.740 --> 00:11:50.210
那么 可读内容导引跟这有什么关系呢

00:11:51.378 --> 00:11:52.913
可读内容导引

00:11:53.480 --> 00:11:57.985
提供信息如何布局文本

00:11:58.352 --> 00:12:00.320
让文本的每行长度看上去好
可读性高

00:12:00.988 --> 00:12:04.791
如果你在用
新的12.9英寸iPad Pros

00:12:04.992 --> 00:12:07.060
把文本布局成一边到另一边

00:12:07.127 --> 00:12:09.963
用户在阅读时会不停转头

00:12:10.497 --> 00:12:15.469
第一件要计算的是文本长度的理想宽度
是多少？

00:12:16.537 --> 00:12:19.306
我们不想要文本溢出边距

00:12:19.373 --> 00:12:22.976
所以把边距导引作为计算的一部分

00:12:23.477 --> 00:12:27.781
把两者结合成可读内容导引

00:12:28.081 --> 00:12:32.252
另一种在UIView中放入文本布局

00:12:33.687 --> 00:12:37.157
现在 可读内容导引基于动态字体大小

00:12:37.724 --> 00:12:39.626
如果动态字体大小变了会怎么样？

00:12:40.127 --> 00:12:42.329
好吧 我们放大了动态字体大小

00:12:42.396 --> 00:12:43.997
理想宽度变大了

00:12:44.531 --> 00:12:45.599
如你所见

00:12:45.666 --> 00:12:49.002
因为可读内容导引基于边距

00:12:49.369 --> 00:12:52.306
导引不会穿过这些边距

00:12:52.739 --> 00:12:54.374
所以你可以铺开文本

00:12:54.441 --> 00:12:58.912
得到可读性强的文本长度在视图里面

00:13:00.314 --> 00:13:02.583
那么
让我们讲讲UIAppearance

00:13:04.051 --> 00:13:06.954
UIAppearance
如果你还没用过 是个声明方式

00:13:07.221 --> 00:13:10.424
给你指定你想让应用看上去怎么样

00:13:11.024 --> 00:13:12.125
这什么意思？

00:13:12.726 --> 00:13:17.497
这意味着 比如说不同于有个新的
标签栏就写代码

00:13:17.564 --> 00:13:18.398
你写道：

00:13:19.066 --> 00:13:21.301
你写说 对于我所有的标签栏

00:13:21.735 --> 00:13:25.205
外表样式中所有未选择的着色是蓝色

00:13:25.706 --> 00:13:28.442
非常简单
每次创建标签栏时

00:13:28.775 --> 00:13:30.377
未选择项目会是蓝色

00:13:31.111 --> 00:13:32.513
但它同样是基于上下文的

00:13:33.013 --> 00:13:37.217
意味着你可以指定基于特征集合

00:13:37.284 --> 00:13:40.487
或基于视图包含物

00:13:42.923 --> 00:13:45.025
这看上去什么样？
让我们看看

00:13:46.059 --> 00:13:48.762
这是我们的应用

00:13:49.196 --> 00:13:53.800
至于样式 我们想把大的标题图片
放在顶部

00:13:53.867 --> 00:13:56.136
在常规型竖向屏幕的时候

00:13:56.403 --> 00:13:59.673
图片会替换导航栏的背景

00:14:00.140 --> 00:14:02.643
然而 当我们在紧凑型竖向屏幕时

00:14:02.910 --> 00:14:04.811
会呈现并排布局

00:14:04.878 --> 00:14:07.714
图片不会超出导航条

00:14:07.781 --> 00:14:10.551
所以我们会用默认背景

00:14:11.151 --> 00:14:13.053
先让我们做默认背景

00:14:14.054 --> 00:14:17.524
创建一个UITraitCollection
给竖向紧凑型屏幕

00:14:19.059 --> 00:14:22.362
把导航条样式赋给特征集合

00:14:23.463 --> 00:14:27.668
说我们不想给这个样式用任何背景图片

00:14:27.968 --> 00:14:31.772
这会导致导航条用回原来默认样式

00:14:32.840 --> 00:14:36.476
类似的 做竖向常规型屏幕时

00:14:37.144 --> 00:14:39.146
给它创建一个特征集合

00:14:40.214 --> 00:14:41.615
用这个样式

00:14:42.549 --> 00:14:45.752
指定一个空图片
导致导航条

00:14:45.819 --> 00:14:48.188
不使用背景图片

00:14:49.089 --> 00:14:53.393
现在 记住给特征集合的样式API

00:14:53.560 --> 00:14:54.695
可能会被读取的很奇怪

00:14:54.761 --> 00:14:57.331
我们实际想修改C2的API

00:14:57.397 --> 00:14:58.665
所以仔细注意这部分

00:14:59.766 --> 00:15:03.604
要结束这个最佳实践的部分前

00:15:04.137 --> 00:15:07.741
这个部分我们回顾了如何用资源目录
整理图片

00:15:08.742 --> 00:15:12.312
动态字体适配用户改变字体大小的愿望

00:15:13.313 --> 00:15:15.883
布局导引帮助你构建你自己的布局

00:15:15.949 --> 00:15:20.120
以容易适配所有布局情况的方式

00:15:20.988 --> 00:15:22.489
最后 外表

00:15:22.656 --> 00:15:25.459
让你的应用看上去跟你想要的一样

00:15:25.759 --> 00:15:27.694
那么接下来
我要交给Kurt继续讲

00:15:35.269 --> 00:15:36.170
谢谢 David

00:15:37.104 --> 00:15:41.408
如果你还记得 从
自适应应用 第一部分演讲中

00:15:41.708 --> 00:15:43.944
要记住的讯息是：

00:15:44.411 --> 00:15:47.247
系统会做大部分工作
你不用做

00:15:48.015 --> 00:15:50.484
现在 我今天要讲的是超越系统做的

00:15:50.951 --> 00:15:54.221
如果你想超越系统提供的

00:15:54.821 --> 00:15:55.822
接下来告诉你怎么做

00:15:56.390 --> 00:15:58.492
这里的关键词是“如果你想要”

00:15:58.559 --> 00:15:59.693
不是必须的

00:16:00.360 --> 00:16:03.664
然而 如果你不想要
即使你不利用它

00:16:03.964 --> 00:16:07.401
还是可以学到如何更有效使用
UIKit

00:16:08.836 --> 00:16:10.938
那么我要讲一些超越基础的

00:16:11.905 --> 00:16:15.409
我要告诉你怎么设计应用来解决
所有各种

00:16:15.475 --> 00:16:17.511
设备方向 尺寸的问题

00:16:18.345 --> 00:16:20.280
你如何实现这些设计

00:16:20.347 --> 00:16:23.317
应用改变大小时 如何动态改变设计

00:16:23.984 --> 00:16:26.186
然后我要讲关于使用可重复元素

00:16:26.253 --> 00:16:28.822
让构建应用更方便快捷

00:16:29.456 --> 00:16:32.459
我会放在做一个应用的上下文中讲这些
这儿我们会做个真正的应用

00:16:32.726 --> 00:16:35.462
那么 称我的应用为
我的非常自适应的应用

00:16:35.996 --> 00:16:38.165
幸运的是
它也很简单

00:16:38.732 --> 00:16:41.635
在这个应用中只要展现三件事

00:16:42.336 --> 00:16:44.204
三个项目
每个项目有个标题

00:16:44.371 --> 00:16:45.973
只是A B 和C

00:16:46.440 --> 00:16:50.010
然后还有更长一些的文本
每个项目一个描述

00:16:50.511 --> 00:16:53.814
即使这个应用非常简单
我会用到一些技巧 你可以在

00:16:53.881 --> 00:16:57.251
更复杂更大的应用中使用

00:16:58.485 --> 00:17:01.622
这就是我应用的原型
这是其中的数据

00:17:01.788 --> 00:17:04.324
那么我的应用该看上去如何
以及如何运行呢？

00:17:04.525 --> 00:17:05.392
设计什么样？

00:17:06.660 --> 00:17:08.762
好 当我在思考设计时

00:17:08.862 --> 00:17:10.830
我需要考虑所有尺寸和方向的组合

00:17:11.330 --> 00:17:14.434
给每个组合做个特别的设计太费事了

00:17:14.734 --> 00:17:17.738
这工作量太大了
让我们试着简化

00:17:18.472 --> 00:17:21.008
我觉得我的应用只需要两个设计

00:17:21.608 --> 00:17:23.143
称第一个为“高的”

00:17:23.210 --> 00:17:26.980
我把所有项目竖着排放
A B 和C竖着放在堆里

00:17:27.981 --> 00:17:31.718
另一个设计叫“宽的”
于是横着排所有项目

00:17:32.819 --> 00:17:35.689
现在 我认为不管应用实际是什么尺寸

00:17:36.023 --> 00:17:39.326
我可以用两者之一的设计
让它们放的合适

00:17:40.661 --> 00:17:41.662
现在我的问题是：

00:17:41.728 --> 00:17:44.364
给到一个设备方向和尺寸的组合

00:17:44.431 --> 00:17:46.366
怎么选择用哪个设计？

00:17:46.800 --> 00:17:50.070
我要定义一个规则
我的应用专用

00:17:51.004 --> 00:17:54.441
我觉得我要选：
如果宽度低于高度

00:17:54.508 --> 00:17:56.009
用“高的”设计

00:17:56.710 --> 00:17:58.645
否则的话 用“宽的”设计

00:17:59.880 --> 00:18:02.616
运行所有的组合看效果怎么样

00:18:02.683 --> 00:18:05.586
在写代码之前先在纸上看看

00:18:06.353 --> 00:18:08.822
比如 这个iPhone是竖向的

00:18:08.889 --> 00:18:11.959
宽度低于高度
我们用“高的“设计

00:18:12.559 --> 00:18:15.162
把iPhone放到横向

00:18:15.462 --> 00:18:19.032
或者iPad全屏
或者iPad部分屏幕

00:18:19.132 --> 00:18:22.302
过一遍所有的例子
全都试一遍确保这个规则能用

00:18:23.871 --> 00:18:25.239
再说一遍我刚刚做的

00:18:25.305 --> 00:18:27.407
在设计应用解决尺寸问题时

00:18:27.808 --> 00:18:29.610
我考虑了所有的组合

00:18:30.577 --> 00:18:34.281
想出了几个设计来覆盖所有组合
整个范围

00:18:35.082 --> 00:18:38.819
然后定义规则来确定用哪个设计

00:18:40.687 --> 00:18:42.189
当我在定义规则时

00:18:42.422 --> 00:18:45.158
有很多方式可以用
这也是让我的应用变得特别的地方

00:18:45.526 --> 00:18:47.661
但要注意我本来可以检查

00:18:47.728 --> 00:18:50.464
尺寸是否正好匹配

00:18:50.531 --> 00:18:53.967
我本来可以看1024x768尺寸

00:18:54.034 --> 00:18:56.803
那么说这是iPad
然后基于这个信息决定设计

00:18:57.104 --> 00:19:00.274
我不想这么做因为这样做会要
解决太多组合

00:19:00.340 --> 00:19:02.176
而具体尺寸会随着时间变化

00:19:03.443 --> 00:19:05.979
所以我定义了一个简单的是否条件

00:19:06.046 --> 00:19:08.081
来告诉我用哪个设计

00:19:08.515 --> 00:19:10.150
有很多方法做这些

00:19:10.551 --> 00:19:13.086
第一条 最明显的是用屏幕分类

00:19:13.153 --> 00:19:14.855
然后就完成了大部分工作

00:19:14.922 --> 00:19:17.891
你只要检查是常规型还是紧凑型

00:19:19.026 --> 00:19:21.228
应用会像系统其他应用一样工作

00:19:21.295 --> 00:19:23.363
因为在用同一个屏幕分类

00:19:23.764 --> 00:19:27.467
所有的Xcode工具可以帮到你
你会无偿得到很多

00:19:28.001 --> 00:19:29.903
但是你也可以自己定义一个规则

00:19:30.637 --> 00:19:34.441
比如可以比较一个值 比如宽度或高度
跟一个阈值比较

00:19:35.409 --> 00:19:38.445
或者比较两个值 像我之前做的
宽度和高度比较

00:19:38.879 --> 00:19:40.080
或者结合这些规则

00:19:40.147 --> 00:19:43.483
重点是想出一个简单清除的规定

00:19:43.550 --> 00:19:45.319
来决定用哪个设计

00:19:47.054 --> 00:19:51.158
在考虑设计时
即使尺寸相同

00:19:51.225 --> 00:19:54.127
比如iPad的一边或者另一边

00:19:54.561 --> 00:19:59.466
不要把设计特定到设备按钮位置

00:19:59.533 --> 00:20:02.469
或者多线程操作时另一个应用在哪儿

00:20:04.938 --> 00:20:06.773
找到应用的大小

00:20:07.674 --> 00:20:10.677
用规则决定用哪个设计

00:20:11.311 --> 00:20:14.014
最后 把设计用在UI上

00:20:14.081 --> 00:20:16.450
改变UI的视图来适配

00:20:17.851 --> 00:20:19.319
现在我该把这段代码放哪儿？

00:20:19.853 --> 00:20:22.923
如果我用个Xcode的新模板
或者新的视图控制器

00:20:22.990 --> 00:20:25.058
有viewDidLoad方法的模板

00:20:25.125 --> 00:20:29.029
它说 在这里进行任何额外设置
那么我就在这儿放代码 对不对？

00:20:29.530 --> 00:20:31.231
不幸的是 没那么简单

00:20:31.865 --> 00:20:35.102
原因是你不会想做这些
因为视图在所需时加载

00:20:35.536 --> 00:20:39.106
第一次要求视图时
这个视图会被调用

00:20:39.606 --> 00:20:40.707
那得很早了

00:20:41.508 --> 00:20:44.878
我们知道那时视图还不是父视图

00:20:45.379 --> 00:20:46.914
布局还无效呢

00:20:47.414 --> 00:20:49.349
所以你不能指望视图尺寸

00:20:49.416 --> 00:20:52.085
活任何父级尺寸或特征之类的

00:20:52.152 --> 00:20:53.086
只是太早了

00:20:53.954 --> 00:20:58.492
对于一次性东西 像初始器
loadView、viewDidLoad

00:20:58.725 --> 00:21:02.229
你会想放一些设计中都一样的代码

00:21:03.130 --> 00:21:04.998
对我来说更好的地方放规则代码

00:21:05.332 --> 00:21:07.768
是在视图控制器的
viewWillLayoutSubViews方法里

00:21:09.870 --> 00:21:13.473
你会看到因为那时视图在父视图中

00:21:14.074 --> 00:21:16.109
父视图的布局已经发生了

00:21:16.243 --> 00:21:18.378
尺寸有效
视图尺寸有效

00:21:18.445 --> 00:21:20.547
特征有效
一切都很好

00:21:21.648 --> 00:21:25.619
这是操纵视图控制器中元素的好时机

00:21:25.719 --> 00:21:28.622
这里改变视图控制器的视图

00:21:28.689 --> 00:21:30.490
约束等等

00:21:31.625 --> 00:21:36.463
现在 注意要小心
因为这是条非常火的路径

00:21:36.530 --> 00:21:39.666
经常被调用 经常
出于你掌控之外的原因

00:21:40.667 --> 00:21:44.304
所以在这个方法里做尽量少的工作

00:21:45.072 --> 00:21:48.909
理想条件下你会发现上次被调用后
什么改变了

00:21:48.976 --> 00:21:51.845
然后基于变化 尽量少的更新

00:21:52.212 --> 00:21:56.183
只改变视图的必须改变的属性

00:21:58.151 --> 00:22:00.754
最后 小心不要导致布局循环

00:22:01.188 --> 00:22:03.323
如果使父视图布局失效

00:22:03.724 --> 00:22:05.692
它们会反过来失效你的布局

00:22:05.859 --> 00:22:08.395
马上你会发现你应用没做任何事
只是不停使生效、

00:22:08.462 --> 00:22:11.198
失效布局
然后任何实际都没有发生

00:22:11.365 --> 00:22:14.434
要了解更多关于调试和
更多关于布局循环

00:22:14.501 --> 00:22:17.204
可以看看今天稍晚些的
自动布局的新进展演讲

00:22:19.339 --> 00:22:22.576
那么这里是我的两个设计
回到这里

00:22:22.643 --> 00:22:24.878
怎样实现它们呢？

00:22:25.612 --> 00:22:29.449
我可以给每个项目A B C一个视图

00:22:30.450 --> 00:22:32.085
然后用UIStackView

00:22:32.152 --> 00:22:34.521
来横向或竖向排列这些东西

00:22:34.788 --> 00:22:37.891
UIStackView做全部工作
我不用特别努力思考

00:22:38.959 --> 00:22:39.993
这有一些代码

00:22:40.427 --> 00:22:43.897
我简单示例的视图控制器是一个
UIViewController的子类

00:22:44.598 --> 00:22:45.866
为它做个storyboard

00:22:45.933 --> 00:22:49.136
其中有个堆视图
而且这个视图中已经有了三个视图

00:22:49.970 --> 00:22:54.374
现在我要
在viewWillLayoutSubviews方法里

00:22:54.441 --> 00:22:55.375
覆写这些

00:22:56.243 --> 00:22:59.112
第一步 得到尺寸
写view.bounds.size

00:23:00.214 --> 00:23:01.582
第二 采用规则

00:23:01.949 --> 00:23:04.151
如果宽度大于高度...

00:23:04.218 --> 00:23:08.255
或等于高度 选择用“宽的”设计

00:23:09.389 --> 00:23:11.291
最后采用设计

00:23:11.892 --> 00:23:13.994
如果再用“宽的”设计

00:23:14.061 --> 00:23:16.530
堆视图的读取会是横向的

00:23:16.597 --> 00:23:19.366
否则就是竖向的
这是所有我要做的

00:23:20.033 --> 00:23:22.469
注意这里我不用做很多工作

00:23:23.003 --> 00:23:26.039
我还利用了StackView很聪明
这个事实

00:23:26.507 --> 00:23:29.710
如果设置读取已有值

00:23:29.776 --> 00:23:31.678
不需要做额外工作

00:23:33.347 --> 00:23:36.717
让我们看看在活动的应用
这是我应用在iPhone竖向屏幕上

00:23:36.783 --> 00:23:40.587
看到竖向布局
现在我旋转到横向

00:23:41.154 --> 00:23:44.391
会看到应用也旋转到横向

00:23:45.259 --> 00:23:47.094
我还无偿得到这个动画

00:23:47.661 --> 00:23:49.963
现在回到竖向
再展示一下

00:23:53.367 --> 00:23:54.701
这样
旋转了

00:23:55.402 --> 00:23:56.403
把这给David看

00:23:56.470 --> 00:23:59.173
因为我被震撼到了
堆视图 免费给了我这个

00:23:59.239 --> 00:24:00.240
我没料到

00:24:00.707 --> 00:24:02.442
他说“好 这很棒

00:24:02.509 --> 00:24:04.912
但怎么让它更好？
你能让它变得更突出吗？”

00:24:05.712 --> 00:24:09.149
如果你是个应用开发者 也许你曾经
从客户那儿听到过这些

00:24:09.383 --> 00:24:11.151
我说“当然 我能让这更突出”

00:24:11.652 --> 00:24:14.721
我可以让应用稍微有趣些
让它更突出

00:24:15.122 --> 00:24:20.260
通过在旋转时 让项目向你变大

00:24:21.195 --> 00:24:23.997
旋转后我让它们回到正常大小

00:24:24.164 --> 00:24:25.165
缩回到正常大小

00:24:27.868 --> 00:24:30.404
这不是我们必须提倡

00:24:30.504 --> 00:24:31.772
你在你应用中做的

00:24:32.739 --> 00:24:35.509
不是这个特定的让应用突出的技巧

00:24:35.843 --> 00:24:40.214
重点是把代码放在哪儿以及具体怎么做

00:24:41.114 --> 00:24:44.585
那么我把代码放在viewWillTransition
方法里来调整大小

00:24:44.651 --> 00:24:45.552
和协调器

00:24:46.353 --> 00:24:49.823
我这么做因为它会在应用尺寸变化时
被调用

00:24:49.890 --> 00:24:50.824
或者在旋转时

00:24:51.225 --> 00:24:53.560
我给协调器设置动画

00:24:53.627 --> 00:24:56.296
在旋转同时设置
之后发生

00:24:57.497 --> 00:24:59.600
为什么不把所有布局代码放在这儿？

00:25:00.000 --> 00:25:03.537
因为应用启动时
第一次不会调用这个方法

00:25:03.604 --> 00:25:05.873
还有别的原因 但那是主要原因

00:25:06.907 --> 00:25:09.076
那么我用协调器
设一段代码

00:25:09.142 --> 00:25:11.044
来在旋转时加入动效

00:25:11.478 --> 00:25:12.746
我要做的是在这段代码中

00:25:12.813 --> 00:25:14.915
设置参数表示我想要动画

00:25:14.982 --> 00:25:18.886
它就会以相同曲线和相同时间旋转

00:25:19.353 --> 00:25:21.321
接下来设置堆视图变化

00:25:21.388 --> 00:25:25.359
到1.4倍
所以变大一点点

00:25:26.627 --> 00:25:30.063
然后结束后
设置自己的动画和持续时间

00:25:30.130 --> 00:25:32.266
这里我选了.5
然后回到正常大小

00:25:32.332 --> 00:25:34.668
设置CGAffineTransform为默认

00:25:34.968 --> 00:25:35.869
也就是正常大小

00:25:36.803 --> 00:25:37.638
那么就这样

00:25:38.005 --> 00:25:40.674
这是同一个应用
上面有多加的代码

00:25:41.008 --> 00:25:41.875
会旋转

00:25:43.911 --> 00:25:45.946
向你弹出然后回去

00:25:46.813 --> 00:25:49.883
如果再旋转 它会做同样的事

00:25:50.817 --> 00:25:53.120
就这样
我加入了弹出效果

00:25:53.187 --> 00:25:54.855
让它变得有趣了些

00:25:54.922 --> 00:25:57.157
但我没有变核心布局代码

00:25:57.224 --> 00:25:59.426
它保持原样
我只是加了些在顶部

00:26:01.929 --> 00:26:04.765
最后我想讲的是可再用元素

00:26:05.599 --> 00:26:08.702
这种方法可以让你构建应用

00:26:08.769 --> 00:26:11.638
由不同设计中可再用的元素

00:26:12.506 --> 00:26:15.509
这种应用构建方法更快
而且利用了

00:26:15.576 --> 00:26:18.579
不同设计而不用重写所有东西

00:26:19.313 --> 00:26:21.148
我们会用到视图控制器

00:26:21.215 --> 00:26:23.317
每个元素往往是一个视图控制器

00:26:23.684 --> 00:26:26.787
这是因为视图控制器打包了
很多有用的东西在一起

00:26:27.221 --> 00:26:29.122
比如你得到了一个树的视图

00:26:29.189 --> 00:26:31.625
不仅是单个视图
而是一整个树的视图

00:26:32.092 --> 00:26:34.061
和所有它们的约束一起

00:26:34.828 --> 00:26:36.964
可以连接到其他的视图控制器

00:26:37.030 --> 00:26:39.933
于是你可以用segue跳转到另一个
不同的视图控制器

00:26:40.000 --> 00:26:43.737
或者呈现某个东西
找到父视图控制器

00:26:43.804 --> 00:26:44.638
之类的

00:26:45.305 --> 00:26:48.408
这里可以和应用的其他部分建立连结

00:26:48.475 --> 00:26:51.845
你可以连接到模型对象或者一个对象

00:26:51.912 --> 00:26:54.081
代表网路接入之类的

00:26:55.516 --> 00:26:59.119
现在你应用的视图控制器有不同的角色

00:26:59.786 --> 00:27:01.755
也许有一个容器视图控制器

00:27:02.122 --> 00:27:06.460
它也许包含了几个被包含的视图控制器

00:27:07.361 --> 00:27:10.364
也许你曾经写过被包含的视图控制器

00:27:10.430 --> 00:27:13.133
然后把它们放在
UIKit提供的容器里

00:27:13.767 --> 00:27:16.870
比如导航控制器
或者分割视图控制器

00:27:16.937 --> 00:27:18.438
或者标签栏控制器等等

00:27:18.705 --> 00:27:21.241
但你可以写自己的容器视图控制器

00:27:21.375 --> 00:27:23.644
这让你解锁很多能量

00:27:23.710 --> 00:27:25.846
你可以通过这做到很多事

00:27:26.880 --> 00:27:29.216
我会展示给你如何做到
又是我的设计

00:27:29.816 --> 00:27:33.820
在我的案例中 我认为我可以有一个
外面的容器视图控制器

00:27:35.556 --> 00:27:37.858
我称它为
示例容器视图控制器

00:27:38.292 --> 00:27:41.228
在那里面我又三个元素视图控制器

00:27:41.295 --> 00:27:42.863
每个元素有一个视图控制器

00:27:44.264 --> 00:27:48.202
现在 想想
我认为我的设计需要一点精化

00:27:48.669 --> 00:27:50.103
如果我没有很多空间

00:27:50.170 --> 00:27:52.806
我会需要展示这些项目的预览

00:27:52.873 --> 00:27:55.209
我没有地方放全部文本
只够放标题

00:27:56.009 --> 00:27:58.345
那么当我点击其中一项时

00:27:58.412 --> 00:28:01.448
或者 不好意思 轻击其中一项时
它会呈现预览

00:28:01.915 --> 00:28:05.319
会呈现展示全文的另一个视图控制器

00:28:06.119 --> 00:28:09.423
然后如果我再轻击那个
我们就遣散了它 它会不见

00:28:10.624 --> 00:28:14.328
做出这个通过...
我的示例容器视图控制器

00:28:14.394 --> 00:28:17.397
会有三个小的元素视图控制器

00:28:17.464 --> 00:28:18.565
我们等会儿会定义它

00:28:19.233 --> 00:28:21.401
当我们要呈现一个时
轻击它

00:28:21.468 --> 00:28:24.905
就创建并呈现了一个新的大的
元素视图控制器

00:28:26.240 --> 00:28:29.042
如果我的应用够大
我不需要做这些

00:28:29.109 --> 00:28:33.380
我只要展示这里的大的
元素视图控制器就可以了

00:28:34.481 --> 00:28:35.883
直接在容器里

00:28:36.149 --> 00:28:39.119
所以我的容器会有三个另一个类的
实例

00:28:39.186 --> 00:28:40.754
LargeElementViewController类

00:28:41.188 --> 00:28:44.892
当应用动态改变尺寸时

00:28:45.058 --> 00:28:49.096
我们要在这两种视图控制器层级的状态
之间改变

00:28:50.130 --> 00:28:51.431
在这里展示代码

00:28:51.498 --> 00:28:54.201
我们将从被包含的视图控制器
向上讲到

00:28:54.268 --> 00:28:55.402
容器

00:28:55.469 --> 00:28:58.572
从给这些被包含的视图控制器的
storyboard开始讲

00:28:58.906 --> 00:29:02.176
它很简单 这里有个简单带标题的视图

00:29:02.476 --> 00:29:06.180
注意我设置自定义类为
小元素视图控制器

00:29:06.513 --> 00:29:09.850
把storyboard标识符
设为小元素

00:29:09.917 --> 00:29:13.387
就能在storyboard找到这些
然后之后举例说明它们

00:29:14.588 --> 00:29:17.791
至于大元素视图控制器
它更大 其中有更多文本

00:29:17.858 --> 00:29:18.692
同样道理

00:29:18.759 --> 00:29:21.428
设置自定义类为
大元素视图控制器

00:29:21.895 --> 00:29:23.163
然后设置标识符

00:29:24.498 --> 00:29:26.934
这儿是给小元素视图控制器的代码

00:29:27.201 --> 00:29:29.570
从这开始
我知道每次展示这些

00:29:29.636 --> 00:29:32.673
就要点击来展示大的视图了

00:29:32.739 --> 00:29:36.243
在viewDidLoad方法中
有个适合的时机来做这个

00:29:36.643 --> 00:29:38.712
我要设置轻击手势识别器

00:29:39.046 --> 00:29:40.047
加到视图中

00:29:41.114 --> 00:29:44.484
接下来它被轻击时会被调用

00:29:45.319 --> 00:29:47.521
找到主storyboard

00:29:47.588 --> 00:29:50.390
举例说明大元素视图控制器

00:29:50.457 --> 00:29:52.226
用标识符 大元素

00:29:52.993 --> 00:29:55.863
最后只要呈现它们

00:29:57.664 --> 00:30:00.200
在大元素视图控制器中更复杂一些

00:30:00.267 --> 00:30:02.936
因为我们需要知道是否在被呈现

00:30:03.136 --> 00:30:05.372
如果在被展示
需要轻击来退出

00:30:05.439 --> 00:30:06.473
如果不是
不需要

00:30:07.174 --> 00:30:09.076
所以我把这段代码放在
viewWillAppear方法里

00:30:09.343 --> 00:30:11.545
我这么做因为能用另一个方法

00:30:11.945 --> 00:30:15.082
isBeingPresented
方法找出这视图是否被呈现

00:30:16.049 --> 00:30:19.353
如果在被展现
跟之前一样加入轻击手势识别器

00:30:19.853 --> 00:30:22.155
当被轻击时
所有要做的只是退出

00:30:25.158 --> 00:30:27.561
现在进入容器视图控制器

00:30:28.629 --> 00:30:30.430
我准备加额外的一个对象

00:30:30.497 --> 00:30:32.165
让它更容易工作

00:30:35.802 --> 00:30:37.938
叫做设计对象

00:30:39.173 --> 00:30:41.141
设计对象可以包裹

00:30:41.208 --> 00:30:43.977
所有描述一个设计的信息

00:30:45.379 --> 00:30:48.315
我把它做成一个无法改变的值类
出于安全考虑

00:30:48.382 --> 00:30:52.252
写一个函数返回其中一个
之后它无法改变

00:30:52.319 --> 00:30:53.287
没人能改变它

00:30:54.521 --> 00:30:56.456
它允许比较

00:30:56.523 --> 00:31:01.295
这样就可以看我想要的设计和当前显示
是否不同

00:31:02.462 --> 00:31:07.134
让我们实现它
我只有一个简单的Swift结构

00:31:07.401 --> 00:31:09.636
它有两项信息

00:31:09.736 --> 00:31:11.171
第一个是轴

00:31:11.505 --> 00:31:15.242
从堆视图中重复使用这个枚举
可以是竖向或横向的

00:31:16.543 --> 00:31:20.113
然后定义这个自己的枚举为
是否在用小版本

00:31:20.180 --> 00:31:22.382
或里面视图控制器的大版本

00:31:22.449 --> 00:31:23.717
称其为ElementKind

00:31:24.852 --> 00:31:27.955
最后这里有个只读的计算的属性

00:31:28.055 --> 00:31:29.423
称为
elementIdentifier

00:31:29.723 --> 00:31:31.959
这只是用来告诉我用哪个标识符

00:31:32.025 --> 00:31:34.428
做storyboard里视图控制器

00:31:36.396 --> 00:31:39.399
最后 实现Swift里的
Equatable协议

00:31:39.733 --> 00:31:43.537
这里只是双等号函数
我在两个设计中比较数据

00:31:43.604 --> 00:31:44.671
来看它们是否相同

00:31:46.640 --> 00:31:49.009
让我们进入容器视图控制器

00:31:49.076 --> 00:31:50.143
然后做这些

00:31:50.210 --> 00:31:53.113
你记得它会有三个子视图控制器

00:31:54.014 --> 00:31:57.317
它要用这些规则来创建决定用哪个设计

00:31:58.051 --> 00:31:59.152
然后更新

00:31:59.219 --> 00:32:01.955
每个布局会重新评估用哪个设计

00:32:02.022 --> 00:32:03.423
然后改些东西如果需要的话

00:32:04.224 --> 00:32:06.860
那么这样
示例视图控制器

00:32:06.927 --> 00:32:10.731
这里有个包含三个位置的数组
给三个可选视图控制器

00:32:11.198 --> 00:32:12.165
它们开始是无值

00:32:12.232 --> 00:32:15.903
当它一开始被创建时
还没有展示任何东西

00:32:17.237 --> 00:32:20.440
我还要跟踪记录当前展示的设计

00:32:20.507 --> 00:32:23.677
这也是可选的 现在是无值的
因为还没有发生什么

00:32:24.745 --> 00:32:28.148
在viewWillLayoutSubviews方法中
这些现在应该看来很熟悉了

00:32:28.215 --> 00:32:29.550
得到尺寸

00:32:30.050 --> 00:32:33.086
调用一个叫
decideDesign的函数

00:32:33.320 --> 00:32:35.923
基于尺寸
返回一个新的设计使用

00:32:36.657 --> 00:32:39.393
如果这个设计和当前显示的不同

00:32:39.459 --> 00:32:43.230
我就把设计用到UI上
改变UI来匹配

00:32:44.031 --> 00:32:48.235
注意这和我之前讲的伪代码一模一样

00:32:48.735 --> 00:32:51.438
不管你的应用做什么

00:32:51.638 --> 00:32:53.607
你也可以按照这个模式来

00:32:53.740 --> 00:32:55.742
也许你的设计中有不同的东西

00:32:55.876 --> 00:32:58.946
你的decideDesign和
applyDesign方法不同

00:32:59.479 --> 00:33:02.649
但会按照一模一样的模式

00:33:03.951 --> 00:33:06.253
现在把这些函数填进示例应用中

00:33:06.653 --> 00:33:10.691
DecideDesign
先决定坐标轴

00:33:10.757 --> 00:33:13.660
我们已经讲过了对这个规则怎么做

00:33:14.361 --> 00:33:16.730
对elementKind
我将用一个不同规则

00:33:16.797 --> 00:33:21.468
我决定选择比较应用宽度是否低于
阈值的规则

00:33:21.535 --> 00:33:24.238
选择用小的视图控制器
否则用大的

00:33:24.605 --> 00:33:26.373
这里我在跟一个定值做比较

00:33:26.440 --> 00:33:28.442
这是一个给我应用用的例子

00:33:28.509 --> 00:33:31.845
你不一定在你的应用中用这个值
这只是一个例子

00:33:33.280 --> 00:33:35.949
把这两样信息打包

00:33:36.016 --> 00:33:37.918
进设计对象
然后返回它

00:33:39.319 --> 00:33:42.422
用这个设计 采用这两样

00:33:42.623 --> 00:33:44.391
我需要找出它们是否改变了

00:33:44.591 --> 00:33:47.194
坐标轴直接传递到堆视图

00:33:47.261 --> 00:33:49.596
它很聪明
不会做任何不需要做的事

00:33:50.531 --> 00:33:52.633
对于elementKind
我们还有些工作要做

00:33:53.500 --> 00:33:58.605
如果有旧的元素视图控制器
而且元素类型在改变

00:33:58.672 --> 00:34:01.275
那么我们需要毁掉老的
创建新的

00:34:01.675 --> 00:34:05.112
这里我们要做的是迭代整个数组

00:34:05.179 --> 00:34:07.247
这里我用了这个枚举函数

00:34:07.314 --> 00:34:10.150
因为它让我们得到索引和
在那个索引的对象

00:34:10.217 --> 00:34:12.018
在迭代的同时

00:34:13.085 --> 00:34:15.856
最后 如果我们有一个
旧的元素视图控制器

00:34:16.190 --> 00:34:18.926
需要删除它
可以调用这个函数删除

00:34:19.626 --> 00:34:22.329
到storyboard
创建一个新的元素视图控制器

00:34:22.396 --> 00:34:24.598
用设计给我的标识符创建

00:34:25.199 --> 00:34:28.335
最后调用函数 加入新的子视图控制器

00:34:28.969 --> 00:34:32.005
然后保存它到数组为了下一次迭代

00:34:33.774 --> 00:34:36.210
这是最后一页代码幻灯片
谢谢你们听我讲到这儿

00:34:36.409 --> 00:34:37.744
这些是我们需要做的

00:34:37.811 --> 00:34:40.013
来做一个运行良好的容器视图控制器

00:34:40.080 --> 00:34:42.649
完全按照这个顺序完成步骤很重要

00:34:43.350 --> 00:34:46.954
加入新的视图控制器时
调用addChildViewController

00:34:47.020 --> 00:34:52.926
这个方法加入这个视图控制器
到自身的一列视图控制器中

00:34:53.827 --> 00:34:56.763
然后需要加入那个新的
视图控制器的视图

00:34:56.830 --> 00:34:57.931
到视图层级中

00:34:58.565 --> 00:35:02.603
通过运用堆视图的
addArrangedSubviews方法

00:35:03.036 --> 00:35:04.538
UIKit不会帮你做这个

00:35:04.605 --> 00:35:06.840
也不能帮你做这个
因为我们不知道

00:35:06.907 --> 00:35:09.643
在视图层级中它该放在哪儿

00:35:09.710 --> 00:35:11.178
只有你能告诉我们这些

00:35:12.379 --> 00:35:14.915
最后 做完前面步骤以后
你告诉那个视图控制器

00:35:14.982 --> 00:35:18.018
它移到了新的父视图控制器
那里是“自己”

00:35:19.319 --> 00:35:22.289
要移除旧的
做基本上相同的步骤

00:35:22.356 --> 00:35:23.557
只是以相反的顺序

00:35:23.757 --> 00:35:27.094
我们告诉它
它会移到一新的父视图控制器 即无值

00:35:27.861 --> 00:35:29.863
从视图层级中移除它的视图

00:35:30.163 --> 00:35:34.301
最后从自身的子视图控制器中移除自己

00:35:36.370 --> 00:35:38.972
就是这样
最终给你们展示了应用

00:35:39.139 --> 00:35:43.010
这里我们在看横屏的iPad
有很多空间

00:35:43.076 --> 00:35:46.813
我们用横向布局和大元素视图控制器

00:35:47.548 --> 00:35:50.350
现在我划到另一个应用固定住

00:35:52.085 --> 00:35:55.022
我的应用变小了
它换到了竖向布局

00:35:55.255 --> 00:35:57.491
我还是在用大元素视图控制器

00:35:57.558 --> 00:36:01.128
它们和之前我们看的视图控制器一样

00:36:01.828 --> 00:36:04.598
现在如果我还把应用变得更小

00:36:06.867 --> 00:36:08.936
你会注意到我们换到了小点儿的设计

00:36:09.002 --> 00:36:11.872
还是竖向 但在用小一点的设计

00:36:12.105 --> 00:36:14.808
现在我能轻击其中一个小视图控制器

00:36:14.875 --> 00:36:18.412
呈现大的那个
如果再轻击 会退出它

00:36:19.980 --> 00:36:22.883
这就是我的应用
记住我们超越了基本的

00:36:22.950 --> 00:36:25.886
我们真的决定了要自己完成这些

00:36:26.453 --> 00:36:29.022
我解决了所有组合的设计

00:36:30.224 --> 00:36:31.658
实现了每个设计

00:36:31.725 --> 00:36:34.995
应用变换尺寸时在不同设计间动态变化

00:36:35.762 --> 00:36:38.065
还用了可重复使用元素来完成

00:36:38.966 --> 00:36:42.336
我的应用只是一个示例
你的应用也能做到这些

00:36:44.538 --> 00:36:48.509
我们讲过了基础
展示给你Xcode能办到什么

00:36:48.575 --> 00:36:52.279
展示了一些
UIKit提供的很棒的东西

00:36:52.346 --> 00:36:54.281
在一整套瑞士军刀一样的工具里

00:36:54.581 --> 00:36:56.984
在实例应用中讲过了代码

00:36:57.317 --> 00:36:59.520
可我们还只是涉及了表面

00:36:59.586 --> 00:37:00.754
还有很多要做

00:37:00.988 --> 00:37:03.757
看看这个URL里的示例代码

00:37:04.725 --> 00:37:07.861
还有 如果你还没有看第一部分
请回顾它

00:37:07.928 --> 00:37:11.665
有一个“兼收并蓄的应用设计”演讲
会讲到字体排印

00:37:12.733 --> 00:37:16.670
David提到
集合视图和自动布局的新特性

00:37:17.171 --> 00:37:19.373
还有WWDC去年两年

00:37:19.439 --> 00:37:21.975
我们讲过关于自适应应用和多线程任务

00:37:22.042 --> 00:37:24.578
真的不想重复太多那些材料

00:37:24.645 --> 00:37:26.380
所以请复习那些东西

00:37:26.446 --> 00:37:28.715
那些演讲中有很多很好的材料

00:37:29.449 --> 00:37:31.451
那么谢谢各位
愿各位度过一个很棒的周五