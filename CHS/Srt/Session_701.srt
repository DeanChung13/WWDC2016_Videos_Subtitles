00:00:19.620 --> 00:00:25.993
Apple File System介绍
下一代存储的快照

00:00:26.927 --> 00:00:28.428
好了 欢迎各位

00:00:28.495 --> 00:00:32.198
我叫Eric Tamura
旁边是Dominic Giampaolo

00:00:32.266 --> 00:00:35.135
我们会向各位讲一下
Apple File System

00:00:42.743 --> 00:00:47.181
这是关于今天展示内容的
一些流程图

00:00:47.447 --> 00:00:50.484
我会稍微讲一下
介绍与动机

00:00:50.584 --> 00:00:52.152
为什么我们决定去构建它

00:00:52.553 --> 00:00:55.689
我们添加了一些新功能
作为Apple File System的一部分

00:00:55.756 --> 00:00:57.791
我们简短地展示这些新功能

00:00:57.858 --> 00:00:59.026
然后在结尾我们会

00:00:59.092 --> 00:01:02.396
谈谈你可以在应用中
使用的一些新API

00:01:04.431 --> 00:01:06.133
我们开始吧

00:01:06.533 --> 00:01:08.302
就像Sebastian提过的

00:01:08.368 --> 00:01:12.072
Apple File System可用在
macOS Sierra的 WWDC 版本

00:01:12.139 --> 00:01:13.807
你们昨天都得到了

00:01:14.174 --> 00:01:17.244
并且它会作为
开发者预览版技术

00:01:17.311 --> 00:01:21.682
于秋季macOS Sierra的
发布之后 在其上面使用

00:01:22.950 --> 00:01:24.818
什么是Apple File System？

00:01:25.085 --> 00:01:28.989
它是我们下一代文件系统
是我们为Apple产品所构建的

00:01:29.356 --> 00:01:30.657
你可能会关心这个

00:01:30.724 --> 00:01:36.029
因为它会在watchOS
iOS tvOS和macOS上运行

00:01:36.630 --> 00:01:38.232
对于预期的受众

00:01:38.298 --> 00:01:41.668
我们预计你们要么
在这些平台上是初来乍到

00:01:41.735 --> 00:01:43.170
或者是一位长期开发者

00:01:43.604 --> 00:01:45.072
但我们打算涵盖

00:01:45.138 --> 00:01:48.609
新文件系统中
所有高级功能的足够细节

00:01:48.675 --> 00:01:49.977
这样你能跟得上

00:01:51.011 --> 00:01:54.314
该产品的一个特点是
我们想从

00:01:54.381 --> 00:01:57.150
从Apple Watch
一路扩展到Mac Pro

00:01:58.452 --> 00:02:01.555
我们也想利用闪存和SSD存储

00:02:01.622 --> 00:02:04.725
因为几乎我们所有的产品
都使用SSD

00:02:06.159 --> 00:02:09.496
最后 其构建有加密
作为主要功能

00:02:09.562 --> 00:02:13.133
从最开始到现在
我们将这个想法变为现实

00:02:14.501 --> 00:02:17.070
你可能会想那HFS+怎么办

00:02:17.137 --> 00:02:21.708
我们目前把HFS+
作为主文件系统发布

00:02:22.843 --> 00:02:25.612
但其最初设计
到目前几乎有30年之久

00:02:25.679 --> 00:02:28.815
你们当中有多少人希望
我们再发布30年的HFS+？

00:02:30.384 --> 00:02:34.688
很好 所以HFS+设计于

00:02:34.755 --> 00:02:37.658
软盘和硬盘代表
最新技术水平的时代

00:02:38.392 --> 00:02:39.626
自此世界改变了很多

00:02:39.693 --> 00:02:44.698
现在我们使用SSD 而且
其它下一代存储技术也不断发展

00:02:45.699 --> 00:02:48.936
HFS+的数据结构
相对来说也是单线程的

00:02:49.002 --> 00:02:53.807
所以B-trees要依靠
大分块来访问或改变它们

00:02:56.610 --> 00:02:59.079
并且数据结构也相对死板

00:02:59.146 --> 00:03:03.317
我们的意思是 像是
HFS+中的文件记录或目录记录

00:03:03.383 --> 00:03:06.687
差不多相当于其他
文件系统的索引节点

00:03:06.753 --> 00:03:09.990
是固定的 这是为了添加
新的字段来扩展文件系统

00:03:10.057 --> 00:03:12.359
加入新的功能
我们必须付出代价

00:03:12.426 --> 00:03:15.229
那就是向后不兼容的卷格式改变

00:03:15.295 --> 00:03:18.398
我们的意思是
如果我们给HFS+添加新功能

00:03:18.465 --> 00:03:22.936
回到10.5版本 然后
附加那个相同的文件系统

00:03:23.136 --> 00:03:24.238
这会发生什么？

00:03:24.671 --> 00:03:27.107
所以如果我们关心向后兼容

00:03:27.174 --> 00:03:30.644
以及向前兼容
我们开始考虑

00:03:30.711 --> 00:03:34.515
也许打造完全
崭新的东西是有意义的

00:03:35.849 --> 00:03:37.784
所以我们考虑出新的东西

00:03:38.719 --> 00:03:43.257
我们想要的是为Apple产品
专门设计和优化的东西

00:03:43.524 --> 00:03:46.960
其他文件系统良好地
执行着其他目的

00:03:47.394 --> 00:03:53.500
尤其 文件管理器或者企业级别
存储服务器有很多的功能

00:03:53.567 --> 00:03:55.636
对于Apple产品没有太大意义

00:03:55.702 --> 00:03:58.939
我们通常在所有产品上
使用单个存储设备

00:03:59.139 --> 00:04:02.042
而且我们的规模广泛

00:04:02.109 --> 00:04:07.347
在Apple Watch上
你有更少的DRAM和存储空间

00:04:07.414 --> 00:04:10.050
与Mac Pro相比
Mac Pro有数十GB的

00:04:10.117 --> 00:04:12.953
潜在DRAM
以及数TB的存储空间

00:04:13.086 --> 00:04:15.389
所以我们想要
灵活动态的东西

00:04:15.489 --> 00:04:18.492
而且在那些平台上运行

00:04:20.894 --> 00:04:22.162
我们想打造的其它东西

00:04:22.229 --> 00:04:24.965
我们想新加并增强安全功能

00:04:25.032 --> 00:04:29.269
我们现在已经在iOS上
发布了HFS+的一个版本

00:04:29.469 --> 00:04:31.572
使用每文件加密

00:04:31.638 --> 00:04:34.341
所以在存储空间上
每个文件都是不同加密的

00:04:34.408 --> 00:04:37.110
不同于这个文件系统
上的其它任何文件

00:04:37.845 --> 00:04:39.413
我们想更进一步

00:04:39.479 --> 00:04:43.183
我们会在稍后的展示中
深入谈谈这些功能

00:04:44.384 --> 00:04:47.821
最后 我们想加入一些
新的通用文件系统功能

00:04:48.455 --> 00:04:51.925
是应大家要求
而且我们认为是十分重要的

00:04:51.992 --> 00:04:54.161
对于我们平台的未来

00:04:55.429 --> 00:04:56.997
在我们讲这些新功能之前

00:04:57.064 --> 00:05:00.133
我想给大家简短介绍一下

00:05:00.200 --> 00:05:02.769
Apple存储软件的样子

00:05:03.170 --> 00:05:07.808
在文件系统和存储方面
我们会谈论HFS+

00:05:08.375 --> 00:05:12.112
但我们涉及的范围
不止是HFS+

00:05:12.179 --> 00:05:14.381
这里实际上有很多辅助技术

00:05:14.448 --> 00:05:16.617
构成了我们的存储软件

00:05:17.518 --> 00:05:18.952
在一开始
我们有HFS标准

00:05:19.019 --> 00:05:21.421
这几乎
至今有30年之久

00:05:21.655 --> 00:05:25.492
若干年后
我们添加了HFS+

00:05:25.659 --> 00:05:27.261
不过我们加入了死机防护

00:05:27.327 --> 00:05:30.664
我们还加入了
区分大小写变体的日志

00:05:32.065 --> 00:05:35.502
我们还增加了CoreStorage
这给了我们全盘加密

00:05:35.569 --> 00:05:39.206
以及Fusion Drive
这将SSD的速度与

00:05:39.273 --> 00:05:41.441
硬盘的容量相组合

00:05:42.075 --> 00:05:44.745
我们不能忘记
所有针对iOS的变体

00:05:44.811 --> 00:05:49.383
我们有针对iOS的HFS+变体
以及支持

00:05:49.449 --> 00:05:51.885
刚才谈到的每文件加密的变体

00:05:52.653 --> 00:05:55.355
所以我们的目的是
所有这些技术

00:05:55.422 --> 00:05:59.560
都被一样东西所取代
那就是Apple File System

00:06:02.329 --> 00:06:05.966
我来稍微谈谈Apple File
System中的一些新功能

00:06:09.136 --> 00:06:13.207
这个简明的视图
囊括了我们现有内容

00:06:13.273 --> 00:06:15.876
我们有一些
改进的文件系统底层技术

00:06:16.176 --> 00:06:21.381
HFS兼容性 空间分享
克隆文件和目录

00:06:21.448 --> 00:06:24.418
快照和快照恢复

00:06:24.852 --> 00:06:27.354
一项我们称之为
目录大小快速调整的功能

00:06:27.688 --> 00:06:30.324
原子级安全存储基元
以及加密

00:06:30.390 --> 00:06:31.859
你不必把它们都记下来

00:06:31.925 --> 00:06:35.529
我们会在下面的幻灯片中
进行深入讲解的

00:06:37.664 --> 00:06:40.667
首先来谈谈
一些改进的底层技术

00:06:40.734 --> 00:06:42.936
改进的文件系统底层技术

00:06:43.003 --> 00:06:45.839
首先闪存和SSD优化

00:06:46.540 --> 00:06:49.877
在我们所有的设备上
在我们所有的iOS设备上

00:06:49.943 --> 00:06:52.779
而且很多Mac上
是内置有SSD的

00:06:52.946 --> 00:06:55.949
我们想尽可能地
对固态硬盘进行优化

00:06:56.950 --> 00:06:59.987
其还有死机防护功能
APFS或Apple File System

00:07:00.053 --> 00:07:02.923
采用崭新的
写入时复制元数据方案

00:07:02.990 --> 00:07:07.661
所以每个元数据写入都
写入到稳态存储上的新位置

00:07:07.828 --> 00:07:10.898
我们将其与
事务处理子系统相组合

00:07:10.964 --> 00:07:13.967
这保证了如果断电
如果机器死机

00:07:14.034 --> 00:07:16.770
或糟糕的事情发生
你会看到一致视图

00:07:16.837 --> 00:07:20.807
关于之前的磁盘内容
或者什么变更都看不到

00:07:23.477 --> 00:07:25.879
我们有现代64位原生字段

00:07:25.946 --> 00:07:29.049
所以索引节点号
扩展成了64位

00:07:29.316 --> 00:07:32.486
我们有时间戳现在也是64位

00:07:32.553 --> 00:07:34.988
我们支持纳秒时间戳粒度

00:07:35.255 --> 00:07:38.692
我们也支持Sparks Files
在Apple File System上是首次

00:07:39.893 --> 00:07:43.830
所有指向磁盘上
分块实际位置的

00:07:43.897 --> 00:07:47.100
文件和目录记录
也扩展成了64位

00:07:48.368 --> 00:07:51.471
我们的数据结构也是可扩展的
而且允许未来扩展

00:07:51.772 --> 00:07:54.374
所以我们讨论
HFS+的一件事是

00:07:54.441 --> 00:07:57.244
其数据结构相对死板

00:07:57.711 --> 00:07:59.913
在APFS或Apple
File System上

00:08:00.347 --> 00:08:04.718
代表核心索引节点的
数据结构现在是灵活的

00:08:05.018 --> 00:08:07.921
所以字段是可选的
或我们可能尚未将其创造出来

00:08:07.988 --> 00:08:10.757
所以我们在过程中
可能选择添加的新字段

00:08:11.124 --> 00:08:13.427
会被正确识别成不支持

00:08:13.493 --> 00:08:16.763
或是我不清楚
你是否将那个存储

00:08:16.830 --> 00:08:20.200
附加到当前版本的
macOS Sierra

00:08:20.667 --> 00:08:22.469
这样我们可以添加新功能

00:08:22.536 --> 00:08:26.006
不需要担心
会破坏掉向后兼容

00:08:26.573 --> 00:08:28.775
这还允许我们
拥有可选字段

00:08:28.842 --> 00:08:32.578
在一些系统上
单是文件的存在

00:08:32.645 --> 00:08:34.982
就足够传递出一些信息

00:08:35.349 --> 00:08:38.619
如果你有0字节的文件
你不一定需要

00:08:38.684 --> 00:08:41.121
所有机器指向
哪个分块在磁盘上

00:08:41.188 --> 00:08:43.857
因为它们不需要
所以这些字段是可选的

00:08:45.592 --> 00:08:48.262
这也优化于Apple
Software生态系统

00:08:48.328 --> 00:08:52.165
我们想添加功能
并优化API

00:08:52.232 --> 00:08:55.569
这对我们平台的
向前发展极其重要

00:08:58.639 --> 00:09:00.607
我们也有低延迟设计

00:09:00.674 --> 00:09:04.945
在文件系统中 延迟
通常是延迟与吞吐量之间的折衷

00:09:05.012 --> 00:09:08.081
我们选择倾向延迟这一边

00:09:08.549 --> 00:09:10.584
这么做是因为
我们想让你的应用

00:09:10.651 --> 00:09:15.489
当用户在桌面上点击应用
或在手机上按下应用时

00:09:15.556 --> 00:09:17.624
你想让应用快速出现
响应迅速

00:09:17.691 --> 00:09:19.426
而且有非常明快的动画

00:09:19.760 --> 00:09:21.828
这个的原因是
当你进入文件系统

00:09:21.895 --> 00:09:25.933
我们想确保
你会尽快得到你想要的回答

00:09:27.501 --> 00:09:30.771
最后我们有原生加密支持
内置于系统内部

00:09:31.138 --> 00:09:34.575
我们提过了 在HFS+上
使用的是每文件加密

00:09:34.641 --> 00:09:37.244
不过它们是通过
扩展属性存储在磁盘上的

00:09:37.578 --> 00:09:40.981
在Apple File System上并非如此
它们现在就如头等公民一般

00:09:41.048 --> 00:09:44.184
是文件系统内部的一级对象

00:09:45.819 --> 00:09:47.421
这就是底层技术的略微介绍

00:09:47.721 --> 00:09:48.956
HFS兼容性

00:09:49.022 --> 00:09:52.326
如果你们的应用
在HFS+上运行良好

00:09:52.659 --> 00:09:54.828
我们打算让它们继续运行

00:09:54.895 --> 00:09:57.865
不需要你那边
进行任何更改

00:09:58.265 --> 00:10:02.236
Apple File System会支持
并替换HFS+的功能

00:10:02.302 --> 00:10:03.303
这里有个星号

00:10:03.370 --> 00:10:06.874
因为有三个功能
我们不会继续支持

00:10:07.207 --> 00:10:10.811
一个是交换数据
另一个是Search FS

00:10:10.878 --> 00:10:14.781
然后第三个是
“时间机器”的目录硬链接

00:10:15.749 --> 00:10:21.388
不过其他剩下的API和行为
都会得到支持 和HFS+一样

00:10:23.056 --> 00:10:24.958
现在我想稍微讲讲
空间分享

00:10:25.025 --> 00:10:28.428
这是Apple File System上
新添加的一项功能

00:10:29.196 --> 00:10:32.099
我快速调查一下
在座的有多少人

00:10:32.165 --> 00:10:35.669
有Mac或者在Mac上
使用一个以上的分区？

00:10:36.870 --> 00:10:41.842
非常好 我们也是
在内部我们做的一件事

00:10:41.909 --> 00:10:45.279
是我们想让开发版本的OS
在一个分区上

00:10:45.345 --> 00:10:48.615
我们想让稳定发布版本
在另一个分区上

00:10:48.815 --> 00:10:50.851
或你可能选择将主目录放在一个分区上

00:10:50.918 --> 00:10:54.154
其他你不在意的不同数据
放在另一个上面

00:10:54.621 --> 00:10:57.891
不过我们得知了一件事
通过分析

00:10:57.958 --> 00:10:59.960
来自用户选择性输入的
数据收集

00:11:00.027 --> 00:11:02.429
以及向Apple设备
报告的统计数据

00:11:02.496 --> 00:11:07.167
大多数终端用户不这样做
他们只有一个分区

00:11:07.734 --> 00:11:10.137
他们不做的原因是这很困难

00:11:10.370 --> 00:11:13.040
你必须清楚知道
如何给磁盘布局

00:11:13.106 --> 00:11:16.777
在你设置的时候
而且更换它是比较昂贵的

00:11:17.211 --> 00:11:19.847
此外 一个分区上的空闲空间
如你所知

00:11:19.913 --> 00:11:23.650
不会转换成
另一分区上的可用空闲空间

00:11:24.151 --> 00:11:27.254
所以我们使用名为
空间分享的功能来解决该问题

00:11:27.654 --> 00:11:28.889
我们看看这个例子

00:11:28.956 --> 00:11:32.159
我们会在流程中
说明这项功能

00:11:32.226 --> 00:11:35.362
假设你在下载
最新最棒的猫咪视频

00:11:35.429 --> 00:11:38.498
从朋友那里得来的
在网络上用AirDrop下载

00:11:39.266 --> 00:11:42.402
假设文件变大
越来越大

00:11:42.469 --> 00:11:45.973
事实上
大到你的空间都被占满了

00:11:46.039 --> 00:11:48.008
在你运行的那个分区上

00:11:48.509 --> 00:11:50.244
这种情况下
你做不了多少事情

00:11:50.310 --> 00:11:51.545
若空间占满
那就是占满了

00:11:51.979 --> 00:11:55.916
你可以做的一件事是
之后马上完全销毁

00:11:55.983 --> 00:11:58.652
那个分区
然后扩张分区1

00:11:58.719 --> 00:11:59.786
我们来看看

00:12:00.053 --> 00:12:04.758
我们可以销毁分区2
分区1扩张

00:12:04.825 --> 00:12:08.562
现在你有足够的空间
来继续下载猫咪视频了

00:12:09.763 --> 00:12:12.999
但这也很不灵活
而且会带来一些问题

00:12:13.066 --> 00:12:16.570
如果你下载的文件不在分区1上

00:12:16.637 --> 00:12:19.072
而实际上是在分区0

00:12:19.673 --> 00:12:21.942
这种情况下
你会下载文件

00:12:22.009 --> 00:12:26.246
越来越大
就算你有空闲空间

00:12:26.313 --> 00:12:29.383
或者愿意销毁分区2上的内容

00:12:29.550 --> 00:12:33.687
我们可以销毁它
不过这样分区0不会扩张

00:12:33.820 --> 00:12:35.956
因为它并不靠近任何我们刚才

00:12:36.023 --> 00:12:37.391
腾出来的空闲空间

00:12:37.524 --> 00:12:40.727
所以我们认为这是可以
使用空间分享解决的问题

00:12:41.128 --> 00:12:43.764
在Apple File System中
我们想出了这一基本概念

00:12:43.830 --> 00:12:46.033
我们称其为容器
很合适的名字

00:12:46.099 --> 00:12:49.736
因为它包含了卷或单个文件系统

00:12:50.571 --> 00:12:53.607
在这个实例中
Apple File System的容器

00:12:53.674 --> 00:12:55.609
代表了最低级别的功能

00:12:55.676 --> 00:12:58.579
这个封装了我们的块分配器

00:12:58.645 --> 00:13:00.981
以及我们的死机防护子系统

00:13:01.715 --> 00:13:04.718
假如说我们有分区0
在分区中占有一定

00:13:04.785 --> 00:13:07.921
数量的空闲空间

00:13:08.989 --> 00:13:11.925
卷可以扩张或缩小

00:13:12.860 --> 00:13:15.429
但在所有这些情况下
空闲空间会动态地调整成

00:13:15.495 --> 00:13:18.565
在你进行请求时
可用的大小

00:13:18.932 --> 00:13:21.335
还可在容器中
创建一个以上的卷

00:13:21.401 --> 00:13:23.570
这会逐渐占用更多空间

00:13:24.104 --> 00:13:26.807
如果你想在这个时候

00:13:26.874 --> 00:13:28.375
扩张卷0
你就能做到

00:13:28.442 --> 00:13:31.812
如果你询问
系统中还剩多少空间可用

00:13:31.879 --> 00:13:35.015
绿色长方形底部的区域就是

00:13:35.249 --> 00:13:36.250
开发者们 要注意

00:13:36.316 --> 00:13:38.452
这个东西稍微不同于

00:13:38.519 --> 00:13:40.988
你之前计算空闲空间的方法

00:13:41.054 --> 00:13:44.491
如果你使用一些范例
例如使用总共存储大小

00:13:44.558 --> 00:13:47.027
减去已用空间
来得出空闲空间

00:13:47.094 --> 00:13:50.030
这不会再起作用了
因为容器上的

00:13:50.097 --> 00:13:52.999
其他卷
也在参与空间分享

00:13:53.433 --> 00:13:58.438
此外 你也没有必要
将所有已用空间加起来

00:14:00.140 --> 00:14:02.142
接下来 我请Dominic上台

00:14:02.209 --> 00:14:05.045
它会给大家讲讲
克隆文件和目录

00:14:10.918 --> 00:14:13.353
嗨 我叫Dominic
我将讲解一些

00:14:13.420 --> 00:14:16.156
我们在APFS中有的
其他高级功能

00:14:16.657 --> 00:14:19.793
首先 我们来谈谈
克隆文件和目录

00:14:19.860 --> 00:14:23.096
这里我们有一个文件
TOP_SECRET_APFS.key

00:14:23.397 --> 00:14:24.831
这在Eric的主目录中

00:14:24.898 --> 00:14:27.234
它引用了两个数据快

00:14:27.467 --> 00:14:30.504
现在如果Eric
想做这次展示的档案

00:14:30.737 --> 00:14:33.373
它在这一时刻中存在着
他可以复制数据

00:14:33.440 --> 00:14:36.143
通过全部读取
然后再写出来

00:14:36.410 --> 00:14:41.582
这很明显会消耗CPU
电力以及磁盘空间使用

00:14:41.682 --> 00:14:44.585
相反 在APFS上
你可以克隆文件

00:14:44.751 --> 00:14:47.721
通过克隆文件
你复制了数据的引用

00:14:47.788 --> 00:14:49.389
而不是实际数据

00:14:49.456 --> 00:14:53.493
所以很明显会更快
而且如果是大文件

00:14:53.594 --> 00:14:55.629
你不会使用两倍的空间

00:14:55.696 --> 00:14:57.631
你使用的是
大小完全一样的空间

00:14:57.698 --> 00:15:02.035
外加用于数据额外引用
少量递增空间

00:15:02.336 --> 00:15:04.805
克隆在文件系统中能保证

00:15:04.872 --> 00:15:08.575
如果在原件或克隆
上进行修改

00:15:08.742 --> 00:15:11.545
文件系统会将
那个数据写入新的位置

00:15:11.612 --> 00:15:13.647
所以克隆原封不动

00:15:14.815 --> 00:15:16.850
所以这一点要着重记住

00:15:16.917 --> 00:15:20.787
当你有克隆时
你在克隆的时候

00:15:20.854 --> 00:15:22.289
你没在使用任何额外空间

00:15:22.356 --> 00:15:26.660
随着你继续进行修改
你会开始使用越来越多的空间

00:15:27.895 --> 00:15:31.465
此外 因为APFS
iOS和macOS

00:15:31.532 --> 00:15:34.735
支持应用程序捆绑包中的文档

00:15:34.801 --> 00:15:38.739
APFS还会允许你克隆
整个目录层级

00:15:38.805 --> 00:15:40.607
文档捆绑包是一个目录

00:15:40.674 --> 00:15:43.076
其内部包含着一套文件

00:15:43.143 --> 00:15:46.113
APFS可以原子级别地克隆它

00:15:47.114 --> 00:15:49.183
接下来我们谈谈快照

00:15:49.716 --> 00:15:53.520
这里我们有文件系统的
另一个代表 其中有两个文件

00:15:53.587 --> 00:15:55.856
BikeRacing和
CoffeeOrigins

00:15:55.989 --> 00:15:59.660
BikeRacing有两个数据块
CoffeeOrigins是一个

00:15:59.860 --> 00:16:03.597
如果我们捕获文件系统的快照
我们现在有一个分离的

00:16:03.664 --> 00:16:07.568
可独立挂载的
只读的文件系统副本

00:16:07.634 --> 00:16:12.806
这代表在捕获快照的那一时刻
文件系统中的数据

00:16:12.940 --> 00:16:16.910
跟克隆很相似 如果在
活动的文件系统中进行写入

00:16:16.977 --> 00:16:19.646
文件系统会将
那个数据放入新的位置

00:16:19.713 --> 00:16:21.915
保留快照的完整性

00:16:22.850 --> 00:16:26.887
同样的 如果我们删除
CoffeeOrigins.key

00:16:26.954 --> 00:16:30.991
尝试清空一些空间
文件系统无法回收那些数据块

00:16:31.058 --> 00:16:33.927
因为如你所见
快照的文件系统

00:16:33.994 --> 00:16:35.896
继续引用这那些数据块

00:16:36.029 --> 00:16:37.631
这是一个很重要的考虑

00:16:37.698 --> 00:16:40.434
开发者在快照上工作时需要留意

00:16:40.501 --> 00:16:43.971
因为当一个文件被删除
如果它存在于

00:16:44.037 --> 00:16:46.840
快照捕获的时刻
那数据块就无法回收

00:16:46.907 --> 00:16:49.710
所以快照可以致使你
使用所有的磁盘空间

00:16:49.776 --> 00:16:52.913
如果你不定期回收它们

00:16:53.580 --> 00:16:56.316
我们预计开发者
可能会将快照

00:16:56.383 --> 00:16:59.486
用于获取稳定只读的数据副本

00:16:59.553 --> 00:17:02.856
将其用于备份
不过我们也想知道来自

00:17:02.923 --> 00:17:05.791
开发者的其他反馈
关于快照的其他可能用途

00:17:05.858 --> 00:17:08.228
所以请在12:30
到实验室和我们见面

00:17:08.694 --> 00:17:11.031
让我们知道
你会如何使用快照

00:17:12.833 --> 00:17:14.902
现在我们谈谈
快照恢复

00:17:14.968 --> 00:17:17.069
这是APFS支持的
另一项功能

00:17:17.137 --> 00:17:19.306
我们有相同的文件系统状态

00:17:19.373 --> 00:17:22.009
不过我们决定
不要这样

00:17:22.075 --> 00:17:25.412
我们想恢复
这基本上是全局撤销

00:17:25.479 --> 00:17:28.248
我们想回到之前捕获这个快照

00:17:28.315 --> 00:17:30.651
那一时刻的文件系统

00:17:30.951 --> 00:17:35.088
你可以标记文件系统
恢复到快照状态

00:17:35.155 --> 00:17:36.657
下一次挂载的时候

00:17:36.990 --> 00:17:42.496
文件系统会返回到
捕获这个快照的那一时刻

00:17:42.563 --> 00:17:45.732
之后允许你继续
从那时开始进行更改

00:17:45.799 --> 00:17:48.836
你能看到
CoffeeOrigins.key回来了

00:17:48.902 --> 00:17:51.972
而且在其他文件上
做出的更改也被丢弃了

00:17:52.039 --> 00:17:54.041
快照会继续存在

00:17:54.107 --> 00:17:56.844
而且你可以无限次数进行恢复

00:17:59.146 --> 00:18:01.982
好了 我们来谈谈
目录大小快速调整

00:18:02.249 --> 00:18:03.750
这项功能回答了一个问题

00:18:03.817 --> 00:18:06.553
那就是目录层级
会使用多少的空间

00:18:06.620 --> 00:18:09.690
应用程序会经常
需要计算这个大小

00:18:09.756 --> 00:18:13.327
用于操作大小调整
给用户提供进程

00:18:13.393 --> 00:18:16.363
这样做的一个明显方式
是打开目录层级

00:18:16.430 --> 00:18:18.665
递归性地迭代所有的内容

00:18:18.732 --> 00:18:22.269
然后查看所有项目的大小
加在一起

00:18:22.703 --> 00:18:26.473
当然 用户会非常乐意
更快一点得知那个答案

00:18:26.540 --> 00:18:27.741
在下一张幻灯片上

00:18:27.808 --> 00:18:30.477
如果你把注意力
集中在屏幕的左边

00:18:30.544 --> 00:18:34.615
当Get Info面板显示出来
你会看到上面写着 计算大小

00:18:36.817 --> 00:18:39.586
几秒钟之后
就会填充上大小

00:18:39.653 --> 00:18:41.522
这是我们想提升的地方

00:18:42.089 --> 00:18:44.358
文件系统可以跟踪它

00:18:44.458 --> 00:18:47.227
很明显 你可以保存
目录层级的大小

00:18:47.294 --> 00:18:50.998
外加目录本身
不过这有一个主要问题

00:18:51.231 --> 00:18:55.302
如果安全地在链上更新
父目录以及父目录的上级？

00:18:55.769 --> 00:18:58.438
我们深入到了文件系统的内部

00:18:58.505 --> 00:19:02.309
不过当你在修改时
锁定了子目录

00:19:02.376 --> 00:19:05.946
你无法再锁定父目录
应为这会违反锁定顺序

00:19:06.113 --> 00:19:09.149
文件系统总是会
从父目录向子目录锁定

00:19:09.216 --> 00:19:10.918
从来不是从子目录到父目录

00:19:10.984 --> 00:19:14.021
如果你反着来做
就会出现死锁

00:19:14.855 --> 00:19:17.724
而APFS绕过了这个问题

00:19:17.958 --> 00:19:20.327
如果问题是将
大小和目录一起保存

00:19:20.394 --> 00:19:22.396
那我们将大小保存到别的地方

00:19:22.796 --> 00:19:24.698
所以通过分隔保存大小

00:19:24.765 --> 00:19:27.568
我们可以使用
原子级操作来将大小更新在

00:19:27.634 --> 00:19:30.704
由文件系统
所维护的单独记录中

00:19:30.904 --> 00:19:33.473
而且不会违反任何锁定顺序

00:19:34.041 --> 00:19:37.678
额外的大小记录
会带来少量增量成本

00:19:37.744 --> 00:19:40.848
不过这基本与IO一起
可忽略不计

00:19:43.016 --> 00:19:46.420
好了 接下来我们要谈谈
原子级安全存储基元

00:19:46.687 --> 00:19:48.822
第一个例子
只是一个基本文件

00:19:48.889 --> 00:19:52.659
这是当今安全存储
怎样在普通文件上起作用的

00:19:52.893 --> 00:19:55.128
这里我有
MakeMoneyFast.key

00:19:55.462 --> 00:19:57.231
我想出了一些
聪明绝顶的新方案

00:19:57.297 --> 00:19:58.699
能快速赚钱

00:19:58.799 --> 00:20:00.901
当应用程序保存那个数据时

00:20:00.968 --> 00:20:04.071
它会被写入边下的
一个临时位置

00:20:04.304 --> 00:20:07.107
当应用程序得知一切都写好

00:20:07.174 --> 00:20:11.111
并安全存在磁盘上
它会请求文件系统进行重命名

00:20:11.278 --> 00:20:14.047
文件重命名
一直都是原子级的

00:20:14.214 --> 00:20:16.783
文件系统保证
要么完全发生

00:20:16.850 --> 00:20:19.353
而且是安全的
要么根本不发生

00:20:19.720 --> 00:20:22.089
此外 文件系统会负责删除

00:20:22.155 --> 00:20:24.124
文档先前的版本

00:20:24.291 --> 00:20:26.760
这对普通文件来说非常好
但如果你有

00:20:26.827 --> 00:20:28.395
文档捆绑包该怎么办？

00:20:28.662 --> 00:20:32.566
我们这里有一个文档捆绑包
ClutchConcertReview.rtfd

00:20:32.633 --> 00:20:37.237
这是一个目录
其中包含着文档的资源

00:20:37.571 --> 00:20:40.307
今天会发生的是
假如我去看Clutch表演

00:20:40.374 --> 00:20:43.610
他们的表演十分出色
然后我更新我的评论

00:20:43.944 --> 00:20:48.815
这个改变写出来了
但现在发生的是无法

00:20:48.882 --> 00:20:51.985
将一个目录在另一个目录
上面进行原子级重命名

00:20:52.052 --> 00:20:54.922
因为POSIX语义不允许这样

00:20:54.988 --> 00:20:57.257
如果有东西在目的地内部

00:20:57.424 --> 00:20:59.359
我们开始玩一个脱壳游戏

00:20:59.960 --> 00:21:02.829
首先 将文档移动开
活动的文档

00:21:02.896 --> 00:21:06.500
这时如果出现什么差错
然后应用程序崩溃

00:21:06.567 --> 00:21:09.536
或者系统断电
用户数据就消失了

00:21:10.070 --> 00:21:13.040
之后 应用程序将数据移动到位

00:21:13.106 --> 00:21:17.144
最后 它要负责删除
目录的先前版本

00:21:17.477 --> 00:21:18.645
文档捆绑包

00:21:18.712 --> 00:21:20.781
所以这不是原子级
而且不安全

00:21:20.848 --> 00:21:22.749
这个问题困扰我们

00:21:22.816 --> 00:21:25.319
很长时间
而且我们想改进它

00:21:25.519 --> 00:21:29.423
在APFS上我们推出了
新的系统 叫做renamex_np

00:21:29.489 --> 00:21:33.961
用于非POSIX 这允许
目录的原子级安全存储

00:21:34.027 --> 00:21:38.298
现在当应用程序将数据
写入其临时位置时

00:21:38.498 --> 00:21:43.971
并请求执行重命名操作
APFS会原子级地负责交换

00:21:44.338 --> 00:21:46.707
并删除文档的先前版本

00:21:46.773 --> 00:21:48.876
所以现在是原子级的并且安全

00:21:49.142 --> 00:21:51.378
当然 作为开发者
你可能不会借助于

00:21:51.445 --> 00:21:53.981
这种低级的系统调用

00:21:54.081 --> 00:21:56.683
因为已经为大家
在Foundation中采用好了

00:21:56.750 --> 00:22:01.355
所以你会在APFS上
享受到这个改进行为的益处

00:22:08.295 --> 00:22:10.297
接下来 我将谈谈加密

00:22:11.131 --> 00:22:13.400
就如Eric所说
有了HFS+

00:22:13.634 --> 00:22:19.840
在Mac上 我们使用叫做Core
Storage的层 位于HFS下层

00:22:20.007 --> 00:22:22.442
提供全盘加密
以及其他内容

00:22:22.509 --> 00:22:25.546
这是一个相当复杂的层
而且功能很多

00:22:25.946 --> 00:22:28.015
在iOS上
我们有不同的变体

00:22:28.081 --> 00:22:31.685
保存加密密钥
和有效扩展属性

00:22:31.752 --> 00:22:33.620
这些加密密钥会与

00:22:33.687 --> 00:22:37.424
iOS设备上的
加速AES硬件一同协作

00:22:37.491 --> 00:22:39.226
来提供每文件加密

00:22:39.426 --> 00:22:43.197
这是个有点复杂故事
有两个非常不同的代码库

00:22:43.263 --> 00:22:47.568
在APFS上 我们想尝试
提供更完成的故事

00:22:47.634 --> 00:22:49.203
在我们所有的产品上

00:22:49.903 --> 00:22:53.540
APFS支持多种级别的
文件系统加密

00:22:53.974 --> 00:22:55.209
不过首先
最简单的级别

00:22:55.275 --> 00:22:57.578
我们一开始就做好了
那就是没有加密

00:22:57.711 --> 00:22:59.446
所有的数据
都是以纯文本写成

00:22:59.513 --> 00:23:02.616
所有数据和元数据都是
以纯文本写入磁盘中的

00:23:03.016 --> 00:23:05.853
下一级别是
每个卷配有一个密钥

00:23:06.420 --> 00:23:11.058
所有敏感的元数据和数据
都是使用相同的密钥加密

00:23:11.124 --> 00:23:14.194
这基本上相当于全盘加密

00:23:14.494 --> 00:23:18.031
我们支持的最复杂级别
是多密钥加密

00:23:18.398 --> 00:23:21.535
这里 所有敏感的元数据是由

00:23:22.135 --> 00:23:26.240
单个密钥加密
密钥不同于用于加密

00:23:26.306 --> 00:23:30.277
单个文件的每文件密钥

00:23:30.577 --> 00:23:33.547
此外 由于快照和
克隆的工作原理

00:23:33.714 --> 00:23:36.350
APFS支持每盘区加密

00:23:36.416 --> 00:23:40.053
所以文件的每个区域
都可以使用自己的密钥加密

00:23:40.487 --> 00:23:44.625
这是独一无二的 而且没有
其他文件系统支持此类功能

00:23:44.892 --> 00:23:47.661
此外 这允许我们
统一我们的加密故事

00:23:47.728 --> 00:23:49.596
在我们所有的平台之间

00:23:49.897 --> 00:23:52.432
好了 之后我将交给Eric

00:23:59.806 --> 00:24:01.708
好了 现在我将快速展示

00:24:01.775 --> 00:24:06.914
WWDC 版macOS Sierra上的
Apple File System

00:24:09.950 --> 00:24:14.221
可能最简单最快速的试验
Apple File System的方法就是

00:24:14.288 --> 00:24:16.790
使用磁盘镜像
我们首先那样做

00:24:17.824 --> 00:24:22.563
你能看到在命令行上
输入了hdiutil create-fs APFS

00:24:22.629 --> 00:24:25.666
这会指定 给我创建
APFS类型的磁盘镜像

00:24:26.033 --> 00:24:28.569
我们指定大小
然后进行稀疏束

00:24:28.802 --> 00:24:32.172
这会出现警告
因为这是尚在开发中的项目

00:24:32.239 --> 00:24:34.541
我们希望你清楚

00:24:34.608 --> 00:24:39.279
你使用的东西目前
并非是100％完成的

00:24:39.813 --> 00:24:42.816
这时它会提醒我
我说是

00:24:44.518 --> 00:24:47.654
你这就创建出磁盘镜像了
如果我附加

00:24:52.259 --> 00:24:55.395
你可以在桌面上检查它
进行Get Info

00:24:56.196 --> 00:24:59.366
你能看到文件系统的类型
确实是APFS

00:24:59.433 --> 00:25:01.502
这可能是最简单的方式
如果你只想

00:25:01.568 --> 00:25:04.137
得出某个东西来尝试

00:25:06.273 --> 00:25:08.775
接下来 我想展示一些其他

00:25:09.176 --> 00:25:12.379
我们加入的更高级功能

00:25:13.313 --> 00:25:14.314
关上它

00:25:15.082 --> 00:25:20.521
这里我有两个优盘
它们只是普通的优盘

00:25:20.587 --> 00:25:23.257
你可以从任何
标准办公用品商店买到

00:25:23.624 --> 00:25:24.625
我插入一个

00:25:24.691 --> 00:25:29.196
其中一个是HFS+格式
另一个是Apple File System格式

00:25:39.006 --> 00:25:41.708
在这两个上面
都进行Get Info

00:25:41.775 --> 00:25:44.945
这样在操作过程中
你能看到空闲空间

00:25:45.913 --> 00:25:51.718
这个时候我有
意大利旅行的一些演示照片

00:25:51.818 --> 00:25:57.024
这两个的目录层级中
都有不少存储空间

00:25:57.324 --> 00:26:00.527
首先我们开始
复制HFS卷中的

00:26:00.594 --> 00:26:04.731
最新版iTunes
然后在APFS中也是同样

00:26:04.798 --> 00:26:08.235
开始复制 进行中

00:26:08.635 --> 00:26:11.839
你能看到这里的进程条
不过APFS已经完成了

00:26:11.905 --> 00:26:13.574
因为它在后台使用克隆

00:26:13.640 --> 00:26:17.010
Finder已经采用了
所有新的克隆行为

00:26:17.077 --> 00:26:19.646
所以如果你进行复制
Finder会自动替你

00:26:19.713 --> 00:26:21.181
在后台进行克隆

00:26:21.515 --> 00:26:22.983
然而HFS还没有完成

00:26:27.621 --> 00:26:30.991
好了 我可以用
演示照片做同样的事

00:26:31.058 --> 00:26:33.727
你在这里能看到
这里有几张照片

00:26:33.794 --> 00:26:36.363
它们全是几MB的大小

00:26:37.764 --> 00:26:43.003
注意这里的空闲空间
3.35GB空闲

00:26:43.070 --> 00:26:47.040
如果我进行复制
这实际上会替我克隆

00:26:47.107 --> 00:26:50.677
你会看到空闲空间
根本没有减小

00:26:53.280 --> 00:26:56.984
接下来
我将展示捕获快照

00:26:59.086 --> 00:27:01.054
这用叫做
SnapshotUtil的工具

00:27:01.121 --> 00:27:05.692
这会在公测版发布之后
供大家使用

00:27:06.560 --> 00:27:08.362
抱歉 这个要作为根运行

00:27:11.932 --> 00:27:17.804
好了 现在我创建了一个快照
我能用SnapshotUtil-s检查它

00:27:23.544 --> 00:27:26.747
你能看到
它现在识别出APFS_Snap

00:27:27.047 --> 00:27:32.519
我在这次演讲之前
创建了一个挂载点

00:27:32.920 --> 00:27:36.857
我会挂载这个时候的快照

00:27:37.624 --> 00:27:40.460
你能看到这个快照
出现在桌面上了

00:27:40.527 --> 00:27:43.463
这包含系统文件的只读视图

00:27:43.530 --> 00:27:47.434
与捕获快照时候的样子相同

00:27:53.907 --> 00:27:57.511
现在 在APFS卷中
我将创建一个临时文件

00:27:59.346 --> 00:28:02.115
大家好 我是临时文件

00:28:03.016 --> 00:28:05.953
保存 关闭
你能看到它在这里显示

00:28:06.019 --> 00:28:09.456
在APFS卷中
这是挂载的读写

00:28:09.990 --> 00:28:11.892
但在快照中不存在

00:28:14.795 --> 00:28:19.600
相应地 我还能删除
一些演示照片

00:28:19.666 --> 00:28:22.669
将它们移到垃圾箱 然后删除

00:28:24.104 --> 00:28:26.473
空闲空间实际上还是没有减小

00:28:26.540 --> 00:28:31.044
因为现在它们被
快照的存在所固定

00:28:31.111 --> 00:28:36.116
如果我想删除它们
我还要删除快照

00:28:38.452 --> 00:28:43.257
好了 这简短展示了Apple
File System的实际效果

00:28:50.964 --> 00:28:53.100
好了 我们来谈谈
一些新的API

00:28:53.166 --> 00:28:55.502
我们为支持Apple
File System而添加

00:28:56.436 --> 00:28:59.873
首先 我们预计可能
大家会熟悉这一个

00:28:59.940 --> 00:29:02.676
如果你使用Foundation
或FileManager

00:29:02.743 --> 00:29:08.015
这两者都得到Swift增强
如果你用copyItem或replaceItem

00:29:08.148 --> 00:29:11.051
它们会采用克隆或
安全存储语义

00:29:11.118 --> 00:29:13.287
我们刚才自动给你描述了

00:29:13.353 --> 00:29:15.689
你不需要做任何事
不费任何功夫

00:29:15.756 --> 00:29:19.393
它会自动弄清你使用的
文件系统是HFS+

00:29:19.459 --> 00:29:23.230
还是Apple File System
而且只有在合适时使用行为

00:29:24.464 --> 00:29:27.901
但是 如果你断定
Foundation或FileManager

00:29:27.968 --> 00:29:29.403
无法提供你所要的确切内容

00:29:29.469 --> 00:29:33.340
你可以到下面 我们有一个
叫做libcopyfile的库

00:29:33.407 --> 00:29:36.376
这个支持深层级的复制

00:29:36.443 --> 00:29:38.111
我们在有克隆功能之前

00:29:38.178 --> 00:29:39.646
已经用它很多年了

00:29:40.047 --> 00:29:43.283
复制文件支持新的位
叫做COPYFILE CLONE

00:29:43.350 --> 00:29:46.987
这与其下方的
5或6个位相同

00:29:47.254 --> 00:29:48.655
我们决定将其选择性加入

00:29:48.722 --> 00:29:51.458
因为如果你使用
像这样的专门库

00:29:51.825 --> 00:29:54.695
你未必想要ACL和扩展属性

00:29:54.761 --> 00:29:57.931
以及剩下的内容
完完全全地复制过来

00:29:58.699 --> 00:30:01.568
而克隆会隐式地
复制所有那些东西

00:30:01.635 --> 00:30:05.572
这个库也会自动
为你调用克隆

00:30:05.639 --> 00:30:07.508
如果后端文件系统支持

00:30:07.574 --> 00:30:09.943
如果不支持 那它就会
继续像往常一样运行

00:30:11.411 --> 00:30:13.347
这些就是新的安全存储API

00:30:13.413 --> 00:30:17.584
renamex Np和renameatx Np
是新的系统调用

00:30:17.651 --> 00:30:20.254
支持安全存储基元

00:30:20.787 --> 00:30:24.224
你可以在Man Pages上使用
在macOS Sierra版本中

00:30:24.291 --> 00:30:26.994
如果你想去看一下Man Page
它们就在这里

00:30:27.561 --> 00:30:29.663
这些也是克隆API

00:30:29.730 --> 00:30:34.234
所以克隆文件及其变体
支持克隆文件和目录

00:30:35.836 --> 00:30:38.972
说一下兼容性
我们认为最简单的方式

00:30:39.039 --> 00:30:44.278
访问Apple File System镜像
就是使用我给你展示的hdiutil

00:30:44.411 --> 00:30:45.913
目前只在macOS Sierra上的

00:30:45.979 --> 00:30:49.316
命令行中可用
作为开发者预览版技术

00:30:49.383 --> 00:30:53.353
还并未特意地完全
为Disk Utility做优化

00:30:54.054 --> 00:30:58.358
所以最快的方法是使用
hdiutil create-fs APFS

00:30:58.425 --> 00:31:00.627
你可以得到磁盘镜像
然后附加它

00:31:01.461 --> 00:31:05.699
你还可用diskutil APFS
增加容器

00:31:05.766 --> 00:31:08.268
创建容器
添加卷 删除卷

00:31:09.002 --> 00:31:13.006
任何你想对容器
本身进行的低级操作

00:31:13.640 --> 00:31:17.211
最后 我们还有FS检查
这是我们在研发的功能

00:31:17.277 --> 00:31:20.280
这个能够验证文件系统

00:31:20.347 --> 00:31:21.815
也可以进行修复

00:31:21.982 --> 00:31:24.251
所以还会继续开发该功能

00:31:25.853 --> 00:31:30.224
macOS Sierra中
APFS上目前的一些限制

00:31:31.124 --> 00:31:32.860
这只会在数据卷上支持

00:31:32.926 --> 00:31:35.829
现在不支持从Apple
File System启动

00:31:36.997 --> 00:31:41.201
现在Apple File
System不支持“时间机器”备份

00:31:42.569 --> 00:31:45.572
FileVault和Fusion Drive
支持还尚需等待

00:31:47.074 --> 00:31:50.177
当前的卷格式
只能是区分大小写的

00:31:50.244 --> 00:31:53.547
如果你不确定你的程序
是否需要不区分大小写

00:31:53.814 --> 00:31:57.050
请试一下
创建磁盘镜像或设置在

00:31:57.117 --> 00:32:01.522
Mac上的分区里
试着证实它并将你的应用

00:32:01.588 --> 00:32:05.359
在Apple File System中运行
然后告诉我们它的效果

00:32:07.461 --> 00:32:09.229
其他对兼容性的备注

00:32:09.596 --> 00:32:12.999
Apple File System
无法通过AFP分享

00:32:13.066 --> 00:32:17.871
如果你想使用文件分享
我们建议你使用SMB代替

00:32:18.705 --> 00:32:21.808
作为未来首选的文件分享机制

00:32:22.342 --> 00:32:24.478
OS X Yosemite
或更早版本

00:32:24.545 --> 00:32:26.680
将无法识别Apple
File System卷

00:32:26.747 --> 00:32:29.082
所以请不要把Apple
File System实例

00:32:29.149 --> 00:32:31.952
带回到OS X Yosemite
或更早版本

00:32:32.019 --> 00:32:36.690
你必定会碰到
你不想回应的对话

00:32:37.824 --> 00:32:43.397
所以macOS Sierra
会有开发者预览版的

00:32:43.463 --> 00:32:45.165
Apple File System

00:32:45.566 --> 00:32:47.935
这会是开发者预览版技术

00:32:48.001 --> 00:32:52.472
一旦macOS Sierra
于今秋发布

00:32:53.307 --> 00:32:55.909
现在你可能会好奇
我们有什么样的推出计划

00:32:55.976 --> 00:32:59.980
各位如何在你们设备上获取Apple
File System？

00:33:01.315 --> 00:33:02.416
我们会讨论这个的

00:33:03.517 --> 00:33:04.952
升级到Apple File System

00:33:05.018 --> 00:33:07.354
你想要这些我们展示过的
出色的新功能

00:33:07.421 --> 00:33:08.388
那你怎样获得它们？

00:33:08.822 --> 00:33:11.758
一个可能方法是
要求所有人

00:33:11.825 --> 00:33:14.628
所有用户备份系统
保存起来

00:33:14.695 --> 00:33:16.563
确保所有东西都绝对安全

00:33:16.630 --> 00:33:18.799
然后擦除卷
擦除设备

00:33:18.866 --> 00:33:21.969
还原 放入新的OS
然后从备份中还原

00:33:22.035 --> 00:33:23.904
这个过程会花数小时

00:33:23.971 --> 00:33:25.806
然后期盼所有东西
在还原后

00:33:25.873 --> 00:33:27.140
都完好如初

00:33:27.541 --> 00:33:28.709
我们不会这样做

00:33:29.276 --> 00:33:32.579
相反 Apple会提供
就地升级路径

00:33:32.646 --> 00:33:35.649
从HFS+
到Apple File System

00:33:41.355 --> 00:33:44.958
在此期间 用户数据
仍保持在其原来位置

00:33:45.259 --> 00:33:49.062
Apple会将崭新的APFS元数据

00:33:49.129 --> 00:33:54.668
写入HPF+空闲空间
我们这么做是为了死机防护

00:33:55.269 --> 00:33:59.239
这个操作可能会耗时
几秒或者几分钟

00:33:59.806 --> 00:34:02.809
在这段期间
如果设备断电 死机

00:34:02.876 --> 00:34:05.479
任何发生的糟糕事情
我们想要设备上的数据

00:34:05.546 --> 00:34:08.114
安然无恙
仿佛什么都未发生过一样

00:34:08.482 --> 00:34:13.120
所以Apple File System Converter
会尽可能以原子级别执行操作

00:34:13.187 --> 00:34:14.855
这不是完全瞬时完成的

00:34:14.922 --> 00:34:16.822
但随着操作持续进行

00:34:16.889 --> 00:34:17.958
如果设备死机

00:34:18.225 --> 00:34:23.429
我们的打算是
使其完好如初 归于原样

00:34:24.231 --> 00:34:29.735
Apple File System 将于2017年
在所有设备上以默认程序发布

00:34:37.311 --> 00:34:38.411
总而言之

00:34:40.047 --> 00:34:42.081
Apple File System
会是默认的文件系统

00:34:42.149 --> 00:34:44.384
用于2017年的
所有Apple产品

00:34:45.118 --> 00:34:49.188
它超现代 有死机防护
支持空间分享

00:34:50.224 --> 00:34:53.793
我们支持克隆和快照
增强的数据安全功能

00:34:53.860 --> 00:34:57.197
像我们刚刚讨论的
多密钥加密

00:34:59.132 --> 00:35:01.201
它也专门优化和设计

00:35:01.268 --> 00:35:03.804
用于我们所有设备里的
Apple生态系统

00:35:05.439 --> 00:35:07.975
你可以得到更多关于
Apple File System的信息

00:35:08.041 --> 00:35:09.776
在我身后的URL中

00:35:10.344 --> 00:35:13.514
那里会有开发者指南
以及一些示例代码

00:35:13.580 --> 00:35:17.784
这样你可以看到
克隆文件和目录的实际演示

00:35:19.653 --> 00:35:22.189
给在座各位说一些要点

00:35:22.256 --> 00:35:26.093
Apple File System
即将到来 2017年将在转眼间来临

00:35:26.994 --> 00:35:29.763
我想请大家将你们的应用
在Apple File System上测试

00:35:29.830 --> 00:35:32.599
用你们昨天获得的macOS版本

00:35:32.999 --> 00:35:35.068
试着在Apple File System上
运行你们的应用

00:35:35.135 --> 00:35:38.305
请告诉我们这一过程的进展如何

00:35:38.972 --> 00:35:41.875
如果你要报告任何错误
请使用Bug Reporter报告

00:35:41.942 --> 00:35:44.178
通过传统的手段
这样我们可以调查

00:35:44.244 --> 00:35:47.281
我们都希望大家会
像我们一样喜欢它

00:35:49.283 --> 00:35:52.019
还有一些相关演讲

00:35:52.085 --> 00:35:54.888
如果你有兴趣学习
更多关于安全功能的内容

00:35:54.955 --> 00:35:57.024
在我们的平台上
特别是iOS

00:35:57.758 --> 00:36:01.428
我们建议你可以看看
iOS Security实际工作原理

00:36:01.495 --> 00:36:04.331
将于今天4点钟
在本会议厅开始

00:36:04.731 --> 00:36:06.700
至此 这就是
Apple File System

00:36:06.767 --> 00:36:08.635
我们迫不及待想知道
各位会如何使用它