00:00:19.786 --> 00:00:20.754
窥视3D TOUCH

00:00:20.821 --> 00:00:23.056
为了下一个维度的TOUCH
增强你的应用

00:00:35.669 --> 00:00:39.473
下午好
欢迎来到“窥视3D TOUCH”

00:00:39.806 --> 00:00:43.544
我是Tyler Fox
稍后同事Peter Hajas会加入我

00:00:43.877 --> 00:00:46.113
我们都是UIKit团队的
工程师

00:00:46.313 --> 00:00:49.349
我们今天非常激动地
告诉大家

00:00:49.449 --> 00:00:51.151
你们该怎样采用3D Touch

00:00:51.318 --> 00:00:54.021
来把你应用的用户体验
提升到下一个等级

00:00:55.956 --> 00:00:58.292
我们今天
想以回顾一些

00:00:58.358 --> 00:01:00.060
3D Touch基本知识来开始

00:01:00.127 --> 00:01:02.896
并向你们演示
它如何跨系统穿越

00:01:04.031 --> 00:01:08.168
然后我们要谈谈
主屏幕快捷操作

00:01:08.869 --> 00:01:11.371
主屏幕快捷操作
是今天最简单的方法之一

00:01:11.438 --> 00:01:13.907
让你可以把3D Touch
加入你的应用

00:01:14.908 --> 00:01:17.277
它们让用户从
主屏幕直接跳到

00:01:17.544 --> 00:01:20.414
你的应用中的
那些关键活动

00:01:22.182 --> 00:01:24.985
然后
我们会谈谈Peek和Pop

00:01:26.119 --> 00:01:30.057
Peek和Pop是让用户
在你的应用中

00:01:30.123 --> 00:01:32.593
预览和浏览内容的
无缝方式

00:01:33.393 --> 00:01:36.563
我们想大部分应用
都会从中极为受益

00:01:36.630 --> 00:01:40.100
即把Peek和Pop
与支持一起加入你的内容中去

00:01:41.635 --> 00:01:43.737
最终 我们也很兴奋
可以告诉你们大家

00:01:43.804 --> 00:01:48.342
关于UIPreviewInteraction的一切
这是iOS X中的全新API

00:01:48.709 --> 00:01:52.145
允许你为你的应用
制作独一无二的3D Touch

00:01:52.913 --> 00:01:55.649
这是给你们中的那些
想要对3D Touch的交互

00:01:56.016 --> 00:01:57.651
进行高级控制的人的

00:01:58.018 --> 00:02:00.854
并让你使用与我们为
Peek和Pop所磨炼的

00:02:01.088 --> 00:02:03.156
同样的压力处理

00:02:03.657 --> 00:02:06.059
但请带来你自己的
自定义用户界面

00:02:06.360 --> 00:02:08.695
这真是太棒了
我们等不及要告诉你这一切

00:02:09.630 --> 00:02:14.468
让我们开始吧
先来谈谈3D Touch

00:02:16.303 --> 00:02:20.374
支持3D Touch的设备
有一种力量敏感显示器

00:02:20.974 --> 00:02:22.476
它可精确测量

00:02:22.543 --> 00:02:24.478
屏幕上的触碰压力

00:02:25.479 --> 00:02:29.116
现在的iOS一直让用户
在用户界面上

00:02:29.183 --> 00:02:30.250
直接操作内容

00:02:31.251 --> 00:02:32.653
这一直是一个标志

00:02:32.853 --> 00:02:34.721
因为原始
iPhone是与其

00:02:35.289 --> 00:02:36.657
多点触控显示屏一起被引入

00:02:37.824 --> 00:02:40.127
但3D Touch更进一步
扩展了这一点

00:02:40.561 --> 00:02:45.265
允许用户更密切的连接到
它们在屏幕上的内容

00:02:48.101 --> 00:02:50.637
让我们来看看一些
3D Touch

00:02:50.704 --> 00:02:53.640
穿越操作系统所用的方法
首先是主屏幕

00:02:54.608 --> 00:02:56.243
当你按下某个应用图标时

00:02:56.710 --> 00:02:59.413
我们就揭示
主屏幕快捷操作

00:03:00.314 --> 00:03:03.483
正如你在此用相机所看到的
这些让你直接跳到

00:03:03.550 --> 00:03:06.053
你来执行的每个应用中的

00:03:06.420 --> 00:03:07.821
一些关键活动

00:03:08.055 --> 00:03:10.691
例如 用相机应用自拍

00:03:11.024 --> 00:03:14.361
使用前置摄像头或用后置摄像头

00:03:14.428 --> 00:03:15.929
拍张普通的照片

00:03:15.996 --> 00:03:18.365
录制视频或慢动作视频

00:03:19.933 --> 00:03:24.905
现在iOS X中的新特性
如果你的应用提供了一个小工具

00:03:24.972 --> 00:03:27.975
它也将在主屏幕快捷操作
旁边显示

00:03:28.075 --> 00:03:30.410
当用户3D接触
你的应用图标时

00:03:31.278 --> 00:03:34.014
另外还要注意的是
当你按下

00:03:34.081 --> 00:03:35.449
每个这样的应用图标时

00:03:35.682 --> 00:03:37.918
该设备正在播放
触觉反馈

00:03:38.118 --> 00:03:40.320
来让你知道
你何时达到阈值

00:03:40.420 --> 00:03:42.422
快速行动
将在何处弹开

00:03:44.391 --> 00:03:46.593
现在让我们来看看消息

00:03:47.327 --> 00:03:50.731
从而来看看
Peek和Pop的一个例子

00:03:52.165 --> 00:03:55.135
在信息这里你可以看到
我在与朋友的对话中

00:03:55.269 --> 00:03:56.737
收到了一张照片

00:03:58.038 --> 00:04:00.574
如果我开始对那张照片
轻轻施加压力

00:04:01.041 --> 00:04:06.180
我就可以窥视它来揭露出
此内容的大型预览

00:04:07.247 --> 00:04:10.684
然后如果我继续施压
我会直接弹在那张照片上

00:04:10.751 --> 00:04:14.354
这将使它铺满全屏
并让我与它交互

00:04:14.421 --> 00:04:16.290
就像我按压过它一样

00:04:16.957 --> 00:04:20.394
Peek和Pop相当好
因为它可以让你

00:04:20.459 --> 00:04:23.630
预览内容以及
也许改变主意

00:04:24.031 --> 00:04:26.333
并释放你的触控
而却实际上不必

00:04:26.400 --> 00:04:28.569
去按压返回按钮
然后再返回

00:04:30.003 --> 00:04:31.672
现在这里有一点要注意的是

00:04:32.306 --> 00:04:35.943
因为我们为Peek和Pop
跨越这两个不同的阈值

00:04:36.643 --> 00:04:39.313
该设备再次
播放触觉反馈

00:04:39.680 --> 00:04:42.649
来让你知道
你何时已经达到这两个阈值

00:04:44.351 --> 00:04:45.853
这就是Peek和Pop

00:04:46.486 --> 00:04:48.722
现在让我们来看看Mail

00:04:49.489 --> 00:04:53.861
看看相同的交互中的
一些有趣的片段

00:04:54.595 --> 00:04:57.064
我希望你能注意到
3D Touch充分互动

00:04:57.164 --> 00:05:00.100
和中断的能力

00:05:00.567 --> 00:05:02.569
我在屏幕上调节

00:05:02.636 --> 00:05:04.505
触控压力
你会在这里看到

00:05:05.205 --> 00:05:08.542
我们使用模糊和缩放
效果来让你知道

00:05:08.609 --> 00:05:11.245
你可以继续
与此内容互动

00:05:11.645 --> 00:05:14.982
注意整个交互
的流畅性和响应度如何

00:05:15.415 --> 00:05:17.217
这是的标志特性中的一个

00:05:17.484 --> 00:05:20.888
是它把3D Touch
和传统触控

00:05:20.954 --> 00:05:22.589
以及基于手势的交互区分开的

00:05:24.424 --> 00:05:25.859
所以你可能会想

00:05:26.226 --> 00:05:28.662
我为何要在我的应用中
支持3D Touch？

00:05:29.496 --> 00:05:31.865
3D Touch最好的
用途之一就是

00:05:32.332 --> 00:05:36.270
是它可以迅速加速
访问你的应用已经提供了的

00:05:36.336 --> 00:05:37.905
现有功能

00:05:38.372 --> 00:05:41.475
你用主屏幕快捷操作
就此看到了一个很棒的例子

00:05:41.808 --> 00:05:44.144
让用户在你的应用里直接进入那些屏幕

00:05:44.211 --> 00:05:48.015
就像深层链接并让它们

00:05:48.081 --> 00:05:50.417
直接做出尝试执行的行动

00:05:51.285 --> 00:05:53.887
但关于3D Touch
另一个真正伟大的的东西

00:05:54.321 --> 00:05:58.292
是它使得之前永远不可能的
全新的身临其境的交互

00:05:58.358 --> 00:06:00.027
变得有可能

00:06:01.295 --> 00:06:04.164
稍后当我们向你们展示一个很棒的例子

00:06:04.464 --> 00:06:08.068
提及这个新的
UIPreviewInteraction API时

00:06:09.937 --> 00:06:14.408
最后我们在iOS X的整个系统中
都采用了3D Touch

00:06:14.975 --> 00:06:18.612
因此用户也希望
你们所有的应用都支持它

00:06:23.283 --> 00:06:24.585
让我们继续谈谈你如何

00:06:24.651 --> 00:06:27.020
从今天就开始通过
主屏幕快捷操作

00:06:27.087 --> 00:06:28.655
来采用3D Touch

00:06:29.423 --> 00:06:33.393
而要做到这一点
我想为你介绍AppChat

00:06:34.361 --> 00:06:37.064
AppChat是一个示例应用
我们一直在努力使它

00:06:37.130 --> 00:06:39.199
在我们的应用中

00:06:39.266 --> 00:06:41.735
突出一些3D Touch的强大功能

00:06:42.936 --> 00:06:44.972
在这里你可以看到3D Touch

00:06:45.272 --> 00:06:48.609
对不起 AppChat是一个
短消息应用

00:06:49.109 --> 00:06:52.312
你可以拍照并作为聊天
发送给朋友 在这里你可以

00:06:52.980 --> 00:06:56.250
看到我已经从朋友们那里
收到一系列不同的聊天

00:06:56.316 --> 00:07:00.821
我可以按上其中任何一个
并全屏查看聊天记录

00:07:04.024 --> 00:07:05.092
就这么简单

00:07:05.492 --> 00:07:08.462
AppChat是一个非常令人熟悉的
UIKit应用

00:07:09.530 --> 00:07:12.065
我们会向你展示
为使3D Touch这么做

00:07:12.132 --> 00:07:16.570
我们增加支持的不同方式
从主屏幕快捷操作开始

00:07:17.237 --> 00:07:19.373
所以当你按下
AppChat应用图标时

00:07:19.806 --> 00:07:22.342
我们将为AppChat揭露一些
主屏幕快捷操作

00:07:23.110 --> 00:07:25.345
你会注意到
我可以选择创建一个新的聊天

00:07:25.412 --> 00:07:27.281
它会打开摄像头
这样我就可拍张照片

00:07:27.347 --> 00:07:29.449
然后从我的朋友中选择一位
将其发送

00:07:30.350 --> 00:07:32.052
但我也可以选择

00:07:32.119 --> 00:07:36.223
这里底部的3种快速行动之一
它们是

00:07:36.290 --> 00:07:38.692
将让我把聊天
直接发送给我的

00:07:38.759 --> 00:07:40.194
前三位朋友的快速行动

00:07:40.561 --> 00:07:42.996
我在AppChat中
交流最多的朋友

00:07:44.565 --> 00:07:46.633
所以实际上
有两种不同类型的

00:07:46.700 --> 00:07:48.168
主屏幕快捷操作

00:07:48.569 --> 00:07:49.903
现在让我们来谈谈它们

00:07:51.772 --> 00:07:54.508
第一类是静态快捷操作

00:07:55.309 --> 00:07:58.011
这些是由你的应用在构建时
所规定的

00:07:58.745 --> 00:08:00.447
它们对在你的应用中一直可用的

00:08:00.514 --> 00:08:02.416
固定操作来说是很棒的

00:08:03.016 --> 00:08:07.487
例如用AppChat
我们有新聊天快捷操作

00:08:07.721 --> 00:08:09.223
我总能创建一个新的聊天

00:08:09.590 --> 00:08:11.592
然后将其发送到
我的朋友之一

00:08:12.092 --> 00:08:15.062
另一方面
我们有动态快捷操作

00:08:16.997 --> 00:08:19.700
动态快捷操作
也是伟大的 因为它们允许你

00:08:19.766 --> 00:08:22.936
定制和定做
被显示给用户的快速操作

00:08:23.003 --> 00:08:26.106
但是让我们首先来看看
静态快捷操作

00:08:27.474 --> 00:08:30.978
静态快捷操作定义
在你的应用的info.plist文件中

00:08:32.913 --> 00:08:34.147
因此一旦你的应用

00:08:34.214 --> 00:08:37.551
被安装在用户的设备上
它们就可用了

00:08:38.719 --> 00:08:40.287
现在让我们来看看一个例子

00:08:40.354 --> 00:08:43.123
我们如何向AppChat添加
一个静态快捷操作

00:08:44.057 --> 00:08:47.361
这是我们的info.plist文件
你可以看到只用几行代码

00:08:47.561 --> 00:08:49.796
我们就能够创建

00:08:49.930 --> 00:08:51.765
并添加这个新聊天快捷操作

00:08:52.399 --> 00:08:53.767
我想在这里
指出几点

00:08:53.834 --> 00:08:55.903
你会注意到
我们在指定一个类型

00:08:56.436 --> 00:08:58.772
这是一个字符串
你的应用定义

00:08:59.106 --> 00:09:03.010
用户选择这些快速操作之一时
稍后你会用哪一个

00:09:03.310 --> 00:09:05.078
从而知道如何处理它

00:09:05.779 --> 00:09:08.782
在这种情况下我们还提供了
一个标题新聊天

00:09:09.583 --> 00:09:14.188
以及一个图标类型
它是你可以显示的

00:09:14.254 --> 00:09:16.823
系统提供的图标之列表中的
一个常量

00:09:17.057 --> 00:09:19.560
这种情况下 我们就这样
得到那个很好的聊天泡泡

00:09:21.695 --> 00:09:25.499
要记住一点 任何面对
你的信息plist.strings文件中

00:09:25.699 --> 00:09:29.036
字符串的用户 你都该
使其本地化来作为最佳实践

00:09:31.004 --> 00:09:33.073
这就是静态快捷操作
我们再来看看

00:09:33.140 --> 00:09:35.542
我之前避开谈论的动态快捷操作

00:09:36.710 --> 00:09:40.480
因此这些是在运行时
由你的应用所定义的

00:09:40.714 --> 00:09:43.350
也同时从你的应用提供到系统

00:09:44.484 --> 00:09:47.287
其结果就是
它们只在用户

00:09:47.354 --> 00:09:49.656
最初第一次启动你的应用时
是可用的

00:09:51.358 --> 00:09:53.894
动态快捷操作

00:09:53.961 --> 00:09:57.231
会在任何静态快捷操作
之后被显示 在空间允许的前提下

00:09:57.698 --> 00:09:59.366
你总共只可显示

00:09:59.433 --> 00:10:01.735
四个快速操作
在主屏幕上

00:10:02.202 --> 00:10:04.137
所以如果你打算确保留有空间

00:10:04.204 --> 00:10:07.441
为任何动态快捷操作

00:10:09.943 --> 00:10:12.980
你还可以包括
一个可选的系统图标 即

00:10:13.680 --> 00:10:17.150
使用你的应用中的模板图像
而制作的自定义图标

00:10:17.951 --> 00:10:21.922
或者你甚至可以
根据用户地址簿中的联系人

00:10:22.122 --> 00:10:23.457
来创建一个图标

00:10:24.491 --> 00:10:26.527
这就是AppChat正在做的
用来拉取

00:10:26.593 --> 00:10:29.062
那些漂亮的个人资料照片

00:10:29.129 --> 00:10:31.532
紧挨着这三个动态快捷操作

00:10:31.598 --> 00:10:33.066
排在前三名的朋友们

00:10:33.867 --> 00:10:35.536
让我们看看
一些代码

00:10:35.602 --> 00:10:37.671
来看看我们如何能够
实现这一点

00:10:39.673 --> 00:10:43.076
那么在这个例子中
我们将以寻找一个联系人开始

00:10:43.143 --> 00:10:45.445
该联系人应
匹配朋友Lexi Torres

00:10:48.081 --> 00:10:50.884
我们一定要做到的
第一件事情

00:10:51.151 --> 00:10:53.020
向用户请求访问联系人通讯录的许可

00:10:53.387 --> 00:10:56.256
假设我们有了这个权限
我们可以继续前进

00:10:56.990 --> 00:11:00.894
并实际查询其联系人通讯录
来寻找这位

00:11:01.061 --> 00:11:03.964
我们所感兴趣的
姓名与这位朋友相匹配的联系人

00:11:04.932 --> 00:11:09.703
如果我们能有至少一个匹配
那么我们就可以

00:11:10.170 --> 00:11:13.473
把该联系人发送给我们的
UIApplicationShortcutIcon初始程序

00:11:14.608 --> 00:11:18.312
这将继续并创建我们
将以此快速操作而使用的图标

00:11:19.346 --> 00:11:21.615
但是当然
我们可能没有收到访问许可

00:11:22.015 --> 00:11:24.117
来访问该用户的联系人通讯录

00:11:24.651 --> 00:11:27.154
或者我们可能没有
为这个朋友找到匹配

00:11:27.454 --> 00:11:29.022
所以我们会希望有一个回退

00:11:29.189 --> 00:11:32.326
在这种情况下我们将使用
该系统的消息样式

00:11:33.060 --> 00:11:34.761
作为图标来显示

00:11:35.896 --> 00:11:37.965
现在我们有了这个图标
我们就可以去创建

00:11:38.031 --> 00:11:40.267
我们实际的快速操作

00:11:40.767 --> 00:11:42.836
在这种情况下
我们需要指定类型

00:11:43.537 --> 00:11:46.139
这与你看待
静态开始操作的方法非常相似

00:11:46.874 --> 00:11:49.810
除了副标题
我们还将用发送一个聊天

00:11:50.477 --> 00:11:51.745
然后我们将把所有这些

00:11:51.812 --> 00:11:55.315
发送到我们的
UIApplicationshortcutItem初始程序

00:11:55.382 --> 00:11:57.985
来创建我们第一个动态快捷操作

00:11:59.353 --> 00:12:03.223
从此 我们可以继续如此操作
并重复无数次

00:12:03.857 --> 00:12:05.826
来创建任何额外的快速操作

00:12:05.959 --> 00:12:08.295
当我们完成后
我们将它们全部打包到

00:12:08.529 --> 00:12:11.131
一个漂亮的阵列中去
并将其发送到

00:12:11.665 --> 00:12:14.434
UIApplicationsShortcutItems
属性中去

00:12:15.202 --> 00:12:16.103
其效果是

00:12:16.170 --> 00:12:19.673
向系统注册这些
动态快捷操作

00:12:20.040 --> 00:12:22.276
以便它们可以显示在主屏幕上

00:12:22.910 --> 00:12:24.077
有一点要记住的是

00:12:24.144 --> 00:12:28.148
这个shortcutItems属性
只显示你的应用

00:12:28.448 --> 00:12:31.185
仅包含你的应用的动态快捷项目

00:12:31.251 --> 00:12:32.719
或动态快捷操作

00:12:32.786 --> 00:12:34.855
静态快捷操作只规定于

00:12:34.922 --> 00:12:37.691
你的info.plist之中
而不会被包含在那个阵列之中

00:12:39.359 --> 00:12:41.595
让我们来看看
所有这一切

00:12:41.662 --> 00:12:43.030
回到主屏幕上是什么样子

00:12:43.730 --> 00:12:46.200
好极了
只需那几行代码

00:12:46.466 --> 00:12:49.503
我们能够创建一个静态快捷操作

00:12:49.837 --> 00:12:52.606
新聊天以及三个不同的
动态快捷操作

00:12:52.673 --> 00:12:54.808
我们排名前三朋友中的每个人

00:12:56.009 --> 00:12:58.345
然而我们现在
还得做一件事

00:12:58.412 --> 00:13:01.982
当然就是当用户选择了一个时
处理这些快速操作

00:13:02.449 --> 00:13:05.152
在此要记住
两种不同的场景

00:13:05.652 --> 00:13:08.722
第一种是如果你的应用已经在运行

00:13:08.789 --> 00:13:11.091
而且正被激活 这意味着你的应用

00:13:11.158 --> 00:13:13.460
处于非活动状态或暂停状态

00:13:14.695 --> 00:13:17.297
在这种情况下
我们将使用回调于

00:13:17.364 --> 00:13:18.732
UIApplicationDelegate

00:13:19.166 --> 00:13:21.735
performActionForShortcutItem应用

00:13:21.802 --> 00:13:22.769
completionHandler

00:13:24.171 --> 00:13:27.307
在这里我们将使用
shortcutItem 它被引入

00:13:27.708 --> 00:13:29.343
实际用于处理此快速操作

00:13:29.676 --> 00:13:32.012
这可能意味着很多东西
然而它取决于你的应用

00:13:32.079 --> 00:13:33.580
以及你有什么快速操作

00:13:33.647 --> 00:13:36.350
但总的来说
你可能应该把用户移动到

00:13:36.416 --> 00:13:38.819
你的应用中的
一个特定的屏幕上

00:13:40.387 --> 00:13:43.857
如果你处理快速操作
你应该确保

00:13:43.924 --> 00:13:46.026
调用completion handler
传递一个Bool

00:13:46.093 --> 00:13:49.062
即它应该表明你是否
实际上已经将其处理好了

00:13:50.497 --> 00:13:52.232
太好了 这是第一个场景

00:13:52.332 --> 00:13:54.168
我们考虑的第二个场景
若应用其实是

00:13:54.468 --> 00:13:58.305
作为一个快速操作的结果
而被启动的

00:13:58.672 --> 00:14:00.807
在这种情况下
我们的应用并没有运行

00:14:01.909 --> 00:14:04.845
在这里我们将在

00:14:04.912 --> 00:14:07.281
使用熟悉的didFinishLaunchingWithOptions
应用回调

00:14:07.347 --> 00:14:08.949
UIApplicationDelegate上

00:14:10.083 --> 00:14:13.520
在里面我们将访问
launchOptions字典的

00:14:13.787 --> 00:14:16.323
shortcutItem key
来看看

00:14:16.523 --> 00:14:19.059
我们的应用是否通过快速操作而启动的

00:14:20.294 --> 00:14:23.463
如果的确如此 那么我们
将处理这个快速操作

00:14:23.664 --> 00:14:25.566
正如我们以前做过的那样

00:14:26.133 --> 00:14:29.169
然后我们将确保
用这个方法返回假

00:14:29.536 --> 00:14:32.706
告诉系统我们确实在此
真正处理了快速操作

00:14:33.006 --> 00:14:36.610
而它会阻止调用
上一张幻灯片中的方法

00:14:38.445 --> 00:14:41.448
这几乎就是所有的一切

00:14:41.715 --> 00:14:45.118
就创建和处理动态与静态
shortcutItems而言

00:14:45.385 --> 00:14:48.455
让我们回顾一些最好的实践
来把它们记住

00:14:49.857 --> 00:14:52.860
首先每一个应用应该提供快速操作

00:14:53.260 --> 00:14:55.395
因为你在这里可以看到
它们很容易被创建

00:14:55.495 --> 00:14:57.231
而它们可以提供巨大的价值

00:14:57.831 --> 00:15:00.367
直接显示在主屏幕 让用户直接

00:15:00.434 --> 00:15:02.703
去到你的应用所提供的那些主要活动

00:15:04.505 --> 00:15:07.641
因此你要专注于
向你的应用所提供的

00:15:07.708 --> 00:15:10.444
最高值的任务
提供快速访问

00:15:10.677 --> 00:15:13.180
记住你只有
4个不同的位置

00:15:13.514 --> 00:15:14.882
来显示快速操作

00:15:15.282 --> 00:15:17.684
所以要明智决定
该选择哪些

00:15:19.119 --> 00:15:20.420
我们的建议是

00:15:20.921 --> 00:15:24.625
当让你的快速操作
保持可被预测非常重要时

00:15:24.691 --> 00:15:27.060
你可能该考虑使用动态快捷操作

00:15:27.995 --> 00:15:31.899
用户将快速打开你的主屏幕快捷操作
并选择其一

00:15:32.132 --> 00:15:34.768
如果你正在做诸如改变顺序的事情

00:15:34.835 --> 00:15:36.904
这可能会
使你的用户产生困惑

00:15:37.237 --> 00:15:39.640
他们会有一个
令人沮丧的体验

00:15:41.909 --> 00:15:44.244
这里要记住
一件有趣的事情

00:15:44.711 --> 00:15:47.681
你应该准备好去处理动态快捷操作

00:15:47.848 --> 00:15:50.150
你的应用先前版本

00:15:50.951 --> 00:15:52.653
如果你还记得的话

00:15:52.719 --> 00:15:56.356
原因是动态快捷操作
直到你的应用运行才生效

00:15:56.423 --> 00:15:58.725
并有能力
把它们提供给系统

00:15:59.426 --> 00:16:01.895
所以如果你的应用是近期刚刚更新的

00:16:02.262 --> 00:16:04.998
它仍显示动态快捷操作

00:16:05.199 --> 00:16:06.466
之前版本的

00:16:07.367 --> 00:16:11.171
其结果是如果你的
快速操作的语义发生了变化

00:16:11.438 --> 00:16:14.474
则在处理时记住这一点
会是一个好主意

00:16:14.608 --> 00:16:16.276
而要做到这一点 你可能应该

00:16:16.343 --> 00:16:18.579
考虑把你的应用的版本号

00:16:18.812 --> 00:16:22.316
纳入信息plist 抱歉
纳入用户信息字典

00:16:22.382 --> 00:16:25.052
可连同动态快捷操作
一起纳入

00:16:26.687 --> 00:16:27.588
最后

00:16:27.921 --> 00:16:31.925
尽量不要添加只可使用
快速操作才能访问的功能

00:16:32.092 --> 00:16:35.062
请记住并非我们所有的设备
都支持3D Touch

00:16:35.128 --> 00:16:38.899
即使是那些支持的设备
用户也有选项在

00:16:38.966 --> 00:16:41.168
系统辅助功能设置中
禁用3D Touch

00:16:43.070 --> 00:16:45.138
对此
我想邀请Peter 上台

00:16:45.205 --> 00:16:47.341
给你们大家讲讲
Peek和Pop

00:16:47.808 --> 00:16:48.775
Peter

00:16:52.479 --> 00:16:53.847
来吧

00:16:54.948 --> 00:16:56.149
谢谢你 Tyler

00:16:57.050 --> 00:17:01.388
我今天真的很高兴
能跟大家讲Peek和Pop

00:17:02.689 --> 00:17:07.728
正如之前Tyler给大家展示的一样
Peek和Pop允许人们

00:17:07.895 --> 00:17:12.232
快速预览和浏览你应用中的内容

00:17:12.799 --> 00:17:15.035
根据我个人的体验
我可以说

00:17:15.301 --> 00:17:17.671
它会改变
你使用手机的方式

00:17:18.839 --> 00:17:23.410
我们讲结合示例应用
来谈谈Peek和Pop

00:17:23.477 --> 00:17:26.613
示例应用就是指Tyler给你们
展示的AppChat

00:17:28.348 --> 00:17:30.918
正如Tyler给你们展示的一样
在最后一节

00:17:31.451 --> 00:17:34.121
AppChat是一个标准的
UIKit应用

00:17:34.922 --> 00:17:37.724
所以在表格中
敲击消息之一

00:17:39.226 --> 00:17:42.930
就会把我带到该条消息
这样我就可以全屏检查了

00:17:44.064 --> 00:17:47.868
把Peek和Pop添加到
你应用的一般经验法则

00:17:48.502 --> 00:17:52.539
是如果用户
能够访问的内容

00:17:52.806 --> 00:17:54.174
可被按压来导航

00:17:54.374 --> 00:17:57.244
它也应支持Peek和Pop

00:17:58.278 --> 00:18:00.480
因此让我们向
AppChat应用该规则

00:18:02.482 --> 00:18:06.486
这意味着当我对此表中的
某个单元格施加压力时

00:18:07.888 --> 00:18:09.857
我们应该得到一个快速的Peek

00:18:10.958 --> 00:18:14.761
在我们的API中
我们称此为预览

00:18:15.062 --> 00:18:17.497
因为我们会得到视图控制器预览

00:18:17.564 --> 00:18:19.233
而我们可以导航到视图控制器

00:18:19.933 --> 00:18:22.002
现在如果我们继续施加压力

00:18:23.237 --> 00:18:24.738
那会弹出全屏

00:18:25.873 --> 00:18:27.808
我们就可以进行交互

00:18:28.575 --> 00:18:32.012
在我们的API中
我们称此为提交

00:18:32.479 --> 00:18:36.049
因为我们已经提交导航到该视图控制器

00:18:37.651 --> 00:18:39.920
好的 让我们看一
Peek和Pop

00:18:40.020 --> 00:18:41.822
的组件吧

00:18:43.657 --> 00:18:46.960
首先且最重要的是我们有已注册
View Controller

00:18:47.961 --> 00:18:49.296
就是这个视图控制器

00:18:49.363 --> 00:18:51.765
包含了用户
交互元素的

00:18:51.999 --> 00:18:53.567
视图控制器

00:18:54.168 --> 00:18:57.638
在我们的例子里 这些是
我们的信息表格单元格

00:18:59.339 --> 00:19:03.477
每个注册了的视图控制器
都有全系列来源

00:19:04.311 --> 00:19:06.747
它们是每一个

00:19:06.813 --> 00:19:09.516
有自己的视图控制器
预览界面元素

00:19:10.284 --> 00:19:15.155
在AppChat中 这自然适应
我们的聊天表格单元格

00:19:16.657 --> 00:19:17.558
最后

00:19:17.925 --> 00:19:20.127
我们有被预览了的
视图控制器

00:19:21.428 --> 00:19:24.965
这是将显示预览内容的
视图控制器

00:19:25.365 --> 00:19:28.435
此预览代表了
我们输入表中的元素

00:19:29.503 --> 00:19:32.372
通常在按压此内容后

00:19:32.439 --> 00:19:34.041
这和我们要展示的元素相同

00:19:34.541 --> 00:19:35.943
按压它

00:19:36.343 --> 00:19:38.612
并通过施加压力
预览它

00:19:39.313 --> 00:19:40.714
向我们展示相同的内容

00:19:42.216 --> 00:19:45.219
所以这样的话
我要一步一步来讲一下

00:19:45.619 --> 00:19:48.722
我们用什么和如何
把Peek和Pop添加到AppChat中去

00:19:48.922 --> 00:19:52.559
这将密切反映你将如何
把Peek和Pop添加到你应用中去

00:20:03.337 --> 00:20:06.240
所以在我们注册了的
视图控制器开始

00:20:06.540 --> 00:20:09.209
记住这就是
视图控制器表格

00:20:09.376 --> 00:20:12.079
其中包含了我们的
演示文稿的源视图

00:20:14.047 --> 00:20:15.349
我们要遵循

00:20:15.482 --> 00:20:19.520
UIViewControllerPreviewing
Delegate协议

00:20:20.487 --> 00:20:22.222
此代理将在

00:20:22.289 --> 00:20:26.126
Peek和Pop交互中的
不同阶段被召回

00:20:26.426 --> 00:20:28.695
来将信息提供给该系统

00:20:29.463 --> 00:20:31.231
这是相当容易实现的

00:20:32.566 --> 00:20:36.003
接下来我们将要确保我们
registerForPreviewing

00:20:36.803 --> 00:20:39.740
进行此操作的很棒时机是
在viewDidLoad中时

00:20:41.441 --> 00:20:43.377
我们要
registerForPreviewing

00:20:43.510 --> 00:20:45.245
并用我们自己做代理

00:20:45.812 --> 00:20:48.448
递交我们的表视图
作为源视图

00:20:48.982 --> 00:20:51.718
因为表视图
是我们想预览的

00:20:51.952 --> 00:20:55.422
所有接口元素的
共同祖先

00:20:57.457 --> 00:21:02.496
现在让我们继续
并在预览代理协议中实施

00:21:02.663 --> 00:21:04.598
两种必要的代理方法

00:21:05.365 --> 00:21:06.366
第一种

00:21:08.702 --> 00:21:09.970
是用于提供

00:21:11.638 --> 00:21:13.440
一个预览
视图控制器

00:21:14.641 --> 00:21:16.443
提供一个
视图控制器

00:21:16.510 --> 00:21:20.347
在源视图内的
一个特定位置

00:21:23.016 --> 00:21:25.352
该方法被称为
previewingContext

00:21:25.485 --> 00:21:27.354
ViewControllerForLocation

00:21:28.155 --> 00:21:29.423
而且它是很容易实施的

00:21:30.891 --> 00:21:34.628
首先我们要找到indexPath
它代表了

00:21:34.962 --> 00:21:37.197
我们通过该代理方法
而被递交的点

00:21:37.865 --> 00:21:40.467
我们可通过点击
测试表视图来如此操作

00:21:42.803 --> 00:21:45.606
下一步我们要创建
一个视图控制器

00:21:45.939 --> 00:21:49.810
使用的模型对象
由indexPath所代表

00:21:50.811 --> 00:21:53.113
这是你可能已经有了的
一种逻辑

00:21:53.180 --> 00:21:55.349
并确实在indexPath中
选择了行

00:21:57.451 --> 00:21:59.820
其次非常重要的一点是

00:22:00.220 --> 00:22:01.889
我们要设置

00:22:02.022 --> 00:22:03.590
previewingContext的
sourceRect

00:22:04.291 --> 00:22:07.694
请记住源视图
是整个表视图

00:22:08.295 --> 00:22:11.298
而我们要确保
从屏幕上仅仅突显单元格

00:22:11.565 --> 00:22:15.736
用的是Tyler向大家
所展示了的

00:22:15.802 --> 00:22:17.070
模糊效应和规模效应

00:22:17.671 --> 00:22:20.774
通过设置sourceRect
系统会适当地

00:22:20.941 --> 00:22:23.577
切出该元素
然后将其在屏幕上突显

00:22:23.677 --> 00:22:24.945
它看起来真的很棒

00:22:26.079 --> 00:22:29.816
最后把视图控制器
返回到系统中去

00:22:31.051 --> 00:22:34.354
现在关于这个代理方法
我想为你们指出

00:22:34.421 --> 00:22:37.391
两个相当重要的部分

00:22:39.426 --> 00:22:43.530
第一个是该方法
将在每次

00:22:43.697 --> 00:22:46.233
我们认为我们将
启动预览时被调用

00:22:47.301 --> 00:22:51.772
正如Tyler之前所说的
我们希望保持交互快速与流畅

00:22:52.005 --> 00:22:54.007
所以我们要伺机将其调用

00:22:54.174 --> 00:22:55.742
以确保一切都准备好了

00:22:57.377 --> 00:23:01.348
因此使用此方法返回
一个视图控制器时

00:23:01.715 --> 00:23:04.151
你需要确保
一定不要花太多时间

00:23:05.085 --> 00:23:07.387
如果你有可以
在后台做的异步工作

00:23:07.487 --> 00:23:10.891
则在准备此视图控制器之前

00:23:11.358 --> 00:23:14.294
在后台做此工作
并不要阻塞主队列

00:23:15.262 --> 00:23:18.732
这样当我们

00:23:19.032 --> 00:23:20.567
向你应用中的界面元素施加压力时

00:23:20.801 --> 00:23:23.003
会有快速、流畅
和反应灵敏的感觉

00:23:24.238 --> 00:23:27.207
我给你们关于此方法的
第二个重要建议

00:23:27.307 --> 00:23:29.676
是它的返回类型

00:23:30.410 --> 00:23:32.813
UIViewControllerOptional

00:23:33.313 --> 00:23:35.182
这意味着我们可以返回零值

00:23:36.116 --> 00:23:37.918
如果你用这个方法返回零值

00:23:38.318 --> 00:23:40.621
我们将不会从屏幕上
突显任何单元格

00:23:40.821 --> 00:23:43.724
我们将不会做任何模糊处理
我们将不会做任何触觉反馈

00:23:43.957 --> 00:23:45.325
我们将不会做预览

00:23:46.593 --> 00:23:48.862
但是你应该确保

00:23:48.929 --> 00:23:52.232
只有当在该位置确实没东西来预览时
才返回零值

00:23:54.034 --> 00:23:56.803
你应该确保
你应用中的外观相似的内容

00:23:57.070 --> 00:23:59.139
可以用相似的方式来预览

00:23:59.873 --> 00:24:01.942
这样人们就不必为了试图
得到一个预览

00:24:02.009 --> 00:24:04.711
而挤压手机
因为外观相似的东西

00:24:04.778 --> 00:24:06.747
将被用相似的方式来预览

00:24:07.781 --> 00:24:09.616
太好了

00:24:10.384 --> 00:24:14.388
这样我们就已经实现了
这种交互的预览部分

00:24:23.030 --> 00:24:24.131
但我们还没全部搞定

00:24:24.464 --> 00:24:27.100
我们需要就此协议
实施第二种所需的方法

00:24:27.167 --> 00:24:30.504
即用于提供提交

00:24:31.605 --> 00:24:33.740
这一种方法更易于实施

00:24:34.808 --> 00:24:38.245
它被称为previewingContext
commitViewController

00:24:39.279 --> 00:24:42.182
需要提交时
它将被系统所调用

00:24:42.549 --> 00:24:44.318
我们已经过了此压力阙值

00:24:44.384 --> 00:24:46.486
我们要设置一些触觉反馈

00:24:46.553 --> 00:24:49.089
我们在屏幕上
显示视图控制器

00:24:51.458 --> 00:24:54.261
在这里我们要尽一切努力

00:24:54.328 --> 00:24:56.196
使这个视图控制器
在屏幕上显示

00:24:56.930 --> 00:25:00.934
AppChat是个使用导航控制器的
简单的UIKit应用

00:25:01.435 --> 00:25:03.737
所以我们只是要调用显示

00:25:04.938 --> 00:25:06.840
这将有将

00:25:06.907 --> 00:25:09.543
视图控制器推送到
导航堆栈的默认效果

00:25:10.010 --> 00:25:12.646
但是这个方法
有一些真的很酷的地方

00:25:13.046 --> 00:25:16.183
UIKit对它的操作
使得你可以在此回调中

00:25:16.250 --> 00:25:19.052
执行任何类型的
视图控制器转换

00:25:19.720 --> 00:25:23.690
推送东西到导航堆栈
做一个自定义介绍

00:25:24.057 --> 00:25:27.027
甚把视图控制器
移动到一自定义容器中

00:25:27.961 --> 00:25:30.831
在你的应用中 尽一切努力

00:25:30.998 --> 00:25:32.833
使这个视图控制器
在屏幕上显示

00:25:33.133 --> 00:25:36.036
而UIKit将代表你
来处理动画方面的事宜

00:25:37.004 --> 00:25:40.641
好 我们已实施了对
视图控制器的提交

00:25:41.542 --> 00:25:44.778
而现在我们已经得到
这个超赞的提交

00:25:46.013 --> 00:25:48.515
这将使我们能够
全屏导航

00:25:48.682 --> 00:25:50.851
并开始与内容的交互

00:25:52.886 --> 00:25:55.322
我们已向应用
添加了Peek和Pop

00:25:56.089 --> 00:25:58.058
但我们可以做一点点
额外的工作

00:25:58.192 --> 00:25:59.826
来把体验提升到

00:26:01.161 --> 00:26:02.229
下一个级别

00:26:05.866 --> 00:26:08.302
Peek和Pop的
另一个很酷之处

00:26:08.602 --> 00:26:10.170
是预览快速操作

00:26:10.671 --> 00:26:13.941
而通过添加这些到你的应用中去
你可以允许用户

00:26:14.007 --> 00:26:16.410
访问最常用的一些操作

00:26:16.643 --> 00:26:18.645
并在预览内显示内容

00:26:19.413 --> 00:26:21.682
这真的很强大
并可以让用户

00:26:21.748 --> 00:26:24.418
以甚至比以前更快的速度
使用你的应用

00:26:25.919 --> 00:26:28.722
如果我们回到我们熟悉的
架构图

00:26:29.489 --> 00:26:32.326
我们将看到这些
预览快速操作

00:26:32.526 --> 00:26:34.294
属于被预览了的视图控制器

00:26:35.495 --> 00:26:38.932
这是能够响应这些操作的视图控制器

00:26:39.433 --> 00:26:43.103
因其对视图控制器
所示内容进行操作

00:26:44.104 --> 00:26:45.439
这些都很容易添加

00:26:46.340 --> 00:26:47.441
我们要做的就是在

00:26:47.708 --> 00:26:52.145
UIViewController中
覆写预览操作项目功能

00:26:53.146 --> 00:26:56.350
这将返回一个
UIPreviewActionItems阵列

00:26:58.252 --> 00:27:02.089
我们可以创建
UIPreviewActions

00:27:02.155 --> 00:27:04.091
使用你可能已经熟悉了的API

00:27:04.791 --> 00:27:09.296
它类似于UIAlertAction
和UITableViewRowAction

00:27:10.130 --> 00:27:15.736
你只是传递标题、风格、和结尾
而我们会

00:27:15.802 --> 00:27:18.939
在用户选择该操作时
调用该结尾

00:27:20.440 --> 00:27:22.910
接下来我们就
返回该操作阵列

00:27:22.976 --> 00:27:25.078
到系统中去

00:27:26.180 --> 00:27:29.883
现在我们已经有了
一个使用heart的操作

00:27:30.184 --> 00:27:32.920
但AppChat让你回复
一大堆的表情符号

00:27:33.754 --> 00:27:36.523
所以我们真正想要做的是
把这些表情图案

00:27:36.823 --> 00:27:39.226
分到一组操作中去

00:27:40.527 --> 00:27:44.831
我们对此也有API
通过UIPreviewActionGroup即可

00:27:46.767 --> 00:27:50.537
你所要做的就是创建
一个预览操作阵列

00:27:51.371 --> 00:27:54.141
在这里我们有所有的
你可以用于回应的表情符号

00:27:55.275 --> 00:27:59.780
然后用标题、风格以及
这些操作的阵列

00:28:00.047 --> 00:28:01.982
创建一个操作组

00:28:02.883 --> 00:28:04.284
这是个很棒的方式
你可用它

00:28:04.351 --> 00:28:08.255
来在你的预览快速操作中
对关联操作进行分组

00:28:09.790 --> 00:28:11.725
有适用于
预览操作API的

00:28:12.092 --> 00:28:16.296
两个其他重要部件
它们也很方便

00:28:20.067 --> 00:28:22.402
这是通过对预览操作项目的
风格枚举

00:28:22.503 --> 00:28:23.704
而完成的

00:28:25.239 --> 00:28:27.407
第一个是所选择的样式

00:28:27.674 --> 00:28:31.078
这将在此项目旁边
显示一个小小的已检查标记

00:28:31.545 --> 00:28:33.981
让用户知道
他们之前可能已经选择过了

00:28:34.047 --> 00:28:35.449
该选项

00:28:36.149 --> 00:28:38.252
在我们推出beta 1版本之前

00:28:38.352 --> 00:28:40.187
那个已检查标记
有点害羞

00:28:40.354 --> 00:28:42.956
所以你会注意到它不在
第一个版本中

00:28:43.123 --> 00:28:45.092
但放心
这个错误将会被修复

00:28:46.960 --> 00:28:49.129
另一个真的使用起来
得心应手的样式

00:28:49.196 --> 00:28:52.699
是破坏性的样式
我们可以用它来指示

00:28:52.766 --> 00:28:55.636
某操作可能
执行一个破坏性行为

00:28:56.236 --> 00:28:59.106
你可以从我背后的
阻止操作中看到这一点

00:28:59.473 --> 00:29:02.543
通过添加Peek和Pop
并预览快速操作

00:29:02.776 --> 00:29:05.412
我们已经把你应用中的体验提升到了

00:29:05.679 --> 00:29:08.549
下一个高度
并加快了你的用户

00:29:08.615 --> 00:29:09.950
可以拥有的交互

00:29:10.884 --> 00:29:13.220
让我们回顾一下
把Peek和Pop

00:29:13.353 --> 00:29:15.422
添加到你应用中去的一些最佳实践

00:29:18.292 --> 00:29:21.428
首先最重要的是
记住经验法则

00:29:22.396 --> 00:29:27.367
可以被按压的内容
还应支持Peek和Pop

00:29:27.768 --> 00:29:30.170
你可以看一下Apple的系统应用

00:29:30.437 --> 00:29:32.873
那里有很棒的提示
来告诉你如何做到这一点

00:29:34.341 --> 00:29:35.209
接下来

00:29:36.043 --> 00:29:38.612
确保始终从代理回调
返回一个

00:29:38.679 --> 00:29:41.849
预览视图控制器

00:29:42.616 --> 00:29:47.254
你应用中的外观类似的内容
应当能被以类似的方式预览

00:29:49.122 --> 00:29:52.092
在同一预览背景回调中

00:29:52.559 --> 00:29:54.261
确保不要花太长时间

00:29:54.895 --> 00:29:57.831
请记住我们不想
阻止主队列

00:29:57.931 --> 00:30:01.602
因为我们希望这种交互
保持流畅和响应

00:30:03.504 --> 00:30:07.107
确保设置好预览背景的
sourceRect

00:30:07.508 --> 00:30:11.078
来在屏幕上突出相应的
用户界面元素

00:30:12.613 --> 00:30:14.781
Peek和Pop
部分就讲完了

00:30:15.682 --> 00:30:17.751
现在我想把注意力转移到

00:30:17.985 --> 00:30:21.421
iOS X中一些超级炫酷的新API

00:30:22.289 --> 00:30:23.790
UIPreviewInteraction

00:30:24.725 --> 00:30:29.196
UIPreviewInteraction让你
感受Peek和Pop的感觉

00:30:29.730 --> 00:30:32.666
即压力处理
和触觉反馈

00:30:33.200 --> 00:30:35.636
但你可以使用
你自己的用户界面

00:30:36.236 --> 00:30:40.174
正如我们不久就将看到的一样
这是一个相当强大的概念

00:30:40.674 --> 00:30:41.942
让我们来看一个例子

00:30:43.644 --> 00:30:46.413
在AppChat中的
我们的聊天细节视图中

00:30:46.847 --> 00:30:49.783
我们已经在底部有了
这个方便的回复按钮

00:30:51.752 --> 00:30:54.221
在没有启动3D Touch
功能的设备上

00:30:54.521 --> 00:30:56.490
我们可以按压此回复按钮

00:30:57.224 --> 00:30:59.927
来得到可以用于回复的
表情符号的完整列表

00:31:01.094 --> 00:31:03.430
然后我们可以按压
这些表情符号之一

00:31:04.531 --> 00:31:05.933
把它送回给我们的朋友

00:31:09.303 --> 00:31:11.772
但在启动了3D Touch
功能的设备上

00:31:12.272 --> 00:31:16.109
我们可以把这种交互做得
更流畅和更有趣

00:31:17.477 --> 00:31:20.681
只需使用UIPreviewInteraction
做几行代码

00:31:21.782 --> 00:31:23.517
我们就添加了
一些相当整洁的内容

00:31:25.152 --> 00:31:27.821
我们可以
对此回复按钮施加压力

00:31:28.255 --> 00:31:30.624
并以交互方式
展示该表单

00:31:30.958 --> 00:31:33.227
注意模糊效果是如何
淡入淡出的

00:31:34.194 --> 00:31:37.898
然后在保持我的
手指在屏幕下方的同时

00:31:38.398 --> 00:31:42.436
我可以左右滑动来挑选
一个表情符号用于回复

00:31:43.403 --> 00:31:45.105
但愿我们不会选到魔鬼

00:31:45.973 --> 00:31:47.941
然后我们会把它送回给
我们的朋友

00:31:48.876 --> 00:31:51.345
这种类型的一触式交互

00:31:51.845 --> 00:31:54.448
是3D Touch所完美适用的

00:31:56.116 --> 00:31:58.952
3D Touch可以帮助我们的
另一件事

00:31:59.453 --> 00:32:01.121
是加速

00:32:01.855 --> 00:32:04.258
可更靠近用户手指的操作

00:32:05.359 --> 00:32:09.229
在iOS 7中
我们增加了滑动收回手势

00:32:09.363 --> 00:32:11.431
作为返回按钮的一种替代

00:32:12.366 --> 00:32:15.102
这就更方便了
因为它就在你的手指旁边

00:32:15.169 --> 00:32:17.337
你可以将它移动到屏幕边缘

00:32:17.404 --> 00:32:19.573
然后向后滑动

00:32:20.507 --> 00:32:23.544
并且通过3D Touch
我们可以把这种便利

00:32:23.644 --> 00:32:25.145
添加到你应用的交互中去

00:32:26.213 --> 00:32:29.349
所以我们可在这张照片中的
任何地方真正应用3D Touch

00:32:30.083 --> 00:32:32.653
来交互地带出
此回复表单

00:32:34.121 --> 00:32:37.391
然后我们实际上可以
通过多用力

00:32:37.858 --> 00:32:39.359
来提交此会被打开的回复表单

00:32:39.893 --> 00:32:42.596
然后再选择一个
表情符号用于回复

00:32:44.364 --> 00:32:46.600
这种类型的丰富交互

00:32:47.201 --> 00:32:51.004
它可以让人有
更流畅更快的感受

00:32:51.405 --> 00:32:54.341
正是我们希望你会用
UIPreviewInteraction

00:32:54.408 --> 00:32:56.109
所构建的东西

00:33:04.651 --> 00:33:08.989
UIPreviewInteraction
采用的Peek和Pop压力处理

00:33:09.056 --> 00:33:11.425
与我们已通过系统所提供的
Peek和Pop的用户界面

00:33:11.558 --> 00:33:13.861
所磨练时采用的
Peek和Pop压力处理相同

00:33:15.028 --> 00:33:18.832
我们在交互的各个阶段
移动时的自动触觉反馈

00:33:18.899 --> 00:33:22.569
但允许你的应用

00:33:22.636 --> 00:33:24.204
使用其自己的用户界面

00:33:24.771 --> 00:33:26.907
而有关这一点
真正令人兴奋的是

00:33:27.307 --> 00:33:31.512
人们现可为Peek和Pop
构建肌肉记忆

00:33:32.145 --> 00:33:34.181
并将此肌肉记忆应用于

00:33:34.548 --> 00:33:36.950
系统的标准预览外观

00:33:37.751 --> 00:33:41.188
并也应用于你将使用

00:33:41.421 --> 00:33:42.923
UIPreviewInteraction
所构建的自定义交互

00:33:43.790 --> 00:33:47.094
而且此肌肉记忆
将是普遍适用的

00:33:47.761 --> 00:33:49.062
这真的很酷

00:33:50.130 --> 00:33:51.932
因此让我们一步一步

00:33:52.232 --> 00:33:57.604
讲解你可以如何
向你应用添加预览交互

00:33:59.540 --> 00:34:01.775
我们将以遵循

00:34:02.042 --> 00:34:05.546
UIPreviewInteractionDelegate协议
作为开始

00:34:06.313 --> 00:34:07.915
此代理

00:34:07.981 --> 00:34:10.984
将在预览交互中的各个阶段
被告知

00:34:11.251 --> 00:34:12.619
来让你知道发生了什么事情

00:34:13.754 --> 00:34:17.224
接下来我们想要确保
创建我们的预览交互

00:34:18.525 --> 00:34:21.161
再次 viewDidLoad
是进行此操作的很棒时机

00:34:21.929 --> 00:34:25.666
在这里我们用源视图
创建了一个预览交互

00:34:26.567 --> 00:34:28.534
并设置我们自己
作为代表

00:34:30.437 --> 00:34:34.408
现在要讲的是预览交互
它纯粹是关于状态转换

00:34:34.942 --> 00:34:37.511
让我们讲讲
这些状态转换是如何工作的

00:34:39.146 --> 00:34:40.681
当交互开始时

00:34:41.047 --> 00:34:44.717
如果你的代理实施
可选的预览交互

00:34:44.952 --> 00:34:46.719
应开始回调

00:34:48.487 --> 00:34:51.091
我们将调用它
或者如果你不这样做

00:34:51.525 --> 00:34:52.993
我们将开始交互

00:34:53.860 --> 00:34:58.465
现在随着压力从交互开始

00:34:58.866 --> 00:35:00.367
向预览状态移动

00:35:01.068 --> 00:35:04.571
我们用previewInteraction
向你的代理发回信息

00:35:04.905 --> 00:35:07.474
didUpdatePreviewTransition:ended

00:35:08.542 --> 00:35:09.376
来查查看

00:35:10.310 --> 00:35:12.713
这些压力进程更新

00:35:12.779 --> 00:35:15.482
被赋予一个从零到一的归一化值

00:35:15.983 --> 00:35:17.851
而真正要强调的重点是

00:35:17.918 --> 00:35:21.021
这不仅仅是
压力的直接转换

00:35:21.922 --> 00:35:24.424
因为它使用
我们为Peek和Pop

00:35:24.491 --> 00:35:28.896
所开发的算法
我们实际上是检测用户的意图

00:35:29.763 --> 00:35:32.733
因此这不仅仅是
简单的压力转换

00:35:34.234 --> 00:35:38.405
当我们在这两种压力状态
之间移动时

00:35:38.472 --> 00:35:41.875
我们将在每一步都
被通过交互而通知以

00:35:42.075 --> 00:35:43.076
我们目前的进度

00:35:43.977 --> 00:35:46.513
而一旦我们达到
预览的目标状态

00:35:47.514 --> 00:35:50.350
我们就会得到消息
因为进度将移动到一

00:35:51.251 --> 00:35:53.720
并且结束参数也将为真

00:35:55.155 --> 00:35:58.859
而且该装置也将自动播放
触觉反馈

00:36:00.127 --> 00:36:03.163
让我们来看看
此方法施用的一个示例

00:36:05.098 --> 00:36:07.501
同样的 方法是
previewInteraction

00:36:07.734 --> 00:36:10.270
didUpdatePreviewTransition:ended

00:36:11.471 --> 00:36:14.107
在这里我们只是
要通过转换

00:36:14.174 --> 00:36:17.211
来就目前的进度
给自己更新

00:36:18.212 --> 00:36:22.015
现在请注意这其实是即插即用

00:36:22.082 --> 00:36:23.417
对许多UIKit的技术

00:36:24.017 --> 00:36:27.454
我们可用它驱动
UIViewPropertyAnimator

00:36:27.821 --> 00:36:29.923
一个百分比驱动的交互转变

00:36:30.157 --> 00:36:32.426
或者甚至一个UIKit动态系统

00:36:33.660 --> 00:36:36.563
这些为状态转换
所做的瞬时更新

00:36:36.830 --> 00:36:38.699
适用于所有这些技术

00:36:39.933 --> 00:36:41.869
并且如果交互结束

00:36:42.302 --> 00:36:45.873
我们将希望展示
我们已完成了的预览外观

00:36:46.540 --> 00:36:49.209
这是第一个所需的代理方法

00:36:49.443 --> 00:36:50.844
在UIPreviewInteraction上

00:36:51.912 --> 00:36:55.115
第二个是为了对取消做出响应

00:36:55.716 --> 00:36:59.019
它被称作
previewInteractionDidCancel

00:37:00.187 --> 00:37:03.423
每当用户抬起手指
或者如果因为任何

00:37:03.891 --> 00:37:06.994
其他原因交互应被取消
这都将被调用

00:37:07.194 --> 00:37:13.467
例如我们接到一个电话
在这里我们将把

00:37:13.667 --> 00:37:16.370
我们的进度设置回零
并重置我们自己至最初的外观

00:37:17.337 --> 00:37:20.774
但是请注意我们是在
一个动画包内如此行动的

00:37:21.708 --> 00:37:24.678
我们将要把我们自己
做成动画回去休息

00:37:24.912 --> 00:37:27.781
从而当我们抬起手指时
我们可以避免东西在周围闪烁

00:37:29.983 --> 00:37:33.453
所以这就是我们应对
预览状态转换的方法

00:37:34.688 --> 00:37:38.091
但要记住在AppChat中
我们也想对

00:37:38.292 --> 00:37:39.993
提交状态转换进行回应

00:37:40.394 --> 00:37:42.396
来把我们的内容粘在屏幕上

00:37:43.997 --> 00:37:46.533
我们可以采用
可选的代理方法

00:37:47.100 --> 00:37:50.971
previewInteraction
didUpdateCommitTransition:ended

00:37:51.405 --> 00:37:53.774
来通过提交对我们的进度
做出回应

00:37:55.742 --> 00:37:58.579
所以当我们在
交互之初

00:37:58.946 --> 00:38:00.214
和预览状态之间时

00:38:00.914 --> 00:38:04.017
我们会回调
didUpdatePreviewTransition

00:38:05.352 --> 00:38:07.421
一旦我们达到
预览的目标状态

00:38:08.255 --> 00:38:12.526
我们就会通过值为一的进度值
以及一个为真的结束值

00:38:12.993 --> 00:38:15.362
而我们也将播放
一些触觉反馈

00:38:16.463 --> 00:38:18.532
然后我们将开始
发送消息

00:38:18.799 --> 00:38:22.970
到didUpdateCommitTransition:ended

00:38:23.270 --> 00:38:25.205
且有预览进度用于提交

00:38:27.140 --> 00:38:29.443
这是同一类的进度更新

00:38:29.710 --> 00:38:31.712
归一化值从零到一

00:38:32.679 --> 00:38:35.816
而且一旦我们达到了
提交的目标状态

00:38:36.517 --> 00:38:40.721
我们会通过让已经结束的
一个的进度值为真

00:38:40.888 --> 00:38:44.558
我们会再播放另一条不同的
触觉反馈

00:38:46.727 --> 00:38:50.230
让我们来讲讲
你可能会采用此方法的方式

00:38:52.533 --> 00:38:54.001
那么在我们实施

00:38:54.434 --> 00:38:58.138
previewInteraction
didUpdateCommitTransition:ended时

00:38:58.939 --> 00:39:01.942
在这里我们要更新
我们对提交的进度

00:39:02.442 --> 00:39:04.912
同样这适用于

00:39:05.045 --> 00:39:07.748
整个UIKit中
动画和动态API套件

00:39:09.049 --> 00:39:11.185
一旦交互结束

00:39:11.685 --> 00:39:14.922
我们将只展示我们
已完成了的提交外观

00:39:16.123 --> 00:39:18.458
关于UIPreviewInteraction
就讲到这里

00:39:19.493 --> 00:39:23.096
现在如果你正在构建
一个游戏或绘图应用

00:39:24.031 --> 00:39:27.367
有一些你可以使用的
低级压力API

00:39:29.469 --> 00:39:32.506
此API提供标准化的访问

00:39:32.606 --> 00:39:36.810
给与每个UITouchObject
一起进来的压力值

00:39:37.211 --> 00:39:39.313
通过UITouch上的两个属性

00:39:39.746 --> 00:39:42.516
压力和maximumPossibleForce

00:39:43.851 --> 00:39:46.653
这些值将被用于填充
所有

00:39:46.720 --> 00:39:50.224
支持3D Touch的设备
以及来自

00:39:50.290 --> 00:39:53.093
支持Apple Pencil的
Apple Pencil触控

00:39:54.228 --> 00:39:57.631
而在此我们不会进一步
详细说明 相反

00:39:57.965 --> 00:39:59.633
我鼓励查看iOS Talk上的

00:39:59.933 --> 00:40:02.769
关于撬动触控输入的视频

00:40:03.036 --> 00:40:06.974
这是一个非常棒的演讲
并深入讲解了这些API

00:40:08.308 --> 00:40:09.409
现在让我们回顾一下

00:40:10.477 --> 00:40:12.112
如Tyler之前向你们展示

00:40:12.779 --> 00:40:16.950
主屏幕快捷操作
允许你的用户直接跳进

00:40:17.251 --> 00:40:20.320
在你的应用内的许多常见活动的操作

00:40:21.154 --> 00:40:23.790
而大多数的应用
将真正受益于

00:40:23.857 --> 00:40:25.893
添加主屏幕快捷操作

00:40:26.994 --> 00:40:32.332
接下来我介绍了
Peek和Pop如何

00:40:32.399 --> 00:40:36.270
前所未有地允许无缝的流畅
且快速的交互并让用户

00:40:36.336 --> 00:40:38.772
与你的应用
以一种全新的方式进行交互

00:40:39.773 --> 00:40:43.844
我们认为许多应用将的确
从添加Peek和Pop受益

00:40:45.812 --> 00:40:49.049
最后 我们检视了
UIPreviewInteraction

00:40:49.917 --> 00:40:52.786
它可以让你在新的深度探索
3D Touch这个海洋

00:40:52.853 --> 00:40:56.590
并真的很好的检视了

00:40:56.723 --> 00:40:59.059
多点触控的下一个维度

00:41:00.594 --> 00:41:05.632
最后需要注意的很重要的一点
用户会期望其设备上的

00:41:05.699 --> 00:41:07.835
所有的应用都支持3D touch

00:41:08.368 --> 00:41:11.471
所以我们强烈建议
你采用这些功能

00:41:12.906 --> 00:41:16.677
要了解更多信息
并下载AppChat示例应用

00:41:16.743 --> 00:41:18.745
我们在整个演讲中
向你展示了这个应用

00:41:18.946 --> 00:41:20.781
它使用了所有这些技术

00:41:21.148 --> 00:41:22.850
请查看我身后的这个地址

00:41:24.184 --> 00:41:26.086
有几个相关的演讲

00:41:26.553 --> 00:41:29.957
一个是关于新的
UIKitPropertyAnimator API

00:41:30.057 --> 00:41:32.659
它非常适用于
UIPreviewInteraction

00:41:33.126 --> 00:41:37.497
而另一个是关于
在iOS上撬动低级触控输入

00:41:38.198 --> 00:41:40.000
就是这样
十分感谢大家

00:41:40.067 --> 00:41:42.336
祝大家在接下来演讲中
也有很大收获 谢谢