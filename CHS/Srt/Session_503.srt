00:00:21.088 --> 00:00:21.922 
早上好

00:00:21.989 --> 00:00:23.790 
AVFoundation回放的新进展

00:00:23.857 --> 00:00:25.959 
等待 循环 转换 扩展 优化

00:00:27.160 --> 00:00:30.597 
欢迎来到我们关于
AVFoundation回放新进展的会话

00:00:32.366 --> 00:00:33.534 
我是Sam Bushell

00:00:34.501 --> 00:00:38.305 
今天我们要讲一些新添加的增强功能

00:00:38.372 --> 00:00:40.340 
这可以使得开发者在处理

00:00:40.407 --> 00:00:43.043 
难题时变得更加得心应手

00:00:43.744 --> 00:00:46.180 
所以AVFoundation
提供样式广泛的API

00:00:46.246 --> 00:00:47.614 
用于多媒体活动

00:00:47.915 --> 00:00:51.118 
包括回放 拍摄 导出
以及多种类型的编辑

00:00:51.185 --> 00:00:53.287 
我的重点主要在回放上

00:00:54.421 --> 00:00:57.624 
AVFoundation回放
支持样式非常广泛的

00:00:57.691 --> 00:01:01.028 
存储于本地的媒体格式

00:01:01.428 --> 00:01:03.597 
在大多数情况下
你可以将相同的文件

00:01:03.697 --> 00:01:05.199 
放到一个网络服务器上

00:01:05.532 --> 00:01:08.869 
然后AVFoundation
可以通过网络播放那个文件

00:01:09.203 --> 00:01:12.539 
该情况下文件格式是相同的
不过IO是通过网络的

00:01:13.273 --> 00:01:15.876 
我们称之为渐进式下载回放

00:01:16.910 --> 00:01:18.712 
一旦我们开始下载该文件

00:01:18.912 --> 00:01:21.215 
即使网络特性发生变化

00:01:21.281 --> 00:01:23.050 
我们继续下载的还是相同文件

00:01:24.251 --> 00:01:27.154 
HTTP直播流更为动态

00:01:27.855 --> 00:01:31.024  
一般来说 基URL
引用的是主播放列表

00:01:31.592 --> 00:01:34.361  
这会带来相同内容的
多个播放列表

00:01:34.428 --> 00:01:37.664  
但在比特率 格式
或是语言上会有差异

00:01:39.132 --> 00:01:41.802  
而且每一个播放列表都引用

00:01:41.869 --> 00:01:44.371  
含有实际压缩媒体文件的分段

00:01:46.106 --> 00:01:48.075 
我们来谈谈今天的话题

00:01:49.142 --> 00:01:50.244 
我们要讨论

00:01:50.611 --> 00:01:54.081 
和预回放缓冲时间
有关的回放变更

00:01:54.715 --> 00:01:56.550 
我们将推出一个新的API

00:01:56.984 --> 00:01:59.253 
来简化单个文件的循环播放

00:01:59.853 --> 00:02:02.623 
我们会讨论一些
在底层作出的回放改进

00:02:05.492 --> 00:02:08.829 
我们会讨论让你的应用程序
为广色域视频做好准备

00:02:09.763 --> 00:02:12.499 
然后我们会用余下的时间
讨论一个热门的话题

00:02:12.566 --> 00:02:15.469 
回放应用中的静态时间优化

00:02:16.503 --> 00:02:19.173 
我们先从等待网络开始

00:02:19.239 --> 00:02:21.041 
缓冲中
请稍等...

00:02:21.141 --> 00:02:23.177 
因为当我们在网上
进行媒体回放时

00:02:23.243 --> 00:02:24.678 
我们任凭网络的摆布

00:02:24.745 --> 00:02:27.481 
我们不想太早开始
否则回放会卡顿

00:02:27.548 --> 00:02:29.983 
我们不想太晚开始
否则用户会放弃观看

00:02:30.417 --> 00:02:33.020 
我们想在那个
完美时刻的开始播放

00:02:33.086 --> 00:02:35.656 
且在我们有足够数据时
开始回放 这样我们就能够

00:02:35.722 --> 00:02:37.491 
持续播放 没有卡顿

00:02:38.392 --> 00:02:40.294 
这是现有的API

00:02:40.827 --> 00:02:43.797 
AVPlayerItem
提供三个Boolean属性

00:02:44.631 --> 00:02:47.401 
playbackLikelyToKeepUp
playbackBufferFull

00:02:47.467 --> 00:02:48.936 
以及playbackBufferEmpty

00:02:49.636 --> 00:02:53.106 
playbackBuffer——抱歉——
playbackLikelyToKeepUp为true的

00:02:53.173 --> 00:02:56.977 
条件是AVFoundation算法
认为如果你现在停止播放

00:02:57.211 --> 00:02:59.079 
你就可以持续播放 没有卡顿

00:02:59.146 --> 00:03:00.013 
直到播放结束

00:03:00.948 --> 00:03:04.117 
playbackBufferFull
为true的条件是缓冲

00:03:04.184 --> 00:03:06.186 
已经达到最大量了

00:03:06.253 --> 00:03:07.821 
如果你还没有开始回放

00:03:07.888 --> 00:03:08.755 
那就开始回放吧

00:03:09.489 --> 00:03:12.092 
playbackBufferEmpty
意味着你卡住了

00:03:12.159 --> 00:03:13.327 
或者即将卡住

00:03:16.330 --> 00:03:19.566 
对于iOS 9和更早版本中的
渐进式下载回放

00:03:19.900 --> 00:03:23.570 
AVFoundation客户端
必须自己监控这些属性

00:03:23.937 --> 00:03:26.607 
等待直到
playbackLikelyToKeepUp为true

00:03:26.673 --> 00:03:28.842 
或playbackBufferFull为true

00:03:29.009 --> 00:03:31.812 
之后再将AVPlayer
的速率属性设置为1

00:03:32.913 --> 00:03:35.215 
对于HTTP直播流
规则更加简单

00:03:35.782 --> 00:03:38.218 
你可立刻将AVPlayer
速率属性设置为1

00:03:38.385 --> 00:03:40.187 
当用户选择播放的时候

00:03:40.487 --> 00:03:42.222 
这就会自动等待

00:03:42.856 --> 00:03:45.359 
缓冲足够的媒体文件
之后再开始回放

00:03:47.160 --> 00:03:49.363 
我们精简了默认的API契约

00:03:49.429 --> 00:03:51.899 
在2016年的iOS版本中

00:03:51.965 --> 00:03:54.234 
iOS  Mac OS  tvOS

00:03:55.002 --> 00:03:59.306 
对使用iOS 10 Mac OS
Sierra tvOS 10及之后版本应用

00:04:00.340 --> 00:04:02.543 
HLS的规则也同样适用于

00:04:02.609 --> 00:04:04.044 
渐进式下载回放

00:04:04.778 --> 00:04:06.046 
当用户点击播放时

00:04:06.113 --> 00:04:09.449 
你可以立刻将AVPlayer
的速率属性设置为1

00:04:09.650 --> 00:04:11.652 
或调用播放方法
都是一样的

00:04:12.452 --> 00:04:14.321 
AVFoundation自动等待

00:04:14.388 --> 00:04:16.190 
足够多的缓冲
从而避免卡住

00:04:17.257 --> 00:04:20.127 
如果回放期间网络中断
然后播放卡住

00:04:20.661 --> 00:04:23.497 
速率属性仍将设置为1

00:04:24.231 --> 00:04:26.934 
所以它会再次缓冲并自动恢复

00:04:27.000 --> 00:04:27.968 
当有足够缓冲的时候

00:04:31.271 --> 00:04:34.374 
如果你使用AVKit
或者MediaPlayer框架

00:04:34.775 --> 00:04:36.710 
来呈现你的回放UI

00:04:37.544 --> 00:04:40.814 
它已经支持了自动缓冲等待

00:04:40.881 --> 00:04:41.849 
并且会继续支持

00:04:42.616 --> 00:04:45.118 
若你的应用
直接使用AVFoundation

00:04:45.385 --> 00:04:46.887 
然后你构建自己的回放UI

00:04:47.054 --> 00:04:48.589 
你可能需要做一些调整

00:04:50.157 --> 00:04:51.758 
所以这个新API应该叫什么？

00:04:52.125 --> 00:04:56.430 
Autoplay这个词
已经用在了QTKit中

00:04:56.530 --> 00:04:59.533 
和HTML 5中
但我们得出的结论是

00:04:59.600 --> 00:05:02.803 
从这个AVPlayer API
的角度看

00:05:03.136 --> 00:05:05.439 
自动的部分并不是回放

00:05:05.839 --> 00:05:06.673 
而是等待

00:05:07.674 --> 00:05:10.077 
所以这个API的正式名称是

00:05:10.210 --> 00:05:12.513 
automaticallyWaits
ToMinimizeStalling

00:05:12.579 --> 00:05:14.381 
但若你喜欢
称它为Autoplay也行

00:05:16.250 --> 00:05:17.551 
这个网络回放现在看起来

00:05:17.618 --> 00:05:19.419 
像是有三个状态的状态机

00:05:20.220 --> 00:05:22.189 
暂停 等待 播放

00:05:23.023 --> 00:05:25.592 
我们从暂停状态开始
直到用户选择播放

00:05:25.993 --> 00:05:28.862 
然后应用调用播放
我们就移至等待状态

00:05:30.264 --> 00:05:33.133 
当playbackLikelyToKeepUp
属性为true时

00:05:33.200 --> 00:05:35.202 
播放器会前进到播放状态

00:05:35.936 --> 00:05:37.738 
如果缓冲是空的

00:05:38.438 --> 00:05:40.107 
播放器会切换回等待状态

00:05:40.174 --> 00:05:41.375 
直到再次
可能跟上播放

00:05:42.209 --> 00:05:45.312 
如果用户暂停
我们会回到暂停状态

00:05:45.879 --> 00:05:47.714 
这里还有一个
可以实现的过渡

00:05:48.282 --> 00:05:51.585 
回想在此次更改之前的
iOS 9或者之前版本

00:05:51.952 --> 00:05:55.055 
你可以在回放可能
跟上之前调用播放

00:05:55.289 --> 00:05:56.957 
回放会立刻开始

00:05:57.391 --> 00:05:58.458 
即使可能会卡住

00:05:58.825 --> 00:06:01.962 
所以我们通过提供
另一种方法保留了该语义

00:06:02.162 --> 00:06:03.797 
playImmediately(atRate:)

00:06:03.864 --> 00:06:05.832 
这可以让你直接
跳转到播放状态

00:06:06.166 --> 00:06:08.168 
从暂停状态或
等待状态过来

00:06:09.102 --> 00:06:11.405 
要注意的是
这可能会导致卡顿

00:06:11.605 --> 00:06:14.608 
而耐心的等待状态
会避免这种情况

00:06:17.177 --> 00:06:18.011 
所以要注意

00:06:18.145 --> 00:06:20.147 
AVPlayer的速率属性
可能不是

00:06:20.214 --> 00:06:21.114 
你所理解的意义

00:06:21.448 --> 00:06:23.016 
我们重述一遍
这样大家都清楚

00:06:24.084 --> 00:06:25.385 
AVPlayer的速率属性

00:06:26.486 --> 00:06:28.822 
是应用请求的回放速率

00:06:29.423 --> 00:06:31.525 
不要和AVPlayeritem的

00:06:31.758 --> 00:06:32.593 
时基速率相混淆

00:06:32.926 --> 00:06:35.062 
那是回放实际发生的速率

00:06:36.630 --> 00:06:38.198 
我们添加了两个新的属性在

00:06:39.867 --> 00:06:42.336 
此版本中

00:06:43.403 --> 00:06:44.571 
来给大家展示更多细节

00:06:44.638 --> 00:06:46.573 
一个是
timeControlStatus

00:06:46.640 --> 00:06:48.442 
这可以表达出
你在哪一个状态中

00:06:48.575 --> 00:06:50.043 
暂停 等待或是播放

00:06:50.377 --> 00:06:51.879 
如果你在等待状态中

00:06:52.813 --> 00:06:55.883 
等待播放的原因
属性会告诉你原因

00:06:56.717 --> 00:06:59.152 
例如 你可能在等待状态中

00:06:59.219 --> 00:07:03.156 
那AVPlayer的
速率属性可能是1

00:07:04.491 --> 00:07:06.927 
因为你在等待
所以timebase.rate会是0

00:07:06.994 --> 00:07:08.595 
timeControlStatus
会再次表达

00:07:08.662 --> 00:07:10.364 
我在等待以特定速率进行播放

00:07:10.797 --> 00:07:14.134 
然后等待播放的原因
可能是为减少卡顿而等待

00:07:15.469 --> 00:07:16.603 
所以凭借这些背景知识

00:07:16.670 --> 00:07:18.872 
我想介绍我的朋友
Moritz Wittenhagen

00:07:18.939 --> 00:07:20.140 
他比我更加大胆

00:07:20.274 --> 00:07:21.441 
因为他要尝试

00:07:21.608 --> 00:07:24.778 
在台上进行
现场网络回放演示

00:07:24.845 --> 00:07:26.446 
所以各位祝他好运
给他一些掌声

00:07:31.051 --> 00:07:32.452 
各位早上好

00:07:34.254 --> 00:07:35.923 
我想先开始展示一下

00:07:36.290 --> 00:07:37.824 
我们在台上有的设备

00:07:38.125 --> 00:07:39.293 
这是我的iPad

00:07:39.560 --> 00:07:41.328 
你能看到
这在屏幕上同步显示着

00:07:41.895 --> 00:07:44.031 
那个iPad正在加入一个

00:07:44.097 --> 00:07:45.265 
由Mac搭建的网络

00:07:46.099 --> 00:07:49.336 
这可以让我使用
网络连接调节器

00:07:49.403 --> 00:07:51.605 
来限制网络连接

00:07:51.672 --> 00:07:53.106 
用于这个iPad的

00:07:53.774 --> 00:07:55.475 
这可以使用
网络连接调节器的

00:07:55.542 --> 00:07:56.376 
偏好面板做到

00:07:56.677 --> 00:07:58.579 
Sam一会儿
会告诉你去哪里去找

00:07:59.112 --> 00:08:01.415 
我设置了
Slow Server配置文件

00:08:01.748 --> 00:08:04.785 
这会将其限制成一般的网络连接

00:08:04.885 --> 00:08:06.253 
这稍微慢于

00:08:06.787 --> 00:08:08.589 
我们想要播放的
媒体比特率

00:08:09.389 --> 00:08:10.290 
目前这是关闭的

00:08:11.391 --> 00:08:14.161 
我们先不开启它
然后来看看iPad在

00:08:14.728 --> 00:08:16.263 
优质网络条件下的性能

00:08:17.431 --> 00:08:19.967 
所以我这里有的只是一个选集

00:08:20.033 --> 00:08:21.768 
我可以选择一个视频

00:08:21.935 --> 00:08:22.803 
我开始选择

00:08:23.036 --> 00:08:26.306 
你看到的是
视频马上就加载上了

00:08:26.573 --> 00:08:32.011 
我们看到
目前没在播放

00:08:32.346 --> 00:08:34.581 
你看看这下面
极好的工程UI

00:08:34.648 --> 00:08:37.351 
告诉我们所有的属性

00:08:37.417 --> 00:08:39.520 
以及功能
这都和自动等待有关

00:08:39.953 --> 00:08:43.289 
这真的是从AVPlayer
和AVPlayeritem中获取的

00:08:43.357 --> 00:08:47.327 
所以有这些属性可供你使用
如果你需要知道

00:08:47.427 --> 00:08:48.729 
自动等待在做什么的话

00:08:49.329 --> 00:08:51.765 
因为现在我们暂停了
所以这些速率都是0

00:08:51.832 --> 00:08:52.766 
当前时间是0

00:08:52.833 --> 00:08:56.370 
但有意思的是
因为我们在快速的网络中

00:08:56.436 --> 00:08:58.472 
我们加载了39秒的视频

00:08:58.539 --> 00:08:59.773 
这实际上就是整个视频

00:08:59.840 --> 00:09:02.309 
然后我们目前
可能跟上回放

00:09:03.043 --> 00:09:06.046 
这意味着
当我现在点击播放

00:09:06.513 --> 00:09:09.750 
视频就会开始播放
没有任何问题

00:09:10.884 --> 00:09:14.755 
现在我们想看看
在差的网络条件下会怎么样

00:09:14.821 --> 00:09:17.457 
所以我们启用Mac
上的网络连接调节器

00:09:18.592 --> 00:09:19.426 
好了

00:09:19.660 --> 00:09:21.995 
对这个视频没什么差别

00:09:22.062 --> 00:09:26.333 
因为如我所说整个视频已经缓冲完毕了

00:09:26.967 --> 00:09:29.803 
所以当我回去再次加载它

00:09:29.870 --> 00:09:32.239 
我想让大家重新注意
loadedTimeRanges

00:09:32.306 --> 00:09:34.374 
和isPlaybackLikely
ToKeepUp

00:09:34.741 --> 00:09:35.576 
所以开始吧

00:09:36.543 --> 00:09:37.444 
重新加载视频

00:09:38.111 --> 00:09:39.680 
现在我们看到的是

00:09:39.746 --> 00:09:42.516 
loadedTimeRange
只是缓慢地增加

00:09:42.583 --> 00:09:45.152 
isPlaybackLikely
ToKeepUp 为false

00:09:46.086 --> 00:09:47.654 
但终究会变成true

00:09:47.988 --> 00:09:50.791 
在那一时刻我们
处在了和之前相同的状态

00:09:50.858 --> 00:09:54.361 
现在准备播放
然后回放就会开始

00:09:55.262 --> 00:09:57.564 
现在我们再试一次

00:09:57.631 --> 00:10:00.534 
这一次我会在视频加载好
之后马上点击播放

00:10:00.934 --> 00:10:04.071 
所以这一次
我们没有足够的数据

00:10:04.137 --> 00:10:05.472 
然后就进入了这个等待状态

00:10:05.539 --> 00:10:08.809 
你看到这个转动图标
告诉用户在等待回放

00:10:08.876 --> 00:10:11.979 
最终这会成为准备播放
然后回放就会开始

00:10:12.880 --> 00:10:16.049 
还有一件事我们可以做
那就是立刻回放

00:10:16.183 --> 00:10:17.284 
我们也试一下

00:10:19.286 --> 00:10:22.623 
我进入这个视频
马上点击立刻播放

00:10:22.890 --> 00:10:26.360 
我们看到回放开始了
不过之后很快就卡住了

00:10:26.426 --> 00:10:29.129 
因为我们没有足够的缓冲
来将视频播完

00:10:29.296 --> 00:10:31.899 
这种情况下
我们会进入等待状态

00:10:31.965 --> 00:10:36.303 
直到重新缓冲出
足够的数据播到最后

00:10:37.037 --> 00:10:39.840 
以上就是自动等待的简短演示

00:10:40.641 --> 00:10:41.842 
回到Sam和幻灯片上

00:10:48.448 --> 00:10:49.383 
谢谢 Moritz

00:10:49.750 --> 00:10:51.485 
我们回顾一下
中间发生了什么

00:10:52.152 --> 00:10:54.655 
当我们设置了
更缓慢的网络速度

00:10:54.755 --> 00:10:56.023 
接近那部电影的数据速率

00:10:57.090 --> 00:10:58.625 
电影一开始是暂停的

00:10:59.293 --> 00:11:00.394 
当他点击播放

00:11:02.029 --> 00:11:03.263 
这就进入等待状态

00:11:04.631 --> 00:11:07.467 
因为目前回放不可能跟上

00:11:08.402 --> 00:11:11.271 
注意到这个时候
播放器的速率是1

00:11:11.338 --> 00:11:12.773 
但时基速率是0

00:11:13.807 --> 00:11:16.677 
几秒钟之后
AVFoundation断定

00:11:17.477 --> 00:11:18.745 
回放有可能跟上

00:11:19.680 --> 00:11:21.982 
所以它将时间控制--

00:11:22.449 --> 00:11:26.119 
它将状态设置成播放
然后现在你看到

00:11:26.186 --> 00:11:28.422 
播放器速率和时基速率都是1

00:11:31.258 --> 00:11:32.092 
你可能会想到

00:11:32.159 --> 00:11:34.027 
有更多一点的细节存在于

00:11:34.094 --> 00:11:36.897 
timeControlStatus
而非播放器速率属性中

00:11:37.197 --> 00:11:39.499 
记住播放器速率告诉你的是应用

00:11:39.566 --> 00:11:40.701 
所求的回放速率

00:11:40.767 --> 00:11:42.336 
timeControlStatus

00:11:42.402 --> 00:11:43.670 
还考虑到实际发生的事情

00:11:44.071 --> 00:11:45.772 
所以这些东西
你可能要考虑周全

00:11:45.839 --> 00:11:46.807 
当你构建回放UI时

00:11:48.475 --> 00:11:49.776 
假如你想在家中尝试

00:11:50.210 --> 00:11:52.646 
你可能要知道如何找到
网络连接调节器

00:11:52.713 --> 00:11:55.516 
这不是我们发明的东西
至少不是我们团队

00:11:55.949 --> 00:11:59.820 
这是硬件IO工具下载的一部分

00:12:00.320 --> 00:12:03.390 
最简单的获取方法是
顺着Xcode菜单

00:12:03.457 --> 00:12:04.858 
找到更多开发者工具

00:12:05.459 --> 00:12:07.761 
登陆后
你就会在这里找到

00:12:09.062 --> 00:12:10.731 
好了 所以

00:12:11.532 --> 00:12:15.669 
如果你使用
2016 SDK或之后的版本

00:12:16.203 --> 00:12:19.006 
你的应用就会
表现出这样的属性设置

00:12:19.106 --> 00:12:21.775 
自动将WaitsToMinimizeStalling
设置为true

00:12:21.842 --> 00:12:23.544 
你可以将那个属性设成false

00:12:24.311 --> 00:12:25.812 
如果你想回到之前的行为

00:12:25.913 --> 00:12:27.581 
你这么做可能会有这几个原因

00:12:27.881 --> 00:12:33.287 
具体说 如果你想使用
setRate(time atHostTime)的调用

00:12:33.554 --> 00:12:36.290 
来用外部时间轴
同步回放

00:12:36.823 --> 00:12:39.359 
那你必须选择性退出
做法是自动将

00:12:39.426 --> 00:12:41.662 
WaitsToMinimizeStalling
属性设置为false

00:12:41.728 --> 00:12:43.564 
否则 你会遇到友好异常

00:12:44.364 --> 00:12:45.199 
很有帮助的提醒

00:12:46.767 --> 00:12:49.770 
最后 提醒一下
绝对不要使用播放器速率

00:12:49.837 --> 00:12:51.905 
来推断将来的当前超时

00:12:52.439 --> 00:12:54.908 
如果你想那么做
那使用项目的时基速率

00:12:54.975 --> 00:12:55.809 
来代替它

00:12:56.043 --> 00:12:57.678 
或使用时基对象中的其他API

00:12:57.744 --> 00:12:58.645 
那是它们的专长

00:12:59.279 --> 00:13:00.781 
好了 这就是缓冲的内容

00:13:01.048 --> 00:13:02.583 
我们前进到循环的话题

00:13:02.983 --> 00:13:03.984 
我问大家一个问题

00:13:04.852 --> 00:13:07.421 
什么是循环单一项目的最佳方法

00:13:07.955 --> 00:13:09.590 
一个想法是设置监听器来

00:13:09.656 --> 00:13:11.058 
监听发出的通知

00:13:11.258 --> 00:13:12.626 
当回放抵达结尾的时候

00:13:12.926 --> 00:13:13.861 
当被调用的时候

00:13:14.261 --> 00:13:16.163 
找回到开头 然后重新开始

00:13:16.830 --> 00:13:18.899 
这个想法挺不错的

00:13:19.166 --> 00:13:21.134 
但不幸的是这会导致空白

00:13:21.201 --> 00:13:22.870 
在两次回放之间
原因有两个

00:13:23.403 --> 00:13:25.138 
第一个原因是这会有延迟

00:13:25.372 --> 00:13:27.174 
这是由于通知发出

00:13:27.241 --> 00:13:30.444 
并送达到程序的时间
以及第二次播放器请求

00:13:30.511 --> 00:13:31.912 
返回到回放系统的时间

00:13:32.713 --> 00:13:35.749 
第二个更为显著的原因是预滚

00:13:35.916 --> 00:13:36.850 
所需的时间

00:13:37.551 --> 00:13:38.452 
你是不可能

00:13:38.519 --> 00:13:40.921 
立刻进行媒体回放的

00:13:40.988 --> 00:13:41.955 
如果没有一些准备

00:13:42.389 --> 00:13:45.926 
有必要先加载媒体数据并解码一些数据

00:13:46.126 --> 00:13:47.694 
之后你才能开始播放出来

00:13:48.262 --> 00:13:50.764 
这个先补充回放管道

00:13:50.998 --> 00:13:53.267 
再开始回放的过程叫做预滚

00:13:54.668 --> 00:13:57.171 
所以我们想在这里做的是

00:13:57.571 --> 00:14:00.140 
将AVFoundation
参与到该计划中

00:14:00.807 --> 00:14:03.610 
如果AVFoundation
对回放项目B

00:14:03.877 --> 00:14:07.281 
足够提前获悉
那这就可以开始预滚

00:14:07.447 --> 00:14:10.450 
然后解码
在项目A播完前进行

00:14:10.717 --> 00:14:13.187 
所以这就能优化A到B的过渡了

00:14:14.121 --> 00:14:17.991 
如果项目B十分短
那AVFoundation甚至可以开始

00:14:18.058 --> 00:14:19.459 
进行到项目C的过渡

00:14:20.994 --> 00:14:24.598 
实现该目的AVFoundation
工具就是AVQueuePlayer

00:14:25.332 --> 00:14:28.802 
AVQueuePlayer是
AVPlayer的子类 拥有一排的

00:14:28.869 --> 00:14:30.838 
AVPlayer项目 叫做播放队列

00:14:31.538 --> 00:14:34.575 
当前项目排在列阵的第一位

00:14:36.043 --> 00:14:38.245 
用AVQueuePlayer

00:14:38.312 --> 00:14:39.446 
优化不同项目间的过渡

00:14:39.847 --> 00:14:43.050 
但在循环的情况下
你可以创建多个AVPlayer项目

00:14:43.116 --> 00:14:44.651 
从同样的AVAsset上面

00:14:45.018 --> 00:14:46.486 
这是另一种优化

00:14:46.820 --> 00:14:48.689 
AVFoundation无需加载

00:14:48.755 --> 00:14:51.124 
并多次暂停媒体文件

00:14:53.627 --> 00:14:56.530 
提醒一下 播放列队不是播放列表

00:14:57.130 --> 00:14:59.733 
请别加载接下来的10,000个项目

00:14:59.800 --> 00:15:02.369 
你认为你可能会在播放列队中播放

00:15:02.436 --> 00:15:03.504 
这并不高效

00:15:03.904 --> 00:15:06.373 
播放列队的目的是提供关于

00:15:06.440 --> 00:15:08.308 
将要播放项目的信息

00:15:08.375 --> 00:15:11.411 
这样AVFoundation
可以优化过渡

00:15:13.747 --> 00:15:15.315 
这种设计模式是当你想无限循环

00:15:15.449 --> 00:15:17.150 
单个媒体文件的话

00:15:17.518 --> 00:15:19.953 
要制作少量的
AVPlayer项目

00:15:20.120 --> 00:15:22.189 
然后将它们放在
AVQueuePlayer列队中

00:15:22.256 --> 00:15:25.058 
并将行动项和属性设置成提前

00:15:26.560 --> 00:15:28.495 
当回放达到一个项目的结尾时

00:15:29.096 --> 00:15:32.599 
随着回放前进到下一个
它会从播放列队中移除

00:15:33.433 --> 00:15:35.402 
当你得到完成过渡的通知时

00:15:35.702 --> 00:15:36.970 
你可将那个播放完的项目

00:15:37.304 --> 00:15:38.872 
将其当前时间设置回开头

00:15:39.139 --> 00:15:41.608 
然后将其放在播放列队的最后重新播放

00:15:42.643 --> 00:15:44.278 
我们将这种
模式叫做跑步机

00:15:45.913 --> 00:15:48.081 
而且你可以自己
实施这个跑步机模式

00:15:48.148 --> 00:15:49.149 
使用AVQueuePlayer

00:15:49.216 --> 00:15:50.517 
我们有示例代码来帮助大家

00:15:51.051 --> 00:15:54.221 
稍微难的一点是
你必须设置键值观察

00:15:54.988 --> 00:15:56.523 
来查看项目何时被移除的

00:15:56.857 --> 00:15:58.225 
然后将其找回到开头

00:16:00.460 --> 00:16:01.862 
然后又出现在播放列队最后

00:16:02.963 --> 00:16:04.932 
如你所见 在这个代码中

00:16:05.065 --> 00:16:07.301 
我们停用了KVO观察者

00:16:07.701 --> 00:16:08.869 
当我们改变播放列队时

00:16:09.203 --> 00:16:10.637 
来避免任何递归的可能

00:16:11.338 --> 00:16:12.639 
所以很明显这是可能的

00:16:12.706 --> 00:16:13.974 
只是有一点复制

00:16:14.942 --> 00:16:16.143 
而且我们收到的反馈是

00:16:16.210 --> 00:16:18.712 
如果我们能将其变得更简单
那就再好不过了

00:16:20.881 --> 00:16:22.983 
我们推出
AVPlayerLooper

00:16:23.116 --> 00:16:24.818 
这会替你实现跑步机模式

00:16:25.219 --> 00:16:27.054 
你给它一个
AVQueuePlayer

00:16:30.624 --> 00:16:33.794 
你给它一个AVQueuePlayer
和一个模板AVPlayerItem

00:16:33.861 --> 00:16:36.463 
然后它构建少量
AVPlayerItem的副本

00:16:36.697 --> 00:16:38.232 
这之后会在播放列队中循环

00:16:38.298 --> 00:16:39.366 
直到你告诉它停止

00:16:41.668 --> 00:16:43.470 
将AVPlayerLooper采用于

00:16:43.537 --> 00:16:45.873 
符号案例中的代码就变得更加容易了

00:16:47.307 --> 00:16:48.609 
所以我想给大家演示一下

00:16:49.276 --> 00:16:50.544 
在这里的iPad上面

00:16:51.011 --> 00:16:52.579 
所以这是一段示例代码

00:16:52.980 --> 00:16:54.581 
启动Video Looper

00:16:54.948 --> 00:16:57.217 
我在这里添加了我自己的一个媒体文件

00:16:57.451 --> 00:16:59.486 
然后我们将用
AVPlayerLooper来播放

00:17:07.928 --> 00:17:08.929 
感觉是不是很柔和？

00:17:11.431 --> 00:17:12.566 
好了 这很明显在循环

00:17:12.633 --> 00:17:15.234 
代码如我指出的那样

00:17:15.301 --> 00:17:16.236 
非常简单

00:17:16.737 --> 00:17:19.406 
这种工具适合用于 例如

00:17:19.740 --> 00:17:21.074 
如果你有一个tvOS应用

00:17:21.441 --> 00:17:24.310 
而且你想在标题菜单
后面放上循环的背景视频

00:17:27.114 --> 00:17:28.949 
好了 我们回到幻灯片

00:17:30.150 --> 00:17:33.053 
演示AVPLAYERLOOPER

00:17:34.588 --> 00:17:37.024 
我们讲了讲如何循环

00:17:37.691 --> 00:17:39.593 
我想花点时间讲讲循环什么

00:17:42.930 --> 00:17:45.632 
理想来说 如果你有音频轨和视频轨

00:17:45.966 --> 00:17:47.568 
它们的长度应该精确相同

00:17:48.035 --> 00:17:52.306 
为什么？如果音频轨更长 那这意味着

00:17:52.372 --> 00:17:54.174 
在接近结尾的时候 那一段

00:17:54.241 --> 00:17:56.510 
音频应该播放的时间 视频却没在播放

00:17:57.411 --> 00:17:59.112 
我们有一段空白的视频

00:17:59.179 --> 00:18:00.480 
所以视频应该怎么办？

00:18:00.547 --> 00:18:01.648 
应该关闭吗？

00:18:01.748 --> 00:18:03.250 
应该停在一帧上吗？

00:18:04.151 --> 00:18:06.186 
相反如果视频轨更长

00:18:06.353 --> 00:18:09.323 
那就会有一段没有音频的时间

00:18:09.857 --> 00:18:12.659 
所以当你创建用于循环的媒体资源时

00:18:12.926 --> 00:18:15.529 
要花时间确认轨道时长互相匹配

00:18:15.596 --> 00:18:16.864 
在QuickTime电影文件中

00:18:16.930 --> 00:18:19.099 
轨道时长是由编辑列表所定义的

00:18:20.734 --> 00:18:23.537 
如果用于循环的媒体资源
并非完全处在你的控制之下

00:18:23.604 --> 00:18:24.705 
另一种可能是

00:18:24.771 --> 00:18:28.008 
你可以将AVPlayerItem的
正向回放结束时间设置成

00:18:28.075 --> 00:18:30.177 
最短轨道的长度

00:18:30.644 --> 00:18:33.247 
从而调短另一个轨道
来实现匹配

00:18:36.049 --> 00:18:38.952 
好了 接下来看看我们在

00:18:39.019 --> 00:18:40.287 
回放管道中做的优化

00:18:40.354 --> 00:18:42.589 
这可能会影响到你的应用程序

00:18:43.624 --> 00:18:45.592 
假设我们当前正在播放中

00:18:45.993 --> 00:18:48.462 
然后播放中的轨道列表发生改变

00:18:49.897 --> 00:18:52.799 
例如 我们能更改字幕语言

00:18:53.066 --> 00:18:54.168 
或者音频语言

00:18:54.601 --> 00:18:56.069 
将音频从英语换成法语

00:18:56.370 --> 00:18:59.139 
我会将字幕语言从英语换成西班牙语

00:19:00.374 --> 00:19:03.710 
或者我们可以移除正在显示
视频的AVPlayerLayer

00:19:05.646 --> 00:19:08.916 
或添加AVPlayerLayer
开始显示视频

00:19:11.852 --> 00:19:13.720 
在iOS 9中的所有这些情况里

00:19:13.954 --> 00:19:16.223 
AVFoundation会暂停回放

00:19:16.423 --> 00:19:19.626 
调整回放管道来匹配启用的轨道列表

00:19:19.793 --> 00:19:20.961 
然后恢复回放

00:19:21.361 --> 00:19:23.463 
在一些情况中 这甚至会导致视频

00:19:23.530 --> 00:19:24.831 
回跳到一个关键帧上

00:19:25.299 --> 00:19:28.669 
我要说我们收到了有建设性的反馈

00:19:28.735 --> 00:19:30.404 
都来自用户和开发者

00:19:31.638 --> 00:19:33.407 
所以我很高兴地宣布

00:19:34.608 --> 00:19:38.745 
在iOS 10和
其他2016年的姊妹系统中

00:19:38.946 --> 00:19:41.949 
这些改变不会再导致回放暂停

00:19:42.249 --> 00:19:46.253 
在播放中的AVPlayer上添加或
移除唯一AVPlayerLayer

00:19:46.587 --> 00:19:47.855 
改变字幕语言

00:19:47.921 --> 00:19:50.123 
或改变播放中
AVPlayer的音频语言

00:19:50.290 --> 00:19:52.392 
或者手动停用或启用轨道

00:19:54.928 --> 00:19:57.731 
我们认为这对用户和
开发者来说是一种提升

00:19:57.798 --> 00:20:00.801 
然而 这显著地改变了API的行为

00:20:00.901 --> 00:20:05.405 
所以我请各位在
seed版本中查看一下

00:20:06.006 --> 00:20:08.642 
看看这是否会在
应用中导致任何复杂问题

00:20:08.976 --> 00:20:12.012 
如果你发现了一个问题
像是我们这边出的错误

00:20:12.246 --> 00:20:13.347 
那就请给我们反馈

00:20:13.413 --> 00:20:15.549 
使用Apple错误报告系统上报错误

00:20:15.849 --> 00:20:17.518 
像往常一样 当上报错误时

00:20:17.784 --> 00:20:19.653 
请给我们所需要的一切信息

00:20:19.720 --> 00:20:21.388 
来让我们自己再现出那个问题

00:20:25.292 --> 00:20:30.130 
我们的行业正在过渡到更广的色域上

00:20:30.430 --> 00:20:32.366 
用于数码摄影和数码视频

00:20:34.134 --> 00:20:36.770 
很多iOS开发者从来不需要应对

00:20:36.837 --> 00:20:40.174 
不使用Rec.709
色彩空间标准的视频

00:20:40.474 --> 00:20:42.609 
因为那是高清视频的标准

00:20:42.676 --> 00:20:45.012 
且那也是我们自iPhone 4
开始使用的拍摄标准

00:20:45.646 --> 00:20:47.848 
但是更广色域的
色彩空间即将来临

00:20:48.782 --> 00:20:51.485 
你可能已看到了
在最新的iPad Pro上

00:20:51.685 --> 00:20:53.120 
当运行iOS 10时

00:20:54.521 --> 00:20:57.057 
你可以拍摄并显示照片

00:20:57.291 --> 00:20:58.992 
在P3色彩空间中

00:20:59.726 --> 00:21:03.230 
一些第三方产品也在P3中拍摄视频

00:21:03.830 --> 00:21:06.967 
所以我想给大家指点一下
你可以应用的API

00:21:07.034 --> 00:21:09.036 
用于你的应用中来做好准备

00:21:09.102 --> 00:21:11.905 
让你的应用支持广色域视频

00:21:13.140 --> 00:21:14.675 
当我首先要给你一些背景知识

00:21:16.243 --> 00:21:18.912 
在媒体文件中色彩空间信息是

00:21:18.979 --> 00:21:20.814 
视频轨的元数据的一部分

00:21:21.181 --> 00:21:23.984 
在QuickTime电影文件中
它保存于样本描述中

00:21:24.218 --> 00:21:27.254 
在一些Codec中
它还保存于Codec特定的位置

00:21:27.688 --> 00:21:29.723 
这个信息有三个主体

00:21:30.457 --> 00:21:33.827 
基色 用于明确100%红色

00:21:33.894 --> 00:21:36.430 
100%绿色和100%蓝色是什么

00:21:36.830 --> 00:21:37.831 
还有白点

00:21:39.032 --> 00:21:40.234 
传递特性

00:21:40.734 --> 00:21:42.369 
你可能听过叫做伽玛曲线

00:21:42.703 --> 00:21:43.604 
或是传递函数

00:21:44.571 --> 00:21:48.509 
这些从像素值到光级来定义映射

00:21:49.276 --> 00:21:52.913 
然后回答那是直线还是曲线的问题

00:21:52.980 --> 00:21:55.048 
这会在黑暗的区域给你更多细节

00:21:55.115 --> 00:21:56.283 
那里我们的眼睛更敏感

00:21:57.317 --> 00:22:00.454 
然后是YCbCr矩阵 是指坐标变换

00:22:00.687 --> 00:22:03.190 
从它们的RGB空间进入到用于

00:22:03.257 --> 00:22:04.825 
高效压缩的空间

00:22:06.660 --> 00:22:08.295 
所以在这里我有一些例子

00:22:08.729 --> 00:22:11.098 
若你没有听说过Rec.709相当于

00:22:11.164 --> 00:22:13.033 
视频上面的SIGB

00:22:13.300 --> 00:22:15.302 
其实SIGB是基于Rec.709的

00:22:16.103 --> 00:22:17.437 
广色域可以通过

00:22:17.804 --> 00:22:20.007 
使用不同组的基色来实现

00:22:20.607 --> 00:22:26.146 
P3基色所指定的100%红色

00:22:26.213 --> 00:22:28.482 
100%绿色和100%蓝色的值

00:22:28.649 --> 00:22:31.318 
要比Rec.709更加鲜艳

00:22:34.454 --> 00:22:35.522 
我还有一点要说

00:22:36.290 --> 00:22:39.359 
在我们的API中 我们一般是通过

00:22:39.860 --> 00:22:41.428 
使用枚举字符串来表现这些选择

00:22:41.528 --> 00:22:43.597 
因为它们更易于打印 显示以及调试

00:22:44.097 --> 00:22:47.267 
但在媒体文件中
它们是通过数字表达的

00:22:47.734 --> 00:22:51.004 
这些标准标签数字
是在MPEG规格中定义出的

00:22:51.271 --> 00:22:52.573 
叫做编码独立代码点

00:22:52.940 --> 00:22:54.341 
这听起来是否有点矛盾？

00:22:54.842 --> 00:22:56.410 
怎么会是编码独立代码点呢？

00:22:56.476 --> 00:22:58.979 
它会不是那么的矛盾

00:22:59.613 --> 00:23:01.882 
如果你读成Codec编码独立代码点

00:23:02.382 --> 00:23:04.785 
这个规则的目的是确保这些标签数字的

00:23:04.852 --> 00:23:06.153 
任务是以一种协调的方式

00:23:06.220 --> 00:23:08.989 
在所有Codec和文件格式中完成

00:23:09.223 --> 00:23:11.058 
所以对数字的解释会是相同的

00:23:11.225 --> 00:23:14.494 
在QuickTime Movie
MPEG-4和H264中等

00:23:15.128 --> 00:23:17.531 
好 有了这些背景知识
我们看看一些新的API

00:23:18.398 --> 00:23:21.535 
我们推出了一个新的媒体特性
这会告诉你

00:23:21.602 --> 00:23:24.004 
视频轨标签有更广的基色

00:23:24.071 --> 00:23:25.939 
比Rec.709基色还要广

00:23:26.473 --> 00:23:28.809 
若你的应用发现这里有广色域视频

00:23:29.243 --> 00:23:30.878 
适合做的是让你的应用采取措施

00:23:30.944 --> 00:23:33.981 
将其保留下来 所以
这不会压回到709的色彩空间

00:23:34.882 --> 00:23:36.617 
如果没有 最好的做法是

00:23:36.717 --> 00:23:38.318 
停留在Rec.709中处理

00:23:39.887 --> 00:23:43.223 
所以你可指定工作色彩空间

00:23:43.290 --> 00:23:46.693 
当你设置AVPlayerItemVideoOutput
或AVAssetReaderOutput时

00:23:47.194 --> 00:23:49.162 
然后你收到的缓冲就被转化到了

00:23:49.229 --> 00:23:50.330 
那个色彩空间中

00:23:50.864 --> 00:23:53.700 
你还可以指定目标色彩空间

00:23:53.767 --> 00:23:55.435 
当你设置AVAssetWriterInput时

00:23:55.502 --> 00:23:57.638 
这种情况下 你提供的源图像缓冲

00:23:57.771 --> 00:23:59.406 
就会被转化到那个色彩空间中

00:23:59.473 --> 00:24:00.307 
在压缩之前

00:24:02.709 --> 00:24:06.146 
使用AVPlayerItemVideoOutput
或AVAssetReaderOutput

00:24:06.213 --> 00:24:08.282 
如果你不想让图像缓冲被转化到

00:24:08.348 --> 00:24:09.616 
普通色彩空间中

00:24:09.816 --> 00:24:13.420 
那你应该设置
AVVideoAllowWideColorKey为true

00:24:13.820 --> 00:24:16.023 
然后你会收到在原始色彩空间中的缓冲

00:24:16.323 --> 00:24:19.560 
这是有效保证了无论什么样的软件收到

00:24:19.626 --> 00:24:22.329 
并处理缓冲 无论是我们的还是你的

00:24:22.563 --> 00:24:24.698 
就会检查并履行那些色彩空间标签

00:24:26.466 --> 00:24:29.636 
这里有类似特性用于配置视频合成

00:24:29.937 --> 00:24:32.306 
首先 你可以指定一个工作色彩空间

00:24:32.372 --> 00:24:33.907 
用于整个视频合成

00:24:34.775 --> 00:24:36.877 
或者 如果你有自定义的视频合成器

00:24:37.077 --> 00:24:38.745 
你可以选择让其支持广色域

00:24:39.279 --> 00:24:42.783 
你可以声明你的自定义
视频合成器支持广色域

00:24:42.850 --> 00:24:45.319 
并且会检查并履行色彩空间的标签

00:24:45.385 --> 00:24:47.020 
在每个源帧缓冲上

00:24:47.287 --> 00:24:50.090 
通过应用可选的
supportsWideColorSourceFrames

00:24:50.157 --> 00:24:51.458 
属性和返回真值

00:24:53.927 --> 00:24:54.995 
我给大家提醒一下

00:24:56.396 --> 00:24:58.498 
比如 如果你手动创建图片缓冲

00:24:58.565 --> 00:24:59.933 
在Metal 使用像素缓冲池

00:25:00.367 --> 00:25:02.402 
然后你应该明确地设置色彩空间标签

00:25:02.469 --> 00:25:04.638 
在每个缓冲上面
通过调用核心视频API

00:25:05.138 --> 00:25:06.707 
大多数开发者不需要这样做

00:25:06.907 --> 00:25:09.843 
在大多数情况下
当你使用支持色彩空间的API时

00:25:09.910 --> 00:25:12.346 
用于源缓冲 这会替你将它们标记上

00:25:12.613 --> 00:25:15.349 
应众人要求 我将用剩下的时间讨论

00:25:15.482 --> 00:25:18.752 
优化回放启动时间的最佳做法

00:25:18.986 --> 00:25:21.889 
我会首先谈谈本地文件回放

00:25:21.989 --> 00:25:23.690 
之后我们去讲HTTP直播流

00:25:24.591 --> 00:25:26.860 
现在的一些优化方法可能

00:25:26.927 --> 00:25:28.195 
第一眼看上去违背常理

00:25:28.428 --> 00:25:29.897 
它们需要你从

00:25:29.963 --> 00:25:32.332 
AVFoundation角度考虑

00:25:32.799 --> 00:25:35.536 
然后考虑它何时会得到其需要的信息

00:25:35.669 --> 00:25:37.271 
来做你的应用所要求的事情

00:25:38.105 --> 00:25:40.440 
例如 这里有一段很直接的代码

00:25:40.574 --> 00:25:42.442 
用于设置本地文件回放

00:25:43.076 --> 00:25:44.478 
我们从文件的URL开始

00:25:44.545 --> 00:25:46.280 
我们创建一AVURLAsset

00:25:46.446 --> 00:25:48.749 
代表存储那个文件的产品

00:25:49.449 --> 00:25:52.853 
之后创建AVPlayerItem
保持回放的可变状态

00:25:52.953 --> 00:25:54.888 
用一个AVPlayeritem
保持回放

00:25:55.155 --> 00:25:56.990 
然后我们创建一个
AVPlayerLayer

00:25:57.057 --> 00:25:59.193 
来将视频回放连接到我们的显示层次中

00:25:59.760 --> 00:26:02.396 
这个代码没问题 但有一点小瑕疵

00:26:02.462 --> 00:26:04.331 
你最初可能没看出来

00:26:05.065 --> 00:26:07.601 
一旦播放项目设置成播放器的当前项目

00:26:08.068 --> 00:26:10.003 
播放器就会开始设置回放管道

00:26:10.070 --> 00:26:11.338 
它不知道将来的事

00:26:11.405 --> 00:26:12.906 
它不知道你过会将设置

00:26:13.040 --> 00:26:14.675 
AVPlayerLayout

00:26:15.676 --> 00:26:18.278 
所以它设置了仅有音频的回放

00:26:18.579 --> 00:26:22.282 
当AVPlayerLayer添加时
现在AVFoundation知道

00:26:22.349 --> 00:26:23.851 
这个视频也需要解码

00:26:23.917 --> 00:26:25.752 
现在它可以重新配置

00:26:25.953 --> 00:26:27.254 
音频和视频的回放

00:26:28.622 --> 00:26:31.491 
如我之前所说

00:26:31.558 --> 00:26:34.461 
我们在今年的iOS版本中做了增强

00:26:35.295 --> 00:26:38.398 
意味着微小的

00:26:38.498 --> 00:26:41.001 
回放列表变更 启用轨道列表的变更

00:26:41.268 --> 00:26:43.170 
不一定会导致中断

00:26:43.637 --> 00:26:46.840 
但理想的做法是在一开始就让

00:26:46.907 --> 00:26:49.877 
AVFoundation
获取所需信息使第一次就一切正常

00:26:49.943 --> 00:26:51.445 
所以我将稍微改变这个代码

00:26:51.512 --> 00:26:53.780 
看好了AVPlayerItem
到哪里连接

00:26:54.147 --> 00:26:55.082 
AVPlayer

00:26:57.351 --> 00:27:00.120 
所以现在播放器
创建好了 没有当前项目

00:27:00.187 --> 00:27:02.689 
这意味着现在
没有理由构建回放管道

00:27:03.257 --> 00:27:05.526 
在你添加AVPlayerLayer
时不会变

00:27:06.293 --> 00:27:07.694 
不会构建回放管道

00:27:07.794 --> 00:27:09.596 
直到播放项目成为了当前项目

00:27:09.796 --> 00:27:12.165 
而到那时候 播放器会知道其需要什么

00:27:12.232 --> 00:27:14.034 
来让第一次就不出问题

00:27:14.868 --> 00:27:16.003 
我们可以概括一下

00:27:16.069 --> 00:27:17.905 
先创建AVPlayerLayer

00:27:17.971 --> 00:27:20.908 
抱歉 首先创建AVPlayer
和AVPlayerItem对象

00:27:20.974 --> 00:27:22.976 
然后设置你在上面需要的属性

00:27:23.043 --> 00:27:26.446 
包括将AVPlayer连接到
AVPlayerLayer上

00:27:26.513 --> 00:27:29.349 
或将AVPlayerItem连接到
AVPlayerItemVideoOutput上

00:27:30.784 --> 00:27:31.785 
这可能似乎有点疯狂

00:27:31.852 --> 00:27:34.021 
但如果你只想要马上开始回放

00:27:34.087 --> 00:27:37.057 
你可以先告诉播放器进行播放
之后你再将播放项目提供给它

00:27:37.157 --> 00:27:38.192 
为什么要这样做？

00:27:38.592 --> 00:27:40.928 
如果你反过来做 播放器一开始会认为

00:27:40.994 --> 00:27:43.764 
你想要显示视频开头的静止帧

00:27:43.931 --> 00:27:45.199 
它可能在这上面浪费时间

00:27:45.265 --> 00:27:48.368 
之后再得到你是真的只想要回放的消息

00:27:48.468 --> 00:27:51.872 
从实际目标开始可能节省几毫秒

00:27:52.973 --> 00:27:54.474 
我们来谈谈HLS

00:27:54.875 --> 00:27:57.744 
我们尝试用HLS来优化
的时间段会更加的长

00:27:57.811 --> 00:28:01.548 
因为它们受网络IO的控制
这比本地文件存储要慢得多

00:28:01.815 --> 00:28:05.219 
所以优化的潜在好处会更加显而易见

00:28:05.652 --> 00:28:07.621 
网络IO能分解成四个部分

00:28:07.688 --> 00:28:11.158 
检索主播放列表 那是你交给
AVURLAsset的URL

00:28:11.225 --> 00:28:13.493 
若内容受到 FairPlay
Streaming的保护

00:28:13.560 --> 00:28:17.431 
检索内容密钥
检索选中的变体播放列表

00:28:17.497 --> 00:28:20.634 
用于视频和音频的合适比特率和格式

00:28:21.001 --> 00:28:22.569 
然后检索一些媒体分段

00:28:22.769 --> 00:28:23.971 
在播放列表中引用过的

00:28:24.238 --> 00:28:27.074 
现媒体分段的实际数据传输量是最多的

00:28:27.207 --> 00:28:29.710 
但在网络IO中
我们要考虑往返延迟

00:28:30.511 --> 00:28:32.079 
其中一些阶段是序列化的

00:28:32.613 --> 00:28:35.215 
你无法从播放列表下载内容

00:28:35.582 --> 00:28:37.251 
直到你得到了播放列表

00:28:38.819 --> 00:28:41.054 
所以要思索的是

00:28:41.421 --> 00:28:44.324 
我们能不能在用户
选择播放之前做这些事？

00:28:46.527 --> 00:28:47.861 
例如 可能在你的应用中

00:28:48.095 --> 00:28:50.664 
当内容先被选择时 显示标题卡片

00:28:51.265 --> 00:28:53.867 
然后这会让用户表明
这个是不是我想播放的内容？

00:28:53.934 --> 00:28:55.435 
或我是否想阅读一些关于它的信息

00:28:55.969 --> 00:28:59.373 
所以问题是我们能不能猜测性地

00:28:59.439 --> 00:29:00.941 
做少量的网络IO

00:29:01.842 --> 00:29:04.678 
当用户识别出他们可能想要播放的内容

00:29:04.745 --> 00:29:05.579 
在确认之前？

00:29:06.713 --> 00:29:09.917 
AVURLAsset是一种懒API

00:29:10.184 --> 00:29:11.885 
它不会开始加载或暂停任何数据

00:29:11.952 --> 00:29:12.953 
直到有人向它要求

00:29:13.520 --> 00:29:15.989 
为了触发从主播放列表进行数据加载

00:29:16.056 --> 00:29:18.559 
我们需要请求它
加载一个会从其中衍生出的值

00:29:18.625 --> 00:29:22.196 
像是时长或是可用的媒体特性

00:29:22.262 --> 00:29:23.363 
外加媒体选择选项

00:29:23.764 --> 00:29:24.932 
时长易于输入

00:29:25.699 --> 00:29:27.601 
你不需要提供完成处理程序 除非

00:29:27.734 --> 00:29:29.303 
你真的要用那个值来做某些事情

00:29:31.138 --> 00:29:33.440 
谈到播放列表 它们易于压缩

00:29:33.507 --> 00:29:36.210 
我们多年支持使用gzip来压缩它们

00:29:36.610 --> 00:29:37.611 
所以一定要这样做

00:29:38.045 --> 00:29:39.880 
这可能只是配置你服务器的事

00:29:41.448 --> 00:29:43.717 
如果你的内容受到
FairPlay Streaming的保护

00:29:43.784 --> 00:29:44.785 
那这里还涉及一个

00:29:44.852 --> 00:29:47.120 
与你的服务器协商内容密钥的往返过程

00:29:47.454 --> 00:29:48.755 
且你可以将其更早地触发

00:29:48.956 --> 00:29:51.725 
通过设置
asset.resourceLoader的

00:29:51.959 --> 00:29:54.127 
preloadsEligibleContentKeys
属性为true

00:29:54.194 --> 00:29:56.196 
为了起作用 主播放列表必须包含

00:29:56.263 --> 00:29:57.497 
会话密钥声明

00:29:59.032 --> 00:30:00.100 
所以现在情况如何？

00:30:00.300 --> 00:30:01.969 
有了这些方法 我们可以开始——

00:30:02.302 --> 00:30:05.172 
它们能将主播放列表
和内容密钥下载下来

00:30:05.472 --> 00:30:06.673 
即使我们还在标题卡上

00:30:06.740 --> 00:30:07.574 
这非常炫酷

00:30:08.041 --> 00:30:10.444 
变体播放列表和数据分段

00:30:10.644 --> 00:30:12.145 
还是会在我们点击播放后加载

00:30:12.613 --> 00:30:13.847 
所以你可能问自己

00:30:14.047 --> 00:30:15.849 
我们能让这种方法更进一步吗？

00:30:17.150 --> 00:30:19.319 
在2016年的新API中有一个叫做

00:30:19.386 --> 00:30:21.355 
preferredForwardBufferDuration

00:30:22.189 --> 00:30:23.991 
设置成低的时长 比如5秒

00:30:24.124 --> 00:30:27.027 
会让AVFoundation缓冲出
其认为你需要的最少内容量

00:30:27.094 --> 00:30:27.961 
来开始播放

00:30:28.629 --> 00:30:31.532 
不过一旦回放开始将覆盖设置回0

00:30:31.698 --> 00:30:34.535 
来让正常缓冲算法重新发挥作用

00:30:37.204 --> 00:30:38.672 
这是一个视频方差的列表

00:30:39.006 --> 00:30:40.340 
可能会出现在主播放列表中

00:30:40.807 --> 00:30:42.643 
在尺寸和比特率上各有不同

00:30:43.143 --> 00:30:46.079 
对于配有快速连接和
大电视的Apple TV来说

00:30:46.146 --> 00:30:47.848 
1080p的变体
可能会是理想

00:30:48.515 --> 00:30:49.850 
对于iPhone SE

00:30:50.884 --> 00:30:52.653 
即使拥有超快的Wi-Fi连接

00:30:52.853 --> 00:30:54.755 
720p变体会是最佳选择

00:30:54.955 --> 00:30:57.591 
这已经比iPhone SE的
屏幕分辨率更大了

00:30:57.824 --> 00:30:59.760 
所以选择更高的不会提升任何品质

00:31:00.627 --> 00:31:03.197 
在巨大的iPad Pro上面
有很多的像素

00:31:03.430 --> 00:31:05.933 
所以我们可以选择
大的变体来全屏显示

00:31:06.266 --> 00:31:07.768 
但如果我们在画中画中播放

00:31:07.835 --> 00:31:09.603 
我们不再需要那么高的分辨率

00:31:10.070 --> 00:31:13.674 
而且更低的比特率变体
可以降低缓存的大小

00:31:13.874 --> 00:31:16.176 
然后帮助我们留出更多
储存空间用于其他应用

00:31:17.277 --> 00:31:19.513 
如果网络连接在所有设备上都很慢

00:31:19.746 --> 00:31:20.914 
那这就会成为限制因素

00:31:21.381 --> 00:31:23.483 
这意味着这AVFoundation

00:31:23.550 --> 00:31:25.519 
需要考虑到显示尺寸

00:31:25.752 --> 00:31:27.821 
以及网络比特率 当选择变体的时候

00:31:28.822 --> 00:31:31.792 
AVFoundation使用屏幕上
AVPlayerLayer的大小

00:31:31.859 --> 00:31:32.893 
来评估尺寸

00:31:33.360 --> 00:31:36.129 
所以将AVPlayerLayer
设置成正确的大小

00:31:36.196 --> 00:31:38.398 
然后尽早连接到AVPlayer上

00:31:38.966 --> 00:31:40.467 
这可以隐藏在其他UI后面

00:31:40.534 --> 00:31:41.869 
如果你还没准备好显示视频

00:31:42.769 --> 00:31:45.272 
在Retina屏幕的iOS设备上
目前有必要将

00:31:45.339 --> 00:31:47.207 
contentsScale
设置成手动

00:31:48.909 --> 00:31:51.812 
对于比特率
AVFoundation在

00:31:51.879 --> 00:31:53.547 
回放第一个开头时会陷于

00:31:53.981 --> 00:31:55.415 
难分先后的情况中

00:31:56.049 --> 00:31:57.351 
它必须选择一些变体

00:31:57.885 --> 00:31:59.987 
但不知道会得到什么样的比特率

00:32:00.921 --> 00:32:02.623 
一旦开始下载分段

00:32:02.723 --> 00:32:04.791 
它可以使用来自那些下载的统计数据

00:32:04.858 --> 00:32:06.059 
来调整变体的选择

00:32:06.593 --> 00:32:07.828 
但对于第一个变体

00:32:08.061 --> 00:32:09.530 
它没有收到任何统计数据

00:32:10.397 --> 00:32:12.599 
所以AVFoundation
的基础算法就是

00:32:12.666 --> 00:32:15.669 
在主播放列表中
选取第一个可适用的变体

00:32:16.036 --> 00:32:17.371 
如果那是低比特率的选项

00:32:17.604 --> 00:32:19.339 
用户开始会看到模糊的内容

00:32:19.706 --> 00:32:22.643 
但AVFoundation会
马上判断出实际的网络比特率是什么

00:32:22.709 --> 00:32:24.111 
然后切换成合适的变体

00:32:25.245 --> 00:32:27.648 
但问题是如果你想尝试

00:32:27.714 --> 00:32:29.416 
提升那个最初选择呢？

00:32:29.950 --> 00:32:33.353 
记住 你要做出权衡

00:32:33.420 --> 00:32:35.589 
在最初品质和启动时间两者之间

00:32:36.223 --> 00:32:39.259 
更高比特率的第一分段需更长时间下载

00:32:39.626 --> 00:32:41.195 
这就意味着开始的时间会更长

00:32:41.695 --> 00:32:45.465 
你可能会决定最好是
从更低比特率的变体开始

00:32:46.099 --> 00:32:47.234 
为了更快开始播放

00:32:48.035 --> 00:32:50.037 
做出权衡的一种方法是弄清楚

00:32:50.103 --> 00:32:52.472 
你想看到的最低可接受的品质等级

00:32:52.739 --> 00:32:55.242 
在特定大小的屏幕上 然后从那里开始

00:32:55.876 --> 00:32:58.345 
之后AVFoundation
切换到更高品质上

00:32:58.645 --> 00:33:01.181 
在回放开始之后 只要网络条件允许

00:33:02.249 --> 00:33:04.918 
可能你知道AVFoundation
不知道的一件事

00:33:05.419 --> 00:33:07.955 
可能你的应用刚播放了不同部分的内容

00:33:08.555 --> 00:33:10.924 
然后也许你可以使用那个回放访问日志

00:33:11.258 --> 00:33:13.060 
来更好地猜测下一个

00:33:13.126 --> 00:33:14.761 
回放站会得到的比特率

00:33:16.630 --> 00:33:18.298 
所以我们假设你得出了一个结论

00:33:18.632 --> 00:33:21.335 
基于启动品质和最近比特率统计数据

00:33:21.768 --> 00:33:23.737 
然后你要决定选择

00:33:23.804 --> 00:33:25.472 
你想以哪一个变体开始

00:33:25.706 --> 00:33:28.308 
如何将那个选择
导入AVFoundation中？

00:33:29.176 --> 00:33:30.711 
这里使用了两种方法

00:33:31.178 --> 00:33:32.045 
这是第一种方法

00:33:32.646 --> 00:33:35.115 
在服务器上
给变体排序

00:33:35.282 --> 00:33:36.483 
从最高到最低

00:33:38.919 --> 00:33:39.753 
就像这样

00:33:40.053 --> 00:33:41.321 
然后在你的应用里

00:33:41.722 --> 00:33:45.425 
你需要设置
playerItem.preferredPeakBitRate

00:33:46.059 --> 00:33:47.194 
为你猜测的比特率

00:33:48.195 --> 00:33:50.464 
这样会使更高的比特率变体

00:33:50.697 --> 00:33:51.832 
从初始选择中淘汰掉

00:33:52.499 --> 00:33:53.800 
回放开始之后不久

00:33:54.034 --> 00:33:56.370 
你应该将那个控制重置为0

00:33:56.703 --> 00:33:59.706 
这能让AVFoundation
提升到更高的比特率变体上

00:33:59.773 --> 00:34:00.641 
只要网络有提升

00:34:02.676 --> 00:34:03.710 
第二个方法

00:34:03.977 --> 00:34:06.547 
是在你的应用里动态改写主播放列表

00:34:06.947 --> 00:34:09.016 
然后把你的优先选择移动到列表顶部

00:34:10.150 --> 00:34:14.588 
为了做到这一点
在AVURLAsset中使用自定义URL方案

00:34:15.722 --> 00:34:19.793 
然后应用AVasset
资源加载器委托协议

00:34:20.226 --> 00:34:23.130 
这样你可以提供改写的播放列表

00:34:23.197 --> 00:34:26.065 
来回应自定义URL方案的加载请求

00:34:27.701 --> 00:34:29.870 
我还想要提醒一下你要分析你的代码

00:34:30.070 --> 00:34:33.005 
在你调用AVFoundation前
看看是否出现任何延迟

00:34:33.072 --> 00:34:36.643 
特别的是 你不需等待
LikelyToKeepUp

00:34:36.710 --> 00:34:39.179 
在设置播放器速率之前
成为true

00:34:39.545 --> 00:34:43.083 
你现在不需要
实际上 对于HLS从来不需要

00:34:44.184 --> 00:34:46.652 
确保你将AVPlayer
和AVPlayerItem

00:34:46.719 --> 00:34:48.021 
从之前的回放会话中释放出来

00:34:48.288 --> 00:34:50.858 
这样它们不会在后台浪费宽带

00:34:50.924 --> 00:34:53.793 
你可以使用Instruments中的
Allocations Instrument

00:34:53.860 --> 00:34:57.264 
来查看AVPlayer和
AVPlayerItem对象的寿命

00:34:58.065 --> 00:35:00.501 
如果你有应用在做其他网络活动

00:35:00.567 --> 00:35:03.504 
考虑一下在网络回放时是否该将其暂停

00:35:03.570 --> 00:35:07.808 
这样用户可充分利用可用宽带进行回放

00:35:09.576 --> 00:35:11.879 
好了 总之

00:35:13.213 --> 00:35:15.382 
自动等待会将卡顿减到最少

00:35:15.816 --> 00:35:17.384 
自动播放 自动等待

00:35:18.318 --> 00:35:19.553 
这默认设置为true

00:35:19.620 --> 00:35:22.789 
如果你的应用使用今年或之后的SDK

00:35:23.357 --> 00:35:25.392 
它提供了统一的缓冲规则

00:35:25.559 --> 00:35:28.362 
用于渐进式下载和HLS回放

00:35:29.963 --> 00:35:32.766 
我们推出一个新的API
叫做AVPlayerLooper

00:35:33.233 --> 00:35:36.970 
使用跑步机模式简化单一项目循环回放

00:35:38.739 --> 00:35:41.742 
在回放期间更改启用的轨道组

00:35:41.808 --> 00:35:44.077 
不会总是引起短暂停顿

00:35:45.312 --> 00:35:47.247 
我们看了看
AVFoundation API

00:35:47.314 --> 00:35:50.184 
你可以用它来让你的应用
为广色域视频做好准备

00:35:51.652 --> 00:35:54.421 
最后 我们谈论了优化回放启动

00:35:54.488 --> 00:35:56.590 
用于本地文件和HLS

00:35:57.124 --> 00:36:00.360 
总之 避免不必要的工作

00:36:01.028 --> 00:36:03.197 
对于你需要做的工作 试着早些去做

00:36:04.598 --> 00:36:07.601 
在这个URL上我们有与
这个会议相关的更多信息

00:36:07.668 --> 00:36:09.636 
包括我们展示的示例代码

00:36:10.637 --> 00:36:13.507 
我们有一些相关会话你可能会想补看

00:36:13.574 --> 00:36:16.076 
可以现场看或者在网上观看

00:36:16.310 --> 00:36:19.479 
最下面的那个是在应用里
只能点播观看的

00:36:20.080 --> 00:36:22.082 
谢谢关注 倍感荣幸

00:36:22.216 --> 00:36:23.450 
希望大家度过愉快的一周