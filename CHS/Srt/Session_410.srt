00:00:19.887 --> 00:00:24.591 
Xcode下可视化调试工具

00:00:29.796 --> 00:00:30.864 
大家下午好

00:00:31.632 --> 00:00:34.201 
欢迎来到
“Xcode下可视化调试工具”演讲

00:00:35.169 --> 00:00:38.172 
我是Chris
在Xcode调试工具UI小组工作

00:00:39.373 --> 00:00:43.210 
众所周知 调试工具存在已久

00:00:44.611 --> 00:00:46.180 
就在不久以前

00:00:46.246 --> 00:00:48.715 
调试工具看上去还是这个样子

00:00:51.418 --> 00:00:53.820 
此后不久 UI进行了改进

00:00:53.887 --> 00:00:56.757 
调试工具开始看上去像这个样子

00:00:59.259 --> 00:01:00.661 
但是快进到今天

00:01:00.727 --> 00:01:03.530 
调试工具变得更加强大

00:01:03.597 --> 00:01:06.066 
同时也更容易操作

00:01:06.567 --> 00:01:09.736 
其中大部分要归功于它变得更为可视化

00:01:09.803 --> 00:01:12.940 
这帮助我们更为快速
更为直观地解决问题

00:01:13.874 --> 00:01:16.076 
今天 我将和同事们一起讲解

00:01:16.143 --> 00:01:18.979 
Xcode中最新的可视化调试工具

00:01:22.583 --> 00:01:24.284 
首先 快速概述一下讲座的内容

00:01:25.219 --> 00:01:27.621 
我们将会讲解Xcode的新功能

00:01:27.688 --> 00:01:31.625 
能报告工具发现的运行时问题

00:01:32.626 --> 00:01:35.229 
我们还将讲解最新的增强功能

00:01:35.295 --> 00:01:37.197 
对Xcode的视图调试工具所作的

00:01:37.264 --> 00:01:40.601 
以及如何把自动布局调试
变得前所未有地简单

00:01:41.735 --> 00:01:44.838 
我们还将讲解一个新功能
可以可视化调试

00:01:44.905 --> 00:01:47.674 
就是状态机 以及做出的增强

00:01:47.741 --> 00:01:51.812 
在FPS性能测量方面
从而更好帮助调试SpriteKit

00:01:51.879 --> 00:01:53.514 
以及SceneKit帧率问题

00:01:54.548 --> 00:01:58.151 
最后 将讲解Xcode的一个新功能

00:01:58.218 --> 00:01:59.820 
可视化内存图形调试工具

00:02:03.857 --> 00:02:05.926 
首先来看问题

00:02:08.862 --> 00:02:12.332 
我们都知道 编译时发生的问题
比如编译器警告 错误

00:02:12.399 --> 00:02:15.469 
和静态分析问题 都已经得到了

00:02:15.536 --> 00:02:20.307 
Xcode用户界面充分支持
和测试时发现的问题相同

00:02:21.408 --> 00:02:24.077 
然而 不能同理可证

00:02:24.144 --> 00:02:27.681 
调试和分析工具的扩展组件
发现的运行时问题

00:02:28.348 --> 00:02:32.452 
这些工具都已经被遗忘

00:02:32.519 --> 00:02:36.757 
最多会被用来在控制台上记录输出结果

00:02:37.124 --> 00:02:38.292 
不是最好的体验

00:02:38.792 --> 00:02:40.561 
我们认为可以做得更好

00:02:42.396 --> 00:02:45.199  
在Xcode 8
我们引进了运行时问题

00:02:52.239 --> 00:02:55.943 
运行时问题
把工具在运行时发现的问题上升

00:02:56.543 --> 00:03:00.514 
和UI里传统编译时问题同等地位

00:03:02.950 --> 00:03:05.619 
活动查看器会如此显示

00:03:05.686 --> 00:03:09.523 
当发现任何运行时问题时
并报告问题数量

00:03:12.025 --> 00:03:15.095 
我们增强了问题浏览器
包含新的运行时范围

00:03:15.362 --> 00:03:17.664 
这区分了运行时问题

00:03:17.731 --> 00:03:19.499 
和传统的编译时问题

00:03:19.566 --> 00:03:22.636 
比如编译器警告 错误和静态分析问题

00:03:26.440 --> 00:03:29.810 
在运行时 会看到什么样的问题呢？

00:03:30.477 --> 00:03:33.013 
在Xcode 8 我们处理三个范围

00:03:33.580 --> 00:03:36.316 
首先 线程问题

00:03:37.017 --> 00:03:38.886 
我们全新的
"Thread Sanitizer线程检查工具"

00:03:38.952 --> 00:03:43.390 
可检测线程问题在应用中 在运行时

00:03:45.692 --> 00:03:46.894 
UI布局问题

00:03:46.994 --> 00:03:49.396 
我们扩展了Xcode的视图调试工具

00:03:49.463 --> 00:03:52.165 
来自动检测模糊的布局问题

00:03:52.232 --> 00:03:53.534 
在应用中 在运行时

00:03:55.903 --> 00:03:56.837 
以及 内存问题

00:03:57.237 --> 00:03:59.139 
全新的内存图形调试工具

00:03:59.206 --> 00:04:01.241 
一会儿我们会详细解释

00:04:01.308 --> 00:04:03.977 
它可以自动检测内存泄漏

00:04:04.044 --> 00:04:05.612 
在应用中 在运行时

00:04:09.783 --> 00:04:11.118 
所以 如你在周一所听到的

00:04:11.185 --> 00:04:13.287 
Xcode最新的运行时的检查工具

00:04:13.353 --> 00:04:14.821 
就是"Thread Sanitizer线程检查工具"

00:04:15.422 --> 00:04:19.892 
"Thread Sanitizer线程检查工具"
帮助我们检测和更好地理解线程问题

00:04:19.959 --> 00:04:21.962 
在应用中 在运行时

00:04:22.629 --> 00:04:25.032 
它可以检测到的问题有 数据竞争

00:04:25.098 --> 00:04:28.368 
使用为初始化的互斥锁
来自错误线程的解锁

00:04:28.836 --> 00:04:31.471 
线程泄漏及信号处理器的不安全调用等

00:04:32.172 --> 00:04:36.176 
发现以上任何一种问题
都会被报告为运行时问题

00:04:37.244 --> 00:04:40.180 
"Thread Sanitizer线程检查工具"
是一个强大的全新的运行时分析工具

00:04:40.247 --> 00:04:43.083 
为了更充分地理解它可以观看
关于"Thread Sanitizer线程检查工具"

00:04:43.150 --> 00:04:44.551 
以及静态分析演讲

00:04:50.591 --> 00:04:52.559 
视图调试是一个非常优秀的范例

00:04:52.626 --> 00:04:55.495 
在Xcode的调试工具中
变得越来越可视化

00:04:56.063 --> 00:05:00.901 
仅仅在过去几年 关于UI调试问题

00:05:00.968 --> 00:05:04.071 
我们从必须要读取调试输出

00:05:04.137 --> 00:05:07.407 
到一个像这样的工具台 变成这样

00:05:08.008 --> 00:05:11.245 
Xcode的可视化视图调试工具
有非常好的用户体验

00:05:11.445 --> 00:05:14.414 
对于调试和理解可视化UI问题

00:05:15.449 --> 00:05:16.783 
如果你还从未使用过

00:05:17.484 --> 00:05:19.319 
当应用在运行Xcode时

00:05:20.053 --> 00:05:24.291 
只需点击调试工具条下方的
“调试视图层次结构”按钮

00:05:25.526 --> 00:05:27.594 
Xcode将会快照你的应用

00:05:28.529 --> 00:05:29.930 
快照你的视图层次结构

00:05:29.997 --> 00:05:32.766 
把它在一可互动的3D场景里分解出来

00:05:33.600 --> 00:05:38.071 
在那里
你可以在3D画布里检查视图层次结构

00:05:38.672 --> 00:05:40.541 
还可以在分级视图里

00:05:40.774 --> 00:05:44.545 
你可以检查所有视图和限制的属性

00:05:44.611 --> 00:05:45.846 
利用检查器

00:05:48.916 --> 00:05:52.386 
在Xcode 8
我们让视图调试——

00:05:53.554 --> 00:05:54.988 
你猜？比过去任何时候都更好

00:06:02.963 --> 00:06:05.365 
快照现在比过去快了近70％

00:06:05.432 --> 00:06:07.201 
所以你可以从运行应用

00:06:07.267 --> 00:06:09.570 
切换到调试UI问题 前所未有的快

00:06:15.542 --> 00:06:17.110 
渲染复杂布局

00:06:17.177 --> 00:06:20.581 
和转换视图在Xcode 8里更准确

00:06:20.681 --> 00:06:24.184 
谈到准确
Xcode现可渲染模糊视图

00:06:24.251 --> 00:06:26.987 
比如画布上带高保真视觉效果的视图

00:06:27.621 --> 00:06:30.357 
因此在Xcode的
视图调试工具所见到的

00:06:30.424 --> 00:06:32.459 
更为准确地反应了在设备上所见到的

00:06:33.026 --> 00:06:35.429 
在beta 2
将会看到改进的模糊渲染

00:06:36.930 --> 00:06:39.132 
我们添加了便利性 比如可以直接跳转

00:06:39.199 --> 00:06:41.101 
从视图类到源代码

00:06:41.168 --> 00:06:43.904 
只需在对象检查器上点击跳转按钮

00:06:45.706 --> 00:06:48.442 
浏览过滤也变得更为强大了

00:06:48.842 --> 00:06:53.514 
可以通过任何标签上的文本
或按钮标题上的文本进行过滤

00:06:54.448 --> 00:06:58.719 
或者你可以通过类名进行过滤
也包括超类名

00:06:58.852 --> 00:07:02.656 
比如 如果通过UI标签进行过滤
将会返回

00:07:02.723 --> 00:07:05.559 
所有视图层次结构中
该UI标签的所有子类

00:07:06.193 --> 00:07:07.895 
甚至可以通过内存地址进行过滤

00:07:08.061 --> 00:07:10.230 
这样可以迅速找到特定的视图

00:07:10.297 --> 00:07:11.999 
只需知道其内存地址

00:07:17.171 --> 00:07:20.240 
自动布局调试也进步显著

00:07:20.741 --> 00:07:24.378 
检查器可以显示更多
和自动布局相关的属性

00:07:25.045 --> 00:07:27.915 
限制在画布上表现得更好

00:07:28.582 --> 00:07:30.484 
我们用标记渲染限制

00:07:30.551 --> 00:07:33.654 
来代表不平等或长宽比关系

00:07:33.987 --> 00:07:37.057 
我们还用虚线渲染非必须限制

00:07:37.124 --> 00:07:39.393 
所以你可以很容易分辨

00:07:39.459 --> 00:07:41.562 
画布上的必须限制和非必须限制

00:07:42.696 --> 00:07:45.399 
但是我最欣赏的自动布局调试的新功能

00:07:45.465 --> 00:07:47.601 
是它结合了运行时问题

00:07:49.436 --> 00:07:52.773 
Xcode现可自动检测模糊布局问题

00:07:52.840 --> 00:07:55.142 
在视图层次结构里 在运行时

00:08:01.648 --> 00:08:02.816 
它是怎么运作的？

00:08:03.150 --> 00:08:04.885 
当快照视图层次结构时

00:08:04.952 --> 00:08:09.223 
Xcode将会检查每一个视图
并将准确决定

00:08:09.289 --> 00:08:11.758 
其中任何一个视图是否存在模糊布局

00:08:11.825 --> 00:08:13.760 
以及模糊原因

00:08:14.595 --> 00:08:20.434 
如果检测到任何布局问题
将会作为运行时问题报告

00:08:21.134 --> 00:08:23.270 
所以可以看见它们显示在活动查看器里

00:08:23.604 --> 00:08:26.507 
还可以看见它们在运行时
被列在问题浏览器里

00:08:28.075 --> 00:08:31.645 
此外 视图层次结构一览将会标记

00:08:31.712 --> 00:08:34.847 
任何有布局问题的视图
因此可以轻易找到它们

00:08:34.914 --> 00:08:37.150 
在整个布局层次结构下

00:08:39.318 --> 00:08:42.956 
对于一个选中的视图
尺寸检查器将会包含

00:08:43.023 --> 00:08:46.326 
任何布局问题的细节 以及所有

00:08:46.393 --> 00:08:48.529 
参与该视图布局的限制

00:08:49.830 --> 00:08:51.999 
我们对Xcode新功能感到十分激动

00:08:52.065 --> 00:08:54.902 
它可以在运行时自动检测模糊布局问题

00:08:55.202 --> 00:08:56.603 
我想为你们做一个演示

00:08:59.273 --> 00:09:02.442 
我有一个iPhone连在Mac上

00:09:02.743 --> 00:09:05.946 
Xcode已经启动
正运行一个叫DemoBots的项目

00:09:06.013 --> 00:09:10.484 
这是我们今年更新Swift 3中的
示例代码项目之一

00:09:11.385 --> 00:09:13.287 
在右边 我正使用
QuickTime Player

00:09:13.353 --> 00:09:16.290 
把手机屏幕映射在桌面上
大家才都可以看见

00:09:17.024 --> 00:09:20.027 
我们的团队的任务是
把一个游戏指导说明书

00:09:20.093 --> 00:09:22.629 
添加到DemoBots
所以做了一个“如何开始游戏”界面

00:09:23.197 --> 00:09:26.300 
然而 在演讲前我们发现了一些问题

00:09:26.400 --> 00:09:28.869 
现在是调试这些问题的好机会

00:09:29.603 --> 00:09:30.637 
点击“如何开始游戏”

00:09:30.971 --> 00:09:32.406 
这就是“如何开始游戏”界面

00:09:32.806 --> 00:09:33.740 
不怎么样是吧？

00:09:34.374 --> 00:09:36.577 
显然 存在一些问题 来看一下

00:09:36.643 --> 00:09:39.146 
可以看到DemoBots图标在后面

00:09:39.213 --> 00:09:41.615 
上方有一些错位的文本

00:09:41.982 --> 00:09:44.284 
我们需要来调试 从哪儿开始？

00:09:45.118 --> 00:09:46.420 
给你们一点提示

00:09:46.920 --> 00:09:50.023 
DemoBots是一款用
SpriteKit编写的街机小游戏

00:09:50.090 --> 00:09:53.093 
但该屏幕是
用UIKit和自动布局产生的

00:09:53.660 --> 00:09:55.929 
所以最好的开始的地方是在

00:09:55.996 --> 00:09:59.867 
在视图层次和布局结构上

00:09:59.933 --> 00:10:01.034 
我们一起来操作

00:10:01.835 --> 00:10:03.136 
回到Xcode

00:10:04.571 --> 00:10:05.539 
最底部

00:10:06.206 --> 00:10:08.342 
找到“调试视图层次”按钮

00:10:09.610 --> 00:10:10.711 
点击

00:10:10.777 --> 00:10:14.047 
它将暂停应用 快照整个视图结构

00:10:14.948 --> 00:10:15.816 
在编辑器里

00:10:16.350 --> 00:10:19.853 
我们返回了刚才屏幕上所见的准确表达

00:10:20.721 --> 00:10:22.956 
为了查看内部结构

00:10:23.023 --> 00:10:24.892 
我们只需把它拖进画布

00:10:24.958 --> 00:10:28.495 
把完整的视图结构开拓成3D视图

00:10:33.867 --> 00:10:37.204 
在这里 可看到构成该屏幕的所有视图

00:10:37.271 --> 00:10:38.539 
后面的视窗

00:10:38.672 --> 00:10:40.707 
容器视图 视觉效果视图

00:10:40.774 --> 00:10:43.644 
及构成“如何开始游戏”说明书的视图

00:10:43.944 --> 00:10:45.112 
放大看一下

00:10:45.579 --> 00:10:47.481 
我们看到DemoBots图标在后面

00:10:47.548 --> 00:10:49.383 
还有很多标签和图像

00:10:49.716 --> 00:10:53.086 
我们迅速可以了解 通过旋转

00:10:53.153 --> 00:10:55.055 
找出屏幕上的一团乱的原因

00:10:55.322 --> 00:10:57.925 
所有这些视图都彼此叠加

00:10:58.225 --> 00:10:59.526 
所以我们的布局有问题

00:11:00.127 --> 00:11:02.629 
传统的工作流程是

00:11:02.696 --> 00:11:04.565 
检测每一个视图及其限制

00:11:04.631 --> 00:11:07.034 
然后试着确定产生布局问题的原因

00:11:07.367 --> 00:11:10.304 
但在Xcode 8
我们有一些额外的可用信息

00:11:10.871 --> 00:11:13.874 
注意上方的活动查看器Xcode报告

00:11:13.941 --> 00:11:15.676 
我们有运行时问题

00:11:16.577 --> 00:11:18.545 
可以点击它

00:11:18.779 --> 00:11:21.481 
将会打开问题浏览器

00:11:21.982 --> 00:11:24.952 
但你可能也注意到了左边这里

00:11:25.018 --> 00:11:26.553 
在调试浏览器里

00:11:27.487 --> 00:11:29.423 
Xcode标记出一些视图

00:11:29.690 --> 00:11:31.859 
它告诉我们 这些视图有布局问题

00:11:31.925 --> 00:11:33.227 
直接来看这里

00:11:34.228 --> 00:11:35.662 
如果选中第一个视图

00:11:36.263 --> 00:11:38.365 
画布中高亮显示

00:11:38.665 --> 00:11:41.735 
然后打开该视图的尺寸检查器
右边这里

00:11:42.970 --> 00:11:46.139 
在这里 我们可以在限制中
找出布局问题的原因

00:11:46.507 --> 00:11:49.343 
该视图有一个模糊垂直位置

00:11:50.077 --> 00:11:52.579 
也就是说自动布局没有足够的信息

00:11:52.646 --> 00:11:56.083 
在垂直维度明确定位该视图

00:11:56.984 --> 00:11:58.685 
很典型 限制缺失

00:12:00.354 --> 00:12:01.722 
来看下一个视图

00:12:02.256 --> 00:12:04.658 
有着一样的问题 垂直位置模糊

00:12:05.292 --> 00:12:06.827 
下一个视图也是

00:12:06.894 --> 00:12:08.095 
若我随机点击一些别的

00:12:08.161 --> 00:12:09.796 
似乎它们都有同样的问题

00:12:10.264 --> 00:12:13.467 
我很好奇 这个列表的第一个子视图

00:12:13.934 --> 00:12:15.135 
并没被标记显示有问题

00:12:15.202 --> 00:12:17.304 
可能是查看布局代码时的一个线索

00:12:17.905 --> 00:12:18.972 
现在我们来看一下

00:12:19.239 --> 00:12:20.674 
如果选中父视图

00:12:21.241 --> 00:12:23.710 
类名是
InstructionsLayoutView

00:12:23.777 --> 00:12:26.713 
这就是负责显示
“如何开始游戏”屏幕的视图

00:12:27.581 --> 00:12:29.383 
来看看它的源代码

00:12:29.917 --> 00:12:32.686 
一种简单的方法就是选中视图

00:12:32.753 --> 00:12:34.021 
右边这里

00:12:34.087 --> 00:12:36.290 
可以找到 对象检查器

00:12:36.657 --> 00:12:39.927 
该按钮可以直接跳转到视图源代码

00:12:40.627 --> 00:12:41.728 
如此操作

00:12:41.795 --> 00:12:43.797 
关上检查器 多留出一点空间

00:12:44.031 --> 00:12:46.667 
我们来看看
InstructionsLayoutView的源代码

00:12:48.202 --> 00:12:50.838 
首先开始循环

00:12:50.904 --> 00:12:53.140 
说明书的每一个部分 都是模块对象

00:12:53.207 --> 00:12:57.678 
描述了页眉部分 段落部分 和图片

00:12:58.212 --> 00:13:00.914 
代码把它们从上到下显示

00:13:01.582 --> 00:13:04.785 
对于每一个部分 修复视图
把它添加到视图层次结构

00:13:05.152 --> 00:13:07.354 
然后是水平布局的源代码

00:13:07.487 --> 00:13:09.323 
但在水平布局中没有发现任何问题

00:13:09.389 --> 00:13:11.525 
所以略过此处 到垂直布局

00:13:12.526 --> 00:13:14.228 
这里 有两条通路

00:13:14.595 --> 00:13:17.130 
第一条是 对于第一个子视图

00:13:17.197 --> 00:13:18.198 
把它限制到容器顶端

00:13:18.866 --> 00:13:22.569 
我们已经注意到 第一个子视图

00:13:22.636 --> 00:13:23.871 
并未报告含有任何问题

00:13:24.071 --> 00:13:26.406 
所以 该限制我们认为是设置正确的

00:13:26.473 --> 00:13:28.642 
来看看条件的另一面

00:13:29.510 --> 00:13:32.713 
这里 查找可选的
previousPartView

00:13:32.779 --> 00:13:36.016 
如果找到了
就把它指定给上面的局部变量

00:13:36.383 --> 00:13:39.620 
然后可把每个视图限制到它上面的视图

00:13:40.020 --> 00:13:41.855 
看上去这就是缺失的限制

00:13:42.389 --> 00:13:46.760 
让我们来看看为什么该条件不为真

00:13:47.461 --> 00:13:50.864 
选中previousPartView
我们从它开始

00:13:50.931 --> 00:13:55.335 
我将使用Command-A选中
Command-F跳出搜索栏

00:13:56.069 --> 00:13:57.771 
检查该变量的实例

00:13:58.272 --> 00:13:59.907 
可以看到其在顶端被定义

00:14:00.107 --> 00:14:02.409 
它被指定为nil 在for循环之前

00:14:02.843 --> 00:14:04.211 
在下方这里也检查

00:14:04.645 --> 00:14:06.747 
在外循环外又检查一次

00:14:06.813 --> 00:14:08.615 
来处理底部限制

00:14:08.682 --> 00:14:10.717 
但看上去我们从未指定给它

00:14:10.918 --> 00:14:12.219 
快速修复一下

00:14:13.053 --> 00:14:15.422 
在循环结尾 我们可把
previousPartView

00:14:16.023 --> 00:14:17.257 
设定给当前的partView

00:14:17.624 --> 00:14:21.028 
然后在每一个循环中
前一个视图都可用

00:14:21.094 --> 00:14:23.497 
都将指定给上面的视图

00:14:23.564 --> 00:14:26.567 
我们将从视图到其上面的视图
之间建立一个限制

00:14:27.234 --> 00:14:29.169 
停止 重新运行 看看结果

00:14:29.903 --> 00:14:31.305 
我把QuickTime移到前面

00:14:32.105 --> 00:14:34.241 
请注意Xcode能给提供多少信息

00:14:34.308 --> 00:14:36.510 
甚至在看到代码之前

00:14:36.977 --> 00:14:39.279 
{\an2用视图调试器查看结构内部

00:14:39.346 --> 00:14:40.881 
看看有什么问题

00:14:41.181 --> 00:14:43.350 
更重要的 Xcode会主动告诉我们

00:14:43.417 --> 00:14:46.486 
应用里的某些布局问题

00:14:46.787 --> 00:14:50.190 
哪个视图有问题 尤其是什么样的问题

00:14:50.457 --> 00:14:53.093 
这在我们查看代码之前就有了很多信息

00:14:53.160 --> 00:14:56.463 
因此我们可以迅速锁定
需要查看的代码部分

00:14:57.698 --> 00:15:00.033 
现在应用正在运行
点击“如何开始游戏”

00:15:01.034 --> 00:15:02.236 
看上去好多了

00:15:02.302 --> 00:15:03.971 
我们有了一个美观的说明页面

00:15:11.211 --> 00:15:16.083 
现在Xcode可以报告运行时错误

00:15:16.149 --> 00:15:19.253 
采用和检测编译时问题时一样的UI

00:15:20.587 --> 00:15:23.423 
今年 Xcode的视图调试器
也有了显著的改进

00:15:23.790 --> 00:15:27.494 
包括更为迅速的快照和更为准确的渲染

00:15:27.561 --> 00:15:30.297 
在复杂布局和模糊视图方面

00:15:31.598 --> 00:15:34.401 
在自动调试方面也有了显著的改进

00:15:34.468 --> 00:15:36.370 
尤其是 Xcode现在可以

00:15:36.436 --> 00:15:40.040 
在运行时自动检测模糊布局问题

00:15:40.674 --> 00:15:43.043 
Xcode的视图调试器支持各种UI

00:15:43.110 --> 00:15:45.679 
在Mac OS iOS和tvOS上

00:15:46.146 --> 00:15:47.247 
在你的项目中试一下

00:15:47.314 --> 00:15:50.918 
我们很乐意得到反馈
关于它如何在调试流程中给你带来帮助

00:15:53.120 --> 00:15:54.855 
下面 我想把讲台让给Tyler

00:15:54.922 --> 00:15:58.659 
他将为我们讲解
调试状态机和帧速率问题

00:15:58.926 --> 00:15:59.760 
谢谢大家

00:16:04.865 --> 00:16:05.799 
谢谢Chris

00:16:06.500 --> 00:16:09.336 
今天 我将为大家演示
一种增强调试体验的新方法

00:16:09.403 --> 00:16:10.771 
利用状态机快速查看

00:16:10.838 --> 00:16:14.274 
及Xcode 8中FPS性能检测的
内部机理

00:16:15.909 --> 00:16:17.444 
今天有很多有用的快速查看

00:16:17.511 --> 00:16:19.580 
已经在Xcode 7里可用

00:16:19.847 --> 00:16:23.183 
这些为你提供了
实时查看各种对象的可能

00:16:23.250 --> 00:16:24.318 
在调试过程中

00:16:24.718 --> 00:16:27.020 
你甚至可以自定义快速查看

00:16:27.087 --> 00:16:28.889 
来检查应用内部对象

00:16:29.656 --> 00:16:30.991 
现在在Xcode 8

00:16:31.058 --> 00:16:34.294 
我们扩展了内置的快速查看
包含了状态机

00:16:35.195 --> 00:16:37.397 
首先我们来看状态机到底是什么

00:16:37.464 --> 00:16:39.066 
以及如何在应用内部使用

00:16:41.168 --> 00:16:43.737 
你们当中一定有很多人已对
GKStateMachine很熟悉

00:16:43.804 --> 00:16:46.139 
去年它是
GameplayKit的一部分

00:16:46.206 --> 00:16:49.376 
可用于
Mac OS iOS和tvOS

00:16:50.277 --> 00:16:53.146 
状态机允许你更为简单地定义复杂行为

00:16:53.213 --> 00:16:55.382 
通过把它构建成为一个有向图

00:16:55.816 --> 00:16:57.017 
在状态机内

00:16:57.084 --> 00:16:59.486 
你为每一个状态提供一个离散行为

00:17:00.220 --> 00:17:02.723 
可以像播放一个动画这么简单

00:17:02.789 --> 00:17:05.459 
或者更复杂的 比如一个AI

00:17:06.460 --> 00:17:08.929 
然后对每一个状态定义条件

00:17:08.996 --> 00:17:12.266 
状态机可以据此
从一个状态转换到另一个状态

00:17:13.834 --> 00:17:17.637 
组装完成后
状态机可以产生极其复杂的行为

00:17:17.704 --> 00:17:21.308 
然而 在代码里它们也会变得很难辨识

00:17:21.375 --> 00:17:22.943 
由于它们复杂度的增加

00:17:23.377 --> 00:17:26.914 
简单的状态机可以迅速进化得更为详细

00:17:28.615 --> 00:17:31.118 
在Xcode 7.3
对调试状态机的支持

00:17:31.185 --> 00:17:34.087 
只局限在当前状态和它的转换

00:17:34.454 --> 00:17:36.156 
而现在在Xcode 8

00:17:36.223 --> 00:17:38.725 
我们可以可视化完整的状态机

00:17:38.792 --> 00:17:40.594 
因此可以一目了然当前状态

00:17:41.728 --> 00:17:43.764 
这非常有用 不论你正在

00:17:43.830 --> 00:17:46.767 
操作简单的状态机 还是你在操作

00:17:46.834 --> 00:17:49.469 
更为复杂的状态机

00:17:50.003 --> 00:17:53.207 
利用快速查看
你可以迅速调试潜在问题

00:17:53.273 --> 00:17:56.343 
并且准确评估状态机的当前情况

00:17:59.246 --> 00:18:01.582 
现在我们把焦点转到性能

00:18:02.282 --> 00:18:04.751 
任何时候新建任何形式的
游戏或视觉应用

00:18:04.885 --> 00:18:06.620 
保证良好性能都是关键

00:18:06.987 --> 00:18:09.690 
在Xcode 8
我们扩大了FPS性能测量

00:18:09.756 --> 00:18:10.824 
在这方面进行帮助

00:18:12.526 --> 00:18:14.027 
你们当中很多人应该已很熟悉

00:18:14.094 --> 00:18:16.530 
Xcode 7的FPS性能测量

00:18:16.830 --> 00:18:18.632 
在报告一开始

00:18:18.699 --> 00:18:20.667 
可以看到实时状态的数据

00:18:21.535 --> 00:18:22.703 
这包括了帧速率

00:18:22.769 --> 00:18:25.172 
即当前每秒被渲染的帧数

00:18:26.006 --> 00:18:27.541 
以及GPU利用率

00:18:27.608 --> 00:18:30.143 
可以看到哪部分的GPU利用率最高

00:18:30.611 --> 00:18:33.580 
以及CPU和GPU的帧时间

00:18:34.147 --> 00:18:37.818 
可以帮助表明
是CPU绑定还是GPU绑定

00:18:39.953 --> 00:18:41.922 
现在 除了实时数据

00:18:41.989 --> 00:18:44.791 
Xcode 8还提供了时间线历史

00:18:44.858 --> 00:18:47.261 
SpriteKit和
SceneKit帧时间

00:18:47.327 --> 00:18:49.129 
为CPU和GPU两者

00:18:49.563 --> 00:18:51.665 
在iOS和watchOS都可用

00:18:52.165 --> 00:18:55.135 
这里很棒的一点是
我们分解了CPU的帧时间

00:18:55.202 --> 00:18:56.904 
以及CPU的各个部分

00:18:56.970 --> 00:18:58.572 
所以可很清楚地看到有多少时间

00:18:58.639 --> 00:19:01.141 
用于渲染 或运行更新循环

00:19:01.208 --> 00:19:04.611 
评估行动和物理
甚至多少时间是空闲的

00:19:06.046 --> 00:19:07.548 
当应用暂停时

00:19:07.614 --> 00:19:10.284 
可以滚动查看所有性能历史

00:19:10.350 --> 00:19:12.953 
就可看到它随着应用的运行如何变化

00:19:13.854 --> 00:19:16.123 
如果有某一个特别感兴趣的地方

00:19:16.190 --> 00:19:19.293 
你可以深入检查更多的细节

00:19:19.660 --> 00:19:21.495 
查看确切时间点

00:19:23.864 --> 00:19:26.300 
来看一下如何在应用里应用

00:19:43.116 --> 00:19:45.853 
我们找到了布局问题

00:19:45.953 --> 00:19:48.989 
在“如何开始游戏”菜单
点进游戏本身

00:19:51.058 --> 00:19:54.294 
这个游戏的目标是
把所有的损坏的机器人

00:19:54.361 --> 00:19:56.463 
变成好的机器人

00:19:57.064 --> 00:19:59.466 
要达成目标 我有一道光束 射向它们

00:19:59.533 --> 00:20:01.768 
就可以把它们重置为好机器人

00:20:02.202 --> 00:20:05.339 
我们看到这里有一个坏机器人在追我

00:20:05.405 --> 00:20:07.374 
我用光束射向它

00:20:11.578 --> 00:20:14.715 
可看到它变成好机器人了 显示为绿色

00:20:15.415 --> 00:20:18.218 
但是我看到还有光束

00:20:18.285 --> 00:20:20.654 
显示在机器人上面 不该有这样的情况

00:20:21.388 --> 00:20:24.892 
既然我们用状态机来管理光束行为

00:20:25.225 --> 00:20:26.627 
这是一个很好的对象

00:20:26.693 --> 00:20:29.796 
来使用状态机快速查看这里是怎么回事

00:20:31.365 --> 00:20:35.169 
我将会暂停应用
浏览BeamComponent

00:20:36.203 --> 00:20:39.473 
我们用BeamComponent
来新建和更新

00:20:39.540 --> 00:20:41.608 
管理光束行为的状态机

00:20:41.975 --> 00:20:44.178 
在更新循环里添加一个断点

00:20:44.244 --> 00:20:47.080 
继续游戏 马上进入断点

00:20:48.081 --> 00:20:50.450 
因为应用已经暂停 可以进入调试区

00:20:50.517 --> 00:20:52.553 
找到状态机的实例

00:20:52.953 --> 00:20:54.087 
快速查看它

00:20:55.088 --> 00:20:57.424 
在这里 我们看到整个状态机

00:20:58.058 --> 00:21:01.895 
蓝色是当前所处状态
即BeamFiringState

00:21:01.962 --> 00:21:04.264 
灰色是所有

00:21:04.331 --> 00:21:05.866 
组成状态机的其余状态

00:21:06.767 --> 00:21:09.403 
我们还可以看到每个状态之间的转换

00:21:09.570 --> 00:21:12.773 
我立即注意到的是有很多转换条件

00:21:12.840 --> 00:21:16.143 
指向BeamFiringState
但没有转换指出去

00:21:16.810 --> 00:21:18.745 
也就是说 一旦进入到开火模式

00:21:18.812 --> 00:21:20.080 
就没办法离开

00:21:20.681 --> 00:21:22.716 
来检查
BeamFiringState

00:21:22.783 --> 00:21:24.051 
看到底是怎么回事

00:21:24.918 --> 00:21:27.754 
删除断点 关闭调试区

00:21:27.821 --> 00:21:29.423 
切换到
BeamFiringState

00:21:31.491 --> 00:21:33.126 
现在来看更新循环

00:21:33.193 --> 00:21:36.096 
这里可以看到有一些转换逻辑

00:21:36.163 --> 00:21:38.599 
既指向CoolingState
又指向IdleState

00:21:39.466 --> 00:21:40.667 
但在下面的方法里

00:21:40.734 --> 00:21:44.304 
检查我们要转换的状态是否有效

00:21:44.371 --> 00:21:45.806 
总是返回假

00:21:45.873 --> 00:21:47.908 
这是不正确的 因为我们想要转换到

00:21:47.975 --> 00:21:49.176 
冷却状态或者空闲状态

00:21:50.177 --> 00:21:51.712 
现在修复该问题

00:21:51.778 --> 00:21:53.714 
通过检查想要转换到的状态

00:21:53.780 --> 00:21:55.415 
是否是两个有效的状态之一

00:21:55.816 --> 00:21:57.217 
回到游戏当中

00:21:57.284 --> 00:21:59.553 
检查这是否是我们看到的问题

00:22:00.754 --> 00:22:04.625 
当我们转换到FiringState
满足条件退出时

00:22:04.691 --> 00:22:07.828 
我们应该可转换回IdleState

00:22:09.830 --> 00:22:10.931 
进入游戏

00:22:10.998 --> 00:22:14.301 
向坏机器人开火

00:22:14.368 --> 00:22:15.736 
把它变为好机器人

00:22:16.036 --> 00:22:20.073 
可以看到光束已经不在游戏者头上了

00:22:20.140 --> 00:22:21.775 
看来问题已经解决了

00:22:23.076 --> 00:22:25.679 
我们还发现了游戏存在性能问题

00:22:26.013 --> 00:22:28.682 
底部有很多地面机器人

00:22:28.749 --> 00:22:31.018 
我发现如果游戏者被机器人袭击

00:22:31.084 --> 00:22:33.020 
性能会急剧下降

00:22:33.987 --> 00:22:35.756 
我将切换到FPS性能测量

00:22:35.822 --> 00:22:39.059 
这样就可以在运行时实时看到性能数据

00:22:39.693 --> 00:22:42.963 
可以看到在这里 显示的是目标帧时间

00:22:43.263 --> 00:22:45.966 
本例中 是16.6毫秒

00:22:46.133 --> 00:22:49.303 
也就是保持每秒60帧的帧速率

00:22:50.838 --> 00:22:53.674 
可以看到一部分时间被用在渲染的时间

00:22:53.740 --> 00:22:55.442 
以及用在运行客户更新的时间

00:22:55.776 --> 00:22:58.512 
还有CPU空闲时间的回旋余地

00:22:59.947 --> 00:23:02.115 
回到游戏 移到右边

00:23:02.182 --> 00:23:04.852 
有一个敌人机器人 我会让它袭击我

00:23:04.918 --> 00:23:07.221 
试着重现性能问题

00:23:08.088 --> 00:23:09.857 
现在切换回性能测量

00:23:09.923 --> 00:23:11.725 
看看更新循环里是怎么回事

00:23:12.326 --> 00:23:15.395 
我发现很长一段时间被用于评估操作上

00:23:15.462 --> 00:23:18.131 
事实上 现在帧速率大幅下降

00:23:18.899 --> 00:23:20.367 
暂停应用

00:23:20.434 --> 00:23:22.703 
来看看其中的问题所在

00:23:23.837 --> 00:23:26.306 
既然已经暂停 我可以及时滚动

00:23:26.373 --> 00:23:27.808 
回到帧分解

00:23:27.875 --> 00:23:30.244 
看看应用里之前的帧时间

00:23:30.711 --> 00:23:33.313 
可以看到在主菜单

00:23:33.380 --> 00:23:35.115 
只有小部分时间用于渲染

00:23:35.182 --> 00:23:36.583 
大部分时间都在空闲

00:23:36.950 --> 00:23:39.219 
游戏中的分解部分也是如此

00:23:39.586 --> 00:23:41.655 
我们已经找出了性能问题

00:23:41.722 --> 00:23:44.424 
可以点击 然后按住来查看细节

00:23:44.491 --> 00:23:46.727 
对于我们发现的性能问题

00:23:47.227 --> 00:23:51.665 
在这里 我看到帧时间是36.2毫秒

00:23:51.732 --> 00:23:54.902 
71%都用于评估操作

00:23:55.802 --> 00:23:59.039 
也就是说在游戏中
可能存在一个或两个问题

00:23:59.473 --> 00:24:01.241 
我们可能在场景中有一个操作

00:24:01.308 --> 00:24:04.444 
占用了非常长的时间来评估

00:24:04.845 --> 00:24:08.215 
或者 可能会有很多操作
造成更新循环产生瓶颈

00:24:08.916 --> 00:24:12.386 
现在已经知道更新循环里哪里有问题

00:24:16.056 --> 00:24:18.225 
我们知道该如何利用状态机快速查看

00:24:18.292 --> 00:24:20.627 
来调试游戏中碰到的问题

00:24:20.994 --> 00:24:23.130 
以及FPS性能测量如何显示

00:24:23.197 --> 00:24:25.866 
更新循环的具体哪里出了问题

00:24:26.800 --> 00:24:28.602 
现邀请Daniel Delwood

00:24:28.669 --> 00:24:30.838 
上台为大家讲解全新的内存图形调试器

00:24:30.904 --> 00:24:32.439 
我们用来确定

00:24:32.506 --> 00:24:35.642 
操作问题从哪里产生
然后可以对其进行修复

00:24:43.350 --> 00:24:44.284 
谢谢你 Tyler

00:24:44.985 --> 00:24:46.086 
我很激动能够为大家讲解

00:24:46.153 --> 00:24:48.722 
Xcode 8里
全新的内存图形调试器

00:24:48.789 --> 00:24:51.391 
我很喜欢视图调试器

00:24:51.625 --> 00:24:53.961 
它是可以更好理解应用的工具

00:24:54.127 --> 00:24:57.464 
如同视图调试器了解视图层次结构

00:24:57.531 --> 00:25:00.367 
内存图形调试器可以帮助了解内存

00:25:00.434 --> 00:25:02.069 
以及内存之间如何互相引用

00:25:02.469 --> 00:25:06.073 
它想回答的一个核心问题是

00:25:06.340 --> 00:25:09.076 
为什么某些对象还存在于堆里？

00:25:10.010 --> 00:25:12.179 
对象互相引用

00:25:12.246 --> 00:25:16.583 
你知道 现在引用

00:25:16.650 --> 00:25:19.920 
和注释已经成为
自动引用指南世界的重要问题

00:25:20.721 --> 00:25:24.791 
我们该如何解决存在

00:25:24.858 --> 00:25:27.528 
不需要的对象 泄漏的对象
或遗弃的对象的问题

00:25:28.195 --> 00:25:31.398 
有一些命令行工具 比如Heap

00:25:32.065 --> 00:25:35.135 
Heap将快照你的进程

00:25:35.202 --> 00:25:37.804 
遍历检查 找出不同类型的摘要

00:25:37.871 --> 00:25:41.108 
以及进程中对象数量

00:25:41.175 --> 00:25:45.579 
你甚至可以使用“地址”标记
来寻找特定类型的对象

00:25:45.646 --> 00:25:47.748 
获取实例列表

00:25:48.315 --> 00:25:50.684 
一旦对某个实例感兴趣

00:25:51.185 --> 00:25:54.188 
可以用leaks中
寻找关于连接问题的信息

00:25:54.254 --> 00:25:56.423 
是否未被引用？是否存在泄漏？

00:25:56.790 --> 00:25:59.860 
是不是从全局位置有一条通路

00:25:59.927 --> 00:26:03.830 
在应用中一直指向该对象？

00:26:05.065 --> 00:26:08.802 
在任何此类调查时
你都可能需要进一步的细节

00:26:08.869 --> 00:26:10.504 
比如栈分配追踪

00:26:10.804 --> 00:26:12.372 
可以用
malloc_history获得

00:26:12.906 --> 00:26:15.442 
而这些都不是可视化体验

00:26:15.509 --> 00:26:18.579 
这就是我们为何要把这三个工具集成到

00:26:18.645 --> 00:26:20.280 
内存图形调试器的IDE

00:26:20.681 --> 00:26:24.218 
快速浏览一下它的构成

00:26:24.484 --> 00:26:27.921 
左边 浏览器中显示堆类型信息

00:26:27.988 --> 00:26:29.256 
用来开始分析

00:26:29.957 --> 00:26:31.792 
中间的编辑器

00:26:31.859 --> 00:26:33.894 
显示连接问题

00:26:34.328 --> 00:26:37.564 
右边 我们用来显示

00:26:37.631 --> 00:26:40.501 
通过检查器显示栈分配追踪

00:26:40.868 --> 00:26:43.403 
讲完以上 回到演示例子

00:26:44.104 --> 00:26:46.507 
从Tyler讲到的地方开始
看看我们是否

00:26:46.573 --> 00:26:48.575 
能看到他所看到的操作问题

00:26:48.842 --> 00:26:49.710 
好

00:26:50.010 --> 00:26:54.748 
现在我们在FPS性能测量

00:26:54.815 --> 00:26:59.520 
看到那些应用里可能出错的动作

00:26:59.953 --> 00:27:01.655 
我们可以直接查看

00:27:01.722 --> 00:27:04.858 
通过选择内存图形调试器按钮

00:27:05.058 --> 00:27:07.561 
在调试菜单栏

00:27:08.061 --> 00:27:10.030 
左边这里

00:27:10.564 --> 00:27:15.569 
浏览器显示了我的应用中所有不同类型

00:27:15.636 --> 00:27:17.004 
分配在应用中的

00:27:17.237 --> 00:27:21.775 
它们按照模式被分解 然后按照类型

00:27:21.842 --> 00:27:24.178 
每一个对象 都有一个实例

00:27:25.212 --> 00:27:29.983 
在本例中 我对搜索堆感兴趣

00:27:30.184 --> 00:27:31.251 
这很容易做到

00:27:31.318 --> 00:27:34.655 
在过滤器里打字 搜索“操作”

00:27:36.290 --> 00:27:38.725 
出现了
在SpriteKit里出现所有类型

00:27:38.792 --> 00:27:42.829 
我们看到有很多操作——559个

00:27:43.197 --> 00:27:45.532 
应该是操作太多了的问题

00:27:45.599 --> 00:27:49.036 
而不是只有一个一直在运行的操作

00:27:50.637 --> 00:27:52.406 
选择其中一个对象

00:27:53.040 --> 00:27:57.444 
编辑器显示问题的答案

00:27:57.511 --> 00:27:59.613 
即为什么这个对象还存在

00:28:00.013 --> 00:28:02.149 
在这里 它显示了根操作图形

00:28:02.216 --> 00:28:06.653 
可以追踪选中的对象

00:28:06.720 --> 00:28:09.523 
回到左边 回到应用根目录

00:28:09.890 --> 00:28:14.061 
可以看到它被一个SKC序列反复引用

00:28:14.127 --> 00:28:15.696 
还带有一个数组

00:28:15.796 --> 00:28:18.232 
我还可以发现更多问题

00:28:18.932 --> 00:28:22.236 
这里有带一些操作的SKNode

00:28:22.302 --> 00:28:25.172 
这是该SKNode的部分操作列表

00:28:25.439 --> 00:28:28.642 
可以点击 然后快速查看

00:28:29.209 --> 00:28:34.147 
如果想查看关于该操作更多的信息

00:28:34.214 --> 00:28:37.117 
我可以选中它 拉出检查器

00:28:38.719 --> 00:28:40.888 
检查器将显示一些内存细节

00:28:40.954 --> 00:28:44.625 
比如类名 地址 层次结构

00:28:44.691 --> 00:28:47.628 
如果是其它对象的子类

00:28:48.228 --> 00:28:50.631 
我想知道该操作是在哪里新建的

00:28:50.697 --> 00:28:51.798 
这样就可以找到该位置

00:28:52.599 --> 00:28:57.905 
折叠该栈追踪 进入代码

00:28:58.872 --> 00:29:02.109 
这里有一个函数
refreshHurtAction

00:29:03.010 --> 00:29:06.180 
一个HurtAction在运行

00:29:06.246 --> 00:29:11.552 
可以用快速帮助看到该操作已经添加到

00:29:11.618 --> 00:29:14.087 
结点的操作列表当中

00:29:15.556 --> 00:29:18.492 
但实际上我只想有一个单机操作

00:29:18.559 --> 00:29:21.195 
并确保它取代之前的操作

00:29:21.261 --> 00:29:22.529 
所以修复很简单

00:29:22.596 --> 00:29:25.465 
我将使用withKey变量

00:29:25.532 --> 00:29:28.035 
取代“playerAction”

00:29:31.772 --> 00:29:35.042 
快速帮助将会显示
是的 这就是我想要的

00:29:35.108 --> 00:29:37.177 
如果一个操作在使用正运行的统一键值

00:29:37.244 --> 00:29:38.946 
它将会在该操作加进来之前被移除

00:29:39.012 --> 00:29:40.013 
很好

00:29:40.881 --> 00:29:46.420 
这是一种非常简单的方法
对某个特定类型进行调查

00:29:46.753 --> 00:29:47.888 
但是我还注意到另外一点

00:29:47.955 --> 00:29:50.791 
当我点击内存图像调试按钮时

00:29:50.858 --> 00:29:55.062 
运行时问题浏览器提醒我有一些问题

00:29:55.295 --> 00:29:56.363 
点击该提醒

00:29:56.430 --> 00:30:00.367 
来到新的运行时问题浏览器

00:30:00.868 --> 00:30:04.171 
显示在应用里有很多泄漏

00:30:05.372 --> 00:30:09.276 
我先从模式里定义的一个类型开始

00:30:09.343 --> 00:30:11.378 
比如这个LoadSceneOperation

00:30:12.546 --> 00:30:16.116 
选中它 图形没有显示同样的风格

00:30:16.183 --> 00:30:18.719 
它显示了一个引用周期

00:30:19.219 --> 00:30:21.889 
它是一个泄漏的对象

00:30:21.955 --> 00:30:24.892 
从应用里的位置无法访问它

00:30:25.392 --> 00:30:28.061 
需要找出哪些

00:30:28.128 --> 00:30:30.898 
泄漏的对象正在彼此引用

00:30:31.765 --> 00:30:33.100 
快速来看这一点

00:30:33.433 --> 00:30:36.803 
有一个带有内部状态的操作

00:30:37.070 --> 00:30:39.106 
它在引用一个完成块

00:30:39.606 --> 00:30:43.944 
作为该块的一部分 有一些捕捉

00:30:44.011 --> 00:30:46.213 
正在强力引用LoadSceneOperation

00:30:46.613 --> 00:30:47.481 
有意思

00:30:48.315 --> 00:30:51.418 
如果点击该模块 我可以看到回溯轨迹

00:30:51.485 --> 00:30:52.686 
马上去那里

00:30:54.855 --> 00:30:56.323 
在这里

00:30:56.623 --> 00:30:58.458 
我的LoadSceneOperation的完成块

00:30:58.525 --> 00:31:01.461 
我甚至有一个“unowned self”捕捉列表

00:31:02.029 --> 00:31:04.631 
但是图形显示该self没有问题

00:31:04.698 --> 00:31:07.467 
问题是LoadSceneOperation
正在捕捉自己

00:31:08.268 --> 00:31:09.770 
就在该模块中

00:31:11.471 --> 00:31:13.407 
此处修复也非常简单

00:31:13.674 --> 00:31:17.477 
只需要捕捉unowned

00:31:18.245 --> 00:31:21.181 
就可以继续了 但是

00:31:23.917 --> 00:31:26.653 
可惜的是 这不是真正的解决方案

00:31:26.987 --> 00:31:31.091 
因为是整个模块 我的
LoadSceneOperation已要结束了

00:31:31.558 --> 00:31:33.760 
如果它执行了该模块

00:31:34.194 --> 00:31:36.830 
LoadSceneOperation将会结束其生命周期

00:31:36.897 --> 00:31:38.599 
不会存在很长时间

00:31:38.966 --> 00:31:41.401 
也就是说
如果用dispatch_async回到主队列

00:31:42.536 --> 00:31:44.972 
该LoadSceneOperation
可能已经不可用

00:31:45.038 --> 00:31:46.240 
系统将会崩溃

00:31:46.807 --> 00:31:50.944 
只是想告诉大家
有时这些捕捉会有点复杂

00:31:51.245 --> 00:31:54.214 
需要一点调查

00:31:54.581 --> 00:31:56.450 
希望内存图形调试器

00:31:56.517 --> 00:31:58.986 
也能够帮助你检查问题

00:32:06.326 --> 00:32:10.397 
现在我们再来讲讲泄漏和废弃内存

00:32:10.964 --> 00:32:14.535 
内存图形调试器是一个调试模式

00:32:14.601 --> 00:32:17.471 
它会暂停 开始对目标应用进行检查

00:32:17.738 --> 00:32:20.607 
这样应用就不会继续运行并改变状态

00:32:20.674 --> 00:32:22.843 
可以有一个恒定的视图

00:32:22.910 --> 00:32:25.879 
也可以让你做一些诸如快速查看的操作
或者PO不同的对象

00:32:25.946 --> 00:32:27.681 
在你进行调查时

00:32:27.748 --> 00:32:30.184 
而且在所有平台上都可用

00:32:31.018 --> 00:32:33.987 
如我所演示的
共有两种不同的图形风格

00:32:34.054 --> 00:32:37.491 
第一种是 根路径图形风格

00:32:37.558 --> 00:32:39.426 
它将显示引用过的内存

00:32:39.493 --> 00:32:40.594 
也许你废弃了它

00:32:41.028 --> 00:32:45.299 
应用中不同的根 比如全局变量

00:32:45.365 --> 00:32:47.968 
和正在运行的线程
是如何引用该内存的

00:32:48.502 --> 00:32:50.103 
利用渐进展开模式

00:32:50.170 --> 00:32:54.708 
它让你从对象开始回溯不同的中间对象

00:32:54.775 --> 00:32:57.411 
找到那些不应该存在的引用

00:32:58.679 --> 00:33:02.716 
对未引用或泄露的内存来说
第二种风格是周期视图

00:33:02.783 --> 00:33:08.989 
其目标是帮助显示正强引用自身的对象

00:33:09.056 --> 00:33:11.992 
会再一次找出引用问题

00:33:14.127 --> 00:33:18.465 
在查看器里看到的栈记录集成

00:33:20.467 --> 00:33:24.438 
它无法自由记录所有的分配和释放

00:33:24.505 --> 00:33:27.007 
这是一种需要选择加入的诊断

00:33:28.709 --> 00:33:31.879 
进入方案编辑器 选中“分配栈记录”

00:33:31.945 --> 00:33:34.448 
在“诊断”标签

00:33:34.815 --> 00:33:38.252 
它将记录所有的磁盘分配和释放

00:33:38.318 --> 00:33:39.653 
方便之后的查询

00:33:40.521 --> 00:33:42.189 
但是对于内存图形调试

00:33:42.256 --> 00:33:44.591 
你不真正需要所有的分配和释放

00:33:44.658 --> 00:33:49.329 
之前的分配模块通常也没什么用

00:33:49.796 --> 00:33:56.236 
所以在最新的OS中有一个新特性
“实时只分配模式”

00:33:56.303 --> 00:33:59.206 
这样做开销较低

00:33:59.673 --> 00:34:02.910 
它还让你获得这些有用的信息

00:34:02.976 --> 00:34:04.378 
在进行内存图形调试时

00:34:04.645 --> 00:34:09.183 
它将把“分配栈记录”
标识为“lite”

00:34:09.248 --> 00:34:10.884 
在目标环境下

00:34:13.320 --> 00:34:18.492 
关于内存图形调试
你们还可能喜欢的一点

00:34:18.559 --> 00:34:21.295 
我们引入.memgraph文件类型

00:34:21.762 --> 00:34:23.830 
当在调试某个问题时

00:34:23.897 --> 00:34:26.867 
你并没有时间去好好研究

00:34:27.234 --> 00:34:28.768 
你想把它存下来

00:34:28.835 --> 00:34:31.438 
或者让团队里的其他工程师也来看看

00:34:32.105 --> 00:34:35.141 
在Xcode里
你可以点击“文件”菜单

00:34:35.208 --> 00:34:37.277 
选择“导出内存图形”

00:34:37.710 --> 00:34:39.246 
这将保存所有

00:34:39.313 --> 00:34:41.815 
连接信息和堆信息

00:34:41.882 --> 00:34:45.452 
以及一些VM数据 到一个文件

00:34:45.853 --> 00:34:47.920 
之后某个时间 你可以双击它

00:34:47.987 --> 00:34:52.259 
加载到Xcode 看一看内存图形

00:34:52.960 --> 00:34:55.094 
但是用这种方法 调试器里没有进程

00:34:55.161 --> 00:34:58.999 
所以你无法回溯 也无法快速查看对象
无法PO对象

00:34:59.333 --> 00:35:03.504 
但这仍然是出错后分析应用的
一项非常强大技术

00:35:04.638 --> 00:35:08.642 
如果你想持续集成

00:35:09.576 --> 00:35:11.645 
在命令行中有一些选项

00:35:12.279 --> 00:35:16.316 
只要运行leaks-outputGraph
选择一个路径

00:35:16.383 --> 00:35:18.819 
保存到一个.memgraph文件
以便之后使用

00:35:20.020 --> 00:35:24.391 
leaks vmmap heap
都可以读这个文件

00:35:31.398 --> 00:35:33.133 
好了 到了有趣的部分

00:35:33.200 --> 00:35:34.801 
我们来讲讲有用的小技巧

00:35:34.868 --> 00:35:37.704 
这一切都建立在泄漏结构上

00:35:38.338 --> 00:35:40.507 
说明图形是保守的

00:35:41.108 --> 00:35:46.213 
我们非常非常小心
避免在对象没有泄漏时报告其泄漏

00:35:46.280 --> 00:35:50.350 
避免误报

00:35:50.918 --> 00:35:53.387 
在图形里可能会看到多余的引用

00:35:54.354 --> 00:35:59.026 
这些引用将被显示为灰色 表示未知

00:35:59.092 --> 00:36:01.061 
可能是有效引用 可能不是

00:36:01.361 --> 00:36:04.364 
可能不止提供元数据给工具

00:36:04.731 --> 00:36:10.170 
当你查看这些图形时 要多多注意

00:36:10.671 --> 00:36:13.173 
提高准确度的一个方法是

00:36:13.240 --> 00:36:14.441 
就是开启“内存涂鸦”

00:36:14.508 --> 00:36:16.944 
该方案下的另一个诊断工具

00:36:17.311 --> 00:36:20.347 
它的作用是当分配自由

00:36:20.714 --> 00:36:23.851 
它将把内存写入 你就不用了

00:36:23.917 --> 00:36:27.721 
未初始化的内存写入新的模块

00:36:29.590 --> 00:36:31.325 
对于那些已知的强引用来说

00:36:31.391 --> 00:36:33.427 
在图形里会粗体显示

00:36:33.493 --> 00:36:39.233 
Swift 3实际上有
很多可用反射元数据

00:36:39.600 --> 00:36:43.804 
我推荐大家使用

00:36:44.571 --> 00:36:46.940 
因为它绝对更为准确

00:36:47.007 --> 00:36:49.476 
在理解捕捉和引用方面

00:36:50.511 --> 00:36:53.113 
最后 我应该关掉内存图形调试器

00:36:53.180 --> 00:36:55.716 
暂时关闭所有检查工具

00:36:55.782 --> 00:36:58.785 
比如地址检查工具
或"Thread Sanitizer线程检查工具"

00:37:00.087 --> 00:37:01.588 
有很多的信息

00:37:02.222 --> 00:37:04.591 
这是不是一个开始编写应用的好地方？

00:37:05.092 --> 00:37:07.294 
验证你的期待吧

00:37:07.794 --> 00:37:10.564 
还有别的某种类型的对象要期待吗？

00:37:11.164 --> 00:37:13.934 
对象是不是在你想要时被释放？

00:37:14.601 --> 00:37:17.938 
你的类型还有没有泄漏？

00:37:18.672 --> 00:37:21.375 
如果你对某一个对象很感兴趣

00:37:21.909 --> 00:37:24.378 
目标就是找到一条不应该

00:37:24.444 --> 00:37:25.646 
连到对象上的路径

00:37:26.079 --> 00:37:29.950 
还有两种常见模式

00:37:30.017 --> 00:37:32.619 
来自块和闭包的强捕捉

00:37:33.287 --> 00:37:39.026 
或图形中潜在的向上引用

00:37:39.359 --> 00:37:41.361 
这些需要被标示为
“weak”或“unowned”

00:37:42.629 --> 00:37:45.532 
讲了很多信息

00:37:46.066 --> 00:37:50.704 
我非常感谢你们的倾听

00:37:50.771 --> 00:37:54.641 
Xcode 8中
全新改进的可视化工具

00:37:54.842 --> 00:37:56.176 
我们对此非常激动

00:37:56.243 --> 00:38:00.047 
如更好的可视化调试 用视图调试器

00:38:00.314 --> 00:38:03.750 
用FPS测量以及内存图形调试器

00:38:03.984 --> 00:38:08.455 
今天就在应用中放手一试
多多解决问题吧