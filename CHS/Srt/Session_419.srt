00:00:20.020 --> 00:00:26.393
UIKit应用基于协议与值的编程

00:00:30.030 --> 00:00:32.031
大家下午好 欢迎大家的到来

00:00:32.766 --> 00:00:35.836
我叫Alex 我和Jacob
今天将会跟大家谈一下

00:00:36.270 --> 00:00:38.705
如何使用值类型和协议

00:00:38.972 --> 00:00:40.073
来提高应用的性能

00:00:40.507 --> 00:00:41.708
我们今天的重点是

00:00:41.775 --> 00:00:44.011
一个叫做局部推理的东西

00:00:45.579 --> 00:00:49.016
局部推理的意思是
当你看眼前的代码时

00:00:49.683 --> 00:00:52.386
你不必考虑其他代码

00:00:52.452 --> 00:00:53.720
与那个函数如何互动

00:00:54.454 --> 00:00:56.256
你之前可能有过这种感觉

00:00:56.957 --> 00:00:58.892
而这就是那种感觉的一个称呼

00:00:59.826 --> 00:01:03.297
比如 也许你刚加入一个新团队

00:01:03.497 --> 00:01:06.700
你要看大量的代码
但是环境很少

00:01:07.301 --> 00:01:10.003
你能明白那一个函数正在
实现什么功能吗？

00:01:10.838 --> 00:01:13.440
所以了解这个信息是非常重要的

00:01:13.540 --> 00:01:15.442
因为这样维护起来更容易

00:01:15.742 --> 00:01:16.844
写起代码来更容易

00:01:17.077 --> 00:01:18.278
测试起来更容易

00:01:18.712 --> 00:01:20.747
首次参与编码也更容易

00:01:22.216 --> 00:01:24.518
所以我们要谈一下
局部推理会如何

00:01:25.419 --> 00:01:26.954
在模型视图控制器设计范例环境下

00:01:27.254 --> 00:01:30.457
改善我们的UIKit应用

00:01:31.158 --> 00:01:34.595
就是Cocoa所使用的模型存储数据

00:01:35.395 --> 00:01:36.730
视图呈现数据

00:01:37.364 --> 00:01:39.600
控制器在两者之间协调

00:01:41.201 --> 00:01:43.770
我们需要一个真实的应用
来验证我们的答案

00:01:45.138 --> 00:01:48.642
不幸的是在Apple中我们实际上
有一个问题需要解决

00:01:51.812 --> 00:01:53.514
我要跟你们说个秘密

00:01:53.580 --> 00:01:55.983
关于我们每年
是如何准备 WWDC 的

00:01:57.484 --> 00:01:58.886
工程师都有梦想

00:01:59.453 --> 00:02:02.823
他们要呈现他们所梦想的东西

00:02:03.056 --> 00:02:06.827
无论用什么方式 我们要了解
这些梦想 并把它们记录下来

00:02:07.394 --> 00:02:11.498
但我们注意到许多工程师实际上
在工作时

00:02:11.565 --> 00:02:12.966
就不再记得他们的梦想了

00:02:13.033 --> 00:02:14.067
他们忘了自己的梦想

00:02:14.701 --> 00:02:16.904
所以我和Jacob开发了
这款很棒的应用

00:02:17.271 --> 00:02:18.305
可让你们记起自己的梦想

00:02:19.006 --> 00:02:20.974
该应用就叫Lucid Dreams

00:02:22.509 --> 00:02:25.879
我要展示去年人们的一些梦想

00:02:27.281 --> 00:02:29.483
有些人梦想成为麒麟

00:02:30.851 --> 00:02:31.952
这是认真的

00:02:34.988 --> 00:02:37.758
很奇怪的是 有些人

00:02:39.193 --> 00:02:42.596
仍然被工作压力问题所束缚

00:02:44.765 --> 00:02:48.435
他们更想离开办公室去骑车

00:02:50.370 --> 00:02:54.074
有些工程师甚至梦想成为Crusty

00:03:02.216 --> 00:03:04.551
那就是我们应用的灵感

00:03:04.618 --> 00:03:07.421
由于我们将在演讲中使用这个应用

00:03:07.487 --> 00:03:08.956
我想快速给你们展示一个演示

00:03:09.456 --> 00:03:11.725
这样你就能明白这个应用是做什么的

00:03:13.026 --> 00:03:15.629
如果我们启动应用
你会注意到它会把我们带到

00:03:15.696 --> 00:03:17.564
我们现有的梦想列表中

00:03:18.699 --> 00:03:21.101
如果你轻触其中一个梦想
你可以编辑它

00:03:22.569 --> 00:03:24.738
并且在顶部可以看到预览

00:03:25.305 --> 00:03:28.041
可以向下滚动并添加一些特效

00:03:28.242 --> 00:03:30.377
比如激光束和雨

00:03:31.945 --> 00:03:36.450
然后往回滚动到原来的位置
你可以看到梦想的预览

00:03:36.683 --> 00:03:40.888
麒麟有激光束、雨和喷火特效

00:03:42.556 --> 00:03:44.391
编辑完成后

00:03:44.458 --> 00:03:46.426
返回梦想列表

00:03:48.061 --> 00:03:49.530
这就是这个应用

00:03:50.764 --> 00:03:54.701
我们要认真努力地思考
如何写出更优秀的代码

00:03:55.235 --> 00:03:58.438
所以我们去年参加了一些
很不错的Swift演讲

00:03:59.706 --> 00:04:02.042
这些演讲的主题是值类型
和面向协议的编程

00:04:02.109 --> 00:04:03.877
的好处

00:04:04.444 --> 00:04:06.213
这些想法非常强大

00:04:06.413 --> 00:04:08.148
我们想要利用它们

00:04:08.215 --> 00:04:11.618
因为它们可以帮助改善
应用中的局部推理

00:04:12.419 --> 00:04:15.122
所以我们用这种不一样的思考
方式写出了这个应用

00:04:15.989 --> 00:04:19.560
现在你可能觉得有些想法很陌生
没有关系

00:04:19.927 --> 00:04:22.262
我们首次尝试这些技术时

00:04:22.329 --> 00:04:24.164
我们也觉得很陌生

00:04:24.464 --> 00:04:26.233
所以不要担心 继续听我们讲

00:04:30.337 --> 00:04:32.539
我们会快速地谈一下模型层中

00:04:32.606 --> 00:04:34.241
值类型的好处

00:04:34.808 --> 00:04:37.911
去年已经谈过了
所以我们要快速回顾一下

00:04:39.246 --> 00:04:41.582
然后我们重点讲如何
在视图控制器层

00:04:41.648 --> 00:04:43.350
使用值类型

00:04:43.750 --> 00:04:48.655
因为我们认为绝大部分人认为
他们不会利用值类型

00:04:49.089 --> 00:04:51.491
即使它们有一些切实的好处

00:04:52.860 --> 00:04:56.163
在演讲中 我会演示如何使用
值类型和协议

00:04:56.230 --> 00:04:57.831
使代码变得可测试

00:04:59.233 --> 00:05:02.970
你刚刚看到了这个很棒的应用
我知道你想测试

00:05:03.036 --> 00:05:04.838
我们已经发布了示例应用

00:05:04.905 --> 00:05:08.242
你可以自己下载 查看代码

00:05:08.308 --> 00:05:09.643
并记录你自己的梦想

00:05:12.446 --> 00:05:15.148
好了 现在 是时候谈模型层了

00:05:16.416 --> 00:05:17.384
那么梦想是什么？

00:05:19.419 --> 00:05:21.054
梦想是模型类型

00:05:21.121 --> 00:05:23.690
会在应用中呈现梦想

00:05:24.825 --> 00:05:28.762
梦想可以是描述、
创造物和一组特效

00:05:28.829 --> 00:05:30.430
正如你刚才在UI上看到的一样

00:05:31.365 --> 00:05:33.333
我想展示梦想类型的一个版本

00:05:33.400 --> 00:05:36.403
是我们去年在应用的第一个版本中使用的

00:05:37.171 --> 00:05:39.239
最开始我们的梦想类型是一个类

00:05:40.274 --> 00:05:42.576
类有引用语义

00:05:42.910 --> 00:05:46.346
意思就是引用同一个实例会共享存储

00:05:46.413 --> 00:05:47.848
这样的共享很含蓄

00:05:48.749 --> 00:05:50.317
这为什么会是个问题呢？

00:05:52.352 --> 00:05:56.156
嗯 假如某人尝试修改
dream2的描述

00:05:57.558 --> 00:06:00.594
如果我们关注dream1
我们会非常吃惊

00:06:00.827 --> 00:06:03.997
因为变量的值在我们的控制下
发生了变更

00:06:06.500 --> 00:06:08.669
这非常影响局部推理

00:06:10.237 --> 00:06:13.340
而且我们自己的应用
即使通过了测试

00:06:13.407 --> 00:06:14.908
恰有这种漏洞

00:06:15.542 --> 00:06:16.543
为什么会这样呢？

00:06:19.580 --> 00:06:22.015
这个图表显示了应用

00:06:22.082 --> 00:06:24.117
第一个版本中的关系

00:06:24.952 --> 00:06:27.955
有些关系可以同时兼具明显和含蓄

00:06:28.255 --> 00:06:30.257
有些关系既可以是单向的
又可以是双向的

00:06:30.858 --> 00:06:33.026
有些关系甚至既可静态又可动态

00:06:34.595 --> 00:06:37.297
所以这些关系可以变得
非常非常复杂

00:06:39.499 --> 00:06:40.968
那么当我们尝试测试它自己的

00:06:41.034 --> 00:06:43.971
梦想类型时发生了什么呢？

00:06:45.572 --> 00:06:49.510
嗯 即使你创建一个能自己
支持自己的梦

00:06:50.377 --> 00:06:53.113
也不会在应用中反映实际情况

00:06:53.180 --> 00:06:55.983
因为实际存在更多的依赖性

00:07:00.921 --> 00:07:02.222
这样很不好

00:07:06.727 --> 00:07:09.763
我们可以通过使梦想类型成为
有值语义

00:07:09.830 --> 00:07:11.231
的结构来解决这个问题

00:07:12.466 --> 00:07:15.102
意思是每个变量都有独立的存储

00:07:15.235 --> 00:07:17.404
改变其中一个变量的值

00:07:17.471 --> 00:07:19.673
不会影响其他变量的值

00:07:20.040 --> 00:07:22.876
如果我们修改dream2的描述

00:07:23.844 --> 00:07:26.980
我们只能修改dream2的描述
不会影响dream1的描述

00:07:28.048 --> 00:07:31.318
这就确保梦想不会涉及

00:07:31.385 --> 00:07:34.054
我们之前所看到的复杂关系

00:07:37.024 --> 00:07:40.260
这也证明了我们有局部推理的能力

00:07:40.627 --> 00:07:45.165
因为没有代码能改变在我们的
控制下正在使用的值

00:07:46.800 --> 00:07:49.269
接下来讲使用值类型

00:07:49.336 --> 00:07:53.240
我们刚看到了我们是如何在模型层
中利用值类型的

00:07:54.007 --> 00:07:57.811
而且在模型层使用值类型实际上
是没有任何争议的

00:07:58.745 --> 00:08:02.082
但你们就不想
在我们应用的其他部分

00:08:02.149 --> 00:08:03.951
利用我们刚刚看到的这种好处吗？

00:08:05.552 --> 00:08:07.621
实际上可能会很吸睛

00:08:07.855 --> 00:08:11.725
我想引用一句话
是我最近在因特网上看到的

00:08:12.359 --> 00:08:15.762
说“只在简单的
模型类型上使用值”

00:08:17.297 --> 00:08:18.966
听起来一点儿都不励志

00:08:19.733 --> 00:08:22.903
但我们会相信从因特网上
看到的所有东西吗？

00:08:24.204 --> 00:08:27.241
答案是不会 如果你不了解的话

00:08:30.010 --> 00:08:31.678
那么 在接下来的演讲中

00:08:31.745 --> 00:08:34.214
我们主要谈如何在应用复杂的

00:08:34.347 --> 00:08:36.582
模型数据中使用值

00:08:37.751 --> 00:08:40.020
同时我们将证明因特网上的
那种说法是错误的

00:08:44.691 --> 00:08:45.626
好的

00:08:46.126 --> 00:08:49.396
让我们邀请Jacob上台
讲一下视图层

00:08:56.937 --> 00:08:57.905
谢谢Alex

00:09:00.574 --> 00:09:04.111
我真的很乐于跟你们讲我们是如何
与视图一起

00:09:04.278 --> 00:09:05.279
使用基于协议的编程

00:09:06.813 --> 00:09:09.750
我们在应用的表视图单元上花了
很多时间

00:09:10.817 --> 00:09:14.021
我们对它们的布局进行了精心设计
我们想要实现

00:09:14.087 --> 00:09:17.724
完全显示出
人们所梦想的麒麟

00:09:19.459 --> 00:09:21.728
当开始开发应用时
我们写了这些布局

00:09:21.795 --> 00:09:24.198
作为UITableViewCell
抽象子类

00:09:25.065 --> 00:09:28.535
比如 这个简单布局 我们把它叫做
DecoratingLayoutCell

00:09:29.236 --> 00:09:31.171
它左侧显示了一点儿装饰

00:09:31.538 --> 00:09:33.540
右侧有大块的内容

00:09:35.375 --> 00:09:38.145
然后 我们做了一个布局单元
的具体子类

00:09:38.245 --> 00:09:40.781
添加具体逻辑 比如显示梦想

00:09:42.015 --> 00:09:44.251
我们做了这种分离 因为我们想

00:09:44.318 --> 00:09:46.520
在不同的地方重新使用布局

00:09:47.521 --> 00:09:48.989
但随着开发的继续

00:09:49.056 --> 00:09:51.124
我们发现越来越不好用了

00:09:51.625 --> 00:09:53.861
它能帮助我们在不同的单元
重新使用布局

00:09:54.628 --> 00:09:56.830
但很难在表视图外使用

00:09:57.998 --> 00:09:59.466
比如 我们有个详细视图

00:09:59.700 --> 00:10:01.735
显示梦想的更多信息

00:10:01.802 --> 00:10:04.037
但我们不能在那儿重新使用
布局单元

00:10:05.405 --> 00:10:07.508
我们想找到更好的方式来构造

00:10:07.574 --> 00:10:10.477
以便我们能在表视图单元上
使用布局

00:10:10.978 --> 00:10:12.913
同时也能在普通UI视图中
使用布局

00:10:14.047 --> 00:10:15.949
我们还想在应用中
添加SpriteKit

00:10:16.016 --> 00:10:17.784
显示那些很酷的粒子特效

00:10:17.918 --> 00:10:21.088
并且我们也想在SpriteKit
节点中使用布局

00:10:22.356 --> 00:10:25.859
这就是我们的目标 我们用从
Swift学到的东西来实现这个目标

00:10:26.994 --> 00:10:29.329
虽然我要具体地讲布局

00:10:29.663 --> 00:10:30.731
我想让你们记住一点

00:10:30.831 --> 00:10:33.233
这些技术可以在整个应用中使用

00:10:33.967 --> 00:10:35.369
好了 我们开始吧

00:10:37.604 --> 00:10:40.073
这是我们以前的布局单元

00:10:40.407 --> 00:10:42.843
有两个视图

00:10:43.243 --> 00:10:46.947
但这个布局逻辑实际上不需要
被困在单元内

00:10:47.147 --> 00:10:50.450
只需要一些数学和几何学
就能算出一组框架

00:10:51.985 --> 00:10:55.189
让我们从不让单元只是作为
普通结构开始吧

00:10:56.223 --> 00:10:57.658
它仍会有两个视图

00:10:58.725 --> 00:11:01.361
我们可以把所有布局逻辑
放在一个方法中

00:11:01.428 --> 00:11:03.330
可以调用方法 显示布局

00:11:04.731 --> 00:11:06.266
只做了这样小小的变更

00:11:06.333 --> 00:11:08.635
我们就拥有了非常独立的代码

00:11:08.902 --> 00:11:11.405
这些代码知道如何实现布局
仅此而已

00:11:13.574 --> 00:11:17.344
然后 我们可以更新梦想单元
使用新结构来展示它的子单元

00:11:18.512 --> 00:11:20.380
好消息是我们现能在UIView子类中

00:11:20.447 --> 00:11:22.049
使用独立代码了

00:11:23.217 --> 00:11:26.119
现在 这个布局逻辑已经跟
表视图单元不挂钩了

00:11:26.286 --> 00:11:27.855
我们可在任何UIView中使用

00:11:29.923 --> 00:11:31.925
还有一个好处

00:11:32.025 --> 00:11:34.528
我们能独立使用布局

00:11:34.828 --> 00:11:37.798
可以非常方便地做单元测试

00:11:37.965 --> 00:11:39.533
我们只需要创建一些视图

00:11:40.501 --> 00:11:41.835
并把它们添加到布局中

00:11:43.036 --> 00:11:45.038
然后在一个已知的矩形中
展示出来

00:11:46.006 --> 00:11:47.441
再然后 我们只需要验证

00:11:47.508 --> 00:11:49.643
结果展示的框架是否正是
我们所期待的框架

00:11:50.244 --> 00:11:52.279
我们的测试不必创建表视图

00:11:52.479 --> 00:11:54.882
或等待正确的视图布局
回调函数起作用

00:11:54.948 --> 00:11:57.684
只需要通知布局开始运行
然后验证输出

00:11:58.919 --> 00:12:01.255
这是我们得到的其中一个好处

00:12:01.822 --> 00:12:04.491
新布局的结构很小、很紧凑

00:12:04.992 --> 00:12:08.095
这种变更使它更容易对这个代码
进行局部推理

00:12:08.929 --> 00:12:11.164
如果我们想了解对布局的测试

00:12:11.431 --> 00:12:14.268
我们只需要了解那个
独立的小结构

00:12:15.035 --> 00:12:17.304
我们不想考虑 哪组视图

00:12:17.371 --> 00:12:18.872
它可能会使用或覆盖

00:12:21.441 --> 00:12:24.444
好的 现在让我们返回
DecoratingLayout代码

00:12:26.446 --> 00:12:29.116
现在 这个代码只知道
如何显示视图

00:12:29.216 --> 00:12:31.051
但就像我刚才所说的
我们也想用这个

00:12:31.118 --> 00:12:32.519
支持SpriteKit

00:12:34.288 --> 00:12:36.423
所以 我们不想复制这个代码

00:12:36.490 --> 00:12:38.725
但SKNode并非UIView子类

00:12:39.293 --> 00:12:41.862
所以这里没有可用的通用超类

00:12:42.529 --> 00:12:45.165
那么我们如何把这两者结合到
一个单一布局中呢？

00:12:46.834 --> 00:12:49.169
由于我们的布局在这些子类中
所实现的唯一功能

00:12:49.236 --> 00:12:50.504
是设置它们的框架

00:12:50.771 --> 00:12:53.473
这是我们需要的唯一功能

00:12:53.807 --> 00:12:56.310
我们可以通过协议
来实现这个需求

00:12:57.678 --> 00:12:58.979
我们要做一个协议

00:12:59.046 --> 00:13:01.415
这个协议只有一个单一框架属性

00:13:01.849 --> 00:13:04.852
这样还不流畅
我们要稍微改进一下

00:13:06.086 --> 00:13:09.022
然后 我们使用这个协议
作为子类的类型

00:13:09.656 --> 00:13:11.225
而不是把它们做成视图

00:13:13.727 --> 00:13:15.996
最后 我们可以使用追溯模型

00:13:16.230 --> 00:13:19.333
使UIView和
SKNode遵守新协议

00:13:20.567 --> 00:13:23.237
现在 我们有一个能在两种类型中
使用的布局了

00:13:23.303 --> 00:13:25.939
这是使用协议 的好处之一

00:13:26.006 --> 00:13:28.075
并非为实现多态的超类

00:13:28.775 --> 00:13:30.711
我们可以使用协议把这个功能添加

00:13:30.811 --> 00:13:33.213
到不相关的类型
并在两种类型中使用

00:13:34.815 --> 00:13:38.252
现在 我们的布局
不再依赖于UIKit了

00:13:38.785 --> 00:13:40.254
我们能做的另一件事是

00:13:40.320 --> 00:13:43.590
把同样的体系带到AppKit中
并支持展示NS视图

00:13:43.657 --> 00:13:44.758
非常简单

00:13:44.825 --> 00:13:46.159
我觉得这很酷

00:13:48.328 --> 00:13:49.563
我们已经很接近了

00:13:49.630 --> 00:13:51.965
但仍然还有要改进的东西

00:13:53.233 --> 00:13:55.736
当我们在视图中使用
DecoratingLayout时

00:13:55.802 --> 00:13:58.705
我们想把所有内容添加为子视图

00:13:59.339 --> 00:14:01.942
类似地 当我们在SpriteKit
场景中使用它时

00:14:02.042 --> 00:14:04.411
我们把内容添加为子节点

00:14:05.279 --> 00:14:08.949
但现在 内容和装饰可以是
有框架的任何类型

00:14:10.083 --> 00:14:13.754
意思是 比如
我们的内容可以是个UIView

00:14:14.021 --> 00:14:15.756
而装饰是一个SKNode

00:14:16.790 --> 00:14:20.861
但相反 我们想让布局
只有一组UI视图

00:14:20.928 --> 00:14:22.629
或只有一组SK节点
作为其子布局

00:14:24.264 --> 00:14:27.367
那样 我们就能把它们添加到
相应的父布局中

00:14:28.402 --> 00:14:31.071
现在Swift有一种方式
就是用泛型表达

00:14:32.339 --> 00:14:34.708
我们可以把布局更新为通用类型

00:14:34.942 --> 00:14:36.743
类型参数叫child

00:14:38.145 --> 00:14:40.113
然后我们可以使内容

00:14:40.180 --> 00:14:42.616
和装饰属性使用child
作为它们的类型

00:14:43.417 --> 00:14:45.419
这就正好提供了我们想要的结果

00:14:45.552 --> 00:14:48.055
我们可以强制它们是同一种
具体类型

00:14:48.155 --> 00:14:49.756
这样我们的
DecoratingLayout

00:14:49.823 --> 00:14:52.926
就只能有UI视图或只包含
SK节点的视图

00:14:53.493 --> 00:14:56.196
因此 泛型是一个很棒的工具
可使我们对代码中的类型

00:14:56.263 --> 00:14:57.664
拥有更多的控制

00:14:58.632 --> 00:15:00.234
泛型的另一个好处是

00:15:00.300 --> 00:15:03.504
编译器能获得关于代码功能的更多信息

00:15:03.904 --> 00:15:05.272
因此可以进行更多优化

00:15:06.106 --> 00:15:08.008
你可以从了解Swift的性能演讲中

00:15:08.075 --> 00:15:10.143
更详细地了解这些信息

00:15:10.377 --> 00:15:12.446
那是场不错的演讲
可以了解Swift如何运作

00:15:12.513 --> 00:15:14.548
以及如何写出迅捷的Swift代码

00:15:16.884 --> 00:15:19.987
好了 我们现有一个不错的
DecoratingLayout实现

00:15:20.721 --> 00:15:23.023
但是我们的应用还包含许多其他布局

00:15:23.557 --> 00:15:24.958
比如这个级联布局

00:15:25.792 --> 00:15:29.396
这个布局类似于我们刚看到的
DecoratingLayout

00:15:30.197 --> 00:15:31.899
右侧都显示一大块区域

00:15:32.332 --> 00:15:34.101
左侧有详细的装饰区

00:15:35.002 --> 00:15:38.038
我们不想粘贴复制代码
来创建这个新布局

00:15:38.105 --> 00:15:39.706
那样可能会失去一个创建两者

00:15:39.773 --> 00:15:42.409
都能使用的共享抽象的好机会

00:15:43.343 --> 00:15:44.978
我们要如何共享这个代码呢？

00:15:45.913 --> 00:15:49.283
你们之前几乎都用过的一个
共享代码的工具是继承

00:15:49.616 --> 00:15:51.952
但如果用继承
你的确是有了代码

00:15:52.019 --> 00:15:53.787
但是请不要尝试
读取这个代码

00:15:53.854 --> 00:15:56.790
而且你还要考虑超类
可能会有什么功能

00:15:57.424 --> 00:16:00.294
以及子类想要变更或覆盖什么

00:16:00.561 --> 00:16:02.930
除了只考虑你正在用的代码

00:16:03.030 --> 00:16:05.566
你还要考虑把
分散在应用中的

00:16:05.632 --> 00:16:07.067
大量代码结合在一起

00:16:07.167 --> 00:16:08.936
而这只是冰山一角

00:16:09.336 --> 00:16:12.005
很多时候你还要从框架类继承

00:16:12.072 --> 00:16:13.607
如UIView或视图控制器

00:16:14.107 --> 00:16:16.276
还有大量数量级的代码

00:16:17.244 --> 00:16:18.679
所以 继承是另一个

00:16:18.745 --> 00:16:21.782
要使用局部推理的地方

00:16:24.852 --> 00:16:27.788
但我们可以通过合成
更好地共享代码

00:16:28.956 --> 00:16:32.626
合成是一个简单的想法
只是把一些小片段结合在一起

00:16:32.693 --> 00:16:33.961
构建一个较大的片段

00:16:34.561 --> 00:16:38.198
但是当合成时
你可以了解那些独立的片段

00:16:39.166 --> 00:16:40.934
你还可以强制封装

00:16:41.001 --> 00:16:43.470
而不需要担心子类或超类

00:16:43.837 --> 00:16:45.572
在抽象中产生漏洞

00:16:46.807 --> 00:16:48.442
但合成也不是个新功能

00:16:49.142 --> 00:16:52.513
你以前可能在Objective-C
或其他语言中用过

00:16:53.714 --> 00:16:55.816
以前我们实现布局的其中
一种方式是

00:16:55.883 --> 00:16:57.551
把视图组合到一起

00:16:58.318 --> 00:16:59.786
你可能会写一个UIView

00:16:59.853 --> 00:17:01.788
执行级联布局行为

00:17:02.322 --> 00:17:05.492
再写另一个UIView
执行装饰布局行为

00:17:05.858 --> 00:17:09.229
然后你可能会将这两者作为
子视图添加到表视图单元中

00:17:09.963 --> 00:17:11.565
但是有一个大问题

00:17:12.266 --> 00:17:13.901
就是类实例的消耗很大

00:17:14.434 --> 00:17:17.237
当你创建另一个对象时
你会有一个额外的堆式分配

00:17:17.471 --> 00:17:19.138
这比视图更糟糕

00:17:19.806 --> 00:17:22.009
因为需要做很多工作来支持视图

00:17:22.075 --> 00:17:24.511
使视图能实现像绘制
和事件处理这样的功能

00:17:25.412 --> 00:17:28.882
正因为如此 我们非常努力地
尝试把视图数量最小化

00:17:29.950 --> 00:17:31.852
所以创建一个不能绘制的视图

00:17:31.952 --> 00:17:34.621
并且只作为布局抽象
是一种很大的浪费

00:17:35.389 --> 00:17:38.392
这也是为什么合成视图方案
不太好的原因

00:17:39.526 --> 00:17:42.095
但通过Swift 我们得到了一个
好得多的方式进行合成

00:17:42.162 --> 00:17:43.664
就是用值类型

00:17:45.232 --> 00:17:47.901
结构是轻量级的 因此
我们可以使用多个结构

00:17:47.968 --> 00:17:51.471
而不需要付出像类和视图
那么多的消耗

00:17:52.673 --> 00:17:55.909
因为结构有值语义
所以就更好了

00:17:56.877 --> 00:17:59.246
使用值类型会有更好的封装

00:17:59.813 --> 00:18:02.316
可以同时使用这些片段
来进行合成

00:18:02.549 --> 00:18:06.453
而不需要担心别人修改
你正在使用的代码

00:18:07.921 --> 00:18:09.690
那么 让我们在布局中应用吧

00:18:11.024 --> 00:18:13.760
嗯 我们可以这样写出
布局中的级联部分

00:18:14.294 --> 00:18:16.296
使用所列出的子布局的一个数组

00:18:17.631 --> 00:18:20.634
然后 我们想用
DecoratingLayout构成布局

00:18:20.934 --> 00:18:22.436
获得最终效果

00:18:23.837 --> 00:18:26.440
但是还有另外一个
小东西需要改变

00:18:26.507 --> 00:18:28.542
这些布局只能有UI视图

00:18:28.609 --> 00:18:30.344
或SK节点的的子布局

00:18:31.211 --> 00:18:34.681
让我们推广一下 这样我们可以使用
布局并把它们合成到一起

00:18:37.184 --> 00:18:40.787
我们为子布局使用的布局协议
需要一个框架属性

00:18:41.355 --> 00:18:43.290
永远不需给那属性调用getter

00:18:43.357 --> 00:18:45.492
我们永远只需要给它设置新值

00:18:45.926 --> 00:18:48.762
我们并不关心子布局是否有框架

00:18:48.829 --> 00:18:50.731
我们只想使子布局

00:18:50.797 --> 00:18:52.699
在指定矩形中展示自己

00:18:53.967 --> 00:18:56.270
因此 让我们改变一下方法

00:18:56.870 --> 00:18:58.705
当我们决定其中一个
子布局的矩形后

00:18:58.772 --> 00:19:01.175
我们将告诉那个子布局
要在那个矩形中展示

00:19:02.576 --> 00:19:05.579
UIView和SKNode仍会遵守
我们的协议

00:19:06.180 --> 00:19:09.650
当它们被要求在矩形中展示时
它们将用它来设置它们的框架

00:19:10.017 --> 00:19:13.420
但现在 我们也可以使布局
遵守这个协议

00:19:13.987 --> 00:19:15.522
它们已经知道如何布局

00:19:15.589 --> 00:19:17.958
当给它们一个框架时
它们只需要分割那个矩形

00:19:18.025 --> 00:19:19.593
并提供给子布局

00:19:21.728 --> 00:19:24.932
我们现需稍微
变更一下DecoratingLayout

00:19:24.998 --> 00:19:27.901
允许它在子布局的类型上
有更多的灵活性

00:19:28.168 --> 00:19:30.637
我们稍后会进行详细解释

00:19:32.406 --> 00:19:34.241
现在 我们能创建
我们喜欢的布局了

00:19:34.308 --> 00:19:37.744
通过把CascadingLayout
和装饰布局

00:19:38.078 --> 00:19:39.880
合成到一起

00:19:42.916 --> 00:19:45.752
这种合成可以使我们
以一种声明的方式

00:19:45.819 --> 00:19:47.254
创建这样的高级布局

00:19:47.855 --> 00:19:50.490
示例代码中还有更多的例子

00:19:51.458 --> 00:19:53.060
当你创建自己的应用时

00:19:53.126 --> 00:19:56.196
当你需要重新使用代码
或自定义一些行为时

00:19:56.530 --> 00:19:58.565
请尝试用合成 这个工具很好用

00:20:01.969 --> 00:20:04.371
那么我之前提到了我们添加

00:20:04.438 --> 00:20:05.772
布局内容

00:20:05.839 --> 00:20:08.041
到超级视图或
SpriteKit场景中

00:20:08.709 --> 00:20:11.979
重点之一就是以正确的顺序
添加这些内容

00:20:13.080 --> 00:20:16.283
比如 我们的CascadingLayout
希望它的子布局按一定的顺序排列

00:20:16.350 --> 00:20:19.186
这样可以显示成一竖排 一个在
另一个的上面 就像这样

00:20:20.721 --> 00:20:23.790
我们可以扩展协议
来支持这种需要

00:20:24.691 --> 00:20:26.593
我们将在布局协议中添加一个属性

00:20:27.094 --> 00:20:28.829
返回它的内容

00:20:29.796 --> 00:20:32.366
我们的合成布局将以正确顺序

00:20:32.432 --> 00:20:33.800
返回所有内容

00:20:34.468 --> 00:20:37.171
然后叶视图和节点只返回自己

00:20:38.872 --> 00:20:42.509
但又一次 如果我们只把内容类型
作为协议

00:20:42.843 --> 00:20:45.212
就会允许产生混合环境

00:20:45.279 --> 00:20:46.780
作为内容的UI视图和SK节点

00:20:47.648 --> 00:20:49.716
因为我们把这些子布局
添加到了父布局

00:20:49.783 --> 00:20:51.818
我们只想实现同类集合

00:20:51.885 --> 00:20:54.321
只有UI视图或只有SK节点

00:20:56.356 --> 00:20:59.426
为了强制实现这个目标 我们可以
向协议中添加一个关联类型

00:21:00.394 --> 00:21:02.563
关联类型就像是一个类型占位符

00:21:03.130 --> 00:21:06.233
一致的类型选择想要使用的
具体类型

00:21:07.367 --> 00:21:10.037
协议的关联类型是我们要放在

00:21:10.103 --> 00:21:12.139
布局内容的数组中的类型

00:21:13.807 --> 00:21:16.877
这就允许我们写出一些
只知道如何展示视图

00:21:16.944 --> 00:21:19.313
并指定其内容类型
为UIView的代码

00:21:20.280 --> 00:21:24.051
类似的 我们也可以写出只有
SK节点作为内容的布局

00:21:25.018 --> 00:21:26.753
这种类型的安全性非常好

00:21:26.820 --> 00:21:30.824
跟以前一样 我们不想
通过布局的通用版本

00:21:32.359 --> 00:21:34.194
分别给视图和节点写布局

00:21:34.261 --> 00:21:36.830
我们仍然拥有支持
两者的单一布局

00:21:37.664 --> 00:21:38.899
对于内容类型

00:21:39.132 --> 00:21:41.401
我们只使用子布局的内容
无论内容是什么

00:21:42.769 --> 00:21:44.838
意思是我们可以创建
DecoratingLayout

00:21:44.905 --> 00:21:48.408
要么只能跟UI视图一起使用
要么只能跟SK节点一起使用

00:21:48.842 --> 00:21:51.678
这两个都是强型的
因此我们可以取出它们的内容

00:21:51.745 --> 00:21:53.080
并准确地了解它们

00:21:53.580 --> 00:21:55.549
它们仍然可以共享
所有的布局逻辑

00:21:56.583 --> 00:22:00.354
相关类型是使协议变得
更健壮的一个好方法

00:22:05.459 --> 00:22:07.528
现在我们改进了布局协议

00:22:07.594 --> 00:22:10.731
我们还可重新访问
DecoratingLayout的子布局类型

00:22:11.565 --> 00:22:13.634
在这里
我们需要它们是同一种类型

00:22:13.867 --> 00:22:16.236
如果都是UI视图
用起来没问题

00:22:16.904 --> 00:22:20.007
但若我们想把CascadingLayout
和UIView一起用就不行了

00:22:20.240 --> 00:22:22.409
就像我们之前在合成
中谈到的那样

00:22:23.744 --> 00:22:27.247
我们真正想要的是使所有内容
都拥有同一种类型

00:22:28.282 --> 00:22:30.250
让我们更新一下布局

00:22:31.451 --> 00:22:35.055
我们可以改变结构 使它有两个
不同的通用类型参数

00:22:35.722 --> 00:22:37.291
每个子布局一个

00:22:38.292 --> 00:22:41.528
然后 我们还可以添加
通用限制来要求

00:22:41.595 --> 00:22:43.997
那两种类型有同种类型的内容

00:22:44.531 --> 00:22:47.334
这就使我们准确地表达出了限制条件

00:22:47.601 --> 00:22:49.770
子布局的内容必须是同一个类型的

00:22:52.306 --> 00:22:53.907
这就是我们完成的协议

00:22:54.007 --> 00:22:56.009
表达了我们的布局抽象

00:22:56.443 --> 00:22:59.079
比我们之前那个协议要好得多

00:22:59.279 --> 00:23:00.480
这个协议有实际意义

00:23:00.981 --> 00:23:02.549
它是一整套操作

00:23:02.850 --> 00:23:05.752
表达了它作为布局进程
的一部分的意义

00:23:06.753 --> 00:23:09.389
你还可以查看我们的示例应用
了解一切运作的

00:23:09.456 --> 00:23:10.657
详细信息

00:23:10.791 --> 00:23:12.326
包括我们如何用它

00:23:12.426 --> 00:23:15.162
在后台线程上实现
渲染图片的布局

00:23:16.830 --> 00:23:18.832
我们可以利用新布局协议的最后一点

00:23:18.899 --> 00:23:21.101
就是单元测试

00:23:22.603 --> 00:23:24.771
我们可以写一个有框架属性的结构

00:23:25.472 --> 00:23:27.207
使结构服从我们的布局协议

00:23:27.841 --> 00:23:30.611
然后我们可以改变单元测试
在单元测试中使用这个结构

00:23:30.677 --> 00:23:32.679
而不是使用布局中作为
子布局的UI视图

00:23:33.814 --> 00:23:36.850
现在 布局只会在这些
简单的结构上设置框架

00:23:38.252 --> 00:23:41.054
意思就是 我们的测试
跟UIView是完全隔离的

00:23:41.321 --> 00:23:44.825
并且只依赖于我们自己的布局
和测试结构的逻辑

00:23:45.993 --> 00:23:48.562
我们在不使用GUI的情况下
对布局进行单元测试

00:23:49.129 --> 00:23:50.564
我认为Crusty一定感到自豪

00:23:58.472 --> 00:24:02.643
这些是如何
在应用的视图层以一种

00:24:02.709 --> 00:24:05.612
你想象不到的方式
使用类型和协议的一些示例

00:24:06.446 --> 00:24:08.715
我们还了解了一些不错的
通用Swift技巧

00:24:08.782 --> 00:24:10.284
你可以随意应用

00:24:11.285 --> 00:24:13.820
首先 我们了解了如何
通过使用值类型

00:24:13.887 --> 00:24:15.022
改进局部推理

00:24:15.956 --> 00:24:18.292
然后我们了解了
如何使用通用类型

00:24:18.392 --> 00:24:20.561
来得到更好的类型安全
和灵活的代码

00:24:21.628 --> 00:24:24.765
我们还了解了值的合成
对于自定义

00:24:24.831 --> 00:24:28.135
和创建复杂的行为来说
是个多么棒的工具

00:24:29.002 --> 00:24:31.338
现在让我们欢迎Alex
回到台上 谈一下

00:24:31.405 --> 00:24:32.906
我们对应用中控制器的处理

00:24:42.749 --> 00:24:43.750
谢谢Jacob

00:24:44.518 --> 00:24:47.955
现在我想重点谈一下我们如何
在控制器层中使用值类型

00:24:48.555 --> 00:24:52.426
让我们谈一下应用的撤销功能

00:24:54.995 --> 00:24:59.600
我们在梦想列表中实现了
撤销功能 很好用

00:25:00.901 --> 00:25:03.203
但我们注意到有个小漏洞

00:25:03.637 --> 00:25:06.406
就是不能撤销
最喜爱的创造物功能

00:25:07.074 --> 00:25:10.711
为了重现这个漏洞
我们可以轻触最喜爱的创造物

00:25:12.446 --> 00:25:15.549
目前有只粉色麒麟
是我们最喜爱的创造物

00:25:15.616 --> 00:25:17.484
现在让我们把它变成龙

00:25:19.219 --> 00:25:23.223
变更完成 我们只需要轻触
右上方的完成按钮即可

00:25:24.625 --> 00:25:27.628
好了 我们已经修改了
最喜爱的创造物

00:25:27.928 --> 00:25:31.365
但问题是 如果我们摇动设备
来撤销 什么也不会发生

00:25:32.432 --> 00:25:33.500
所以这是一个漏洞

00:25:33.967 --> 00:25:36.904
让我们看一下代码
看看为什么会这样

00:25:38.338 --> 00:25:41.508
目前 在视图控制器上
有两个模型属性

00:25:41.775 --> 00:25:44.912
一个是梦想的模型属性
一个是最喜爱的创造物的模型属性

00:25:45.913 --> 00:25:48.448
这在UIKit应用中
是个很典型的安排

00:25:48.715 --> 00:25:51.818
尤其是当模型增加和功能增加时

00:25:53.820 --> 00:25:57.024
再一次 我们只有梦想功能

00:25:57.324 --> 00:26:00.260
那么我们实现了撤销 这很棒

00:26:01.094 --> 00:26:03.864
但当我们添加
最喜爱的创造物功能后

00:26:04.064 --> 00:26:05.599
我们的撤销代码就不见了

00:26:06.967 --> 00:26:09.169
漏洞的产生是因为忘了添加那段代码

00:26:10.103 --> 00:26:12.906
要修复这个漏洞
我们可以添加另一个代码路径

00:26:13.807 --> 00:26:16.043
实现最喜爱的创造物的撤销功能

00:26:16.543 --> 00:26:18.512
听起来像是一个噩梦

00:26:18.579 --> 00:26:21.281
因为每次要添加
另一个模型属性时

00:26:21.849 --> 00:26:24.685
我们就不得不添加另一个
代码路径来实现撤销

00:26:25.285 --> 00:26:26.720
这很糟糕

00:26:27.654 --> 00:26:28.822
我们不希望这样

00:26:30.290 --> 00:26:31.992
我们往回退一步

00:26:32.059 --> 00:26:34.695
当我们添加更多的模型属性时

00:26:34.761 --> 00:26:36.897
想要找到一个更好的解决方案

00:26:38.866 --> 00:26:41.935
那么方案就是把这些
模型属性合成

00:26:42.135 --> 00:26:45.005
到一个单一值中
我们的模型结构

00:26:45.672 --> 00:26:49.142
撤销逻辑会按照
那一个类型单独运行

00:26:50.644 --> 00:26:54.014
请注意 模型仍然有值语义
这很重要

00:26:54.314 --> 00:26:56.884
那是因为它是由两个
别的值合成的

00:26:57.451 --> 00:26:59.887
这个方法很棒

00:26:59.987 --> 00:27:02.356
因为现在两个模型属性

00:27:02.689 --> 00:27:04.458
只有一个单一代码路径

00:27:04.525 --> 00:27:06.460
如果我们添加另一个模型属性

00:27:06.527 --> 00:27:08.262
我们仍然有一个代码路径

00:27:08.662 --> 00:27:10.030
这很棒

00:27:14.134 --> 00:27:17.504
我们可以通过把两个
模型属性挪到视图控制器上的

00:27:17.571 --> 00:27:20.440
新模型结构中实现

00:27:21.642 --> 00:27:25.245
这样 我们要做的就是向
视图控制器添加新的模型属性

00:27:27.047 --> 00:27:28.815
这也是我们的构造方式

00:27:28.882 --> 00:27:30.784
但现在 我们需要实现撤销代码

00:27:31.318 --> 00:27:32.452
我们如何实现呢？

00:27:33.020 --> 00:27:35.789
嗯 我首先要展示的是
常见的实现方式

00:27:35.856 --> 00:27:37.691
以及我们为何认为
这种方式有漏洞

00:27:39.526 --> 00:27:42.996
左侧是视图控制器的当前模型值

00:27:43.630 --> 00:27:46.433
右侧是运算和撤销堆栈

00:27:47.401 --> 00:27:49.203
在应用的原始版本中

00:27:49.336 --> 00:27:52.472
我们认为撤销堆栈
是一系列的小步骤

00:27:52.940 --> 00:27:56.043
每个步骤都能响应
对第一个模型的修改

00:27:56.310 --> 00:27:58.212
和匹配的视图

00:27:59.813 --> 00:28:01.882
比如 在第一个撤销步骤中

00:28:02.149 --> 00:28:04.618
我们要移除用户刚添加的梦想

00:28:04.918 --> 00:28:07.054
然后我们要从那个表视图中删除那一行

00:28:09.990 --> 00:28:12.292
然后继续下一个撤销步骤

00:28:13.994 --> 00:28:15.762
在这个撤销步骤中

00:28:16.363 --> 00:28:21.635
我们要把模型重新变回粉色麒麟

00:28:23.303 --> 00:28:26.106
那么这个分别修改并更新

00:28:26.173 --> 00:28:27.841
视图个体模型属性的方法

00:28:28.108 --> 00:28:29.743
很容易出错

00:28:29.810 --> 00:28:32.446
因为你需要精确地
匹配模型中的变更

00:28:32.513 --> 00:28:35.415
和视图中的变更

00:28:36.283 --> 00:28:39.386
如果失败会导致模型和视图

00:28:39.453 --> 00:28:41.255
之间的很多矛盾

00:28:41.889 --> 00:28:43.690
最后就会得到这样的漏洞

00:28:44.791 --> 00:28:47.027
我确定你们所有人都遇到过
这样的问题

00:28:47.094 --> 00:28:48.495
我总会遇到这样的问题

00:28:49.630 --> 00:28:51.098
很难进行调试

00:28:51.865 --> 00:28:53.367
为什么很难调试呢？

00:28:54.401 --> 00:28:55.836
嗯 让我们再看看

00:28:55.903 --> 00:28:58.005
我们最初的撤销堆栈

00:28:59.206 --> 00:29:01.942
这些不可撤销的变更
实际上是从哪儿来的呢？

00:29:03.510 --> 00:29:07.381
嗯 每个不可撤销的变更都来自
我们的视图控制器

00:29:07.881 --> 00:29:11.351
并且每个不可撤销的变更
都会影响顺序

00:29:12.653 --> 00:29:16.890
当我们向应用中添加功能时
出错的几率很大

00:29:18.025 --> 00:29:20.928
我们的代码中并没有可以

00:29:20.994 --> 00:29:24.164
让我们在模型和视图更新之间
推理一致性的地方

00:29:24.831 --> 00:29:26.834
这很不好 因为太复杂了

00:29:28.368 --> 00:29:32.272
让我们寻找一种更简单的方式
来处理撤销

00:29:34.842 --> 00:29:37.144
如果不记录小的变更

00:29:38.612 --> 00:29:41.381
堆栈中的每一条都只是个
完整的新值

00:29:41.682 --> 00:29:42.783
完整的新模型

00:29:43.250 --> 00:29:44.818
现在 在模型上

00:29:44.885 --> 00:29:46.420
实施撤销就非常简单了

00:29:47.020 --> 00:29:49.723
只需要用堆栈上的模型
替换当前模型即可

00:29:50.390 --> 00:29:52.893
这样我们就不用再担心
顺序问题了

00:29:53.827 --> 00:29:55.395
然后我们只替换值

00:29:57.698 --> 00:29:59.766
这样我们就解决了模型的问题

00:29:59.833 --> 00:30:02.336
我们还要解决如何更新
UI的问题

00:30:04.171 --> 00:30:07.474
在视图控制器中 无论什么时候
只要模型发生变更

00:30:07.541 --> 00:30:09.877
我们就调用
modelDidChange方法

00:30:10.811 --> 00:30:13.313
我建议你下载这个示例

00:30:13.380 --> 00:30:16.617
了解这个方法具体是如何
运作的更多信息

00:30:17.684 --> 00:30:19.753
在那个方法中
我们需要找到

00:30:19.820 --> 00:30:21.922
新旧模型值之间的不同点

00:30:22.189 --> 00:30:23.590
并更新我们的UI进行匹配

00:30:24.625 --> 00:30:26.793
比如 我们可以查看

00:30:26.860 --> 00:30:29.630
旧模型中最喜爱的创造物
是不是跟

00:30:29.897 --> 00:30:31.932
新模型中最喜爱的创造物不一样

00:30:32.999 --> 00:30:35.536
如果不一样 我们就更新表视图中

00:30:35.602 --> 00:30:38.472
包含最喜爱的创造物的那一行

00:30:40.541 --> 00:30:43.944
在对象中有一个更好的实现

00:30:44.011 --> 00:30:46.346
就像我刚提到的那样
我建议你查看

00:30:46.413 --> 00:30:47.915
关于更新UI的更多信息

00:30:49.983 --> 00:30:52.386
最后 我们只需要注册撤销逻辑

00:30:52.920 --> 00:30:54.988
把模型重设为旧值

00:30:55.589 --> 00:30:58.225
这很棒
因为我们现在只需要一个

00:30:58.292 --> 00:31:01.028
或者说我们只需要在一个地方
注册撤销

00:31:03.730 --> 00:31:05.265
这有什么好处呢？

00:31:05.799 --> 00:31:09.236
正如我们所看到的 为了更新UI
我们生成了一个单一代码路径

00:31:09.603 --> 00:31:11.738
所有操作都按顺序独立进行

00:31:12.005 --> 00:31:13.574
以前并不是这样的

00:31:14.241 --> 00:31:16.810
这能帮助我们对代码进行局部推理

00:31:17.211 --> 00:31:18.879
和UI更新代码

00:31:20.480 --> 00:31:24.084
我们还能了解值之间是如何
恰如其分地组合在一起的

00:31:24.885 --> 00:31:28.388
如果单一值的属性有两个值

00:31:28.856 --> 00:31:31.191
那个值仍然会有值语义

00:31:37.497 --> 00:31:41.168
好了 让我们谈谈如何
在有模型属性的控制器层

00:31:41.235 --> 00:31:44.137
使用值类型

00:31:44.671 --> 00:31:46.039
在控制器的UI状态属性中

00:31:46.173 --> 00:31:48.242
我想实现同样的功能

00:31:49.810 --> 00:31:51.645
你以前看过这个屏幕

00:31:51.812 --> 00:31:53.914
这是梦想列表

00:31:54.381 --> 00:31:57.217
但这个视图控制器有许多不同的状态

00:31:57.818 --> 00:31:59.853
我要给你们展示视图控制器的状态图

00:31:59.920 --> 00:32:03.390
因为它跟我们一个很酷的功能有关

00:32:03.624 --> 00:32:05.526
就是和朋友分享梦想

00:32:06.460 --> 00:32:07.661
让我们来看一下

00:32:09.296 --> 00:32:10.964
这是基本状态图

00:32:13.267 --> 00:32:15.836
我们要从浏览状态开始

00:32:17.504 --> 00:32:19.706
轻触顶部的分享按钮

00:32:19.773 --> 00:32:21.875
将会把我们带入选择状态

00:32:23.210 --> 00:32:25.179
然后选择要分享的梦想

00:32:26.380 --> 00:32:29.383
然后轻触完成按钮返回分享状态

00:32:34.121 --> 00:32:36.957
分享完成后
我们会回到浏览状态

00:32:38.625 --> 00:32:39.927
用起来很流畅

00:32:40.661 --> 00:32:43.263
但让我们再快速返回选择状态

00:32:43.931 --> 00:32:47.668
你会注意到 我们可以通过轻触

00:32:47.734 --> 00:32:50.037
左上角的取消按钮停止分享

00:32:53.640 --> 00:32:55.876
这将把我们带回浏览状态

00:32:56.543 --> 00:32:58.946
你会看到导航栏看起来
显示的是正确的

00:32:59.313 --> 00:33:01.281
因为它又显示分享按钮了

00:33:01.915 --> 00:33:03.917
但其实在应用中有一个很小的UI漏洞

00:33:03.984 --> 00:33:05.886
是由一种不一致状态导致的

00:33:07.487 --> 00:33:09.857
表视图左侧的UI

00:33:10.057 --> 00:33:13.961
仍然可见 并仍然允许用户选择
梦想并分享 这样是不对的

00:33:15.495 --> 00:33:17.397
当我们返回去调试这段代码时

00:33:17.464 --> 00:33:19.967
我们看到某些状态属性

00:33:20.133 --> 00:33:22.669
在状态变更时并没有被全部清除

00:33:23.737 --> 00:33:26.840
在这种情况下
即使我们进入了浏览状态

00:33:26.907 --> 00:33:28.909
我们忘记去清除选择状态的

00:33:28.976 --> 00:33:30.377
某些属性

00:33:31.311 --> 00:33:35.048
让我们再看看状态图
看是否修复了这个问题

00:33:37.985 --> 00:33:41.054
这里的每个状态都有相应的属性

00:33:41.822 --> 00:33:44.691
并且这些属性是视图控制器上的属性

00:33:46.360 --> 00:33:49.730
状态属性的个数

00:33:49.897 --> 00:33:52.466
随着应用功能的增加
视图控制器中的

00:33:52.533 --> 00:33:54.801
增长可能会很迅速

00:33:55.502 --> 00:33:59.873
在这种情况下 重点是我们的属性
是相互排斥的

00:34:01.542 --> 00:34:03.510
那么 当我们浏览时
我们就不分享

00:34:03.577 --> 00:34:05.846
当我们分享时 我们就不选择

00:34:07.381 --> 00:34:10.284
但是 我们写这段代码的方式是
当你设置一个属性时

00:34:10.350 --> 00:34:12.418
你需要清除其他所有属性

00:34:12.485 --> 00:34:13.987
这很容易出错

00:34:15.222 --> 00:34:16.924
我们要如何解决这个问题呢？

00:34:17.391 --> 00:34:21.460
嗯 枚举非常适合处理
相互排斥的值

00:34:23.297 --> 00:34:27.835
我们把所有UI状态属性
都转成了枚举值

00:34:29.036 --> 00:34:32.272
然后 我们只需要通过使用枚举
把状态属性添加到视图控制器即可

00:34:34.641 --> 00:34:38.846
 我们可以确保
状态是相互排斥的

00:34:39.478 --> 00:34:42.949
这很棒
因为我们之前发现的无效状态漏洞

00:34:43.016 --> 00:34:46.119
现已不可能再发生了
因为它受类体系的迫使

00:34:47.721 --> 00:34:50.556
这个方案也意味着
我们的状态变更

00:34:50.858 --> 00:34:54.494
是突然发生的
不需要任何可能的中间状态

00:34:54.828 --> 00:34:59.566
因此
我们不需要协调该死的属性

00:34:59.933 --> 00:35:01.702
和隐含的时间依赖性

00:35:03.437 --> 00:35:05.873
此外 使状态多合一

00:35:05.939 --> 00:35:07.774
更容易以用户

00:35:07.941 --> 00:35:10.310
上次离开时的完全相同的
状态启动应用

00:35:10.410 --> 00:35:14.047
我真心推荐你们再次查看
和下载这个项目

00:35:14.114 --> 00:35:17.317
看我们是如何在应用中
实现状态修复的

00:35:20.220 --> 00:35:22.256
好了 我们今天讲了很多内容

00:35:23.490 --> 00:35:28.195
开始讲了
改进应用中的局部推理

00:35:28.495 --> 00:35:31.098
通过把值类型和协议引入

00:35:31.164 --> 00:35:33.667
到基于模型视图控制器的应用

00:35:34.301 --> 00:35:35.769
我们是如何实现的？

00:35:36.870 --> 00:35:39.873
开始是通过把梦想类型做成结构

00:35:40.107 --> 00:35:41.742
使模型有值语义

00:35:42.709 --> 00:35:45.612
使我们更容易对代码
进行局部推理

00:35:45.979 --> 00:35:48.916
因为我们的梦想变量
没有隐含的分享

00:35:50.851 --> 00:35:53.487
然后Jacob展示了
如何创建小组件

00:35:53.720 --> 00:35:56.056
如DecoratingLayout
和CascadingLayout

00:35:57.024 --> 00:36:00.661
这些小组件利用了通用协议

00:36:00.727 --> 00:36:04.798
确保通用组件可以在视图、
中重新使用

00:36:05.165 --> 00:36:07.301
SpriteKit节点和图形渲染

00:36:08.035 --> 00:36:10.270
这使我们得到了更好的局部推理

00:36:10.404 --> 00:36:14.975
因为每个类型都是小的、
可测试的、分离的值类型

00:36:18.512 --> 00:36:21.882
然后我们了解了如何利用
视图控制器上的模型属性

00:36:22.082 --> 00:36:24.318
合成到单一类型中

00:36:25.152 --> 00:36:28.455
这使我们更容易用单一
代码路径实现撤销

00:36:29.122 --> 00:36:31.992
即使我们的模型类型
有更多的属性

00:36:33.160 --> 00:36:37.631
这个方案还给了我们一个
更新UI的代码路径

00:36:37.998 --> 00:36:40.300
使我们更容易理解

00:36:40.734 --> 00:36:42.636
独立视图控制器的UI逻辑

00:36:45.005 --> 00:36:49.343
最后 我们了解了如何把相互
排斥的状态属性转成

00:36:49.409 --> 00:36:51.979
视图控制器上的枚举值

00:36:52.446 --> 00:36:56.183
这降低了UI为不一致
状态的潜在几率

00:36:57.217 --> 00:37:01.788
并且这也是我们今天
讨论的值类型

00:37:02.890 --> 00:37:05.325
但是 如果你下载示例项目

00:37:05.792 --> 00:37:08.629
你将看到项目中的更多信息

00:37:10.163 --> 00:37:13.767
而且我们整个应用也使用了很多值类型

00:37:13.834 --> 00:37:17.437
除了我们需要用控制器
或视图对象的地方

00:37:18.338 --> 00:37:21.008
现在 UIKit要求把这些
作为引用类型

00:37:21.308 --> 00:37:26.013
但是我们仍然把绝大多数功能
挪到了值类型中

00:37:29.550 --> 00:37:33.153
我们今天讲了很多 我希望你回家

00:37:33.220 --> 00:37:36.356
的时候头脑里要记得这几点

00:37:38.492 --> 00:37:41.495
第一是通过合成而不是继承

00:37:41.895 --> 00:37:44.231
进行自定义

00:37:45.065 --> 00:37:46.667
你再坐在办公桌旁

00:37:47.067 --> 00:37:50.103
绘制类图来解决问题时

00:37:51.338 --> 00:37:54.241
我希望你考虑如何使用合成

00:37:54.641 --> 00:37:56.977
而不是继承来解决那个问题

00:37:57.344 --> 00:38:00.280
这样你就能获得我们今天讲到的
值类型的各种好处了

00:38:01.849 --> 00:38:05.552
第二个技巧是给通用的可重复
使用的代码使用协议

00:38:06.620 --> 00:38:09.423
你可以做可重复使用的小组件

00:38:09.489 --> 00:38:12.359
很容易进行局部推理和测试

00:38:13.060 --> 00:38:15.062
我强烈建议你们查看

00:38:15.128 --> 00:38:17.264
我们是如何用通用类型而不是类层次

00:38:17.331 --> 00:38:21.201
在那个示例中实现的

00:38:23.637 --> 00:38:26.607
我们还展示了如何利用值语义

00:38:27.274 --> 00:38:28.909
需要记住的重点是

00:38:29.076 --> 00:38:33.146
如果有由其他属性组成的值

00:38:33.714 --> 00:38:36.183
较大的值也会有值语义

00:38:38.418 --> 00:38:40.787
最后 我们谈了局部推理

00:38:42.155 --> 00:38:45.459
局部推理实际上是个
非常通用的技巧

00:38:45.592 --> 00:38:50.464
并不是UI编程专用的

00:38:50.597 --> 00:38:54.601
也不是移动开发专用的
也不是Swift专用的

00:38:55.335 --> 00:38:57.237
这是所有编程语言的

00:38:57.304 --> 00:39:00.541
一个非常重要的方面

00:39:01.408 --> 00:39:04.111
当你回到办公室并开始编码时

00:39:04.545 --> 00:39:06.647
我希望你思考 无论是哪种语言

00:39:07.114 --> 00:39:10.484
如何使用那块代码
看那块代码如何支持局部推理

00:39:11.618 --> 00:39:17.658
Swift如此强调值类型
绝不是偶然

00:39:17.991 --> 00:39:20.394
因为它们是个非常重要的方面

00:39:20.761 --> 00:39:23.497
可以让你对代码进行局部推理

00:39:26.600 --> 00:39:27.501
就是这样了

00:39:27.801 --> 00:39:31.371
你可以从这里找到示例代码
和更多相关资源

00:39:31.438 --> 00:39:33.073
我强烈建议你们这样做

00:39:34.374 --> 00:39:37.444
我们还有一些相关演讲
我们在演讲中也提到了

00:39:37.878 --> 00:39:39.680
我建议你们观看相关视频

00:39:40.180 --> 00:39:42.749
谢谢大家 希望你们在
WWDC期间过得愉快

00:00:19.386 --> 00:00:22.389
优化应用的网页内容

00:00:22.456 --> 00:00:23.290
大家好

00:00:27.427 --> 00:00:29.763
欢迎来到“优化应用的网页内容”

00:00:29.830 --> 00:00:31.398
我是Jonathan Davis

00:00:31.465 --> 00:00:34.168
网络技术的推广人
负责Safari和WebKit

00:00:34.902 --> 00:00:37.271
现在我要先说明一些事情

00:00:38.172 --> 00:00:40.707
很多人说我长得像
Edward Snowden

00:00:40.774 --> 00:00:42.309
但我向你保证 我不是他

00:00:43.210 --> 00:00:46.947
但这么多卫星在头顶盘旋
大概都是来抓我们的

00:00:47.915 --> 00:00:50.751
除此之外 我很激动地要展示些新东西

00:00:50.817 --> 00:00:53.787
它们可以帮助你
提升应用网页内容的性能

00:00:54.288 --> 00:00:56.323
我们一直都知道

00:00:56.390 --> 00:00:59.326
性能是提供最佳用户体验的关键

00:00:59.393 --> 00:01:04.431
若你是个应用开发者并在应用里用了
WebViews和JSContext

00:01:05.364 --> 00:01:07.901
而且你很关心性能
那你就来对地方了

00:01:08.569 --> 00:01:09.970
说到性能

00:01:10.304 --> 00:01:14.074
在当今时代里
性能其实就是指电池寿命

00:01:14.141 --> 00:01:17.411
我认为电池寿命是最终的有限资源

00:01:17.845 --> 00:01:20.280
它带来很不同的结果
如果你能拨出最后一通电话

00:01:20.347 --> 00:01:23.717
或者发出最后一份重要的文件
在电池耗光之前

00:01:24.218 --> 00:01:26.420
性能对用户来说
事关重大

00:01:26.753 --> 00:01:29.389
他们所选择的应用
不会让设备变慢

00:01:29.456 --> 00:01:30.724
而且耗电量低

00:01:31.692 --> 00:01:35.596
我们的经验就是
根据用户的反馈和各自的体会

00:01:35.662 --> 00:01:38.966
性能很重要
因为电池寿命事关重大

00:01:40.400 --> 00:01:44.104
所以今年我们致力于
提供更好的工具

00:01:44.171 --> 00:01:46.640
来找到和修复
网页内容的性能问题

00:01:47.207 --> 00:01:49.510
现在我们为应用提供了工具
比如Swift

00:01:49.576 --> 00:01:51.778
还有Objective-C代码
比如Instruments

00:01:52.312 --> 00:01:56.049
我们还提供了网络检查器
帮助网页开发者创建网页和网站

00:01:57.017 --> 00:01:59.286
但不要觉得
因为你选择了

00:01:59.353 --> 00:02:02.422
在应用中用网络技术
就没有其他工具可用了

00:02:02.489 --> 00:02:05.259
实际上
我今天展示给你的所有工具

00:02:05.325 --> 00:02:07.427
就是开发给人们
既能帮助他们建设网站

00:02:07.494 --> 00:02:10.430
也能让他们在应用里
用网络技术

00:02:11.265 --> 00:02:12.566
那么我首先要
向你展示

00:02:12.633 --> 00:02:15.936
如何把网络检查器连接到
JSContext的WebViews

00:02:16.003 --> 00:02:18.505
这样在你需要它的时候
它就会立刻出现

00:02:19.540 --> 00:02:21.375
之后你会了解
一些新的功能

00:02:21.441 --> 00:02:25.479
它们能让你了解JavaScript代码
如何分配时间

00:02:25.546 --> 00:02:29.650
以及这些新功能
如何帮你迅速找到性能上的问题

00:02:30.651 --> 00:02:34.955
如果你想要看到
网络内容的内存使用情况

00:02:35.022 --> 00:02:38.392
我们也给网络检查器增添了新的时间线
我都已等不及想展示了

00:02:38.592 --> 00:02:41.562
它们会帮你节省很多时间
来找到内存过大的问题

00:02:41.995 --> 00:02:43.797
准备好了？
那就开始吧

00:02:45.032 --> 00:02:46.333
第一件
我们要做的事

00:02:46.400 --> 00:02:48.769
是把网络检查器
连接到应用里

00:02:49.469 --> 00:02:52.840
在应用里使用网络技术
有很多原因

00:02:53.574 --> 00:02:56.276
如JS context里的
一些JavaScript模块

00:02:56.343 --> 00:02:59.980
可以让你轻松交换逻辑
并无编译地添加新的模块

00:03:00.747 --> 00:03:05.419
可能有些人正在tvOS应用里
使用TVML的 JSContext

00:03:06.053 --> 00:03:09.690
另外一个使用网络技术的原因
就是你要显示的网页内容

00:03:10.157 --> 00:03:12.059
比如第三方网站的
一个网页

00:03:12.459 --> 00:03:13.727
这个网站
你不能控制

00:03:14.027 --> 00:03:16.663
可能就要用到Safari视图控制器

00:03:16.730 --> 00:03:18.398
如果不是
你也许可以去听听

00:03:18.465 --> 00:03:21.602
去年的演讲
“介绍Safari视图控制器”

00:03:22.903 --> 00:03:26.106
但如果你显示的内容
是你自己的或者你可以控制的

00:03:26.173 --> 00:03:31.912
或是可自定义的HTML CSS
或JavaScript编写的内容

00:03:31.979 --> 00:03:34.281
或者是
可以提升应用体验的内容

00:03:34.615 --> 00:03:36.350
WKWebView
是最好的选择

00:03:36.717 --> 00:03:39.786
它实际上是个矩形
把网页内容拉入应用

00:03:40.354 --> 00:03:43.690
它引入了iOS 8
和OS 10 Yosemite

00:03:44.858 --> 00:03:47.561
若你还在使用WebView
或者UIWebView

00:03:47.828 --> 00:03:51.164
那你一定要考虑
升级到WKWebView

00:03:51.565 --> 00:03:54.735
事实上 升级到WKWebView
可以让你利用

00:03:54.801 --> 00:03:58.805
Nitro JavaScript
核心引擎和四级JIT编译器

00:03:58.872 --> 00:04:00.007
这能大大提升速度

00:04:00.741 --> 00:04:02.743
若想了解更多WKWebView信息

00:04:03.010 --> 00:04:07.314
我推荐2014年的演讲
介绍了现代化的WebKit API

00:04:08.282 --> 00:04:11.418
那么去年我们给WKWebView
添加了很多优秀的功能

00:04:11.485 --> 00:04:16.589
比如 加载文件URL和自定义用户代理字符串
还有WK网站数据存储API

00:04:17.858 --> 00:04:22.296
现今有了iOS 10和macOS Sierra
我们改进了3D-touch支持

00:04:23.063 --> 00:04:25.532
现在你的应用就可以执行这些好用的

00:04:25.599 --> 00:04:27.835
Peek和Pop事件
在WKWebView里

00:04:29.336 --> 00:04:31.438
就像我之前说的
因为你选了

00:04:31.505 --> 00:04:32.906
在应用里
应用网络技术

00:04:33.807 --> 00:04:35.142
并不意味着
你没有工具可用

00:04:35.209 --> 00:04:37.811
不论哪种情况
你可连接网络检查器

00:04:37.878 --> 00:04:40.214
发掘网页内容
或JavaScript活动情况

00:04:41.081 --> 00:04:44.985
但使用网络检查器前
你必须要激活develop菜单

00:04:45.219 --> 00:04:49.156
只要上传Safari设置
然后找到“高级”标签

00:04:49.356 --> 00:04:51.558
然后在底部
你会看到这个复选框

00:04:51.625 --> 00:04:53.961
写着在菜单栏显示Develop菜单

00:04:54.995 --> 00:04:56.730
那就点击它

00:04:56.964 --> 00:04:59.766
Develop菜单就会出现在
Safari的菜单栏里

00:05:01.735 --> 00:05:04.371
为让网络检查器
连接到iOS设备

00:05:04.438 --> 00:05:06.073
你要开启一个设置

00:05:06.607 --> 00:05:10.210
在iOS的设置应用里
点击Safari

00:05:10.511 --> 00:05:16.016
然后拉到底部 点击“高级”
然后把检查器设置打开

00:05:16.884 --> 00:05:18.652
现在你就可以
把设备连到Mac上

00:05:18.719 --> 00:05:20.654
在Safari里
检查Develop菜单

00:05:22.356 --> 00:05:24.558
Develop菜单里
有些很酷炫的东西

00:05:24.625 --> 00:05:26.627
你之前可能
从未注意到过

00:05:26.693 --> 00:05:28.962
就是你能看到设备的列表

00:05:29.029 --> 00:05:32.866
这里有已连接的iPhone
MacBook Pro和模拟器

00:05:33.500 --> 00:05:36.837
要连接一个设备
并开始使用这些工具

00:05:36.904 --> 00:05:39.206
进行调试
那么只要选择Device菜单

00:05:39.473 --> 00:05:43.377
就会收到 当前设备上运行的
WebViews和JSContexts 的列表

00:05:44.411 --> 00:05:46.580
这里的Mac应用
并没有使用WebKit

00:05:46.647 --> 00:05:48.015
而用JavaScript

00:05:48.148 --> 00:05:50.651
所以我可以直接连接它
并使用工具

00:05:51.585 --> 00:05:56.190
iOS里的应用只会出现在
用Xcode创建和运行的时候

00:05:56.924 --> 00:06:00.194
但是说到Mac应用
你还要做一件事

00:06:01.261 --> 00:06:05.299
就是保持应用的完整性
我们不会让任何人下载你的应用

00:06:05.365 --> 00:06:08.168
并用网络检查器
巡查你的应用

00:06:08.669 --> 00:06:10.103
所以你要添加
这个授权

00:06:10.170 --> 00:06:12.272
到应用本地开发的
授权文件里

00:06:13.307 --> 00:06:15.542
你可能已经有了一个
授权文件

00:06:15.609 --> 00:06:17.477
如果没有
创建一个也很简单

00:06:17.544 --> 00:06:20.581
你只要创建新的plist
拓展名为.entitlements

00:06:20.914 --> 00:06:25.419
并且Xcode的创建设置里
定义一个代码签名的授权传递路径

00:06:26.753 --> 00:06:28.488
这个要在
开发的时候添加

00:06:28.555 --> 00:06:30.791
之后在
运行应用的时候删除

00:06:31.792 --> 00:06:32.893
一旦有了这个授权

00:06:33.126 --> 00:06:35.395
你的设备和应用就
出现在Develop菜单

00:06:35.462 --> 00:06:36.496
这样就可以连接了

00:06:36.830 --> 00:06:42.669
轻松把网络检查器连接到
JSContext和WebViews上了

00:06:44.805 --> 00:06:47.674
我们已正常运行了
网络检查器和应用

00:06:48.675 --> 00:06:51.078
该谈谈网络检查器里
新功能了

00:06:51.144 --> 00:06:53.814
我想首先讲讲
分析JavaScript代码

00:06:53.881 --> 00:06:54.715
分析JavaScript

00:06:54.781 --> 00:06:57.584
JavaScript的分析器
已经存在挺长时间了

00:06:57.651 --> 00:06:59.620
今年它变得更好

00:06:59.686 --> 00:07:03.156
更有效率
能帮助你迅速找到

00:07:03.223 --> 00:07:05.392
哪里调出的JavaScript
成本最高

00:07:05.459 --> 00:07:06.660
原因很简单

00:07:07.628 --> 00:07:11.965
新的分析器采用了取样技术
不会影响性能

00:07:12.032 --> 00:07:13.734
比以前好太多

00:07:14.568 --> 00:07:17.504
我们的分析器
在编译器能用之前的时代

00:07:17.571 --> 00:07:18.739
实际是个翻译器

00:07:19.206 --> 00:07:23.143
但是现在我们有了
这个强大的四级JIT编译器

00:07:23.443 --> 00:07:26.947
那么这个分析器
就真正成为样本分析器

00:07:28.048 --> 00:07:31.518
样本分析器告诉你
代码把时间都用在哪里

00:07:31.752 --> 00:07:35.622
帮你解答
哪个代码占用的时间最多？

00:07:36.590 --> 00:07:39.059
它在运行程序中的取样
以每毫秒为单位

00:07:39.126 --> 00:07:40.594
并且短暂地
停顿执行

00:07:40.661 --> 00:07:43.130
并快照
所有正在运行的代码

00:07:44.598 --> 00:07:45.966
它还可以取样

00:07:46.033 --> 00:07:48.936
在代码运行于
JIT编译器所有四级的时候

00:07:49.002 --> 00:07:52.039
所以它的取样速度
跟你代码的实际速度差不多

00:07:52.873 --> 00:07:56.443
由于断点处理
会导致代码去优化

00:07:56.510 --> 00:07:57.978
我们暂时不管它们

00:07:58.545 --> 00:08:02.583
那么当你分析的时候
你就可以了解网页应用的真实性能

00:08:03.050 --> 00:08:06.854
使用样本分析器
对性能几乎没有损害

00:08:07.120 --> 00:08:10.157
这就意味着
当你分析代码的时候

00:08:10.657 --> 00:08:13.560
速度高达以前的30倍

00:08:14.361 --> 00:08:17.931
这就让代码分析过程
更快也更简单

00:08:17.998 --> 00:08:20.434
而且收到的数据
也更准确

00:08:21.869 --> 00:08:25.939
这个进步真令人振奋 因为我们团队
和网络检查器团队

00:08:26.006 --> 00:08:29.610
能利用它来发现
可以提升速度的地方

00:08:29.676 --> 00:08:31.044
就在网络检查器本身

00:08:32.412 --> 00:08:34.515
好了
现在我们有了样本分析器

00:08:34.581 --> 00:08:37.618
看看如何利用网络检查器
帮我们找到问题

00:08:38.519 --> 00:08:41.688
这个内容很多
但是可以简单的拆分开来

00:08:41.788 --> 00:08:43.991
更方便的是
这都是你已经熟悉的代码

00:08:44.958 --> 00:08:47.160
当我们说到
分析JavaScript时

00:08:47.227 --> 00:08:50.597
意思是在Events里
为JavaScript记录时间线

00:08:50.664 --> 00:08:52.399
这就是Events视图

00:08:52.733 --> 00:08:56.270
显示了一列单独而且具体的
JavaScript事件

00:08:56.570 --> 00:09:00.073
特别的是
这里都是D3库的代码

00:09:00.140 --> 00:09:02.910
所以它能更方便
调试代码

00:09:02.976 --> 00:09:05.612
和分析代码
在你正在使用的库里

00:09:06.346 --> 00:09:09.449
而且这里的每一条
都是代码运行的事件

00:09:09.716 --> 00:09:13.187
这是代码进出
JavaScript核心引擎的情况

00:09:14.087 --> 00:09:15.856
包括了
监听事件的回调

00:09:15.923 --> 00:09:19.193
比如动画框架的条目
是在请求动画框架处理器

00:09:20.160 --> 00:09:22.596
脚本评估条目
显示JavaScript文件

00:09:22.663 --> 00:09:24.331
的上传和首次评估

00:09:25.265 --> 00:09:27.234
这里还有一些
时间信息

00:09:27.701 --> 00:09:30.971
告诉你运行的代码
所花费的时间

00:09:32.039 --> 00:09:34.708
所以如果有哪个
超过了10或15毫秒

00:09:34.775 --> 00:09:36.343
你就快要打破

00:09:36.410 --> 00:09:38.812
60帧每秒的
流畅性能底线

00:09:40.647 --> 00:09:43.217
Events视图很有用
但是还有另一个视图

00:09:43.283 --> 00:09:46.119
是我们为你添加的
叫做Call Trees视图

00:09:46.553 --> 00:09:49.790
如果你用过其他分析工具
那么对这个应该很熟悉

00:09:51.225 --> 00:09:54.161
只要点击这个菜单
然后转换到Call Trees视图

00:09:55.429 --> 00:09:59.399
现在显示了调用堆栈里
函数的累计运行时间

00:10:00.133 --> 00:10:01.768
这个叫做Top Down视图

00:10:01.835 --> 00:10:04.137
你可以用它
深入发掘Call Tree

00:10:04.204 --> 00:10:06.707
来找到
耗费大量时间的热函数

00:10:07.774 --> 00:10:10.177
但我最喜欢的视图是
Bottom Up视图

00:10:12.513 --> 00:10:14.448
它能直接让我找到
最热的函数

00:10:14.515 --> 00:10:16.650
就是取样最频繁的函数

00:10:17.551 --> 00:10:19.319
这里罗列的
是调出的函数

00:10:19.386 --> 00:10:21.622
按照用时
从大到小分类

00:10:21.688 --> 00:10:26.593
它反转了Call Tree
让你能直接对比各个函数的耗时

00:10:27.861 --> 00:10:30.731
你能准确地看到
耗时最多的地方

00:10:32.332 --> 00:10:35.169
你可以展开这一条
并按照路径返回

00:10:35.235 --> 00:10:36.837
找到耗时最多的函数

00:10:37.471 --> 00:10:41.108
你就能知道这个成本最高的代码
是何时何地调出的

00:10:42.809 --> 00:10:45.312
那么关于这部分
有请我的同事

00:10:45.379 --> 00:10:46.980
Brian Burg
上台为大家展示

00:10:55.155 --> 00:10:57.858
谢谢你 Jon
样本分析器很好用

00:10:57.925 --> 00:11:00.494
因为它可以提取
十分复杂的内容

00:11:00.561 --> 00:11:03.564
并进行分析
让你看到十分精确的信息

00:11:03.630 --> 00:11:05.132
而且你可以让它
跑的更快

00:11:05.832 --> 00:11:09.469
为了给你们展示
我要用我制作的iPad应用

00:11:09.770 --> 00:11:12.139
叫做卫星跟踪器
在这里看看

00:11:15.676 --> 00:11:19.680
卫星跟踪器
会展示给你现在或任何时间

00:11:20.080 --> 00:11:21.615
卫星所在的位置

00:11:21.882 --> 00:11:24.618
你可以选择
地球上的不同地点

00:11:25.219 --> 00:11:26.787
也可以选择不同的卫星

00:11:28.222 --> 00:11:29.223
不同的时区

00:11:30.023 --> 00:11:30.858
这很棒吧

00:11:31.725 --> 00:11:33.460
如果你担心
头上盘旋的卫星

00:11:33.527 --> 00:11:36.330
要带个锡纸帽子以防万一
这个应用就是理想之选

00:11:37.064 --> 00:11:39.633
但是这里有个小问题

00:11:39.700 --> 00:11:44.071
如果很多卫星
或者很多卫星组件

00:11:44.137 --> 00:11:47.207
像这样挤爆了
那么帧率的波动会很大

00:11:47.674 --> 00:11:49.676
这肯定不是
60帧每秒

00:11:49.743 --> 00:11:50.878
它会一直波动

00:11:51.411 --> 00:11:53.981
这样就可以用
样本分析器来查找

00:11:54.047 --> 00:11:55.849
发生了什么
为什么这么慢

00:11:57.751 --> 00:12:03.257
我们要做的就是打开Safari
并进入Develop菜单

00:12:03.957 --> 00:12:06.026
找到这里的iPad
并连接上

00:12:07.594 --> 00:12:11.098
那么我要做的第一件事
就是进入Frames视图

00:12:11.164 --> 00:12:14.001
看看现在的位置
帧率如何

00:12:14.067 --> 00:12:16.069
那么开始记录

00:12:17.137 --> 00:12:18.572
我再转回iPad

00:12:19.373 --> 00:12:20.774
做点什么

00:12:22.876 --> 00:12:24.244
比如转动一下

00:12:25.746 --> 00:12:27.514
或者换一个卫星

00:12:29.383 --> 00:12:30.250
换个时区

00:12:30.884 --> 00:12:32.219
好了
现在回去看看

00:12:35.489 --> 00:12:36.723
好的
把这个缩小

00:12:37.424 --> 00:12:40.227
所有的性能
就都显示在这里了

00:12:40.294 --> 00:12:44.865
有的时候是60帧每秒
像左边这些

00:12:45.299 --> 00:12:47.367
在中间
则上下都有

00:12:47.434 --> 00:12:48.802
因为我们在
更改视图

00:12:49.136 --> 00:12:51.972
这一些
就太慢了

00:12:52.940 --> 00:12:55.042
我想知道
出了什么问题

00:12:56.710 --> 00:12:58.879
那么我就转到
Events视图

00:13:00.981 --> 00:13:03.283
点击JavaScript
和Events时间线

00:13:03.350 --> 00:13:06.019
重点看看
样本分析器的数据

00:13:07.955 --> 00:13:10.691
就像Jon之前演示的那样
这里的Events视图

00:13:10.757 --> 00:13:12.926
会显示所有
运行循环里的内容

00:13:12.993 --> 00:13:16.096
这个例子里
就是动画和模拟

00:13:16.163 --> 00:13:18.398
就是我们在
不断地渲染帧

00:13:18.465 --> 00:13:22.769
这不是很有用
因为无法找到耗时最多的地方

00:13:23.537 --> 00:13:25.939
那么我们转到
Call Trees视图

00:13:27.574 --> 00:13:30.844
这里我们看到Top Down
Call Tree

00:13:31.211 --> 00:13:35.849
集合显示了
所有的渲染帧

00:13:35.916 --> 00:13:37.484
都是最耗时的地方

00:13:38.352 --> 00:13:42.356
展开这个就能看到
D3有一个Timer函数

00:13:42.422 --> 00:13:45.893
它调出一些代码
画了一些场景

00:13:46.960 --> 00:13:49.863
这些场景包括
卫星

00:13:49.930 --> 00:13:52.099
和时间等

00:13:52.165 --> 00:13:56.303
这个很棒
能让我们了解代码在做什么

00:13:56.670 --> 00:13:59.373
但是如果要想找出
哪个函数最耗费

00:14:00.073 --> 00:14:02.376
最好还是去看
Bottom Up视图

00:14:04.044 --> 00:14:09.316
这里我们列出了所有函数
无论谁调用它们

00:14:09.917 --> 00:14:12.686
我们看到这个fillText

00:14:12.753 --> 00:14:15.322
和tangent
是最耗费的两个

00:14:15.422 --> 00:14:18.559
那为什么
会调出tangent呢？

00:14:18.792 --> 00:14:23.630
我们展开这一行
看看调令来源

00:14:23.830 --> 00:14:28.202
就在这里
是_plotSatellites

00:14:28.435 --> 00:14:33.273
好像正在计算转换
用来绘制地球

00:14:34.041 --> 00:14:35.876
好的
这些看着都很正常

00:14:36.443 --> 00:14:39.079
也许我该找出数学课本
让它算得快一点

00:14:40.314 --> 00:14:41.682
现在看看
fillText

00:14:41.748 --> 00:14:45.652
换个画面
回到这里的应用

00:14:46.320 --> 00:14:51.458
我们正在当前时间上绘制文本
也在每个数据点上绘制

00:14:52.492 --> 00:14:53.460
这说得通

00:14:53.527 --> 00:14:57.898
但是如果仔细看
我们实际上把这个时间画了两次

00:14:58.699 --> 00:15:00.000
这就有点奇怪

00:15:00.767 --> 00:15:03.403
所以我们展开这一行

00:15:04.238 --> 00:15:06.707
就能看到
调令来自哪里

00:15:07.975 --> 00:15:11.245
这里我们好像
一次画了两个不同的前景

00:15:11.778 --> 00:15:14.114
这大概
不是我们想要的

00:15:15.516 --> 00:15:17.284
那么来找找
哪儿出了问题

00:15:17.417 --> 00:15:20.120
如果像这样
画了两个前景

00:15:20.220 --> 00:15:23.290
那么我们的工作量
实际就是所需的两倍

00:15:24.858 --> 00:15:28.729
为了让你的记忆更清晰
记住我们有个平面地图

00:15:28.795 --> 00:15:31.431
然后有这个地球
它在转动

00:15:32.833 --> 00:15:36.303
那么
现在回到代码

00:15:37.771 --> 00:15:41.942
找一找是什么
控制着两个地图的切换

00:15:42.009 --> 00:15:43.010
估计哪里弄错了

00:15:46.513 --> 00:15:49.783
改变地点的时候
我们会让两个地球互换

00:15:51.051 --> 00:15:52.252
这是 updateLocation

00:15:52.819 --> 00:15:57.191
好的 因为已经有一个地图
就不再需要另一个

00:15:57.291 --> 00:16:00.494
这是有道理的
因为这里我们添加了隐藏类

00:16:00.561 --> 00:16:02.863
就为了不让它
显示出来

00:16:04.298 --> 00:16:07.701
这里在_globeMap
我们定义running值为真

00:16:07.768 --> 00:16:09.236
在整个运行中

00:16:09.603 --> 00:16:12.506
而且在place中声明
我们显示的不是_globeProjection

00:16:12.573 --> 00:16:13.407
这是对的

00:16:13.473 --> 00:16:15.042
当我们显示
平面地图

00:16:15.108 --> 00:16:17.144
我们不会显示地球
它也不会运行

00:16:18.178 --> 00:16:20.280
这个平面地图
看上去好像

00:16:20.347 --> 00:16:22.382
一直在运行
UI也在运行

00:16:22.516 --> 00:16:26.086
这也挺奇怪的

00:16:26.486 --> 00:16:28.655
那么我们回到地图
试着做点儿什么

00:16:32.192 --> 00:16:34.628
这里我们选择
这个数据组

00:16:35.762 --> 00:16:37.431
然后进入Earth

00:16:38.465 --> 00:16:43.237
它的帧率要好于
只做世界地图

00:16:43.303 --> 00:16:44.505
那么
这就很有道理

00:16:44.571 --> 00:16:47.574
我想我们在世界地图活动的时候
画了两张地图

00:16:47.641 --> 00:16:49.443
但是在平面地图的时候
只画了一个

00:16:49.510 --> 00:16:53.914
那么我们就在这里
改变这个条件

00:16:59.786 --> 00:17:01.288
糟糕
应该反过来

00:17:04.558 --> 00:17:08.996
好的 先停下
看看有没有修复

00:17:12.598 --> 00:17:14.001
回到iPad

00:17:15.502 --> 00:17:16.737
好的
这看上去很流畅

00:17:16.803 --> 00:17:17.671
来到这里

00:17:19.006 --> 00:17:19.839
恩 很好

00:17:22.041 --> 00:17:22.910
看上去不错

00:17:22.976 --> 00:17:25.913
那么我们再去检查
时间渲染

00:17:25.979 --> 00:17:29.249
看看是不是
60帧每秒

00:17:30.684 --> 00:17:32.386
那么
回到Frames视图

00:17:33.053 --> 00:17:37.024
然后开始记录
很不错

00:17:37.090 --> 00:17:40.160
我转动地球的时候
有点慢

00:17:40.227 --> 00:17:42.496
但稳定度
看上去...

00:17:42.563 --> 00:17:45.299
不错
绝对在60帧每秒以下

00:17:45.832 --> 00:17:49.736
在这里有一个条
只要低于它就是好的

00:17:52.940 --> 00:17:56.610
现在卫星跟踪器
快了很多

00:17:56.677 --> 00:17:58.779
我们就知道
什么时候带上帽子

00:17:58.946 --> 00:17:59.780
这很棒

00:18:00.247 --> 00:18:04.017
这就是个简单的例子
关于如何使用样本分析器

00:18:04.084 --> 00:18:07.788
来发现最繁忙的内容
并让它运行的更快

00:18:08.689 --> 00:18:12.893
下面Jon会跟大家讲讲
内存和分配

00:18:21.802 --> 00:18:22.636
谢谢 Brian

00:18:24.371 --> 00:18:27.074
你看到了
分析很迅速

00:18:27.274 --> 00:18:29.443
它能让你了解
代码的真实速度

00:18:29.510 --> 00:18:31.311
这样你就能
获得十分精确的数据

00:18:31.678 --> 00:18:34.448
再看看JavaScript
和Events时间线

00:18:34.948 --> 00:18:37.918
并用它们找到
缓慢的回调处理器和定时器

00:18:37.985 --> 00:18:40.454
或者在Events视图里
缓慢的脚本初始化

00:18:41.822 --> 00:18:44.157
请用新的Call Trees视图
来了解耗时

00:18:44.224 --> 00:18:47.227
因为它们会沿着
你选择的时间线堆积起来

00:18:48.228 --> 00:18:50.464
记着Bottom Up
是你的新朋友

00:18:50.531 --> 00:18:54.201
它能帮助你找到
最需要优化的地方

00:18:55.869 --> 00:18:58.071
那么现在我们已经看过了
新的样本分析器

00:18:58.138 --> 00:19:00.574
和新的JavaScript
Call Trees视图

00:19:00.908 --> 00:19:04.611
我很激动能用更好的工具
来优化CPU时间

00:19:04.678 --> 00:19:06.513
这样就能给用户
快速的体验

00:19:06.580 --> 00:19:08.282
并帮他们
节省了电池

00:19:08.782 --> 00:19:10.551
这真的不错
现在我们继续

00:19:10.617 --> 00:19:12.219
看看性能的另一方面

00:19:12.586 --> 00:19:14.254
就是了解
内存都去哪儿了

00:19:15.189 --> 00:19:17.858
你肯定想更有效率地使用
网页内容的内存

00:19:17.925 --> 00:19:19.526
因为这是有限资源

00:19:19.960 --> 00:19:24.731
有效地使用内存可以
优化网页内容的比例

00:19:24.798 --> 00:19:26.600
并能处理
大型数据组

00:19:28.335 --> 00:19:32.472
而且内存占用过多会降低性能
我们并不想这样

00:19:33.273 --> 00:19:35.175
它也会让
你的网页内容崩溃

00:19:35.242 --> 00:19:36.777
这更非我们所愿

00:19:37.311 --> 00:19:41.682
好消息是若你运行WKWebView
它会以单独的进程运行

00:19:41.982 --> 00:19:43.450
不会让
整个应用崩溃

00:19:43.517 --> 00:19:45.752
但是这仍然不是
一个好的用户体验

00:19:46.286 --> 00:19:48.755
为了帮你解决这些问题
我们添加了两个新时间线

00:19:48.822 --> 00:19:50.557
给网络检查器
和Safari 10

00:19:51.859 --> 00:19:55.295
当启动新网络检查器
新时间线就默认关闭

00:19:55.362 --> 00:19:56.730
所以要打开它们

00:19:56.797 --> 00:19:59.633
你只要点击Edit
就在时间线上面

00:20:01.134 --> 00:20:03.704
就可以配置
自己想看的时间线

00:20:03.770 --> 00:20:06.673
这样就可以只研究
自己想用的那个

00:20:06.740 --> 00:20:08.342
就和Instruments应用一样

00:20:09.543 --> 00:20:12.946
只要开启新的时间线
就可以记录新的时间线了

00:20:13.280 --> 00:20:15.983
但你可能不想
让它们同时运行

00:20:16.550 --> 00:20:19.386
JavaScript和
Events时间线样本分析器

00:20:19.453 --> 00:20:21.188
虽然负载较少
但还是有

00:20:21.722 --> 00:20:24.491
而JavaScript Allocation
的时间线会添加更多进程

00:20:24.558 --> 00:20:27.761
在垃圾回收过程中
这会影响性能

00:20:28.428 --> 00:20:31.965
那我们就一直开着
Memory时间线

00:20:32.032 --> 00:20:35.002
那么在记录一个时间线的时候
你会看到这个

00:20:35.936 --> 00:20:39.907
这个新的Memory时间线图表
显示了内存如何分配

00:20:39.973 --> 00:20:42.342
到不同的目录里
在不同的时间

00:20:43.076 --> 00:20:44.878
这里有一系列图表

00:20:44.945 --> 00:20:48.515
帮你了解
内存的使用和划分

00:20:49.750 --> 00:20:52.319
Breakdown表显示了
内存如何分配给

00:20:52.386 --> 00:20:56.356
JavaScript和图画
和构成页面的分层

00:20:56.423 --> 00:20:58.825
以及其他
引擎相关的网页

00:21:00.060 --> 00:21:03.463
Max Comparison图
帮你研究内存高峰

00:21:03.530 --> 00:21:04.831
这里有一个高的水印

00:21:04.898 --> 00:21:07.401
帮你观察
过去的内存问题

00:21:07.467 --> 00:21:10.437
你甚至可以分离各个峰
通过选择一个特定的部分

00:21:10.504 --> 00:21:14.041
或者在一个峰值周围
选择一个特定的时间段

00:21:14.541 --> 00:21:17.945
然后你就可以使用
下面的目录分类

00:21:18.011 --> 00:21:20.180
来看看是什么
造成了大部分高峰

00:21:20.781 --> 00:21:23.784
这里的每个图表
都是独立测量的

00:21:23.851 --> 00:21:26.653
所以你可以清楚地看到
不同时间的变化

00:21:28.021 --> 00:21:30.591
JavaScript里的峰值
显示的是

00:21:30.657 --> 00:21:33.527
大量新对象
被创建和引用的地方

00:21:33.660 --> 00:21:36.763
其中包括的对象
有字符串对象和函数

00:21:37.164 --> 00:21:41.201
以及所有支持它们的引擎数据
比如结构数据和编译代码

00:21:41.902 --> 00:21:44.605
当你看到
JavaScript的用量下降

00:21:44.671 --> 00:21:47.241
就是说垃圾回收
在回收内存

00:21:48.308 --> 00:21:50.811
图片显示了
分配给图片的内存

00:21:50.878 --> 00:21:52.713
这些图片都
通过解码显示

00:21:52.980 --> 00:21:54.815
这里的图片数据
比较大

00:21:54.882 --> 00:21:57.551
通常用于
可以在视口显示的图片

00:21:59.052 --> 00:22:01.722
层显示的是
图层内存

00:22:01.788 --> 00:22:04.858
分配在WebKits
tileGrid复合层

00:22:04.925 --> 00:22:06.093
和其他引擎层

00:22:07.227 --> 00:22:08.896
页面就囊括了
所有其他的东西

00:22:08.962 --> 00:22:10.931
引擎所追踪的
所有内容

00:22:10.998 --> 00:22:14.234
比如DOM和页面风格
以及字体渲染数据

00:22:14.301 --> 00:22:16.470
内存缓存和系统分配

00:22:17.271 --> 00:22:19.306
所以这个分类
能让你很好的保证

00:22:19.373 --> 00:22:22.242
内存用量
符合你的预期

00:22:22.943 --> 00:22:26.446
若你有很多JavaScript内容
你要明白

00:22:26.513 --> 00:22:30.150
JavaScript会是分类图表里
用量最多的一类

00:22:30.217 --> 00:22:33.086
在时间线图表里
你可能会随着时间看到更多变化

00:22:33.954 --> 00:22:38.125
但是对于多图片的页面
比如画廊

00:22:38.192 --> 00:22:41.428
那么分层和图片目录
就可能是最大的

00:22:41.495 --> 00:22:42.896
随着时间
变化也更多

00:22:43.830 --> 00:22:47.501
这就是Safari 10里
最新的Memory时间线

00:22:49.203 --> 00:22:53.540
Memory时间线的补充就是
新的JavaScript Allocations时间线

00:22:54.074 --> 00:22:56.343
你不仅能看到
不同时间里内存的变化

00:22:56.510 --> 00:22:58.111
还能更细的探究

00:22:58.178 --> 00:23:00.781
JavaScript Allocations
的真实情况

00:23:00.948 --> 00:23:06.553
对此我们有个强大的工具
JavaScript Allocation Snapshots

00:23:07.321 --> 00:23:08.889
快照的强大之处

00:23:08.956 --> 00:23:12.426
是你可在JavaScripts堆里
对一个时刻进行快照

00:23:12.726 --> 00:23:15.696
然后你就可以深入看到
所有被分配的东西

00:23:16.129 --> 00:23:18.765
但是更强大的是
你有两个快照的时候

00:23:19.466 --> 00:23:22.436
你就可以回头再看
并进行对比

00:23:22.503 --> 00:23:25.639
对比快照
是我们最强大的工具之一

00:23:25.706 --> 00:23:29.243
它可以解答
我是不是做了不必要的分配？

00:23:30.110 --> 00:23:32.579
一定要利用它
因为你需要多个快照

00:23:32.646 --> 00:23:36.783
这也就是为什么
默认每10秒照一次

00:23:37.217 --> 00:23:39.753
不仅要在记录开始
还要在结束

00:23:40.153 --> 00:23:42.923
快照是在时间线上设计的
所以它们能连到

00:23:42.990 --> 00:23:44.825
其他时间线上
发生的事情

00:23:44.892 --> 00:23:46.894
在这里
其他的都被我关了

00:23:48.128 --> 00:23:50.330
这些快照在下面列出
并附了一些细节

00:23:50.397 --> 00:23:51.899
比如堆的
时间和大小

00:23:52.766 --> 00:23:54.501
要了解一个特定的问题

00:23:54.568 --> 00:23:56.870
就通常需要
在开始和结束的时候快照

00:23:56.937 --> 00:23:58.739
围绕你认为
内存会出问题的地方

00:23:59.173 --> 00:24:00.541
这里有三个技巧

00:24:01.074 --> 00:24:03.710
你可以依赖自动快照
每10秒一次

00:24:04.478 --> 00:24:07.247
或者可以亲自快照
就按快照键

00:24:08.282 --> 00:24:09.750
或者用代码执行

00:24:10.551 --> 00:24:14.254
最简单的找到问题的方法
还是改代码

00:24:14.555 --> 00:24:16.623
调出
takeHeapSnapshot API

00:24:16.690 --> 00:24:19.526
传递一个自定义的标签参数
它可以是任何

00:24:19.593 --> 00:24:21.261
之后能帮你识别它的东西

00:24:21.695 --> 00:24:24.198
还有你要做
一对快照

00:24:24.264 --> 00:24:27.100
在你认为导致问题的代码
的前后

00:24:28.035 --> 00:24:30.537
你还可以通过快照
来使用这个代码

00:24:30.604 --> 00:24:32.940
在一个循环内的
工作之间

00:24:33.340 --> 00:24:34.308
分析内存

00:24:34.374 --> 00:24:38.846
下面讲讲要时刻牢记的几点
关于takeHeapSnapshot API

00:24:39.179 --> 00:24:43.050
要记住快照会增添一些额外的进程
在垃圾回收进程中

00:24:43.116 --> 00:24:45.552
这会影响性能
所以你一定要注意

00:24:45.619 --> 00:24:48.088
你的代码是否
频繁的发射快照

00:24:49.189 --> 00:24:52.726
你也要捕捉到
前后不同的信息

00:24:52.793 --> 00:24:55.462
当代码在一个循环之间的
某个时刻运行时

00:24:56.630 --> 00:24:57.698
不要留下这个

00:24:57.764 --> 00:25:00.734
如果你把它留下
对大部分用户来说没问题

00:25:00.801 --> 00:25:04.204
但一旦有人运行网络检查器
它们就会使用所有的快照

00:25:04.271 --> 00:25:05.506
你大概也不想这样

00:25:05.572 --> 00:25:08.876
所以要记住
在启动前一定把它们删除

00:25:09.776 --> 00:25:11.411
那么这些快照
都显示了什么？

00:25:13.146 --> 00:25:14.181
让我们来看一看

00:25:14.848 --> 00:25:18.619
你只要点击时间线上的
快照图标

00:25:18.685 --> 00:25:21.555
或者在快照列表条目里
点击Arrow按键

00:25:22.422 --> 00:25:25.225
你看到的这一列对象
都是之前分配在堆里的

00:25:25.292 --> 00:25:27.294
快照有两个视图

00:25:27.694 --> 00:25:29.129
这是Instances视图

00:25:29.196 --> 00:25:33.033
展示了堆里的对象列表
按照类来分组

00:25:33.634 --> 00:25:35.736
另一个是
对象图像视图

00:25:35.802 --> 00:25:37.871
这实际上
概括了所有东西

00:25:37.938 --> 00:25:40.073
所有的所有

00:25:40.507 --> 00:25:42.109
如果你很熟悉这个代码

00:25:42.176 --> 00:25:45.946
它就能很好地帮助你
确认事情或者找到相应的位置

00:25:46.947 --> 00:25:49.183
但是实际上
更有用的视图

00:25:49.249 --> 00:25:51.785
是在Instances视图里

00:25:51.852 --> 00:25:54.221
它的强大在于
你可以轻松地找到对象

00:25:54.288 --> 00:25:57.057
不论他们在属性路径里
藏得多深

00:25:57.958 --> 00:26:00.494
这里的Count可以帮你
意识到潜在的问题

00:26:00.561 --> 00:26:02.162
就是它们
无法达到预期的时候

00:26:02.229 --> 00:26:05.199
比如我能否实现
4000多个字符串对象？

00:26:06.733 --> 00:26:10.470
你可以展开这个Classes
来看看所有分配到这里的对象

00:26:11.238 --> 00:26:14.942
然后判断什么是什么
通过这么多不同的线索

00:26:15.008 --> 00:26:16.076
Class是一线索

00:26:16.944 --> 00:26:19.379
另外就是
对象的实际属性

00:26:19.713 --> 00:26:21.648
这能让我们很快了解
什么是什么

00:26:22.516 --> 00:26:24.785
但是最简单的
了解对象的方法

00:26:24.852 --> 00:26:29.323
就是悬停在这个对象识别器上
你就会看到这个

00:26:30.924 --> 00:26:34.795
这里实际上显示的是
到对象的最短路径

00:26:35.362 --> 00:26:38.098
它告诉了你究竟是什么
让这个对象保持活动

00:26:38.732 --> 00:26:40.868
它基本上总会给你
你需要的答案

00:26:41.768 --> 00:26:45.572
特别是在JavaScript的
垃圾回收里

00:26:45.639 --> 00:26:48.509
这就是能
立刻解开疑惑的方法

00:26:49.643 --> 00:26:53.013
但是它最重要的功能
和最关键的要点

00:26:53.080 --> 00:26:55.048
在于它能
比较两个快照

00:26:55.349 --> 00:26:57.551
看看这个
当你已经收集了一些快照

00:26:58.218 --> 00:27:00.521
只要点击此处“比较快照”按键

00:27:01.321 --> 00:27:04.992
然后选择Baseline快照
再选一个对比

00:27:05.792 --> 00:27:06.627
一下子

00:27:07.027 --> 00:27:09.263
你就有了一个
新的对比快照可以研究

00:27:09.796 --> 00:27:11.131
这个十分有意义

00:27:11.498 --> 00:27:13.467
因为现在只能看到
新的对象

00:27:13.534 --> 00:27:16.637
在两个点之间
在两个快照之间

00:27:18.172 --> 00:27:21.475
展开对象类分组
可以看到所有的对象分配

00:27:21.542 --> 00:27:24.945
预览中显示了它们的名字
和类似遥测数据的东西

00:27:25.646 --> 00:27:27.848
这里就说明
它是卫星对象

00:27:28.348 --> 00:27:31.151
这里的弹窗显示
_Satellites Array属性

00:27:32.319 --> 00:27:34.054
由于这是
一个快照对比

00:27:34.121 --> 00:27:36.857
卫星的对象
都是新分配的

00:27:36.924 --> 00:27:39.359
这是个很重要的线索
显示代码在做什么

00:27:39.893 --> 00:27:42.296
那么为了让你们实际看到
这些新的存储功能

00:27:42.362 --> 00:27:44.798
我要有请Brian回到台上
来做另一个演示

00:27:51.171 --> 00:27:52.005
谢谢 Jon

00:27:52.606 --> 00:27:55.742
我把卫星跟踪器
给了我的朋友Ed

00:27:55.809 --> 00:27:58.545
他熬了一夜
在玩这个

00:28:00.113 --> 00:28:04.251
他很开心
因为他从来没有被卫星跟踪过

00:28:04.351 --> 00:28:05.452
但是这就有个问题

00:28:05.519 --> 00:28:09.122
它运行时间越长
最终会变得越来越慢

00:28:09.790 --> 00:28:13.026
这在我看来
很像传统的内存

00:28:13.093 --> 00:28:15.262
打开时间越久
就越慢

00:28:15.929 --> 00:28:20.601
我想在卫星跟踪器里
用这些新存储工具来看看

00:28:20.667 --> 00:28:22.369
我们是否泄漏了
一些内存

00:28:23.637 --> 00:28:26.173
那么第一件事

00:28:26.240 --> 00:28:28.575
我的iPad在这儿

00:28:29.309 --> 00:28:31.545
我要回到
网络检查器...

00:28:34.381 --> 00:28:35.782
并且检查这个应用

00:28:36.717 --> 00:28:38.418
我要做的第一件事

00:28:39.286 --> 00:28:43.857
在我不知道问题在哪儿的时候
就是要使用Memory时间线

00:28:43.924 --> 00:28:48.595
它会告诉我
页面上大概发生了什么

00:28:48.662 --> 00:28:50.030
那么我们开始记录

00:28:51.131 --> 00:28:52.766
转回来

00:28:52.833 --> 00:28:57.604
我在两个卫星之间
来回切换

00:28:58.138 --> 00:29:00.741
也许我会在这里
添加一些效果

00:29:02.142 --> 00:29:04.611
好的
我在来回切换

00:29:06.613 --> 00:29:08.048
好了
现在去时间线看看

00:29:11.351 --> 00:29:15.422
在时间线概览中
你看到一个堆积线形图

00:29:15.489 --> 00:29:17.624
显示了所有不同的部分
和相关的大小

00:29:17.858 --> 00:29:21.128
如果你点击这里
会看到更多的细节

00:29:22.563 --> 00:29:24.831
那么这个页面上
没有图片

00:29:24.898 --> 00:29:25.766
都是画布

00:29:26.400 --> 00:29:27.801
分层也很平面

00:29:28.268 --> 00:29:30.804
页面有些波动
有些内容在垃圾回收

00:29:30.871 --> 00:29:31.705
没有问题

00:29:32.306 --> 00:29:35.175
如果你仔细看看JavaScript
你会看到...

00:29:35.776 --> 00:29:37.444
虽然有些东西
被垃圾回收

00:29:37.511 --> 00:29:40.280
但是整体来说
它还是在随着时间堆积

00:29:40.614 --> 00:29:44.318
如果我们运行一整晚
那估计会堆积更多

00:29:44.952 --> 00:29:51.358
下一步就是启用heap快照
或allocation快照

00:29:51.425 --> 00:29:54.194
这样我们就能找到
随着时间而分配的内容

00:29:56.630 --> 00:30:00.667
为了实现这个
我们要开始新的记录

00:30:03.103 --> 00:30:06.139
这有个快捷键
Shift 点击或Shift 空格

00:30:06.206 --> 00:30:08.942
这样就会启动新的记录
而不是继续之前那个

00:30:09.510 --> 00:30:11.778
等等
我忘了改时间线

00:30:11.845 --> 00:30:13.046
去掉Memory

00:30:14.314 --> 00:30:15.916
选上Allocations

00:30:18.252 --> 00:30:19.520
好了
开始记录

00:30:20.387 --> 00:30:21.288
回到iPad

00:30:23.190 --> 00:30:25.759
添加了小小的
takeHeapSnapshot键

00:30:25.826 --> 00:30:29.229
我已给控制台添加了
一些takeHeapSnapshot的调令

00:30:29.296 --> 00:30:32.633
用于切换两个卫星小组
和其他操作

00:30:33.800 --> 00:30:38.038
对这个记录
我要转动地图

00:30:38.105 --> 00:30:41.942
然后不断在
两个卫星中切换

00:30:46.580 --> 00:30:49.416
我们还要看看Spy Satellites
看上去也有关联

00:30:52.419 --> 00:30:54.254
好了 你会发现
开始有点卡了

00:30:54.321 --> 00:30:57.591
因为我们给JavaScript堆里的
所有东西拍了快照

00:30:57.658 --> 00:31:00.060
因此
产生了很多对象

00:31:00.127 --> 00:31:01.795
这会大幅降低
应用的速度

00:31:01.862 --> 00:31:05.265
所以一定不要
拍很多快照

00:31:05.332 --> 00:31:08.435
只在重要的时候拍

00:31:08.802 --> 00:31:13.974
这里你可以看到方块里的S
就是我们拍的快照

00:31:16.043 --> 00:31:18.812
放大一下能看到

00:31:18.879 --> 00:31:20.814
随着时间过去
内存十分稳定的增长

00:31:20.881 --> 00:31:23.584
当我们开始在
两个卫星之间切换的时候

00:31:26.753 --> 00:31:29.056
如果我们要研究这个
像Jon说的那样

00:31:29.122 --> 00:31:35.829
我们就要启动对比
来看看是什么被拦住了

00:31:35.896 --> 00:31:40.167
那么我们就对比
快照9和11

00:31:41.602 --> 00:31:45.072
立刻
我们就看到很多东西

00:31:45.138 --> 00:31:49.443
被分配在9和11之间
并且仍然在活动中

00:31:49.943 --> 00:31:52.412
这就清楚地说明了
它们被留存了

00:31:52.479 --> 00:31:54.648
虽然我们
并不想这么做

00:31:55.649 --> 00:31:57.551
那么我们来看看
这些都是什么

00:31:58.752 --> 00:31:59.620
这是些阵列

00:32:00.454 --> 00:32:03.423
看上去这个阵列里
全是坐标

00:32:04.858 --> 00:32:07.728
你知道在应用的不同部分
我们会用大量的坐标

00:32:07.794 --> 00:32:11.164
但是如果我们停在这里
就会看到它的路径

00:32:11.265 --> 00:32:14.701
它们好像是被保存于
trajectoryHistory

00:32:14.768 --> 00:32:18.572
这是我们用来制作
追踪卫星的东西

00:32:19.973 --> 00:32:21.375
好的
这样不错

00:32:21.441 --> 00:32:23.710
但是我想不应该

00:32:25.112 --> 00:32:27.714
再在已不显示的卫星里用
trajectoryHistory

00:32:27.781 --> 00:32:29.416
这好像是个bug

00:32:31.985 --> 00:32:33.620
我们也分配了
一些对象

00:32:35.055 --> 00:32:39.526
但奇怪的是
在快照9和11之间

00:32:39.593 --> 00:32:41.795
我们之前已经看到
这些卫星

00:32:41.862 --> 00:32:45.065
那么我就不想
再给每个卫星创建新的对象

00:32:45.132 --> 00:32:48.735
我们只要直接使用它们
只要我们已经为他们获取了资源

00:32:48.802 --> 00:32:53.140
然后这里有了很多
坐标和遥测

00:32:53.207 --> 00:32:56.476
好像正在
重新解析什么

00:32:58.045 --> 00:32:59.646
我不太确定
那么...

00:33:00.113 --> 00:33:03.851
在这个视图里
我们有很多对象

00:33:03.917 --> 00:33:05.085
你不能读取所有

00:33:05.152 --> 00:33:08.355
所以我想做的
就是找出很特别的那一个

00:33:08.856 --> 00:33:10.357
那么在这个快照里

00:33:11.825 --> 00:33:13.861
我们有很多字符串
阵列和对象

00:33:13.927 --> 00:33:15.395
但只有一个Promise

00:33:15.829 --> 00:33:17.831
它停留在
两个快照之间

00:33:17.898 --> 00:33:19.900
所以我认为
应该调试这个

00:33:19.967 --> 00:33:24.071
那么我就找到代码
看看是哪里在用Promises

00:33:24.371 --> 00:33:27.274
因为好像它与别的什么
一起被泄露了

00:33:27.441 --> 00:33:29.576
于是
搜索Promise

00:33:30.077 --> 00:33:34.882
好了 这是D3库
这是使用它的代码

00:33:37.251 --> 00:33:39.052
好的
来看看这个

00:33:39.887 --> 00:33:44.892
好了 在［听不清］里
我们常常在卫星之间切换

00:33:44.958 --> 00:33:46.593
代码是loadDataset

00:33:46.793 --> 00:33:50.631
有人写了评论
太好了

00:33:51.665 --> 00:33:56.103
这里看上去好像
有人请求我们改变卫星

00:33:57.271 --> 00:34:03.710
那么这里就可以
异步从URL下载数据

00:34:03.777 --> 00:34:06.046
当它返回
我们就要解析

00:34:07.414 --> 00:34:10.918
然后使用卫星绘图库 
做更多的解析

00:34:11.784 --> 00:34:13.887
然后我们把它存到
卫星列表上

00:34:15.389 --> 00:34:18.525
这都很不错
但是回到检查器

00:34:18.592 --> 00:34:20.527
我们好像每次都泄露该Promise

00:34:20.594 --> 00:34:22.929
如果你更仔细的想想

00:34:22.996 --> 00:34:25.732
如果切换到
已经下载的数据组会怎样？

00:34:26.967 --> 00:34:29.235
我们甚至都没有
检查过这个事情

00:34:30.237 --> 00:34:33.373
你仔细的看看这里

00:34:34.107 --> 00:34:36.577
每次在两个卫星之间转换

00:34:37.277 --> 00:34:38.812
我们就发出
一个新的网络请求

00:34:38.879 --> 00:34:40.179
如果我们进入这个时间线

00:34:41.014 --> 00:34:44.618
就会看到我们在不断请求
同样的垃圾数据

00:34:46.018 --> 00:34:49.523
这是正常的
如果回到代码 发出请求

00:34:49.590 --> 00:34:51.859
解析的时候
会产生大量的对象

00:34:52.492 --> 00:34:54.293
然后我们把它推入
卫星阵列

00:34:54.360 --> 00:34:56.697
就目前来看
它怎么都不清楚

00:34:56.763 --> 00:35:02.202
我们好像一直在做无用功
然后不断泄露

00:35:02.269 --> 00:35:04.838
所以这里
我们要做的

00:35:04.905 --> 00:35:08.475
是检查我们是否已经
解析了这个卫星对象

00:35:08.742 --> 00:35:10.043
因为这是Promise

00:35:10.344 --> 00:35:14.081
如果它确实存在
我们可以调出.then

00:35:14.848 --> 00:35:18.886
由于这已解决
下一次评估Promise的反应时

00:35:18.952 --> 00:35:22.556
它就会进行检查
并将卫星放到地图上

00:35:23.657 --> 00:35:26.960
那么在这里
添加代码

00:35:30.664 --> 00:35:33.734
如果不存在
我们就创建一个

00:35:42.242 --> 00:35:47.314
好了 现在停下来看看
有没有效果

00:35:50.117 --> 00:35:52.352
我们就要回去
重新连接

00:35:55.923 --> 00:35:59.993
这是我们的应用
开始记录吧

00:36:02.329 --> 00:36:05.132
当我们回到应用
我就打开快照

00:36:05.632 --> 00:36:06.700
打开一些效果

00:36:06.800 --> 00:36:10.237
然后往南走

00:36:10.804 --> 00:36:13.240
好的 间谍卫星

00:36:14.274 --> 00:36:16.777
卫星的科学实验

00:36:17.811 --> 00:36:18.779
科学实验

00:36:20.480 --> 00:36:21.315
好了

00:36:24.885 --> 00:36:28.455
如果我们回到这里
我们看到内存的增长大大降低

00:36:28.522 --> 00:36:31.959
大概在1兆
而不是四五兆

00:36:32.025 --> 00:36:34.228
那么这里可能有
更多的泄露

00:36:34.294 --> 00:36:38.665
但是在快照结束的时候
我们的内存

00:36:38.732 --> 00:36:41.168
跟刚开始渲染的时候
一样大

00:36:41.235 --> 00:36:43.537
这样我们就修复了
这个特殊的泄露

00:36:44.805 --> 00:36:49.710
这就展示了我们如何使用
Allocations和Memory时间线

00:36:49.776 --> 00:36:53.547
来解决像这样的
应用的内存泄露问题

00:36:54.114 --> 00:36:58.585
这很不错
因为应用可以用更多的操作

00:36:58.652 --> 00:37:00.954
有了diffing功能

00:37:01.021 --> 00:37:04.825
我们就可以深入观察
我们所关心的卫星里的变化

00:37:06.660 --> 00:37:09.062
好了
卫星跟踪器就讲到这

00:37:10.197 --> 00:37:11.031
你回来吧 Jon

00:37:16.670 --> 00:37:17.504
谢谢 Brian

00:37:17.738 --> 00:37:21.241
你看到了
真是不可思议的迅速和简单

00:37:21.308 --> 00:37:24.845
这些新的时间线
让内存零问题

00:37:25.512 --> 00:37:27.748
所以请记住
Memory时间线是了解

00:37:27.814 --> 00:37:30.317
内存的使用情况
和造成内存高峰的原因

00:37:30.384 --> 00:37:32.119
这样你就知道
该去哪里找问题

00:37:33.020 --> 00:37:37.291
然后使用多个Heap快照
在JavaScript Allocations时间线里

00:37:37.357 --> 00:37:39.826
以便单独放大
造成内存增长的代码

00:37:40.761 --> 00:37:43.363
还有不要忘了删除
takeHeapSnapshot

00:37:43.430 --> 00:37:44.932
在代码运行之前

00:37:46.066 --> 00:37:48.101
要记住性能所受的影响

00:37:48.168 --> 00:37:51.505
是JavaScript Allocations
时间线记录时产生的

00:37:53.607 --> 00:37:56.577
那么以上就是
新的时间线工具

00:37:56.643 --> 00:37:58.445
可用在Safari 10的
网络检查器上

00:37:58.979 --> 00:38:00.747
我想你一定会
爱上它们

00:38:01.982 --> 00:38:04.852
在结束之前
我还想再说几点

00:38:05.586 --> 00:38:08.355
我要建议你们
重新考虑下WKWebView

00:38:08.422 --> 00:38:09.623
如果你还没有换掉它

00:38:11.358 --> 00:38:13.493
在Safari设置里
打开Develop菜单

00:38:13.560 --> 00:38:15.262
连接网络检查器
到你的应用

00:38:15.329 --> 00:38:17.631
然后开始利用
这些新功能

00:38:18.031 --> 00:38:21.468
节省大量时间
Bottom Up视图和Call Trees用于

00:38:21.535 --> 00:38:23.504
找到最需要优化的地方

00:38:23.570 --> 00:38:26.974
Memory时间线可以
快速看到内存高峰的情况

00:38:27.140 --> 00:38:31.111
Heap快照可以
轻松查找和比较对象分配

00:38:32.379 --> 00:38:33.881
时刻关注
新功能的更新

00:38:33.947 --> 00:38:36.550
今年网络检查器
和WebKit有更多内容

00:38:36.617 --> 00:38:39.486
可以让你利用
应用的网页内容

00:38:39.620 --> 00:38:41.722
来创造绝佳的
应用内的用户体验

00:38:42.789 --> 00:38:45.225
除了Brian和我
今天为你们展示的功能

00:38:45.292 --> 00:38:48.562
我们团队过去一年也为
网络检查器添加了很多内容

00:38:49.396 --> 00:38:53.500
Quick Open会让你直接跳到
页面加载的资源

00:38:53.867 --> 00:38:58.739
尾调用堆栈
现在可显示调试器里的尾调用优化函数

00:38:59.339 --> 00:39:02.809
初春的时候在OS 10系统下
我们引进了Safari 9.1

00:39:03.277 --> 00:39:05.245
并更新了
网络检查器

00:39:05.913 --> 00:39:09.416
它显示了Elements标签下
DOM Tree里的Pseudo Elements

00:39:09.883 --> 00:39:12.319
这里还有一个
新的视觉风格边栏

00:39:13.787 --> 00:39:15.489
可能你还没注意到

00:39:15.756 --> 00:39:17.991
网络检查器
是一个开发者工具

00:39:18.058 --> 00:39:20.527
作为WebKit开源项目的一部分

00:39:21.962 --> 00:39:25.199
WebKit是网页浏览器引擎
用来支持你的应用

00:39:25.265 --> 00:39:27.668
驱动WebViews
和JSContext

00:39:28.068 --> 00:39:30.137
当然它也是Safari
背后的动力

00:39:31.004 --> 00:39:34.508
在过去一年里
我们为WebKit添加了好多新功能

00:39:34.575 --> 00:39:36.910
我们对ES6
100％支持

00:39:37.678 --> 00:39:40.714
我们改进了对IndexedDB
Standard的支持

00:39:41.215 --> 00:39:45.219
还添加了Shadow DOM支持
WebDriver和CSS变量

00:39:45.619 --> 00:39:46.753
以及Picture Element

00:39:47.688 --> 00:39:50.224
所以真的是很多内容
而且作为开源项目

00:39:50.290 --> 00:39:52.559
一旦有新的出现
你就能知道

00:39:53.060 --> 00:39:55.329
你们在座大部分人
肯定都想能利用它工作

00:39:55.395 --> 00:39:58.365
如果你们想
对这些内容作出改进

00:39:58.432 --> 00:39:59.433
完全有机会

00:39:59.499 --> 00:40:01.702
因为WebKit
是开放资源

00:40:02.669 --> 00:40:05.906
你可在WebKit.org上
找到更多WebKit项目信息

00:40:05.973 --> 00:40:09.710
WebKit团队及其背后的
工程师们会在博客上写他们的开发工作

00:40:09.776 --> 00:40:11.778
实际上
我们现在有两个博客

00:40:11.845 --> 00:40:14.648
关于Memory时间线
和样本分析器

00:40:14.715 --> 00:40:15.716
就是今天讲的内容

00:40:15.782 --> 00:40:18.151
所以如果你想了解更多
可以去那里看看

00:40:18.552 --> 00:40:21.355
我们还有一个功能状态页
一目了然的列出了所有更新

00:40:21.421 --> 00:40:22.789
针对网页标准进程

00:40:23.357 --> 00:40:26.260
这里还有链接
可以下载WebKit夜间建构

00:40:26.727 --> 00:40:29.930
和最新的浏览器
Safari技术概览

00:40:30.797 --> 00:40:34.201
每几周更新一次
附带更新的WebKit引擎

00:40:34.668 --> 00:40:37.871
所以你可以在WebKit上
尝试这些新的实验性功能

00:40:37.938 --> 00:40:39.606
它们每两周改进一次

00:40:40.474 --> 00:40:44.411
我们团队投入了大量精力给Safari
WebKit和网络检查器

00:40:44.478 --> 00:40:47.581
网络检查器团队
可以使用这些新性能特性

00:40:47.648 --> 00:40:50.918
就像我们今天展示的那样
去查询问题并提高性能

00:40:50.984 --> 00:40:52.419
对网络检查器本身

00:40:52.619 --> 00:40:54.555
我已经迫不及待
想看看你们会做些什么

00:40:54.855 --> 00:40:56.590
想了解更多信息
请观看这个演讲

00:40:56.657 --> 00:40:59.259
在developer.apple.com
下载幻灯片

00:41:00.093 --> 00:41:03.163
这周的前几天有很多场相关演讲

00:41:03.230 --> 00:41:04.831
过去几年也有不少

00:41:05.098 --> 00:41:07.835
这些都能在
developer.apple.com上找到

00:41:08.769 --> 00:41:12.606
那么代表Brian 我自己
和Safari与WebKit团队

00:41:12.673 --> 00:41:15.442
感谢你们的到来
祝大家在接下来的WWDC中过得愉快

00:00:19.386 --> 00:00:22.389
优化应用的网页内容

00:00:22.456 --> 00:00:23.290
大家好

00:00:27.427 --> 00:00:29.763
欢迎来到“优化应用的网页内容”

00:00:29.830 --> 00:00:31.398
我是Jonathan Davis

00:00:31.465 --> 00:00:34.168
网络技术的推广人
负责Safari和WebKit

00:00:34.902 --> 00:00:37.271
现在我要先说明一些事情

00:00:38.172 --> 00:00:40.707
很多人说我长得像
Edward Snowden

00:00:40.774 --> 00:00:42.309
但我向你保证 我不是他

00:00:43.210 --> 00:00:46.947
但这么多卫星在头顶盘旋
大概都是来抓我们的

00:00:47.915 --> 00:00:50.751
除此之外 我很激动地要展示些新东西

00:00:50.817 --> 00:00:53.787
它们可以帮助你
提升应用网页内容的性能

00:00:54.288 --> 00:00:56.323
我们一直都知道

00:00:56.390 --> 00:00:59.326
性能是提供最佳用户体验的关键

00:00:59.393 --> 00:01:04.431
若你是个应用开发者并在应用里用了
WebViews和JSContext

00:01:05.364 --> 00:01:07.901
而且你很关心性能
那你就来对地方了

00:01:08.569 --> 00:01:09.970
说到性能

00:01:10.304 --> 00:01:14.074
在当今时代里
性能其实就是指电池寿命

00:01:14.141 --> 00:01:17.411
我认为电池寿命是最终的有限资源

00:01:17.845 --> 00:01:20.280
它带来很不同的结果
如果你能拨出最后一通电话

00:01:20.347 --> 00:01:23.717
或者发出最后一份重要的文件
在电池耗光之前

00:01:24.218 --> 00:01:26.420
性能对用户来说
事关重大

00:01:26.753 --> 00:01:29.389
他们所选择的应用
不会让设备变慢

00:01:29.456 --> 00:01:30.724
而且耗电量低

00:01:31.692 --> 00:01:35.596
我们的经验就是
根据用户的反馈和各自的体会

00:01:35.662 --> 00:01:38.966
性能很重要
因为电池寿命事关重大

00:01:40.400 --> 00:01:44.104
所以今年我们致力于
提供更好的工具

00:01:44.171 --> 00:01:46.640
来找到和修复
网页内容的性能问题

00:01:47.207 --> 00:01:49.510
现在我们为应用提供了工具
比如Swift

00:01:49.576 --> 00:01:51.778
还有Objective-C代码
比如Instruments

00:01:52.312 --> 00:01:56.049
我们还提供了网络检查器
帮助网页开发者创建网页和网站

00:01:57.017 --> 00:01:59.286
但不要觉得
因为你选择了

00:01:59.353 --> 00:02:02.422
在应用中用网络技术
就没有其他工具可用了

00:02:02.489 --> 00:02:05.259
实际上
我今天展示给你的所有工具

00:02:05.325 --> 00:02:07.427
就是开发给人们
既能帮助他们建设网站

00:02:07.494 --> 00:02:10.430
也能让他们在应用里
用网络技术

00:02:11.265 --> 00:02:12.566
那么我首先要
向你展示

00:02:12.633 --> 00:02:15.936
如何把网络检查器连接到
JSContext的WebViews

00:02:16.003 --> 00:02:18.505
这样在你需要它的时候
它就会立刻出现

00:02:19.540 --> 00:02:21.375
之后你会了解
一些新的功能

00:02:21.441 --> 00:02:25.479
它们能让你了解JavaScript代码
如何分配时间

00:02:25.546 --> 00:02:29.650
以及这些新功能
如何帮你迅速找到性能上的问题

00:02:30.651 --> 00:02:34.955
如果你想要看到
网络内容的内存使用情况

00:02:35.022 --> 00:02:38.392
我们也给网络检查器增添了新的时间线
我都已等不及想展示了

00:02:38.592 --> 00:02:41.562
它们会帮你节省很多时间
来找到内存过大的问题

00:02:41.995 --> 00:02:43.797
准备好了？
那就开始吧

00:02:45.032 --> 00:02:46.333
第一件
我们要做的事

00:02:46.400 --> 00:02:48.769
是把网络检查器
连接到应用里

00:02:49.469 --> 00:02:52.840
在应用里使用网络技术
有很多原因

00:02:53.574 --> 00:02:56.276
如JS context里的
一些JavaScript模块

00:02:56.343 --> 00:02:59.980
可以让你轻松交换逻辑
并无编译地添加新的模块

00:03:00.747 --> 00:03:05.419
可能有些人正在tvOS应用里
使用TVML的 JSContext

00:03:06.053 --> 00:03:09.690
另外一个使用网络技术的原因
就是你要显示的网页内容

00:03:10.157 --> 00:03:12.059
比如第三方网站的
一个网页

00:03:12.459 --> 00:03:13.727
这个网站
你不能控制

00:03:14.027 --> 00:03:16.663
可能就要用到Safari视图控制器

00:03:16.730 --> 00:03:18.398
如果不是
你也许可以去听听

00:03:18.465 --> 00:03:21.602
去年的演讲
“介绍Safari视图控制器”

00:03:22.903 --> 00:03:26.106
但如果你显示的内容
是你自己的或者你可以控制的

00:03:26.173 --> 00:03:31.912
或是可自定义的HTML CSS
或JavaScript编写的内容

00:03:31.979 --> 00:03:34.281
或者是
可以提升应用体验的内容

00:03:34.615 --> 00:03:36.350
WKWebView
是最好的选择

00:03:36.717 --> 00:03:39.786
它实际上是个矩形
把网页内容拉入应用

00:03:40.354 --> 00:03:43.690
它引入了iOS 8
和OS 10 Yosemite

00:03:44.858 --> 00:03:47.561
若你还在使用WebView
或者UIWebView

00:03:47.828 --> 00:03:51.164
那你一定要考虑
升级到WKWebView

00:03:51.565 --> 00:03:54.735
事实上 升级到WKWebView
可以让你利用

00:03:54.801 --> 00:03:58.805
Nitro JavaScript
核心引擎和四级JIT编译器

00:03:58.872 --> 00:04:00.007
这能大大提升速度

00:04:00.741 --> 00:04:02.743
若想了解更多WKWebView信息

00:04:03.010 --> 00:04:07.314
我推荐2014年的演讲
介绍了现代化的WebKit API

00:04:08.282 --> 00:04:11.418
那么去年我们给WKWebView
添加了很多优秀的功能

00:04:11.485 --> 00:04:16.589
比如 加载文件URL和自定义用户代理字符串
还有WK网站数据存储API

00:04:17.858 --> 00:04:22.296
现今有了iOS 10和macOS Sierra
我们改进了3D-touch支持

00:04:23.063 --> 00:04:25.532
现在你的应用就可以执行这些好用的

00:04:25.599 --> 00:04:27.835
Peek和Pop事件
在WKWebView里

00:04:29.336 --> 00:04:31.438
就像我之前说的
因为你选了

00:04:31.505 --> 00:04:32.906
在应用里
应用网络技术

00:04:33.807 --> 00:04:35.142
并不意味着
你没有工具可用

00:04:35.209 --> 00:04:37.811
不论哪种情况
你可连接网络检查器

00:04:37.878 --> 00:04:40.214
发掘网页内容
或JavaScript活动情况

00:04:41.081 --> 00:04:44.985
但使用网络检查器前
你必须要激活develop菜单

00:04:45.219 --> 00:04:49.156
只要上传Safari设置
然后找到“高级”标签

00:04:49.356 --> 00:04:51.558
然后在底部
你会看到这个复选框

00:04:51.625 --> 00:04:53.961
写着在菜单栏显示Develop菜单

00:04:54.995 --> 00:04:56.730
那就点击它

00:04:56.964 --> 00:04:59.766
Develop菜单就会出现在
Safari的菜单栏里

00:05:01.735 --> 00:05:04.371
为让网络检查器
连接到iOS设备

00:05:04.438 --> 00:05:06.073
你要开启一个设置

00:05:06.607 --> 00:05:10.210
在iOS的设置应用里
点击Safari

00:05:10.511 --> 00:05:16.016
然后拉到底部 点击“高级”
然后把检查器设置打开

00:05:16.884 --> 00:05:18.652
现在你就可以
把设备连到Mac上

00:05:18.719 --> 00:05:20.654
在Safari里
检查Develop菜单

00:05:22.356 --> 00:05:24.558
Develop菜单里
有些很酷炫的东西

00:05:24.625 --> 00:05:26.627
你之前可能
从未注意到过

00:05:26.693 --> 00:05:28.962
就是你能看到设备的列表

00:05:29.029 --> 00:05:32.866
这里有已连接的iPhone
MacBook Pro和模拟器

00:05:33.500 --> 00:05:36.837
要连接一个设备
并开始使用这些工具

00:05:36.904 --> 00:05:39.206
进行调试
那么只要选择Device菜单

00:05:39.473 --> 00:05:43.377
就会收到 当前设备上运行的
WebViews和JSContexts 的列表

00:05:44.411 --> 00:05:46.580
这里的Mac应用
并没有使用WebKit

00:05:46.647 --> 00:05:48.015
而用JavaScript

00:05:48.148 --> 00:05:50.651
所以我可以直接连接它
并使用工具

00:05:51.585 --> 00:05:56.190
iOS里的应用只会出现在
用Xcode创建和运行的时候

00:05:56.924 --> 00:06:00.194
但是说到Mac应用
你还要做一件事

00:06:01.261 --> 00:06:05.299
就是保持应用的完整性
我们不会让任何人下载你的应用

00:06:05.365 --> 00:06:08.168
并用网络检查器
巡查你的应用

00:06:08.669 --> 00:06:10.103
所以你要添加
这个授权

00:06:10.170 --> 00:06:12.272
到应用本地开发的
授权文件里

00:06:13.307 --> 00:06:15.542
你可能已经有了一个
授权文件

00:06:15.609 --> 00:06:17.477
如果没有
创建一个也很简单

00:06:17.544 --> 00:06:20.581
你只要创建新的plist
拓展名为.entitlements

00:06:20.914 --> 00:06:25.419
并且Xcode的创建设置里
定义一个代码签名的授权传递路径

00:06:26.753 --> 00:06:28.488
这个要在
开发的时候添加

00:06:28.555 --> 00:06:30.791
之后在
运行应用的时候删除

00:06:31.792 --> 00:06:32.893
一旦有了这个授权

00:06:33.126 --> 00:06:35.395
你的设备和应用就
出现在Develop菜单

00:06:35.462 --> 00:06:36.496
这样就可以连接了

00:06:36.830 --> 00:06:42.669
轻松把网络检查器连接到
JSContext和WebViews上了

00:06:44.805 --> 00:06:47.674
我们已正常运行了
网络检查器和应用

00:06:48.675 --> 00:06:51.078
该谈谈网络检查器里
新功能了

00:06:51.144 --> 00:06:53.814
我想首先讲讲
分析JavaScript代码

00:06:53.881 --> 00:06:54.715
分析JavaScript

00:06:54.781 --> 00:06:57.584
JavaScript的分析器
已经存在挺长时间了

00:06:57.651 --> 00:06:59.620
今年它变得更好

00:06:59.686 --> 00:07:03.156
更有效率
能帮助你迅速找到

00:07:03.223 --> 00:07:05.392
哪里调出的JavaScript
成本最高

00:07:05.459 --> 00:07:06.660
原因很简单

00:07:07.628 --> 00:07:11.965
新的分析器采用了取样技术
不会影响性能

00:07:12.032 --> 00:07:13.734
比以前好太多

00:07:14.568 --> 00:07:17.504
我们的分析器
在编译器能用之前的时代

00:07:17.571 --> 00:07:18.739
实际是个翻译器

00:07:19.206 --> 00:07:23.143
但是现在我们有了
这个强大的四级JIT编译器

00:07:23.443 --> 00:07:26.947
那么这个分析器
就真正成为样本分析器

00:07:28.048 --> 00:07:31.518
样本分析器告诉你
代码把时间都用在哪里

00:07:31.752 --> 00:07:35.622
帮你解答
哪个代码占用的时间最多？

00:07:36.590 --> 00:07:39.059
它在运行程序中的取样
以每毫秒为单位

00:07:39.126 --> 00:07:40.594
并且短暂地
停顿执行

00:07:40.661 --> 00:07:43.130
并快照
所有正在运行的代码

00:07:44.598 --> 00:07:45.966
它还可以取样

00:07:46.033 --> 00:07:48.936
在代码运行于
JIT编译器所有四级的时候

00:07:49.002 --> 00:07:52.039
所以它的取样速度
跟你代码的实际速度差不多

00:07:52.873 --> 00:07:56.443
由于断点处理
会导致代码去优化

00:07:56.510 --> 00:07:57.978
我们暂时不管它们

00:07:58.545 --> 00:08:02.583
那么当你分析的时候
你就可以了解网页应用的真实性能

00:08:03.050 --> 00:08:06.854
使用样本分析器
对性能几乎没有损害

00:08:07.120 --> 00:08:10.157
这就意味着
当你分析代码的时候

00:08:10.657 --> 00:08:13.560
速度高达以前的30倍

00:08:14.361 --> 00:08:17.931
这就让代码分析过程
更快也更简单

00:08:17.998 --> 00:08:20.434
而且收到的数据
也更准确

00:08:21.869 --> 00:08:25.939
这个进步真令人振奋 因为我们团队
和网络检查器团队

00:08:26.006 --> 00:08:29.610
能利用它来发现
可以提升速度的地方

00:08:29.676 --> 00:08:31.044
就在网络检查器本身

00:08:32.412 --> 00:08:34.515
好了
现在我们有了样本分析器

00:08:34.581 --> 00:08:37.618
看看如何利用网络检查器
帮我们找到问题

00:08:38.519 --> 00:08:41.688
这个内容很多
但是可以简单的拆分开来

00:08:41.788 --> 00:08:43.991
更方便的是
这都是你已经熟悉的代码

00:08:44.958 --> 00:08:47.160
当我们说到
分析JavaScript时

00:08:47.227 --> 00:08:50.597
意思是在Events里
为JavaScript记录时间线

00:08:50.664 --> 00:08:52.399
这就是Events视图

00:08:52.733 --> 00:08:56.270
显示了一列单独而且具体的
JavaScript事件

00:08:56.570 --> 00:09:00.073
特别的是
这里都是D3库的代码

00:09:00.140 --> 00:09:02.910
所以它能更方便
调试代码

00:09:02.976 --> 00:09:05.612
和分析代码
在你正在使用的库里

00:09:06.346 --> 00:09:09.449
而且这里的每一条
都是代码运行的事件

00:09:09.716 --> 00:09:13.187
这是代码进出
JavaScript核心引擎的情况

00:09:14.087 --> 00:09:15.856
包括了
监听事件的回调

00:09:15.923 --> 00:09:19.193
比如动画框架的条目
是在请求动画框架处理器

00:09:20.160 --> 00:09:22.596
脚本评估条目
显示JavaScript文件

00:09:22.663 --> 00:09:24.331
的上传和首次评估

00:09:25.265 --> 00:09:27.234
这里还有一些
时间信息

00:09:27.701 --> 00:09:30.971
告诉你运行的代码
所花费的时间

00:09:32.039 --> 00:09:34.708
所以如果有哪个
超过了10或15毫秒

00:09:34.775 --> 00:09:36.343
你就快要打破

00:09:36.410 --> 00:09:38.812
60帧每秒的
流畅性能底线

00:09:40.647 --> 00:09:43.217
Events视图很有用
但是还有另一个视图

00:09:43.283 --> 00:09:46.119
是我们为你添加的
叫做Call Trees视图

00:09:46.553 --> 00:09:49.790
如果你用过其他分析工具
那么对这个应该很熟悉

00:09:51.225 --> 00:09:54.161
只要点击这个菜单
然后转换到Call Trees视图

00:09:55.429 --> 00:09:59.399
现在显示了调用堆栈里
函数的累计运行时间

00:10:00.133 --> 00:10:01.768
这个叫做Top Down视图

00:10:01.835 --> 00:10:04.137
你可以用它
深入发掘Call Tree

00:10:04.204 --> 00:10:06.707
来找到
耗费大量时间的热函数

00:10:07.774 --> 00:10:10.177
但我最喜欢的视图是
Bottom Up视图

00:10:12.513 --> 00:10:14.448
它能直接让我找到
最热的函数

00:10:14.515 --> 00:10:16.650
就是取样最频繁的函数

00:10:17.551 --> 00:10:19.319
这里罗列的
是调出的函数

00:10:19.386 --> 00:10:21.622
按照用时
从大到小分类

00:10:21.688 --> 00:10:26.593
它反转了Call Tree
让你能直接对比各个函数的耗时

00:10:27.861 --> 00:10:30.731
你能准确地看到
耗时最多的地方

00:10:32.332 --> 00:10:35.169
你可以展开这一条
并按照路径返回

00:10:35.235 --> 00:10:36.837
找到耗时最多的函数

00:10:37.471 --> 00:10:41.108
你就能知道这个成本最高的代码
是何时何地调出的

00:10:42.809 --> 00:10:45.312
那么关于这部分
有请我的同事

00:10:45.379 --> 00:10:46.980
Brian Burg
上台为大家展示

00:10:55.155 --> 00:10:57.858
谢谢你 Jon
样本分析器很好用

00:10:57.925 --> 00:11:00.494
因为它可以提取
十分复杂的内容

00:11:00.561 --> 00:11:03.564
并进行分析
让你看到十分精确的信息

00:11:03.630 --> 00:11:05.132
而且你可以让它
跑的更快

00:11:05.832 --> 00:11:09.469
为了给你们展示
我要用我制作的iPad应用

00:11:09.770 --> 00:11:12.139
叫做卫星跟踪器
在这里看看

00:11:15.676 --> 00:11:19.680
卫星跟踪器
会展示给你现在或任何时间

00:11:20.080 --> 00:11:21.615
卫星所在的位置

00:11:21.882 --> 00:11:24.618
你可以选择
地球上的不同地点

00:11:25.219 --> 00:11:26.787
也可以选择不同的卫星

00:11:28.222 --> 00:11:29.223
不同的时区

00:11:30.023 --> 00:11:30.858
这很棒吧

00:11:31.725 --> 00:11:33.460
如果你担心
头上盘旋的卫星

00:11:33.527 --> 00:11:36.330
要带个锡纸帽子以防万一
这个应用就是理想之选

00:11:37.064 --> 00:11:39.633
但是这里有个小问题

00:11:39.700 --> 00:11:44.071
如果很多卫星
或者很多卫星组件

00:11:44.137 --> 00:11:47.207
像这样挤爆了
那么帧率的波动会很大

00:11:47.674 --> 00:11:49.676
这肯定不是
60帧每秒

00:11:49.743 --> 00:11:50.878
它会一直波动

00:11:51.411 --> 00:11:53.981
这样就可以用
样本分析器来查找

00:11:54.047 --> 00:11:55.849
发生了什么
为什么这么慢

00:11:57.751 --> 00:12:03.257
我们要做的就是打开Safari
并进入Develop菜单

00:12:03.957 --> 00:12:06.026
找到这里的iPad
并连接上

00:12:07.594 --> 00:12:11.098
那么我要做的第一件事
就是进入Frames视图

00:12:11.164 --> 00:12:14.001
看看现在的位置
帧率如何

00:12:14.067 --> 00:12:16.069
那么开始记录

00:12:17.137 --> 00:12:18.572
我再转回iPad

00:12:19.373 --> 00:12:20.774
做点什么

00:12:22.876 --> 00:12:24.244
比如转动一下

00:12:25.746 --> 00:12:27.514
或者换一个卫星

00:12:29.383 --> 00:12:30.250
换个时区

00:12:30.884 --> 00:12:32.219
好了
现在回去看看

00:12:35.489 --> 00:12:36.723
好的
把这个缩小

00:12:37.424 --> 00:12:40.227
所有的性能
就都显示在这里了

00:12:40.294 --> 00:12:44.865
有的时候是60帧每秒
像左边这些

00:12:45.299 --> 00:12:47.367
在中间
则上下都有

00:12:47.434 --> 00:12:48.802
因为我们在
更改视图

00:12:49.136 --> 00:12:51.972
这一些
就太慢了

00:12:52.940 --> 00:12:55.042
我想知道
出了什么问题

00:12:56.710 --> 00:12:58.879
那么我就转到
Events视图

00:13:00.981 --> 00:13:03.283
点击JavaScript
和Events时间线

00:13:03.350 --> 00:13:06.019
重点看看
样本分析器的数据

00:13:07.955 --> 00:13:10.691
就像Jon之前演示的那样
这里的Events视图

00:13:10.757 --> 00:13:12.926
会显示所有
运行循环里的内容

00:13:12.993 --> 00:13:16.096
这个例子里
就是动画和模拟

00:13:16.163 --> 00:13:18.398
就是我们在
不断地渲染帧

00:13:18.465 --> 00:13:22.769
这不是很有用
因为无法找到耗时最多的地方

00:13:23.537 --> 00:13:25.939
那么我们转到
Call Trees视图

00:13:27.574 --> 00:13:30.844
这里我们看到Top Down
Call Tree

00:13:31.211 --> 00:13:35.849
集合显示了
所有的渲染帧

00:13:35.916 --> 00:13:37.484
都是最耗时的地方

00:13:38.352 --> 00:13:42.356
展开这个就能看到
D3有一个Timer函数

00:13:42.422 --> 00:13:45.893
它调出一些代码
画了一些场景

00:13:46.960 --> 00:13:49.863
这些场景包括
卫星

00:13:49.930 --> 00:13:52.099
和时间等

00:13:52.165 --> 00:13:56.303
这个很棒
能让我们了解代码在做什么

00:13:56.670 --> 00:13:59.373
但是如果要想找出
哪个函数最耗费

00:14:00.073 --> 00:14:02.376
最好还是去看
Bottom Up视图

00:14:04.044 --> 00:14:09.316
这里我们列出了所有函数
无论谁调用它们

00:14:09.917 --> 00:14:12.686
我们看到这个fillText

00:14:12.753 --> 00:14:15.322
和tangent
是最耗费的两个

00:14:15.422 --> 00:14:18.559
那为什么
会调出tangent呢？

00:14:18.792 --> 00:14:23.630
我们展开这一行
看看调令来源

00:14:23.830 --> 00:14:28.202
就在这里
是_plotSatellites

00:14:28.435 --> 00:14:33.273
好像正在计算转换
用来绘制地球

00:14:34.041 --> 00:14:35.876
好的
这些看着都很正常

00:14:36.443 --> 00:14:39.079
也许我该找出数学课本
让它算得快一点

00:14:40.314 --> 00:14:41.682
现在看看
fillText

00:14:41.748 --> 00:14:45.652
换个画面
回到这里的应用

00:14:46.320 --> 00:14:51.458
我们正在当前时间上绘制文本
也在每个数据点上绘制

00:14:52.492 --> 00:14:53.460
这说得通

00:14:53.527 --> 00:14:57.898
但是如果仔细看
我们实际上把这个时间画了两次

00:14:58.699 --> 00:15:00.000
这就有点奇怪

00:15:00.767 --> 00:15:03.403
所以我们展开这一行

00:15:04.238 --> 00:15:06.707
就能看到
调令来自哪里

00:15:07.975 --> 00:15:11.245
这里我们好像
一次画了两个不同的前景

00:15:11.778 --> 00:15:14.114
这大概
不是我们想要的

00:15:15.516 --> 00:15:17.284
那么来找找
哪儿出了问题

00:15:17.417 --> 00:15:20.120
如果像这样
画了两个前景

00:15:20.220 --> 00:15:23.290
那么我们的工作量
实际就是所需的两倍

00:15:24.858 --> 00:15:28.729
为了让你的记忆更清晰
记住我们有个平面地图

00:15:28.795 --> 00:15:31.431
然后有这个地球
它在转动

00:15:32.833 --> 00:15:36.303
那么
现在回到代码

00:15:37.771 --> 00:15:41.942
找一找是什么
控制着两个地图的切换

00:15:42.009 --> 00:15:43.010
估计哪里弄错了

00:15:46.513 --> 00:15:49.783
改变地点的时候
我们会让两个地球互换

00:15:51.051 --> 00:15:52.252
这是 updateLocation

00:15:52.819 --> 00:15:57.191
好的 因为已经有一个地图
就不再需要另一个

00:15:57.291 --> 00:16:00.494
这是有道理的
因为这里我们添加了隐藏类

00:16:00.561 --> 00:16:02.863
就为了不让它
显示出来

00:16:04.298 --> 00:16:07.701
这里在_globeMap
我们定义running值为真

00:16:07.768 --> 00:16:09.236
在整个运行中

00:16:09.603 --> 00:16:12.506
而且在place中声明
我们显示的不是_globeProjection

00:16:12.573 --> 00:16:13.407
这是对的

00:16:13.473 --> 00:16:15.042
当我们显示
平面地图

00:16:15.108 --> 00:16:17.144
我们不会显示地球
它也不会运行

00:16:18.178 --> 00:16:20.280
这个平面地图
看上去好像

00:16:20.347 --> 00:16:22.382
一直在运行
UI也在运行

00:16:22.516 --> 00:16:26.086
这也挺奇怪的

00:16:26.486 --> 00:16:28.655
那么我们回到地图
试着做点儿什么

00:16:32.192 --> 00:16:34.628
这里我们选择
这个数据组

00:16:35.762 --> 00:16:37.431
然后进入Earth

00:16:38.465 --> 00:16:43.237
它的帧率要好于
只做世界地图

00:16:43.303 --> 00:16:44.505
那么
这就很有道理

00:16:44.571 --> 00:16:47.574
我想我们在世界地图活动的时候
画了两张地图

00:16:47.641 --> 00:16:49.443
但是在平面地图的时候
只画了一个

00:16:49.510 --> 00:16:53.914
那么我们就在这里
改变这个条件

00:16:59.786 --> 00:17:01.288
糟糕
应该反过来

00:17:04.558 --> 00:17:08.996
好的 先停下
看看有没有修复

00:17:12.598 --> 00:17:14.001
回到iPad

00:17:15.502 --> 00:17:16.737
好的
这看上去很流畅

00:17:16.803 --> 00:17:17.671
来到这里

00:17:19.006 --> 00:17:19.839
恩 很好

00:17:22.041 --> 00:17:22.910
看上去不错

00:17:22.976 --> 00:17:25.913
那么我们再去检查
时间渲染

00:17:25.979 --> 00:17:29.249
看看是不是
60帧每秒

00:17:30.684 --> 00:17:32.386
那么
回到Frames视图

00:17:33.053 --> 00:17:37.024
然后开始记录
很不错

00:17:37.090 --> 00:17:40.160
我转动地球的时候
有点慢

00:17:40.227 --> 00:17:42.496
但稳定度
看上去...

00:17:42.563 --> 00:17:45.299
不错
绝对在60帧每秒以下

00:17:45.832 --> 00:17:49.736
在这里有一个条
只要低于它就是好的

00:17:52.940 --> 00:17:56.610
现在卫星跟踪器
快了很多

00:17:56.677 --> 00:17:58.779
我们就知道
什么时候带上帽子

00:17:58.946 --> 00:17:59.780
这很棒

00:18:00.247 --> 00:18:04.017
这就是个简单的例子
关于如何使用样本分析器

00:18:04.084 --> 00:18:07.788
来发现最繁忙的内容
并让它运行的更快

00:18:08.689 --> 00:18:12.893
下面Jon会跟大家讲讲
内存和分配

00:18:21.802 --> 00:18:22.636
谢谢 Brian

00:18:24.371 --> 00:18:27.074
你看到了
分析很迅速

00:18:27.274 --> 00:18:29.443
它能让你了解
代码的真实速度

00:18:29.510 --> 00:18:31.311
这样你就能
获得十分精确的数据

00:18:31.678 --> 00:18:34.448
再看看JavaScript
和Events时间线

00:18:34.948 --> 00:18:37.918
并用它们找到
缓慢的回调处理器和定时器

00:18:37.985 --> 00:18:40.454
或者在Events视图里
缓慢的脚本初始化

00:18:41.822 --> 00:18:44.157
请用新的Call Trees视图
来了解耗时

00:18:44.224 --> 00:18:47.227
因为它们会沿着
你选择的时间线堆积起来

00:18:48.228 --> 00:18:50.464
记着Bottom Up
是你的新朋友

00:18:50.531 --> 00:18:54.201
它能帮助你找到
最需要优化的地方

00:18:55.869 --> 00:18:58.071
那么现在我们已经看过了
新的样本分析器

00:18:58.138 --> 00:19:00.574
和新的JavaScript
Call Trees视图

00:19:00.908 --> 00:19:04.611
我很激动能用更好的工具
来优化CPU时间

00:19:04.678 --> 00:19:06.513
这样就能给用户
快速的体验

00:19:06.580 --> 00:19:08.282
并帮他们
节省了电池

00:19:08.782 --> 00:19:10.551
这真的不错
现在我们继续

00:19:10.617 --> 00:19:12.219
看看性能的另一方面

00:19:12.586 --> 00:19:14.254
就是了解
内存都去哪儿了

00:19:15.189 --> 00:19:17.858
你肯定想更有效率地使用
网页内容的内存

00:19:17.925 --> 00:19:19.526
因为这是有限资源

00:19:19.960 --> 00:19:24.731
有效地使用内存可以
优化网页内容的比例

00:19:24.798 --> 00:19:26.600
并能处理
大型数据组

00:19:28.335 --> 00:19:32.472
而且内存占用过多会降低性能
我们并不想这样

00:19:33.273 --> 00:19:35.175
它也会让
你的网页内容崩溃

00:19:35.242 --> 00:19:36.777
这更非我们所愿

00:19:37.311 --> 00:19:41.682
好消息是若你运行WKWebView
它会以单独的进程运行

00:19:41.982 --> 00:19:43.450
不会让
整个应用崩溃

00:19:43.517 --> 00:19:45.752
但是这仍然不是
一个好的用户体验

00:19:46.286 --> 00:19:48.755
为了帮你解决这些问题
我们添加了两个新时间线

00:19:48.822 --> 00:19:50.557
给网络检查器
和Safari 10

00:19:51.859 --> 00:19:55.295
当启动新网络检查器
新时间线就默认关闭

00:19:55.362 --> 00:19:56.730
所以要打开它们

00:19:56.797 --> 00:19:59.633
你只要点击Edit
就在时间线上面

00:20:01.134 --> 00:20:03.704
就可以配置
自己想看的时间线

00:20:03.770 --> 00:20:06.673
这样就可以只研究
自己想用的那个

00:20:06.740 --> 00:20:08.342
就和Instruments应用一样

00:20:09.543 --> 00:20:12.946
只要开启新的时间线
就可以记录新的时间线了

00:20:13.280 --> 00:20:15.983
但你可能不想
让它们同时运行

00:20:16.550 --> 00:20:19.386
JavaScript和
Events时间线样本分析器

00:20:19.453 --> 00:20:21.188
虽然负载较少
但还是有

00:20:21.722 --> 00:20:24.491
而JavaScript Allocation
的时间线会添加更多进程

00:20:24.558 --> 00:20:27.761
在垃圾回收过程中
这会影响性能

00:20:28.428 --> 00:20:31.965
那我们就一直开着
Memory时间线

00:20:32.032 --> 00:20:35.002
那么在记录一个时间线的时候
你会看到这个

00:20:35.936 --> 00:20:39.907
这个新的Memory时间线图表
显示了内存如何分配

00:20:39.973 --> 00:20:42.342
到不同的目录里
在不同的时间

00:20:43.076 --> 00:20:44.878
这里有一系列图表

00:20:44.945 --> 00:20:48.515
帮你了解
内存的使用和划分

00:20:49.750 --> 00:20:52.319
Breakdown表显示了
内存如何分配给

00:20:52.386 --> 00:20:56.356
JavaScript和图画
和构成页面的分层

00:20:56.423 --> 00:20:58.825
以及其他
引擎相关的网页

00:21:00.060 --> 00:21:03.463
Max Comparison图
帮你研究内存高峰

00:21:03.530 --> 00:21:04.831
这里有一个高的水印

00:21:04.898 --> 00:21:07.401
帮你观察
过去的内存问题

00:21:07.467 --> 00:21:10.437
你甚至可以分离各个峰
通过选择一个特定的部分

00:21:10.504 --> 00:21:14.041
或者在一个峰值周围
选择一个特定的时间段

00:21:14.541 --> 00:21:17.945
然后你就可以使用
下面的目录分类

00:21:18.011 --> 00:21:20.180
来看看是什么
造成了大部分高峰

00:21:20.781 --> 00:21:23.784
这里的每个图表
都是独立测量的

00:21:23.851 --> 00:21:26.653
所以你可以清楚地看到
不同时间的变化

00:21:28.021 --> 00:21:30.591
JavaScript里的峰值
显示的是

00:21:30.657 --> 00:21:33.527
大量新对象
被创建和引用的地方

00:21:33.660 --> 00:21:36.763
其中包括的对象
有字符串对象和函数

00:21:37.164 --> 00:21:41.201
以及所有支持它们的引擎数据
比如结构数据和编译代码

00:21:41.902 --> 00:21:44.605
当你看到
JavaScript的用量下降

00:21:44.671 --> 00:21:47.241
就是说垃圾回收
在回收内存

00:21:48.308 --> 00:21:50.811
图片显示了
分配给图片的内存

00:21:50.878 --> 00:21:52.713
这些图片都
通过解码显示

00:21:52.980 --> 00:21:54.815
这里的图片数据
比较大

00:21:54.882 --> 00:21:57.551
通常用于
可以在视口显示的图片

00:21:59.052 --> 00:22:01.722
层显示的是
图层内存

00:22:01.788 --> 00:22:04.858
分配在WebKits
tileGrid复合层

00:22:04.925 --> 00:22:06.093
和其他引擎层

00:22:07.227 --> 00:22:08.896
页面就囊括了
所有其他的东西

00:22:08.962 --> 00:22:10.931
引擎所追踪的
所有内容

00:22:10.998 --> 00:22:14.234
比如DOM和页面风格
以及字体渲染数据

00:22:14.301 --> 00:22:16.470
内存缓存和系统分配

00:22:17.271 --> 00:22:19.306
所以这个分类
能让你很好的保证

00:22:19.373 --> 00:22:22.242
内存用量
符合你的预期

00:22:22.943 --> 00:22:26.446
若你有很多JavaScript内容
你要明白

00:22:26.513 --> 00:22:30.150
JavaScript会是分类图表里
用量最多的一类

00:22:30.217 --> 00:22:33.086
在时间线图表里
你可能会随着时间看到更多变化

00:22:33.954 --> 00:22:38.125
但是对于多图片的页面
比如画廊

00:22:38.192 --> 00:22:41.428
那么分层和图片目录
就可能是最大的

00:22:41.495 --> 00:22:42.896
随着时间
变化也更多

00:22:43.830 --> 00:22:47.501
这就是Safari 10里
最新的Memory时间线

00:22:49.203 --> 00:22:53.540
Memory时间线的补充就是
新的JavaScript Allocations时间线

00:22:54.074 --> 00:22:56.343
你不仅能看到
不同时间里内存的变化

00:22:56.510 --> 00:22:58.111
还能更细的探究

00:22:58.178 --> 00:23:00.781
JavaScript Allocations
的真实情况

00:23:00.948 --> 00:23:06.553
对此我们有个强大的工具
JavaScript Allocation Snapshots

00:23:07.321 --> 00:23:08.889
快照的强大之处

00:23:08.956 --> 00:23:12.426
是你可在JavaScripts堆里
对一个时刻进行快照

00:23:12.726 --> 00:23:15.696
然后你就可以深入看到
所有被分配的东西

00:23:16.129 --> 00:23:18.765
但是更强大的是
你有两个快照的时候

00:23:19.466 --> 00:23:22.436
你就可以回头再看
并进行对比

00:23:22.503 --> 00:23:25.639
对比快照
是我们最强大的工具之一

00:23:25.706 --> 00:23:29.243
它可以解答
我是不是做了不必要的分配？

00:23:30.110 --> 00:23:32.579
一定要利用它
因为你需要多个快照

00:23:32.646 --> 00:23:36.783
这也就是为什么
默认每10秒照一次

00:23:37.217 --> 00:23:39.753
不仅要在记录开始
还要在结束

00:23:40.153 --> 00:23:42.923
快照是在时间线上设计的
所以它们能连到

00:23:42.990 --> 00:23:44.825
其他时间线上
发生的事情

00:23:44.892 --> 00:23:46.894
在这里
其他的都被我关了

00:23:48.128 --> 00:23:50.330
这些快照在下面列出
并附了一些细节

00:23:50.397 --> 00:23:51.899
比如堆的
时间和大小

00:23:52.766 --> 00:23:54.501
要了解一个特定的问题

00:23:54.568 --> 00:23:56.870
就通常需要
在开始和结束的时候快照

00:23:56.937 --> 00:23:58.739
围绕你认为
内存会出问题的地方

00:23:59.173 --> 00:24:00.541
这里有三个技巧

00:24:01.074 --> 00:24:03.710
你可以依赖自动快照
每10秒一次

00:24:04.478 --> 00:24:07.247
或者可以亲自快照
就按快照键

00:24:08.282 --> 00:24:09.750
或者用代码执行

00:24:10.551 --> 00:24:14.254
最简单的找到问题的方法
还是改代码

00:24:14.555 --> 00:24:16.623
调出
takeHeapSnapshot API

00:24:16.690 --> 00:24:19.526
传递一个自定义的标签参数
它可以是任何

00:24:19.593 --> 00:24:21.261
之后能帮你识别它的东西

00:24:21.695 --> 00:24:24.198
还有你要做
一对快照

00:24:24.264 --> 00:24:27.100
在你认为导致问题的代码
的前后

00:24:28.035 --> 00:24:30.537
你还可以通过快照
来使用这个代码

00:24:30.604 --> 00:24:32.940
在一个循环内的
工作之间

00:24:33.340 --> 00:24:34.308
分析内存

00:24:34.374 --> 00:24:38.846
下面讲讲要时刻牢记的几点
关于takeHeapSnapshot API

00:24:39.179 --> 00:24:43.050
要记住快照会增添一些额外的进程
在垃圾回收进程中

00:24:43.116 --> 00:24:45.552
这会影响性能
所以你一定要注意

00:24:45.619 --> 00:24:48.088
你的代码是否
频繁的发射快照

00:24:49.189 --> 00:24:52.726
你也要捕捉到
前后不同的信息

00:24:52.793 --> 00:24:55.462
当代码在一个循环之间的
某个时刻运行时

00:24:56.630 --> 00:24:57.698
不要留下这个

00:24:57.764 --> 00:25:00.734
如果你把它留下
对大部分用户来说没问题

00:25:00.801 --> 00:25:04.204
但一旦有人运行网络检查器
它们就会使用所有的快照

00:25:04.271 --> 00:25:05.506
你大概也不想这样

00:25:05.572 --> 00:25:08.876
所以要记住
在启动前一定把它们删除

00:25:09.776 --> 00:25:11.411
那么这些快照
都显示了什么？

00:25:13.146 --> 00:25:14.181
让我们来看一看

00:25:14.848 --> 00:25:18.619
你只要点击时间线上的
快照图标

00:25:18.685 --> 00:25:21.555
或者在快照列表条目里
点击Arrow按键

00:25:22.422 --> 00:25:25.225
你看到的这一列对象
都是之前分配在堆里的

00:25:25.292 --> 00:25:27.294
快照有两个视图

00:25:27.694 --> 00:25:29.129
这是Instances视图

00:25:29.196 --> 00:25:33.033
展示了堆里的对象列表
按照类来分组

00:25:33.634 --> 00:25:35.736
另一个是
对象图像视图

00:25:35.802 --> 00:25:37.871
这实际上
概括了所有东西

00:25:37.938 --> 00:25:40.073
所有的所有

00:25:40.507 --> 00:25:42.109
如果你很熟悉这个代码

00:25:42.176 --> 00:25:45.946
它就能很好地帮助你
确认事情或者找到相应的位置

00:25:46.947 --> 00:25:49.183
但是实际上
更有用的视图

00:25:49.249 --> 00:25:51.785
是在Instances视图里

00:25:51.852 --> 00:25:54.221
它的强大在于
你可以轻松地找到对象

00:25:54.288 --> 00:25:57.057
不论他们在属性路径里
藏得多深

00:25:57.958 --> 00:26:00.494
这里的Count可以帮你
意识到潜在的问题

00:26:00.561 --> 00:26:02.162
就是它们
无法达到预期的时候

00:26:02.229 --> 00:26:05.199
比如我能否实现
4000多个字符串对象？

00:26:06.733 --> 00:26:10.470
你可以展开这个Classes
来看看所有分配到这里的对象

00:26:11.238 --> 00:26:14.942
然后判断什么是什么
通过这么多不同的线索

00:26:15.008 --> 00:26:16.076
Class是一线索

00:26:16.944 --> 00:26:19.379
另外就是
对象的实际属性

00:26:19.713 --> 00:26:21.648
这能让我们很快了解
什么是什么

00:26:22.516 --> 00:26:24.785
但是最简单的
了解对象的方法

00:26:24.852 --> 00:26:29.323
就是悬停在这个对象识别器上
你就会看到这个

00:26:30.924 --> 00:26:34.795
这里实际上显示的是
到对象的最短路径

00:26:35.362 --> 00:26:38.098
它告诉了你究竟是什么
让这个对象保持活动

00:26:38.732 --> 00:26:40.868
它基本上总会给你
你需要的答案

00:26:41.768 --> 00:26:45.572
特别是在JavaScript的
垃圾回收里

00:26:45.639 --> 00:26:48.509
这就是能
立刻解开疑惑的方法

00:26:49.643 --> 00:26:53.013
但是它最重要的功能
和最关键的要点

00:26:53.080 --> 00:26:55.048
在于它能
比较两个快照

00:26:55.349 --> 00:26:57.551
看看这个
当你已经收集了一些快照

00:26:58.218 --> 00:27:00.521
只要点击此处“比较快照”按键

00:27:01.321 --> 00:27:04.992
然后选择Baseline快照
再选一个对比

00:27:05.792 --> 00:27:06.627
一下子

00:27:07.027 --> 00:27:09.263
你就有了一个
新的对比快照可以研究

00:27:09.796 --> 00:27:11.131
这个十分有意义

00:27:11.498 --> 00:27:13.467
因为现在只能看到
新的对象

00:27:13.534 --> 00:27:16.637
在两个点之间
在两个快照之间

00:27:18.172 --> 00:27:21.475
展开对象类分组
可以看到所有的对象分配

00:27:21.542 --> 00:27:24.945
预览中显示了它们的名字
和类似遥测数据的东西

00:27:25.646 --> 00:27:27.848
这里就说明
它是卫星对象

00:27:28.348 --> 00:27:31.151
这里的弹窗显示
_Satellites Array属性

00:27:32.319 --> 00:27:34.054
由于这是
一个快照对比

00:27:34.121 --> 00:27:36.857
卫星的对象
都是新分配的

00:27:36.924 --> 00:27:39.359
这是个很重要的线索
显示代码在做什么

00:27:39.893 --> 00:27:42.296
那么为了让你们实际看到
这些新的存储功能

00:27:42.362 --> 00:27:44.798
我要有请Brian回到台上
来做另一个演示

00:27:51.171 --> 00:27:52.005
谢谢 Jon

00:27:52.606 --> 00:27:55.742
我把卫星跟踪器
给了我的朋友Ed

00:27:55.809 --> 00:27:58.545
他熬了一夜
在玩这个

00:28:00.113 --> 00:28:04.251
他很开心
因为他从来没有被卫星跟踪过

00:28:04.351 --> 00:28:05.452
但是这就有个问题

00:28:05.519 --> 00:28:09.122
它运行时间越长
最终会变得越来越慢

00:28:09.790 --> 00:28:13.026
这在我看来
很像传统的内存

00:28:13.093 --> 00:28:15.262
打开时间越久
就越慢

00:28:15.929 --> 00:28:20.601
我想在卫星跟踪器里
用这些新存储工具来看看

00:28:20.667 --> 00:28:22.369
我们是否泄漏了
一些内存

00:28:23.637 --> 00:28:26.173
那么第一件事

00:28:26.240 --> 00:28:28.575
我的iPad在这儿

00:28:29.309 --> 00:28:31.545
我要回到
网络检查器...

00:28:34.381 --> 00:28:35.782
并且检查这个应用

00:28:36.717 --> 00:28:38.418
我要做的第一件事

00:28:39.286 --> 00:28:43.857
在我不知道问题在哪儿的时候
就是要使用Memory时间线

00:28:43.924 --> 00:28:48.595
它会告诉我
页面上大概发生了什么

00:28:48.662 --> 00:28:50.030
那么我们开始记录

00:28:51.131 --> 00:28:52.766
转回来

00:28:52.833 --> 00:28:57.604
我在两个卫星之间
来回切换

00:28:58.138 --> 00:29:00.741
也许我会在这里
添加一些效果

00:29:02.142 --> 00:29:04.611
好的
我在来回切换

00:29:06.613 --> 00:29:08.048
好了
现在去时间线看看

00:29:11.351 --> 00:29:15.422
在时间线概览中
你看到一个堆积线形图

00:29:15.489 --> 00:29:17.624
显示了所有不同的部分
和相关的大小

00:29:17.858 --> 00:29:21.128
如果你点击这里
会看到更多的细节

00:29:22.563 --> 00:29:24.831
那么这个页面上
没有图片

00:29:24.898 --> 00:29:25.766
都是画布

00:29:26.400 --> 00:29:27.801
分层也很平面

00:29:28.268 --> 00:29:30.804
页面有些波动
有些内容在垃圾回收

00:29:30.871 --> 00:29:31.705
没有问题

00:29:32.306 --> 00:29:35.175
如果你仔细看看JavaScript
你会看到...

00:29:35.776 --> 00:29:37.444
虽然有些东西
被垃圾回收

00:29:37.511 --> 00:29:40.280
但是整体来说
它还是在随着时间堆积

00:29:40.614 --> 00:29:44.318
如果我们运行一整晚
那估计会堆积更多

00:29:44.952 --> 00:29:51.358
下一步就是启用heap快照
或allocation快照

00:29:51.425 --> 00:29:54.194
这样我们就能找到
随着时间而分配的内容

00:29:56.630 --> 00:30:00.667
为了实现这个
我们要开始新的记录

00:30:03.103 --> 00:30:06.139
这有个快捷键
Shift 点击或Shift 空格

00:30:06.206 --> 00:30:08.942
这样就会启动新的记录
而不是继续之前那个

00:30:09.510 --> 00:30:11.778
等等
我忘了改时间线

00:30:11.845 --> 00:30:13.046
去掉Memory

00:30:14.314 --> 00:30:15.916
选上Allocations

00:30:18.252 --> 00:30:19.520
好了
开始记录

00:30:20.387 --> 00:30:21.288
回到iPad

00:30:23.190 --> 00:30:25.759
添加了小小的
takeHeapSnapshot键

00:30:25.826 --> 00:30:29.229
我已给控制台添加了
一些takeHeapSnapshot的调令

00:30:29.296 --> 00:30:32.633
用于切换两个卫星小组
和其他操作

00:30:33.800 --> 00:30:38.038
对这个记录
我要转动地图

00:30:38.105 --> 00:30:41.942
然后不断在
两个卫星中切换

00:30:46.580 --> 00:30:49.416
我们还要看看Spy Satellites
看上去也有关联

00:30:52.419 --> 00:30:54.254
好了 你会发现
开始有点卡了

00:30:54.321 --> 00:30:57.591
因为我们给JavaScript堆里的
所有东西拍了快照

00:30:57.658 --> 00:31:00.060
因此
产生了很多对象

00:31:00.127 --> 00:31:01.795
这会大幅降低
应用的速度

00:31:01.862 --> 00:31:05.265
所以一定不要
拍很多快照

00:31:05.332 --> 00:31:08.435
只在重要的时候拍

00:31:08.802 --> 00:31:13.974
这里你可以看到方块里的S
就是我们拍的快照

00:31:16.043 --> 00:31:18.812
放大一下能看到

00:31:18.879 --> 00:31:20.814
随着时间过去
内存十分稳定的增长

00:31:20.881 --> 00:31:23.584
当我们开始在
两个卫星之间切换的时候

00:31:26.753 --> 00:31:29.056
如果我们要研究这个
像Jon说的那样

00:31:29.122 --> 00:31:35.829
我们就要启动对比
来看看是什么被拦住了

00:31:35.896 --> 00:31:40.167
那么我们就对比
快照9和11

00:31:41.602 --> 00:31:45.072
立刻
我们就看到很多东西

00:31:45.138 --> 00:31:49.443
被分配在9和11之间
并且仍然在活动中

00:31:49.943 --> 00:31:52.412
这就清楚地说明了
它们被留存了

00:31:52.479 --> 00:31:54.648
虽然我们
并不想这么做

00:31:55.649 --> 00:31:57.551
那么我们来看看
这些都是什么

00:31:58.752 --> 00:31:59.620
这是些阵列

00:32:00.454 --> 00:32:03.423
看上去这个阵列里
全是坐标

00:32:04.858 --> 00:32:07.728
你知道在应用的不同部分
我们会用大量的坐标

00:32:07.794 --> 00:32:11.164
但是如果我们停在这里
就会看到它的路径

00:32:11.265 --> 00:32:14.701
它们好像是被保存于
trajectoryHistory

00:32:14.768 --> 00:32:18.572
这是我们用来制作
追踪卫星的东西

00:32:19.973 --> 00:32:21.375
好的
这样不错

00:32:21.441 --> 00:32:23.710
但是我想不应该

00:32:25.112 --> 00:32:27.714
再在已不显示的卫星里用
trajectoryHistory

00:32:27.781 --> 00:32:29.416
这好像是个bug

00:32:31.985 --> 00:32:33.620
我们也分配了
一些对象

00:32:35.055 --> 00:32:39.526
但奇怪的是
在快照9和11之间

00:32:39.593 --> 00:32:41.795
我们之前已经看到
这些卫星

00:32:41.862 --> 00:32:45.065
那么我就不想
再给每个卫星创建新的对象

00:32:45.132 --> 00:32:48.735
我们只要直接使用它们
只要我们已经为他们获取了资源

00:32:48.802 --> 00:32:53.140
然后这里有了很多
坐标和遥测

00:32:53.207 --> 00:32:56.476
好像正在
重新解析什么

00:32:58.045 --> 00:32:59.646
我不太确定
那么...

00:33:00.113 --> 00:33:03.851
在这个视图里
我们有很多对象

00:33:03.917 --> 00:33:05.085
你不能读取所有

00:33:05.152 --> 00:33:08.355
所以我想做的
就是找出很特别的那一个

00:33:08.856 --> 00:33:10.357
那么在这个快照里

00:33:11.825 --> 00:33:13.861
我们有很多字符串
阵列和对象

00:33:13.927 --> 00:33:15.395
但只有一个Promise

00:33:15.829 --> 00:33:17.831
它停留在
两个快照之间

00:33:17.898 --> 00:33:19.900
所以我认为
应该调试这个

00:33:19.967 --> 00:33:24.071
那么我就找到代码
看看是哪里在用Promises

00:33:24.371 --> 00:33:27.274
因为好像它与别的什么
一起被泄露了

00:33:27.441 --> 00:33:29.576
于是
搜索Promise

00:33:30.077 --> 00:33:34.882
好了 这是D3库
这是使用它的代码

00:33:37.251 --> 00:33:39.052
好的
来看看这个

00:33:39.887 --> 00:33:44.892
好了 在［听不清］里
我们常常在卫星之间切换

00:33:44.958 --> 00:33:46.593
代码是loadDataset

00:33:46.793 --> 00:33:50.631
有人写了评论
太好了

00:33:51.665 --> 00:33:56.103
这里看上去好像
有人请求我们改变卫星

00:33:57.271 --> 00:34:03.710
那么这里就可以
异步从URL下载数据

00:34:03.777 --> 00:34:06.046
当它返回
我们就要解析

00:34:07.414 --> 00:34:10.918
然后使用卫星绘图库 
做更多的解析

00:34:11.784 --> 00:34:13.887
然后我们把它存到
卫星列表上

00:34:15.389 --> 00:34:18.525
这都很不错
但是回到检查器

00:34:18.592 --> 00:34:20.527
我们好像每次都泄露该Promise

00:34:20.594 --> 00:34:22.929
如果你更仔细的想想

00:34:22.996 --> 00:34:25.732
如果切换到
已经下载的数据组会怎样？

00:34:26.967 --> 00:34:29.235
我们甚至都没有
检查过这个事情

00:34:30.237 --> 00:34:33.373
你仔细的看看这里

00:34:34.107 --> 00:34:36.577
每次在两个卫星之间转换

00:34:37.277 --> 00:34:38.812
我们就发出
一个新的网络请求

00:34:38.879 --> 00:34:40.179
如果我们进入这个时间线

00:34:41.014 --> 00:34:44.618
就会看到我们在不断请求
同样的垃圾数据

00:34:46.018 --> 00:34:49.523
这是正常的
如果回到代码 发出请求

00:34:49.590 --> 00:34:51.859
解析的时候
会产生大量的对象

00:34:52.492 --> 00:34:54.293
然后我们把它推入
卫星阵列

00:34:54.360 --> 00:34:56.697
就目前来看
它怎么都不清楚

00:34:56.763 --> 00:35:02.202
我们好像一直在做无用功
然后不断泄露

00:35:02.269 --> 00:35:04.838
所以这里
我们要做的

00:35:04.905 --> 00:35:08.475
是检查我们是否已经
解析了这个卫星对象

00:35:08.742 --> 00:35:10.043
因为这是Promise

00:35:10.344 --> 00:35:14.081
如果它确实存在
我们可以调出.then

00:35:14.848 --> 00:35:18.886
由于这已解决
下一次评估Promise的反应时

00:35:18.952 --> 00:35:22.556
它就会进行检查
并将卫星放到地图上

00:35:23.657 --> 00:35:26.960
那么在这里
添加代码

00:35:30.664 --> 00:35:33.734
如果不存在
我们就创建一个

00:35:42.242 --> 00:35:47.314
好了 现在停下来看看
有没有效果

00:35:50.117 --> 00:35:52.352
我们就要回去
重新连接

00:35:55.923 --> 00:35:59.993
这是我们的应用
开始记录吧

00:36:02.329 --> 00:36:05.132
当我们回到应用
我就打开快照

00:36:05.632 --> 00:36:06.700
打开一些效果

00:36:06.800 --> 00:36:10.237
然后往南走

00:36:10.804 --> 00:36:13.240
好的 间谍卫星

00:36:14.274 --> 00:36:16.777
卫星的科学实验

00:36:17.811 --> 00:36:18.779
科学实验

00:36:20.480 --> 00:36:21.315
好了

00:36:24.885 --> 00:36:28.455
如果我们回到这里
我们看到内存的增长大大降低

00:36:28.522 --> 00:36:31.959
大概在1兆
而不是四五兆

00:36:32.025 --> 00:36:34.228
那么这里可能有
更多的泄露

00:36:34.294 --> 00:36:38.665
但是在快照结束的时候
我们的内存

00:36:38.732 --> 00:36:41.168
跟刚开始渲染的时候
一样大

00:36:41.235 --> 00:36:43.537
这样我们就修复了
这个特殊的泄露

00:36:44.805 --> 00:36:49.710
这就展示了我们如何使用
Allocations和Memory时间线

00:36:49.776 --> 00:36:53.547
来解决像这样的
应用的内存泄露问题

00:36:54.114 --> 00:36:58.585
这很不错
因为应用可以用更多的操作

00:36:58.652 --> 00:37:00.954
有了diffing功能

00:37:01.021 --> 00:37:04.825
我们就可以深入观察
我们所关心的卫星里的变化

00:37:06.660 --> 00:37:09.062
好了
卫星跟踪器就讲到这

00:37:10.197 --> 00:37:11.031
你回来吧 Jon

00:37:16.670 --> 00:37:17.504
谢谢 Brian

00:37:17.738 --> 00:37:21.241
你看到了
真是不可思议的迅速和简单

00:37:21.308 --> 00:37:24.845
这些新的时间线
让内存零问题

00:37:25.512 --> 00:37:27.748
所以请记住
Memory时间线是了解

00:37:27.814 --> 00:37:30.317
内存的使用情况
和造成内存高峰的原因

00:37:30.384 --> 00:37:32.119
这样你就知道
该去哪里找问题

00:37:33.020 --> 00:37:37.291
然后使用多个Heap快照
在JavaScript Allocations时间线里

00:37:37.357 --> 00:37:39.826
以便单独放大
造成内存增长的代码

00:37:40.761 --> 00:37:43.363
还有不要忘了删除
takeHeapSnapshot

00:37:43.430 --> 00:37:44.932
在代码运行之前

00:37:46.066 --> 00:37:48.101
要记住性能所受的影响

00:37:48.168 --> 00:37:51.505
是JavaScript Allocations
时间线记录时产生的

00:37:53.607 --> 00:37:56.577
那么以上就是
新的时间线工具

00:37:56.643 --> 00:37:58.445
可用在Safari 10的
网络检查器上

00:37:58.979 --> 00:38:00.747
我想你一定会
爱上它们

00:38:01.982 --> 00:38:04.852
在结束之前
我还想再说几点

00:38:05.586 --> 00:38:08.355
我要建议你们
重新考虑下WKWebView

00:38:08.422 --> 00:38:09.623
如果你还没有换掉它

00:38:11.358 --> 00:38:13.493
在Safari设置里
打开Develop菜单

00:38:13.560 --> 00:38:15.262
连接网络检查器
到你的应用

00:38:15.329 --> 00:38:17.631
然后开始利用
这些新功能

00:38:18.031 --> 00:38:21.468
节省大量时间
Bottom Up视图和Call Trees用于

00:38:21.535 --> 00:38:23.504
找到最需要优化的地方

00:38:23.570 --> 00:38:26.974
Memory时间线可以
快速看到内存高峰的情况

00:38:27.140 --> 00:38:31.111
Heap快照可以
轻松查找和比较对象分配

00:38:32.379 --> 00:38:33.881
时刻关注
新功能的更新

00:38:33.947 --> 00:38:36.550
今年网络检查器
和WebKit有更多内容

00:38:36.617 --> 00:38:39.486
可以让你利用
应用的网页内容

00:38:39.620 --> 00:38:41.722
来创造绝佳的
应用内的用户体验

00:38:42.789 --> 00:38:45.225
除了Brian和我
今天为你们展示的功能

00:38:45.292 --> 00:38:48.562
我们团队过去一年也为
网络检查器添加了很多内容

00:38:49.396 --> 00:38:53.500
Quick Open会让你直接跳到
页面加载的资源

00:38:53.867 --> 00:38:58.739
尾调用堆栈
现在可显示调试器里的尾调用优化函数

00:38:59.339 --> 00:39:02.809
初春的时候在OS 10系统下
我们引进了Safari 9.1

00:39:03.277 --> 00:39:05.245
并更新了
网络检查器

00:39:05.913 --> 00:39:09.416
它显示了Elements标签下
DOM Tree里的Pseudo Elements

00:39:09.883 --> 00:39:12.319
这里还有一个
新的视觉风格边栏

00:39:13.787 --> 00:39:15.489
可能你还没注意到

00:39:15.756 --> 00:39:17.991
网络检查器
是一个开发者工具

00:39:18.058 --> 00:39:20.527
作为WebKit开源项目的一部分

00:39:21.962 --> 00:39:25.199
WebKit是网页浏览器引擎
用来支持你的应用

00:39:25.265 --> 00:39:27.668
驱动WebViews
和JSContext

00:39:28.068 --> 00:39:30.137
当然它也是Safari
背后的动力

00:39:31.004 --> 00:39:34.508
在过去一年里
我们为WebKit添加了好多新功能

00:39:34.575 --> 00:39:36.910
我们对ES6
100％支持

00:39:37.678 --> 00:39:40.714
我们改进了对IndexedDB
Standard的支持

00:39:41.215 --> 00:39:45.219
还添加了Shadow DOM支持
WebDriver和CSS变量

00:39:45.619 --> 00:39:46.753
以及Picture Element

00:39:47.688 --> 00:39:50.224
所以真的是很多内容
而且作为开源项目

00:39:50.290 --> 00:39:52.559
一旦有新的出现
你就能知道

00:39:53.060 --> 00:39:55.329
你们在座大部分人
肯定都想能利用它工作

00:39:55.395 --> 00:39:58.365
如果你们想
对这些内容作出改进

00:39:58.432 --> 00:39:59.433
完全有机会

00:39:59.499 --> 00:40:01.702
因为WebKit
是开放资源

00:40:02.669 --> 00:40:05.906
你可在WebKit.org上
找到更多WebKit项目信息

00:40:05.973 --> 00:40:09.710
WebKit团队及其背后的
工程师们会在博客上写他们的开发工作

00:40:09.776 --> 00:40:11.778
实际上
我们现在有两个博客

00:40:11.845 --> 00:40:14.648
关于Memory时间线
和样本分析器

00:40:14.715 --> 00:40:15.716
就是今天讲的内容

00:40:15.782 --> 00:40:18.151
所以如果你想了解更多
可以去那里看看

00:40:18.552 --> 00:40:21.355
我们还有一个功能状态页
一目了然的列出了所有更新

00:40:21.421 --> 00:40:22.789
针对网页标准进程

00:40:23.357 --> 00:40:26.260
这里还有链接
可以下载WebKit夜间建构

00:40:26.727 --> 00:40:29.930
和最新的浏览器
Safari技术概览

00:40:30.797 --> 00:40:34.201
每几周更新一次
附带更新的WebKit引擎

00:40:34.668 --> 00:40:37.871
所以你可以在WebKit上
尝试这些新的实验性功能

00:40:37.938 --> 00:40:39.606
它们每两周改进一次

00:40:40.474 --> 00:40:44.411
我们团队投入了大量精力给Safari
WebKit和网络检查器

00:40:44.478 --> 00:40:47.581
网络检查器团队
可以使用这些新性能特性

00:40:47.648 --> 00:40:50.918
就像我们今天展示的那样
去查询问题并提高性能

00:40:50.984 --> 00:40:52.419
对网络检查器本身

00:40:52.619 --> 00:40:54.555
我已经迫不及待
想看看你们会做些什么

00:40:54.855 --> 00:40:56.590
想了解更多信息
请观看这个演讲

00:40:56.657 --> 00:40:59.259
在developer.apple.com
下载幻灯片

00:41:00.093 --> 00:41:03.163
这周的前几天有很多场相关演讲

00:41:03.230 --> 00:41:04.831
过去几年也有不少

00:41:05.098 --> 00:41:07.835
这些都能在
developer.apple.com上找到

00:41:08.769 --> 00:41:12.606
那么代表Brian 我自己
和Safari与WebKit团队

00:41:12.673 --> 00:41:15.442
感谢你们的到来
祝大家在接下来的WWDC中过得愉快