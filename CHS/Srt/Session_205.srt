00:00:20.020 --> 00:00:21.989 
COCOA TOUCH的新特性

00:00:22.055 --> 00:00:22.890 
下午好

00:00:24.491 --> 00:00:25.325 
欢迎各位

00:00:28.028 --> 00:00:31.265 
我叫Olivier Gutknecht
负责管理UIKit 团队

00:00:31.765 --> 00:00:35.602 
今天我们要探讨UIKit的新功能

00:00:36.103 --> 00:00:39.139 
以及iOS X 中的其他系统架构

00:00:40.574 --> 00:00:44.278 
但我首先想说的是

00:00:44.845 --> 00:00:48.448 
COCOA TOUCH的旧特性

00:00:49.650 --> 00:00:55.122 
为什么？自从上届 WWDC 以来

00:00:55.189 --> 00:00:56.657 
我们引进了大量的重要产品

00:00:57.925 --> 00:01:01.495 
带有3D Touch
的iPhone 6S

00:01:02.262 --> 00:01:05.364 
9.7和12.9英寸的
iPad Pro

00:01:07.267 --> 00:01:11.638 
还有Apple Pencil
和Smart Keyboard

00:01:12.639 --> 00:01:18.145 
而且 这些产品采用了多项关键技术

00:01:18.212 --> 00:01:21.682 
采用这些技术可以让你的应用更出色

00:01:22.749 --> 00:01:25.853 
我首先想谈的是自适应性

00:01:27.221 --> 00:01:30.591 
我们2年前引进了自适应性

00:01:31.191 --> 00:01:35.229 
我们当时引入的
一项技术是尺寸分级概念

00:01:36.196 --> 00:01:39.900 
iPhone是一个紧凑型产品

00:01:41.001 --> 00:01:43.437 
iPad是常规产品

00:01:44.471 --> 00:01:47.474 
现在我们有了12.9英寸
的iPad Pro

00:01:48.542 --> 00:01:50.744 
我们需要更大的尺寸等级吗

00:01:52.179 --> 00:01:53.113 
我们不需要

00:01:54.481 --> 00:01:57.150 
因为现在我们拥有所有工具

00:01:57.651 --> 00:02:00.254 
在架构中表达它

00:02:01.255 --> 00:02:02.823 
我们拥有特征系统

00:02:02.956 --> 00:02:05.325 
它决定你的应用如何理解

00:02:05.826 --> 00:02:09.096 
你的应用的上下文和背景

00:02:09.329 --> 00:02:13.133 
尺寸等级是一个很重要的特征

00:02:13.667 --> 00:02:14.868 
但你拥有了需要的一切

00:02:15.135 --> 00:02:18.472 
基于这些设备的布局创建尺寸

00:02:20.040 --> 00:02:22.776 
我们为尺寸等级添加了新的支持

00:02:23.677 --> 00:02:27.748 
在接口Builder和架构本身中

00:02:28.482 --> 00:02:32.753 
包括从自动布局到动态类资产分类

00:02:33.120 --> 00:02:35.422 
配有布局指南 甚至UI外观

00:02:35.956 --> 00:02:38.258 
一切都已准备好 并且完全集成

00:02:39.660 --> 00:02:42.062 
我们还将

00:02:42.396 --> 00:02:45.933 
在本周举行制作应用自适应布局
的两场研习会

00:02:45.999 --> 00:02:50.103 
第一场研习会重点关注基础知识和工具

00:02:50.671 --> 00:02:53.941 
第二场研习会将关注API

00:02:54.074 --> 00:02:57.377 
以及你用于制作自适应的技术

00:02:58.145 --> 00:03:00.914 
今天早上举行了一场令人惊叹的研习会

00:03:00.981 --> 00:03:03.116 
重点介绍的是设计 你应该看看

00:03:05.319 --> 00:03:08.655 
我其次想谈的是触控输入

00:03:10.257 --> 00:03:14.962 
去年iPad Air 2上市
现在是iPad Pro

00:03:15.596 --> 00:03:18.332 
我们采用了120 Hz触控扫描

00:03:18.699 --> 00:03:22.569 
我们的扫描速度比屏幕刷新率快

00:03:23.403 --> 00:03:27.107 
配备Apple Pencil之后
我们有了另外的性能

00:03:27.474 --> 00:03:32.179 
通过触控技术
你可以获得精准定位 力度

00:03:33.480 --> 00:03:37.284 
在iPhone 6S上
你也有相同的力度信息

00:03:37.351 --> 00:03:43.090 
3D Touch技术
已用在iOS 9和iOS 9.1上

00:03:43.957 --> 00:03:49.162 
你需要用API在这些设备上
创建令人惊讶的UI

00:03:49.596 --> 00:03:51.665 
Dominique Wagner
将为你展示

00:03:51.732 --> 00:03:54.568 
如何在iOS上利用触控输入

00:03:58.005 --> 00:04:02.743 
我最后想谈的是
Smart Keyboard

00:04:03.677 --> 00:04:08.749 
我们为你提供了一个API
你可以在应用上实现键盘快捷键

00:04:09.349 --> 00:04:12.152 
我想 你现在有更多用户

00:04:12.219 --> 00:04:14.154 
通过键盘和你的应用交互

00:04:14.888 --> 00:04:18.959 
所以上下文快捷键需求获得增长

00:04:19.860 --> 00:04:21.928 
为此采用API是合理的

00:04:23.096 --> 00:04:25.999 
其实API在iOS 7中是新的

00:04:27.100 --> 00:04:29.736 
它变得重要起来
因为自iOS 9之后

00:04:30.270 --> 00:04:33.874 
我们可以展示这些漂亮的自动快捷键

00:04:34.208 --> 00:04:35.375 
只需要按住命令键即可

00:04:38.846 --> 00:04:43.350 
现在 让我们来谈谈
Cocoa Touch的新特性

00:04:43.951 --> 00:04:46.520 
我今天想谈四个方面

00:04:47.588 --> 00:04:50.490 
首先是核心技术

00:04:50.991 --> 00:04:53.393 
你可能已经在应用中使用了

00:04:54.261 --> 00:04:59.733 
然后我们要讨论
使用UIKit和其他 API

00:05:00.167 --> 00:05:03.337 
你如何为你的应用构建更好的UI

00:05:03.837 --> 00:05:07.241 
我们将为你展示

00:05:07.307 --> 00:05:10.143 
在iOS X中
新系统特性如何让你的应用更好

00:05:11.478 --> 00:05:13.580 
最后我们还将讨论

00:05:13.981 --> 00:05:16.517 
你的应用自身如何扩展

00:05:16.984 --> 00:05:19.253 
系统的所有新扩展点

00:05:21.455 --> 00:05:23.657 
接下来我们来谈谈这些核心技术

00:05:25.459 --> 00:05:29.263 
Swift 3很可能是
第一个要提到的

00:05:29.897 --> 00:05:36.170 
因为采用Swift 3之后
每个API都焕然一新

00:05:36.803 --> 00:05:40.140 
因为我们改变了规则 我们改变了

00:05:40.741 --> 00:05:43.510 
如何从Objective-C
转化为Swift的方式

00:05:43.777 --> 00:05:47.748 
我们正在这样做 让你的代码更佳

00:05:48.248 --> 00:05:52.319 
所以 在Swift上编写代码时
它给人极强的真实感

00:05:52.653 --> 00:05:55.422 
例如 首选字体

00:05:56.023 --> 00:05:58.325 
我们现在使用第一个参数

00:05:58.559 --> 00:06:00.627 
让意图更明确

00:06:02.329 --> 00:06:05.299 
我们尽量不重复自己UI颜色

00:06:05.365 --> 00:06:08.535 
黑色现在只是白色或黑色

00:06:10.370 --> 00:06:16.476 
对于Swift 3
我最喜欢的是一个方面是

00:06:16.543 --> 00:06:20.581 
AIP和核心图形让人真的感觉非常棒

00:06:20.681 --> 00:06:22.749 
编写UIKit应用时

00:06:23.817 --> 00:06:27.387 
甚至像多线程优化技术（GCD）

00:06:28.689 --> 00:06:31.458 
现在也是一个完整的对象API

00:06:34.695 --> 00:06:36.463 
我们来谈谈GCD

00:06:37.231 --> 00:06:42.803 
还有一种我非常喜欢的功能
很常见的东西

00:06:42.870 --> 00:06:45.806 
通过这项执行技术
创造你自己的私人队列

00:06:46.840 --> 00:06:52.946 
当同步执行队列工作项目时

00:06:53.680 --> 00:06:58.218 
iOS X中出现新的特性
你可以真正设置队列

00:06:58.719 --> 00:07:04.057 
在自动释放池中为每个工作项自动换行

00:07:04.791 --> 00:07:07.828 
真的很容易 你只需创建一个调度队列

00:07:08.428 --> 00:07:11.832 
然后你提供一个释放池工作项目

00:07:12.499 --> 00:07:18.238 
我们有一个完整的GCD
队列及编程研习会

00:07:20.941 --> 00:07:24.077 
还有Foundation框架
它也改编了大量的

00:07:24.144 --> 00:07:28.849 
Swift增强性能 在许多类别中
我们放弃了MS前缀

00:07:29.216 --> 00:07:33.053 
我们有一项主要新功能
我们正在将多种值类型

00:07:33.487 --> 00:07:34.588 
添加至Foundation API上

00:07:35.489 --> 00:07:36.523 
不仅如此

00:07:37.324 --> 00:07:39.960 
我们也全面支持

00:07:40.427 --> 00:07:42.229 
Foundation的单位和计量

00:07:43.664 --> 00:07:48.902 
另外 是为AP 601格式
有一个新的日期格式器

00:07:49.336 --> 00:07:51.438 
如果你知道AP 601是什么

00:07:52.339 --> 00:07:54.074 
你很可能欣喜若狂

00:07:59.780 --> 00:08:05.085 
另一个好功能是我们如何更好地

00:08:05.152 --> 00:08:07.387 
使用新历日期间隔进行日期计算

00:08:07.821 --> 00:08:09.923 
我们举行了两个关于
Foundation的研习会

00:08:10.390 --> 00:08:12.192  
Foundation和
Swift的新特性

00:08:12.259 --> 00:08:13.894  
以及测量和单位

00:08:16.263 --> 00:08:20.934 
昨天 我们宣布支持通用键盘

00:08:21.535 --> 00:08:25.439 
在你的Mac上复制
然后粘贴在你的iOS设备上

00:08:26.240 --> 00:08:28.308 
你如何在你的应用上应用这种功能？

00:08:29.176 --> 00:08:33.547 
只需使用现有UI Pasteboard API
就这么简单

00:08:34.648 --> 00:08:35.948 
你还需要知道另外一点

00:08:38.150 --> 00:08:43.190 
你可能必须在你的设备上
获得很大的资源

00:08:43.323 --> 00:08:45.893 
如果我需要复制一张非常大的图片

00:08:46.627 --> 00:08:48.228 
可能需要一两秒钟

00:08:48.295 --> 00:08:49.530 
你可能会看到这个UI

00:08:50.297 --> 00:08:55.002 
为了避免检索远程数据时的问题

00:08:55.169 --> 00:08:58.372 
你应该首先检查
看看你是否需要相关数据

00:08:58.539 --> 00:09:00.107 
所以为了避免看到这个UI

00:09:00.807 --> 00:09:03.944 
为此在UI Pasteboard上
我们添加了四个新方法

00:09:04.278 --> 00:09:08.982 
因此你可以轻松检查屏幕
URL、图像和颜色

00:09:11.818 --> 00:09:14.154 
在UI Pasteboard上
另外一个特性是

00:09:15.022 --> 00:09:19.226 
你现在可以控制你放在粘贴板上的东西

00:09:19.726 --> 00:09:25.165 
现在你可以在本地设备上限制你的数据

00:09:25.866 --> 00:09:27.801 
或者设置到期日期

00:09:36.043 --> 00:09:38.612 
但我现在想说的是颜色

00:09:40.614 --> 00:09:44.518 
它不是一种软件功能
而是真正的硬件功能

00:09:44.585 --> 00:09:47.788 
在我们新的iMac 5 K上

00:09:48.689 --> 00:09:52.326 
以及9.7 英寸的
iPad Pro 上

00:09:53.760 --> 00:09:57.331 
这是一个技术转变
你现在可以在屏幕上描绘

00:09:58.198 --> 00:10:00.767 
之前在物理上不可能实现的色彩

00:10:01.502 --> 00:10:06.607 
而且 我们正在改变
我们描绘色彩的方式

00:10:07.741 --> 00:10:11.245 
iOS设备曾经使用sRGB颜色空间

00:10:11.879 --> 00:10:16.183 
现在通过这件设备
你将在扩展的sRGB色彩空间内工作

00:10:16.683 --> 00:10:17.851 
这对于你意味着什么？

00:10:18.752 --> 00:10:23.423 
首先 iOS实际上
已经实现色彩管理

00:10:24.024 --> 00:10:30.664 
iOS和TVOS以及在
iOS X中 我们正在公开API

00:10:30.931 --> 00:10:32.566 
从而适应广泛的色彩范围

00:10:34.601 --> 00:10:37.371 
第一种方式是只使用
UI Image View

00:10:38.305 --> 00:10:40.941 
UI Image View实际上
已实现色彩管理

00:10:41.175 --> 00:10:43.710 
始于iOS 9.3
所以你已经准备好了

00:10:44.745 --> 00:10:46.346 
UI Color怎么样呢？

00:10:48.081 --> 00:10:49.716 
我们让它变得很简单

00:10:50.651 --> 00:10:55.289 
我们在其中已设有一个
采用RGB色彩模式的初始化器

00:10:56.657 --> 00:11:01.995 
其中第二个新的初始化器
采用display P3 RGB色彩模式

00:11:03.030 --> 00:11:07.901 
第一个初始化器是你如何绘制任意颜色

00:11:08.168 --> 00:11:10.470 
在扩展的sRGB空间内

00:11:11.405 --> 00:11:14.174 
现在你可以表达超出

00:11:14.474 --> 00:11:18.679 
0-1范围内的色彩
如果你想要超越传统的sRGB

00:11:19.947 --> 00:11:21.915 
第二个是 displayP3

00:11:22.416 --> 00:11:24.351 
displayP3是真正的彩色显示

00:11:24.418 --> 00:11:26.720 
在创作侧非常常见

00:11:26.787 --> 00:11:30.190 
如果你收到一个有广泛色彩的规范

00:11:30.257 --> 00:11:32.326 
很有可能你将使用displayP3

00:11:32.392 --> 00:11:36.196 
这就是为什么我们提供初始化器的原因

00:11:36.396 --> 00:11:37.231 
就是这样的原因

00:11:37.898 --> 00:11:39.800 
我们没有色彩空间分类

00:11:40.400 --> 00:11:43.370 
你只需要使用这两个初始化器
即可大功告成

00:11:47.975 --> 00:11:51.478 
但我现在想谈谈图像渲染

00:11:55.282 --> 00:11:57.484 
图像渲染是

00:11:57.551 --> 00:12:00.521 
你今天可能已经在使用的东西

00:12:00.954 --> 00:12:03.423 
通过UI 图形开始图像上下文

00:12:03.991 --> 00:12:05.726 
添加来自文本API的图像

00:12:06.293 --> 00:12:09.663 
这有几分像你想干就干的事

00:12:10.497 --> 00:12:12.366 
渲染离屏图像

00:12:12.900 --> 00:12:15.035 
因此 这个API有一个问题

00:12:16.136 --> 00:12:21.375 
它实际上是32位sRGB
是一个内置的假定

00:12:22.109 --> 00:12:27.714 
此外 这并非我们最好的API
它在数据块之前就存在

00:12:28.215 --> 00:12:30.450 
而它不是真正可扩展的

00:12:30.517 --> 00:12:34.221 
因此 你编写图像所用的东西

00:12:34.288 --> 00:12:37.257 
开始图像上下文API看起来就像这样

00:12:37.958 --> 00:12:40.627 
我不知道有多少人已犯下这个错误

00:12:40.694 --> 00:12:43.964 
试图在开始图像上下文之后获得图像

00:12:44.498 --> 00:12:45.365 
我肯定犯过这种错

00:12:46.567 --> 00:12:49.236 
但现在 我们有一个新的类型

00:12:50.737 --> 00:12:52.573 
新的 UI 图形渲染类型

00:12:54.241 --> 00:12:58.545 
它带给你的首先是完全的色彩管理

00:12:59.580 --> 00:13:01.515 
它要在默认情况下做正确的事

00:13:02.382 --> 00:13:05.686 
如果你在9.7 英寸的 iPad上

00:13:06.453 --> 00:13:08.889 
你将获得一个广泛的色彩上下文

00:13:09.323 --> 00:13:11.959 
如果不是在该设备上
你可以获得传统上下文

00:13:13.293 --> 00:13:16.330 
另外 它基于数据块设计 易于使用

00:13:16.930 --> 00:13:19.533 
此外 它是一个基于API的对象

00:13:19.600 --> 00:13:23.403 
我们必须为图形和PDF
增加我们的类型

00:13:25.239 --> 00:13:27.774 
此外 很重要的是

00:13:28.642 --> 00:13:32.980 
这个类型将管理
你的色彩上下文的生存期

00:13:33.547 --> 00:13:37.150 
这意味着我们可以在
hood下做一些内存优化

00:13:38.218 --> 00:13:39.319  
让我给你举个例子

00:13:40.554 --> 00:13:46.393  
相当于之前的情况
你只需要创建你的渲染器

00:13:48.262 --> 00:13:49.763  
你试图生成一个图像

00:13:50.297 --> 00:13:54.101  
它只要提供数据块
这里是你的绘制代码

00:13:55.102 --> 00:13:56.870  
有关这一点最酷的事是

00:13:57.504 --> 00:14:00.908  
如果你再次调用 这里的图像方法

00:14:01.441 --> 00:14:04.578  
我们打算仅再次使用这个上下文

00:14:10.784 --> 00:14:17.357 
图像相关的一个新功能是资源分类

00:14:18.492 --> 00:14:23.297 
我们拥有资源分类 支持各种色彩资源

00:14:24.264 --> 00:14:28.402 
从右到左和从左到右的资源
以及压缩功能

00:14:29.303 --> 00:14:31.038 
当然它们是完全集成于

00:14:31.271 --> 00:14:33.607 
UIKit的特色系统

00:14:34.675 --> 00:14:36.877 
所以 让我们看看第一个

00:14:37.945 --> 00:14:38.912 
什么是色彩资源？

00:14:38.979 --> 00:14:40.514 
我们想在这里做什么？

00:14:41.281 --> 00:14:44.985 
如果你嵌入广泛的色彩资源

00:14:45.452 --> 00:14:48.689 
在你的应用中 你希望能够部署

00:14:49.323 --> 00:14:51.058 
在非全彩色设备上

00:14:51.725 --> 00:14:53.627 
因此 我们想做的是

00:14:53.694 --> 00:14:59.233 
我们将为你自动提供一代sRGB变体

00:15:00.067 --> 00:15:02.870 
它将弯曲和
App Thinning兼容

00:15:02.936 --> 00:15:05.639 
所以我们将只部署需要的东西

00:15:06.173 --> 00:15:07.207 
在正确的设备上

00:15:11.879 --> 00:15:15.349 
资源分类中的另外一个新功能是压缩

00:15:16.917 --> 00:15:20.053 
我们添加了对有损压缩方案的支持

00:15:21.088 --> 00:15:26.460 
而且它自动挑选 如果你选择了它

00:15:27.961 --> 00:15:32.165 
它会为给定设备生成正确的变体

00:15:32.232 --> 00:15:37.404 
于是你将在足迹和质量之间
保持绝佳的平衡

00:15:38.005 --> 00:15:41.375 
而且它同样完全兼容
App Thinning

00:15:41.441 --> 00:15:45.012 
因此 们只将需要的东西
部署在给定设备上

00:15:47.581 --> 00:15:51.685 
我想在此介绍资源分类的最后一个功能

00:15:52.319 --> 00:15:54.588 
方向或图像资源支持

00:15:56.490 --> 00:16:00.394  
现在它意味着直接在资源分类层级上

00:16:00.761 --> 00:16:05.098  
你可以指定一个图形为RTL资源

00:16:06.033 --> 00:16:08.802  
或者是从左到右的资源

00:16:09.336 --> 00:16:11.371  
或者某种自动翻转的资源

00:16:12.272 --> 00:16:14.007  
直接在资源管理系统中

00:16:14.808 --> 00:16:19.413  
我们也有关于
国际用户界面的完整研习会

00:16:20.214 --> 00:16:23.584  
其中可以让你了解更多
有关iOS X的改进

00:16:26.653 --> 00:16:28.388 
但我现在想谈的是

00:16:28.455 --> 00:16:32.726 
如何创建更好的用户界面

00:16:33.126 --> 00:16:35.429 
以及在iOS X中的交互

00:16:37.130 --> 00:16:39.933 
首先你需要确保

00:16:41.068 --> 00:16:44.671 
每个人都可以和你的应用交互

00:16:45.539 --> 00:16:47.975 
我们有新的辅助功能检查器

00:16:48.609 --> 00:16:51.778 
你可以利用这个工具 它真的很牛

00:16:51.845 --> 00:16:54.815 
你可以连接到一个应用上

00:16:55.082 --> 00:16:58.051 
然后你将自动了解给定

00:16:58.685 --> 00:16:59.987 
UI元素的辅助功能属性

00:17:01.722 --> 00:17:03.323 
还有另一个很不错的功能

00:17:07.895 --> 00:17:12.232 
你还可以在应用上启动审核功能

00:17:12.699 --> 00:17:14.134 
在模拟器或你的设备上运行

00:17:14.434 --> 00:17:18.338 
这样可以让你获得提示

00:17:18.472 --> 00:17:22.075 
了解你希望修复的问题 以及你真正想

00:17:22.142 --> 00:17:23.877 
修复的与你的应用相关的问题

00:17:26.213 --> 00:17:31.919 
有一点要注意 就像Xode
如果你没有收到任何警告

00:17:32.619 --> 00:17:34.922 
并不意味着你的应用完美无缺

00:17:35.589 --> 00:17:37.558 
但这是很好的第一步

00:17:38.825 --> 00:17:41.328 
我们也有新的方式

00:17:41.828 --> 00:17:44.932 
和 iOS X上的应用交互

00:17:46.433 --> 00:17:50.237 
我们添加了一个新手势 语音识别器

00:17:51.572 --> 00:17:54.007 
[外语]

00:17:56.677 --> 00:17:58.178 
而且不限于英语

00:17:59.012 --> 00:18:01.281 
它是一个非常简单的API

00:18:02.516 --> 00:18:05.686 
SFSpeech识别器

00:18:05.752 --> 00:18:08.589 
它可以做连续语音识别

00:18:09.590 --> 00:18:13.160 
而且你可以将其连接到音频文件

00:18:14.094 --> 00:18:15.996 
或者实时音频流上

00:18:16.730 --> 00:18:19.466 
你可以做实时的连续语音识别

00:18:22.669 --> 00:18:27.508 
你可以将其配置为优化识别

00:18:27.875 --> 00:18:31.044 
用于听写或实现简易字符串

00:18:32.212 --> 00:18:35.349 
这里只是举一个API的例子

00:18:35.883 --> 00:18:39.753 
你创建一个识别器
你将其配置了一个请求

00:18:40.521 --> 00:18:42.723 
你开始一项任务 然后

00:18:42.789 --> 00:18:45.192 
我们回电告知你结果

00:18:46.126 --> 00:18:47.261 
真的方便使用

00:18:47.761 --> 00:18:52.766 
我们在 WWDC应用上
有关于这个API的相应视频

00:18:55.502 --> 00:19:01.074 
iOS X中的另一大改进是文本输入

00:19:01.575 --> 00:19:06.380 
你现在可以做的一件事是

00:19:06.446 --> 00:19:09.983 
为你的文本字段中的内容添加信息

00:19:10.851 --> 00:19:15.422 
你可以通过这个功能提供智能建议

00:19:15.923 --> 00:19:20.294 
以Quick type模式
例如如果我的文本字段是关于位置

00:19:20.861 --> 00:19:23.430 
我在Quick type中看到地址

00:19:25.132 --> 00:19:30.671 
我们有很多预定义的内容类型
对人而言

00:19:30.804 --> 00:19:36.510 
你可以指定名 姓氏 全名或地点

00:19:36.677 --> 00:19:38.846 
在此情况下 它将配置成

00:19:38.912 --> 00:19:41.615 
一个完整的街道地址

00:19:43.183 --> 00:19:47.054 
或甚至可以配置电子邮件
电话 信用卡卡号

00:19:50.457 --> 00:19:52.693 
关于文本输入

00:19:53.060 --> 00:19:57.097 
以及文本的另一点是
你如何在iOS中呈现文本

00:19:58.565 --> 00:20:03.537 
在iOS 7中 我们添加了
支持动态类型 在iOS X中

00:20:03.737 --> 00:20:06.840 
我们正在制作内容尺寸分类

00:20:06.907 --> 00:20:08.675 
用于动态类型 一种特征

00:20:09.710 --> 00:20:10.677 
那么 这意味着什么？

00:20:11.712 --> 00:20:16.450 
在iOS X之前的内容
尺寸类别只是一个属性

00:20:16.717 --> 00:20:17.684 
在UI App上

00:20:19.286 --> 00:20:22.923 
而且 你实际发送了通知

00:20:23.857 --> 00:20:27.094 
如果用户改变了内容尺寸

00:20:27.628 --> 00:20:30.797 
你必须重新发出通知并且更新你的UI

00:20:33.233 --> 00:20:37.938 
现在 因为它集成为一个特性

00:20:38.438 --> 00:20:40.307 
它在视图控制器上可用了 这意味着

00:20:40.374 --> 00:20:44.645 
你可以在所有UI扩展中使用动态类型

00:20:47.414 --> 00:20:51.251 
我们实际上还添加了对动态类型的支持

00:20:51.685 --> 00:20:54.454 
在新的UIKit中的现有元素内

00:20:54.855 --> 00:21:00.527 
因此 如果你通过文本字段
文本视图 标签创建UI

00:21:01.461 --> 00:21:06.033 
你希望对尺寸变化重新做出反应

00:21:07.534 --> 00:21:10.804 
现在在iOS X中
你可以使用是的调整字体功能

00:21:11.471 --> 00:21:16.176 
调整内容尺寸分类
你的标签 文本视图

00:21:16.343 --> 00:21:19.046 
文本字段仅对此重新做出反应

00:21:19.813 --> 00:21:23.083 
例如 你正在使用音频应用 你的应用

00:21:23.517 --> 00:21:25.052 
将会自动更新

00:21:25.552 --> 00:21:29.189 
对于动态类型而言
这是一个很棒的功能

00:21:29.489 --> 00:21:33.193 
完全自动支持 标签和文本字段

00:21:40.033 --> 00:21:44.972 
我们曾经希望在UIKit中
添加新的自定义

00:21:45.339 --> 00:21:48.141 
选项卡栏项是一个极好的案例

00:21:48.609 --> 00:21:52.346 
现在你可以自定义批处理
颜色和文本属性

00:21:52.479 --> 00:21:57.985 
在标签栏项中
你还可以自定义选定的主题颜色

00:21:58.552 --> 00:22:01.154 
因此 我们可以说我有一个标准标签栏

00:22:01.288 --> 00:22:02.789 
看起来就像那样

00:22:03.423 --> 00:22:07.060 
如果我将此代码添加到我的应用中

00:22:10.097 --> 00:22:13.300  
它将成为我的新标签栏UI

00:22:14.168 --> 00:22:16.737  
也许这就是我并非设计师的原因

00:22:25.179 --> 00:22:27.581 
另一项极佳的定制 在网页视图中

00:22:28.849 --> 00:22:33.420 
为3D Touch iPhone
装入Peek和Pop时

00:22:34.521 --> 00:22:37.758 
我们曾在UIKit中
有非常简单的API用于视图控制器

00:22:38.125 --> 00:22:41.295 
我们曾有内置的支持WK网页视图

00:22:42.196 --> 00:22:45.832 
现在在iOS X中
你可以很好的控制

00:22:46.200 --> 00:22:49.169 
web视图中的Peek和Pop行为

00:22:49.236 --> 00:22:53.640 
这意味着你可以使用自定义视图控制器

00:22:54.041 --> 00:22:54.975 
用于做Peek

00:22:55.576 --> 00:23:00.214 
你可以有预览操作
以及很棒的后续结果

00:23:00.280 --> 00:23:04.051 
当你Pop网页视图中时 你可以决定

00:23:04.117 --> 00:23:06.386 
留在你的应用内

00:23:07.154 --> 00:23:12.860 
它就像web视图类上的
新的委托方法一样可用

00:23:14.261 --> 00:23:17.865 
但Peek和Pop
最让我感到激动的是

00:23:18.332 --> 00:23:21.969 
新的UI预览交互类型

00:23:22.769 --> 00:23:27.274 
因此在UIKit内的
Peek和Pop完全是两回事

00:23:28.876 --> 00:23:33.480 
有一种视觉效果 这种模糊效果
这种很棒的动画

00:23:33.547 --> 00:23:35.449 
当你想要预览某种东西时

00:23:36.617 --> 00:23:40.587 
有一种触摸 我们如何对压力做出回应

00:23:40.854 --> 00:23:44.258 
我们如何检测用户的意图 是撞击

00:23:44.324 --> 00:23:46.360 
一次滚动 还是Peek的开始？

00:23:47.294 --> 00:23:50.697 
通过UI预览互动 你可以做到

00:23:51.131 --> 00:23:54.935 
使用UIKit提供的
执行实现这种触摸

00:23:55.903 --> 00:23:58.338 
但为Peek和Pop
提供你自己的动画

00:23:59.339 --> 00:24:04.411 
这是此类型上的一种新的委托
你可以知道

00:24:04.478 --> 00:24:07.014 
当你从Peek转到Pop时
我们将会

00:24:07.080 --> 00:24:10.350 
为你提供改进 一连串的改进

00:24:10.417 --> 00:24:14.288 
你可以插入自己的互动 你自己的动画

00:24:14.354 --> 00:24:16.723 
你可以实现完全定制的Peek

00:24:16.790 --> 00:24:18.792 
以及Pop UI
这确实是一个很大的改进

00:24:24.231 --> 00:24:28.135 
如果你希望全面了解
Peek和Pop及3D Touch

00:24:28.202 --> 00:24:31.839 
我们周四下午4点将举行完整会话

00:24:35.008 --> 00:24:39.246 
我们添加的另外一个新特性

00:24:39.313 --> 00:24:41.381 
在大家曾经需要的滚动视图中

00:24:42.516 --> 00:24:46.720 
它实际上完全支持UI刷新控件

00:24:53.527 --> 00:24:55.762 
它在UI滚动视图上可用

00:24:56.563 --> 00:24:57.998 
在类型的滚动视图上也可用

00:24:58.298 --> 00:25:01.835 
我们已经支持表格视图和刷新控制

00:25:01.902 --> 00:25:05.305 
因此 它意味着现在
你可以使用刷新控制

00:25:05.672 --> 00:25:06.607 
修正视图

00:25:08.742 --> 00:25:10.978 
我们来谈谈集合视图

00:25:12.646 --> 00:25:14.414 
这是UIKit上一个很不错的功能

00:25:15.215 --> 00:25:18.485 
去年我们添加了

00:25:18.552 --> 00:25:21.955 
对流布局中
自动自调整尺寸的单元格的支持

00:25:24.124 --> 00:25:25.826 
在此之前你必须要做的是

00:25:25.893 --> 00:25:28.762 
你必须计算预估尺寸

00:25:29.830 --> 00:25:31.498 
有时它并不容易

00:25:32.232 --> 00:25:35.869 
但在UIKit水平上
我们知道屏幕上呈现何种单元格

00:25:36.303 --> 00:25:38.639 
因此我们在流布局中有个一个新的模式

00:25:39.106 --> 00:25:41.909 
你可以自动通过 我们将为你

00:25:41.975 --> 00:25:44.545 
估算 你无需自己去做

00:25:44.611 --> 00:25:46.280 
这个估算了

00:25:53.720 --> 00:25:56.523 
你知道我们为UI校正视图
支持重新排序了吗？

00:25:57.291 --> 00:25:59.459 
我们做了 而且我们正在改善

00:25:59.526 --> 00:26:03.530 
在集合视图中添加分页支持

00:26:04.264 --> 00:26:07.100 
这是滚动视图级展示的东西

00:26:07.568 --> 00:26:10.103 
校正视图将为你完成工作

00:26:11.839 --> 00:26:16.610 
但我对今年的一项功能非常激动

00:26:16.677 --> 00:26:19.413 
关于集合视图的平滑滚动

00:26:20.781 --> 00:26:23.217 
它是一个真正简单聪明的想法

00:26:24.051 --> 00:26:27.855 
如果我在集合视图中有一个网格

00:26:29.022 --> 00:26:31.225 
我会滚动这个网格

00:26:32.693 --> 00:26:37.397 
在某种程度上 我需要上个单元格

00:26:37.965 --> 00:26:39.967 
同时出现在屏幕上

00:26:40.634 --> 00:26:45.472 
对于布局而言
如果你的单元格有点复杂

00:26:45.873 --> 00:26:48.842 
它可能需要一定的时间
你可能剥夺一个架构

00:26:49.877 --> 00:26:50.711 
那样并不好

00:26:51.879 --> 00:26:56.984 
因此 我们现在正在做的是
我们称之为单元格预取的东西

00:26:58.952 --> 00:27:04.491 
这里的想法是
实际要在屏幕上实现一个单元格前

00:27:05.192 --> 00:27:08.662 
我们可能向你要求这个单元格
我们不会

00:27:08.729 --> 00:27:14.234 
将一个单元格作为单元格数据块
就像一整行

00:27:14.635 --> 00:27:17.471 
我们会要求一个单元格
然后下一个 再下一个

00:27:17.771 --> 00:27:19.673 
所以我们要摊销成本

00:27:20.941 --> 00:27:24.044 
从而在你的应用中建立单元格

00:27:25.779 --> 00:27:28.649 
好事是这是自动完成的

00:27:29.449 --> 00:27:32.319 
如果你为iOS X重建你的应用

00:27:32.753 --> 00:27:35.088 
你可以免费实现这样的行为

00:27:44.631 --> 00:27:45.465 
而且还有更多

00:27:47.901 --> 00:27:53.874 
我们有一个新的协议
我们称之为数据预取

00:27:54.808 --> 00:27:56.844 
因为有时不仅仅是

00:27:56.910 --> 00:27:59.413 
为你的单元格制作布局

00:28:00.113 --> 00:28:01.748 
有时你需要获取数据

00:28:02.983 --> 00:28:04.218 
你需要从光盘读取

00:28:04.451 --> 00:28:08.355 
你需要从网络获取数据 因此它很棒

00:28:08.422 --> 00:28:12.192 
如果我们可以告诉你嘿
我们需要速索引

00:28:13.193 --> 00:28:15.128 
你可以提前准备

00:28:16.864 --> 00:28:18.732 
这正是这个新协议的作用

00:28:19.233 --> 00:28:22.803 
你可以实施几种委托方法
我们将会告诉你

00:28:22.870 --> 00:28:26.907 
我们何时将会要求一个单元格

00:28:26.974 --> 00:28:28.475 
因此你可以将数据准备好

00:28:28.976 --> 00:28:31.678 
从而再次改善

00:28:31.745 --> 00:28:33.780 
你的基于应用的集合视图的表现

00:28:34.748 --> 00:28:38.285 
我们在表格视图上也提供了这种功能

00:28:50.797 --> 00:28:55.068 
我们将举行关于新UI集合视图的
完整会话

00:28:55.469 --> 00:28:57.704 
单元格预取 数据预取

00:28:57.938 --> 00:29:00.007 
重新排序 不要错过哦

00:29:04.912 --> 00:29:10.350 
但我认为今年UIKit的主要新功能

00:29:11.151 --> 00:29:13.820 
是我们称之为UI视图属性动画大师

00:29:15.255 --> 00:29:16.790 
它是一种新的API

00:29:18.225 --> 00:29:20.727 
它是一种新的API

00:29:20.794 --> 00:29:24.865 
让你建立可以中断的动画

00:29:25.399 --> 00:29:29.336 
你可以清除的动画 你可以倒退的动画

00:29:30.737 --> 00:29:34.575 
我们正在展示新的时间曲线

00:29:35.776 --> 00:29:37.211 
它是完全动态的

00:29:37.744 --> 00:29:39.680 
你可以快速添加动画

00:29:40.113 --> 00:29:44.384 
我在此要说的是 新的API

00:29:44.918 --> 00:29:48.155 
就像一部电影中的时间轴

00:29:48.222 --> 00:29:52.593 
你可以清除 快进 播放 倒退

00:29:53.594 --> 00:29:57.464 
该模型很简单 使用极其简单

00:29:58.332 --> 00:30:02.169 
你只需要创建一个新的动画

00:30:03.403 --> 00:30:06.173 
你设置时间参数和持续时间

00:30:06.240 --> 00:30:07.541 
你添加自己的动画

00:30:07.941 --> 00:30:10.711 
你启动动画 因为你有一个对象

00:30:10.777 --> 00:30:14.648 
代表该动画 你可以快进

00:30:14.948 --> 00:30:17.351 
或者改变其进度

00:30:18.886 --> 00:30:21.021 
它还完全集成在

00:30:21.088 --> 00:30:23.624 
i视图控制器运行系统中

00:30:23.957 --> 00:30:26.693 
我们将会对此详细解释

00:30:28.328 --> 00:30:31.899 
本周三将举行UI动画
和技术进步的会话

00:30:33.166 --> 00:30:37.004 
但我想告诉你的是
你可以用它创建什么

00:30:37.638 --> 00:30:41.141 
这是一个非常简单的照片应用

00:30:43.343 --> 00:30:47.014 
你之前可以做到的是

00:30:47.881 --> 00:30:49.416 
在导航控制器中实现自定义过渡

00:30:49.983 --> 00:30:54.821 
但有了这个动画API
我可以启动过渡

00:30:56.757 --> 00:31:00.460 
在飞行中用一个手势捕捉它 移动它

00:31:01.595 --> 00:31:02.429 
释放它

00:31:05.933 --> 00:31:06.900 
然后再次捕捉它

00:31:08.869 --> 00:31:10.571 
我会倒转我的过渡

00:31:11.638 --> 00:31:12.940 
让动画结束

00:31:14.675 --> 00:31:16.176 
令人惊叹的是

00:31:17.144 --> 00:31:19.179 
它是只是一个过渡

00:31:19.713 --> 00:31:24.451 
所以我们在相同的上下文中移动
从非交互式

00:31:25.018 --> 00:31:28.889 
前往交互式手势驱动 再回到非交互式

00:31:29.223 --> 00:31:32.059 
到手势驱动 再到交互式
再到非交互式

00:31:32.292 --> 00:31:37.297 
你可以完全将基于手势的
互动和动画混合起来

00:31:37.364 --> 00:31:40.167 
我们认为这是一项期待已久的伟大功能

00:31:40.234 --> 00:31:41.969 
通过它可以看到你将创建的东西

00:31:50.544 --> 00:31:56.149 
现在 我想谈谈我们为iOS X
带来的新特点

00:31:59.553 --> 00:32:03.924 
这里关键的事情是 没有什么

00:32:03.991 --> 00:32:06.093 
是你绝对要采用的

00:32:06.527 --> 00:32:09.062 
不 恰恰相反 我们该做什么来帮助你

00:32:09.663 --> 00:32:11.565 
我们拥有一些新的功能

00:32:11.632 --> 00:32:14.268 
它们将会让你的应用变得更好

00:32:15.802 --> 00:32:18.839 
这些新功能将简化你的体系结构

00:32:20.307 --> 00:32:23.243 
用于调整应用的东西将会更加集成

00:32:24.244 --> 00:32:26.847 
一个好案例是某种非常简单的东西

00:32:27.447 --> 00:32:29.950 
就是我们过去如何更改开放式URL

00:32:31.118 --> 00:32:33.587 
因此 我们首先要让它变成异步

00:32:34.454 --> 00:32:40.160 
使用完成处理程序
但我们还要添加通用链接

00:32:40.561 --> 00:32:43.664 
因此你知道通用链接
是当你打开一个URL时

00:32:44.831 --> 00:32:46.667 
例如链接至社交网络

00:32:47.134 --> 00:32:50.437 
如果你有一个本地应用
它就会打开本地应用

00:32:51.371 --> 00:32:55.209 
但现在有了这个新的API
你可以实际检查

00:32:56.276 --> 00:33:00.113 
系统上是否已安装一个应用

00:33:00.814 --> 00:33:04.218 
如果没有 你可以留在你的应用中

00:33:04.284 --> 00:33:07.721 
你可以仍然保留这种体验 而不是

00:33:07.788 --> 00:33:10.224 
例如打开Safari

00:33:10.724 --> 00:33:13.560 
因此它将真正改善

00:33:13.927 --> 00:33:16.997 
你如何整合内容和处理系统中
这些应用的方法

00:33:18.498 --> 00:33:23.203 
另一大功能是我们对核心数据的更改

00:33:25.038 --> 00:33:28.976 
第一个是我们称之为查询生成的功能

00:33:30.744 --> 00:33:35.115 
这里的想法是
你的菜单I拥有上下文很常见

00:33:35.182 --> 00:33:39.853 
而且你打算在背景队列工作

00:33:40.053 --> 00:33:43.490 
在单独的上下文中

00:33:44.658 --> 00:33:47.160 
你能做的是通过查询生成

00:33:47.661 --> 00:33:49.296 
你实际上可以pin

00:33:51.231 --> 00:33:53.901 
你的模型在你的菜单上

00:33:54.668 --> 00:33:58.505 
你可以准确控制 当你希望从

00:33:59.239 --> 00:34:01.141 
你的模型一个版本移至另一个版本

00:34:01.808 --> 00:34:06.113 
它意味着你不必要再处理力度

00:34:06.246 --> 00:34:07.814 
因为某种东西改变了背景队列

00:34:07.881 --> 00:34:12.585 
因为你可以准确决定
菜单I何时应该移动

00:34:13.020 --> 00:34:14.188 
至数据的一个新版本

00:34:14.888 --> 00:34:16.523 
这是一个真正伟大的方式

00:34:16.590 --> 00:34:20.092 
简化了你的应用中的核心数据代码

00:34:20.627 --> 00:34:24.531 
另外一个功能是关于连接池

00:34:25.065 --> 00:34:27.266 
目前在一次存储中 我们完全支持

00:34:27.333 --> 00:34:30.938 
多位读者 一位作者模式

00:34:31.371 --> 00:34:33.639 
这将给你带来极大的性能提高

00:34:34.174 --> 00:34:39.446 
我们在工具侧还有新的功能 了解它们

00:34:40.013 --> 00:34:42.081 
我建议你去参加周五举行的

00:34:42.149 --> 00:34:45.485 
核心数据的新特性会话

00:34:47.321 --> 00:34:51.024 
为你的应用数据建模的另外一个方式
是使用CloudKit

00:34:51.757 --> 00:34:56.063 
对于CloudKit
我们已经为公共数据库

00:34:56.897 --> 00:35:00.434 
以及私人用户数据库保留

00:35:01.101 --> 00:35:04.571 
我们要在iOS X中
添加的是记录分享

00:35:05.072 --> 00:35:09.543 
因此你可以让多个用户访问相同的记录

00:35:09.843 --> 00:35:12.513 
这就会打开一个全新类别的

00:35:13.013 --> 00:35:14.615 
具有CloudKit的应用

00:35:16.216 --> 00:35:17.150 
这棒极了

00:35:17.651 --> 00:35:21.255 
但一些东西有时很难处理

00:35:21.321 --> 00:35:25.893 
基于应用的协作 即如何处理UI流

00:35:26.660 --> 00:35:30.430 
你如何邀请人们参与文档协作？

00:35:31.365 --> 00:35:34.668 
你如何以一种安全的方式实现它？

00:35:35.335 --> 00:35:39.706 
因此 我们添加了
新的UI云共享控制器

00:35:40.240 --> 00:35:42.743 
这是由UIKit展示的视图控制器

00:35:43.377 --> 00:35:47.814 
使用非常方便
只需提供新的共享对象即可

00:35:47.915 --> 00:35:50.751 
它将会控制CloudKit中
的控制记录共享

00:35:51.285 --> 00:35:55.589 
我们将会为你自动生成UI

00:35:55.956 --> 00:36:00.260 
以管理邀请流和被邀请人的名单

00:36:01.128 --> 00:36:05.199 
很容易在CloudKit中
建立基于应用的协作

00:36:05.799 --> 00:36:07.634 
我们会举行关于
CloudKit的完整会话

00:36:07.701 --> 00:36:11.805 
介绍CloudKit的新特性
地点是Pesidio 时间是周四

00:36:14.308 --> 00:36:18.545 
现在我想谈谈NS用户活动

00:36:20.247 --> 00:36:23.417 
NS 用户活动是一个类

00:36:23.483 --> 00:36:26.620 
我们利用它捕捉你的应用的状态

00:36:27.321 --> 00:36:30.390 
我们已经在多个方面使用它

00:36:30.691 --> 00:36:34.061 
例如Handoff和
Spotlight

00:36:34.761 --> 00:36:38.332 
我们在iOS X现在要做的是

00:36:38.398 --> 00:36:41.001 
添加对用户活动位置的支持

00:36:41.068 --> 00:36:44.972 
因此 如果我的应用要处理地址

00:36:45.672 --> 00:36:49.109 
我可以表达的是 用户当前活动

00:36:50.677 --> 00:36:51.845 
和此地址有关

00:36:52.212 --> 00:36:57.084 
你只需要提供你附加在
活动上的地图套件项目

00:36:57.451 --> 00:37:01.855 
现在你明白我如何创建这个建议

00:37:01.989 --> 00:37:03.991 
在几分钟前的文本字段中

00:37:04.458 --> 00:37:07.928 
系统会注意到 哦 也许这个应用

00:37:08.595 --> 00:37:09.997 
正在处理这些地址

00:37:10.230 --> 00:37:11.832 
因此那很可能是一个极好的建议

00:37:11.899 --> 00:37:14.601 
用于处理地址文本文件

00:37:14.935 --> 00:37:18.372 
它会为你完全自动打开

00:37:19.039 --> 00:37:20.474 
如果你在活动下有选项

00:37:21.275 --> 00:37:25.379 
我们有许多的新方式来提高

00:37:25.445 --> 00:37:29.016 
你的应用使用率
通过与我们称之为主动建议

00:37:29.082 --> 00:37:32.753 
它是以智能 活动为基础的功能

00:37:33.654 --> 00:37:36.256 
在iOS X中 在你的应用上

00:37:37.824 --> 00:37:38.659 
另一个地方

00:37:40.627 --> 00:37:45.799 
我们使用NS用户活动是搜索

00:37:46.633 --> 00:37:50.938 
在iOS 9中也是如此
我们已经为索引活动添加了支持

00:37:51.772 --> 00:37:57.611 
它的用法非常简单
我们只需要创建一个活动

00:37:57.678 --> 00:37:59.646 
并提供文本字段信息

00:37:59.713 --> 00:38:01.982 
它就会在Spotlight中
显示出来

00:38:02.883 --> 00:38:04.651 
但现在你可以做到的是

00:38:05.352 --> 00:38:07.988 
我们这里有一个新的按钮
在应用中搜索

00:38:08.856 --> 00:38:13.727 
你的用户现在可以返回
直接转到你的应用

00:38:15.028 --> 00:38:18.131 
而且你可以继续自动搜索

00:38:18.465 --> 00:38:19.600 
在你的应用里

00:38:20.167 --> 00:38:21.602 
使用非常方便

00:38:22.069 --> 00:38:26.473 
第一步 你需要为你的
info Plist添加新的密钥

00:38:27.741 --> 00:38:30.911 
告诉我们你支持
Spotlight继续功能

00:38:32.846 --> 00:38:37.584 
第二步是运用新的UI应用委托方法

00:38:39.586 --> 00:38:40.754 
实施起来非常方便

00:38:41.488 --> 00:38:45.058 
我们为你提供用户活动
你可以创建UI

00:38:45.125 --> 00:38:48.362 
并继续在你的应用中显示搜索

00:38:50.030 --> 00:38:54.434 
去年最新的改进也和搜索有关

00:38:55.469 --> 00:38:59.206 
我们添加了对你的内容索引的支持
通过Core Spotlight

00:39:00.274 --> 00:39:05.145 
但现在你实际上可以在
Spotlight中搜索你的数据

00:39:05.212 --> 00:39:07.181 
我们正在打开Spotlight索引

00:39:07.848 --> 00:39:09.249 
这棒极了 因为我们

00:39:10.017 --> 00:39:14.454 
为电源和性能实现了该索引的完全优化

00:39:14.721 --> 00:39:18.759 
我们有非常强大的quarry模型

00:39:19.193 --> 00:39:21.061 
因此使用很方便

00:39:22.296 --> 00:39:24.398 
你只需要建立一个搜索查询

00:39:27.367 --> 00:39:28.268 
你提供一个请求

00:39:29.169 --> 00:39:32.272 
你可以为你的数据
搜索Spotlight索引

00:39:32.706 --> 00:39:37.244 
所以你可以将系统索引数据

00:39:37.311 --> 00:39:40.080 
例如来自网络的数据
为你的应用整合起来

00:39:41.048 --> 00:39:46.086 
我们今年将举行一个关于
搜索API的会话

00:39:46.153 --> 00:39:48.222 
介绍延续性

00:39:49.156 --> 00:39:51.425 
核心Spotlight搜索
以及其他功能

00:39:56.763 --> 00:39:59.666 
我们提供了Replay Kit

00:39:59.733 --> 00:40:01.735 
它是在你的应用中录屏的方式

00:40:02.202 --> 00:40:06.640 
在iOS X中
可使用Replay Kit为流媒体

00:40:07.641 --> 00:40:10.277 
因此你可以进行现场直播

00:40:10.811 --> 00:40:14.615 
利用你的应用 因为我们还提供扩展点

00:40:14.681 --> 00:40:18.552 
它意味着你第三方服务

00:40:19.019 --> 00:40:21.321 
给你带来直播能力

00:40:21.388 --> 00:40:24.925 
例如我们在playground上
正在使用它

00:40:29.229 --> 00:40:32.866 
另一个大的架构是SceneKit

00:40:34.568 --> 00:40:38.505 
SceneKit是强大的3D引擎

00:40:38.572 --> 00:40:42.976 
你可以使用它在应用中
集成3D交互式组件

00:40:44.044 --> 00:40:47.247 
今年主要新功能是一种

00:40:47.648 --> 00:40:50.450 
全新的渲染引擎 基于物理的渲染

00:40:51.919 --> 00:40:55.789 
可以说 它现在支持高动态范围

00:40:56.423 --> 00:40:59.293 
或者内部使用一个线性交叉空间

00:40:59.359 --> 00:41:00.894 
但我认为它是更好地向你展示

00:41:02.129 --> 00:41:05.799 
这是你在iOS 9上的消防车

00:41:08.001 --> 00:41:09.970 
这是你在iOS X上的消防车

00:41:10.704 --> 00:41:11.605 
真的令人惊叹

00:41:17.277 --> 00:41:19.646 
它目前在Watch OS 2
上可用

00:41:20.447 --> 00:41:23.617 
我们将在Presidio举行一次
完整的SceneKit Rendering会话

00:41:26.854 --> 00:41:29.389 
但我现在想谈谈Apple Pay

00:41:30.657 --> 00:41:32.226 
关于Apple Pay
有两个方面要谈

00:41:33.427 --> 00:41:38.031 
首先我们正在推广Apple Pay

00:41:38.098 --> 00:41:40.133 
让你的用户可用

00:41:41.001 --> 00:41:46.206 
今天Apple Pay
已装在iOS和Watch上

00:41:46.573 --> 00:41:49.243 
正如你昨天了解到的 我们正在推广它

00:41:49.309 --> 00:41:51.378 
让Apple Pay在web上可用

00:41:52.145 --> 00:41:54.515 
我们在Mac支持Apple Pay

00:41:54.715 --> 00:41:57.317 
所以对于用户而言
Apple Pay无处不在

00:41:58.552 --> 00:42:01.355 
但令人高兴的是 作为开发人员

00:42:02.022 --> 00:42:04.291 
我们已经支持Apple Pay

00:42:04.925 --> 00:42:06.660 
在你的基于UIKit的应用中

00:42:07.327 --> 00:42:10.497 
但是现在你可在
Safari中用Apple Pay

00:42:10.564 --> 00:42:12.766 
采用新的Javascript架构

00:42:13.333 --> 00:42:16.837 
但它也可能意味着
你可以使用Apple Pay

00:42:17.271 --> 00:42:20.507 
在内嵌的Safari视图控制器中

00:42:21.842 --> 00:42:24.144 
你使用Apple Pay
的另外一个地方是

00:42:24.611 --> 00:42:26.880 
在非UI代码中

00:42:27.915 --> 00:42:30.918 
我们有一个新的API供非UI扩展用

00:42:31.351 --> 00:42:36.190 
在扩展中使用Apple Pay
真的令人惊叹

00:42:36.256 --> 00:42:38.992 
对于你的iMessage应用而言
是极佳的功能

00:42:39.426 --> 00:42:43.463 
这是你现在可以直接创建的一种流

00:42:43.530 --> 00:42:45.332 
在信息中通过一个扩展实现

00:42:45.799 --> 00:42:50.170 
我想提供有关Apple Pay
的两个会话

00:42:50.571 --> 00:42:52.105 
不幸的是 第一场研习会

00:42:52.172 --> 00:42:55.108 
和网页上Apple Pay同时举行

00:42:55.175 --> 00:42:58.879 
之后是
Apple Pay钱包的新特性

00:43:01.849 --> 00:43:08.589 
我最后想谈谈你如何让iOS变得更好

00:43:08.655 --> 00:43:11.525 
你如何和iOS集成

00:43:12.025 --> 00:43:17.531 
我们在iOS X中有新的主要扩展点

00:43:17.931 --> 00:43:21.201 
以及信息Siri Callkit中
也是如此

00:43:22.035 --> 00:43:26.940 
我们也改善了已有扩展 例如像键盘

00:43:27.207 --> 00:43:30.377 
现在你可以使用
相同的Globekey

00:43:32.012 --> 00:43:35.115 
来自你的键盘扩展的键盘peeker

00:43:35.182 --> 00:43:38.652 
我们也可以给你提供

00:43:38.952 --> 00:43:41.088 
用户交互用语言提示

00:43:41.154 --> 00:43:45.058 
因此你可以在第三方扩展中
创建多语言支持

00:43:46.159 --> 00:43:49.129 
我们对iOS X的另一个改进是

00:43:49.396 --> 00:43:51.632 
是各种小工具的新显示模式

00:43:52.132 --> 00:43:58.572 
此前你必须给我们提供你偏好的尺寸

00:43:58.872 --> 00:44:02.009 
现在我们有一个用户控制的尺寸

00:44:02.276 --> 00:44:05.412 
紧凑模式有固定的高度

00:44:06.313 --> 00:44:09.550 
扩展模式有可变高度

00:44:10.083 --> 00:44:11.318 
使用真的非常方便

00:44:12.319 --> 00:44:14.555 
你不必做任何事情
通过我们新的API

00:44:14.621 --> 00:44:17.658 
你可以知道小工具何时会从

00:44:17.724 --> 00:44:19.693 
紧凑型移至扩展型

00:44:20.093 --> 00:44:23.430 
你可以给我们一个最大的尺寸
你可以知道显示模式

00:44:23.497 --> 00:44:26.200 
你可以定制你需要显示的信息

00:44:27.034 --> 00:44:30.237 
还有一件事 我需要指出来

00:44:30.537 --> 00:44:34.875 
尽管是小工具 它会在锁屏上显示出来

00:44:35.976 --> 00:44:41.048 
因此 小心处理你展示的数据类型

00:44:42.282 --> 00:44:47.321 
要时刻牢记的一件事是

00:44:47.387 --> 00:44:49.690 
和你在小工具中展示的数据保持一致

00:44:50.023 --> 00:44:52.426 
如果我来配置 如果我添加你的小工具

00:44:52.492 --> 00:44:54.328 
到我的主屏幕上 锁屏上

00:44:55.395 --> 00:44:58.398 
我期望我总会看到相同种类的数据

00:44:58.465 --> 00:45:01.435 
保持相同的隐私级别

00:45:01.502 --> 00:45:05.239 
我不希望看到令人吃惊的东西

00:45:05.506 --> 00:45:07.641 
在我的iPhone锁住时
在我的锁屏上显示

00:45:10.677 --> 00:45:14.781 
在iOS X上一个完全性的
架构是用户通知

00:45:15.616 --> 00:45:21.121 
用户通知曾经是我们

00:45:22.055 --> 00:45:23.490 
在UI应用层级常见的东西

00:45:24.091 --> 00:45:27.694 
我们有一个新的架构
但我们要展示相同的功能

00:45:28.195 --> 00:45:30.230 
我们将在这里添加几个增强功能

00:45:30.497 --> 00:45:35.402 
首先我们统一了本地通知和远程通知

00:45:35.669 --> 00:45:37.871 
因此更容易处理

00:45:44.344 --> 00:45:47.915 
你可以更好地控制你的提供方式

00:45:48.415 --> 00:45:51.251 
我们向用户提供通知的方式

00:45:52.586 --> 00:45:55.355 
我们要告诉你的另外一个优点是

00:45:56.924 --> 00:45:58.759 
在显示通知之前

00:45:59.326 --> 00:46:02.462 
在应用上你会更好地控制

00:46:02.629 --> 00:46:04.064 
通知本身

00:46:05.799 --> 00:46:10.604 
此外 这也是一个
跨不同平台的统一模型

00:46:12.773 --> 00:46:15.742 
除了这些API增强功能之外

00:46:16.877 --> 00:46:18.612 
我们还有两个扩展

00:46:19.546 --> 00:46:22.649 
第一个是服务扩展

00:46:23.984 --> 00:46:27.421 
服务扩展是你可以

00:46:29.823 --> 00:46:33.393 
插入设备的扩展 当我们收到通知时

00:46:33.460 --> 00:46:35.596 
在此之前 它实际上已经被显示了

00:46:35.896 --> 00:46:41.401 
在它在屏幕上显示前
你可以处理有效载荷

00:46:42.202 --> 00:46:46.573 
有两个极佳的使用案例
你可以用它建立

00:46:48.208 --> 00:46:53.180 
你可以有媒体附件 有效载荷是相当小

00:46:53.847 --> 00:46:57.584 
但如果你了解你要为
给定有效载荷显示什么

00:46:58.018 --> 00:47:00.487 
当你收到该通知时 你可以

00:47:00.988 --> 00:47:02.456 
取回它并显示

00:47:03.757 --> 00:47:06.827 
另外一个非常棒的功能是端到端加密

00:47:07.494 --> 00:47:10.330 
因为你现在负责两端

00:47:10.731 --> 00:47:13.200 
在服务器和本地设备上

00:47:13.800 --> 00:47:15.135 
因此你可以收到某种东西

00:47:15.802 --> 00:47:17.804 
然后用你自己的代码解密

00:47:17.871 --> 00:47:20.140 
我们认为这是一项非常棒的新功能

00:47:20.574 --> 00:47:22.409 
为扩展提供了极佳的新可能性

00:47:30.117 --> 00:47:32.686 
这是我们拥有的另外一个扩展

00:47:32.986 --> 00:47:35.656 
用于用户通知架构

00:47:36.390 --> 00:47:41.428 
你可以在你的通知中嵌入UI视图

00:47:42.629 --> 00:47:46.266 
尽管还有一个限制 你不能直接

00:47:47.201 --> 00:47:51.038 
和视图进行交互 但你有通知行动

00:47:51.972 --> 00:47:55.709  
我们将举行关于用户通知的两场研习会

00:47:56.310 --> 00:47:59.012  
通知介绍和高级通知

00:47:59.446 --> 00:48:01.148  
地点是Pacific Heights
时间是周三

00:48:02.616 --> 00:48:07.054 
iOS X中的另外一个
新功能是CallKit

00:48:07.120 --> 00:48:09.823 
我们再次提供了一个新的扩展点

00:48:11.225 --> 00:48:13.126 
目录扩展

00:48:13.560 --> 00:48:18.298 
我们允许你配置我们如何阻止来电

00:48:19.533 --> 00:48:20.934 
你对此可以完全掌控

00:48:22.002 --> 00:48:27.574 
第二个功能是我们如何识别电话号码

00:48:27.941 --> 00:48:29.042 
并显示我们的标签

00:48:29.576 --> 00:48:32.479 
以当我们接到一个电话时
我们首先要检查

00:48:32.679 --> 00:48:37.050 
地址簿 然后如果我们找不到匹配

00:48:37.651 --> 00:48:39.086 
我们可以添加你的扩展

00:48:40.587 --> 00:48:42.189 
因此使用API非常简单

00:48:43.156 --> 00:48:45.492 
它是非UI扩展点

00:48:45.792 --> 00:48:47.528 
完全是两种方法

00:48:48.829 --> 00:48:51.431 
但真正不错的新功能

00:48:51.732 --> 00:48:55.602 
在CallKit中电话提供者API

00:48:56.370 --> 00:48:57.871 
通过电话供者API

00:48:58.805 --> 00:49:01.675 
我们拥有真正的第一方体验

00:49:02.309 --> 00:49:04.945 
用于你的IP电话应用

00:49:05.412 --> 00:49:07.614 
也就是说 你可以获得某种性能

00:49:07.681 --> 00:49:10.417 
如全屏来电UI

00:49:11.185 --> 00:49:12.686 
当你在应用上接到一个电话

00:49:13.153 --> 00:49:14.288 
但不仅如此

00:49:14.988 --> 00:49:17.157 
我们完全将你的应用

00:49:18.058 --> 00:49:20.661 
和iOS上的核心管理结合起来

00:49:20.994 --> 00:49:25.499 
比如像你的收藏和最近阅读

00:49:25.566 --> 00:49:29.136 
我们从你的应用上自动获得电话

00:49:30.737 --> 00:49:33.040 
你可以支持Siri
还可支持CarPlay

00:49:33.140 --> 00:49:36.210 
你可以和免打扰和蓝牙结合起来

00:49:36.610 --> 00:49:39.046 
这是手机的一项主要新功能

00:49:44.418 --> 00:49:46.954 
我们可以全部了解它

00:49:47.020 --> 00:49:49.656 
在具有CallKit的
Enhancing VOIP应用中

00:49:53.060 --> 00:49:54.661 
我现在要谈谈Siri

00:49:56.630 --> 00:49:59.867 
你可能还不知道

00:50:00.367 --> 00:50:07.107 
在不同的语境中
Siri也会有相应的不同变化

00:50:07.608 --> 00:50:11.345 
因此 如果你在主屏幕上
正使用Siri

00:50:11.645 --> 00:50:15.749 
使用home键 或若你在使用
带有Hey Siri功能的Siri

00:50:16.817 --> 00:50:19.486 
或者如果你在使用
带有CarPlay功能的Siri

00:50:20.821 --> 00:50:22.856 
或者作为一种辅助功能

00:50:24.057 --> 00:50:27.761 
Siri将根据那样的
上下文对自身调整

00:50:28.061 --> 00:50:31.498 
你可以和Siri进行最佳可能的交互

00:50:33.333 --> 00:50:34.902 
它是相当复杂的任务

00:50:35.202 --> 00:50:38.205 
因为它涉及识别阶段

00:50:40.007 --> 00:50:42.843 
理解域 理解环境

00:50:43.243 --> 00:50:46.146 
这是我们要为你免费提供的东西

00:50:46.780 --> 00:50:49.816 
当你创建一个SiriKit扩展时

00:50:50.384 --> 00:50:51.752 
我们将提供给你的是

00:50:52.286 --> 00:50:55.222 
一个代表请求的意图

00:50:55.822 --> 00:50:59.426 
这就是你的扩展将和它交互的方式

00:51:00.294 --> 00:51:05.732  
你也可以提供
你自己的词汇帮助Siri

00:51:06.233 --> 00:51:09.870  
它可能对于特定应用或用户

00:51:10.304 --> 00:51:13.240  
因此我们可以再次调整识别

00:51:13.774 --> 00:51:15.909  
和Siri的交互

00:51:17.044 --> 00:51:18.045  
它如此如何工作的？

00:51:18.178 --> 00:51:21.215 
意图扩展背后的想法是

00:51:22.149 --> 00:51:25.752 
它是一个非UI扩展 将代表

00:51:25.819 --> 00:51:28.155 
Siri和你的应用之间的交互

00:51:29.456 --> 00:51:32.025 
因此 它是基于意图的概念

00:51:32.492 --> 00:51:34.361 
来自于Siri和响应

00:51:34.661 --> 00:51:36.463 
这里主要的想法是

00:51:36.830 --> 00:51:39.733 
意图是域特殊性东西

00:51:40.133 --> 00:51:41.768 
因此你可以有消息域

00:51:42.302 --> 00:51:43.937 
付款域等等

00:51:44.271 --> 00:51:47.374 
对于消息 你有一个意图清单

00:51:47.708 --> 00:51:51.879 
Siri可以识别它
进行交互并发送

00:51:51.945 --> 00:51:55.682 
至用于...的应用来管理
与Siri的交互

00:51:56.216 --> 00:52:01.154 
这里的主要目标
对于Siri意图而言

00:52:01.221 --> 00:52:05.492 
扩展是确保你和Siri
在同一个页面上

00:52:05.859 --> 00:52:07.594 
当Siri理解一个请求时

00:52:07.961 --> 00:52:11.498 
对于有效请求 我们需要对其确认

00:52:12.533 --> 00:52:15.135  
我们执行这个请求 基本上是流

00:52:15.602 --> 00:52:18.972  
当你使用Siri说事情时 比如

00:52:19.339 --> 00:52:22.910  
告诉 WWDC 谈话的Miko
我们需要在会议后见面

00:52:22.976 --> 00:52:26.013  
Siri要在意图内进行编码

00:52:26.079 --> 00:52:30.250  
事实上 它是处于消息域中

00:52:30.684 --> 00:52:34.021  
它是同一个消息意图 这里有一个收据

00:52:34.454 --> 00:52:37.157  
这是有关你的应用
和我们从你那里获得的内容

00:52:39.459 --> 00:52:41.895 
我们为Siri Kit提供
另一个扩展

00:52:42.362 --> 00:52:44.264 
即意图UI扩展

00:52:44.865 --> 00:52:46.600 
它实际上是一个可选扩展

00:52:47.201 --> 00:52:51.705 
但通过它你可以
将自己的UI嵌入Siri副本上

00:52:51.872 --> 00:52:55.576 
因此你可以确认它调整到你的内容上

00:52:55.976 --> 00:52:56.944 
这真的很棒

00:52:58.111 --> 00:53:02.182 
关于意图系统的另一个优点是

00:53:02.916 --> 00:53:05.485 
它不仅和Siri有关

00:53:06.053 --> 00:53:09.156 
它是一种描述请求的方式 当然

00:53:09.223 --> 00:53:12.326 
我们在Siri中使用它
和你的应用沟通

00:53:12.993 --> 00:53:15.796 
但这也是我们和
CallKit集成的方式

00:53:16.096 --> 00:53:20.033 
这是我们如何在地图上
正确分享扩展的方式

00:53:20.100 --> 00:53:22.336 
这个功能很棒的原因是

00:53:22.803 --> 00:53:26.773 
这是你如何给系统提供

00:53:26.840 --> 00:53:30.277 
关于你的用户在做什么的信息的方式

00:53:30.410 --> 00:53:32.312 
例如 在你的消息应用中

00:53:33.046 --> 00:53:36.283 
当然 它和用户的活动结合起来

00:53:36.683 --> 00:53:38.819 
由此 我们可以说

00:53:38.886 --> 00:53:45.792 
我在使用我的 WWDC 谈话应用
发送消息

00:53:46.193 --> 00:53:51.331 
然后在UI联系人中
我们要显示该信息

00:53:51.398 --> 00:53:53.267 
有关此信息自动联系

00:53:53.700 --> 00:53:56.270 
当我们有一个行动清单时

00:53:57.437 --> 00:54:02.442 
我们可直接向你显示你的应用 如果你

00:54:02.509 --> 00:54:05.379 
通过意图展示该信息

00:54:07.514 --> 00:54:08.415 
在某一点上

00:54:09.950 --> 00:54:12.486 
你的应用讲述默认应用

00:54:12.886 --> 00:54:14.755 
在标准联系人卡上

00:54:15.289 --> 00:54:16.924 
这真的令人惊叹

00:54:16.990 --> 00:54:20.093 
为你的应用增加可视性

00:54:22.829 --> 00:54:25.532 
我最后要谈谈iMessage应用

00:54:26.567 --> 00:54:30.070 
因此 消息真的变成一个平台

00:54:30.137 --> 00:54:32.873 
我们在这里有两个功能

00:54:32.940 --> 00:54:34.875 
一个是贴纸包

00:54:35.475 --> 00:54:38.278 
另一个是消息扩展

00:54:38.345 --> 00:54:42.149 
对于贴纸包 不需要代码

00:54:42.449 --> 00:54:47.454 
你只需要打包你的静态或动态图像

00:54:48.822 --> 00:54:50.924 
你使用Xcode完成它

00:54:50.991 --> 00:54:55.162 
你可以通过消息存储发布它

00:54:56.396 --> 00:54:57.764 
你还可以做另外一件事

00:54:58.232 --> 00:55:03.070 
使用iMessage应用
等于使用性的消息扩展

00:55:03.537 --> 00:55:08.108 
你可以用它编写
完全基于UIKit的扩展

00:55:08.809 --> 00:55:10.844 
你可以做其他事情 例如

00:55:11.411 --> 00:55:15.048 
动态生成贴纸内容

00:55:15.115 --> 00:55:18.719 
你甚至可以使用该扩展中全新的相机

00:55:19.119 --> 00:55:24.024 
你可以调整你的UI
实现紧凑或扩大模式

00:55:24.324 --> 00:55:26.827 
它将成为live-in消息

00:55:27.094 --> 00:55:29.663 
这是一个极佳的功能
但你可以做得更多

00:55:29.730 --> 00:55:32.699 
你可以自定义泡泡

00:55:33.200 --> 00:55:35.269 
它意味着你的扩展

00:55:35.335 --> 00:55:39.273 
使用的消息架构实际上

00:55:39.339 --> 00:55:44.344 
在和它结合的消息中有一个对话概念

00:55:44.411 --> 00:55:48.448 
与其他用户的更改关联

00:55:48.515 --> 00:55:51.385 
我们也全面支持消息扩展

00:55:51.552 --> 00:55:53.420 
在iOS X的模拟器中

00:55:53.487 --> 00:55:55.022 
因此使用非常方便

00:55:55.189 --> 00:55:59.826 
这是一个非常棒的功能
可以让你和消息结合起来

00:56:01.562 --> 00:56:04.965 
当然你还能用它实现另外一个功能

00:56:05.032 --> 00:56:08.669 
在你的互动泡泡中完全自定义内容

00:56:10.604 --> 00:56:14.074 
我们举行了两场会话
介绍iMessage应用

00:56:15.576 --> 00:56:18.412  
信息应用以及贴纸
时间是今天早上

00:56:18.745 --> 00:56:22.282  
a第二场会议重点介绍扩展部件

00:56:22.349 --> 00:56:25.018  
时间是周四下午1:40

00:56:25.385 --> 00:56:28.222 
非常感谢大家 享受 WWDC 大会