00:00:19.720 --> 00:00:22.990
Metal的新特性 第一部分

00:00:24.558 --> 00:00:25.692
各位早上好

00:00:26.727 --> 00:00:27.628
谢谢

00:00:30.497 --> 00:00:32.266
我叫Aaftab Munshi

00:00:32.698 --> 00:00:34.601
我和我的同事十分激动地

00:00:34.668 --> 00:00:36.770
与大家分享Metal的新特性

00:00:36.870 --> 00:00:39.039
macOS Sierra
和iOS 10中

00:00:39.273 --> 00:00:44.311
不过开始我先着重说说
今年我们关于Metal的演讲

00:00:44.378 --> 00:00:45.379
在 WWDC

00:00:45.445 --> 00:00:49.383
昨天我们有两场演讲
谈论了将Metal采用到

00:00:49.449 --> 00:00:50.817
你的应用程序中

00:00:51.084 --> 00:00:53.253
今天我们有三场演讲

00:00:53.320 --> 00:00:58.458
所以这一场 外加两场演讲
覆盖了Metal的新特性

00:00:58.525 --> 00:01:01.628
之后还有另一场演讲
其中我们会讲

00:01:01.695 --> 00:01:03.130
Metal着色器优化

00:01:04.364 --> 00:01:06.466
那么我们...

00:01:08.335 --> 00:01:10.504
看看我们将要讲的功能

00:01:10.571 --> 00:01:14.074
在第二场演讲中
我们要谈的功能是

00:01:14.141 --> 00:01:18.612
函数或着色器特殊化
以及写入资源的能力

00:01:18.679 --> 00:01:22.583
例如来自片段和顶点
着色器的缓冲和纹理

00:01:23.016 --> 00:01:27.187
广色域 在你的应用程序中
使用广色域显示 以及纹理资源

00:01:27.254 --> 00:01:30.691
还有在Metal性能着色器上
添加的一些新内容

00:01:30.757 --> 00:01:34.928
具体是通过Metal在GPU上
使用辅助卷积神经网络

00:01:35.195 --> 00:01:36.230
本次演讲中

00:01:37.264 --> 00:01:38.732
我们将谈谈

00:01:39.066 --> 00:01:41.735
我们在工具上
加入的一些改进

00:01:41.802 --> 00:01:43.670
我们认为大家一定会喜欢的

00:01:43.937 --> 00:01:48.075
我们也让资源堆
和资源分配更加快速

00:01:48.175 --> 00:01:49.343
给你更多的控制

00:01:49.409 --> 00:01:52.446
我们将谈谈那个资源堆
和无记忆渲染目标

00:01:52.613 --> 00:01:54.648
然后我将谈谈曲面细分

00:01:54.982 --> 00:01:56.016
所以开始吧

00:01:56.650 --> 00:01:58.085
好了 首先

00:01:58.385 --> 00:02:01.989
我们花一点时间去理解

00:02:02.122 --> 00:02:04.057
为什么需要
曲面细分

00:02:04.224 --> 00:02:07.861
我们看到应用程序
例如游戏

00:02:08.095 --> 00:02:10.531
渲染越来越多的
逼真视觉内容

00:02:10.597 --> 00:02:13.033
所以这意味着
为了渲染那么多内容

00:02:13.100 --> 00:02:16.737
我们需要能将精细的
几何图形发送给GPU

00:02:16.837 --> 00:02:18.572
我们要将输入发送过去

00:02:19.039 --> 00:02:22.910
这意味着需要处理
非常多的三角形

00:02:23.143 --> 00:02:25.345
这会极大增加存储带宽

00:02:25.412 --> 00:02:27.080
一件非常好的事是

00:02:27.514 --> 00:02:31.084
如果我们能将
这个发送给GPU的

00:02:31.151 --> 00:02:33.921
几何图形只描述成
一个低分辨率的模型

00:02:33.987 --> 00:02:35.489
名为Core Smash

00:02:35.556 --> 00:02:39.726
然后让GPU生成
高分辨率的模型

00:02:39.793 --> 00:02:43.130
事实上 这就是
曲面细分的功能

00:02:43.463 --> 00:02:46.800
曲面细分这种技术
你可以用它来放大并细化

00:02:46.867 --> 00:02:48.836
几何对象的细节

00:02:49.002 --> 00:02:51.672
我们必须要符合
两个重要的要求

00:02:51.972 --> 00:02:55.175
第一个是
那个生成的高分辨率

00:02:55.242 --> 00:02:59.213
三角形模型
不能存储在显存中

00:02:59.279 --> 00:03:01.081
我们不想占用带宽

00:03:01.148 --> 00:03:04.585
第二 所使用的方法
需要是可编程的

00:03:04.651 --> 00:03:06.987
所以我们来看一个例子

00:03:07.054 --> 00:03:10.724
这是GFXBench 4.0的截图

00:03:10.891 --> 00:03:13.060
是一款由Kishonti
发布的测试程序

00:03:13.126 --> 00:03:15.696
其注重的一个关键功能
就是曲面细分

00:03:15.796 --> 00:03:19.666
这张截图是没有使用
曲面细分而渲染出的汽车

00:03:19.766 --> 00:03:21.235
你看看那些轮圈

00:03:21.602 --> 00:03:23.470
多边形很明显
你不会开种车的

00:03:23.537 --> 00:03:24.538
对吧？

00:03:24.938 --> 00:03:27.975
就连车身板件上都有裂纹

00:03:28.041 --> 00:03:33.213
因为这就是实际
发送过去的几何图形

00:03:33.280 --> 00:03:35.516
你能看到 没有很多三角形

00:03:36.450 --> 00:03:38.418
这很好
--正是我们想要的

00:03:38.552 --> 00:03:41.388
曲面细分的功能是
将那个输入的几何图形

00:03:41.455 --> 00:03:42.756
变成这个样子

00:03:44.324 --> 00:03:45.726
我认为这十分炫酷

00:03:46.693 --> 00:03:51.098
如果你看看线框图
你可以看到是GPU负责生成

00:03:51.164 --> 00:03:53.934
现在我们渲染出
非常多的三角形 是吧？

00:03:54.001 --> 00:03:55.402
这就是曲面细分的威力

00:03:55.903 --> 00:03:59.306
好了 我们来看看曲面细分
如何在Metal中工作的

00:04:00.307 --> 00:04:03.944
所以就像Metal那样

00:04:04.044 --> 00:04:07.381
我们想采用
全新的设计方法

00:04:07.447 --> 00:04:09.950
我们想设计出--

00:04:10.117 --> 00:04:13.420
即使现在有支持
曲面细分的API

00:04:13.554 --> 00:04:14.888
你可能很熟悉

00:04:14.955 --> 00:04:17.925
我们想要的是
易于表达的东西

00:04:18.024 --> 00:04:19.226
易于使用

00:04:19.293 --> 00:04:21.995
而且我们不想保留任何性能

00:04:22.996 --> 00:04:25.666
我们认为我们做到了
希望你也会认同

00:04:25.732 --> 00:04:27.067
在这次展示之后

00:04:28.302 --> 00:04:32.005
曲面细分在macOS Sierra
和iOS上可以使用

00:04:32.072 --> 00:04:33.473
搭载A9处理器

00:04:33.774 --> 00:04:37.211
好了 我想谈论的是

00:04:37.277 --> 00:04:41.248
用于曲面细分的Metal
图形管线是什么样的？

00:04:41.548 --> 00:04:43.517
如何使用曲面细分
渲染我的几何图形？

00:04:43.617 --> 00:04:46.153
以及如何将它应用到
我的应用程序中？

00:04:46.253 --> 00:04:47.287
所以开始吧

00:04:48.255 --> 00:04:52.326
现在 当你用Metal将
基元发送给GPU

00:04:52.693 --> 00:04:56.029
你发送的是三角形
线条或者是点

00:04:56.163 --> 00:04:59.633
有了曲面细分 你发送
的东西我们称其为面片

00:04:59.733 --> 00:05:03.270
简单来说
面片就是参数曲面

00:05:03.337 --> 00:05:05.272
是由样条曲线构成
但这意味着什么？

00:05:05.339 --> 00:05:08.976
你可能听过Bezier面片
或B样条面片之类的东西

00:05:09.142 --> 00:05:12.412
你通过一组控制点来描述面片

00:05:12.513 --> 00:05:16.383
所以这个图中
你看到的是B样条面片

00:05:16.450 --> 00:05:20.187
所以你有16个控制点
或者是控制顶点

00:05:20.287 --> 00:05:25.158
曲面细分的作用是
简单来说 允许你控制

00:05:25.359 --> 00:05:28.762
使用多少个三角形
来渲染这个面片

00:05:28.829 --> 00:05:32.065
所以你会决定
“我不想要很多的三角形”

00:05:32.132 --> 00:05:33.600
“我不在乎它什么样”

00:05:33.667 --> 00:05:36.770
所以你可以决定
四个三角形就足够了

00:05:36.837 --> 00:05:38.305
然后你会得到
多边形的外观

00:05:38.505 --> 00:05:42.242
或你决定 “我真的
想让它看起来精致又平滑”

00:05:43.310 --> 00:05:46.313
这会需要更多的三角形
不过这是由你控制

00:05:48.081 --> 00:05:48.949
所以我们开始

00:05:49.016 --> 00:05:52.686
当我们做曲面细分时
图形管线中的第一阶段

00:05:52.753 --> 00:05:54.454
我们称之为曲面细分内核

00:05:54.721 --> 00:05:56.590
它的作用是将面片

00:05:56.657 --> 00:05:59.426
我们讲了带有
控制点的面片 作为输入

00:05:59.493 --> 00:06:03.096
并决定
“我需要将它细分成多少？”

00:06:03.163 --> 00:06:06.200
“我想让GPU生成
多少个三角形” 对吧？

00:06:06.300 --> 00:06:10.370
这种信息是在
曲面细分因子中捕捉到的

00:06:10.437 --> 00:06:14.408
我会在几个幻灯片之后
稍微谈谈这些因子

00:06:15.042 --> 00:06:18.445
你还可以生成额外面片数据

00:06:18.512 --> 00:06:20.414
如果在随后阶段中需要的话

00:06:20.480 --> 00:06:22.282
关键的是
这是一个可编程阶段

00:06:22.349 --> 00:06:23.750
意味着你要写代码

00:06:24.885 --> 00:06:28.388
一旦你写完了
生成了曲面细分因子

00:06:28.455 --> 00:06:30.657
下一阶段叫做镶嵌器

00:06:30.858 --> 00:06:33.760
这是一个固定函数阶段
所以没有代码可写

00:06:33.827 --> 00:06:37.297
不过你确实会得到
配置它的旋钮

00:06:37.531 --> 00:06:42.569
所以它使用那些曲面细分因子
然后将面片分解成三角形

00:06:43.437 --> 00:06:46.907
镶嵌器在这里的
关键作用是它不将

00:06:46.974 --> 00:06:49.543
生成的三角形列表
存储在显存中

00:06:50.010 --> 00:06:52.713
除了其生成的三角形列表之外

00:06:52.779 --> 00:06:56.483
对于三角形列表中的每个顶点
它会生成我们所称的

00:06:56.550 --> 00:06:59.253
参数坐标 U和V值

00:06:59.319 --> 00:07:02.956
它将这个和控制点一起使用

00:07:03.624 --> 00:07:06.393
来计算在表面上的实际位置

00:07:06.793 --> 00:07:09.263
镶嵌器会生成三角形

00:07:09.329 --> 00:07:13.834
今天在Metal中
当你想渲染基元时

00:07:13.934 --> 00:07:16.136
你将三角形发送给GPU

00:07:16.270 --> 00:07:21.074
首先会发生什么？
执行顶点着色器

00:07:21.141 --> 00:07:23.777
在这里是镶嵌器生成
三角形 所以...

00:07:24.745 --> 00:07:28.315
如果你逻辑思考一下
下一阶段就会是顶点着色器

00:07:28.382 --> 00:07:29.416
确实如此

00:07:29.550 --> 00:07:32.452
我们将其称为
后曲面细分顶点着色器

00:07:32.519 --> 00:07:36.790
因为它在由镶嵌器
生成的三角形上运行

00:07:37.090 --> 00:07:41.128
所以它会在
三角形的顶点上执行

00:07:41.195 --> 00:07:42.896
三角形由镶嵌器生成的

00:07:42.963 --> 00:07:45.933
然后会输出变换位置

00:07:45.999 --> 00:07:51.171
如果你熟悉DirectX
这个着色器所扮演的角色

00:07:51.238 --> 00:07:53.473
和DirectX中的域着色器相似

00:07:54.975 --> 00:07:57.444
好了 之后剩下的
管线都是一样的

00:07:57.511 --> 00:08:00.080
我们有光栅器和
片段着色器

00:08:00.147 --> 00:08:03.717
你可能会问 “所以
我需要写这个计算内核

00:08:03.784 --> 00:08:05.586
来生成曲面细分因子吗？”

00:08:05.819 --> 00:08:08.388
“我能使用顶点或
片段着色器吗？”

00:08:08.722 --> 00:08:09.857
你当然可以

00:08:09.923 --> 00:08:14.061
事实上 你根本不需要编写
着色器来生成这些因子

00:08:14.127 --> 00:08:15.796
你可能预先计算好它们了

00:08:15.863 --> 00:08:18.565
你就能将它们加载到缓冲中
然后将其传给镶嵌器

00:08:18.632 --> 00:08:20.200
所以你有很多控制

00:08:20.300 --> 00:08:24.404
不过如果你在GPU中
生成这些因子

00:08:24.471 --> 00:08:26.273
我们建议你使用计算内核

00:08:26.340 --> 00:08:27.441
因为你知道吗？

00:08:27.508 --> 00:08:32.145
这会允许我们将那个内核
和其他绘制指令异步运行

00:08:32.412 --> 00:08:36.116
所以让你提高性能
我认为你们会喜欢的

00:08:36.850 --> 00:08:38.986
让我们更进一步

00:08:39.052 --> 00:08:41.087
你不需要每一帧
都运行这个内核

00:08:41.355 --> 00:08:42.489
因为你知道吗？

00:08:42.556 --> 00:08:44.491
如果你已经计算了
曲面细分因子--

00:08:44.558 --> 00:08:45.626
假如你决定

00:08:45.692 --> 00:08:49.496
“离镜头更近的物体
会有更多的曲面细分”

00:08:49.563 --> 00:08:51.865
“更远的物体就没那么多”

00:08:51.932 --> 00:08:55.602
一旦计算完了 之后
根据物体的运动方式

00:08:55.669 --> 00:08:58.872
我可以应用一个刻度
然后镶嵌器会接受它

00:08:59.039 --> 00:09:03.343
所以管线真的十分简单
我们有四个阶段

00:09:03.410 --> 00:09:07.047
我们拿它和没有
曲面细分的图形管线相比

00:09:08.081 --> 00:09:10.384
没有曲面细分的话
我们有三个阶段--

00:09:10.450 --> 00:09:13.887
顶点着色器 光栅器
和片段着色器阶段

00:09:14.188 --> 00:09:16.757
有曲面细分的话
我们添加了新的阶段 镶嵌器

00:09:16.823 --> 00:09:19.259
这是固定函数 所以
你不需要写任何着色器

00:09:19.459 --> 00:09:22.663
然后顶点着色器成为了
后曲面细分顶点着色器

00:09:23.397 --> 00:09:26.333
我们认为这很容易理解

00:09:26.800 --> 00:09:28.068
希望你们会认同

00:09:29.203 --> 00:09:32.339
好了 如何用曲面细分
来渲染我的几何图形？

00:09:33.173 --> 00:09:34.975
这里我要讲四点

00:09:35.042 --> 00:09:37.110
我们先看看后曲面细分

00:09:37.177 --> 00:09:38.979
或后曲面细分
顶点着色器

00:09:39.046 --> 00:09:41.515
这与普通的
顶点着色器有何不同？

00:09:41.715 --> 00:09:43.617
如何传递我的面片输入

00:09:43.684 --> 00:09:46.220
我跟你说过镶嵌器是可以配置的

00:09:46.320 --> 00:09:49.256
我们来看看如何配置
之后绘制面片

00:09:50.891 --> 00:09:53.393
看看这就是新的着色器
跟旧的着色器一样

00:09:53.460 --> 00:09:56.230
事实上 你声明
后曲面细分顶点着色器

00:09:56.296 --> 00:09:57.898
要使用顶点限定符

00:09:57.965 --> 00:10:01.468
除此之外
你还要指定这个属性

00:10:01.535 --> 00:10:03.470
写着
“这是作用于面片的”

00:10:03.537 --> 00:10:06.807
这里有两种面片
--四边形和三角形面片

00:10:06.874 --> 00:10:08.542
你看到它边上的数字了吗？

00:10:08.709 --> 00:10:12.412
那个数字就是告诉你
那个面片作用于多少个控制点

00:10:13.013 --> 00:10:15.949
如果你有普通的顶点着色器
你会传递

00:10:16.016 --> 00:10:17.684
一个顶点ID输入

00:10:17.784 --> 00:10:20.187
现在你将patchID
作为输入传递

00:10:20.587 --> 00:10:24.758
还记得我告诉你镶嵌器
生成参数UV坐标吗？

00:10:24.825 --> 00:10:28.595
那就这个
position_in_patch输入

00:10:28.729 --> 00:10:31.198
之后 如果你有
普通顶点着色器

00:10:31.298 --> 00:10:33.433
你要将其作为
stage_in传递

00:10:33.500 --> 00:10:35.769
我们在stage_in
传递的面片输入

00:10:36.036 --> 00:10:37.638
其他东西
你就进行计算

00:10:37.704 --> 00:10:41.308
然后就生成
变换的顶点输出

00:10:41.575 --> 00:10:43.644
这实际上会完全相同

00:10:43.710 --> 00:10:48.615
因为下一阶段 无论
有没有曲面细分 都是光栅器

00:10:50.250 --> 00:10:52.152
好了 我们看看面片输入

00:10:52.953 --> 00:10:57.224
如果你有普通顶点着色器
你会在着色器中将顶点输入

00:10:57.291 --> 00:10:59.393
描述为结构体

00:10:59.459 --> 00:11:02.229
如果你将数据类型
解耦合了 这意味着

00:11:02.296 --> 00:11:05.199
布局和产生顶点输入的缓冲

00:11:05.265 --> 00:11:08.202
无法匹配着色器中的声明

00:11:08.268 --> 00:11:10.838
之后你要使用
MTLVertexDescriptor

00:11:11.004 --> 00:11:12.506
来描述布局

00:11:12.573 --> 00:11:17.744
这里有两种面片输入
一种是每面片输入

00:11:17.811 --> 00:11:21.014
还记得我告诉你的
这里有一个或以上的控制点吗？

00:11:21.114 --> 00:11:23.717
所以我们也需要
将它们指定为输入

00:11:24.284 --> 00:11:27.588
不过你指定
它们的方法看起来一样

00:11:27.688 --> 00:11:31.325
你用MTLVertexDescriptor
将面片输入数据的

00:11:31.391 --> 00:11:33.827
布局在内存中指定

00:11:34.194 --> 00:11:38.599
我之前展示过这个幻灯片
我们还将输入作为stage_in声明

00:11:38.832 --> 00:11:44.271
你使用属性索引在着色器中
将元素识别为输入

00:11:44.338 --> 00:11:48.175
通过MTLVertexDescriptor中
相应的声明

00:11:49.309 --> 00:11:51.678
因为会有不止一个控制点

00:11:52.546 --> 00:11:55.949
基本上 我们要使用
模板类型来对其声明

00:11:56.016 --> 00:11:57.518
我会在下一个幻灯片上讲的

00:11:57.584 --> 00:11:59.186
我们来看一个例子

00:11:59.286 --> 00:12:02.289
这里我有我的控制点数据
上面有两个元素

00:12:02.356 --> 00:12:04.424
我使用0和1属性

00:12:04.992 --> 00:12:08.095
每面片数据
是2和3属性

00:12:08.262 --> 00:12:09.730
我们将这两个组合一起

00:12:09.796 --> 00:12:12.900
这是每个面片的面片输入

00:12:13.100 --> 00:12:17.471
注意那个控制模板类型
patch_control_point

00:12:17.571 --> 00:12:19.573
这就在告诉
Metal的着色编译器

00:12:19.640 --> 00:12:22.676
“这是引用控制点输入”

00:12:23.177 --> 00:12:26.780
还记得我告诉你的这个
数字16吗？数字多少无所谓

00:12:26.914 --> 00:12:30.717
这也在告诉Metal着色编译器
这里有多少个控制点

00:12:30.884 --> 00:12:34.655
现在我们有了为获取
面片输入所需的所有信息

00:12:35.189 --> 00:12:37.157
所以我们将它
作为stage_in传递

00:12:37.991 --> 00:12:38.892
非常简单

00:12:40.861 --> 00:12:41.795
我认为

00:12:42.129 --> 00:12:43.030
好了

00:12:43.530 --> 00:12:45.532
我如何配置旋钮呢？

00:12:45.732 --> 00:12:46.767
这里有属性

00:12:46.834 --> 00:12:49.603
你可以设置在
MTLRenderPipelineDescriptor中

00:12:50.404 --> 00:12:53.640
几个例子是
你可以告诉镶嵌器

00:12:53.707 --> 00:12:56.476
你想用的三角形生成方法

00:12:56.543 --> 00:12:58.312
叫做分区模式

00:12:58.579 --> 00:13:01.849
你还可以指定
最高曲面细分等级

00:13:01.915 --> 00:13:04.685
我们认为这是非常有用的

00:13:04.751 --> 00:13:08.355
因为这允许你控制
所生成的几何图形最大量

00:13:08.422 --> 00:13:11.258
由GPU为曲面细分物体生成

00:13:12.292 --> 00:13:15.095
记住镶嵌器需要读取这些因子

00:13:15.162 --> 00:13:17.664
所以你需要指定
产生它们的缓冲

00:13:17.731 --> 00:13:21.268
所以使用
setTessellationFactorBuffer API

00:13:21.335 --> 00:13:22.202
来完成

00:13:22.269 --> 00:13:28.909
这些因子会说明沿着边缘
将这些面片细分成什么程度

00:13:28.976 --> 00:13:30.344
还有在内部

00:13:30.444 --> 00:13:32.079
所以我们有两种面片

00:13:32.145 --> 00:13:36.016
如果是三角形面片
会有三个边和一个内部

00:13:36.116 --> 00:13:39.686
如果是四边形
那就会有四个边和两个内部

00:13:39.920 --> 00:13:43.690
所以你将它们指定为
半精度浮点值

00:13:43.757 --> 00:13:44.791
传递进去

00:13:47.494 --> 00:13:48.629
然后是绘制

00:13:48.695 --> 00:13:51.765
现在 当你绘制基元时

00:13:51.832 --> 00:13:54.067
你发送的三角形由GPU渲染

00:13:54.134 --> 00:13:57.671
你要么调用drawPrimitives
或者drawIndexPrimitives

00:13:57.905 --> 00:14:01.175
你指定起始顶点
顶点数量

00:14:01.308 --> 00:14:05.546
如果你的顶点索引不是连续的
你就传递一个索引缓冲

00:14:05.646 --> 00:14:08.315
要想绘制面片
你就调用drawPatches

00:14:08.649 --> 00:14:09.816
或者drawIndexedPatches

00:14:10.184 --> 00:14:13.453
你指定起始面片
面片数量

00:14:13.620 --> 00:14:17.624
如果你的控制点索引不是连续的
你就指定一个索引缓冲

00:14:17.824 --> 00:14:19.059
所以这是一对一映射

00:14:19.893 --> 00:14:22.996
然后这里有
DrawIndirect变体

00:14:23.063 --> 00:14:25.866
它们的功能是
你不指定出

00:14:25.966 --> 00:14:28.135
哪个是起始面片
以及面片数量

00:14:28.202 --> 00:14:31.071
以及当你进行
绘制调用时的其他信息

00:14:31.238 --> 00:14:32.906
相反 你传递一个缓冲

00:14:33.373 --> 00:14:35.776
这些信息会填写在其上面

00:14:35.843 --> 00:14:38.645
通过一个在GPU上
运行的指令 就像你在

00:14:38.712 --> 00:14:40.013
drawPrimitives
上做得那样

00:14:40.314 --> 00:14:43.517
如果你不知道如何
使用drawPrimitives

00:14:43.884 --> 00:14:46.787
drawPatches的
效果非常相似

00:14:47.020 --> 00:14:49.489
所以我们认为
这非常易于使用

00:14:50.290 --> 00:14:51.191
好了

00:14:52.025 --> 00:14:52.860
稍等

00:14:57.464 --> 00:15:00.534
我给你展示了
什么是Metal曲面细分

00:15:00.601 --> 00:15:01.735
以及使用方法

00:15:02.669 --> 00:15:05.172
在座很多人可能熟悉

00:15:05.239 --> 00:15:09.443
或者已经在你的应用程序中
使用了曲面细分 通过DirectX

00:15:09.776 --> 00:15:10.844
或者OpenGL

00:15:10.911 --> 00:15:13.347
你会注意到Metal
曲面细分有点不同

00:15:13.514 --> 00:15:14.381
别担心

00:15:14.448 --> 00:15:17.484
我们设计的Metal曲面细分
可以极其直截了当地

00:15:17.551 --> 00:15:20.187
将你现有的曲面细分
代码转移到Metal上

00:15:20.287 --> 00:15:24.491
例如 在过去几周里
我们与Unity合作

00:15:24.791 --> 00:15:27.928
在极短的时间里
他们能够

00:15:27.995 --> 00:15:30.931
将Metal曲面细分
整合到他们的引擎中

00:15:31.231 --> 00:15:32.866
他们是这样评价的

00:15:35.602 --> 00:15:39.072
我们非常激动地宣布
对Metal曲面细分

00:15:39.139 --> 00:15:42.142
Metal Compute和在Unity中
编写原生Metal着色器的功能支持

00:15:42.209 --> 00:15:45.512
将于今年晚些时候推出
这十分令人激动

00:15:46.513 --> 00:15:50.517
而且我们也与Epic合作
来有效地将

00:15:50.584 --> 00:15:52.853
Metal曲面细分整合到
Unreal Engine 4中

00:15:53.820 --> 00:15:58.358
而且Epic计划将于今年
晚些时候发布对UE4的支持

00:16:00.093 --> 00:16:04.331
所以我们有UE4 我们有
Unity支持Metal曲面细分

00:16:05.299 --> 00:16:11.171
让我给你展示曲面细分在
这些游戏引擎中的实际效果

00:16:11.238 --> 00:16:14.741
通过演示
两种常用的渲染技术

00:16:14.842 --> 00:16:18.679
叫做适配曲面细分
和置换贴图

00:16:19.813 --> 00:16:20.814
好了

00:16:25.719 --> 00:16:29.489
我们有一个简单的演示...

00:16:31.291 --> 00:16:33.760
由几位Apple工程师开发的

00:16:33.827 --> 00:16:35.062
使用Unreal Engine 4

00:16:35.128 --> 00:16:39.066
我们已经关上曲面细分
然后看看线框图模式

00:16:39.166 --> 00:16:42.769
你能看到没有很多的
三角形发送给GPU

00:16:42.836 --> 00:16:44.338
非常好
这正是我们想要的

00:16:44.404 --> 00:16:48.375
我们要将发送给GPU的
几何图形量维持得越少越好

00:16:48.509 --> 00:16:51.245
我们启用曲面细分
看看会发生什么

00:16:52.179 --> 00:16:55.649
你能看到现在GPU
生成了非常多的三角形

00:16:56.083 --> 00:16:59.987
适配曲面细分这种技术
允许你控制

00:17:00.053 --> 00:17:02.022
重要地方的几何细节

00:17:02.089 --> 00:17:03.524
在这个例子中

00:17:03.624 --> 00:17:07.027
我们决定离镜头更近的
物体需要更多的细节

00:17:07.094 --> 00:17:09.061
所以绘制上更多的三角形

00:17:09.128 --> 00:17:11.231
相反 远处的物体则不会

00:17:11.298 --> 00:17:16.236
蓝色的区域代表着
曲面细分量最少的区域

00:17:16.303 --> 00:17:18.438
然后红色的区域代表着

00:17:18.505 --> 00:17:19.873
曲面细分量最大的区域

00:17:19.940 --> 00:17:22.309
我可以展示
随着我将滑动器向右滑动

00:17:22.376 --> 00:17:24.278
我可以用它来增加
曲面细分级别

00:17:24.344 --> 00:17:27.513
你能看到更近的
物体变成了红色

00:17:27.580 --> 00:17:30.284
好了 我们将线框图关掉

00:17:31.351 --> 00:17:34.154
如果你跑动
随着我们通过这个洞穴

00:17:34.488 --> 00:17:36.456
你可以看到这里有
更多的细节 对吧？

00:17:36.523 --> 00:17:40.294
如果我将曲面细分关掉
所有的细节都没了 丢失了

00:17:41.028 --> 00:17:44.164
打开曲面细分
看起来非常惊艳

00:17:44.264 --> 00:17:49.603
所以这个例子演示了
如何使用曲面细分

00:17:50.304 --> 00:17:53.874
在我的应用程序中
构建丰富的视觉场景

00:17:54.274 --> 00:17:58.078
我想感谢那些在Epic的能人
他们让这一切成为现实

00:17:58.712 --> 00:17:59.780
所以下一个演示...

00:18:02.449 --> 00:18:03.917
是置换贴图...

00:18:07.821 --> 00:18:09.923
在Unity上运行

00:18:10.123 --> 00:18:12.025
这里我们渲染出一个球体

00:18:12.326 --> 00:18:15.329
我们看看用了多少个
三角形来渲染这个球体

00:18:16.363 --> 00:18:17.364
不多 对吧？

00:18:17.431 --> 00:18:19.299
大概有3000个三角形

00:18:19.766 --> 00:18:22.202
置换贴图指的是
一种技术

00:18:22.269 --> 00:18:27.641
允许你置换几何图形
来创建惊人的细节

00:18:28.141 --> 00:18:33.780
其做法是使用
一个置换贴图 是一种纹理

00:18:33.847 --> 00:18:36.283
所以你从纹理查找
从这个纹理

00:18:36.350 --> 00:18:39.052
之后用它将顶点位置偏移

00:18:39.453 --> 00:18:41.855
或者如果你想的话
你可以按顺序地做

00:18:42.556 --> 00:18:45.726
不过置换贴图需要

00:18:45.792 --> 00:18:48.028
你要绘制数量众多的

00:18:48.095 --> 00:18:49.496
非常小的三角形

00:18:49.563 --> 00:18:52.366
否则不会有效
它创建一个工件 只是裂纹

00:18:52.499 --> 00:18:53.700
不过这没问题的

00:18:53.767 --> 00:18:55.736
我们可使用曲面细分
它是专门做这个的

00:18:55.802 --> 00:18:58.305
因为我们还想要
将3000个三角形

00:18:58.372 --> 00:19:01.441
更小的三角形发送给GPU
然后用曲面细分来生成它

00:19:01.508 --> 00:19:03.076
我们将线框图模式关掉

00:19:03.143 --> 00:19:05.145
我们启用置换贴图

00:19:06.180 --> 00:19:09.283
如你所见 现在
球体上的细节非常惊人

00:19:09.383 --> 00:19:11.318
如果我将线框图模式打开

00:19:11.485 --> 00:19:16.123
你可以看到我们生成了
非常多的三角形 而且都非常小

00:19:16.290 --> 00:19:18.725
实际上 我们看看这个
置换贴图的动画效果

00:19:18.792 --> 00:19:22.963
你能看到形状变化
我们放大来看看细节

00:19:25.065 --> 00:19:26.934
你可以看到自阴影的出现

00:19:27.801 --> 00:19:30.504
自阴影在这里出现的原因是

00:19:30.571 --> 00:19:33.440
因为我们在改变几何图形

00:19:33.507 --> 00:19:37.177
与在座很多人可能熟悉的
凹凸贴图技术不同

00:19:37.244 --> 00:19:39.313
那只是创建虚假的现实

00:19:39.379 --> 00:19:42.516
所以这是另一种技术
你可以用上曲面细分

00:19:42.583 --> 00:19:46.553
在所渲染的应用程序中
创建出惊人的细节

00:19:46.620 --> 00:19:49.089
还有 非常感谢Unity
提供这个演示

00:19:50.123 --> 00:19:53.927
演示
曲面细分实际效果

00:19:58.165 --> 00:19:59.132
好了 所以...

00:20:05.205 --> 00:20:10.110
Metal曲面细分还可以
用于加速数字内容创作工具

00:20:10.344 --> 00:20:15.516
例如 OpenSubdiv是由
Pixar发布的开源库

00:20:15.649 --> 00:20:19.253
它会实现高性能细分表面

00:20:19.553 --> 00:20:20.921
实际上 它集成到了多个

00:20:20.988 --> 00:20:23.924
第三方数字内容创作工具

00:20:23.991 --> 00:20:25.826
例如Autodesk的Maya

00:20:26.627 --> 00:20:30.964
OpenSubdiv使用曲面细分
来渲染这些细分表面

00:20:31.231 --> 00:20:35.936
Apple在OpenSubdiv中
加入了Metal曲面细分

00:20:36.003 --> 00:20:39.573
我很激动地在这里宣布
我们计划将这些变更

00:20:39.640 --> 00:20:43.010
今夏晚些时候在OpenSubdiv
开源项目上发布

00:20:43.677 --> 00:20:45.412
这是Pixar的评价

00:20:46.513 --> 00:20:50.150
如你所见 Pixar非常激动
看到在iOS和macOS中

00:20:50.284 --> 00:20:54.321
实现了OpenSubdiv上的
原生Metal

00:20:55.856 --> 00:20:58.992
好了 现在你可能会问
“那我呢？”

00:20:59.092 --> 00:21:02.629
“我如何将现有的曲面细分
代码转移到Metal中？”

00:21:02.863 --> 00:21:04.064
我来展示给你看

00:21:04.431 --> 00:21:08.302
所以我们以DirectX为例
不过对OpenGL的规则也是一样的

00:21:08.435 --> 00:21:12.639
这是带有曲面细分的
DirectX图形管线

00:21:12.806 --> 00:21:15.375
我们有三个新的阶段--
其中两个是可编程的

00:21:15.442 --> 00:21:17.344
它们叫做外壳和域着色器

00:21:17.444 --> 00:21:18.946
然后我们在中间有镶嵌器

00:21:19.046 --> 00:21:21.281
那我如何
将它转移到Metal中？

00:21:21.348 --> 00:21:24.785
注意域着色器的位置
正好在镶嵌器的后面

00:21:25.285 --> 00:21:28.488
这让你想起其他我在
Metal管线中展示的着色器吗？

00:21:28.856 --> 00:21:29.890
“我想是吧”

00:21:29.957 --> 00:21:32.826
没错 后曲面细分顶点着色器
不过你知道吗？

00:21:32.893 --> 00:21:37.497
曲面细分的域着色器
就会成为新的顶点着色器

00:21:38.332 --> 00:21:44.404
就像你可很容易将HLSL或
GLSL顶点函数移动至Metal中

00:21:44.471 --> 00:21:47.174
你可以非常容易地
将这些域着色器移动到

00:21:47.274 --> 00:21:49.776
后曲面细分顶点着色器

00:21:49.843 --> 00:21:52.746
镶嵌器是完全相同的
没有改变

00:21:52.880 --> 00:21:55.549
所以就是这个东西
这两个着色器

00:21:55.616 --> 00:21:56.850
顶点和外壳着色器

00:21:56.917 --> 00:21:58.552
我们要将它们放入内核中

00:21:58.685 --> 00:22:00.854
那么我们看看如何去做

00:22:02.189 --> 00:22:07.027
我们看看一些
因为我们已经有了顶点着色器

00:22:07.294 --> 00:22:10.797
这意味着这里可能
有顶点描述符在运行时

00:22:10.864 --> 00:22:12.866
由应用程序所描述

00:22:13.267 --> 00:22:17.304
因为数据可能会解耦合

00:22:17.437 --> 00:22:22.242
这意味着我要声明stage_in
但我无法在内核中stage_in

00:22:22.309 --> 00:22:24.244
对吧？不过现在可以了

00:22:24.311 --> 00:22:25.646
我们添加了支持

00:22:25.846 --> 00:22:29.016
所以就像在顶点着色器中
你使用stage_in来说

00:22:29.082 --> 00:22:32.452
“这是我的顶点输入”
你可以用stage_in来说

00:22:32.519 --> 00:22:34.755
“这是我的每线程输入”

00:22:34.821 --> 00:22:38.258
而且你可以指定
实际数据布局

00:22:38.425 --> 00:22:40.961
在MTLStage
inputOutputDescriptor中

00:22:41.028 --> 00:22:42.229
表现相同

00:22:42.296 --> 00:22:44.998
非常相似于
MTLVertexDescriptor

00:22:45.098 --> 00:22:48.735
有一些你指定的东西
有一点不同

00:22:48.802 --> 00:22:51.538
因为这是用于计算的
而不是顶点的

00:22:56.476 --> 00:22:58.946
然后 要观察两点

00:23:00.714 --> 00:23:04.551
DirectX或OpenGL的
曲面细分顶点着色器执行于

00:23:04.618 --> 00:23:06.553
面片的控制点

00:23:06.753 --> 00:23:10.224
外壳着色器有这两个函数

00:23:10.290 --> 00:23:12.526
一个是在控制点上执行

00:23:12.593 --> 00:23:14.394
另一个是在面片上执行

00:23:14.494 --> 00:23:16.997
每面片外壳函数才是真正生成

00:23:17.064 --> 00:23:18.465
你的曲面细分因子

00:23:18.632 --> 00:23:20.634
那最好的做法是？

00:23:20.701 --> 00:23:23.403
将所有这三个函数
转化成Metal函数

00:23:23.604 --> 00:23:26.573
然后我们写一个Metal内核
来调用这些函数

00:23:26.640 --> 00:23:28.675
不过别担心
我们不会做函数调用

00:23:28.742 --> 00:23:31.144
Metal编译器
会将它们内联的

00:23:32.246 --> 00:23:33.981
我们来看看这是怎么起作用的

00:23:34.047 --> 00:23:38.986
基本上 每个线程会
调用控制点函数 用于顶点的

00:23:39.052 --> 00:23:40.721
和外壳的

00:23:40.821 --> 00:23:44.925
假设这里有16个控制点
所有第一个线程调用顶点

00:23:44.992 --> 00:23:46.593
和控制点外壳函数

00:23:46.760 --> 00:23:50.163
第二个也是一样
如此类推

00:23:50.230 --> 00:23:53.634
它们产生的任何间歇数据
如果想分享的话

00:23:53.700 --> 00:23:55.169
会放入线程组内存中

00:23:55.235 --> 00:24:00.274
就是高性能
极低延迟的本地内存

00:24:00.340 --> 00:24:02.176
我们不会去使用显存

00:24:02.442 --> 00:24:06.413
之后 如果有16个控制点
这就会有16个线程

00:24:06.480 --> 00:24:07.614
在上面运行

00:24:07.748 --> 00:24:10.984
只需其中一个执行
每面片外壳函数

00:24:11.051 --> 00:24:14.321
这意味着通常会遇到栅栏
之后你只会执行

00:24:14.388 --> 00:24:16.657
其中的一个线程
会执行外壳函数

00:24:16.723 --> 00:24:18.058
你会遇到条件性检查 会说

00:24:18.125 --> 00:24:22.629
“我的线程是在线程组ID0吗？
之后调用这个”

00:24:22.829 --> 00:24:27.668
这个函数会将
曲面细分因子输出到

00:24:27.734 --> 00:24:29.002
显存中

00:24:29.069 --> 00:24:33.006
如果你有额外想要输出
的面片数据 你可以做到

00:24:33.173 --> 00:24:38.212
如果你真的非常想输出
控制点数据 你可以做到

00:24:38.278 --> 00:24:42.115
但我们发现在大多数情况中
控制点数据只是通过

00:24:42.216 --> 00:24:47.187
是这些现有API中
图形管线的性质

00:24:47.254 --> 00:24:48.956
需要你将它们传递过去

00:24:49.022 --> 00:24:51.291
不过你只是让它们传递过去
不要写出来

00:24:51.358 --> 00:24:53.861
你已经在缓冲中有了

00:24:54.895 --> 00:24:56.163
好了 让我总结一下

00:24:56.230 --> 00:25:02.503
我希望给你展示了
MetalTessellation是很简单的

00:25:02.569 --> 00:25:03.604
而且易于使用

00:25:03.704 --> 00:25:07.241
我们从头开始设计
专注性能

00:25:07.641 --> 00:25:12.713
我展示了将你现有的曲面细分
代码应用到Metal中是很简单的

00:25:13.280 --> 00:25:15.115
在iOS和macOS上可用

00:25:15.182 --> 00:25:16.383
现在轮到你们了

00:25:18.352 --> 00:25:23.056
展示出来 使用曲面细分
并创建一些惊艳的画面

00:25:23.123 --> 00:25:24.958
在你的应用程序中渲染

00:25:26.126 --> 00:25:29.029
我想感谢大家抽出宝贵时间
我将请上我的同事 James

00:25:29.096 --> 00:25:31.164
他将谈谈关于资源堆

00:25:31.231 --> 00:25:33.233
和无记忆渲染目标
谢谢大家

00:25:41.008 --> 00:25:42.276
好了 谢谢你 Aaftab

00:25:43.443 --> 00:25:46.280
本次演讲的下一部分
我很激动地介绍

00:25:46.346 --> 00:25:50.417
在iOS和tvOS上
可用的两项新Metal功能

00:25:50.684 --> 00:25:53.554
资源堆和无记忆渲染目标

00:25:54.154 --> 00:25:57.457
这些功能可以让你
控制你的资源管理

00:25:57.524 --> 00:26:00.194
从而实现更大的
CPU和内存效率

00:26:00.861 --> 00:26:04.631
我将首先介绍资源堆
之后再讲无记忆渲染目标

00:26:06.133 --> 00:26:10.704
资源堆是Metal中的一个
新的较低开销资源管理选项

00:26:11.205 --> 00:26:13.607
你早就可以在Metal中
创建缓冲和纹理了

00:26:13.674 --> 00:26:15.475
那为什么还要
另一种方式？

00:26:16.076 --> 00:26:18.478
在设备上通过现有Metal API

00:26:18.545 --> 00:26:21.348
创建资源是既容易又方便的

00:26:21.415 --> 00:26:23.917
而且很多开发者
很赞赏这种简单

00:26:24.351 --> 00:26:25.385
另一方面

00:26:25.452 --> 00:26:29.857
随着Metal应用渲染
越来越丰富复杂的场景

00:26:29.923 --> 00:26:33.126
你会寻求更完善的
Metal资源控制

00:26:33.193 --> 00:26:35.929
来解锁更大的
CPU和内存效率

00:26:36.430 --> 00:26:38.699
这就是我们推出资源堆的原因

00:26:39.466 --> 00:26:43.370
资源堆可以实现
快速的资源创建和绑定

00:26:43.437 --> 00:26:45.339
通过资源子分配

00:26:45.772 --> 00:26:49.142
资源堆的灵活性
会节省你的内存

00:26:49.209 --> 00:26:52.412
通过允许多个资源
在内存中取别名

00:26:53.380 --> 00:26:57.417
最后 资源堆的效率
和灵活性的实现是靠

00:26:57.484 --> 00:27:01.088
你控制资源依赖性跟踪

00:27:01.188 --> 00:27:03.223
通过使用显式指令同步

00:27:03.891 --> 00:27:05.526
我们来深入了解这些功能

00:27:05.959 --> 00:27:07.828
从资源子分配开始

00:27:09.196 --> 00:27:11.431
在谈子分配的细节之前

00:27:11.765 --> 00:27:16.170
我们首先讨论为什么
基于设备的资源创建耗费巨大

00:27:17.337 --> 00:27:18.939
创建单个资源

00:27:19.006 --> 00:27:21.241
使用Metal设备
涉及多个步骤

00:27:21.775 --> 00:27:24.912
分配内存
准备内存用于GPU

00:27:25.412 --> 00:27:27.181
清除内存保证安全

00:27:27.247 --> 00:27:29.917
最后
创建Metal对象

00:27:30.551 --> 00:27:32.920
每一步都需要时间
而大多数时间

00:27:32.986 --> 00:27:35.122
都花在内存操作上

00:27:36.156 --> 00:27:38.792
不过也有这种情况
当你需要创建资源

00:27:38.859 --> 00:27:42.496
在性能关键的路径上
并且不出现性能故障

00:27:43.297 --> 00:27:45.132
纹理流就是一个例子

00:27:45.332 --> 00:27:47.901
或者也许你有
一个图像处理应用

00:27:47.968 --> 00:27:51.405
需要生产多个临时纹理
来执行一个滤镜

00:27:53.340 --> 00:27:55.008
绑定资源的成本

00:27:55.209 --> 00:27:58.178
对于指令编码器来说
也会成为性能问题

00:27:58.779 --> 00:28:01.481
Metal必须跟踪
每个绑定到指令编码器

00:28:01.548 --> 00:28:05.285
的独特资源来确保
GPU能够访问内存

00:28:05.686 --> 00:28:08.589
对于复制的场景
这个成本也会水涨船高

00:28:09.990 --> 00:28:13.594
资源子分配解决了
这两个性能问题

00:28:14.161 --> 00:28:16.797
记住资源创建中
开销大的部分

00:28:16.864 --> 00:28:18.432
是在内存操作中

00:28:18.966 --> 00:28:21.502
有了资源堆
你可以提前执行

00:28:21.568 --> 00:28:23.770
内存操作
在游戏循环之外

00:28:24.905 --> 00:28:27.508
资源堆解决了绑定成本
做法是允许你

00:28:27.574 --> 00:28:31.211
从单个堆中对许多
逻辑资源进行子分配

00:28:31.979 --> 00:28:34.615
通过从一个堆中
对多个资源进行子分配

00:28:34.681 --> 00:28:39.052
Metal跟踪的是一个内存分配
而不是每个资源的内存分配

00:28:39.419 --> 00:28:41.822
这会显著降低
你的驱动过载

00:28:43.457 --> 00:28:44.825
我们给资源创建做对比

00:28:44.892 --> 00:28:47.528
在Metal设备和
新的Metal资源堆之间

00:28:48.629 --> 00:28:50.831
当你使用设备创建资源

00:28:50.898 --> 00:28:53.300
Metal会分配并准备
一个内存块

00:28:53.367 --> 00:28:54.868
然后创建Metal对象

00:28:55.335 --> 00:28:59.239
对于四个资源 Metal会
分配并准备四个内存块

00:29:00.474 --> 00:29:01.942
这与MTLHeap相比

00:29:02.376 --> 00:29:04.144
将MTLHeap
用于资源创建时

00:29:04.211 --> 00:29:06.580
你首先要提前创建堆对象

00:29:07.614 --> 00:29:11.084
内存会按请求的大小
分配并准备一个内存块

00:29:11.385 --> 00:29:14.054
如果你在渲染循环
之外提前做了这件事

00:29:14.321 --> 00:29:17.057
资源创建中
开销大的部分就完成了

00:29:18.091 --> 00:29:20.594
要从MTLHeap中
创建出四个资源

00:29:20.928 --> 00:29:23.797
Metal只需要保留
一块堆的内存

00:29:23.864 --> 00:29:25.332
然后创建资源元数据

00:29:25.532 --> 00:29:26.733
这会更加快速

00:29:27.434 --> 00:29:30.103
现在来看看当我们想释放
一些资源时会发生什么

00:29:31.205 --> 00:29:35.008
当基于设备的资源释放后
Metal对象就会被破坏

00:29:35.242 --> 00:29:38.412
不过设备也会释放
内存资源分配

00:29:39.179 --> 00:29:41.281
另一方面
当释放堆资源时

00:29:41.548 --> 00:29:45.352
只有对象被破坏
内存还由堆所占有

00:29:45.786 --> 00:29:47.588
所以在设备上创建新资源

00:29:47.654 --> 00:29:50.257
会引起另一次
高开销内存分配

00:29:50.524 --> 00:29:55.362
而堆可以快速将闲置内存
再分配给另一个资源

00:29:56.763 --> 00:29:58.031
我给你展示这有多容易

00:29:58.098 --> 00:30:00.200
用Swift对Metal资源
进行子分配

00:30:01.869 --> 00:30:04.137
所以跟很多Metal对象一样

00:30:04.204 --> 00:30:07.875
Metal资源堆有
一个相应的描述符对象

00:30:08.842 --> 00:30:11.278
我们创建堆描述符
然后将大小设置成

00:30:11.345 --> 00:30:13.213
支持堆的内存量

00:30:14.781 --> 00:30:16.783
凭借堆描述符
我们可以请求设备

00:30:16.850 --> 00:30:18.385
给我们创建一个堆对象

00:30:18.652 --> 00:30:21.555
记住 这个操作会比较慢
所以要提前做

00:30:21.955 --> 00:30:24.691
例如当应用启动时
或是内容加载时间

00:30:26.059 --> 00:30:29.363
有了这个创建出的堆
我们可以调用其资源创建方法

00:30:29.530 --> 00:30:32.533
这看起来非常眼熟
因为名称和参数

00:30:32.599 --> 00:30:35.002
与设备上的名称和参数相同

00:30:39.439 --> 00:30:41.275
在进行下一个话题之前

00:30:41.341 --> 00:30:45.045
我想分享一些使用资源堆
进行子分配的最佳做法

00:30:46.113 --> 00:30:48.382
最重要的一点
就是使用资源堆

00:30:48.448 --> 00:30:51.318
在性能关键的路径上创建资源

00:30:51.618 --> 00:30:54.354
使用设备去创建资源不是专门

00:30:54.421 --> 00:30:56.623
用于游戏循环的
资源堆是专门的

00:30:58.959 --> 00:31:03.897
分配大小不同的资源
可能会导致堆内存出现碎片

00:31:04.198 --> 00:31:06.500
如果资源有不同的生命周期

00:31:07.167 --> 00:31:10.404
所以使用多个堆
并按照大小将资源装好

00:31:10.470 --> 00:31:12.239
来限制碎片的影响

00:31:14.041 --> 00:31:17.211
你可以还在想
如何选择合适的堆大小

00:31:17.644 --> 00:31:20.380
Metal在Metal设备上
提供了两种新的方法

00:31:20.747 --> 00:31:23.984
来查询纹理和缓冲的大小与排列

00:31:24.952 --> 00:31:27.955
使用这些查询来帮助你
计算所需堆的大小

00:31:29.323 --> 00:31:33.093
好了 我们来看看资源堆的
下一项功能：资源别名

00:31:34.194 --> 00:31:36.897
资源别名允许多个动态资源

00:31:37.164 --> 00:31:38.565
占用相同的内存

00:31:38.832 --> 00:31:41.268
因此减少了资源的总体

00:31:41.335 --> 00:31:42.336
内存占用

00:31:42.903 --> 00:31:46.540
动态资源的内容
每一帧都是再生成的

00:31:46.607 --> 00:31:50.177
内容包括阴影贴图
G缓冲数据

00:31:50.244 --> 00:31:53.780
或是用于后处理的临时纹理

00:31:55.182 --> 00:31:58.018
我们这里有一个堆
包含两个非别名的资源

00:31:58.585 --> 00:32:01.321
与这个包含两个
相同资源的堆相比

00:32:01.388 --> 00:32:02.656
不过现在用了别名

00:32:03.023 --> 00:32:04.992
你能明显看到
使用别名的资源

00:32:05.058 --> 00:32:06.760
可以放入更小的堆中

00:32:10.797 --> 00:32:13.634
我们将资源别名
应用到这个游戏帧中

00:32:14.301 --> 00:32:16.570
阴影贴图过程
会渲染一组阴影贴图

00:32:16.970 --> 00:32:18.772
用于场景中的每个光源

00:32:19.373 --> 00:32:21.608
所以在这里的堆中
我们有多个阴影贴图

00:32:23.343 --> 00:32:25.846
在主过程的碎片加工中

00:32:25.979 --> 00:32:28.282
着色器会采样
阴影贴图来判定

00:32:28.348 --> 00:32:30.284
是否每个对象都在阴影中

00:32:31.752 --> 00:32:34.655
在主过程结束后
阴影贴图的内容

00:32:34.721 --> 00:32:35.956
就会被完全消耗

00:32:36.223 --> 00:32:38.425
它们会在下一帧中再生成

00:32:40.060 --> 00:32:42.663
在主过程结束后
我们会执行后处理链

00:32:42.729 --> 00:32:45.732
这个可能包含多个
离屏渲染过程

00:32:45.799 --> 00:32:48.569
每个都执行特定的滤镜
像是模糊或者高光

00:32:49.803 --> 00:32:52.139
这些滤镜会将其内容
存储进纹理中

00:32:52.206 --> 00:32:55.142
来将滤镜结果传递给
链中的下一个阶段

00:32:55.943 --> 00:32:58.645
这里的要点是
阴影贴图的

00:32:58.712 --> 00:33:00.714
内容和后处理纹理

00:33:00.781 --> 00:33:02.382
从来不是同时使用的

00:33:02.983 --> 00:33:04.618
所以为何不共享内存呢？

00:33:07.087 --> 00:33:10.824
我来给你展示如何用Swift
创建这些别名资源集

00:33:11.258 --> 00:33:12.960
这第一部分
应该看起来眼熟

00:33:13.327 --> 00:33:14.962
首先我们请求设备创建一个堆

00:33:15.796 --> 00:33:17.664
然后我们创建三个阴影贴图

00:33:18.999 --> 00:33:21.802
现在我们看到了一个新方法
makeAliasable

00:33:22.469 --> 00:33:24.671
通过在堆资源上
调用makeAliasable

00:33:24.805 --> 00:33:28.342
你告诉那个堆
将资源的内存视为闲置的

00:33:29.309 --> 00:33:32.980
阴影贴图仍在启用中
但是它们的内存可以自由

00:33:33.046 --> 00:33:35.482
被堆再分配给新的资源

00:33:36.650 --> 00:33:39.553
现在当我们在相同的堆上
创建后处理纹理时

00:33:40.087 --> 00:33:43.023
它们可以作为阴影贴图
占用相同的内存

00:33:45.526 --> 00:33:47.794
现在我们来谈谈
一些最佳做法

00:33:47.861 --> 00:33:48.996
用于资源别名

00:33:50.163 --> 00:33:53.433
为了实现动态资源的
内存再使用最大化

00:33:53.834 --> 00:33:56.703
调用资源创建方法

00:33:56.770 --> 00:34:00.040
在一个帧里
资源所使用的相同序列中

00:34:00.574 --> 00:34:02.876
允许你调用
makeAliasable

00:34:03.544 --> 00:34:06.547
会允许你交错
makeAliasable调用

00:34:06.947 --> 00:34:09.216
当资源内容被消耗的时候

00:34:11.717 --> 00:34:15.121
而且你要将动态资源和
静态资源保持在分隔的堆中

00:34:15.822 --> 00:34:18.926
静态资源一般无法进行别名
而且会导致

00:34:18.992 --> 00:34:22.596
动态资源无法互相使用别名

00:34:22.663 --> 00:34:24.331
由于堆的内存碎片

00:34:25.866 --> 00:34:28.735
接下来我将谈谈如何
实现堆资源的

00:34:28.802 --> 00:34:30.237
同步指令访问

00:34:32.973 --> 00:34:36.643
目前我们讨论了
凭借子分配实现的快速资源创建

00:34:36.976 --> 00:34:39.713
以及通过资源别名
实现的高效内存使用

00:34:39.947 --> 00:34:42.482
但要记住资源堆是快速灵活的

00:34:42.549 --> 00:34:45.252
因为你控制
堆资源的同步

00:34:45.819 --> 00:34:48.522
你在设备资源上不必这样做

00:34:49.656 --> 00:34:52.226
但与设备资源不同
Metal不知道

00:34:52.292 --> 00:34:54.895
指令会什么时候
修改堆资源的内容

00:34:55.395 --> 00:34:59.032
例如当渲染过程
将新内容存储到纹理中

00:35:00.267 --> 00:35:02.503
Metal也不知道
你何时会将堆内存的

00:35:02.569 --> 00:35:05.506
解释从一个别名集
改成另一个

00:35:07.174 --> 00:35:10.944
不过为了正确性 Metal需要
知道何时指令会更新堆资源

00:35:11.011 --> 00:35:14.114
这样其他指令
可以安全地读取结果

00:35:14.915 --> 00:35:16.250
这尤为重要

00:35:16.316 --> 00:35:18.986
因为GPU可以并行
执行多个指令

00:35:20.654 --> 00:35:22.789
为了实现堆资源的同步访问

00:35:22.856 --> 00:35:25.926
你的应用程序会创建
并管理GPU栅栏

00:35:26.393 --> 00:35:29.196
来在指令之间
沟通资源依赖性

00:35:30.197 --> 00:35:32.132
我们深入看看
GPU栅栏的工作原理

00:35:33.333 --> 00:35:35.536
GPU栅栏就是时间戳

00:35:35.903 --> 00:35:39.506
是GPU执行时间轴上的
一个参考点

00:35:40.240 --> 00:35:43.310
你可以用栅栏
编码两种行动来同步指令

00:35:43.810 --> 00:35:47.214
指令可以更新栅栏
将时间戳向前移

00:35:47.281 --> 00:35:48.649
当指令完成后

00:35:49.483 --> 00:35:51.351
而且指令可以等待栅栏

00:35:51.552 --> 00:35:55.255
在执行之前 等到
GPU触及最新的栅栏更新

00:35:56.623 --> 00:35:58.759
那我们回来看看
之前的游戏帧

00:35:58.926 --> 00:36:00.561
我会展示给你
如何使用栅栏

00:36:00.661 --> 00:36:03.530
来实现别名堆资源的
同步指令访问

00:36:05.132 --> 00:36:08.702
这就是示例帧
这个帧有三部分

00:36:08.802 --> 00:36:11.505
但现在我们有五个方框
因为两个渲染阶段

00:36:11.572 --> 00:36:15.409
渲染过程分成了
顶点和片段处理步骤

00:36:16.043 --> 00:36:18.178
我们有阴影过程
主过程

00:36:18.245 --> 00:36:21.815
最后是后处理过程
我们会使用计算来执行

00:36:23.584 --> 00:36:27.855
Metal指令是按顺序
提交给指令队列的

00:36:28.488 --> 00:36:29.790
所以可能目前不清楚

00:36:29.857 --> 00:36:32.059
为什么我们需要
指令间的同步

00:36:32.993 --> 00:36:35.429
不过GPU是并行机
可以并行地

00:36:35.495 --> 00:36:36.930
执行多个指令

00:36:38.232 --> 00:36:41.902
我们iOS和tvOS产品中的
GPU可以执行顶点

00:36:42.302 --> 00:36:45.372
片段和计算指令
全部并行执行

00:36:45.439 --> 00:36:47.841
将GPU的利用率最大化

00:36:48.709 --> 00:36:52.412
GPU甚至可以同时
执行多个帧

00:36:53.247 --> 00:36:55.015
好了 现在你可能
会发现一个问题

00:36:56.049 --> 00:36:57.885
看看这两个突出显示的指令

00:36:58.519 --> 00:37:00.153
它们都是在同时更新

00:37:00.220 --> 00:37:01.922
别名堆资源

00:37:02.923 --> 00:37:04.925
我们要使用栅栏来修复它

00:37:06.193 --> 00:37:07.794
首先我们将栅栏带入

00:37:09.162 --> 00:37:11.632
后处理指令更新栅栏

00:37:12.933 --> 00:37:16.036
所以阴影指令片段处理阶段

00:37:16.103 --> 00:37:17.304
可以等待栅栏

00:37:18.539 --> 00:37:22.442
现在这两个指令
不再同时执行了

00:37:23.510 --> 00:37:25.179
我将展示给你如何使用Swift

00:37:25.245 --> 00:37:27.481
给栅栏更新和栅栏等待编码

00:37:29.483 --> 00:37:31.685
首先 我们用设备创建栅栏

00:37:32.352 --> 00:37:34.154
这是新方法
--不带参数

00:37:34.955 --> 00:37:37.724
接下来 我们编码
后处理计算编码器

00:37:37.824 --> 00:37:39.193
在第一帧的结尾

00:37:39.693 --> 00:37:43.363
我们首先创建
computeCommandEncoder

00:37:43.597 --> 00:37:44.865
然后编码分派

00:37:46.567 --> 00:37:51.104
在我们结束编码器之前
我们首先更新栅栏

00:37:51.205 --> 00:37:55.843
这样后续指令可以等待
直到这个指令执行完成

00:37:57.444 --> 00:38:01.248
在下一个帧中我们会
编码阴影渲染

00:38:01.648 --> 00:38:03.283
我们创建
renderCommandEncoder

00:38:03.884 --> 00:38:06.353
在commandBufB中
代表指令缓冲

00:38:06.420 --> 00:38:07.521
用于下一帧

00:38:08.555 --> 00:38:12.159
不过在绘制场景之前
我们首先编码栅栏等待

00:38:13.160 --> 00:38:16.196
来等待到GPU上的后处理完成

00:38:16.496 --> 00:38:18.565
注意这一次
这里有两个参数

00:38:18.632 --> 00:38:21.168
第二个参数
叫做beforeStages

00:38:22.436 --> 00:38:25.439
渲染指令在两个阶段中执行
--顶点和片段

00:38:25.539 --> 00:38:29.209
所以Metal允许你指定
特定的需要

00:38:29.276 --> 00:38:30.444
等待栅栏的阶段

00:38:30.978 --> 00:38:32.980
在我们的例子中
只有片段阶段需要

00:38:33.046 --> 00:38:36.583
访问堆资源
所以我们指定片段阶段

00:38:38.352 --> 00:38:40.654
最后 我们可以安全地
渲染我们的阴影贴图

00:38:41.021 --> 00:38:43.390
因为我们知道
这个指令只有在

00:38:43.457 --> 00:38:46.293
前一帧的后处理
完成后才会执行

00:38:48.395 --> 00:38:51.265
让我谈谈一些
指令同步的最佳做法

00:38:52.332 --> 00:38:55.202
你知道如果使用堆
你必须使用栅栏

00:38:55.269 --> 00:38:56.970
来同步指令访问

00:38:57.037 --> 00:39:00.207
但你有这个控制是因为
你非常清楚

00:39:00.274 --> 00:39:02.476
你的资源是如何使用的

00:39:02.776 --> 00:39:05.879
而且你的应用程序
会有更高的CPU效率

00:39:06.180 --> 00:39:08.515
如果使用Metal
为你进行跟踪

00:39:09.449 --> 00:39:11.785
例如
只初始化一次的纹理

00:39:11.852 --> 00:39:14.588
并且未被修改
是不需要跟踪的

00:39:15.856 --> 00:39:17.057
另一个例子

00:39:17.324 --> 00:39:21.228
一起使用的资源可以
通过单个栅栏一同跟踪

00:39:24.131 --> 00:39:27.067
所以让我总结
资源堆的主旨

00:39:28.268 --> 00:39:31.071
凭借子分配
更快速创建资源

00:39:32.239 --> 00:39:35.642
通过资源别名
更加有效使用内存预算

00:39:36.710 --> 00:39:43.083
然后使用GPU栅栏
实现GPU指令间的堆更新同步

00:39:45.953 --> 00:39:50.991
好了 现在我想介绍另一项
在iOS和tvOS上可用的新功能

00:39:51.058 --> 00:39:52.693
无记忆渲染目标

00:39:53.560 --> 00:39:55.162
这听起来有点魔幻

00:39:55.295 --> 00:39:58.498
不过我会给你展示几乎
所有Metal应用都能使用该功能

00:39:58.565 --> 00:40:02.703
只通过一行代码
就节省大量的内存

00:40:04.571 --> 00:40:06.974
无记忆渲染目标
这种纹理

00:40:07.040 --> 00:40:10.077
不将任何系统内存
分配给纹理内容

00:40:10.811 --> 00:40:14.615
没有任何内存
存储纹理内容

00:40:14.848 --> 00:40:16.950
剩下的就是纹理元数据

00:40:17.017 --> 00:40:20.020
例如纹理尺寸和内部纹理格式

00:40:20.454 --> 00:40:22.956
很明显 这节省了大量的内存

00:40:23.290 --> 00:40:25.526
但什么时候能用
无记忆渲染目标呢？

00:40:26.426 --> 00:40:29.696
你可以将它们用于
未保存的渲染过程附件

00:40:30.497 --> 00:40:34.468
大多数Metal应用
会有一些附件与

00:40:34.535 --> 00:40:38.105
存储不在意行动
或多重采样解析有关

00:40:38.672 --> 00:40:42.109
而且用于那些渲染过程附件
的纹理可以是无记忆的

00:40:43.610 --> 00:40:46.180
要制作无记忆渲染目标

00:40:46.480 --> 00:40:49.116
你可以像平常创建纹理那样

00:40:49.249 --> 00:40:51.185
使用额外存储模式标记

00:40:51.351 --> 00:40:53.487
MTLStorageModeMemoryless

00:40:53.554 --> 00:40:54.454
这就行了

00:40:55.222 --> 00:40:59.193
该功能只支持iOS和tvOS
因为它依靠于

00:40:59.259 --> 00:41:03.564
A7及其之后GPU的
砖墙式渲染架构

00:41:04.531 --> 00:41:06.233
我来给你展示其工作原理

00:41:07.201 --> 00:41:09.970
在你的右边我们有
两个渲染过程附件

00:41:10.070 --> 00:41:12.039
一个色彩附件
一个深度附件

00:41:13.073 --> 00:41:16.376
A7及其之后GPU
以每次一个分块执行渲染过程

00:41:16.710 --> 00:41:20.380
利用快速的GPU分块存储

00:41:20.614 --> 00:41:22.015
在GPU的核心

00:41:23.050 --> 00:41:25.719
GPU分块存储包含
分块大小的

00:41:25.786 --> 00:41:28.388
深度 模板以及
色彩附件的代表

00:41:28.856 --> 00:41:31.191
这个分块存储
是完全隔离于

00:41:31.491 --> 00:41:33.594
纹理支持和系统内存

00:41:34.995 --> 00:41:37.331
在Metal中 你的
加载和存储动作控制着

00:41:37.397 --> 00:41:40.000
如何初始化GPU
分块存储 以及是否

00:41:40.067 --> 00:41:44.004
将GPU分块存储的结果
复制回系统内存里

00:41:45.205 --> 00:41:47.207
如果附件未从内存中加载

00:41:47.274 --> 00:41:49.042
而且未保存在内存中

00:41:49.343 --> 00:41:52.012
你可以使那个附件的
纹理变得无记忆

00:41:52.079 --> 00:41:54.615
来消除内存分配

00:41:55.716 --> 00:41:57.851
接下来 我会描述
一些很常见的情景

00:41:57.918 --> 00:42:00.587
你可以将该功能
应用到你的应用上

00:42:02.789 --> 00:42:06.894
深度附件经常在3D场景中
用于启用深度测试

00:42:07.895 --> 00:42:10.898
不过A7及其之后GPU
的深度测试是完全在

00:42:10.964 --> 00:42:13.433
GPU分块存储中进行
每次一个分块

00:42:13.834 --> 00:42:16.503
深度测试不需要
使用系统内存

00:42:17.171 --> 00:42:19.940
如果你不保存深度纹理
为之后过程所用

00:42:20.507 --> 00:42:22.709
那就将纹理变得无记忆
并节省下内存

00:42:24.311 --> 00:42:25.979
我来给你展示另一个机会

00:42:27.147 --> 00:42:29.049
当执行多重采样渲染时

00:42:29.116 --> 00:42:32.786
A7及其之后GPU在
GPU分块存储中进行所有渲染

00:42:33.053 --> 00:42:35.789
MSAA色彩附件纹理
会被使用

00:42:35.856 --> 00:42:38.625
只有在你选择
保存采样数据以备后用

00:42:39.593 --> 00:42:43.397
不过大多数应用会选择
多重采样解析存储动作

00:42:43.764 --> 00:42:46.133
这直接源于从GPU分块存储

00:42:46.200 --> 00:42:48.068
到解析色彩附件纹理

00:42:49.203 --> 00:42:52.739
在那种情况下 确保多重采样
色彩附件纹理是无记忆的

00:42:52.806 --> 00:42:54.675
而且这会节省大量的内存

00:42:56.009 --> 00:42:59.346
如你所见 采用该功能
所带来的节省是显著的

00:42:59.613 --> 00:43:02.449
通过将1080p
深度纹理变成无记忆的

00:43:02.783 --> 00:43:04.952
你的应用会省下将近8MB空间

00:43:05.586 --> 00:43:09.223
若你在12.9英寸iPad Pro
上渲染原始分辨率

00:43:09.489 --> 00:43:11.959
深度缓存的节省会高达20MB

00:43:12.759 --> 00:43:15.395
而且将四倍多重采样
渲染目标变得

00:43:15.462 --> 00:43:18.498
无记忆 会节省下更多
4倍之多

00:43:19.733 --> 00:43:23.303
所以使用无记忆渲染目标
来最大程度使用

00:43:23.370 --> 00:43:25.772
你的应用程序的内存预算

00:43:26.340 --> 00:43:29.409
使用这省下的空间降低
你游戏的内存占用

00:43:29.510 --> 00:43:31.812
或更好
用省下的空间

00:43:31.879 --> 00:43:34.248
在游戏中加入更加
精美独特的内容

00:43:36.350 --> 00:43:40.754
我想邀请Jose上台告诉大家
关于Metal工具上的所有改进

00:43:47.394 --> 00:43:48.262
谢谢 James

00:43:48.595 --> 00:43:50.898
除了Metal API上
新加的出色功能

00:43:50.964 --> 00:43:54.234
我们在Metal Developer Tool上
有一些出色的改进 给大家展示

00:43:56.904 --> 00:43:59.239
首先我们会谈谈
Metal System Trace的新功能

00:43:59.773 --> 00:44:02.309
之后介绍一项新功能
叫做GPU Overrides

00:44:03.076 --> 00:44:05.279
我们有一些非常
激动人心的新功能

00:44:05.345 --> 00:44:07.514
登录到
GPU Frame Debugger

00:44:11.785 --> 00:44:13.253
什么是
Metal System Trace？

00:44:14.254 --> 00:44:16.990
在之前的Metal演讲中
我们出示了这个图表

00:44:17.591 --> 00:44:21.295
展示了Metal在CPU和GPU
上的工作情况

00:44:22.062 --> 00:44:25.866
Metal System Trace
这一套工具可以将其可视化

00:44:26.633 --> 00:44:29.503
帮助你了解你的
Metal应用程序的时间轴

00:44:29.803 --> 00:44:33.340
通过整体图形管线
从CPU

00:44:33.740 --> 00:44:36.643
到GPU
再到显示器

00:44:38.812 --> 00:44:43.016
去年 WWDC 我们推出了
iOS平台的Metal System Trace

00:44:43.750 --> 00:44:46.253
我极力推荐去观看去年的展示

00:44:46.320 --> 00:44:48.388
来更好地总览Metal
System Trace

00:44:49.690 --> 00:44:52.392
之后在秋季
我们加入了tvOS支持

00:44:53.160 --> 00:44:55.662
今天我们很高兴宣布Metal
System Trace

00:44:55.729 --> 00:44:59.199
登录macOS 帮助你
榨干最后一滴性能

00:44:59.733 --> 00:45:01.168
在所有Metal平台上

00:45:06.406 --> 00:45:08.642
我们全方位地改进了Metal
System Trace

00:45:08.709 --> 00:45:10.377
扩展我们报告的事件

00:45:12.145 --> 00:45:13.213
对于资源事件

00:45:13.280 --> 00:45:16.116
我们将高开销的资源操作
变得直观 例如选取数据

00:45:16.183 --> 00:45:18.085
从系统内存到显存

00:45:20.053 --> 00:45:24.324
这种案例中
我们能看到macOS中的绘制

00:45:24.391 --> 00:45:26.426
这导致了GPU执行延迟

00:45:29.463 --> 00:45:32.666
Metal System
Trace还显示调试组

00:45:32.833 --> 00:45:36.937
这让你更容易让你了解
跟踪中的指令编码关系

00:45:38.839 --> 00:45:42.509
在macOS上 我们支持
同时跟踪多个GPU

00:45:42.776 --> 00:45:44.678
这对一些使用案例来说
这难以置信

00:45:44.745 --> 00:45:47.481
比如你在不同GPU之间分配工作

00:45:49.349 --> 00:45:52.052
在iOS上
我们现在显示定标器工作量

00:45:52.119 --> 00:45:54.922
所以当你遇到延迟时
可以进行诊断

00:45:55.222 --> 00:45:57.558
通过旋转或缩放你的视图

00:46:01.094 --> 00:46:03.363
你现在可以将种类更多的工具

00:46:03.430 --> 00:46:05.132
与Metal System
Trace一同使用

00:46:05.599 --> 00:46:09.970
例如Time Profiler
File Activity

00:46:10.838 --> 00:46:13.273
Allocations 还有更多

00:46:13.607 --> 00:46:18.078
甚至不同的视图 例如CPU数据
这会展示CPU核心时间片段

00:46:19.713 --> 00:46:23.483
这会帮助你将Metal事件
与内容进行关联

00:46:23.550 --> 00:46:25.152
深入了解

00:46:25.219 --> 00:46:27.888
系统运行应用程序的情况

00:46:27.955 --> 00:46:34.895
允许你诊断像是由
CPU停滞引起的GPU饥饿

00:46:35.429 --> 00:46:37.264
由于错误的I/O操作

00:46:40.767 --> 00:46:43.136
Metal System
Trace会捕捉大量的数据

00:46:43.504 --> 00:46:45.939
所以我们让解释和
导航变得更容易

00:46:47.441 --> 00:46:49.243
使用新的工作量突出显示

00:46:49.443 --> 00:46:52.279
你可以注重于任何
指令编码器或编码缓冲

00:46:53.113 --> 00:46:54.848
随着它在管线中通过

00:46:55.182 --> 00:46:56.783
通过键盘导航支持

00:46:56.850 --> 00:46:59.219
你可以将你的选择
快速地在跟踪中移动

00:47:01.655 --> 00:47:04.625
最后我想介绍Performance
Observation

00:47:04.958 --> 00:47:07.761
Performance
Observation是给你呈现

00:47:07.828 --> 00:47:10.764
潜在问题的完整列表
这是我们在

00:47:10.831 --> 00:47:12.499
跟踪中通过分析找到的

00:47:13.934 --> 00:47:16.470
从显示面耗时过长

00:47:17.504 --> 00:47:20.140
到意外着色器汇编

00:47:21.241 --> 00:47:23.510
或者高GPU执行时间

00:47:24.344 --> 00:47:27.781
Performance Observations
替你发现你在寻找的事件

00:47:28.215 --> 00:47:31.451
你能从Performance
Observation列表直接导航

00:47:32.619 --> 00:47:33.887
所有这些新功能
会允许你

00:47:33.954 --> 00:47:37.457
调整你的Metal应用程序
使其如你所想的那样流畅运行

00:47:38.358 --> 00:47:41.595
现在为了展示我们在
GPU调试上做出的出色改进

00:47:41.662 --> 00:47:43.430
让我交给我的同事 Alp

00:47:43.897 --> 00:47:47.434
演示GPU
Frame Debugger

00:47:56.977 --> 00:47:57.878
谢谢 Jose

00:47:58.779 --> 00:48:01.181
我今天有很多
出色的功能要给大家展示

00:48:01.348 --> 00:48:02.716
我们直接开始吧

00:48:04.117 --> 00:48:05.652
我的应用在这里运行

00:48:05.819 --> 00:48:09.590
漫游过美丽的地形
细节由曲面细分做到了极致

00:48:10.657 --> 00:48:12.993
在线框图中查看这个地形该多好

00:48:13.060 --> 00:48:14.862
去查看每一个三角形

00:48:15.896 --> 00:48:19.499
好消息是 我们最新的功能
GPU Overrides

00:48:19.600 --> 00:48:22.069
让你能够修改你的Metal渲染

00:48:22.169 --> 00:48:24.705
直接从调试栏
当应用还在运行时

00:48:26.039 --> 00:48:28.775
我们有多个不同的
覆盖你可以混搭使用

00:48:28.842 --> 00:48:30.210
包括线框图模式

00:48:31.445 --> 00:48:35.015
我们切换到线框图模式
来看看地形的曲面细分程度

00:48:37.184 --> 00:48:38.785
显示每个三角形

00:48:39.019 --> 00:48:41.922
你可能想要调整
曲面细分来找到

00:48:41.989 --> 00:48:44.558
性能和视觉品质之间平衡

00:48:45.259 --> 00:48:49.263
通常你需要回去更改你的代码
重新编译 然后运行

00:48:49.796 --> 00:48:52.332
但是有了GPU Overrides
你可以

00:48:52.399 --> 00:48:55.636
直接从Overrides菜单
试验曲面细分比例

00:48:57.070 --> 00:48:59.406
我们将比例设置到25%

00:49:02.242 --> 00:49:06.313
现在我们有更少的三角形
而且还丢失了一些有趣的细节

00:49:07.648 --> 00:49:09.283
我们试试75%

00:49:11.685 --> 00:49:14.688
我认为这个效果更好
我们看看没有线框图的样子

00:49:16.757 --> 00:49:18.091
可以 我喜欢这个

00:49:18.525 --> 00:49:21.161
这比开始少了很多三角形

00:49:21.461 --> 00:49:23.130
不过还是有全部的细节

00:49:23.197 --> 00:49:27.167
外加提升的性能 我可以
在场景中加入更多炫酷效果

00:49:28.702 --> 00:49:32.539
如你所见 GPU
Overrides这工具非常有助于

00:49:32.606 --> 00:49:34.775
初次诊断场景中的

00:49:34.842 --> 00:49:36.877
一些视觉和性能问题

00:49:38.345 --> 00:49:43.016
接下来我们捕捉这一帧
来给你展示一些功能

00:49:43.083 --> 00:49:45.452
来极大提升你的调试工作流

00:49:47.988 --> 00:49:49.323
帧捕捉已经完成

00:49:49.556 --> 00:49:55.362
我在查看地形资源
来看看地形面片的情况

00:49:57.397 --> 00:50:00.467
在Resource Center
中切换到所有GPU对象

00:50:00.868 --> 00:50:03.303
你能看到所有的纹理和缓冲

00:50:06.206 --> 00:50:08.141
我们这里有全部的资源

00:50:08.442 --> 00:50:10.577
我要一个个地查看

00:50:10.644 --> 00:50:13.614
来找地形资源
会花一些时间

00:50:14.615 --> 00:50:17.117
这就是新的筛选条
发挥作用的时刻

00:50:17.985 --> 00:50:21.421
你可以按这里的任何属性
进行筛选 例如标签

00:50:21.922 --> 00:50:23.790
类型 大小或者细节

00:50:25.559 --> 00:50:29.029
因为我标注了所有的资源
我就只按地形筛选

00:50:29.897 --> 00:50:33.834
在这里 我有所有
用于渲染地形的资源

00:50:35.569 --> 00:50:37.704
现在我找到了
地形面片缓冲

00:50:38.005 --> 00:50:41.108
我想做的是
看看它用在什么地方

00:50:42.409 --> 00:50:47.014
通过简单的拖放
我可以筛选功能导航器

00:50:47.080 --> 00:50:51.785
给我展示所有用于地形面片
缓冲的调用 就像这样

00:50:52.586 --> 00:50:56.323
在这个案例中 我使用计算
得知了它的计算位置

00:50:56.823 --> 00:50:59.793
以及当渲染地形时
它的读取位置

00:51:01.662 --> 00:51:03.230
这个筛选十分强大

00:51:03.697 --> 00:51:06.066
我还可以使用绑定资源的

00:51:06.133 --> 00:51:08.168
其他任何属性
来筛选绘制调用

00:51:09.069 --> 00:51:12.239
例如 如果你按sRGB筛选

00:51:12.706 --> 00:51:16.343
你会看到所有绘制调用
使用的纹理

00:51:16.410 --> 00:51:18.478
都是sRGB像素格式

00:51:19.613 --> 00:51:22.850
这是很自然的方式
快速地在帧上导航

00:51:25.085 --> 00:51:28.388
接下来 我们进入
绑定GPU对象

00:51:28.455 --> 00:51:31.859
来看看我们是如何
使用资源来渲染地形的

00:51:34.194 --> 00:51:36.864
在绑定模式中
你的资源归入在

00:51:36.930 --> 00:51:39.032
不同的部分中
基于使用它们的

00:51:39.099 --> 00:51:43.036
Metal管线阶段
所以你知道到哪里去找

00:51:44.404 --> 00:51:46.073
看看顶点阶段

00:51:46.139 --> 00:51:49.443
地形面片是一个
绑定到多个绑定点的缓冲

00:51:49.510 --> 00:51:50.744
拥有不同的偏移量

00:51:52.279 --> 00:51:55.482
我们使用唯一的
缓冲来检查数据

00:51:57.918 --> 00:51:59.953
所有的顶点数据的布局

00:52:00.020 --> 00:52:03.390
排列整齐 除了这是
来自带有面片的Metal函数

00:52:03.957 --> 00:52:07.828
所以这使用了与
后顶点函数完全相同的结构体

00:52:09.863 --> 00:52:11.498
我们这里有颜色数据

00:52:11.899 --> 00:52:15.435
它识别颜色单词
然后在这里显示

00:52:15.502 --> 00:52:17.070
值的真正颜色

00:52:19.640 --> 00:52:22.976
因为这是包含
不同数据类型的大型缓冲

00:52:23.210 --> 00:52:27.080
我用新的MTLBuffer API
添加了一些调试标记

00:52:27.247 --> 00:52:30.117
这会让你极其轻松地
找到你想要的东西

00:52:32.719 --> 00:52:35.389
通过布局菜单
你可以直接跳入

00:52:35.455 --> 00:52:38.125
其他你想检查的可用布局

00:52:43.230 --> 00:52:45.098
查看单个缓冲是很好的

00:52:45.866 --> 00:52:48.836
更好的是
新的输入属性视图

00:52:49.469 --> 00:52:52.172
让你看到所有的顶点数据

00:52:52.239 --> 00:52:53.974
与顶点着色器的视角一样

00:52:55.943 --> 00:52:58.979
输入属性从你的实例
中收集所有数据

00:52:59.413 --> 00:53:02.749
曲面细分因子缓冲
和stage_in数据

00:53:03.283 --> 00:53:06.954
之后提供给你单个视图
来一同查看它们

00:53:10.190 --> 00:53:14.061
在这个案例中
我们用多个面片渲染实例

00:53:14.361 --> 00:53:18.699
我可以看出什么数据
属于实例的哪个面片

00:53:20.601 --> 00:53:22.269
所以这简短介绍了

00:53:22.336 --> 00:53:25.005
GPU Frame
Debugger上的一些最新功能

00:53:25.072 --> 00:53:27.407
我们切回幻灯片
做个总结

00:53:32.212 --> 00:53:35.449
演示GPU
Frame Debugger

00:53:37.784 --> 00:53:41.421
你刚才看到了一些最新的GPU
Frame Debugger功能

00:53:41.588 --> 00:53:43.590
我想再告诉大家两个

00:53:46.326 --> 00:53:49.596
有了新Extended Validation模式
GPU Frame Debugger可以

00:53:49.663 --> 00:53:52.533
进行更加深入的应用分析

00:53:53.333 --> 00:53:57.271
在选择最佳纹理使用上
提供推荐

00:53:57.371 --> 00:53:59.573
或者资源的存储模式

00:54:01.275 --> 00:54:04.278
你可以从Xcode方案编辑器
中启用这个模式

00:54:07.548 --> 00:54:10.384
独立Metal Library
Projects的新支持

00:54:10.450 --> 00:54:14.354
让你创建Metal库
在多个应用中共享

00:54:14.755 --> 00:54:17.157
或者将多个库
包含在一个应用中

00:54:17.658 --> 00:54:19.960
就像其他任何框架或库

00:54:22.729 --> 00:54:24.331
使用我们讲的功能

00:54:24.398 --> 00:54:26.333
能极大提升
你的工具体验

00:54:26.900 --> 00:54:30.037
现在我们总结
本次演讲中看到的内容

00:54:32.840 --> 00:54:36.410
我们看到通过曲面细分
给Metal API新增的功能

00:54:36.844 --> 00:54:39.646
资源堆和无记忆渲染目标

00:54:40.147 --> 00:54:42.216
之后我们展示了改进的工具

00:54:42.282 --> 00:54:44.685
Metal System Trace
和GPU Frame Debugger

00:54:45.519 --> 00:54:47.754
一定要看看
下午的第二部分

00:54:47.821 --> 00:54:50.991
我会讲讲关于函数特殊化

00:54:51.124 --> 00:54:52.826
和函数资源读写

00:54:53.760 --> 00:54:55.696
广色域和纹理资源

00:54:56.230 --> 00:54:58.765
以及Metal性能
着色器的增加功能

00:55:00.868 --> 00:55:04.204
有关更多本次演讲的信息
请访问这个网络连接

00:55:04.605 --> 00:55:09.142
你可以补看视频 并得到
资料和示例代码链接

00:55:11.812 --> 00:55:15.148
我们昨天的演讲十分精彩
你可以在线观看

00:55:15.816 --> 00:55:19.219
这个下午 我们有
Metal的新功能 第二部分

00:55:19.419 --> 00:55:22.155
之后高级Metal着色器优化
就在这个演讲厅

00:55:23.190 --> 00:55:25.492
感谢大家的到来
祝各位 WWDC 过得愉快