00:00:19.920 --> 00:00:23.624
统一日志和活动追踪
记录未来

00:00:30.764 --> 00:00:36.503
欢迎大家来到“统一日志和
活动追踪——记录未来”

00:00:36.603 --> 00:00:40.307
感谢大家
能在周五晚上来到这里

00:00:41.775 --> 00:00:43.877
我是
Steven Szymanski

00:00:48.248 --> 00:00:50.684
真没想到这个时间
还有这么多人来听

00:00:50.751 --> 00:00:53.987
我是Steven Szymanski
将会主持大部分演讲

00:00:54.054 --> 00:00:56.757
稍后我会邀请
Matthieu Lucas上台

00:00:57.624 --> 00:01:00.994
那么我们开始吧
要讲的内容很多

00:01:01.728 --> 00:01:03.764
我开始先做个
简单的介绍

00:01:03.830 --> 00:01:07.067
然后讲讲新的日志系统
背后的基本概念

00:01:07.134 --> 00:01:08.869
这是这周
才引入的新系统

00:01:08.936 --> 00:01:10.704
一会儿
做个简短的演示

00:01:10.771 --> 00:01:13.006
然后再回过头来
讲解如何真正使用它

00:01:13.073 --> 00:01:15.742
如何使用API
怎么使用这些工具

00:01:16.243 --> 00:01:19.947
再讨论一下
我们心目中的最佳操作

00:01:21.215 --> 00:01:24.384
然后讲一下
如何收集你创建的记录

00:01:24.685 --> 00:01:27.588
最后讲一些
弃用的界面

00:01:28.722 --> 00:01:29.790
那么开始吧

00:01:31.658 --> 00:01:32.960
先讲一点背景

00:01:33.660 --> 00:01:37.297
如果你已经听过几场演讲
你就知道在2014年

00:01:37.664 --> 00:01:40.300
Apple引入了“活动追踪”的概念

00:01:40.801 --> 00:01:43.937
它能跟踪所有的工作

00:01:44.204 --> 00:01:47.908
代表某些操作
在整个系统里运行

00:01:48.141 --> 00:01:50.878
这个工作可以在一个应用里完成

00:01:50.978 --> 00:01:55.082
可以在应用调出的一个框架库里完成

00:01:55.148 --> 00:01:59.052
甚至可以代表应用在另外的进程里完成

00:02:00.053 --> 00:02:02.289
我们同时引入的另一个概念

00:02:02.856 --> 00:02:04.691
就是故障和错误

00:02:04.758 --> 00:02:10.464
这种特殊类型的日志事件
会引发额外的工作

00:02:10.531 --> 00:02:12.566
让系统收集额外数据

00:02:14.101 --> 00:02:16.670
作为开场白的最后一点

00:02:16.737 --> 00:02:21.008
就是我们意识到
Apple已有一些记录API

00:02:21.074 --> 00:02:25.179
而且希望演讲结束后
你能明白我们为什么要介绍

00:02:25.245 --> 00:02:29.149
这个新的API
以及它如何与其他人相互关联

00:02:32.186 --> 00:02:34.755
那么这个项目的目标是什么？

00:02:35.455 --> 00:02:38.025
首先我们想要做的是创建

00:02:38.091 --> 00:02:42.763
一个公开公共且有效的记录机制
覆盖整个系统

00:02:42.829 --> 00:02:45.432
既能用在用户模式下
也能用在内核模式下

00:02:45.499 --> 00:02:46.834
目标

00:02:46.900 --> 00:02:51.205
其中一个目的是为了
尽可能多的收集信息

00:02:51.271 --> 00:02:54.541
同时 最小化观察者效应

00:02:55.309 --> 00:02:59.112
这里的观察者效应指的是
我们开发者都有的体验

00:02:59.179 --> 00:03:02.883
当你遇到问题
将一些日志粘贴到你的代码

00:03:02.950 --> 00:03:06.153
问题一下子就没有了
因为你改变了时间

00:03:06.453 --> 00:03:10.023
我们想要一个无痕的
记录界面

00:03:10.090 --> 00:03:14.494
在你调出代码的时候
对代码的影响最小

00:03:15.596 --> 00:03:19.166
如何实现这一目标
就是这场演讲我要具体讲的内容

00:03:19.499 --> 00:03:21.001
首先 我们压缩数据

00:03:21.435 --> 00:03:25.506
这样就能在磁盘上
存更多的信息

00:03:26.607 --> 00:03:28.842
却不占用更多空间

00:03:29.910 --> 00:03:33.280
另外一件重要的事就是
我们延迟了许多工作

00:03:33.780 --> 00:03:38.185
我们能做的所有事情
都是在显示信息的时候

00:03:38.252 --> 00:03:42.055
而不是在收集信息的时候
所以我们想要延迟到那个时候

00:03:42.122 --> 00:03:45.125
这是我们采用的主要方法
来避免观察者效应

00:03:46.159 --> 00:03:51.698
另外我们做的就是用新方法
来管理消息的生命周期

00:03:52.232 --> 00:03:54.601
我们的想法是
不同种类的信息

00:03:54.668 --> 00:03:57.704
可能在系统里
停留的时间不同

00:03:57.771 --> 00:04:01.942
要尽可能让你想要的信息
真正出现在

00:04:02.009 --> 00:04:03.610
你实际去研究
和使用它们的时候

00:04:04.378 --> 00:04:07.247
背景情况是
我们想要能

00:04:07.314 --> 00:04:11.051
打开系统里尽可能多的日志
无论在任何时候

00:04:11.351 --> 00:04:13.220
而不需要回去再说

00:04:13.287 --> 00:04:16.423
“能否打开这个
再给我一个新的日志”

00:04:16.490 --> 00:04:18.659
我们要看到所有
越多越好

00:04:20.060 --> 00:04:21.762
另外一个动机是

00:04:21.827 --> 00:04:25.732
我们想把隐私
完全融入系统里

00:04:25.832 --> 00:04:27.568
这个我一会儿也会细讲

00:04:30.003 --> 00:04:32.105
那么
这个新系统的主要功能是什么？

00:04:33.207 --> 00:04:38.245
就是用新改进的方法
分类和筛选日志消息

00:04:38.545 --> 00:04:40.948
因此我们将为你
提供新的工具

00:04:41.014 --> 00:04:43.550
让你能给日志信息分类

00:04:43.617 --> 00:04:45.853
这样在需要查看日志的时候

00:04:46.220 --> 00:04:48.822
能更简单的找到
你要的信息

00:04:49.323 --> 00:04:50.424
特性

00:04:50.490 --> 00:04:55.662
另外很重要的一点是
日志系统会为你收集调令源的信息

00:04:55.729 --> 00:05:00.767
所以你不再需要传递文件和代码行

00:05:00.834 --> 00:05:02.769
去确定这个调令来自哪里

00:05:02.836 --> 00:05:04.905
我们自动为你收集好

00:05:12.379 --> 00:05:15.782
这里还有很多
新的内置分类符

00:05:16.183 --> 00:05:19.887
让我们可以为你
处理二进制数据的格式

00:05:19.953 --> 00:05:21.989
这样你就不用
花时间做这个了

00:05:22.856 --> 00:05:25.726
我们有个新的Console应用
和一个新的命令行工具

00:05:25.792 --> 00:05:27.761
我们用它们
来访问所有的功能

00:05:29.329 --> 00:05:31.365
我们所有的平台都支持它

00:05:31.431 --> 00:05:35.936
macOS iOS watchOS
tvOS和所有的模拟器

00:05:36.503 --> 00:05:38.005
它同时也可用于...

00:05:43.143 --> 00:05:48.282
用于这周发布的C
C++和Objctive-C版本

00:05:48.348 --> 00:05:50.717
不久之后也会支持Swift

00:05:54.021 --> 00:05:56.990
那么现在
给你一些小预告

00:05:57.057 --> 00:05:59.927
这是现在使用的Console应用
就是你看到的这样

00:06:01.528 --> 00:06:04.431
而这是
新Console的样子

00:06:04.498 --> 00:06:07.000
这里我要指出

00:06:11.705 --> 00:06:14.308
仔细看看高亮的这一部分

00:06:14.374 --> 00:06:18.579
这个树状图向你展示的
是一个特定活动

00:06:18.645 --> 00:06:20.948
不断从一个进程
到另一个进程的过程

00:06:21.014 --> 00:06:24.218
这样你就可以直观的看到
所有的工作情况

00:06:24.284 --> 00:06:26.720
它们代表你所请求的操作

00:06:28.789 --> 00:06:32.359
那么我们先来打个基础 讲讲理论

00:06:32.426 --> 00:06:34.328
以及背后的抽象概念

00:06:35.195 --> 00:06:36.330
首先 采用

00:06:37.197 --> 00:06:41.001
如果你想使用新的统一日志系统
你一开始要做的

00:06:41.068 --> 00:06:43.737
就是使用这周新发布的SDK
来进行创建

00:06:45.172 --> 00:06:46.373
如果这样做

00:06:46.440 --> 00:06:51.144
所有遗留的API NSLog
asl log和message syslog

00:06:51.211 --> 00:06:54.581
所有这些
都会被重新引入新系统

00:06:54.715 --> 00:06:58.051
你一行代码都不用改
就可以开始使用这个系统

00:06:58.118 --> 00:07:03.290
当然如果要使用这些新功能
就要开始使用新的API

00:07:03.357 --> 00:07:06.994
但是如果你什么都不做
直接使用新系统创建

00:07:07.060 --> 00:07:09.730
它们就都被引入
新的日志架构

00:07:10.531 --> 00:07:13.600
另一方面
如果你不想开始使用

00:07:13.667 --> 00:07:16.970
新的日志系统
并且继续用旧的SDK创建

00:07:17.037 --> 00:07:19.039
那么你的系统
不会有任何变化

00:07:19.106 --> 00:07:20.207
采用

00:07:21.041 --> 00:07:23.377
下面来讲
新的文件格式

00:07:25.646 --> 00:07:31.151
在新的系统里
日志数据是以二进制形式压缩在磁盘里

00:07:31.218 --> 00:07:32.886
叫做.tracev3文件

00:07:34.521 --> 00:07:37.958
这些文件现在的保存路径为
/var/db/diagnostics

00:07:38.559 --> 00:07:42.696
其辅助文件的路径为
/var/db/uuidtext

00:07:43.997 --> 00:07:46.800
现在可以用新的工具
访问这个数据

00:07:46.867 --> 00:07:49.803
我们有新的Console
新的命令行工具

00:07:50.070 --> 00:07:51.371
你还要记住一点

00:07:51.438 --> 00:07:55.142
就是由于数据
以二进制格式保存

00:07:55.409 --> 00:07:57.477
你必须使用新工具来访问

00:07:57.544 --> 00:08:01.348
所以你不能再用grep命令查找日志
而必须用我们的工具

00:08:01.415 --> 00:08:02.716
来浏览日志

00:08:04.151 --> 00:08:07.487
还有另一种新的文件类型
.logarchive

00:08:07.554 --> 00:08:09.990
这是为了
实现数据可移植性

00:08:10.390 --> 00:08:13.927
其实.logarchive文件
是信息的集合

00:08:13.994 --> 00:08:17.364
来自/var/db/diagnostics
和uuidtext

00:08:17.431 --> 00:08:19.733
它们集合到一个文件里

00:08:19.800 --> 00:08:25.405
这样就能更方便邮件传输
添加到故障报告等

00:08:28.041 --> 00:08:30.210
这个系统背后的
另一个新概念是

00:08:30.277 --> 00:08:32.145
子系统和分类

00:08:33.179 --> 00:08:37.017
日志消息现在可以
与一个子系统和一个分类联系在一起

00:08:38.284 --> 00:08:42.556
它可以用来控制
日志消息的筛选和显示

00:08:43.890 --> 00:08:47.427
一个子系统实际上
可以包含很多个不同的类别

00:08:47.861 --> 00:08:52.165
而且你可以使用很多子系统和分类
只要你需要

00:08:53.033 --> 00:08:57.237
举个例子
你可能有一些应用

00:08:57.304 --> 00:09:01.775
并定义一个子系统为
com.your-company.your-application

00:09:01.842 --> 00:09:06.246
它有三个分类setup
inprogress和teardown

00:09:06.914 --> 00:09:08.348
在同一个应用里

00:09:08.415 --> 00:09:14.855
你还可以定义另一个子系统
com.your-company.test.your-application

00:09:14.922 --> 00:09:17.324
只包含一个分类测试

00:09:17.758 --> 00:09:22.129
你可以用它们
来控制日志消息的显示

00:09:23.664 --> 00:09:26.400
日志行为
这是这个系统的核心所在

00:09:27.034 --> 00:09:32.072
每个日志消息都有一个级别
由你创建使用的API决定

00:09:32.372 --> 00:09:36.376
有三个基本级别：Default
Info和Debug

00:09:36.910 --> 00:09:39.847
还有两个特殊级别：故障和错误

00:09:42.516 --> 00:09:44.918
每个基本级别有两个特征

00:09:44.985 --> 00:09:49.289
既可以在系统范围内
定义给某个子系统

00:09:49.556 --> 00:09:52.392
也可以给子系统里
定义一个特定类别

00:09:53.160 --> 00:09:54.795
第一个是指
是否可用

00:09:54.862 --> 00:09:57.898
如果你发出指令
它是否真的能生成一个log line

00:09:58.699 --> 00:10:01.835
要注意
默认消息总是可用的

00:10:01.935 --> 00:10:03.770
你无法关闭默认消息

00:10:05.172 --> 00:10:08.709
另一个特征就是
你可以定义所有级别

00:10:08.775 --> 00:10:10.911
是要保存到磁盘
还是内存

00:10:11.211 --> 00:10:13.747
看上去应该是
存到磁盘里

00:10:14.982 --> 00:10:16.917
但是我说的是
存到内存里

00:10:16.984 --> 00:10:19.253
新的统一日志系统

00:10:19.319 --> 00:10:23.624
保存了大量的
内存中环形缓冲区

00:10:23.824 --> 00:10:26.360
一些日志消息
可以被转到这里

00:10:26.860 --> 00:10:30.931
然后这些消息只会在
故障和错误时存到磁盘里

00:10:31.832 --> 00:10:34.968
这很有用
尤其是对很快就过期的消息来说

00:10:35.035 --> 00:10:37.004
假设你有一个消息

00:10:37.337 --> 00:10:41.875
这个信息
基本上已经没用了

00:10:42.042 --> 00:10:44.945
你所能看到的
就是这个消息最后的版本

00:10:45.012 --> 00:10:49.550
无论何时你收到一个日志
都没有必要把几百个

00:10:49.616 --> 00:10:50.918
不同的备份存到磁盘上

00:10:51.218 --> 00:10:55.989
如果存到缓冲区
它就可以在故障与错误中找到

00:10:56.056 --> 00:10:57.791
而且就是你需要的
最后一版

00:10:57.858 --> 00:10:59.960
而不用存
一堆额外的东西

00:11:01.695 --> 00:11:03.864
这些级别是有顺序的

00:11:03.931 --> 00:11:06.800
也就是说 若你定义Debug给磁盘

00:11:06.867 --> 00:11:09.403
那么信息也会引入磁盘

00:11:11.305 --> 00:11:13.240
所有这些行为都可以自定义

00:11:13.307 --> 00:11:16.777
通过安装文件
或者在macOS上使用log命令

00:11:19.379 --> 00:11:21.415
会立刻出现
什么样的标准行为呢？

00:11:21.481 --> 00:11:24.151
如果你没有安装
一个特定文件的话

00:11:24.985 --> 00:11:28.055
Default级别的消息
总是可用

00:11:28.121 --> 00:11:31.959
标准配置下
他们会进入磁盘

00:11:32.693 --> 00:11:36.263
Info级别的信息可用
但是他们进入内存

00:11:37.197 --> 00:11:42.536
Debug级别的信息是关闭的
他们不可用

00:11:42.603 --> 00:11:45.172
当然因为处于关闭
他们哪里也去不了

00:11:46.406 --> 00:11:50.344
那么另外两种类型的消息
就是故障和错误

00:11:51.512 --> 00:11:54.448
故障和错误通常都是开启的
并总是存入磁盘

00:11:56.650 --> 00:11:58.418
现在花点时间
来讲讲隐私

00:11:59.686 --> 00:12:02.990
你知道
Apple十分重视客户隐私

00:12:03.056 --> 00:12:05.792
作为指导原则
我们设计的所有产品

00:12:05.859 --> 00:12:09.162
在我们的应用 服务
以及OS的新版本

00:12:09.429 --> 00:12:11.565
都要尊重用户的隐私

00:12:11.999 --> 00:12:16.403
所有的开发者 包括你们在座的各位
都跟我们有一样的责任

00:12:17.070 --> 00:12:18.539
如何在日志里体现呢？

00:12:18.605 --> 00:12:21.375
我们想避免的是不小心记录了

00:12:21.441 --> 00:12:25.078
能够识别个人信息的日志

00:12:25.279 --> 00:12:27.915
这样其他人就可以
从日志数据中提取信息

00:12:28.882 --> 00:12:33.287
因此 动态字符串
集合 阵列和对象等

00:12:33.353 --> 00:12:36.056
都被认为
是包含隐私的数据

00:12:36.256 --> 00:12:39.626
静态字符串和标量
被认为是可公开的

00:12:40.694 --> 00:12:44.231
稍后我们会进一步讲讲
怎样控制它

00:12:45.632 --> 00:12:46.567
现在来看
故障和错误

00:12:46.633 --> 00:12:50.470
我之前讲过
作为活动追踪的一部分

00:12:50.838 --> 00:12:53.040
我们引入了
故障和错误的概念

00:12:54.374 --> 00:12:56.577
它的一个基本理念就是

00:12:56.643 --> 00:13:00.948
我们在故障和错误上
下更多功夫

00:13:01.014 --> 00:13:02.549
就能保存更多的信息

00:13:03.283 --> 00:13:06.553
错误指的是一个问题

00:13:06.620 --> 00:13:09.056
出现在不同应用或者库里

00:13:09.857 --> 00:13:13.961
对于错误
我们查找内存缓冲区

00:13:14.027 --> 00:13:17.898
收集来自相关进程的
所有日志消息

00:13:17.965 --> 00:13:20.501
并保存到磁盘上
作为错误的一部分

00:13:21.602 --> 00:13:26.139
相对而言 故障代表的是
系统中更广泛的问题

00:13:26.206 --> 00:13:27.975
是更大型的故障

00:13:28.876 --> 00:13:32.112
针对故障
我们查找存储缓冲区

00:13:32.179 --> 00:13:35.182
收集相关进程的
所有日志消息

00:13:35.249 --> 00:13:38.051
以及这个活动
涉及到的所有进程

00:13:39.353 --> 00:13:42.322
实际上我们还收集了
一些其他系统信息

00:13:42.389 --> 00:13:44.157
它们可能对我们有用

00:13:45.459 --> 00:13:49.396
故障与错误以及所有
作为它们的部分而收集的日志数据

00:13:49.463 --> 00:13:52.766
都实际上存到了
单独的一套日志文件中

00:13:53.967 --> 00:13:58.205
这样做是为了
不让正常的日志把他们挤掉

00:13:58.272 --> 00:14:02.476
因为这会导致它们超出份额
占用更多的空间

00:14:02.809 --> 00:14:05.679
也就是说
故障和错误的数据会一直存在

00:14:05.746 --> 00:14:08.248
甚至比正常的日志数据还长

00:14:10.651 --> 00:14:15.155
好的 现在我来做
一个很直观的介绍

00:14:15.222 --> 00:14:17.958
看看系统如何在
细节大量丢失的情况下工作

00:14:18.025 --> 00:14:21.995
这是个比较宽泛粗略的讨论

00:14:22.629 --> 00:14:24.097
好了 每一个进程里

00:14:24.164 --> 00:14:27.668
有一个小缓冲区的集合
我们会把日志消息存在这里

00:14:28.068 --> 00:14:31.672
这些缓冲区实际存在于
与日志守候进程共享的内存里

00:14:32.406 --> 00:14:35.742
缓冲区满了的时候
日志守候进程就会开启

00:14:36.009 --> 00:14:39.980
把数据压缩进
它的一个更大的缓冲区

00:14:40.814 --> 00:14:44.918
当这些大的缓冲区也满了的时候
我们可以把它们存到磁盘上

00:14:44.985 --> 00:14:48.355
也可以再利用
将它们作为内存缓冲器的一部分

00:14:48.422 --> 00:14:50.023
架构

00:14:50.090 --> 00:14:52.559
那么最后会做的就是

00:14:52.626 --> 00:14:55.629
请求在线流式
日志数据

00:14:55.696 --> 00:14:58.332
比如你在Console上
想看到的日志

00:14:58.498 --> 00:15:00.000
是在一出现就实时记录的

00:15:00.567 --> 00:15:01.802
我们执行的方法是

00:15:01.869 --> 00:15:06.440
立刻做一个IPC
连接到诊断守候进程

00:15:06.807 --> 00:15:09.943
它会分发日志消息
给所有的客户

00:15:10.644 --> 00:15:12.513
副作用是

00:15:12.579 --> 00:15:16.850
它会极大的影响
在线流式日志数据的性能

00:15:17.317 --> 00:15:21.722
基本上我们做了很多努力
来节省力气 提高日志的速度

00:15:21.788 --> 00:15:25.392
这样你的代码
就不会有观察者效应

00:15:25.459 --> 00:15:29.263
因为我们给每个调令
都做了IPC

00:15:30.397 --> 00:15:34.902
另外要注意的是
每一类消息是如何

00:15:34.968 --> 00:15:39.106
不管从应用还是某个子系统
还是绕过这些路径

00:15:39.173 --> 00:15:41.675
如果通过配置等等来改变

00:15:43.544 --> 00:15:48.182
我讲的差不多了
请Matthieu Lucas上台

00:15:48.248 --> 00:15:52.252
来为大家实际演示一下
如何使用Console应用

00:15:59.092 --> 00:16:00.093
谢谢 Steven

00:16:00.727 --> 00:16:03.197
就像Steven
在一开始说的那样

00:16:03.797 --> 00:16:06.366
今年我们引入了
全新的Console应用

00:16:06.767 --> 00:16:10.871
我们重新
用Swift编写

00:16:11.205 --> 00:16:14.107
我们想创建
一个新的日志系统

00:16:14.174 --> 00:16:17.911
让你们的开发
能够更简单

00:16:18.679 --> 00:16:19.947
让我们来看看这个应用

00:16:21.215 --> 00:16:22.182
这是新的界面

00:16:23.684 --> 00:16:26.486
你能看到
布局其实没怎么变

00:16:26.553 --> 00:16:30.691
中间还是主要流式

00:16:30.757 --> 00:16:34.761
顶部是不同的操作
边栏是不同的来源

00:16:35.229 --> 00:16:38.565
先来看看边栏

00:16:38.899 --> 00:16:41.201
你还是能看到
不同的报告

00:16:42.102 --> 00:16:46.406
系统报告或者用户报告
还有不同的遗留日志

00:16:46.473 --> 00:16:48.408
它们可能都有
系统路径

00:16:48.775 --> 00:16:50.944
但是这里你看到
有一个新部分

00:16:51.011 --> 00:16:55.015
我们现在可以显示
所有连接到你的机器的设备

00:16:55.082 --> 00:16:56.817
也会显示当前的机器

00:17:01.622 --> 00:17:07.060
我们可以支持iOS
tvOS和watchOS设备

00:17:07.127 --> 00:17:10.430
所以你可以连接
所有你有的设备

00:17:10.830 --> 00:17:13.700
现在再来看看
主要流式

00:17:14.134 --> 00:17:16.136
现在 日志流
由两个视图组成

00:17:16.637 --> 00:17:19.673
一个是消息视图
一个是活动视图

00:17:20.406 --> 00:17:22.309
就跟Steven
之前说的一样

00:17:22.742 --> 00:17:27.114
在活动视图里
你可以看到活动的分层

00:17:27.181 --> 00:17:29.716
以及相关的消息
如果有的话

00:17:29.783 --> 00:17:33.053
细节会显示在底部
这里

00:17:34.888 --> 00:17:37.391
现在转过来看看消息

00:17:38.425 --> 00:17:42.029
这里你看到
有一大堆消息

00:17:42.196 --> 00:17:46.767
那么为了能包含
Debug和Info消息

00:17:46.834 --> 00:17:49.703
你需要在Action菜单里
手动操作

00:17:49.770 --> 00:17:52.206
这样他们就能
和默认的流一起显示

00:17:53.307 --> 00:17:55.943
现在我们来多看一些...

00:17:56.343 --> 00:18:00.214
我开几个应用来创建一些日志

00:18:00.781 --> 00:18:04.418
这里现在能看到
出现了更多的信息

00:18:04.685 --> 00:18:07.721
能看到
不同的消息类型

00:18:08.222 --> 00:18:12.192
通过这些彩色的点
在类型这一栏

00:18:12.259 --> 00:18:16.630
灰色的是Info消息

00:18:17.231 --> 00:18:21.001
黄色的是错误
红色的是故障

00:18:21.101 --> 00:18:26.340
深灰色的是Debug

00:18:26.440 --> 00:18:29.776
如果没有点
就是默认类型

00:18:31.311 --> 00:18:37.150
你也可以展开
或者折叠你的消息

00:18:37.217 --> 00:18:41.154
直接在行内
使用左右箭头

00:18:41.221 --> 00:18:45.459
或者使用这里的
视图菜单选项

00:18:45.526 --> 00:18:47.127
展开或折叠

00:18:48.195 --> 00:18:51.398
只要你点一个消息

00:18:51.465 --> 00:18:55.602
你就能看到
有关这个消息的所有细节

00:18:55.669 --> 00:18:58.505
就在下面这个
细节视图里

00:18:59.273 --> 00:19:01.875
所以说
我们可以展示给你所有信息

00:19:01.942 --> 00:19:07.414
只要是有关这个日志的
这就是新的日志系统的一部分

00:19:07.581 --> 00:19:11.919
那么现在我们来展示一下进程
还有它来自哪个库

00:19:12.186 --> 00:19:13.954
你们看到这一个

00:19:14.021 --> 00:19:18.258
它就accountsd下的
Accounts.framework

00:19:20.961 --> 00:19:26.700
你还能看到更多的信息
在我们收集所有新日志的时候

00:19:26.900 --> 00:19:30.537
你现在看到
我们有子系统 分类

00:19:31.205 --> 00:19:34.041
活动ID
线程ID或PID

00:19:35.742 --> 00:19:39.213
现在再看看这个iPad

00:19:39.479 --> 00:19:45.986
我连接的iPad只有一个最基本应用
上面有些数字

00:19:46.320 --> 00:19:52.526
我们要找到它们
通过浏览不同的功能

00:19:53.660 --> 00:19:57.698
首先我们最小化
栏的布局

00:19:57.764 --> 00:20:01.201
我可以右击上方
这里

00:20:01.268 --> 00:20:05.873
然后添加一些新的栏

00:20:05.939 --> 00:20:09.877
我就添加子系统
和分类

00:20:11.411 --> 00:20:13.714
然后把它挪到这里

00:20:13.780 --> 00:20:19.086
现在这个布局是永久的
你不用再设第二遍

00:20:19.820 --> 00:20:24.525
现在我们可以看到
这个设备上有很多信息

00:20:24.591 --> 00:20:27.661
为了精确你的搜索

00:20:27.728 --> 00:20:31.965
我们有两个方法

00:20:32.032 --> 00:20:35.202
你可以首先
右击一个消息

00:20:35.769 --> 00:20:38.505
然后你能选择
不要子系统

00:20:38.572 --> 00:20:42.576
不要进程
或者只显示一个特定的进程

00:20:42.643 --> 00:20:48.115
这样我们开始就可以
减掉特定的分类

00:20:48.182 --> 00:20:49.983
假设我们要widgets不出声

00:20:51.351 --> 00:20:57.291
第二个方法就是

00:20:57.357 --> 00:20:58.859
在这里直接打字输入

00:20:58.926 --> 00:21:03.063
所以你看到 我们只添加了一个
自定义的token给widget

00:21:03.864 --> 00:21:07.601
假设我只想看Bookmarks应用

00:21:07.668 --> 00:21:09.770
就是这个应用
在我的设备上出错了

00:21:10.938 --> 00:21:15.509
这样一来 这里就只有
来自Bookmarks的消息了

00:21:15.776 --> 00:21:17.611
而没有分类widget

00:21:18.045 --> 00:21:23.350
那么再来添加一个token
只显示错误类型

00:21:24.685 --> 00:21:27.554
现在看到的消息
就只来自于Bookmarks

00:21:27.621 --> 00:21:31.859
没有分类widget
并带有一个错误类型

00:21:32.159 --> 00:21:38.532
我们可以看到网页视图的
不同的错误

00:21:39.933 --> 00:21:45.672
这就是我们如何
直接关联到要查找的内容

00:21:46.173 --> 00:21:50.043
为了之后能修正错误
你只要保存它

00:21:50.110 --> 00:21:53.847
通过点击右上方的
保存键

00:21:54.948 --> 00:21:58.018
名字就叫Bookmark Errors

00:21:58.952 --> 00:22:04.124
你可以看到所有你保存的搜索
都会显示在这个部分里

00:22:04.992 --> 00:22:09.596
你可以重新排列它们
愿意的话也可以删除

00:22:09.663 --> 00:22:12.466
你会有两个
默认保存的搜索

00:22:12.533 --> 00:22:14.768
就是全部信息
和故障及错误

00:22:15.002 --> 00:22:18.539
现在来转到
活动视图

00:22:18.605 --> 00:22:21.575
看看能否找到
更多有关这些日志的情况

00:22:21.642 --> 00:22:24.545
能否简单的
重制这些错误

00:22:25.679 --> 00:22:29.583
这里我们看到
不同的活动

00:22:29.917 --> 00:22:33.987
这些活动的视图
基于同样的搜索机制

00:22:34.621 --> 00:22:39.193
所以我们可以使用同样的功能
并且保存

00:22:39.927 --> 00:22:41.328
这里我们看到

00:22:41.395 --> 00:22:47.401
不同孩子的
Bookmarks活动

00:22:47.768 --> 00:22:49.837
我们可以看到
当时是在准备转换

00:22:49.903 --> 00:22:55.609
然后我们检索一个对象
打开细节视图

00:22:55.676 --> 00:22:58.879
然后设定细节视图
下载网页视图

00:22:59.279 --> 00:23:04.518
现在你就可以看到
信息直接显示在底部的视图

00:23:04.985 --> 00:23:06.820
这些都是
有关这个活动的信息

00:23:06.887 --> 00:23:12.960
这个消息是记录在这个活动里的
所以才会显示在这里

00:23:13.327 --> 00:23:16.263
我们现在看到
这些消息

00:23:16.330 --> 00:23:20.901
这两个错误
是加载网页视图活动的一部分

00:23:22.135 --> 00:23:26.206
那么我们就知道了
是什么情况

00:23:26.273 --> 00:23:29.409
导致了这个错误

00:23:29.743 --> 00:23:34.448
那么现在我们添加
一个分享选项给Console

00:23:34.515 --> 00:23:37.985
你只要选择
一些活动或消息

00:23:38.318 --> 00:23:41.622
直接分享给某个人
或者给备注

00:23:41.688 --> 00:23:45.325
我这里就只添加为备注
以便以后的调试

00:23:46.527 --> 00:23:47.861
下一个问题

00:23:53.500 --> 00:23:58.739
另外一个可用的输入
是日志档案

00:23:58.805 --> 00:24:00.941
在桌面上有一个日志档案

00:24:01.008 --> 00:24:03.810
是另外一个设备
之前生成的

00:24:04.178 --> 00:24:07.714
如果你也有一个
双击它

00:24:07.781 --> 00:24:09.049
Console会打开它

00:24:09.616 --> 00:24:13.787
你可以看到
无论何时你点开它

00:24:14.087 --> 00:24:15.489
它就会下载所有的东西

00:24:15.923 --> 00:24:17.558
你还可以看到

00:24:17.624 --> 00:24:22.095
这里保存的筛选
跟我们之前说的一样

00:24:22.162 --> 00:24:28.135
那么为了能看到
这个特定的日志文档

00:24:28.202 --> 00:24:33.140
是否包含了同样的错误消息
作为流的当前设备

00:24:33.207 --> 00:24:38.712
我们只要点击它
它就会自动重新应用同样的筛选

00:24:39.513 --> 00:24:42.449
这里就看到
错误是一样的

00:24:42.516 --> 00:24:48.689
同样我们也可以在活动视图
查看同样的活动

00:24:49.323 --> 00:24:54.561
这就是Console的全部内容
我要请Steven回到舞台

00:24:54.928 --> 00:24:55.863
谢谢

00:25:05.539 --> 00:25:07.241
十分感谢 Matthieu

00:25:08.275 --> 00:25:12.379
我十分喜欢新的Console
很好用

00:25:13.113 --> 00:25:17.184
那么我们来讲讲
新的统一日志系统

00:25:17.251 --> 00:25:18.552
以及如何实际使用

00:25:20.320 --> 00:25:23.690
首先我们来总结一下
所有新的API

00:25:24.291 --> 00:25:29.796
Os_log是基本的日志API
用默认模式记录

00:25:30.097 --> 00:25:36.003
Os_log_info是一个调令
默认发送日志消息给内存

00:25:36.069 --> 00:25:40.874
也用于你想收集的额外即时信息

00:25:41.441 --> 00:25:44.178
Os_log_debug用于
十分频繁的调试

00:25:45.012 --> 00:25:47.548
另外还有os_log_error
和os_log_fault

00:25:47.614 --> 00:25:49.483
用来生成故障和错误信息

00:25:49.816 --> 00:25:52.219
最后一个调令
是os_log_create

00:25:52.286 --> 00:25:55.856
它能创建一个日志对象
让你自定义你的行为

00:25:56.156 --> 00:25:58.158
就这一点
我们再深入讲一下

00:25:58.225 --> 00:26:00.427
因为它对你们来说
应该是最不熟悉的

00:26:00.494 --> 00:26:02.729
相较于其他内容而言

00:26:03.263 --> 00:26:06.533
调出os_log_create
由两个参数组成

00:26:06.600 --> 00:26:09.203
子系统的名字
和分类的名字

00:26:09.670 --> 00:26:12.873
它要做的是创建
一个线程安全的单例对象

00:26:13.106 --> 00:26:16.510
来控制
你传递的日志调令行为

00:26:17.611 --> 00:26:21.014
在默认情况下
这是个系统范围内的行为

00:26:21.315 --> 00:26:24.084
但是你可以自定义为
某种特定的行为

00:26:24.151 --> 00:26:26.653
通过使用配置
或者日志命令行工具

00:26:27.454 --> 00:26:30.524
使用方法就是
简单地将它作为第一个参数传递

00:26:30.591 --> 00:26:31.625
给所有其他调令

00:26:31.692 --> 00:26:35.729
这里我调出os_log
第一个参数为log

00:26:35.796 --> 00:26:39.132
它是从os_log_create
返回的值

00:26:41.034 --> 00:26:44.104
它所做的就是
制造一个引用给分类

00:26:44.171 --> 00:26:47.574
和用这个日志对象
定义的子系统

00:26:47.641 --> 00:26:50.711
跟每个用到的日志消息
存在一起

00:26:51.211 --> 00:26:55.916
以便以后可用在后端上
筛选和显示消息

00:26:57.050 --> 00:27:01.755
如果你无所谓有没有
自己的子系统和分类

00:27:01.822 --> 00:27:04.958
那么另一个办法就是传递一个
os_log_default

00:27:05.025 --> 00:27:07.728
只是我们一直提供的
默认日志对象

00:27:07.995 --> 00:27:09.963
它没有子系统或分类

00:27:10.197 --> 00:27:13.834
但是它很有用
如果你不需要那种控制的话

00:27:16.203 --> 00:27:17.538
内置类别格式化

00:27:18.205 --> 00:27:24.044
我们都花费了大量的代码
去把二进制信息转换成字符串

00:27:24.111 --> 00:27:25.345
以便我们记录

00:27:25.612 --> 00:27:28.715
统一日志系统
可以帮你完成大部分这样的工作

00:27:28.782 --> 00:27:31.885
通过为常见的类别
提供内置格式化

00:27:32.319 --> 00:27:34.021
更重要的是

00:27:34.087 --> 00:27:39.126
我们省去了转换工作
直到我们要显示日志消息的时候

00:27:39.193 --> 00:27:41.461
所以你不需要
为转换而苦恼

00:27:41.528 --> 00:27:43.564
在生成日志消息的时候

00:27:44.031 --> 00:27:49.069
避免所有不同类型的
观察者效应

00:27:50.070 --> 00:27:52.506
这点我们多讲一些

00:27:52.606 --> 00:27:55.209
对于一些常用的值
这里有内置的解码

00:27:55.542 --> 00:27:58.645
语法不是％d

00:27:58.712 --> 00:28:04.117
而是％（time t ）d

00:28:04.184 --> 00:28:06.720
这就是说
这个十进制的值

00:28:06.787 --> 00:28:10.023
你传递的实际上
是一个time_t

00:28:10.090 --> 00:28:13.694
那么在打印的时候
印出的就是一个time字符串

00:28:14.695 --> 00:28:17.865
同样的
对于错误你要写 ％（errno ）d

00:28:17.931 --> 00:28:21.301
这样这个错误就会被转换成
肉眼可以辨识的格式

00:28:23.537 --> 00:28:29.443
我们还有一个新的基本时间格式
％P 不是小写p

00:28:29.510 --> 00:28:31.044
这已经不是新闻了

00:28:31.111 --> 00:28:34.114
你可以用它来显示
任意二进制数据

00:28:35.015 --> 00:28:39.920
所有常用类型都有解码器
比如％（uuid t ）

00:28:40.721 --> 00:28:46.260
这里列出了
我们现在使用的所有代码

00:28:46.326 --> 00:28:48.529
包括所有不同类型的时间值

00:28:48.595 --> 00:28:53.934
errno和uuids
还有所有不同类型的网络ID

00:28:54.501 --> 00:28:58.405
而且我们很期待
未来还有更多的代码出现

00:29:00.607 --> 00:29:02.809
那现在讲讲
以参数为单位的隐私

00:29:04.111 --> 00:29:07.648
隐私现在基于参数处理
并以一个参数为单位

00:29:08.115 --> 00:29:11.051
标量和静态字符串
被认为是公开的

00:29:11.718 --> 00:29:16.356
另一方面
动态字符串 集合和对象被认为

00:29:16.423 --> 00:29:20.194
含有隐私信息
除非你特别说明

00:29:21.161 --> 00:29:25.365
那么这个行为就可以重写
以一个参数为基准

00:29:25.666 --> 00:29:28.335
以前会写％@
来表示

00:29:28.402 --> 00:29:33.073
“我想把这个对象
包含进我的日志”

00:29:33.140 --> 00:29:36.643
而现在你要写％（public ）@
来告诉我们这个对象

00:29:36.710 --> 00:29:40.547
以及这个对象里的所有内容都是公开的
不用担心

00:29:41.215 --> 00:29:45.786
另外如果你有一个事件
里面的一些数值

00:29:45.853 --> 00:29:50.357
出于某些原因是隐私的
你就可以写％（private ）d

00:29:50.591 --> 00:29:54.127
让这个数据记录为
隐私信息

00:29:56.897 --> 00:29:59.700
这样你就可以把
隐私和格式结合起来

00:29:59.766 --> 00:30:04.771
那么我可以写
％（public, uuid t ）.16P

00:30:04.838 --> 00:30:06.940
来表示这里有一个uuid

00:30:07.007 --> 00:30:10.344
它是公开信息
并且已格式化

00:30:12.112 --> 00:30:14.047
那么我们再讲讲实例

00:30:14.114 --> 00:30:18.051
看看写代码的时候
会产生什么不同

00:30:18.719 --> 00:30:21.355
日志消息简化

00:30:21.522 --> 00:30:23.524
这是我们以前用的方法

00:30:23.991 --> 00:30:26.126
好的
首先你要检查并声明

00:30:26.193 --> 00:30:29.463
当前的日志层级
是否在发出任何调令前可用

00:30:29.530 --> 00:30:34.101
然后你要声明
你要显示一个uuid

00:30:34.168 --> 00:30:38.071
你要做的第一件事就是
调出unparse 转换成字符串

00:30:38.705 --> 00:30:41.074
碰巧你还有
一个套接字地址

00:30:41.141 --> 00:30:43.377
这个之后
也要转换成字符串

00:30:44.378 --> 00:30:48.682
然后调出NSLog
包括所有已经转换的元素

00:30:48.749 --> 00:30:51.185
当然你还要
传递这个函数的名字

00:30:51.251 --> 00:30:53.153
以及file和line的数字

00:30:53.787 --> 00:30:55.923
完成后
不要忘了

00:30:55.989 --> 00:30:58.992
释放为套接字地址
所创建的字符串

00:30:59.526 --> 00:31:00.494
这就好了

00:31:01.195 --> 00:31:02.329
下面来看看新方法

00:31:03.263 --> 00:31:07.601
简单地调出os_log_info
它可以帮你检查日志级别

00:31:07.935 --> 00:31:10.270
这种情况下
我传递默认的日志对象

00:31:11.305 --> 00:31:17.211
我在格式字符串里定义所给的参数
是一个uuid和一个套接字地址

00:31:17.277 --> 00:31:19.146
就不用再做转换

00:31:19.213 --> 00:31:22.816
现在我什么也不做
直到我们要显示它的时候

00:31:23.417 --> 00:31:26.086
然后我只要传递参数
就这么简单

00:31:35.896 --> 00:31:38.065
在我做示例的时候
让我多说一下

00:31:38.131 --> 00:31:40.200
使用其他API的例子

00:31:41.435 --> 00:31:46.874
这里我做了一个log_create
定义了一个子系统和分类

00:31:46.940 --> 00:31:49.209
子系统是
com.apple.logging.example

00:31:49.543 --> 00:31:53.313
分类就是普通分类
那么这就是我一般的日志对象

00:31:53.680 --> 00:31:57.484
我要做一样的事情 但这次
我创建了一个分类timestamp

00:31:59.553 --> 00:32:01.154
然后写个简单的调令

00:32:01.221 --> 00:32:05.893
调出os _log 使用general_log对象
传递字符串 日志完成

00:32:07.160 --> 00:32:09.196
这里有个更有趣的案例

00:32:09.263 --> 00:32:10.464
我调出os_log_info

00:32:10.531 --> 00:32:12.866
这之后会进入
内存缓冲区

00:32:12.933 --> 00:32:15.435
并只保存在
有故障和错误的时候

00:32:16.136 --> 00:32:21.074
在我的格式行里
我定义％（public ）s给filename

00:32:21.141 --> 00:32:23.343
因为filename
是个动态字符串

00:32:23.410 --> 00:32:25.979
所以我们假设
它是隐私信息

00:32:26.046 --> 00:32:27.781
除非你特别声明
它是公开的

00:32:28.649 --> 00:32:30.317
下面这是个
比较复杂的例子

00:32:30.384 --> 00:32:32.753
我打开一个文件
检查到一个错误

00:32:32.819 --> 00:32:36.256
如果它返回一个错误
我就调出os_log_error

00:32:36.890 --> 00:32:41.428
在我的格式行里就会声明
这个filename是公开信息

00:32:41.495 --> 00:32:44.898
我声明给格式
定义errno为errno

00:32:45.799 --> 00:32:49.736
这是另一个相似的例子
这一次我调出fstat

00:32:49.803 --> 00:32:52.906
但糟糕的是我调出的fstat
是在打开文件之后

00:32:52.973 --> 00:32:56.910
所以如果我收到报错
就可能有奇怪的问题出现

00:32:57.177 --> 00:33:00.013
因此我调出os_log_fault
同样类型的参数

00:33:01.582 --> 00:33:04.651
最后一步
就是调出os_log_info

00:33:04.818 --> 00:33:07.888
但是这一次
我传递timestamp日志对象

00:33:08.388 --> 00:33:11.692
然后基本上我会丢掉
这个文件的所有timestamp

00:33:11.758 --> 00:33:15.062
这就意味着
当我打开浏览Console的时候

00:33:16.096 --> 00:33:18.365
我可以简单地筛选
并说

00:33:18.432 --> 00:33:22.769
我只要看timestamp数据
或者我不想看timestamp数据

00:33:22.836 --> 00:33:24.404
因为我要看其他数据

00:33:26.106 --> 00:33:30.410
新的统一日志系统
不是此次发布的唯一改变

00:33:30.544 --> 00:33:33.514
我们还改进了
活动跟踪系统

00:33:34.314 --> 00:33:38.652
活动 是最优先
被保存和再利用的对象

00:33:39.853 --> 00:33:43.724
创建操作
让你能控制

00:33:43.790 --> 00:33:48.462
不同活动对象之间的关系
就在你创建它们的时候

00:33:49.630 --> 00:33:53.967
还有一些新的API
是观察你的代码活动

00:33:55.702 --> 00:33:56.837
改进的活动API

00:33:56.904 --> 00:33:59.373
这里就是
所有的新API

00:33:59.640 --> 00:34:04.878
这个新的os_activity_create
跟os_log_create一样

00:34:04.945 --> 00:34:08.581
都是创建一个日志对象
只是在识别一个活动的时候

00:34:10.184 --> 00:34:13.554
你可以使用两个调令
在你的代码上

00:34:13.620 --> 00:34:17.123
os_activity_scope
和os_activity_apply

00:34:17.190 --> 00:34:20.860
我一会儿让你们看几个例子
看看他们的运行有何不同

00:34:21.495 --> 00:34:26.600
最后就是os_activity_label_useraction
它将活动标记为

00:34:26.667 --> 00:34:29.770
基于UI的用户活动

00:34:31.103 --> 00:34:32.940
那我们用个例子
来说明

00:34:33.639 --> 00:34:37.878
首先调出os_activity_create
创建init活动

00:34:39.079 --> 00:34:41.281
注意这个函数的
第二个参数

00:34:41.348 --> 00:34:43.550
是常量
os_activity_current

00:34:43.617 --> 00:34:46.719
这就是说这个init活动是
附属于

00:34:46.786 --> 00:34:49.255
当前活动的
不论这个活动是什么

00:34:50.357 --> 00:34:54.228
现在我开始做os_activity_create
为验证活动

00:34:54.594 --> 00:34:57.898
但是第二个参数
是我刚建的init活动

00:34:57.965 --> 00:35:02.369
这样我就给这些活动
手动创建了一个层级结构

00:35:03.971 --> 00:35:05.772
现在我有了一个代码块

00:35:05.839 --> 00:35:09.176
准备好了
我大括号里还有一些代码

00:35:09.543 --> 00:35:12.713
第一件事就是调出
os_activity_scope

00:35:13.013 --> 00:35:15.482
然后传递
这个验证活动

00:35:15.949 --> 00:35:19.219
意思就是
这个代码块里的其他代码

00:35:19.286 --> 00:35:23.357
被认为是这个活动范围之内的
直到我点击结束括号

00:35:23.991 --> 00:35:28.428
不用再记得要在结束时
调出os_activity_end

00:35:28.495 --> 00:35:30.264
它会自动完成

00:35:30.898 --> 00:35:35.369
当你离开这个scope的时候
你就不再是这个活动的一部分了

00:35:36.737 --> 00:35:39.840
我们提供的另一调令是
os_activity_apply

00:35:40.507 --> 00:35:45.279
先传递活动对象
再传递这个代码块

00:35:45.345 --> 00:35:49.449
然后它就会运行这个代码块
并以这个活动为执行范围

00:35:51.018 --> 00:35:52.052
工具

00:35:52.786 --> 00:35:56.123
Matthieu已经为你们
展示了新的Console

00:35:56.190 --> 00:35:59.193
那么我就快速
过一下它的功能

00:36:00.127 --> 00:36:02.629
你可以浏览系统中
的活动内容

00:36:03.030 --> 00:36:04.831
可以打开日志档案

00:36:05.132 --> 00:36:08.802
可以使用新的日志检测
的活动中心视图

00:36:09.503 --> 00:36:11.872
你可以使用
高级的筛选和搜索

00:36:12.306 --> 00:36:14.775
还可以看到设备的日志

00:36:16.777 --> 00:36:20.314
现在我仔细讲讲
新的命令行工具

00:36:22.783 --> 00:36:25.819
它提供了跟Console
完全一样的功能

00:36:25.886 --> 00:36:27.120
但是是用命令行

00:36:27.588 --> 00:36:33.360
要想获取在线流式日志消息
只要写log stream

00:36:33.994 --> 00:36:35.229
如果要漂亮一点

00:36:35.295 --> 00:36:40.334
你可以写log stream
--predicate eventMessage contains my message

00:36:40.400 --> 00:36:43.437
它能做的就是
获取所有流式日志消息

00:36:43.504 --> 00:36:45.506
包括了my message字符串

00:36:47.040 --> 00:36:51.278
就跟Console一样
让你打开日志档案

00:36:51.512 --> 00:36:56.016
一个日志档案可以
通过日志命令显示

00:36:56.450 --> 00:36:59.152
你可以写log_show
然后给它文件名

00:36:59.486 --> 00:37:01.588
然后它就可以显示
这个日志文件的内容

00:37:03.524 --> 00:37:08.896
你可以在macOS做的另一件事
使用日志命令去更改

00:37:08.962 --> 00:37:11.798
你的子系统和分类的配置

00:37:12.065 --> 00:37:13.367
这里是个案例

00:37:13.433 --> 00:37:18.672
我写了
log_config --mode level:debug

00:37:18.739 --> 00:37:22.242
然后写-system com.mycorp.myapp

00:37:22.309 --> 00:37:24.845
这么做是为了能够记录

00:37:24.912 --> 00:37:28.348
这个子系统的日志
在你的macOS上

00:37:30.918 --> 00:37:32.219
即将推出

00:37:33.020 --> 00:37:39.626
我们很感谢你们
将使用iOS 10来开发你的应用

00:37:39.693 --> 00:37:45.399
但是请继续使用Mac上的macOS 10.11
即El Capitan

00:37:46.466 --> 00:37:52.339
让你能够通过El Capitan
访问新日志的工具马上就会推出

00:37:52.406 --> 00:37:55.042
但与此同时

00:37:57.878 --> 00:38:00.113
我们煞费苦心的
提供了一个变通方案

00:38:00.180 --> 00:38:04.017
能让你的新工具
在模拟器内部运行

00:38:04.384 --> 00:38:07.020
xcrun simctl spawn booted

00:38:07.087 --> 00:38:09.890
然后写
log show system logs.logarchive

00:38:09.957 --> 00:38:13.861
然后你就可以执行所有命令
跟往常一样

00:38:14.261 --> 00:38:16.196
另一种方法也再研究中

00:38:21.435 --> 00:38:25.239
那么我现在开始讲最佳操作
记录规则

00:38:27.140 --> 00:38:30.944
一定要保证你的消息里
只包含真正有用的信息

00:38:31.011 --> 00:38:35.215
不要有额外的空白字
或者填充数据

00:38:35.415 --> 00:38:36.550
要保持紧凑

00:38:38.752 --> 00:38:43.891
让我们利用内置格式化组件
去做格式转换

00:38:43.957 --> 00:38:47.828
你提前做的
字符串转换越多

00:38:47.895 --> 00:38:49.630
你的应用就显示得越慢

00:38:49.696 --> 00:38:53.967
相比之下
输出的时候再转换就好很多

00:38:55.402 --> 00:38:58.772
避免将日志API
包含于其他函数

00:38:59.039 --> 00:39:01.375
如果你把它
包在其他函数里

00:39:01.441 --> 00:39:06.046
你就无法
收集文件和行数

00:39:07.114 --> 00:39:10.450
如果你必须要
包装我们的API

00:39:10.517 --> 00:39:13.086
那么把它们包在宏命令里
不要包在函数里

00:39:14.254 --> 00:39:17.791
只从字典和档案里
记录所需要的内容

00:39:17.858 --> 00:39:20.260
这里说的字典是指
字典和数组

00:39:21.261 --> 00:39:22.796
它们占用了
磁盘上很多的空间

00:39:22.863 --> 00:39:26.633
也就是说他们会挤掉
其他人们需要的日志消息

00:39:26.934 --> 00:39:31.438
尽可能的只记录
你日志所真正需要的部分

00:39:32.973 --> 00:39:36.710
还要避免记录到
紧凑代码循环里

00:39:38.579 --> 00:39:42.482
简单说一下我们心目中
这些新API的最佳用途

00:39:43.050 --> 00:39:49.223
Os_log是记录
日志信息的基本细节

00:39:49.289 --> 00:39:51.458
这个信息类型
可能正是你需要的

00:39:51.525 --> 00:39:54.228
能在几个小时前
帮你调试问题

00:39:55.362 --> 00:39:59.533
使用os_log_info
去获取额外的即时信息

00:39:59.900 --> 00:40:02.970
这个首先要用于
很快就会过期的信息

00:40:03.770 --> 00:40:07.674
使用os_log_debug
来处理开发过程中大量的调试工作

00:40:08.575 --> 00:40:12.446
错误出现在
你需要收集额外信息

00:40:12.513 --> 00:40:13.914
并为你的应用保留的情况下

00:40:14.648 --> 00:40:16.783
故障是指你想要收集额外的

00:40:16.850 --> 00:40:19.052
有关系统的信息

00:40:20.921 --> 00:40:23.724
简单来讲讲
日志收集

00:40:24.925 --> 00:40:29.062
我们推荐Sysdiagnose
来捕捉有关故障报告的数据

00:40:29.129 --> 00:40:30.264
使用sysdiagnose

00:40:30.330 --> 00:40:35.302
如果你使用sysdiagnose
我刚刚描述的系统里的日志数据

00:40:35.369 --> 00:40:39.640
就会出现在档案里
文件名是system logs.archive

00:40:41.642 --> 00:40:44.745
可使用key-chords
来激活sysdiagnose

00:40:45.112 --> 00:40:47.214
如果在Apple watch上

00:40:47.281 --> 00:40:49.883
它不仅会在手表上激活
也会在与之匹配的手机上激活

00:40:50.951 --> 00:40:54.154
然后你可以用iTunes
转移这个档案

00:40:54.221 --> 00:40:57.424
给你的Mac
来进行操作

00:40:58.325 --> 00:41:02.462
这个文件就是
Apple想要为你提供的

00:41:02.529 --> 00:41:04.498
解决你给我们提出的问题

00:41:04.565 --> 00:41:06.333
所以你可以把它附在雷达上

00:41:06.400 --> 00:41:08.669
也可以发送给
开发者技术支持

00:41:11.271 --> 00:41:13.273
这就是各种key-chords

00:41:13.574 --> 00:41:16.410
Shift + Control + Option
+ Command + Period （. ） 对Mac OS

00:41:16.710 --> 00:41:19.880
Volume up + Volume Down
+ Power 对iOS

00:41:20.547 --> 00:41:23.784
手机上会产生轻微震动
iPad不会

00:41:24.184 --> 00:41:28.889
在watchOS上
长按电子表冠和边键一整秒

00:41:29.223 --> 00:41:32.125
如果按的时间不够长
你就只获得一个截屏

00:41:32.593 --> 00:41:39.132
启动的时候
会有轻微的触摸震动

00:41:40.667 --> 00:41:43.370
Play/Pause + Volume Down
在tvOS上

00:41:43.504 --> 00:41:46.573
注意以前的
Apple TV遥控器

00:41:46.773 --> 00:41:49.443
得按五秒钟才能激活

00:41:50.544 --> 00:41:51.411
弃用

00:41:52.412 --> 00:41:56.950
这一部分
我们要对一些API说再见了

00:41:58.585 --> 00:42:03.056
首先就是所有的ASL日志API
现在已经被这些新的API所替代了

00:42:03.123 --> 00:42:05.559
所以这些旧的API就被弃用了

00:42:06.226 --> 00:42:08.161
但这里还有
一个有趣的极端情况

00:42:08.462 --> 00:42:13.433
搜索日志数据的新API
在这一版本不会被公布

00:42:13.500 --> 00:42:17.304
意思就是
现在没有能替代asl搜索功能的工具

00:42:17.804 --> 00:42:21.441
如果你的系统
完全依赖asl搜索

00:42:21.775 --> 00:42:25.479
那就得等着使用
新的日志系统了

00:42:29.149 --> 00:42:33.187
还有一些活动API
也会被弃用

00:42:33.720 --> 00:42:38.458
现在不用再写os_activity_start
和os_activity_end

00:42:38.525 --> 00:42:42.162
而是像我展示的那样
写os_activity_create就可以

00:42:42.229 --> 00:42:45.832
然后调出scope或者apply
来应用到代码块

00:42:46.200 --> 00:42:50.704
Os_activity_breadcrumb已经被
os_activity_user_label代替

00:42:51.004 --> 00:42:55.542
Os_trace_with_payload也换成了
任意os_log调令

00:42:56.276 --> 00:42:59.313
注意这些函数
在这一版本里以没有ops

00:42:59.379 --> 00:43:02.082
所以如果你继续调用它们
它们也不会进行任何操作

00:43:03.317 --> 00:43:04.284
总的来说

00:43:05.085 --> 00:43:10.724
新的日志系统更快也更简单
也给你更多的控制力

00:43:10.791 --> 00:43:13.727
但它的确要使用
新的API和新工具

00:43:14.595 --> 00:43:16.129
相关演讲

00:43:16.196 --> 00:43:20.234
我提到了几次
在2014年发布的“活动追踪”

00:43:20.300 --> 00:43:22.603
这个演讲
讲的就是这个内容

00:43:22.669 --> 00:43:24.371
所以如果你想回顾一下

00:43:24.872 --> 00:43:29.009
或者想了解更多有关这个演讲的信息
请登陆这个URL

00:43:29.343 --> 00:43:30.410
谢谢大家