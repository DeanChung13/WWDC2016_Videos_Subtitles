00:00:19.486 --> 00:00:23.757
线程检查工具
和静态分析

00:00:23.824 --> 00:00:28.829
帮助你在代码中查找错误

00:00:31.765 --> 00:00:32.833
大家好 我是Anna

00:00:32.900 --> 00:00:35.869
欢迎来到线程检查工具
和静态分析演讲

00:00:36.937 --> 00:00:39.606
由于我们的团队
从事于错误寻找工具

00:00:39.673 --> 00:00:43.377
我们将告诉你
找出错误的新方法

00:00:44.044 --> 00:00:47.614
我开始会简要概述一下
地址检查工具

00:00:47.681 --> 00:00:50.484
然后更加深入到
线程检查工具

00:00:50.551 --> 00:00:52.953
这是我们今年推出的新功能

00:00:53.554 --> 00:00:56.456
之后 Devin会上台
给大家讲讲新的检查

00:00:56.523 --> 00:00:58.759
我们添加到
Clang静态分析器上

00:00:59.893 --> 00:01:00.727
开始吧

00:01:01.895 --> 00:01:07.601
检查工具是LEM工具的一个家族
组合编译时间检测工具

00:01:07.835 --> 00:01:11.405
和运行时监控
在运行时寻找错误

00:01:11.772 --> 00:01:13.407
它们与Valgrind相似

00:01:13.540 --> 00:01:17.377
然而 它们的主要优点
是有低的运行时开销

00:01:18.178 --> 00:01:20.314
兼容Swift
和Objective-C

00:01:20.514 --> 00:01:23.317
而且紧密集成于
Xcode UI

00:01:24.651 --> 00:01:28.555
去年我们在macOS和iOS上
推出了地址检查工具

00:01:29.056 --> 00:01:33.694
这个工具能找出内存崩溃
例如栈堆缓冲区溢出

00:01:33.760 --> 00:01:35.762
用后死机 双重死机

00:01:36.530 --> 00:01:39.499
在寻找内存问题上
极为有效

00:01:39.566 --> 00:01:43.470
所以如果你还没使用
我极力推荐它

00:01:44.304 --> 00:01:47.975
今年我们扩展这个工具
给Swift提供全面支持

00:01:48.609 --> 00:01:51.044
这会是令人激动的消息
对于那些

00:01:51.144 --> 00:01:53.780
喜欢在Swift中
不走寻常路的人

00:01:55.148 --> 00:01:58.452
所以这意味着什么
如果你使用不安全指针类型？

00:01:58.752 --> 00:02:03.056
在地址检查工具开启时
进行测试 它会为你找出错误

00:02:04.491 --> 00:02:08.829
地址检查工具
虽然主要注重于内存崩溃问题

00:02:08.895 --> 00:02:11.965
这里还有一个大的错误来源
那就是线程问题

00:02:12.933 --> 00:02:15.135
这些更加难以重现并调试

00:02:15.469 --> 00:02:16.970
对时机很敏感

00:02:17.171 --> 00:02:20.174
它们可能只会在
某些情况下出现

00:02:20.440 --> 00:02:23.577
这意味着
包含它们的应用程序

00:02:23.644 --> 00:02:25.746
会有难以预测的行为

00:02:26.213 --> 00:02:30.284
所以今年我们推出另一个工具的支持
线程检查工具

00:02:30.918 --> 00:02:32.819
这会有助于你找到

00:02:33.020 --> 00:02:35.756
并更好理解
你的线程错误

00:02:37.124 --> 00:02:39.126
TSan报告很多
不同类型的错误

00:02:39.193 --> 00:02:40.894
我们来看一些错误

00:02:41.228 --> 00:02:44.064
我会告诉你关于
未初始化互斥体的使用

00:02:44.531 --> 00:02:46.166
这可能看起来
没什么大不了

00:02:46.400 --> 00:02:49.736
然而 如果你使用
未经恰当初始化的互斥体

00:02:49.870 --> 00:02:52.372
这会在你的应用程序中
导致非常细微的错误

00:02:52.439 --> 00:02:55.509
因为实际上
你没有实现任何互相排斥

00:02:55.576 --> 00:02:56.977
当你使用那样互斥体

00:02:57.411 --> 00:02:59.446
另一个例子是线程泄露

00:02:59.713 --> 00:03:01.682
如果你的应用程序
拥有很多线程

00:03:01.748 --> 00:03:03.383
如果那些线程泄露了

00:03:03.984 --> 00:03:06.186
这就会导致内存泄漏

00:03:06.687 --> 00:03:09.089
另一个是信号处理器中的
不安全调用

00:03:09.156 --> 00:03:11.058
以及从错误线程中解锁

00:03:11.325 --> 00:03:15.028
然而 数据竞争
是目前最常见的问题

00:03:15.295 --> 00:03:17.397
因为它们非常易于引发

00:03:17.898 --> 00:03:21.468
当多个线程访问相同
内存位置时就会发生

00:03:21.768 --> 00:03:24.004
没有使用恰当的同步

00:03:25.005 --> 00:03:26.874
我们看看该工具
是如何工作的

00:03:26.940 --> 00:03:29.109
通过进入Xcode演示

00:03:39.419 --> 00:03:42.689
这里我将演示
线程检查工具

00:03:42.756 --> 00:03:45.859
在去年Alpha版的
WWDC应用上

00:03:46.393 --> 00:03:49.329
所以如你所料
这里显示出了一周的安排

00:03:49.863 --> 00:03:51.965
不过 注意这个
有趣的视觉错误

00:03:52.032 --> 00:03:54.735
即使所有会话的数据
已下载完成

00:03:54.968 --> 00:03:57.171
网络活动指示器
还是在转动

00:03:58.238 --> 00:04:00.374
我知道我使用
全局变量来决定

00:04:00.440 --> 00:04:03.744
何时显示或隐藏这个指示器
所以这里可能有线程问题

00:04:03.810 --> 00:04:06.380
我们看看线程检查工具
能否帮我们找到

00:04:07.381 --> 00:04:10.517
为启用线程检查工具
我们选择编辑方案

00:04:11.585 --> 00:04:13.287
现在Diagnostics选项卡

00:04:13.820 --> 00:04:16.055
点击这里启用
线程检查工具

00:04:16.990 --> 00:04:19.993
现在你可以选择
每当遇到一个问题时

00:04:20.060 --> 00:04:23.063
就暂停调试器
并就地调试那个问题

00:04:23.530 --> 00:04:25.332
或者你可以选择保持运行

00:04:25.399 --> 00:04:28.235
收集线程检查工具
报告的所有线程问题

00:04:28.302 --> 00:04:29.469
之后再探究它们

00:04:30.003 --> 00:04:33.707
Xcode 8第二个工作流程是新的
只有线程检查工具支持

00:04:33.774 --> 00:04:35.809
我们看看其工作原理

00:04:37.444 --> 00:04:40.147
当你在线程检查工具下
启动应用程序

00:04:40.347 --> 00:04:44.084
Xcode会通过额外的
编译器工具重建你的项目

00:04:44.518 --> 00:04:46.653
然后会在特殊模式中启动它

00:04:46.720 --> 00:04:48.722
尝试找到线程问题

00:04:49.256 --> 00:04:51.358
这里我们的应用程序启动了

00:04:51.658 --> 00:04:54.494
Xcode告诉我们线程检查工具
检测到两个问题

00:04:54.561 --> 00:04:58.031
并在活动查看器中显示了
这个紫色的指示器

00:04:59.032 --> 00:05:01.034
点击这个紫色指示器

00:05:01.401 --> 00:05:03.136
会将我们带到
问题导航器

00:05:03.437 --> 00:05:05.172
之前我们只是用它

00:05:05.239 --> 00:05:07.608
显示构建时间问题
例如编译器警告

00:05:07.674 --> 00:05:09.776
编译器错误
静态分析器问题

00:05:09.843 --> 00:05:12.779
今年扩展支持了
运行时问题

00:05:12.846 --> 00:05:15.849
这样线程检查工具
的问题就能找到根源

00:05:16.783 --> 00:05:20.053
线程检查工具报告了两个问题
我们一个个看

00:05:20.120 --> 00:05:23.123
第一个是使用了
未初始化互斥体

00:05:24.091 --> 00:05:27.928
这个问题在之前运行
应用程序的某个时候出现的

00:05:28.295 --> 00:05:31.431
线程检查工具
会告诉我们确切的时间

00:05:31.498 --> 00:05:33.834
通过提供历史堆栈跟踪

00:05:34.301 --> 00:05:36.336
即使这不是即时堆栈跟踪

00:05:36.403 --> 00:05:39.606
你可以把它当做即时
堆栈跟踪 一帧一帧查看

00:05:39.706 --> 00:05:40.707
我们来看看

00:05:40.774 --> 00:05:42.976
某时刻
我们调用了acquireLock

00:05:43.043 --> 00:05:46.613
这调用了pthread_mutex_lock
然后传递了无效的互斥体引用

00:05:47.114 --> 00:05:50.551
这是调用自resetFeedStatus
而它又是调用自初始化器

00:05:51.485 --> 00:05:53.820
这里如你所见
我们确实初始化了互斥体

00:05:53.921 --> 00:05:55.889
不过是在使用之后
才初始化的

00:05:56.023 --> 00:05:57.491
这是简单的排序错误

00:05:58.025 --> 00:06:00.961
所以重新给这两个陈述排序
就应该解决好了

00:06:01.195 --> 00:06:05.199
好了 我们来看看第二个问题
那就是数据竞争

00:06:06.433 --> 00:06:09.036
线程检查工具
告诉我们出现数据竞争

00:06:09.102 --> 00:06:11.004
在叫做活动计数的变量上

00:06:11.071 --> 00:06:14.341
这是相同的全局变量
用来决定

00:06:14.408 --> 00:06:16.476
何时显示或隐藏指示器的

00:06:17.344 --> 00:06:21.381
因为这是数据竞争
线程检查工具会告诉我们两个事件

00:06:21.582 --> 00:06:23.617
两个竞争访问

00:06:23.684 --> 00:06:25.118
一个读取和一个写入

00:06:25.452 --> 00:06:27.187
所以线程11上出现读取

00:06:27.254 --> 00:06:29.256
而线程13上出现写入

00:06:29.857 --> 00:06:32.326
注意这两个都不是主线程

00:06:32.893 --> 00:06:34.428
而且堆栈跟踪是一样的

00:06:34.494 --> 00:06:37.297
这意味着它们可能
通过多个线程

00:06:37.598 --> 00:06:40.467
在相同的线上执行
并且没有使用同步

00:06:40.701 --> 00:06:41.635
我们来看看

00:06:42.169 --> 00:06:45.372
好了 我们在更新
活动计数变量

00:06:46.139 --> 00:06:49.009
现在我可以通过添加锁
来修复这个竞争

00:06:49.409 --> 00:06:51.578
不过注意这只是症状

00:06:52.312 --> 00:06:54.882
这里的下一行更新UI

00:06:55.983 --> 00:06:59.052
我们知道UI更新
应该发生在主线程上

00:06:59.419 --> 00:07:01.989
所以合适的修复是将

00:07:02.456 --> 00:07:06.293
counter-increment
和UI更新分派到

00:07:06.560 --> 00:07:10.764
Grand Central Dispatch
的主队列上

00:07:11.965 --> 00:07:15.202
这既会解决
我们应用程序的逻辑问题

00:07:15.269 --> 00:07:18.539
也会解决竞争
因为所有的线程会从

00:07:20.174 --> 00:07:22.242
相同的线程上
访问计数变量

00:07:22.743 --> 00:07:25.579
我确定
我说得十分有说服力

00:07:25.646 --> 00:07:27.814
而且你们都相信
我将错误修复好了

00:07:28.048 --> 00:07:30.450
然而 最好的自行检查方式

00:07:30.517 --> 00:07:33.253
就是在你的项目上
再次运行这个工具

00:07:33.921 --> 00:07:38.525
所以我们应该在线程检查工具
启用的情况下重新运行应用程序

00:07:38.592 --> 00:07:40.594
这会再次重建你的项目

00:07:40.661 --> 00:07:43.897
带有这个额外检查
而且在特殊模式中启动

00:07:44.731 --> 00:07:46.400
现在应用程序启动了

00:07:46.800 --> 00:07:50.103
我们看到奇怪的
视觉UI错误消失了

00:07:50.170 --> 00:07:52.406
而且线程检查工具
没有报告任何问题

00:07:52.840 --> 00:07:53.907
一切正常

00:07:54.274 --> 00:07:56.844
我们回到幻灯片

00:08:05.819 --> 00:08:07.654
我们回顾一下演示

00:08:08.288 --> 00:08:10.691
在方案编辑器中启用
线程检查工具

00:08:10.757 --> 00:08:14.528
当你进入诊断选项卡
跟地址检查工具的做法一样

00:08:14.728 --> 00:08:19.166
除了拥有在出现第一个问题时
暂停调试器的ASan工作流程之外

00:08:19.399 --> 00:08:21.802
线程检查工具
支持另一种模式

00:08:21.969 --> 00:08:24.471
你可以在检测问题的
过程中保持运行

00:08:24.538 --> 00:08:27.040
之后你可以在
问题导航器中探究它们

00:08:27.207 --> 00:08:29.877
在你重启应用程序之前
它们会留在那里

00:08:30.944 --> 00:08:33.947
我们来谈谈Xcode
在后台发挥了什么作用

00:08:34.014 --> 00:08:35.649
来让这一切奏效

00:08:36.316 --> 00:08:39.520
为了使用线程检查工具
Xcode将特殊标记传递给

00:08:39.586 --> 00:08:41.822
Clang和Swift编译器

00:08:42.289 --> 00:08:44.925
命令它们生成
被检测二进制文件

00:08:45.993 --> 00:08:48.929
这个二进制文件链接到
TSan运行时间库

00:08:49.329 --> 00:08:51.832
由检测工具使用来

00:08:51.965 --> 00:08:55.302
监控程序的执行
并检测那些线程问题

00:08:55.936 --> 00:08:58.805
所以如果你从命令行
进行构建和运行

00:08:58.872 --> 00:09:01.942
你可以将选项
传递给任何一个编译器

00:09:02.876 --> 00:09:04.978
而且xcodebuild还会支持
线程检查工具

00:09:05.045 --> 00:09:07.381
通过提供
enableThreadSanitizer选项

00:09:08.282 --> 00:09:11.818
默认情况下 TSan会在
检测错误的过程中持续运行

00:09:12.319 --> 00:09:15.756
不过你可以命令它
在遇到第一个问题时就中止

00:09:15.956 --> 00:09:18.492
通过将TSan选项
环境变量设置成

00:09:18.559 --> 00:09:21.562
在启动过程的时候
当halt_on_error=1时中止

00:09:21.828 --> 00:09:25.832
这会允许你有相同的工作流
与地址检查工具是一样

00:09:27.968 --> 00:09:29.403
在哪里可以使用这个工具？

00:09:29.503 --> 00:09:31.705
线程检查工具
在macOS上有支持

00:09:31.772 --> 00:09:33.640
以及64位的模拟器

00:09:33.841 --> 00:09:36.109
并不在设备上支持

00:09:37.344 --> 00:09:40.480
现在你知道如何使用该工具
如何启动 如果寻找问题

00:09:40.547 --> 00:09:43.750
我们来谈谈
如何修复报告中的错误

00:09:44.117 --> 00:09:45.986
我们主要注重于数据竞争

00:09:46.053 --> 00:09:49.423
因为这是所报告的
错误中最多的类型

00:09:50.224 --> 00:09:51.825
什么是数据竞争？

00:09:52.159 --> 00:09:54.328
数据竞争发生于
当多个线程

00:09:54.995 --> 00:09:56.997
访问相同的内存位置

00:09:57.064 --> 00:09:59.233
没有使用恰当的同步

00:09:59.733 --> 00:10:02.703
而且至少一个访问是写入

00:10:03.971 --> 00:10:08.642
这里的问题是
你最后可能不止得到过期数据

00:10:08.942 --> 00:10:10.944
而且行为是无法预测的

00:10:11.011 --> 00:10:13.380
你最后甚至可能遇到内存崩溃

00:10:14.281 --> 00:10:16.550
所以数据竞争的原因是什么？

00:10:16.717 --> 00:10:19.419
这通常表明
你遇到了逻辑问题

00:10:19.853 --> 00:10:22.389
在你程序的结构中

00:10:22.556 --> 00:10:24.424
而且只有你知道如何修复

00:10:25.125 --> 00:10:28.195
另一方面 这还意味着
缺失一些同步

00:10:28.262 --> 00:10:30.797
我们来谈谈第二种情景

00:10:31.965 --> 00:10:34.368
这是一个Swift中
数据竞争的例子

00:10:34.668 --> 00:10:36.270
我们有全局变量数据

00:10:36.703 --> 00:10:38.839
我们有一个生产者
设置成42

00:10:38.906 --> 00:10:41.141
以及一个打印它的消费者

00:10:42.009 --> 00:10:44.244
如果执行这两段代码

00:10:44.511 --> 00:10:46.947
通过两个不同的线程
这就会出现数据竞争

00:10:48.182 --> 00:10:49.283
那这个代码怎么样？

00:10:49.650 --> 00:10:52.886
我们引入了另一个变量
叫做isDataAvailable

00:10:53.287 --> 00:10:57.024
数据在生产者中更新后
我们设置那个标记

00:10:57.291 --> 00:10:59.826
而在消费者中我们要等待
直到标记设置完成

00:10:59.893 --> 00:11:01.929
如果一旦设置好
我们打印数据

00:11:02.362 --> 00:11:04.464
这看起来很有逻辑

00:11:04.598 --> 00:11:05.999
看起来应该会奏效

00:11:06.600 --> 00:11:10.070
问题是你看到的东西
不会得到执行

00:11:11.238 --> 00:11:14.808
这里的指令可以被
任一个编译器重新排序

00:11:14.875 --> 00:11:18.045
或者CPU 所以你不能
假设标记是在

00:11:18.111 --> 00:11:20.314
数据更新之后设置

00:11:20.848 --> 00:11:23.617
指令的顺序无法保证

00:11:23.684 --> 00:11:25.319
在生产者和
消费者中都一样

00:11:26.687 --> 00:11:28.422
所以这张幻灯片的意义何在？

00:11:28.488 --> 00:11:30.724
我只是想演示

00:11:31.058 --> 00:11:34.428
试着推出自己的同步方法

00:11:34.628 --> 00:11:36.597
通常是不好的想法

00:11:37.030 --> 00:11:38.198
那应该怎么做？

00:11:38.465 --> 00:11:40.868
我们应该使用
已经可用的东西

00:11:41.201 --> 00:11:43.537
例如
Grand Central Dispatch

00:11:43.770 --> 00:11:47.007
是一个非常好的选项
你可以将最近访问

00:11:47.407 --> 00:11:49.543
分配到相同的串行队列

00:11:49.943 --> 00:11:52.613
这会确保它们在
相同的线程上执行

00:11:52.679 --> 00:11:54.147
而且没有数据竞争

00:11:55.382 --> 00:11:59.486
现你可能想起线程检查工具
适用于Objective-C和Swift

00:11:59.653 --> 00:12:02.089
我们使用Objective-C
作为下一个例子

00:12:03.557 --> 00:12:05.459
这是惰性初始化代码

00:12:05.759 --> 00:12:09.196
我们的实现方法
叫做getSingleton

00:12:09.496 --> 00:12:13.467
确保我们将相同的共享实例
返回到其所有的调用者

00:12:14.968 --> 00:12:17.738
如果这个代码
由多个线程执行

00:12:18.071 --> 00:12:20.741
没有适当的同步
这就会出现数据竞争

00:12:21.074 --> 00:12:24.878
当两个线程都尝试
更新共享实例变量

00:12:26.146 --> 00:12:27.881
好了 那这个代码呢？

00:12:28.348 --> 00:12:31.485
我们尝试修复这个问题
通过分配

00:12:31.552 --> 00:12:33.487
并初始化本地变量

00:12:33.921 --> 00:12:37.024
之后我们使用
atomic_compare_and_set操作

00:12:37.090 --> 00:12:41.962
来确保线程会原子级地
更新那个全局变量

00:12:42.062 --> 00:12:44.565
所以在右边
不会有数据竞争

00:12:45.566 --> 00:12:47.301
这看起来像是踏入正轨

00:12:47.367 --> 00:12:48.902
不过这个代码还有问题

00:12:49.336 --> 00:12:50.637
我们来看看它们

00:12:50.771 --> 00:12:54.441
首先 这会非常难以
推断出内存管理

00:12:54.541 --> 00:12:56.143
当你使用原子

00:12:56.543 --> 00:12:59.813
例如 如果你使用ARC
这里你会遇到use-after-free

00:13:00.681 --> 00:13:02.783
如果你使用MRR

00:13:03.083 --> 00:13:06.420
这个对象只有在
竞争出现时泄露

00:13:07.054 --> 00:13:09.122
这不是好事

00:13:09.223 --> 00:13:10.357
问题不只这一个

00:13:10.424 --> 00:13:14.628
另一个问题是
因为读取是非同步的

00:13:14.895 --> 00:13:17.030
这里还是会出现竞争
如果一个线程尝试

00:13:17.097 --> 00:13:18.699
读取那个共享变量

00:13:18.765 --> 00:13:21.802
而另一个尝试
原子级地设置它

00:13:22.503 --> 00:13:25.305
所以这是未定义行为
这不好

00:13:26.039 --> 00:13:27.274
那你应该怎么做？

00:13:27.341 --> 00:13:30.444
如果你已经知道解决方案了
使用Grand Central Dispatch

00:13:30.511 --> 00:13:34.081
这会替你进行
惰性初始化设置

00:13:35.282 --> 00:13:36.850
这在Swift中更加容易

00:13:37.251 --> 00:13:41.855
全局变量和类型常量
都分派了一个语义

00:13:42.122 --> 00:13:43.924
你能选择两者任意
一个解决方案

00:13:43.991 --> 00:13:45.792
对你的代码有最有效的那个

00:13:47.561 --> 00:13:49.196
好了 总结一下

00:13:49.263 --> 00:13:52.366
你应该使用适合
你需求的最高级别API

00:13:52.900 --> 00:13:55.936
大多数人应该使用Grand
Central Dispatch

00:13:56.069 --> 00:13:59.940
如果这不适合
你可以使用pthread API

00:14:00.240 --> 00:14:01.775
或者比如NSLock

00:14:03.343 --> 00:14:07.781
我们新os_unfair_lock
是今年在我们平台上新出的

00:14:07.848 --> 00:14:09.716
它代替了OSSpinLock

00:14:09.950 --> 00:14:12.553
我们还有
C++和C11 Atomics

00:14:13.120 --> 00:14:15.255
线程检查工具支持它们

00:14:15.355 --> 00:14:19.226
你在之前的例子中看过了
它们非常难以正确地使用

00:14:20.093 --> 00:14:21.495
除了性能之外

00:14:21.562 --> 00:14:25.265
这要么是不可测量的
或者是可以忽略的

00:14:25.699 --> 00:14:29.870
所以不要选择使用那些API
如果你不去测量

00:14:29.937 --> 00:14:32.873
它们确实在你的
应用程序上有一些东西

00:14:34.408 --> 00:14:36.844
所以关于更多这些API的信息

00:14:36.910 --> 00:14:40.547
请参加
周五的并发程序设计演讲

00:14:42.216 --> 00:14:44.618
现在我们来谈谈良性竞争

00:14:44.918 --> 00:14:45.953
这是什么？

00:14:46.019 --> 00:14:48.689
一些开发者主张
在一些架构上

00:14:48.956 --> 00:14:50.457
例如x86

00:14:50.858 --> 00:14:54.328
你不需要在读取和
写入之间插入同步

00:14:54.828 --> 00:14:57.798
因为架构本身就保证了自动

00:14:57.865 --> 00:15:00.534
指针大小数据的操作

00:15:01.802 --> 00:15:05.539
要记住的重要一点是
任何竞争 即使是良性竞争

00:15:05.606 --> 00:15:09.676
在C或C++标准中
被视为未定义的行为

00:15:10.377 --> 00:15:14.781
所以你不仅会惊奇地发现
带有良性竞争的代码运行在

00:15:14.848 --> 00:15:17.684
你之前没有完全测试好的架构上

00:15:18.118 --> 00:15:21.421
而且编译器可以自由
给那些指令重新排序

00:15:21.488 --> 00:15:23.724
跟没有其他线程看到一样

00:15:24.958 --> 00:15:28.328
所以最后你可能
会遇到非常细微的错误

00:15:28.695 --> 00:15:35.068
正如我们的线程检查工具
工程主管所说：“修复所有错误”

00:15:43.277 --> 00:15:46.013
现在到我们演讲
最精彩的部分了

00:15:46.580 --> 00:15:49.716
我们都知道数据竞争
很难重现 因为它们

00:15:49.783 --> 00:15:51.051
对时机非常敏感

00:15:51.652 --> 00:15:55.222
线程检查工具
最有趣的一点是它可以检测

00:15:55.289 --> 00:15:58.192
那些在特定程序运行
过程中未显现的竞争

00:15:58.825 --> 00:16:00.260
来看看它是怎么做到的

00:16:01.295 --> 00:16:04.031
当你用线程检查工具
编译你的程序

00:16:04.231 --> 00:16:06.300
它会检测每个内存访问

00:16:06.366 --> 00:16:09.369
然后在上面加上标记前缀
使用引号

00:16:09.636 --> 00:16:13.273
不过首先
记录关于访问的信息

00:16:14.341 --> 00:16:19.680
第二 检查那个
访问是否参与竞争

00:16:20.347 --> 00:16:21.715
我们来深入看看

00:16:22.683 --> 00:16:25.319
对于每个对齐的
8字节应用程序内存

00:16:25.919 --> 00:16:30.791
线程检查工具的影子状态
会最多记录4个访问

00:16:31.425 --> 00:16:33.126
假设你有4个线程

00:16:33.360 --> 00:16:35.229
线程1写入到那个内存位置

00:16:35.495 --> 00:16:38.165
线程检查工具更新它
将信息存储在

00:16:38.232 --> 00:16:40.434
影子线程
来重置内存位置

00:16:40.701 --> 00:16:43.871
我们还是会记录
我们持续不断做下去

00:16:44.338 --> 00:16:47.841
现在如果你有
4个以上的访问怎么办？

00:16:50.377 --> 00:16:52.880
线程检查工具
使用有根据的推测

00:16:52.946 --> 00:16:55.816
决定接下来
将哪个单元格驱逐掉

00:16:55.883 --> 00:16:59.052
这里它驱逐了
相同线程的访问

00:16:59.887 --> 00:17:01.855
这不会使其失去精度

00:17:03.090 --> 00:17:05.325
然而 如果我们有
第五个访问

00:17:05.392 --> 00:17:07.426
这会驱逐一个随机单元格

00:17:07.994 --> 00:17:10.797
所以像这样限制
访问的数量意味着

00:17:10.864 --> 00:17:13.500
我们可能不会在
所有案例中遇到所有竞争

00:17:14.902 --> 00:17:18.839
好了 现在我们谈谈
它是如何检测数据竞争的

00:17:19.339 --> 00:17:21.208
线程检查工具
使用众所周知的方法

00:17:21.275 --> 00:17:23.377
用向量时钟检查竞争

00:17:24.178 --> 00:17:25.345
这如何起作用的？

00:17:25.878 --> 00:17:27.580
每个线程有线程本地存储

00:17:27.915 --> 00:17:30.651
记录线程自身的计数器

00:17:31.885 --> 00:17:34.955
以及其他所有线程的计数器

00:17:35.822 --> 00:17:37.991
这个计数器初始化为0

00:17:38.225 --> 00:17:40.627
每次有线程访问内存

00:17:41.195 --> 00:17:42.896
计数器就会增加

00:17:43.497 --> 00:17:48.836
例如 线程1访问了
2个内存位置

00:17:49.236 --> 00:17:52.039
线程2访问了
22个内存位置

00:17:52.906 --> 00:17:55.342
线程3访问了
55个内存位置

00:17:56.343 --> 00:17:58.712
这个时间戳
是没有可比性的

00:17:59.413 --> 00:18:02.182
每个线程使用这些
时间戳或者计数器

00:18:02.249 --> 00:18:06.253
来给其进行的内存访问排序

00:18:07.955 --> 00:18:10.090
好了 我们回来

00:18:10.824 --> 00:18:13.727
将内存位置带回来

00:18:13.794 --> 00:18:17.598
及其影子
看看线程是如何交互的

00:18:17.664 --> 00:18:19.333
以及它们如何
更新这里的计数器

00:18:19.900 --> 00:18:21.802
我们还会加入锁
线程使用它

00:18:21.869 --> 00:18:24.071
来同步内存位置的访问

00:18:24.838 --> 00:18:26.473
好了 线程1写入

00:18:27.174 --> 00:18:29.810
这是行为良好的线程
它会获取那个锁

00:18:30.577 --> 00:18:32.279
它会更新其计数器

00:18:33.146 --> 00:18:35.182
它会写入到那个内存位置中

00:18:35.749 --> 00:18:37.784
线程检查工具
现在看到它了

00:18:38.151 --> 00:18:39.887
它会更新影子

00:18:40.721 --> 00:18:44.057
在更新影子之前
它看到影子中什么都没有

00:18:44.124 --> 00:18:46.226
没保存到影子中
意味着

00:18:46.460 --> 00:18:49.763
内存位置之前未被访问

00:18:50.264 --> 00:18:52.299
所以可以安全地写入进去

00:18:53.734 --> 00:18:56.770
在释放锁之前
线程1会在上面

00:18:56.904 --> 00:18:58.805
更新有自己的时间戳

00:18:59.706 --> 00:19:01.074
然后释放那个锁

00:19:01.575 --> 00:19:04.278
现在该线程2去写入了

00:19:05.012 --> 00:19:08.448
线程2也是行为非常良好
的线程 它会获取那个锁

00:19:09.550 --> 00:19:13.287
像这样获取锁
会让线程2看到

00:19:13.353 --> 00:19:16.123
线程1的计数器已经增加了

00:19:18.192 --> 00:19:20.194
线程2增加其自身的计数器

00:19:20.260 --> 00:19:22.296
写入到那个内存位置中

00:19:22.629 --> 00:19:25.332
线程检查工具
看到它想要更新影子

00:19:26.033 --> 00:19:28.969
它在这里看到
之前有东西进入影子里了

00:19:29.036 --> 00:19:31.839
这意味着那个内存位置
已经被访问了

00:19:31.905 --> 00:19:33.574
所以就会检查是否有竞争

00:19:36.009 --> 00:19:38.178
通过对比时间戳

00:19:38.245 --> 00:19:41.148
线程检查工具
看到线程2的同步时间

00:19:41.215 --> 00:19:43.650
是在线程1访问内存之后

00:19:44.284 --> 00:19:45.786
所以没有数据竞争

00:19:46.486 --> 00:19:48.255
我们就可以继续更新

00:19:48.422 --> 00:19:50.457
在释放锁之前
线程2会更新

00:19:50.524 --> 00:19:51.892
其自身的时间戳

00:19:52.426 --> 00:19:53.527
然后释放锁

00:19:54.561 --> 00:19:56.730
好了 现在该线程3去写入了

00:19:57.297 --> 00:19:58.932
线程3已经等了很长时间

00:19:58.999 --> 00:20:01.168
很激动地要写入
那个内存位置中

00:20:01.268 --> 00:20:03.303
结果呢 它把锁忘了

00:20:03.971 --> 00:20:06.740
它增加计数器
写入到内存位置

00:20:07.508 --> 00:20:09.610
线程检查工具
在那里监督着

00:20:09.910 --> 00:20:14.047
它想更新影子
并检查有没有竞争

00:20:15.015 --> 00:20:18.886
线程检查工具
看到线程3的

00:20:18.952 --> 00:20:20.420
旧视图实在旧了

00:20:21.154 --> 00:20:23.757
在影子中存储的
读取和写入是发生在

00:20:23.824 --> 00:20:25.659
线程3上次同步之后

00:20:27.060 --> 00:20:29.897
这就允许线程检查工具
揪出那个错误

00:20:37.104 --> 00:20:39.540
关于这个算法
重要是要知道

00:20:39.606 --> 00:20:42.409
我们将与数据竞争相关联的

00:20:42.476 --> 00:20:44.311
时间敏感性
在这里不适用

00:20:45.045 --> 00:20:49.049
即使竞争在特定运行中没有
显现出来 TSan还是能检测到

00:20:49.116 --> 00:20:51.285
但可能再次运行
应用程序就会出现

00:20:51.351 --> 00:20:53.220
或者用户运行你的应用程序

00:20:53.754 --> 00:20:56.723
这让使用线程检查工具
更加高效

00:20:56.924 --> 00:21:00.294
相比于调试并
重现那些数据竞争

00:21:00.360 --> 00:21:02.763
在不使用该工具的
普通环境下

00:21:03.964 --> 00:21:05.732
另一个需要记住的是

00:21:05.799 --> 00:21:08.569
线程检查工具
是运行时错误查找工具

00:21:08.635 --> 00:21:10.804
所以它只会找出竞争

00:21:11.071 --> 00:21:13.941
当你提供了足够的覆盖面

00:21:14.007 --> 00:21:17.144
所以请在线程检查工具
启用时运行你的所有测试

00:21:18.245 --> 00:21:21.315
这就是Xcode 8上新出的
线程检查工具　用它

00:21:21.715 --> 00:21:24.484
它会找出错误
它会让你的应用程序更好

00:21:32.459 --> 00:21:35.062
现在交给Devin
他会讲讲我们在

00:21:35.128 --> 00:21:37.130
Clang静态分析器
上添加的检查

00:21:43.470 --> 00:21:44.338
谢谢 Anna

00:21:46.106 --> 00:21:49.510
与检查工具不同
静态分析器可无需

00:21:49.676 --> 00:21:51.645
运行你的代码
就能找出错误

00:21:52.479 --> 00:21:56.383
其做法是系统性地探测
整个程序的所有路径

00:21:57.084 --> 00:22:00.888
这让使其十分适合找出
重现条件很难很极端的错误

00:22:01.989 --> 00:22:04.992
它支持Clang
可编译的所有语言

00:22:05.058 --> 00:22:07.761
所以C
Objective-C和C++

00:22:09.630 --> 00:22:12.966
今年静态分析器
我们添加了三个新检查

00:22:13.500 --> 00:22:15.235
本地化能力缺失的检查

00:22:16.136 --> 00:22:17.938
不正当的实例清理检查

00:22:18.138 --> 00:22:19.840
在手动保持的释放代码中

00:22:20.240 --> 00:22:22.142
还有为空性违规的检查

00:22:23.010 --> 00:22:24.344
我来跟大家讲讲

00:22:25.712 --> 00:22:28.248
在本地化应用中的常见错误

00:22:28.382 --> 00:22:30.651
就是忘记本地化UI元素

00:22:31.218 --> 00:22:33.654
这对用户来说
会是很惊人的事

00:22:34.454 --> 00:22:37.824
他们会以自己的母语
使用你的应用

00:22:37.891 --> 00:22:39.626
不过突然出乎意料地

00:22:39.993 --> 00:22:43.497
你语言中的字符串
出现在他们的UI中

00:22:43.830 --> 00:22:45.933
这不是好的用户体验

00:22:46.767 --> 00:22:47.868
我来给演示一下

00:22:47.935 --> 00:22:50.737
静态分析器
是如何找出这种错误的

00:22:56.143 --> 00:22:59.346
好了 我将演示
静态分析器

00:22:59.413 --> 00:23:00.781
Anna使用的相同应用上

00:23:02.549 --> 00:23:05.519
要运行分析器
你可以去Xcode的产品菜单

00:23:05.586 --> 00:23:06.753
选择分析

00:23:07.554 --> 00:23:10.157
这会探测大量经过你程序的路径

00:23:10.224 --> 00:23:12.359
并试图在每个路径里发现错误

00:23:13.727 --> 00:23:15.429
就像线程检查工具

00:23:15.963 --> 00:23:19.166
如果静态分析器
发现一个问题

00:23:19.466 --> 00:23:22.202
它会将这蓝色
静态分析器图标

00:23:22.269 --> 00:23:24.638
显示在Xcode的活动条中

00:23:26.406 --> 00:23:28.876
如果你点击它
它会给你显示问题导航器

00:23:29.042 --> 00:23:31.445
看来我们有一个本地化问题

00:23:32.779 --> 00:23:36.183
一个非本地化字符串
流向了面向用户属性

00:23:36.617 --> 00:23:38.051
所以我们应将其本地化

00:23:39.152 --> 00:23:41.188
不过看看这个方法

00:23:41.722 --> 00:23:43.857
我没有看出任何很明显的错误

00:23:44.525 --> 00:23:46.293
我会去点击诊断功能

00:23:47.427 --> 00:23:49.630
这给我展示了更多的信息

00:23:49.696 --> 00:23:53.066
关于这个非本地化
字符串是如何流向

00:23:53.233 --> 00:23:54.668
面向用户属性的

00:23:56.436 --> 00:23:58.972
我可以通过路径探测器栏
探测这个路径

00:23:59.406 --> 00:24:01.441
在Xcode编辑器顶部

00:24:02.843 --> 00:24:05.379
通过反向推断
我能看到这个方法是调用自

00:24:05.445 --> 00:24:07.381
表视图数据源方法

00:24:07.648 --> 00:24:10.184
之后反过来它将其传递到

00:24:10.350 --> 00:24:12.252
这个非本地化的常量字符串

00:24:12.719 --> 00:24:14.121
所以我们将其本地化

00:24:16.190 --> 00:24:18.825
为此我将使用
NS本地化字符串宏

00:24:21.395 --> 00:24:24.798
这会在运行时
加载一个翻译版的字符串

00:24:25.866 --> 00:24:28.735
在使用这个宏时
非常重要的是

00:24:28.802 --> 00:24:31.672
同时包括你给译员的注释

00:24:31.738 --> 00:24:33.807
来帮助他们正确翻译字符串

00:24:34.741 --> 00:24:35.776
所以我会说：

00:24:36.176 --> 00:24:37.611
“这是按钮...

00:24:38.278 --> 00:24:40.414
会重置会话筛选器”

00:24:44.318 --> 00:24:45.152
好了

00:24:45.752 --> 00:24:48.822
我们再次运行分析器
确保我们解决了这个问题

00:24:52.793 --> 00:24:55.329
看起来很好
我切换回幻灯片

00:25:03.670 --> 00:25:07.140
回顾一下 你可以从
产品菜单中运行分析器

00:25:07.407 --> 00:25:10.711
它会将其找到的任何问题
在问题导航器中显示

00:25:11.645 --> 00:25:16.750
正如我们所见 点击诊断功能
非常有助于显示路径

00:25:17.184 --> 00:25:21.121
这会使问题更易于理解
并且最终修复它

00:25:26.393 --> 00:25:29.863
我们看到分析器可以
找到缺失本地化功能的地方

00:25:30.497 --> 00:25:33.233
但这也警告我们
当我们忘记给

00:25:33.567 --> 00:25:35.769
译员提供注释

00:25:36.670 --> 00:25:40.541
这里我提供了零的注释
没有一点帮助

00:25:40.874 --> 00:25:42.910
所以分析器会警告

00:25:44.478 --> 00:25:45.812
你可以把这些检查打开

00:25:45.879 --> 00:25:49.416
其他静态分析器
检查在项目构建设置中

00:25:49.483 --> 00:25:51.318
静态分析器的部分

00:25:52.052 --> 00:25:55.822
本地化功能缺失的检查
会由Xcode自动打开

00:25:56.156 --> 00:25:59.193
如果你的项目拥有
不止一种语言的本地化版本

00:26:00.427 --> 00:26:02.829
注释缺失的检查
是默认关闭的

00:26:02.930 --> 00:26:05.165
但你一定要打开它

00:26:05.232 --> 00:26:09.236
如果你不用其他方式
将这些注释传达给你的译员

00:26:10.070 --> 00:26:13.740
例如 你可能已经直接
在字符串文件中这么做了

00:26:18.478 --> 00:26:21.048
今年我们还改进了
dealloc检查

00:26:21.148 --> 00:26:23.183
在你的手动保留释放代码中

00:26:24.218 --> 00:26:26.854
在手动保持释放下
非常重要的是

00:26:27.454 --> 00:26:30.090
不要释放实例变量
合成用于

00:26:30.157 --> 00:26:32.426
dealloc内的分配属性

00:26:32.993 --> 00:26:35.495
如果你那么做
这会导致过度释放

00:26:35.562 --> 00:26:39.900
当那个值的所有者也释放它
这会使你的程序崩溃

00:26:40.601 --> 00:26:42.669
所以现在分析器
放出了警告

00:26:44.505 --> 00:26:47.274
另一方面
你必须释放实例变量

00:26:47.341 --> 00:26:49.977
合成用于保持或复制属性

00:26:50.210 --> 00:26:52.279
因为如果你不这样做
它们会泄露

00:26:52.880 --> 00:26:54.715
分析器同样也会警告

00:26:56.383 --> 00:26:57.217
耶！

00:26:59.520 --> 00:27:02.322
这真是非常棒的检查

00:27:02.789 --> 00:27:06.793
我们运行的每个手动
保持释放项目中 它都会

00:27:07.027 --> 00:27:07.961
找出一个错误

00:27:08.262 --> 00:27:09.263
所以试一下

00:27:11.565 --> 00:27:14.935
当然去除保持释放问题
最好的方法

00:27:15.035 --> 00:27:17.971
是将你的项目
升级到自动引用计数

00:27:22.176 --> 00:27:24.711
幸运的是 Xcode可以
帮你自动完成这些

00:27:24.778 --> 00:27:26.213
如果你去编辑菜单

00:27:26.480 --> 00:27:29.183
选择转换到
Objective-C ARC

00:27:29.950 --> 00:27:32.386
这会让编译器
为你处理所有的麻烦

00:27:32.452 --> 00:27:34.087
关于保持释放

00:27:36.990 --> 00:27:38.258
终于在今年

00:27:38.592 --> 00:27:40.894
我们给为空性违规
添加了一个检查

00:27:41.962 --> 00:27:45.365
这是基于去年的成果
我们给SDK加注释

00:27:45.432 --> 00:27:49.570
来表示方法或属性
是接收还是返回零

00:27:50.637 --> 00:27:54.608
例如 Core Location的
时间戳属性是非空的

00:27:55.075 --> 00:27:57.244
这是因为每次的位置测量

00:27:57.678 --> 00:27:59.980
也有对应的日期和时间

00:28:00.914 --> 00:28:03.016
相比之下
其底层属性可为空

00:28:03.650 --> 00:28:06.653
这是因为这个属性会返回零

00:28:07.087 --> 00:28:10.557
当这个位置不是
室内定位激活的场地

00:28:12.492 --> 00:28:14.962
你应该给自己标头注释为空性

00:28:15.062 --> 00:28:17.164
因为它会启用
新的程序和模型

00:28:17.631 --> 00:28:20.501
可以将你的为空性预期直接

00:28:20.567 --> 00:28:22.236
传达到客户那里

00:28:22.903 --> 00:28:25.205
这很重要 因为违反

00:28:25.272 --> 00:28:28.842
这些预期 可能会引起
崩溃或意想不到的行为

00:28:29.710 --> 00:28:31.445
事实上 我们认为它如此重要

00:28:31.578 --> 00:28:35.215
以至于将它内置到Swift中
那里的可选类型要求你

00:28:35.282 --> 00:28:37.518
先检查零 之后再使用值

00:28:38.619 --> 00:28:40.888
这在Objective-C
中也很重要

00:28:41.288 --> 00:28:45.325
所以我们将为空性违规的检查
添加到静态分析器

00:28:46.360 --> 00:28:48.729
而且这个检查特别适用于

00:28:48.795 --> 00:28:51.431
混合Swift和
Objective-C代码项目

00:28:52.199 --> 00:28:53.867
它会发现两种问题

00:28:54.668 --> 00:28:56.670
在代码中可能有逻辑问题

00:28:56.737 --> 00:28:58.872
可能你在错误时间返回零

00:28:59.173 --> 00:29:01.441
或者你可能会有错误的注释

00:29:02.276 --> 00:29:03.710
所以我们看看如何修复

00:29:03.777 --> 00:29:06.280
这两种问题

00:29:08.482 --> 00:29:12.986
一个常见错误是
从零初始化局部变量

00:29:13.220 --> 00:29:15.522
之后填充进一连串

00:29:15.589 --> 00:29:17.324
非穷举的分支

00:29:18.425 --> 00:29:19.693
例如 这个方法

00:29:19.927 --> 00:29:22.629
返回一个位置的简短说明

00:29:23.163 --> 00:29:24.364
要么是城市的名字

00:29:24.731 --> 00:29:27.100
或国家
含有着这个位置

00:29:28.035 --> 00:29:30.671
但我们没能考虑到
一个很重要的情况

00:29:31.605 --> 00:29:33.841
如果这个位置是
位于国际海域呢？

00:29:34.441 --> 00:29:36.510
那这既不是城市
也不是国家

00:29:36.577 --> 00:29:39.713
所以这个方法会
不出意外地返回零

00:29:40.614 --> 00:29:42.482
然后分析器会告诉我们

00:29:43.550 --> 00:29:44.418
幸运的是

00:29:45.185 --> 00:29:46.320
这也很棒

00:29:50.757 --> 00:29:52.793
幸运的是
这很容易修复的

00:29:53.026 --> 00:29:55.729
你要做的是
初始化你的局部变量

00:29:57.664 --> 00:30:00.000
通过非零默认值

00:30:00.667 --> 00:30:02.870
在此例中
我们使用常量字符串Earth

00:30:03.070 --> 00:30:05.772
当然 要确保将其本地化

00:30:08.609 --> 00:30:11.144
另一方面
可能是你的代码

00:30:11.445 --> 00:30:13.780
在实施方面完全没问题

00:30:14.081 --> 00:30:15.983
而是注释出现错误

00:30:16.950 --> 00:30:19.453
我们发现其经常
发生的一个原因

00:30:19.686 --> 00:30:23.957
是当你使用方便的
NS_ASSUME_NONNULL_BEGIN和END的宏

00:30:25.092 --> 00:30:27.160
这些宏会将
标头的一部分包起来

00:30:27.961 --> 00:30:30.264
而且它们包起来的内部范围

00:30:30.397 --> 00:30:32.833
那些类型会隐含地成为非空

00:30:33.567 --> 00:30:35.736
这可以节省你很多的键入

00:30:36.236 --> 00:30:38.405
但这也让你很容易忘记

00:30:38.705 --> 00:30:40.474
将属性标记为可空

00:30:41.341 --> 00:30:44.411
在这个例子中
压力特性会返回零

00:30:44.478 --> 00:30:46.547
如果设备没有气压计

00:30:47.414 --> 00:30:50.617
但是属性是隐含成为非空的

00:30:52.352 --> 00:30:54.821
幸运的是
这里也很容易修复

00:30:55.322 --> 00:30:57.591
我们可以明确地
将属性标记为

00:30:57.658 --> 00:30:59.760
可空
在那个区域内部

00:30:59.993 --> 00:31:02.996
这会告诉客户
不要期待压力数据

00:31:03.063 --> 00:31:04.565
是一直可用的

00:31:07.334 --> 00:31:09.970
你的确需要注意这个

00:31:10.404 --> 00:31:13.240
这是因为你API的
为空性是一种契约

00:31:13.540 --> 00:31:16.343
所以你不应该为满足
分析器而更改它

00:31:17.277 --> 00:31:19.713
相反 你应该仔细考虑你想

00:31:19.780 --> 00:31:22.282
公开的API并使用它

00:31:23.884 --> 00:31:25.986
如果你决定改变你的API

00:31:26.253 --> 00:31:29.256
那你还要仔细考虑向后兼容

00:31:30.057 --> 00:31:32.392
这在Swift尤为重要

00:31:32.960 --> 00:31:35.596
因为 为空性会改变
类型的导入方式

00:31:38.632 --> 00:31:40.767
你也可能处在这样的情况下

00:31:41.168 --> 00:31:43.804
你无法改变方法的实现

00:31:43.871 --> 00:31:45.072
及其注释

00:31:45.706 --> 00:31:49.209
在这些情况下 你可以通过
转换来压制分析器诊断功能

00:31:50.277 --> 00:31:53.080
它经常出现的一个原因要归咎于

00:31:53.347 --> 00:31:56.583
当违反前提条件时
会防守性返回零的方法

00:31:57.284 --> 00:31:59.152
在这个例子中
该方法返回零

00:31:59.219 --> 00:32:01.221
当索引越界的时候

00:32:02.155 --> 00:32:05.092
如果有依靠这种行为
的现有代码

00:32:05.792 --> 00:32:07.261
那你不能移除那个检查

00:32:07.628 --> 00:32:09.363
而且你不能
用一个证书替代它

00:32:10.030 --> 00:32:13.800
相反 正确做法是告诉分析器
这是你特意做的

00:32:14.134 --> 00:32:16.670
通过将返回值转化为非空

00:32:22.075 --> 00:32:25.279
所以这是静态分析器
和Xcode 8的新功能

00:32:32.586 --> 00:32:33.520
我们做个总结

00:32:34.621 --> 00:32:37.024
今天我们讲了
三个很棒的工具

00:32:37.824 --> 00:32:39.793
这些工具找到真正的错误

00:32:40.561 --> 00:32:43.497
地址检查工具和
线程检查工具在运行时

00:32:43.564 --> 00:32:45.232
查找内存崩溃和线程问题

00:32:45.599 --> 00:32:49.469
静态分析器甚至不用运行
你的代码就能发现错误

00:32:49.837 --> 00:32:53.040
所以请在自己的项目中
使用这些工具

00:32:53.307 --> 00:32:57.010
它们会在用户发现错误
之前帮你找到错误

00:32:58.312 --> 00:33:01.281
如果你有兴趣了解更多信息
你可以去演讲网站

00:33:02.349 --> 00:33:04.284
这里还有几个相关演讲

00:33:04.351 --> 00:33:06.086
我们认为可能会帮助到你

00:33:07.521 --> 00:33:08.355
谢谢大家