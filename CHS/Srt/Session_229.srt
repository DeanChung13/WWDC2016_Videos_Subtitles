00:00:19.953 --> 00:00:23.023
使用TVMLKit开发应用

00:00:23.090 --> 00:00:24.024
好的

00:00:27.261 --> 00:00:31.932
大家下午好 欢迎来到
TVMLKit应用开发的第二部分

00:00:33.300 --> 00:00:35.235
有许多优秀的应用

00:00:35.335 --> 00:00:37.938
使用TVMLKit开发出来
放在App Store上

00:00:38.805 --> 00:00:41.241
一些应用使用自定义样式

00:00:41.341 --> 00:00:44.745
带给用户与众不同的体验
同时扩大了应用的知名度

00:00:46.046 --> 00:00:49.016
今天我格外的高兴

00:00:49.416 --> 00:00:52.553
同你们进行交谈 并且告诉你们如何

00:00:52.719 --> 00:00:54.888
提升应用到另一个水平

00:00:55.989 --> 00:00:58.792
这需要通过扩展TVMLKit

00:00:59.259 --> 00:01:00.694
扩展接口

00:01:01.094 --> 00:01:04.197
同时也需要JavaScript
中提供的功能来实现

00:01:05.199 --> 00:01:08.435
通过上述方式
基本上能让你的应用脱颖而出

00:01:08.802 --> 00:01:10.737
甚至会有属于自己的品牌

00:01:13.373 --> 00:01:17.511
TVMLKit是一个功能完备的框架

00:01:18.445 --> 00:01:20.013
我们也试图确保

00:01:20.080 --> 00:01:23.483
你在思考如何构建你的想法时

00:01:23.884 --> 00:01:27.187
你只需要考虑两个扩展点即可

00:01:28.121 --> 00:01:29.456
在上半场演讲中

00:01:29.957 --> 00:01:32.326
我将告诉大家如何

00:01:32.392 --> 00:01:35.596
在TVMLKit中通过扩展模板的方式
来扩展用户界面

00:01:37.130 --> 00:01:38.265
下半场演讲

00:01:38.799 --> 00:01:40.801
我的同事Christopher将会讲解

00:01:40.868 --> 00:01:44.638
如何增强你的应用通过添加程序功能

00:01:45.172 --> 00:01:47.474
到JavaScript引擎
支持TVMLKit的JavaScript引擎

00:01:50.444 --> 00:01:52.679
让我们谈论扩展模板的内容

00:01:54.748 --> 00:01:56.984
首先第一件事情每一个人都会遇到的是

00:01:57.050 --> 00:01:59.820
他们使用的TVMLKit就是模板的概念

00:02:00.254 --> 00:02:03.557
模板在TVML中定义 就是TV标记语言

00:02:04.925 --> 00:02:08.829
他们使用XML描述屏幕上显示的内容

00:02:09.496 --> 00:02:11.031
当人们看到了这里

00:02:11.431 --> 00:02:12.733
他们会说嘿

00:02:12.866 --> 00:02:15.435
我知道它 它是浏览器

00:02:16.136 --> 00:02:19.339
我敢向你保证那绝对不是浏览器

00:02:20.107 --> 00:02:23.677
TVMLKit是一个功能强大的模板引擎

00:02:24.478 --> 00:02:27.648
但那并不意味着你只能使用
我们提供的模板

00:02:28.782 --> 00:02:33.353
实际上 Apple自家的应用
同样使用TVMLKit

00:02:33.420 --> 00:02:34.655
但是以巧妙的方式扩展

00:02:35.055 --> 00:02:36.890
使它可以和原先的

00:02:36.957 --> 00:02:40.794
框架共存仍能良好的运行在tvOS上

00:02:42.462 --> 00:02:45.399
让我们看一个例子

00:02:46.033 --> 00:02:47.434
这是App Store上的应用

00:02:48.368 --> 00:02:50.437
App Store的主题有一个要求

00:02:50.504 --> 00:02:52.706
一个shelf中
只能存在一个cell

00:02:53.874 --> 00:02:57.277
你能看到他们复用了
TVMLKit提供的

00:02:57.344 --> 00:02:58.846
一个图片控件和三个文本控件

00:02:59.513 --> 00:03:01.448
除了这些他们还有自定义布局

00:03:01.615 --> 00:03:03.483
使用了自定义的聚焦动作

00:03:05.819 --> 00:03:07.988
另一个例子是我们非常熟悉的

00:03:08.055 --> 00:03:09.857
是对于购买按钮的印象

00:03:10.524 --> 00:03:12.459
App Store的主题要求

00:03:12.526 --> 00:03:16.797
购买按钮必须反映出
应用程序的不同安装状态

00:03:17.698 --> 00:03:19.433
你是否正在购买应用

00:03:19.499 --> 00:03:21.902
应用是否被安装或者已经下载

00:03:22.569 --> 00:03:25.706
所有的这些都通过复用
TVMLKit提供的模板来实现

00:03:26.273 --> 00:03:28.475
这些主题就是
今天我想特意展示给你们的

00:03:29.476 --> 00:03:31.879
尽可能复用TVMLKit

00:03:32.312 --> 00:03:35.082
并且尽可能的扩展
我们没有在模板中提供给你的样式

00:03:36.884 --> 00:03:38.619
这就是模板

00:03:40.020 --> 00:03:45.959
如果你已经使用了TVMLKit
它遵循一系列的路径

00:03:46.627 --> 00:03:49.463
当你把TVMLKit注入到框架中
最后会在屏幕上显示

00:03:50.163 --> 00:03:53.066
TV标记语言由许多元素组成

00:03:53.333 --> 00:03:54.701
命名各不相同

00:03:55.402 --> 00:03:58.539
当它进入到框架中后会被传递到
TVElementFactory

00:03:58.906 --> 00:04:00.507
TVElementFactory
是注册中心

00:04:01.141 --> 00:04:02.676
它记录着所有的元素

00:04:02.743 --> 00:04:05.012
它能够将元素翻译为相应的数据结构

00:04:05.112 --> 00:04:07.147
框架能够识别的数据结构

00:04:08.382 --> 00:04:11.351
我们使用TVInterfaceFactory类

00:04:11.451 --> 00:04:13.153
生成用户界面

00:04:13.687 --> 00:04:15.322
然后将他们显示在屏幕上

00:04:16.255 --> 00:04:19.660
这就是TVML如何显示到屏幕的过程

00:04:20.627 --> 00:04:24.231
让我们看一下扩展模板的过程中会发生什么

00:04:27.367 --> 00:04:31.805
当提到模板的扩展
就像添加你自己的标记那样简单

00:04:31.872 --> 00:04:33.841
在TVML中将标记发送给框架

00:04:34.441 --> 00:04:35.843
它会经历相同的处理过程

00:04:35.909 --> 00:04:38.712
它会进入到TVElementFactory
紧接着被转译

00:04:39.413 --> 00:04:41.949
但是当自定义的元素碰到
TVInterfaceFactory

00:04:42.015 --> 00:04:44.585
因为框架不了解你的用户界面

00:04:44.651 --> 00:04:45.953
框架会针对自定义元素询问你

00:04:46.887 --> 00:04:48.989
当你将界面给框架后

00:04:49.056 --> 00:04:51.925
TVInterfaceFactory
将把自定义的元素显示在屏幕上

00:04:53.093 --> 00:04:53.927
就是如此的简单

00:04:55.028 --> 00:04:57.731
现在你知道每个过程是如何工作的

00:04:58.165 --> 00:04:59.700
让我们来看一下它们的具体实现

00:05:00.300 --> 00:05:02.169
你需要考虑三个步骤

00:05:02.236 --> 00:05:03.770
当你想扩展模板的时候

00:05:03.837 --> 00:05:06.273
首先是定义标记符号

00:05:07.841 --> 00:05:10.210
标记在TVML中
基本上就是XML

00:05:11.245 --> 00:05:12.980
你有一个想法

00:05:13.046 --> 00:05:15.249
就是你的用户界面在屏幕上会怎样显示

00:05:16.283 --> 00:05:18.352
你必须将它转译为一种结构

00:05:18.452 --> 00:05:19.686
一些类似于

00:05:19.753 --> 00:05:22.823
使用标记本身就可以标识什么应该显示在屏幕上

00:05:23.824 --> 00:05:27.427
在我们的例子中 我们想在
stackTemplate上显示一个banner

00:05:29.196 --> 00:05:31.798
banner会有一个动画背景

00:05:31.865 --> 00:05:35.536
假如你想有能力控制动画你可以在TVML中
使用一个开关

00:05:36.436 --> 00:05:41.041
因此 myBanner这个元素会有
一个animated属性

00:05:42.276 --> 00:05:44.811
除此之外 我们再添加一个按钮

00:05:45.312 --> 00:05:48.515
但是因为不需要额外的功能

00:05:48.582 --> 00:05:50.417
我们可以使用TVML提供的按钮

00:05:50.918 --> 00:05:52.853
这就是按钮的一种形式

00:05:54.688 --> 00:05:58.559
现在你会构想自己的用户界面

00:05:58.625 --> 00:06:00.160
在标记中会如何显示

00:06:00.227 --> 00:06:02.462
你需要告诉框架

00:06:02.930 --> 00:06:06.900
这就像将你元素的唯一标识
注册到框架中那样简单

00:06:08.168 --> 00:06:11.872
在应用控制器启动之前注册操作需要执行一次

00:06:11.939 --> 00:06:13.674
以便框架能够意识到

00:06:13.740 --> 00:06:15.008
所有的元素需要特别处理

00:06:16.410 --> 00:06:18.812
上面的过程很简单就像告知
TVElementFactory

00:06:18.879 --> 00:06:22.115
你想要关联一个
TVViewElement类到

00:06:22.983 --> 00:06:25.519
你自定义的元素上

00:06:26.587 --> 00:06:30.591
TVViewElement
是基础的数据结构

00:06:30.657 --> 00:06:32.659
用来转译你的标记

00:06:32.726 --> 00:06:34.828
让框架能识别这些标记

00:06:35.262 --> 00:06:36.964
除TVViewElement外

00:06:37.030 --> 00:06:39.266
我们还可以使用它的两个子类

00:06:39.833 --> 00:06:42.269
TVImageElement
用于处理图像

00:06:42.336 --> 00:06:45.272
TVTextElement
用来处理文本

00:06:47.708 --> 00:06:50.611
既然我们已经注册了这些元素

00:06:51.345 --> 00:06:54.815
现在处理第二步 第三步时
你那边会有小部分工作

00:06:55.449 --> 00:06:58.585
但是我们试图让事情保持简单
接下来只有两个步骤

00:06:59.553 --> 00:07:03.123
你要做的第一件事是
创建一个建造者接口

00:07:03.423 --> 00:07:06.426
创建的接口必须遵循
TVInterfaceCreating协议

00:07:06.860 --> 00:07:08.328
这个特别的对象会

00:07:08.395 --> 00:07:10.998
提供你的用户界面
当框架需要的时候

00:07:11.465 --> 00:07:14.268
有一些回调函数你需要实现

00:07:14.334 --> 00:07:16.203
这些函数需要遵循
TVInterfaceCreating

00:07:16.270 --> 00:07:20.140
协议声明返回你想要的UI类型

00:07:22.643 --> 00:07:26.313
下一步是当你调用你建造类的接口时

00:07:26.813 --> 00:07:29.816
框架会对你的界面进行配置
然后将界面返回给我们

00:07:31.018 --> 00:07:34.888
像我之前强调的
尽可能复用TVMLKit

00:07:34.955 --> 00:07:36.823
我们已经做了很多工作去保证

00:07:36.890 --> 00:07:41.128
在tvOS上运行时
内置元素在性能、外观和体验上的表现是良好的

00:07:41.728 --> 00:07:43.263
让我们来看一个例子

00:07:43.330 --> 00:07:45.299
建造者的接口是什么样子

00:07:47.000 --> 00:07:49.069
在这里我们有一个
MyInterfaceCreator类

00:07:49.136 --> 00:07:51.205
这个类遵循
TVInterfaceCreating协议

00:07:52.472 --> 00:07:55.108
因为我们仅对特定的视图更感兴趣

00:07:55.175 --> 00:07:57.845
我们可以去实现makeView元素

00:07:57.911 --> 00:08:00.113
还需要实现
existingView的回调方法

00:08:01.315 --> 00:08:04.318
一旦实现这个类后 你需要做的是

00:08:04.384 --> 00:08:07.554
使用TVInterfaceFactory
注册这个类的实例

00:08:10.324 --> 00:08:12.426
让我们具体看一下makeView
这个元素

00:08:13.093 --> 00:08:15.562
我们可以看到TVMLKit

00:08:15.629 --> 00:08:18.866
给你提供了一个元素和
一个可选的existingView

00:08:19.366 --> 00:08:20.901
在这个例子的banner中

00:08:21.301 --> 00:08:23.637
我们只需要检查这个元素自身的名字

00:08:25.506 --> 00:08:27.708
我们需特别注意
myBanner这个元素

00:08:27.774 --> 00:08:29.510
当我们发现和它类似的元素时

00:08:30.143 --> 00:08:31.745
我们要创建这个视图的实例

00:08:33.113 --> 00:08:35.381
因为myBanner有一个元素属性

00:08:35.916 --> 00:08:38.018
我们可以很容易的筛选到这个元素

00:08:38.085 --> 00:08:40.020
利用这个元素提供的回调函数

00:08:40.787 --> 00:08:42.688
然后将这个元素转换到视图上

00:08:44.024 --> 00:08:46.226
我们在这个视图上还有一个按钮

00:08:46.760 --> 00:08:49.229
因为它是一个TVMLKit按钮

00:08:49.630 --> 00:08:51.098
这样做是简单的就像

00:08:51.164 --> 00:08:53.767
为特定的元素调用
TVInterfaceFactory

00:08:54.134 --> 00:08:56.770
然后会为myBanner元素
返回它所需要的视图

00:08:57.638 --> 00:08:59.773
最后当然也会返回你需要的视图

00:09:01.375 --> 00:09:03.744
在框架默认方法中

00:09:03.810 --> 00:09:05.512
必须返回nil

00:09:07.114 --> 00:09:10.284
我们已经谈论了很多视图的内容
视图控制器的内容呢？

00:09:11.685 --> 00:09:15.022
TVMLKit提供视图控制器样式是

00:09:15.088 --> 00:09:16.723
一个shelf有很多lockup

00:09:16.790 --> 00:09:18.592
用这种样式进行水平方向扩展

00:09:18.992 --> 00:09:20.661
或者是网格垂直方向上的扩展

00:09:21.962 --> 00:09:24.331
使用TVMLKit的回调函数

00:09:24.398 --> 00:09:27.367
返回这些视图控制器

00:09:27.434 --> 00:09:29.236
你可以使用你自己的视图控制器
替换默认的视图控制器

00:09:30.804 --> 00:09:34.641
这种用法类似于makeView

00:09:34.708 --> 00:09:38.345
在这个实例中我们仍然提供相应元素的
existingViewController

00:09:38.412 --> 00:09:41.682
我们希望最终返回的是
existingViewController

00:09:43.483 --> 00:09:45.185
现在你会想原来如此

00:09:46.520 --> 00:09:47.754
本质上就是视图的集合

00:09:48.355 --> 00:09:51.225
视图的集合是许多带有cell的视图

00:09:51.925 --> 00:09:54.761
这就是如何对自己的
lockup进行定义

00:09:56.730 --> 00:09:57.998
这个例子够深刻吗？

00:09:59.333 --> 00:10:02.536
App Store有一个特殊的要求

00:10:03.103 --> 00:10:07.941
一个布局仅有一个cell
和特定的行为

00:10:08.575 --> 00:10:11.512
就像你看到的
其他的东西是UMLKit的扩展

00:10:12.145 --> 00:10:13.580
标题的上下浮动依赖于

00:10:13.647 --> 00:10:16.350
焦点是否位于元素的范围内

00:10:17.618 --> 00:10:21.121
在将要推出的tvOS 10中

00:10:21.188 --> 00:10:23.924
我们允许你指定
自定义视图集合的cell

00:10:24.858 --> 00:10:27.094
允许你为cell自定义布局

00:10:27.160 --> 00:10:29.930
最重要的是你可以拦截焦点事件

00:10:29.997 --> 00:10:31.465
当cell获得焦点的时候

00:10:32.299 --> 00:10:34.334
为了达到这种效果你需要做两件事情

00:10:34.868 --> 00:10:37.738
首先是用我们最新的API

00:10:37.804 --> 00:10:40.941
它允许你对我们视图集合的
CellClass进行设置

00:10:41.008 --> 00:10:43.076
当我们使用特定元素的时候

00:10:44.178 --> 00:10:46.413
我们在屏幕上构建用户界面

00:10:46.947 --> 00:10:49.616
框架通过使用makeView
来允许你进行自定义

00:10:49.883 --> 00:10:52.819
对相关的cell进行配置
返回界面给我们

00:10:53.520 --> 00:10:57.791
我们提供可自定义的视图集合cell

00:10:57.925 --> 00:10:59.459
将视图集合的条目加入队列中

00:10:59.526 --> 00:11:03.463
使用已有视图自身的参数

00:11:05.432 --> 00:11:07.668
接下来我将请Parry上台

00:11:07.734 --> 00:11:10.504
为你们展示上面提到的界面
是如何工作的 Parry

00:11:10.904 --> 00:11:14.007
视图集合条目的自定义展示

00:11:16.009 --> 00:11:16.910
谢谢你Jeremy

00:11:17.277 --> 00:11:20.914
大家好 我是Parry
我将给大家展示

00:11:21.114 --> 00:11:23.283
如何在TVMLKit自定义cell

00:11:24.451 --> 00:11:26.086
自定义cell是简单的

00:11:26.153 --> 00:11:29.690
如果你想像多个shelf那样
使用TVMLKit集合

00:11:29.756 --> 00:11:32.492
还有网格 但你想添加自己的cell

00:11:32.893 --> 00:11:37.397
通过自定义布局和
聚焦机制来展示你的内容

00:11:38.665 --> 00:11:42.336
我将向你展示一个基于
TVMLKit制作的简单应用

00:11:43.270 --> 00:11:44.404
稍后

00:11:44.638 --> 00:11:47.374
我将使用自定义cell对它进行扩展

00:11:48.375 --> 00:11:50.177
使得应用的显示效果更好

00:11:52.312 --> 00:11:53.347
让我们开始吧

00:11:55.949 --> 00:11:58.352
我把屏幕转接到我的电脑上

00:12:02.055 --> 00:12:05.893
我使用Xcode打开我的应用

00:12:06.360 --> 00:12:08.228
我会基于TVMLKit进行编码

00:12:08.695 --> 00:12:10.531
让我们看看这个应用

00:12:11.265 --> 00:12:15.502
这个应用可以使用户浏览他们的相册

00:12:18.305 --> 00:12:23.610
应用中使用到的JavaScript
和同XML相关的文件

00:12:23.877 --> 00:12:25.746
都存储在我的电脑上

00:12:26.046 --> 00:12:28.348
我们可以大体浏览下这些文件

00:12:29.650 --> 00:12:32.753
现在显示的是应用的一个页面

00:12:33.687 --> 00:12:36.156
这个页面会把用户的相册展示出来

00:12:37.224 --> 00:12:39.259
你可以看到
stackedtemplate

00:12:40.994 --> 00:12:43.163
还有一个不错的banner

00:12:43.430 --> 00:12:44.765
背景图

00:12:46.133 --> 00:12:49.503
它有一个shelf是用来展示相册的

00:12:51.438 --> 00:12:54.842
每个相册其实通过lockup呈现

00:12:55.809 --> 00:13:01.448
每一个lockup嵌入了
来自相册的图片

00:13:02.516 --> 00:13:03.717
最后相册展示出来

00:13:05.519 --> 00:13:09.223
除了使用一些自定义样式
使得lockup变得大一点

00:13:09.356 --> 00:13:11.491
我没有自定义TVMLKit

00:13:12.226 --> 00:13:16.864
现在它是没有TVMLKit的应用

00:13:18.332 --> 00:13:22.202
运行程序看一下它的展示效果

00:13:25.239 --> 00:13:27.841
接下来我将在Apple TV上运行

00:13:32.246 --> 00:13:36.783
这就是我在stackedtemplate
文件中提到过的应用

00:13:37.084 --> 00:13:39.052
别致的banner在顶端

00:13:39.920 --> 00:13:41.355
它的shelf在底部

00:13:41.788 --> 00:13:46.293
我觉得超出范围的那部分还是挺不错的

00:13:47.060 --> 00:13:50.797
这是奏效的较大的lockup
能使得它看起来不一样

00:13:52.533 --> 00:13:55.068
我觉得还能做得更好一点

00:13:59.373 --> 00:14:01.675
考虑这种情况

00:14:02.509 --> 00:14:05.546
除了从相册中取一张照片

00:14:05.979 --> 00:14:08.215
显示在当前的页面上

00:14:09.650 --> 00:14:12.419
要是我们选择多张相片

00:14:12.719 --> 00:14:14.621
选中的照片来自于相册

00:14:14.888 --> 00:14:18.892
使用那种方式将
相册放到文档上会怎样？

00:14:19.927 --> 00:14:23.363
让我们想一下

00:14:23.463 --> 00:14:27.134
如何构建图像的拼图

00:14:27.601 --> 00:14:29.069
当相册没有被选中

00:14:30.804 --> 00:14:34.975
或者当相册没有获得焦点时
将图片加入到九宫格中

00:14:35.909 --> 00:14:36.810
那听起来挺酷

00:14:37.911 --> 00:14:39.012
但不止于此

00:14:39.580 --> 00:14:44.084
它将关于相册的上下文信息传递给用户

00:14:44.885 --> 00:14:48.388
用户可以看到相册中的许多图片

00:14:51.258 --> 00:14:56.330
真是一个使用TVMLKit
自定义cell的不错例子

00:14:57.497 --> 00:14:58.765
让我展示如何使用它

00:15:00.434 --> 00:15:04.605
我将切回我的电脑

00:15:05.639 --> 00:15:07.574
我想做的第一件事情是

00:15:07.641 --> 00:15:11.144
像我刚才所说的创建一个特定的标记

00:15:12.279 --> 00:15:16.049
它是视觉表现的呈现形式

00:15:16.116 --> 00:15:17.718
对你的用户界面来说

00:15:18.085 --> 00:15:21.321
根据XML的规则使得
TVMLKit可以被理解

00:15:22.322 --> 00:15:24.391
所以我将在这里

00:15:25.559 --> 00:15:29.363
就像你看到的 它也是一个带有shelf
的stackedtemplate

00:15:30.464 --> 00:15:36.069
但是除了lockup之外
它还有有一个新的元素

00:15:36.136 --> 00:15:38.138
就是我刚才创建的
叫做FlyoutCell

00:15:38.539 --> 00:15:40.340
展示的就是我刚才创建的那个条目

00:15:40.774 --> 00:15:43.911
我称它为flyout
因为图片看着像从里面飞出了一样

00:15:46.013 --> 00:15:48.248
就像描述中提及的

00:15:48.549 --> 00:15:52.019
我想在cell里放多张图片

00:15:52.819 --> 00:15:53.687
因此

00:15:53.754 --> 00:15:57.758
cell里面有多个图片子元素

00:16:00.294 --> 00:16:02.296
有一点需要注意

00:16:02.596 --> 00:16:04.765
对所有自定义的cell来说

00:16:05.365 --> 00:16:09.303
它们需要有三种样式

00:16:10.637 --> 00:16:15.375
它们是宽和高

00:16:16.543 --> 00:16:19.379
在tvOS 10中添加新的样式

00:16:19.446 --> 00:16:21.215
是TV focus margin

00:16:22.883 --> 00:16:27.487
TVMLKit使用宽和高

00:16:27.888 --> 00:16:31.625
在集合视图中给cell适合的边框

00:16:32.860 --> 00:16:35.128
使用TV focus margin
作为默认大小

00:16:36.129 --> 00:16:39.399
当元素获得焦点时
便可以知道将边缘扩大多少

00:16:40.601 --> 00:16:42.736
它使用这个信息创建

00:16:43.370 --> 00:16:45.172
适合的间隔在两个shelf之间

00:16:46.340 --> 00:16:48.542
也会去重新调整
shelf header

00:16:49.910 --> 00:16:52.079
当移动到cell下它便获得焦点

00:16:54.681 --> 00:16:57.818
现在我们有了规格
那下一步该做什么？

00:17:00.454 --> 00:17:05.025
需要将新元素加入到TVMLKit中

00:17:05.192 --> 00:17:06.527
让我们快点做

00:17:07.261 --> 00:17:09.829
让我们看一下AppDelegate

00:17:10.897 --> 00:17:14.501
在应用中有
didFinishLaunchingWithOptions方法

00:17:16.502 --> 00:17:19.106
我将删除这些代码

00:17:19.173 --> 00:17:22.910
我之前写的 就像上面那样

00:17:26.012 --> 00:17:29.783
使用我刚添加的
FlyoutCell元素

00:17:31.385 --> 00:17:34.821
使用TVMLKit中的
TVElementFactory

00:17:37.324 --> 00:17:41.395
TVMLKit希望我们对
建造者的接口做出提升

00:17:42.062 --> 00:17:46.800
通过对它进行扩展
以便我可以对cell进行配置

00:17:47.734 --> 00:17:50.370
对吧？所以让我们快点完成它

00:17:57.778 --> 00:18:00.380
这就是TVMLKit要求的全部配置

00:18:00.447 --> 00:18:03.650
让我们看一下这些类的实现

00:18:04.084 --> 00:18:07.688
从ExtendedInterfaceCreator开始

00:18:09.990 --> 00:18:13.527
对于自定义的cell
你需要实现两个API

00:18:15.095 --> 00:18:15.929
首先

00:18:17.531 --> 00:18:19.633
collectionViewCellClass类

00:18:21.235 --> 00:18:24.004
要求用它映射你的自定义元素

00:18:24.071 --> 00:18:27.608
到你使用的
collectionViewCellClass类

00:18:29.977 --> 00:18:34.882
第二个是makeView要求

00:18:34.982 --> 00:18:37.918
使用你的元素配置你的cell

00:18:40.020 --> 00:18:41.889
让我们快速填充空白的地方

00:18:43.690 --> 00:18:46.426
用我以前写过的一部分代码

00:18:46.860 --> 00:18:50.330
对自定义的cell进行映射

00:18:51.832 --> 00:18:55.636
利用collectionViewCellClass类

00:18:58.605 --> 00:18:59.773
同样的

00:19:04.645 --> 00:19:09.516
利用映射去配置
collectionViewCell类

00:19:10.250 --> 00:19:14.588
特别注意的是已存在视图的参数

00:19:14.655 --> 00:19:15.989
总是有效的

00:19:16.190 --> 00:19:18.759
因为TVMLKit将它加入队列

00:19:18.825 --> 00:19:21.962
从视图集合中为了使它显示出来

00:19:22.029 --> 00:19:26.300
对于自定义的cell
它将会出现在这里

00:19:28.068 --> 00:19:31.405
在跳转到flyoutcell配置前

00:19:31.772 --> 00:19:35.075
让我们看一下
Flyoutcell类本身

00:19:38.278 --> 00:19:41.081
这就是
FlyoutCollectionViewCell类

00:19:41.148 --> 00:19:44.284
我使用它展现flyoutCell

00:19:44.551 --> 00:19:46.954
你可以看到 它就是

00:19:47.020 --> 00:19:48.355
UICollectionViewCell的子类

00:19:49.389 --> 00:19:53.126
在类内部
没有使用TVMLKit做任何事情

00:19:54.127 --> 00:19:55.429
它仅仅是cell的类

00:19:55.495 --> 00:19:58.498
我可以在原生应用或其它应用中使用它

00:20:00.167 --> 00:20:03.337
需要指出的是它接受

00:20:03.971 --> 00:20:07.541
图片视图的数组

00:20:07.608 --> 00:20:10.777
那些数组用来显示视图的内容

00:20:12.679 --> 00:20:15.749
这些图片是我们想要展示的

00:20:15.816 --> 00:20:20.487
在我们扩展TV视图元素的接口中

00:20:23.557 --> 00:20:28.095
让我们回到要扩展接口的地方
补全这些代码

00:20:36.570 --> 00:20:39.540
这就是需要展示的内容 不是太多

00:20:40.974 --> 00:20:43.944
但是挺重要的

00:20:45.979 --> 00:20:50.250
我遍历所有的子元素

00:20:51.785 --> 00:20:54.588
提取出图像元素

00:20:55.489 --> 00:21:00.661
简单的重复使用TVMLKit
为我们创建图像

00:21:00.761 --> 00:21:03.597
现在除了没有显示图像之外
它是相当棒的

00:21:03.664 --> 00:21:08.068
因为我们使用的是网络图片

00:21:09.136 --> 00:21:13.106
它允许我们对图像进行缩放裁剪
来使用给出的范围

00:21:13.173 --> 00:21:15.209
以便用户界面可以更好的展示

00:21:16.276 --> 00:21:20.380
它同样做了缓存以便我可以在
其他地方重复使用这些图片

00:21:21.448 --> 00:21:27.154
因此复用TVMLKit的视图
和其他的功能是很有好处的

00:21:27.855 --> 00:21:29.122
我建议你们使用它

00:21:30.624 --> 00:21:33.994
我们已经对代码进行了完善

00:21:34.061 --> 00:21:36.530
并且和TVMLKit相关的类
能理解我们的元素

00:21:36.830 --> 00:21:39.132
还有一件事情需要去做

00:21:39.333 --> 00:21:42.803
回到我刚才展示的
stacked文本中

00:21:43.470 --> 00:21:47.407
将所有的lockup替换为
我们刚添加的FlyoutCell

00:21:48.809 --> 00:21:50.177
我现在回到了那个地方

00:21:51.512 --> 00:21:53.714
移除掉这些lockup

00:21:59.152 --> 00:22:01.355
添加FlyoutCell

00:22:07.027 --> 00:22:10.631
现在有三个相册
有三个FlyoutCell进行填充

00:22:10.697 --> 00:22:13.233
每一个FlyoutCell有...

00:22:15.202 --> 00:22:16.336
四张图片在它里面

00:22:17.704 --> 00:22:21.241
当你添加这些cell的时候
不要忘记添加样式

00:22:21.308 --> 00:22:24.011
那是强制的要求

00:22:30.083 --> 00:22:34.288
我们添加了所有的东西然后回到应用中

00:22:34.721 --> 00:22:36.523
看一下修改之后的样子

00:22:38.425 --> 00:22:40.561
我将切换到Apple TV

00:22:46.733 --> 00:22:48.268
上面是flyoutcell

00:22:55.709 --> 00:23:01.515
你可以看到现在比
展示一张图片的效果更好了

00:23:01.915 --> 00:23:04.785
它看起来更生动

00:23:05.752 --> 00:23:10.023
特别注意cell
只是适用于TVMLKit

00:23:10.090 --> 00:23:13.927
间隔是合适的 甚至相册的封面

00:23:15.529 --> 00:23:19.533
随着cell获得焦点视图
会进行上下移动

00:23:22.469 --> 00:23:26.907
感觉像是TVMLKit内置的控件
然而它的确是你添加的

00:23:28.775 --> 00:23:29.977
你的界面实现了

00:23:31.178 --> 00:23:33.347
自定义cell的确是非常容易实现

00:23:34.648 --> 00:23:39.520
它允许你添加许多数值到你的应用中

00:23:39.586 --> 00:23:42.155
通过复用TVMLKit提供的

00:23:42.656 --> 00:23:47.127
同时会允许你使用你的方法进行展示

00:23:48.262 --> 00:23:49.129
谢谢

00:23:54.701 --> 00:23:56.136
谢谢你Parry

00:23:56.803 --> 00:23:59.473
我认为Parry花了很多时间
构建FlyoutCell

00:23:59.540 --> 00:24:02.209
比实际中利用TVMLKit进行显示

00:24:03.210 --> 00:24:07.414
在继续进行之前
让我们快速回顾下前面的内容

00:24:07.981 --> 00:24:11.051
最开始提到了扩展模板

00:24:11.118 --> 00:24:13.987
定义一个标记去描述你的用户接口

00:24:15.155 --> 00:24:18.592
用TVElementFactory
注册上面的接口

00:24:18.659 --> 00:24:21.762
然后将它转译成视图元素

00:24:23.163 --> 00:24:27.334
提供可扩展建造者的接口
以便你能声明自己的用户接口

00:24:27.401 --> 00:24:30.204
可以随时停止在屏幕上构建的UI

00:24:32.072 --> 00:24:33.407
更重要的是

00:24:33.473 --> 00:24:37.711
使用TVViewElement
的属性和特性

00:24:37.778 --> 00:24:41.348
去配置你的用户界面在显示到屏幕之前

00:24:43.417 --> 00:24:45.819
这就是关于扩展模板的全部内容

00:24:45.886 --> 00:24:47.321
挺简单的

00:24:48.322 --> 00:24:52.192
我们看到你们用它
构建自己的应用挺兴奋的

00:24:53.427 --> 00:24:58.599
在继续之前
我们要告诉你一些需要注意的事情

00:25:02.536 --> 00:25:07.140
你的用户界面通过TVML中的
元素展示出来

00:25:08.008 --> 00:25:10.511
这个文件可以在任意时间更新

00:25:11.144 --> 00:25:16.316
举个例子 带有lockup的
shelf在搜索模板里

00:25:16.917 --> 00:25:21.922
当你进行搜索时 shelf会使用
JavaScript进行更新

00:25:22.189 --> 00:25:23.790
显示的内容会改变

00:25:24.157 --> 00:25:26.293
这就是内容的更新

00:25:27.427 --> 00:25:28.428
现在

00:25:28.896 --> 00:25:33.433
当我们重新构建用户界面
文档的更新就会发生

00:25:33.800 --> 00:25:36.803
我们需要调用接口的建造者

00:25:37.471 --> 00:25:42.009
你需要在元素中查看更新的类型

00:25:42.276 --> 00:25:44.044
并且能看出什么地方进行了更新

00:25:45.412 --> 00:25:47.714
举例来说 孩子有可能会变得淘气

00:25:47.981 --> 00:25:49.183
作为称职的父母

00:25:49.249 --> 00:25:51.318
你不想放弃你的孩子

00:25:51.385 --> 00:25:52.886
因为那样做不太好

00:25:54.054 --> 00:25:58.358
相应的
尽可能复用cell 复用视图

00:26:01.028 --> 00:26:04.364
在我们返回banner的那个例子中

00:26:04.932 --> 00:26:08.035
在TVMLKit生态系统中
我们不是好公民

00:26:08.101 --> 00:26:09.703
我们没有复用所有视图

00:26:10.571 --> 00:26:12.206
让我们看看能否改变这种局面

00:26:13.640 --> 00:26:16.043
挺简单的就更改两行代码

00:26:17.544 --> 00:26:22.382
在这个例子中我们把
existingView看作回调的一部分

00:26:22.749 --> 00:26:26.620
我们尽力做出我们期望的视图

00:26:26.687 --> 00:26:28.589
在MyBanner视图中

00:26:29.423 --> 00:26:33.126
如果不是我们期望的
实例化一份新的拷贝

00:26:34.361 --> 00:26:38.866
因为我们有TVMLKit按钮
基于TVMLKit

00:26:39.433 --> 00:26:41.435
我们也必须做正确的事情

00:26:41.502 --> 00:26:47.641
通过传递到
TVInterfaceFactory进行复用

00:26:47.975 --> 00:26:49.977
现有视图参数

00:26:51.278 --> 00:26:52.846
在特殊的例子中

00:26:52.913 --> 00:26:55.415
因为MyBanner
是一个比较简单的视图

00:26:55.482 --> 00:26:57.918
在任何时间更新它都是没问题的

00:26:58.218 --> 00:27:00.020
我们不需要去看更新的类型

00:27:00.854 --> 00:27:03.824
除非你的视图 结构是相当复杂的

00:27:04.191 --> 00:27:06.593
出于性能的原因 我们建议你

00:27:06.660 --> 00:27:09.696
看一下更新的类型找出更新的部分

00:27:12.633 --> 00:27:13.667
这是...

00:27:15.002 --> 00:27:18.071
你需要改变的第一行

00:27:19.806 --> 00:27:20.774
现在

00:27:21.241 --> 00:27:25.679
在tvOS 10的新特性
就是明暗的视觉表现

00:27:26.113 --> 00:27:28.916
若你使用TVMLKit自定义的视图

00:27:29.550 --> 00:27:34.221
你可以去监听这些特征
来做出或明或暗的变化

00:27:36.456 --> 00:27:40.994
我们有阐述tvOS新特性的演讲
还会告诉你需要做的

00:27:41.128 --> 00:27:43.096
我建议你们仔细看看

00:27:43.664 --> 00:27:44.932
外观的适配

00:27:45.365 --> 00:27:48.902
在这个例子中
你需要了解TVMLKit的规则

00:27:49.069 --> 00:27:52.372
复用我们的组件 谢谢你

00:27:53.207 --> 00:27:56.777
我建议你检核样式更新的提示

00:27:56.844 --> 00:27:58.345
从元素更新类型过程中

00:27:59.112 --> 00:28:01.682
它会告诉你视图

00:28:01.748 --> 00:28:03.650
是明或是暗的表现形式

00:28:04.351 --> 00:28:06.386
复用文档灵活更新

00:28:06.453 --> 00:28:09.356
对你来说是仅有的方法

00:28:09.423 --> 00:28:12.526
来更新你的视图展示或明或暗的效果

00:28:13.760 --> 00:28:16.630
因为他们是你需要
复用的TVMLKit组件

00:28:17.531 --> 00:28:21.001
更重要的是我们需要转到
TVInterfaceFactory

00:28:21.068 --> 00:28:22.603
这样才能完成这些显示工作

00:28:25.806 --> 00:28:31.445
如果你有原生的应用
又或者你有自己的视图控制器

00:28:32.246 --> 00:28:34.314
你在应用中使用了TVMLKit

00:28:34.848 --> 00:28:37.184
你可以让框架混合使用它们

00:28:38.085 --> 00:28:40.988
这就像定义一个模板元素那样简单

00:28:43.023 --> 00:28:46.293
再次强调 通过元素工厂注册它

00:28:47.327 --> 00:28:52.032
通过加载特定的模板
构建我们的用户界面

00:28:52.232 --> 00:28:55.502
返回你的视图控制器
所有的设置就完成了

00:28:58.672 --> 00:29:02.976
另一种方法在你已存在的
原生应用使用TVMLKit

00:29:03.410 --> 00:29:07.981
是获得我们提供子应用的导航控制器

00:29:09.950 --> 00:29:12.920
你已经学习了
如何创建TV应用的控制器

00:29:13.187 --> 00:29:17.658
我要强调的是
在这个例子中你不用指定一个窗口

00:29:17.858 --> 00:29:19.526
因为我们已经有一个窗口了

00:29:20.127 --> 00:29:24.031
选择你要在导航控制器中
显示的视图控制器

00:29:25.032 --> 00:29:27.301
一旦你有了TV应用的控制器

00:29:27.801 --> 00:29:30.470
获得它的导航控制器并且展示它

00:29:32.706 --> 00:29:37.144
另一种方法是
使用UIWindow的实例

00:29:37.978 --> 00:29:42.850
在这个例子中你需要指定窗口参数

00:29:43.917 --> 00:29:47.487
一旦JavaScript启动
或者应用逻辑执行了

00:29:47.554 --> 00:29:52.125
TVMLKit做正确的事
将你窗口的键值隐藏

00:29:54.161 --> 00:29:57.531
接下来Christopher
将会和大家谈论

00:29:57.598 --> 00:30:00.100
如何扩展应用的功能

00:30:00.167 --> 00:30:02.102
通过调用JavaScript

00:30:02.469 --> 00:30:03.370
Chris

00:30:08.208 --> 00:30:09.142
谢谢Jeremy

00:30:09.243 --> 00:30:13.247
大家好 我是Christopher
TVMLKit的工程师

00:30:14.147 --> 00:30:19.219
刚刚我们看了如何在
TVMLKit中扩展模板引擎

00:30:19.586 --> 00:30:21.221
使用自定义的标记

00:30:21.388 --> 00:30:25.492
实现我们自己的视图和视图控制器

00:30:25.659 --> 00:30:27.528
还有视图集合的cell

00:30:28.095 --> 00:30:31.899
你也可扩展TVMLKit的脚本引擎

00:30:31.965 --> 00:30:34.201
通过使用
JavaScriptCore实现

00:30:34.401 --> 00:30:38.438
实现你自己应用中的特定功能

00:30:38.505 --> 00:30:41.275
在JavaScript中
或暴露给JavaScript

00:30:42.176 --> 00:30:46.547
有三种方式来将代码注入到
JavaScript的运行环境

00:30:46.613 --> 00:30:48.515
在你的TVML应用中

00:30:48.582 --> 00:30:49.516
让我们看一下

00:30:51.318 --> 00:30:56.290
首先 你可以在运行时
加载额外的JavaScript库

00:30:58.559 --> 00:31:03.197
第二 你可以使用原生代码直接交互

00:31:03.263 --> 00:31:05.966
同JavaScript的上下文
在你的应用中

00:31:06.066 --> 00:31:11.038
触发JavaScript中的函数
或者传递数据

00:31:11.104 --> 00:31:12.472
在两个运行环境之间

00:31:13.640 --> 00:31:17.044
第三 你可以使用原生类

00:31:17.444 --> 00:31:20.347
将原生类传递到JavaScript

00:31:20.714 --> 00:31:24.618
通过简单的类约定
使你的脚本可以访问它们

00:31:24.685 --> 00:31:25.919
在JavaScriptCore中

00:31:27.154 --> 00:31:29.756
让我们详细的了解下这些方法

00:31:29.823 --> 00:31:31.391
从最简单的开始

00:31:32.659 --> 00:31:33.794
JavaScript库

00:31:33.861 --> 00:31:38.031
当你的应用开始加载
最先发生的事情是

00:31:38.098 --> 00:31:40.601
TVMLKit会加载
JavaScript文件

00:31:40.667 --> 00:31:43.604
文件里面会包含
app.onlaunch回调

00:31:43.670 --> 00:31:47.674
应用的控制权会交给你TVML
应用的JavaScript

00:31:48.342 --> 00:31:52.880
启动过程必须等待直到
application.js文件加载运行

00:31:53.013 --> 00:31:56.450
在app.launch执行完成之前

00:31:56.850 --> 00:32:00.954
如果说你的应用比较庞大
你可以对代码进行切割

00:32:01.021 --> 00:32:03.991
把代码放到许多独立的文件中
加速启动时间

00:32:05.626 --> 00:32:09.263
这是TVMLKit普遍支持的形式

00:32:09.329 --> 00:32:11.765
允许你加载额外的
JavaScript

00:32:12.533 --> 00:32:14.768
在应用运行时的任何时候

00:32:16.103 --> 00:32:20.440
你的JavaScript库
其中可以定义变量

00:32:20.507 --> 00:32:24.411
和函数并且可以被所有的脚本使用

00:32:26.947 --> 00:32:33.287
让我们看一下TVMLKit JS
提供的全局函数

00:32:33.887 --> 00:32:38.091
一般情况下你能在
app.onlaunch上进行调用

00:32:38.158 --> 00:32:40.027
你也可以在其他的地方进行调用

00:32:40.861 --> 00:32:47.067
这个函数使用脚本URL的数组
和完整的回调函数作为参数

00:32:48.068 --> 00:32:50.871
当回调函数执行后

00:32:51.238 --> 00:32:53.774
你可以使用变量和函数

00:32:53.841 --> 00:32:55.475
我们在脚本库中定义的

00:32:56.376 --> 00:32:58.312
但是还有一些事情需要注意

00:33:01.381 --> 00:33:03.550
当你调用执行脚本的时候

00:33:04.151 --> 00:33:07.254
TVMLKit JS会执行这些代码

00:33:07.321 --> 00:33:10.390
在你的JavaScript文件中
会调用其它函数

00:33:11.358 --> 00:33:15.729
所以在相同的文件中
不要多次调用执行脚本

00:33:16.363 --> 00:33:20.133
同样要注意如果你的脚本
依赖其它的脚本

00:33:20.200 --> 00:33:22.135
你需要以正确的顺序加载它们

00:33:24.905 --> 00:33:29.443
执行脚本会并发的
根据URL下载脚本文件

00:33:30.244 --> 00:33:32.946
然后会一次执行它们

00:33:33.380 --> 00:33:37.985
如果其中任何一个脚本没有获取到
其它脚本也不会执行

00:33:38.051 --> 00:33:42.890
当回调完成后要检查成功的参数来确保

00:33:42.956 --> 00:33:45.592
JavaScript库是可获取到的

00:33:47.995 --> 00:33:50.430
最后 我想告诉大家

00:33:50.531 --> 00:33:55.169
尽管TVMLKit
提供了许多类似网页的接口

00:33:55.235 --> 00:33:58.238
可是你的TVML应用不是网页浏览器

00:33:58.472 --> 00:34:02.643
可能发现许多JavaScript库
能很好的帮助你开发网页应用

00:34:02.709 --> 00:34:04.811
但在TVMLKit中
有可能出现不兼容的情况

00:34:04.878 --> 00:34:07.314
尤其是你依赖浏览器功能的时候

00:34:07.381 --> 00:34:11.518
比如全局的window对象
或者全局的document对象

00:34:12.319 --> 00:34:13.587
记住那些就可以了

00:34:15.989 --> 00:34:17.591
但是不要限制你自己

00:34:17.658 --> 00:34:20.527
在你的TVML应用中
使用JavaScript

00:34:20.860 --> 00:34:24.264
你能进入到
JavaScript运行环境

00:34:24.364 --> 00:34:25.831
从原生的代码中

00:34:26.500 --> 00:34:31.505
可以将应用的UI事件
传递到JavaScript中

00:34:31.605 --> 00:34:34.741
或者在JavaScript和
原生之间上传和拉取数据

00:34:37.678 --> 00:34:43.583
TVML中 你JavaScript
运行环境是被TVMLKit

00:34:44.451 --> 00:34:47.654
的一个叫作
TVApplicationController类管理着

00:34:48.388 --> 00:34:51.324
JavaScript
在单独的线程中执行

00:34:51.391 --> 00:34:53.659
所以你需要对进行交互的时机进行调度

00:34:54.761 --> 00:34:57.331
最简单的形式是
你只需要简单的调用函数

00:34:57.397 --> 00:35:01.768
在TVApplicationController上
然后将block传递进去并执行

00:35:04.338 --> 00:35:08.942
当block执行后
你将获得JS上下文环境的引用

00:35:09.209 --> 00:35:13.080
在这里你可将字符串当做
JavaScript代码执行

00:35:13.747 --> 00:35:16.583
你可以在对象上触发函数

00:35:16.817 --> 00:35:21.855
你可获取和设置JavaScript
的属性使用原生的变量

00:35:23.190 --> 00:35:26.827
你不能持有JSContext

00:35:26.927 --> 00:35:28.962
或者在block之外的任何地方使用

00:35:31.632 --> 00:35:34.768
由于JavaScript运行在
单独的线程中

00:35:34.835 --> 00:35:38.972
你需要注意你不能执行任何阻塞操作

00:35:39.039 --> 00:35:40.807
当你执行block的时候

00:35:41.041 --> 00:35:43.043
否则会在主线程中出现死锁

00:35:44.011 --> 00:35:48.682
获得关于JSContext和
JavaScriptCore更多信息

00:35:48.749 --> 00:35:53.520
请访问 WWDC 2013中
JavaScriptCore部分

00:35:55.289 --> 00:35:59.760
让我看这个例子是如何调用
JavaScript代码的

00:36:00.194 --> 00:36:01.862
从Swift应用中

00:36:02.696 --> 00:36:07.367
这个显示的Swift代码是
TVML应用代理里面的

00:36:07.901 --> 00:36:11.839
我们已为UIApplication
的代理方法实现了一个stub

00:36:11.905 --> 00:36:14.508
来处理自定义的URL方案

00:36:16.910 --> 00:36:20.647
如果我们想把URL
传递到JavaScript中

00:36:20.781 --> 00:36:25.252
需要让appController
去执行block

00:36:25.352 --> 00:36:27.054
在JavaScript的执行环境中

00:36:29.456 --> 00:36:34.995
当block执行完之后
我们将得到JSContext的引用

00:36:35.195 --> 00:36:37.564
从这儿我们可以访问相应的属性

00:36:37.631 --> 00:36:41.235
直接在JavaScript的
全局对象上

00:36:42.903 --> 00:36:48.842
我们可以得到原生的变量和对象且
能将其作为JavaScript属性

00:36:48.909 --> 00:36:51.278
或者就像这个例子中 作为函数的参数

00:36:52.145 --> 00:36:56.283
我们触发打开URL的全局函数

00:36:56.350 --> 00:37:01.822
函数在JavaScript中
定义然后将URL字符串传递进去

00:37:01.889 --> 00:37:04.791
URL来自
UIApplication代理回调

00:37:06.593 --> 00:37:09.897
我们暴露新的函数

00:37:09.963 --> 00:37:12.065
在我们的TVMLKit应用中

00:37:12.165 --> 00:37:14.768
并且将应用的事件
传递到JavaScript中

00:37:18.005 --> 00:37:19.973
接下来 让我们谈论桥接

00:37:20.674 --> 00:37:25.112
使用本地变量是如此的简单

00:37:25.345 --> 00:37:30.450
在JavaScript中
使用这些变量就像使用字符串

00:37:30.517 --> 00:37:32.553
数字和数组那样简单

00:37:32.619 --> 00:37:35.355
这些已经在
JavaScriptCore处理了

00:37:36.890 --> 00:37:39.359
如果你想使用自己的类

00:37:40.060 --> 00:37:43.697
你所要做的是遵循类之间一些简单协议

00:37:43.764 --> 00:37:47.267
JavaScriptCore
也会为你的类进行连接

00:37:47.668 --> 00:37:48.569
让我们看一下

00:37:50.337 --> 00:37:52.139
这儿有三个主要的步骤

00:37:53.106 --> 00:37:59.546
首先你必须声明一个自定义扩展
自JSExport的协议

00:37:59.613 --> 00:38:01.481
JSExport存在于
JavaScriptCore中

00:38:03.350 --> 00:38:08.622
第二 我们需要使用
Swift定义我们的类

00:38:08.755 --> 00:38:13.594
扩展这个协议后然后将它暴露给原生类

00:38:14.761 --> 00:38:18.699
第三 对我们的类进行实例化

00:38:18.765 --> 00:38:21.802
或者将这个类本身暴露出来

00:38:21.869 --> 00:38:26.273
在TV应用控制器的代理上进行回调

00:38:26.373 --> 00:38:30.511
在控制权被交到JavaScript
之前准备JSContext

00:38:30.577 --> 00:38:31.912
在应用启动期间

00:38:34.314 --> 00:38:38.418
让我们看一个方法如何去

00:38:38.485 --> 00:38:42.689
对StoreKit进行包装

00:38:42.756 --> 00:38:45.392
如果我们想把购买的函数暴露给

00:38:46.093 --> 00:38:47.194
给JavaScript

00:38:49.496 --> 00:38:52.599
我们开始定义我们的协议

00:38:53.367 --> 00:38:56.737
在这里我们会指定属性和方法

00:38:56.803 --> 00:39:00.073
使用JavaScriptCore
为我们提供连接

00:39:02.242 --> 00:39:04.378
这里 我将把它作为stub

00:39:04.444 --> 00:39:10.017
看到我们扩展了JSExport且定义了
StoreKitWrapperProtocol的协议

00:39:11.985 --> 00:39:16.590
下一步我将为
StoreKit创建一个包装类

00:39:16.657 --> 00:39:20.627
扩展自NSObject
并且实现自定义的协议

00:39:21.528 --> 00:39:23.997
再次强调 我保留了存根的细节

00:39:24.064 --> 00:39:27.100
但是你要在存根出定义你的原生函数

00:39:27.167 --> 00:39:29.203
这函数你在
JavaScript中调用

00:39:31.972 --> 00:39:37.177
最后 我们实现
TVApplicationControllerDelegate方法

00:39:37.578 --> 00:39:40.547
在执行应用的
JavaScript上下文环境中

00:39:41.148 --> 00:39:44.785
这些会在app.onlaunch
执行之前调用

00:39:44.852 --> 00:39:48.789
并且允许我们去暴露我们自己的函数

00:39:48.856 --> 00:39:51.658
在将控制权移交给
JavaScript之前

00:39:52.926 --> 00:39:54.528
这就是关于原生语言调用
JavaScript的全部内容

00:39:55.028 --> 00:39:57.431
我们定义了一个原生类

00:39:57.497 --> 00:39:59.399
我们使用使用上述步骤
使这个类可访问

00:39:59.466 --> 00:40:01.902
对我们TVML应用
JavaScript来说

00:40:04.938 --> 00:40:09.476
在这个会议上 我们已看到
如何利用原生功能

00:40:09.543 --> 00:40:12.212
提升你的TVML应用

00:40:13.580 --> 00:40:16.817
你可以使用自定义的标记扩展模板

00:40:17.317 --> 00:40:20.187
为你自己的视图和视图集合cell

00:40:20.687 --> 00:40:25.425
在你的原生应用中
你可以获得TVMLKit

00:40:25.492 --> 00:40:29.630
或者在TVMLKit中
使用你的原生视图控制器

00:40:31.098 --> 00:40:34.868
你甚至可以在TVMLKit中
扩展脚本的环境

00:40:35.035 --> 00:40:38.705
连接原生类 应用程序事件

00:40:39.206 --> 00:40:41.141
和加载额外的库

00:40:42.009 --> 00:40:46.847
我们已经展示给大家
它是多么的简单去构建应用的特定功能

00:40:46.914 --> 00:40:50.050
在你的TVMLKit应用中
自定义自己的品牌

00:40:50.918 --> 00:40:54.988
在构建复杂应用时TVMLKit
提供的API是比较简单的

00:40:55.055 --> 00:40:57.891
构建高质量的应用和小的开销

00:40:59.760 --> 00:41:02.629
我希望你能看一下TVML指南

00:41:02.696 --> 00:41:05.566
还有TVML目录下的应用实例

00:41:05.632 --> 00:41:09.403
获取更多的关于扩展和
使用TVMLKit的信息

00:41:10.070 --> 00:41:12.372
你也可以访问Apple开发者网站

00:41:12.439 --> 00:41:15.843
查看编程指南 示例代码和文档

00:41:19.446 --> 00:41:24.484
还可以留意今年 WWDC 2016
的其他演讲内容

00:41:24.551 --> 00:41:28.222
特别是使用TVMLKit
开发应用的第一部分

00:41:28.288 --> 00:41:32.226
里面展示了构建一个完整应用的全过程

00:41:33.126 --> 00:41:36.964
谢谢 希望大家在WWDC 2016
余下的演讲中玩得愉快