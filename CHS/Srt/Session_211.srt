00:00:20.153 --> 00:00:25.225 
WATCHOS快速操作技术

00:00:30.831 --> 00:00:32.332 
大家早上好

00:00:33.834 --> 00:00:35.035 
我叫Tom Witkin

00:00:35.135 --> 00:00:37.371 
Apple watchOS的工程师

00:00:37.437 --> 00:00:40.174 
今早我们将讨论添加快速操作

00:00:40.240 --> 00:00:41.842 
进入Apple Watch应用

00:00:42.309 --> 00:00:44.545 
让我们从这个问题开始

00:00:44.845 --> 00:00:47.147 
我们如何定义快速操作？

00:00:47.548 --> 00:00:51.985 
我很确定你们中的很多人
为iOS或Mac OS开发过应用

00:00:52.052 --> 00:00:54.354 
在那些平台上
我们一般测量

00:00:54.454 --> 00:00:56.857 
用户花在你的应用上的时间

00:00:57.024 --> 00:00:59.293 
尺度是几分钟甚至几小时

00:00:59.393 --> 00:01:01.695 
但是在watchOS中
是另一种情况

00:01:01.795 --> 00:01:03.630 
用户希望可以举起他们的手腕

00:01:03.697 --> 00:01:07.100 
然后快速获得特定信息
或者执行特定操作

00:01:07.201 --> 00:01:09.536 
然后放下他们的手腕
回到他们之前做的事

00:01:09.636 --> 00:01:12.539 
所以交互模型完全不同

00:01:12.606 --> 00:01:15.509 
这里有些关于什么是
Apple Watch快速操作之例

00:01:17.411 --> 00:01:19.613 
比如说开始一个定时器

00:01:22.649 --> 00:01:23.884 
或者查看天气

00:01:27.621 --> 00:01:29.923 
或者从你的购物清单里删除一项

00:01:31.291 --> 00:01:34.795 
我们认为这些是一些操作类型的原型
在Apple Watch上

00:01:34.895 --> 00:01:38.232 
在这背后有一些关键的哲学
你们可能已经在这周听说过

00:01:38.699 --> 00:01:40.734 
首先Apple Watch上的应用

00:01:40.834 --> 00:01:42.069 
他们要易于查看

00:01:42.169 --> 00:01:43.637 
也就是说只需要一瞥

00:01:43.704 --> 00:01:46.139 
你的用户就应该能够获得他们
想要的信息

00:01:47.207 --> 00:01:48.709 
应用要易于操作

00:01:48.775 --> 00:01:51.445 
也就是说用户应该能够作出快速

00:01:51.545 --> 00:01:53.146 
并且获得足够信息的决定

00:01:53.714 --> 00:01:55.082 
最后它们要可响应

00:01:55.182 --> 00:01:57.317 
你应该从不让用户等待

00:01:57.618 --> 00:01:59.720 
如果你有兴趣了解更多

00:01:59.820 --> 00:02:01.088 
我强烈建议你观看

00:02:01.188 --> 00:02:04.491  
今天下午的设计优秀
Apple Watch体验这一演讲

00:02:04.591 --> 00:02:08.729  
或观看watchOS 3新特性演讲

00:02:09.696 --> 00:02:13.200  
现在我们对什么是快速操作
有了初步了解

00:02:13.267 --> 00:02:17.104  
但是Apple Watch上的
快速操作是指多长时间？

00:02:17.905 --> 00:02:20.908 
我们认为理想的操作时间

00:02:21.675 --> 00:02:23.777 
是2秒

00:02:23.844 --> 00:02:25.579 
2秒并不长

00:02:25.679 --> 00:02:29.082 
所以你们不得不仔细考虑
你们的设计

00:02:29.183 --> 00:02:30.817 
以及开发你们的应用

00:02:30.884 --> 00:02:32.719 
但是我们认为这是可以实现的

00:02:32.786 --> 00:02:34.521 
特别是有了这些新特性的帮助

00:02:34.621 --> 00:02:37.224 
我们在watchOS 3中
加入的一个API

00:02:37.824 --> 00:02:39.159 
我们要从这开始

00:02:39.226 --> 00:02:42.029 
通过谈论这些新的特性和API

00:02:42.095 --> 00:02:44.665 
之后我们要谈论一些实用技术

00:02:44.731 --> 00:02:46.099 
你们可以在应用里使用

00:02:46.166 --> 00:02:48.235 
来创建这一类快速操作

00:02:48.836 --> 00:02:51.138 
我要说的就这些
我想把演讲交给我的同事

00:02:51.238 --> 00:02:53.240 
来谈论新特性和API

00:02:54.942 --> 00:02:56.043 
谢谢Tom

00:02:56.143 --> 00:02:58.345 
大家好 我是Miguel

00:02:58.445 --> 00:03:00.380 
我将带你们快速浏览

00:03:00.480 --> 00:03:03.250 
我们在WatchKit里
引入的新API

00:03:03.317 --> 00:03:05.319 
使你们能实现快速操作

00:03:06.887 --> 00:03:09.590 
我将谈论5类API

00:03:09.690 --> 00:03:12.893 
让你们的应用易读 易操作
随时响应

00:03:13.894 --> 00:03:18.198 
首先要让你们可以访问更多新的
输入种类

00:03:18.999 --> 00:03:20.300 
你们现在可以使用手势

00:03:20.400 --> 00:03:22.269 
在你的应用中有手势识别

00:03:23.604 --> 00:03:24.638 
我们要给你访问

00:03:24.705 --> 00:03:27.407 
Digital Crown中的
旋转事件

00:03:28.942 --> 00:03:31.778 
我们还有3个其他方面

00:03:32.279 --> 00:03:35.349 
一是增强的表导航

00:03:35.415 --> 00:03:38.652 
对新的用户通知框架的支持

00:03:38.719 --> 00:03:41.622 
以及集成SpriteKit和SceneKit

00:03:42.422 --> 00:03:43.524 
让我们开始

00:03:44.157 --> 00:03:46.460 
我会给你们API的概览

00:03:46.527 --> 00:03:48.228 
然后 Tom会回到台上

00:03:48.295 --> 00:03:51.431 
向你们展示一些他如何结合这些
API的例子

00:03:52.833 --> 00:03:56.136 
如果你在iOS中使用过手势识别

00:03:56.236 --> 00:03:58.705 
那么你基本上已经知道了几乎
所有需要知道的

00:03:58.805 --> 00:04:01.642 
关于watchOS的手势识别

00:04:01.708 --> 00:04:04.678 
如果你还没有
手势识别是对象

00:04:05.012 --> 00:04:07.481 
用来帮助你分析底层的触摸事件

00:04:07.581 --> 00:04:09.983 
到可识别的手势中

00:04:10.484 --> 00:04:13.187 
我们为4个识别器编写了支持

00:04:13.253 --> 00:04:14.087 
两个离散的

00:04:14.788 --> 00:04:16.255 
SwipeGesture

00:04:17.757 --> 00:04:18.791 
和TapGesture

00:04:18.858 --> 00:04:21.261 
以及两个连续的手势识别器

00:04:23.230 --> 00:04:24.398 
PanGesture

00:04:26.567 --> 00:04:27.835 
和LongPress

00:04:29.336 --> 00:04:30.404 
你使用它们的方法

00:04:30.470 --> 00:04:32.940 
和你在WatchKit中进行的
大部分开发相似

00:04:33.006 --> 00:04:35.609 
是storyboard中的
interface builder

00:04:36.009 --> 00:04:38.879 
你把对象拖入你的界面中

00:04:39.313 --> 00:04:40.747 
如果你看看这个库

00:04:40.814 --> 00:04:43.750 
你可以看到4个识别器实例

00:04:43.817 --> 00:04:45.586 
它们被拖入元素中

00:04:45.652 --> 00:04:48.522 
那些你想要附加手势的元素

00:04:48.922 --> 00:04:52.292 
然后你在检查器中设置
interface builder

00:04:53.293 --> 00:04:56.330 
你要做的最后一件事是把行动
拖入识别器中

00:04:56.430 --> 00:04:59.032 
到你的代码的一个函数里

00:04:59.132 --> 00:05:00.567 
这是一个函数将被调用

00:05:00.634 --> 00:05:02.870 
当手势被系统识别时

00:05:03.370 --> 00:05:06.773 
如你所见一个参数是手势识别器
它自己

00:05:07.841 --> 00:05:10.811 
从中你可以知道位置

00:05:11.178 --> 00:05:13.180 
手势在这个位置被识别

00:05:13.247 --> 00:05:14.281 
这个对象的边界

00:05:14.381 --> 00:05:16.984 
以及手势的状态

00:05:17.985 --> 00:05:20.654 
一些关于手势状态的事

00:05:21.788 --> 00:05:25.192 
手势在被识别前从可能状态开始

00:05:25.259 --> 00:05:28.495 
可能会转变成已识别或失败状态

00:05:28.896 --> 00:05:30.797 
当你处理离散手势时

00:05:30.898 --> 00:05:32.999 
你不需要过多考虑状态

00:05:33.600 --> 00:05:36.403 
你只需要知道当手势被识别时

00:05:36.470 --> 00:05:38.272 
你的行动方法被调用

00:05:39.506 --> 00:05:42.109 
这和连续手势有一点不同

00:05:42.743 --> 00:05:44.912 
它们也从可能状态开始

00:05:45.012 --> 00:05:46.813 
但就像它们的名字所表明的

00:05:47.414 --> 00:05:51.318 
它们会在代码里经历多次更新

00:05:51.385 --> 00:05:55.589 
所以要假设你的行动方法会被
多次调用

00:05:55.656 --> 00:05:57.357 
随着手势的改变

00:05:57.424 --> 00:06:00.060 
给你一个机会更新用户界面

00:06:02.563 --> 00:06:05.065 
一些watchOS中使用手势的提示

00:06:05.866 --> 00:06:09.970 
我们推荐把它们附加到
组元素上

00:06:10.070 --> 00:06:11.972 
而不是控制上
你可以这样做

00:06:12.039 --> 00:06:13.707 
但是你可能会和其他手势冲突

00:06:13.774 --> 00:06:15.809 
那些已经在控制里的手势

00:06:16.276 --> 00:06:18.812 
并且记住你获得一个更小的屏幕

00:06:18.879 --> 00:06:19.880 
在Watch应用中

00:06:19.947 --> 00:06:23.016 
那些组会是更大的界面元素

00:06:23.083 --> 00:06:24.518 
在你的应用中

00:06:25.786 --> 00:06:28.889 
你可以设定手势间的依赖关系

00:06:29.790 --> 00:06:31.792 
但是对watchOS这只可能

00:06:31.892 --> 00:06:34.194 
在查看器及interface
builder中

00:06:35.729 --> 00:06:38.498 
并且注意那些系统手势

00:06:38.599 --> 00:06:41.401 
会优先于你定义的手势

00:06:42.202 --> 00:06:43.036 
比如

00:06:44.004 --> 00:06:46.940 
如果你有一个元素允许滚动

00:06:47.007 --> 00:06:50.711 
并且你想要附加
一个SwipeDown手势

00:06:50.777 --> 00:06:53.680 
它不会被识别
滚动会优先

00:06:53.814 --> 00:06:56.383 
ForceTouch和
LongPress也是同样的

00:06:58.151 --> 00:06:59.987 
让我们继续到第二个输入元素

00:07:00.053 --> 00:07:01.488 
Digital Crown

00:07:02.289 --> 00:07:05.592 
这是一个Apple Watch
独有的元素

00:07:05.659 --> 00:07:09.997 
它允许用户快速准确控制输入

00:07:10.063 --> 00:07:13.166 
从watchOS 2
开始访问Digital Crown

00:07:13.233 --> 00:07:15.769 
通过WKInterfacePicker对象

00:07:17.037 --> 00:07:20.140 
要使用它你要提供一个选取项目
列表

00:07:20.207 --> 00:07:21.475 
并且设置样式

00:07:22.776 --> 00:07:25.078 
WatchKit会为你绘制这些元素

00:07:25.145 --> 00:07:26.580 
这是列表样式

00:07:26.647 --> 00:07:28.415 
你有堆叠样式

00:07:29.082 --> 00:07:31.785 
图片序列样式

00:07:33.353 --> 00:07:34.922 
但是对这个元素

00:07:34.988 --> 00:07:38.125 
WatchKit帮助你处理很多事情

00:07:38.192 --> 00:07:39.359 
我们绘制这个元素

00:07:39.426 --> 00:07:42.663 
我们处理表冠事件的解释

00:07:42.729 --> 00:07:45.799 
我们当一个选择被做出时
调用你的行动

00:07:46.867 --> 00:07:48.202 
在watchOS 3中

00:07:48.268 --> 00:07:51.405 
我们允许你直接访问旋转事件

00:07:51.605 --> 00:07:54.007 
所以你可以编写你自己的UI元素

00:07:54.107 --> 00:07:56.276 
并且用旋转数值来驱动它

00:07:58.212 --> 00:08:00.247 
这能过两个新对象实现

00:08:00.347 --> 00:08:01.882 
通过我们要介绍的新类

00:08:01.949 --> 00:08:05.619 
WKCrownSequencer
它使你能访问旋转事件

00:08:06.453 --> 00:08:08.188 
对不起每秒的旋转数

00:08:08.255 --> 00:08:11.425 
和新的委托协议
WKCrownDelegate

00:08:11.525 --> 00:08:13.760 
在旋转差量上有回调函数

00:08:14.228 --> 00:08:16.563 
所以你会得到2种值

00:08:16.630 --> 00:08:19.366 
每秒的旋转数和旋转差量

00:08:19.867 --> 00:08:22.569 
你怎么处理它们
或者你怎么访问它们?

00:08:23.470 --> 00:08:26.507 
如果你对每秒旋转数感兴趣

00:08:26.573 --> 00:08:28.909 
访问crownSequencer
属性

00:08:28.976 --> 00:08:32.379 
现在出现在所有界面控制器类中

00:08:33.280 --> 00:08:37.217 
你查询它的每秒旋转数属性

00:08:37.284 --> 00:08:38.919 
这可能是你将会用到的东西

00:08:38.986 --> 00:08:41.788 
当你想知道表冠的旋转速度

00:08:41.855 --> 00:08:45.092 
可能是基于物理的动画 游戏
类似这些的东西

00:08:47.694 --> 00:08:50.297 
旋转差量和你通信

00:08:50.364 --> 00:08:52.232 
通过委托协议

00:08:52.299 --> 00:08:56.803 
这使你能够知道表冠的旋转次数

00:08:57.604 --> 00:09:00.574 
你会在crownDidRotate
方法中获得回调

00:09:00.641 --> 00:09:03.844 
rotationalDelta
是一个参数

00:09:05.445 --> 00:09:07.247 
你在这个方法中需要做的

00:09:07.314 --> 00:09:09.616 
是维护一个累加器变量

00:09:09.683 --> 00:09:12.553 
你把我们传给你的
差量加到这个累加器中

00:09:13.153 --> 00:09:16.557 
你要用的数学是一整圈旋转

00:09:16.623 --> 00:09:19.159 
相当于累积的差量是1

00:09:20.694 --> 00:09:24.131 
另一个例子是如果你只想要
侦测到旋转一半

00:09:24.198 --> 00:09:26.500 
你最多积累差量到0.5

00:09:26.567 --> 00:09:28.735 
所以你还是累加我们给你的差量

00:09:28.802 --> 00:09:30.470 
当它们超过阈值时

00:09:30.537 --> 00:09:32.472 
你知道一次旋转发生了

00:09:33.874 --> 00:09:35.876 
这取决于你来断定

00:09:35.943 --> 00:09:37.511 
如何计算这些旋转

00:09:37.578 --> 00:09:40.781 
根据你想要显示的内容的灵敏度

00:09:43.784 --> 00:09:47.120 
当我们向你发送数值时
请注意符号

00:09:47.187 --> 00:09:48.689 
可以是正或负

00:09:49.256 --> 00:09:51.225 
当用户在滚动

00:09:51.291 --> 00:09:53.227 
想让内容上移

00:09:53.293 --> 00:09:55.929 
我们发送正的值

00:09:56.029 --> 00:09:58.532 
当他们滚动想让内容下移

00:09:58.599 --> 00:10:00.033 
我们发送负的值

00:10:00.334 --> 00:10:03.136 
这些值方向无关

00:10:03.203 --> 00:10:06.607 
所以你不需要考虑顺时针逆时针
代表什么

00:10:06.907 --> 00:10:11.545 
如果用户改变表冠的方向

00:10:11.612 --> 00:10:14.882 
我们仍然会给你正或负值

00:10:14.948 --> 00:10:16.383 
为上和下

00:10:16.450 --> 00:10:17.718 
所以你不需要考虑那些

00:10:19.253 --> 00:10:22.089 
最后有一个表冠焦点的概念

00:10:22.155 --> 00:10:25.993 
焦点可以被其他界面元素获取

00:10:26.059 --> 00:10:29.129 
比如一个选择器 一个滑动器
任何可滚动的元素

00:10:29.429 --> 00:10:31.164 
这需要你来决定

00:10:31.231 --> 00:10:35.068 
什么时候界面元素需要取得表冠
的焦点

00:10:35.435 --> 00:10:38.639 
这是一个很好的使用新手势的地方

00:10:39.940 --> 00:10:40.774 
而且

00:10:41.808 --> 00:10:45.179 
一旦你决定你的元素需要重新
获得焦点

00:10:45.245 --> 00:10:47.247 
请调用函数focus

00:10:47.314 --> 00:10:49.283 
并且不要忘了在初始化时调用

00:10:49.349 --> 00:10:52.719 
当你的界面控制器第一次出现

00:10:55.556 --> 00:10:58.425 
让我们把输入元素放一边
说说别的

00:10:58.492 --> 00:11:01.595 
关于我们将引入的垂直填充

00:11:03.096 --> 00:11:07.601 
用户浏览表格的典型方式

00:11:07.668 --> 00:11:09.503 
是选择一行

00:11:09.570 --> 00:11:12.773 
在另一个控制器中查看这一行
的详情

00:11:13.273 --> 00:11:16.176 
他们需要返回主表

00:11:16.243 --> 00:11:19.213 
他们需要选择另一行才能查看详情

00:11:21.114 --> 00:11:24.718 
在watchOS 3中
我们有垂直填充的概念

00:11:25.219 --> 00:11:27.187 
所以在你的表格中启用它时

00:11:27.254 --> 00:11:30.557 
一旦你的用户第一次进入详情

00:11:30.657 --> 00:11:34.127 
他们可以滑动手指或使用表冠

00:11:34.294 --> 00:11:37.531 
上和下来查看随后的详情

00:11:38.198 --> 00:11:42.436 
他们不需要回到主表中

00:11:42.669 --> 00:11:45.005 
使你的应用看起来更有响应性

00:11:46.273 --> 00:11:48.208 
你怎么进入这种模式?

00:11:48.275 --> 00:11:49.743 
这很简单

00:11:49.810 --> 00:11:53.680 
你只需要点选 Item
Pagination复选框

00:11:53.747 --> 00:11:56.316 
在你的表查看器中

00:11:56.884 --> 00:12:01.555 
但是你还需要确定你的表格
使用segues API

00:12:01.955 --> 00:12:05.959 
在这里你告诉我们你想用什么
上下文初始化控制器

00:12:06.026 --> 00:12:07.661 
然后用指定的上下文来初始化它

00:12:07.728 --> 00:12:09.196 
你可能已经在这样做

00:12:11.131 --> 00:12:13.267 
所以这个API并没有改变很多

00:12:13.333 --> 00:12:15.035 
只有一些改变

00:12:15.102 --> 00:12:19.806 
有一个方法允许你用代码进入
连续模式

00:12:20.307 --> 00:12:22.576 
它在你启动应用的时候很有用

00:12:22.643 --> 00:12:27.080 
通过点击一个
complication或通知

00:12:27.147 --> 00:12:29.483 
并且你想直接进入一个特定视图

00:12:29.583 --> 00:12:31.185 
在连续模式下

00:12:32.653 --> 00:12:34.821 
你要知道的第二件事是

00:12:35.789 --> 00:12:37.824 
WatchKit正试着
变聪明并帮助你

00:12:37.891 --> 00:12:39.226 
提升应用速度

00:12:39.293 --> 00:12:41.228 
所以我们为控制器进行预热

00:12:41.295 --> 00:12:44.731 
预测用户会向上或下滚动

00:12:45.232 --> 00:12:48.268 
所以控制器的一些生命周期方法

00:12:48.368 --> 00:12:51.238 
会在元素出现在屏幕前被调用

00:12:51.872 --> 00:12:54.107 
我不会谈论太多细节

00:12:54.174 --> 00:12:57.444 
但是我们有一整个新的场次
为了性能的架构

00:12:57.544 --> 00:12:59.713 
会给你详细的例子

00:12:59.780 --> 00:13:02.149 
关于所有的生命周期方法

00:13:03.417 --> 00:13:05.586 
现在让我们来谈谈通知

00:13:05.686 --> 00:13:09.022 
他们是最快的操作

00:13:09.089 --> 00:13:12.459 
我们最初发布Apple Watch
产品时就引入了

00:13:14.494 --> 00:13:17.731 
所以从用户的角度
你的用户的角度

00:13:18.665 --> 00:13:21.568 
他们操作通知的方式

00:13:21.668 --> 00:13:24.538 
是简单的感觉他们手臂的震动

00:13:25.239 --> 00:13:26.440 
他们抬起手腕

00:13:26.874 --> 00:13:29.877 
他们会自动看到这个短看界面

00:13:29.943 --> 00:13:31.278 
为你的通知

00:13:31.845 --> 00:13:34.948 
如果他们保持手抬起

00:13:35.015 --> 00:13:38.285 
我们转到这个通知的长看界面

00:13:41.488 --> 00:13:44.124 
他们对你通知的反应是

00:13:44.191 --> 00:13:46.493 
我会通过长看的例子

00:13:46.560 --> 00:13:48.262 
有着最多的细节

00:13:50.330 --> 00:13:53.333 
所以如果你已经有了优秀的交流

00:13:53.400 --> 00:13:56.036 
通过使用文字来表现你的
通知的内容

00:13:56.637 --> 00:13:59.106 
他们不需要做任何事
除了删除这条通知

00:13:59.173 --> 00:14:01.175 
这是最短的快速操作

00:14:02.576 --> 00:14:06.046 
他们还可以点击通知来启动应用

00:14:08.415 --> 00:14:09.249 
或者

00:14:09.716 --> 00:14:14.154 
请记住通知可以有与它们相关联
的定制化行动

00:14:14.621 --> 00:14:16.223 
在这个情况下我会展示3个

00:14:16.290 --> 00:14:18.525 
接受 可能 拒绝按钮

00:14:18.659 --> 00:14:20.594 
你最多可以有4个

00:14:21.395 --> 00:14:24.131 
当你把行动和通知关联时

00:14:24.565 --> 00:14:27.067 
他们可以是前台行动

00:14:27.167 --> 00:14:29.369 
就是说如果用户点击按钮

00:14:29.436 --> 00:14:31.605 
你的应用会被激活

00:14:31.839 --> 00:14:33.273 
或者后台行动

00:14:34.341 --> 00:14:39.112 
后台活动在watchOS 2中
永远会被转发给你的手机

00:14:42.115 --> 00:14:45.285 
在watchOS 3中
对通知的一个大改变

00:14:45.352 --> 00:14:49.189 
是有一个全新的通知框架

00:14:50.724 --> 00:14:53.627 
请到介绍通知这个场次

00:14:53.694 --> 00:14:57.331 
去了解关于这个新框架的所有
细节

00:14:58.065 --> 00:15:02.135 
但是对WatchKit开发者
高级的重点有三个

00:15:04.505 --> 00:15:05.706 
你们现在有一套

00:15:05.839 --> 00:15:09.510 
跨平台的类似的通知API

00:15:09.576 --> 00:15:11.778 
iOS tvOS和watchOS

00:15:13.380 --> 00:15:16.884 
我们现在可以在watch上调度通知

00:15:19.219 --> 00:15:21.722 
有后台行动的通知

00:15:21.788 --> 00:15:24.525 
会被发送到你的扩展

00:15:24.591 --> 00:15:26.894 
只要它们是在Watch上调度的

00:15:30.364 --> 00:15:31.665 
让我们来看看API

00:15:32.900 --> 00:15:35.903 
新的UNUserNotificationCenter
对象

00:15:35.969 --> 00:15:38.205 
你想要成为这个对象的代表

00:15:38.272 --> 00:15:42.676 
当applicationDidFinishLaunching
方法启动你的应用时

00:15:43.443 --> 00:15:44.611 
你想要指出

00:15:44.678 --> 00:15:48.515 
你要采用notification
center 委托协议

00:15:49.216 --> 00:15:52.119 
这个协议的2个方法对你很有用

00:15:52.219 --> 00:15:54.421 
第1个是willPresent方法

00:15:54.922 --> 00:15:57.925 
它会被调用
当你的应用已经被激活

00:15:58.458 --> 00:15:59.960 
在表盘上

00:16:01.261 --> 00:16:03.564 
系统会给你一个机会告诉它

00:16:03.630 --> 00:16:05.966 
你想要系统怎么处理那条通知

00:16:06.667 --> 00:16:09.002 
所以根据你的决定

00:16:09.069 --> 00:16:10.838 
在完成处理器这

00:16:11.205 --> 00:16:13.373 
系统将会做二件事中的一件

00:16:14.374 --> 00:16:17.311 
如果你要用警告选项

00:16:17.678 --> 00:16:21.281 
我们将会返回普通的长看界面

00:16:21.348 --> 00:16:25.085 
属于这个通知并且它会覆盖在
你的应用之上

00:16:26.119 --> 00:16:27.988 
如果你不想做任何事

00:16:28.055 --> 00:16:30.257 
那表明系统不应该做任何事

00:16:30.591 --> 00:16:32.192 
因为你的应用已经被激活

00:16:32.259 --> 00:16:35.529 
你需要处理显示通知内容

00:16:35.596 --> 00:16:37.231 
在你的应用里用某些方式

00:16:38.699 --> 00:16:41.602 
第二个方法是
didReceive响应

00:16:42.469 --> 00:16:45.038 
当你的用户在通知上采取行动

00:16:45.772 --> 00:16:48.642 
这是程序变成前台运行时的
回调函数

00:16:48.709 --> 00:16:50.444 
因为用户点击了按钮

00:16:50.978 --> 00:16:54.248 
这也是watchOS 3新的入口点

00:16:54.314 --> 00:16:57.317 
在这你可以得到后台行动的回调

00:16:57.684 --> 00:16:59.653 
但是请记住这只作用于后台行动

00:16:59.720 --> 00:17:01.755 
是由Watch自己调度的后台行动

00:17:03.657 --> 00:17:05.692 
现在是快速回顾的好时机

00:17:05.759 --> 00:17:10.063 
回顾在Apple Watch上
调度和传送通知

00:17:11.031 --> 00:17:13.867 
任何时候手机触发一个通知

00:17:14.667 --> 00:17:18.672 
它被转发给Watch
如果手机屏幕关闭

00:17:18.739 --> 00:17:21.275 
而且你戴着Watch并且它被解锁

00:17:21.742 --> 00:17:23.676 
永远都会是这种行为

00:17:25.311 --> 00:17:26.646 
但在watchOS 3中

00:17:26.713 --> 00:17:29.082 
你可以调度你自己的通知

00:17:29.149 --> 00:17:30.584 
在Apple Watch上

00:17:31.218 --> 00:17:34.488 
请记住它们只被发送到Watch上

00:17:34.555 --> 00:17:36.056 
如果你的应用需要

00:17:36.123 --> 00:17:40.327 
在手机上也有相应的通知

00:17:40.427 --> 00:17:42.796 
你需要和手机通讯

00:17:42.863 --> 00:17:44.898 
并且在那调度你的通知

00:17:45.499 --> 00:17:48.368 
现在你可能想知道
如果我调度多个通知

00:17:48.435 --> 00:17:50.204 
如果它们都触发了会发生什么?

00:17:51.305 --> 00:17:54.908 
你可以删除重复通知

00:17:54.975 --> 00:17:56.743 
只要你使用相同的识别符

00:17:56.810 --> 00:17:58.278 
在Watch上

00:17:58.345 --> 00:18:00.447 
和在iPhone上
对这个通知

00:18:01.081 --> 00:18:02.816 
如果我们在这种情况

00:18:02.883 --> 00:18:05.686 
我们转发通知给Watch

00:18:06.753 --> 00:18:08.589 
我们首先查看识别符

00:18:08.722 --> 00:18:11.158 
如果还存在通知有相同的识别符

00:18:11.225 --> 00:18:12.793 
当时在Watch上被触发

00:18:12.860 --> 00:18:15.128 
这有更高的优先级并且被显示

00:18:15.195 --> 00:18:18.232 
这样用户就不会同时
看到两条相同通知

00:18:21.768 --> 00:18:25.639 
最后让我们谈谈SpriteKit
以及SceneKit对象

00:18:27.174 --> 00:18:30.210 
SpriteKit和SceneKit
提供丰富的API

00:18:30.277 --> 00:18:33.146 
它们允许你进行2D和3D绘制

00:18:33.213 --> 00:18:35.582 
它们允许你极大的扩展

00:18:35.649 --> 00:18:37.985 
你应用的视觉语言

00:18:39.486 --> 00:18:42.389 
我们有2个类为了WatchKit

00:18:42.789 --> 00:18:44.691 
支持这些框架

00:18:44.758 --> 00:18:48.195 
针对SpriteKit
的WKInterfaceSKScene

00:18:48.929 --> 00:18:52.499 
针对SceneKit
的WKInterfaceSCNScene

00:18:54.101 --> 00:18:56.303 
你们还是进行所有的设置

00:18:56.370 --> 00:18:58.505 
在storyboard
以及interface builder中

00:18:59.406 --> 00:19:02.543 
你现在可以看到这两个类出现在
库中

00:19:04.278 --> 00:19:06.547 
你只需要把它们拖入你的控制器

00:19:06.613 --> 00:19:10.317 
它们就会提供绘制场景的画布

00:19:10.617 --> 00:19:12.252 
然后设置就完成了

00:19:12.819 --> 00:19:14.955 
在查看器和interface builder中

00:19:17.858 --> 00:19:20.027 
一旦你准备好显示场景

00:19:20.661 --> 00:19:24.164 
SpriteKit和SceneKit
所有代码保持原样

00:19:24.231 --> 00:19:26.200 
你继续使用API

00:19:26.266 --> 00:19:29.303 
我不会讨论那些框架本身的API

00:19:30.003 --> 00:19:33.006 
但是一旦你的场景准备好显示

00:19:33.373 --> 00:19:36.710 
和WatchKit集成
来显示场景很简单

00:19:37.010 --> 00:19:39.179 
如果你在处理SpriteKit场景

00:19:39.246 --> 00:19:40.848 
你调用百分比函数

00:19:41.882 --> 00:19:44.751 
或者几个函数
取决于你是否有过渡

00:19:45.485 --> 00:19:47.721 
如果你有一个SceneKit场景

00:19:47.821 --> 00:19:52.159 
你只需要在对象里设置场景的属性

00:19:53.360 --> 00:19:56.330 
这就是集成需要做的所有事

00:19:58.232 --> 00:20:00.334 
我已经带你们快速回顾了

00:20:00.400 --> 00:20:03.203 
你们拥有的新的工具包项目

00:20:03.504 --> 00:20:05.672 
来开发易于查看 易于操作

00:20:05.739 --> 00:20:07.908 
可响应的应用

00:20:08.342 --> 00:20:11.078 
现在Tom会回来给出一些特定例子

00:20:11.144 --> 00:20:13.847 
关于怎样结合多个界面

00:20:14.147 --> 00:20:16.049 
让你的应用有更好的响应性

00:20:16.216 --> 00:20:17.050 
谢谢

00:20:23.357 --> 00:20:25.225 
好的
现在我们有了工具包

00:20:25.292 --> 00:20:27.160 
所以我们可以来看一些实用技术

00:20:27.227 --> 00:20:29.796 
要创建这些快速操作

00:20:30.497 --> 00:20:32.900 
我们要谈谈
增加complications

00:20:32.966 --> 00:20:35.736 
和通知在你的应用中
现在这些并不是新东西

00:20:35.802 --> 00:20:38.605 
但是我们要谈谈它们的一些
独特的新方式

00:20:39.540 --> 00:20:41.275 
之后我们会谈谈

00:20:41.341 --> 00:20:44.077 
在apps有一个简单的浏览模型

00:20:44.711 --> 00:20:45.913 
最后我们会谈谈

00:20:45.979 --> 00:20:48.582 
给你的用户放下手腕的信心

00:20:48.649 --> 00:20:51.585 
在他们在你的应用里完成操作后

00:20:52.219 --> 00:20:54.855 
我们从易于操作的
complications开始

00:20:55.656 --> 00:20:59.593 
在watchOS 2中对第三方应用
引入了complications

00:20:59.660 --> 00:21:02.462 
在watchOS 3中
它们扮演更重要的角色

00:21:03.063 --> 00:21:05.832 
现在有更多的表盘
有complications

00:21:06.033 --> 00:21:09.870 
有一些已有的表盘有更多的
complication插槽

00:21:10.270 --> 00:21:12.739 
现在你可以快速滑动

00:21:13.774 --> 00:21:17.778 
在你的表盘间来查看
所有complications

00:21:17.845 --> 00:21:20.280 
因此我们认为每个应用

00:21:20.347 --> 00:21:22.850 
Apple Watch
都该有complication

00:21:22.916 --> 00:21:26.386 
你还什么看到所有原生apps
都有complications

00:21:26.453 --> 00:21:28.655 
比如健身应用和心率应用

00:21:29.723 --> 00:21:30.991 
为何有complications？

00:21:31.358 --> 00:21:33.827 
它们非常易读
它们永远在手腕上

00:21:33.894 --> 00:21:37.197 
只要一眼就能看到很多重要信息

00:21:38.198 --> 00:21:39.566 
它们频繁更新

00:21:39.633 --> 00:21:42.503 
若你的应用在当前表盘
上有complication

00:21:42.569 --> 00:21:44.571 
它每小时至少更新2次

00:21:44.638 --> 00:21:46.640 
你能确保新鲜

00:21:46.707 --> 00:21:49.443 
以及当前的数据
用户部是可以得到这些

00:21:50.744 --> 00:21:52.079 
你的应用会保留在内存里

00:21:52.145 --> 00:21:53.680 
这很重要

00:21:53.780 --> 00:21:56.717 
因为这使你应用的启动很快

00:21:56.783 --> 00:21:58.952 
使你应用里的很多操作

00:21:59.019 --> 00:22:00.587 
响应更快

00:22:01.889 --> 00:22:06.159 
而且complications提供
一种方式使用户更快进入应用

00:22:06.226 --> 00:22:08.495 
来完成特定功能

00:22:09.263 --> 00:22:12.733 
比如我们来看
音乐complication

00:22:12.799 --> 00:22:15.502 
我点击它
我直接进入现在播放界面

00:22:15.569 --> 00:22:18.539 
如果我在播放音乐这对我最重要

00:22:18.605 --> 00:22:21.241 
我可以播放 暂停 跳过一首歌

00:22:21.308 --> 00:22:23.877 
这使整个操作快得多

00:22:23.944 --> 00:22:26.113 
因为我直接进入我想要的界面

00:22:27.814 --> 00:22:31.552 
watchOS 3和iOS 10中
新出现的是新画廊

00:22:31.618 --> 00:22:33.720 
在iPhone的
Apple Watch应用中

00:22:33.954 --> 00:22:37.558 
这很好因为它允许你在
Apple Watch中添加新表盘

00:22:37.624 --> 00:22:40.260  
它还允许你定制表盘

00:22:40.327 --> 00:22:42.095  
并在complications中
选择

00:22:42.162 --> 00:22:44.765  
第三方complications
也会出现在这

00:22:44.831 --> 00:22:47.968  
这方便用户
发现你的complications

00:22:48.068 --> 00:22:50.137  
并把它直接加入表盘

00:22:51.138 --> 00:22:53.173 
如果你想成为这些
complications的一部分

00:22:53.240 --> 00:22:54.808 
你创建一个
complication捆绑

00:22:54.875 --> 00:22:57.544 
在开发者网站上有相关文档

00:22:57.611 --> 00:22:59.479 
我强烈建议你们去看一下

00:23:00.280 --> 00:23:03.717 
所以Apple Watch上的
complications机制很棒

00:23:03.784 --> 00:23:05.385 
使用户进入你的应用

00:23:05.485 --> 00:23:07.721 
并提供一系列快速操作

00:23:07.821 --> 00:23:10.390 
如果你的当前应用
没有complication

00:23:10.490 --> 00:23:12.993 
或者你正在开发新应用
请确保你包括它们

00:23:14.795 --> 00:23:17.898 
接下来我们来到易读的通知

00:23:17.998 --> 00:23:20.100 
我们都知道通知

00:23:20.167 --> 00:23:22.069 
在Apple Watch上很优秀

00:23:22.503 --> 00:23:26.139 
一个主要原因是它们完全可定制

00:23:26.206 --> 00:23:28.709 
你可以把它们弄成任意你想要的
样子

00:23:29.076 --> 00:23:33.213 
而且它允许你显示真正有价值的
信息

00:23:33.280 --> 00:23:35.516 
在通知中

00:23:35.616 --> 00:23:37.885 
比如这是一个日历通知

00:23:37.951 --> 00:23:41.054 
我可以看到事件的名称
时间 地点

00:23:41.421 --> 00:23:42.656 
而且

00:23:42.723 --> 00:23:44.625 
这经常可以去除一种必要性

00:23:44.691 --> 00:23:46.226 
启动Watch应用的必要性

00:23:46.293 --> 00:23:49.363 
因为重要的信息都内联了

00:23:49.429 --> 00:23:50.697 
在通知中

00:23:51.231 --> 00:23:54.968 
在watchOS 3中
所有通知都支持SpriteKit

00:23:55.068 --> 00:23:56.904 
和SceneKit以及内联视频

00:23:56.970 --> 00:23:59.473 
所以你能提供更多定制

00:23:59.540 --> 00:24:00.874 
在你的通知中

00:24:02.176 --> 00:24:03.510 
所以SpriteKit和SceneKit

00:24:03.577 --> 00:24:06.213 
我确定你们中的很多人认为是
为了游戏

00:24:06.280 --> 00:24:07.447 
而且他们确实利于游戏

00:24:07.514 --> 00:24:10.918 
在周五会有一个场次
关于Apple Watch的游戏

00:24:11.084 --> 00:24:15.155 
但是在这里我想要谈谈它们
非游戏的界面

00:24:15.756 --> 00:24:17.925 
为什么它们对非游戏重要?

00:24:18.292 --> 00:24:22.229 
它们允许你完全定制内容

00:24:22.296 --> 00:24:25.399 
和布局以及你界面的动画

00:24:25.465 --> 00:24:29.069 
所以这允许你创建定制化的外观

00:24:29.636 --> 00:24:32.873 
我们来看一个Photos应用的例子

00:24:32.940 --> 00:24:35.809 
你可以看到我获得
来自我的朋友Ivy的通知

00:24:35.876 --> 00:24:37.711 
她向我分享了一些照片

00:24:38.145 --> 00:24:40.180 
这不包括很多信息

00:24:40.247 --> 00:24:41.982 
我不知道这些照片是关于什么

00:24:42.049 --> 00:24:44.751 
我需要阅读文字来知道谁分享了
它们

00:24:44.818 --> 00:24:47.888 
这样我们可以获得很多好处

00:24:47.955 --> 00:24:51.124 
从通知的可定制性中

00:24:51.959 --> 00:24:55.529 
所以现在有另一种方法
在顶部使用SpriteKit

00:24:55.596 --> 00:24:57.998 
它包括共享给我的相片

00:24:58.065 --> 00:25:00.067 
它有我朋友Ivy的相片

00:25:00.133 --> 00:25:02.703 
只需要瞥一眼我就可以获得
大量信息

00:25:02.769 --> 00:25:05.739 
最终我可以获得更多信息来做决定

00:25:05.806 --> 00:25:08.008 
我是否需要启动Watch应用

00:25:08.075 --> 00:25:10.878 
或者拿出我的iPhone来查看
关于相片的更多信息

00:25:12.479 --> 00:25:14.014 
我们来看看这是如何实现的

00:25:14.081 --> 00:25:17.618 
在顶部我们有新的
WKInterfaceSKScene对象

00:25:18.051 --> 00:25:20.854  
在那之下我们有一个普通标签

00:25:20.921 --> 00:25:24.157  
我想要指出这里的关键之处是你
混合搭配

00:25:24.224 --> 00:25:27.127  
SpriteKit和
WatchKit界面元素

00:25:27.194 --> 00:25:29.863  
也许你正在使用动画图像

00:25:29.930 --> 00:25:31.798  
或者视图动画API

00:25:31.865 --> 00:25:33.834 
你可以用SpriteKit替换它们

00:25:34.134 --> 00:25:36.737 
或者你想要添加动画到已有界面

00:25:36.803 --> 00:25:39.773 
你不需要为了采用SpriteKit
而重写一切

00:25:39.840 --> 00:25:42.643  
所以它提供一种强大的方式
来添加更丰富的内容

00:25:42.709 --> 00:25:43.810  
到你的界面中

00:25:43.877 --> 00:25:47.314  
而无需抛弃已有的一切重新开始
这很酷

00:25:48.782 --> 00:25:50.617 
如果你的应用中有通知

00:25:50.684 --> 00:25:53.554 
请确保充分发挥它们提供的优势

00:25:53.687 --> 00:25:55.722 
如果你只想要默认界面

00:25:55.789 --> 00:25:57.958 
考虑什么信息是真正重要的

00:25:58.025 --> 00:25:59.426 
在通知里

00:25:59.493 --> 00:26:01.762 
添加一个定制界面来反映它

00:26:03.864 --> 00:26:05.399 
接下来让我们来到

00:26:05.465 --> 00:26:09.069 
你应用中的一个简单浏览模型

00:26:09.703 --> 00:26:13.006 
早前我们谈论了表格的新的
垂直填充API

00:26:13.073 --> 00:26:15.609 
它对所有分层的应用都有利

00:26:15.676 --> 00:26:17.578 
但是在这里我们想谈谈浏览

00:26:17.644 --> 00:26:20.414 
关于另外两种技术

00:26:20.881 --> 00:26:23.650 
它们是手势和
Digital Crown

00:26:23.717 --> 00:26:26.620 
Digital Crown
是Apple Watch特有的

00:26:26.687 --> 00:26:29.189 
它是一个很好的输入机制

00:26:29.556 --> 00:26:32.726 
它允许你快速精确地操作界面

00:26:32.793 --> 00:26:35.529 
它用很多种使用方法

00:26:35.996 --> 00:26:38.198 
比如计时器应用

00:26:38.265 --> 00:26:41.668 
它可以快速通过不同的时长来
选择你想要的时间

00:26:42.469 --> 00:26:44.805 
或者在Photos应用中它可以

00:26:44.872 --> 00:26:46.907 
放大缩小相片

00:26:47.741 --> 00:26:51.245 
你如何在应用中使用 Digital
Crown可很有创造性

00:26:51.311 --> 00:26:53.647 
我们对你怎样使用它感到兴奋

00:26:53.881 --> 00:26:55.716 
在这我们想通过一些例子

00:26:55.782 --> 00:26:57.384 
通过一个跑步应用

00:26:57.451 --> 00:26:59.720 
使用手势和
Digital Crown

00:26:59.786 --> 00:27:01.188 
来简化浏览

00:27:02.155 --> 00:27:04.224 
我们有一个跑步应用

00:27:04.291 --> 00:27:06.560 
目的是显示我之前的跑步

00:27:06.627 --> 00:27:10.430 
并且显示平均时间 距离 高度

00:27:11.031 --> 00:27:13.967 
一个版本是有一个关于每一英里
的列表

00:27:14.034 --> 00:27:16.837 
我可能点击一英里来看更多信息

00:27:16.937 --> 00:27:19.439 
或者我滚动列表来看跑步全程

00:27:19.973 --> 00:27:23.377 
这个版本有我需要的所有信息

00:27:23.544 --> 00:27:26.380 
你不得不找来找去来寻找你想要的

00:27:26.446 --> 00:27:28.782 
你需要点击一行
你需要滚动这个列表

00:27:28.849 --> 00:27:31.218 
信息的密度不易读

00:27:31.285 --> 00:27:34.087 
这绝对可以用更好的方式实现

00:27:35.255 --> 00:27:37.758 
这是一个使用SpriteKit的
替代方案

00:27:37.824 --> 00:27:40.661 
使顶部有一个图表
显示跑步全程

00:27:40.727 --> 00:27:43.997 
只需要一瞥我可以看到更多信息

00:27:44.498 --> 00:27:47.100 
现在有了手势
我可以点击图表

00:27:47.334 --> 00:27:50.304 
它会在步速和高度中使用动画

00:27:51.205 --> 00:27:54.141 
用Digital Crown
在图表中浏览

00:27:54.208 --> 00:27:55.909 
到达特定的数据点

00:27:56.910 --> 00:27:59.346 
虽然屏幕上有很多信息

00:27:59.413 --> 00:28:01.148 
浏览变得更容易

00:28:01.215 --> 00:28:03.951 
要到达我在寻找的特定信息

00:28:04.017 --> 00:28:06.854 
使得整个操作更快

00:28:07.621 --> 00:28:09.823 
如你所见我们开始混合搭配

00:28:09.890 --> 00:28:11.792 
我们介绍的所有技术

00:28:11.859 --> 00:28:14.561 
手势 Digital Crown
和SpriteKit

00:28:14.862 --> 00:28:17.231 
它们创造出一些很强大的组合

00:28:17.531 --> 00:28:19.733 
当你开发自己的应用时

00:28:19.800 --> 00:28:22.936 
你应该确保考虑过这些技术

00:28:23.036 --> 00:28:26.273 
并看看它们能怎样帮助简化你
应用的浏览

00:28:26.573 --> 00:28:30.978 
我们把很多时间花在
watchOS 3的浏览上

00:28:31.044 --> 00:28:33.247 
我们很想确保它

00:28:33.313 --> 00:28:36.416 
也进入到你们的应用里

00:28:39.419 --> 00:28:42.155 
最后我们要谈一个技术

00:28:42.456 --> 00:28:44.658 
允许你的用户放下手腕

00:28:44.725 --> 00:28:46.593 
一旦他们完成操作

00:28:47.194 --> 00:28:50.264 
在Apple Watch上
完成快速操作的一个关键方面

00:28:50.330 --> 00:28:53.267 
是使你的应用有很好的响应性

00:28:53.467 --> 00:28:57.037 
特别是你要用到任何类型的网络

00:28:57.104 --> 00:28:59.206 
或者要和iPhone通讯

00:28:59.606 --> 00:29:01.241 
因为通常这样

00:29:01.308 --> 00:29:03.844 
会引入载入指示符
这并不是很好

00:29:04.444 --> 00:29:05.879 
它的一方面是

00:29:05.946 --> 00:29:07.915 
如果你在应用中更新数据

00:29:07.981 --> 00:29:10.851 
这是一个很大的话题我们实际上
可以花一整场时间来讨论

00:29:10.918 --> 00:29:12.886  
使你的Watch应用保持最新状态

00:29:12.953 --> 00:29:14.454  
请确保去看了这个演讲

00:29:14.955 --> 00:29:18.992  
但是我们现在想讨论响应用户
操作时的网络问题

00:29:19.526 --> 00:29:22.329 
例如我们有食品派送应用

00:29:22.429 --> 00:29:25.165 
你想买一些食品并点击购买按钮

00:29:25.232 --> 00:29:27.901 
你的应用在这种情况下应当怎样
响应?

00:29:29.570 --> 00:29:32.639 
我们建议你立即提供反馈

00:29:32.706 --> 00:29:35.275 
向你的用户
而不是显示一个载入指示符

00:29:35.809 --> 00:29:38.312 
我们会用一个例子来解释那
是什么意思

00:29:38.412 --> 00:29:41.081 
这是我在谈论的食品派送应用

00:29:41.682 --> 00:29:44.351 
我可以点击我最喜欢的商品
那有一个大的购买按钮

00:29:44.418 --> 00:29:47.487 
我们认为这会是一个很快的操作

00:29:47.654 --> 00:29:50.891 
我点击购买
我得到一个载入指示符

00:29:51.725 --> 00:29:54.494 
因为应用要和服务器通讯

00:29:54.561 --> 00:29:57.531 
它需要处理这个订单
它需要得到确认

00:29:57.898 --> 00:29:59.299 
一旦它完成了

00:29:59.466 --> 00:30:01.268 
它需要发送回Watch

00:30:01.335 --> 00:30:04.771 
此时它才可以移除载入指示符

00:30:04.838 --> 00:30:06.640 
并且说 “你的订单在路上了”

00:30:07.274 --> 00:30:10.110 
如果我们看看它的时间线
就会发现问题

00:30:10.177 --> 00:30:11.745 
我们从选择商品开始

00:30:11.979 --> 00:30:12.980 
我们点击购买

00:30:13.747 --> 00:30:15.682 
然后显示载入指示符

00:30:15.782 --> 00:30:16.617 
在这期间

00:30:16.683 --> 00:30:19.319 
用户只能抬着手腕看着你的应用

00:30:19.686 --> 00:30:21.555  
直到你显示确认

00:30:21.822 --> 00:30:24.258  
用户仅仅进行操作

00:30:24.324 --> 00:30:26.026  
在开始和结束阶段

00:30:26.093 --> 00:30:28.295 
大部分时间用来等待

00:30:28.629 --> 00:30:31.899 
我们绝对可以改进这类操作

00:30:32.933 --> 00:30:36.670 
如果我们回到我们的食品应用

00:30:36.737 --> 00:30:39.940 
点击购买按钮
我们马上得到反馈

00:30:40.474 --> 00:30:42.376 
关键是这并不是确认

00:30:42.442 --> 00:30:44.278 
因为我们还没有进行网络通信

00:30:44.344 --> 00:30:46.013 
我们不能说订单已经在路上

00:30:46.079 --> 00:30:47.414 
因为我们不知道

00:30:47.481 --> 00:30:51.552 
但是我们想提供反馈
并让用户相信

00:30:51.618 --> 00:30:53.787 
应用在处理他们的订单

00:30:53.954 --> 00:30:56.523 
并允许用户放下手腕

00:30:56.590 --> 00:30:58.825 
不需要等待应用

00:30:59.393 --> 00:31:01.695 
现在在后台应用会用

00:31:01.762 --> 00:31:04.398 
一个后台NSURLSession

00:31:04.665 --> 00:31:06.366 
来和服务器通讯

00:31:06.433 --> 00:31:08.235 
并最终获得响应

00:31:08.602 --> 00:31:11.238 
然后应用在后台被唤醒

00:31:11.338 --> 00:31:13.740 
现在它可以使用本地通知支持

00:31:14.208 --> 00:31:17.611 
来说“好的现在你的订单
已经确认了 它在路上”

00:31:17.778 --> 00:31:20.814 
然后你有和之前相同的信息

00:31:21.682 --> 00:31:22.816 
看看这种情况的时间线

00:31:22.883 --> 00:31:26.153 
它显示这样有怎样的提升

00:31:26.220 --> 00:31:29.256 
我们选择商品 点击购买
我们以相同方式开始

00:31:29.957 --> 00:31:32.125 
接下不不是显示载入指示符

00:31:32.192 --> 00:31:33.227 
我们显示反馈

00:31:33.861 --> 00:31:35.629 
在我们完成网络通信之后

00:31:35.696 --> 00:31:36.930  
我们显示通知

00:31:37.698 --> 00:31:40.501  
从应用的角度来看
总的操作

00:31:40.567 --> 00:31:43.837  
和前一种情况一样

00:31:44.438 --> 00:31:46.073  
但是从用户的角度来看

00:31:46.440 --> 00:31:49.676  
感觉更快响应性更好

00:31:49.776 --> 00:31:52.045 
所以是一个更好的互动

00:31:52.646 --> 00:31:54.815 
我想要指出在这你实际上可以
怎么

00:31:54.882 --> 00:31:57.551 
在用户放下手腕后进行处理

00:31:57.618 --> 00:31:59.019 
如果你进行网络通信

00:31:59.219 --> 00:32:02.089 
你可用后台NSURLSession

00:32:02.155 --> 00:32:03.690 
并确保使用一个下载任务

00:32:03.757 --> 00:32:07.494 
这将允许你的应用在任务完成后
在后台被唤醒

00:32:07.561 --> 00:32:10.097 
在这时
你可以进行本地通知

00:32:10.163 --> 00:32:11.765 
这对你的应用有意义

00:32:12.833 --> 00:32:16.036 
或者你需要在Watch中进行处理

00:32:16.103 --> 00:32:18.472 
你可以使用一个后台任务判定

00:32:18.539 --> 00:32:19.673 
我们对它有很好的介绍

00:32:19.740 --> 00:32:22.176 
在去年的会话中
WatchKit提示和技巧

00:32:22.242 --> 00:32:25.145 
如果你要做任何处理请去看它

00:32:25.212 --> 00:32:26.313 
在Watch本身处理

00:32:27.047 --> 00:32:29.449 
2秒是一个大胆的目标

00:32:29.516 --> 00:32:32.819  
就Apple Watch上的
互动应该多快而言

00:32:32.886 --> 00:32:34.621  
但我们认为它应该就是目标

00:32:34.688 --> 00:32:36.023  
当你开发你的应用时

00:32:36.089 --> 00:32:40.027  
因为它会告诉你怎样设计和开发应用

00:32:40.627 --> 00:32:43.564  
所以当你要开发新应用时

00:32:43.630 --> 00:32:45.632  
或者思考你已有的应用

00:32:45.699 --> 00:32:48.836 
确保在一开始就关注快速操作

00:32:49.002 --> 00:32:50.737 
思考什么特性

00:32:50.804 --> 00:32:53.907 
是你的用户想在你的应用上使用的

00:32:53.974 --> 00:32:56.476 
确保它们出现在最前

00:32:56.543 --> 00:32:58.545 
并且确实很快响应性很好

00:32:59.746 --> 00:33:01.715 
使用complications
和通知

00:33:01.782 --> 00:33:05.085 
因为它们带来很快的操作

00:33:05.152 --> 00:33:10.357 
它们为你的应用带来很多可用性

00:33:12.192 --> 00:33:15.963 
使用SceneKit和
SpriteKit创建丰富

00:33:16.029 --> 00:33:18.298 
且可操作的界面

00:33:18.365 --> 00:33:20.534 
它们能带来很多能力

00:33:20.601 --> 00:33:23.136 
为你新的和已有的应用

00:33:23.203 --> 00:33:25.772 
我们对你们将用它们做什么
感到兴奋

00:33:26.907 --> 00:33:28.342 
简化浏览

00:33:28.408 --> 00:33:31.445 
再一次 watchOS做了很多工作

00:33:31.512 --> 00:33:34.081 
在系统层面简化浏览

00:33:34.147 --> 00:33:38.018 
但是我们也希望那也发生在所有
的应用中

00:33:39.686 --> 00:33:41.522 
再一次 永远不要让用户等待

00:33:41.588 --> 00:33:43.557 
如果你在屏幕上显示载入指示符

00:33:43.624 --> 00:33:47.494 
试着重新组织你的应用
允许用户放下手腕

00:33:47.561 --> 00:33:50.364 
立即提供反馈
并让用户相信

00:33:50.464 --> 00:33:52.332 
你的应用在处理事情

00:33:53.300 --> 00:33:56.103 
想了解我们今天谈论的话题的
更多信息

00:33:56.170 --> 00:33:57.804 
去查看开发者网站

00:33:58.272 --> 00:34:00.641 
这周有很多演讲我都强烈推荐

00:34:00.707 --> 00:34:03.777 
今天下午的
设计优秀Apple Watch体验

00:34:03.844 --> 00:34:06.213 
或者明天的watchOS演讲

00:34:07.147 --> 00:34:08.715 
就这些了
谢谢今天到这来

00:34:08.782 --> 00:34:10.951 
请在旧金山享受这种接下来的时光