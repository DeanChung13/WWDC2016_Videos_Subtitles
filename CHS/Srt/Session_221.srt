00:00:19.486 --> 00:00:24.491
优化按需加载资源

00:00:25.859 --> 00:00:28.228
欢迎来到优化按需加载资源

00:00:28.295 --> 00:00:31.064
我是tvOS工程师团队
的Bill Bumgarner

00:00:32.766 --> 00:00:37.337
在这个演讲上 在去年的WWDC上

00:00:37.404 --> 00:00:39.506
在这一年的开发者厨房

00:00:39.573 --> 00:00:42.709
我们已经讲了如何使用按需加载资源

00:00:43.010 --> 00:00:44.611
本场演讲中 我们想要关注在

00:00:44.678 --> 00:00:47.748
如何优化资源的使用 特别是

00:00:47.814 --> 00:00:50.417
如何打磨用户体验 来真正地创造

00:00:50.484 --> 00:00:52.653
一个极好的用户体验

00:00:53.053 --> 00:00:56.190
我们来看一下这些动机的一个基本概况

00:00:56.256 --> 00:00:59.593
如何指定标签 API的使用

00:00:59.660 --> 00:01:02.396
然后讲一下如何优化首次启动

00:01:02.462 --> 00:01:05.799
如何优化运行中的用户体验

00:01:05.866 --> 00:01:08.235
同时也会讲一下优化应用更新

00:01:08.302 --> 00:01:10.771
和一些实现的细节

00:01:13.674 --> 00:01:15.709
所以为什么

00:01:15.776 --> 00:01:17.878
为什么要按需加载资源

00:01:17.945 --> 00:01:20.914
对于一个传统的应用程序

00:01:20.981 --> 00:01:24.518
它是由应用程序的二进制值
和一堆资源所构成的

00:01:24.585 --> 00:01:26.720
这些一起组成了应用束

00:01:27.054 --> 00:01:29.423
它被组合在一起 上传到商店

00:01:30.123 --> 00:01:32.893
你们的用户可以下载并安装它

00:01:32.960 --> 00:01:36.363
慢慢地 他们会下载和安装一堆的应用

00:01:37.231 --> 00:01:39.867
但是如果你看一下这些应用的使用模式

00:01:39.933 --> 00:01:45.405
我们会发现
只有一部分的资源被经常用到

00:01:45.806 --> 00:01:47.641
另外一些资源可能只被用了一次

00:01:47.708 --> 00:01:49.710
在程序介绍或类似的其它地方

00:01:50.844 --> 00:01:53.280
而这会导致占用大量的磁盘空间

00:01:53.914 --> 00:01:56.250
这也意味着
用户不得不在一定程度上思考

00:01:56.316 --> 00:01:58.418
关于什么是他们要保留什么的
什么是不要保留的

00:01:58.485 --> 00:02:01.355
我们不想让我们的用户变成系统管理员

00:02:03.056 --> 00:02:06.226
所以在按需资源应用中
我们想要尝试优化的是

00:02:06.293 --> 00:02:08.895
优化资源的使用

00:02:08.961 --> 00:02:11.365
在它被使用的时候

00:02:11.431 --> 00:02:14.768
同时保证它是可得的 早于用户注意到

00:02:14.835 --> 00:02:16.036
它需要被下载

00:02:17.104 --> 00:02:20.941
所以在传统应用的基础上 我们把资源

00:02:21.008 --> 00:02:24.678
分成绑定的资源和按需加载资源

00:02:24.745 --> 00:02:28.215
它们不是真的存在于系统里
当应用被安装的时候

00:02:29.183 --> 00:02:33.420
现在 在过去的一年中
有一些错误的概念

00:02:33.487 --> 00:02:35.889
关于tvOS应用的大小

00:02:36.924 --> 00:02:40.661
有一种说法是
我们把它限制在200MB以内

00:02:40.727 --> 00:02:41.929
这不是真的

00:02:42.496 --> 00:02:48.268
tvOS上主程序集限制是200MB
而对于iOS

00:02:48.335 --> 00:02:51.138
它可以最大到4GB
无论如何 在这两种系统中

00:02:51.205 --> 00:02:54.308
它们的按需加载资源可以达到20GB

00:02:56.276 --> 00:02:58.345
所以按需资源

00:02:58.912 --> 00:03:03.317
它们提供了动态加载的内容
它可以按需提供

00:03:03.383 --> 00:03:05.586
或者可以在应用安装时被下载

00:03:06.753 --> 00:03:10.691
它是托管在App Store上的
包括托管不同版本

00:03:10.757 --> 00:03:12.960
所以升级不是问题

00:03:13.026 --> 00:03:16.029
显然若你有一个用户坚持使用旧版本
它还是能工作的

00:03:18.065 --> 00:03:20.534
它们在程序安装过程中是可以下载的

00:03:20.601 --> 00:03:24.104
在运行的时候 如果有请求
它们也是可以下载的

00:03:24.605 --> 00:03:27.474
而且你可以控制下载的优先级

00:03:27.541 --> 00:03:29.343
而且你可以调整优先级

00:03:29.409 --> 00:03:31.845
因为用户可能改变他们的想法

00:03:31.912 --> 00:03:33.046
去做他们想做的事情

00:03:34.348 --> 00:03:36.917
同时 所以这些和系统一起

00:03:36.984 --> 00:03:40.854
提供了智能的内容缓存和智能清理

00:03:41.588 --> 00:03:45.092
这样 我们就让用户远离了
系统管理的工作

00:03:45.392 --> 00:03:49.596
对于你的的应用来说 好处是变小了

00:03:50.130 --> 00:03:52.032
这意味着它更快了和加速了下载

00:03:52.099 --> 00:03:55.736
意味着这个时间间隔变短了
在用户点击购买按钮和

00:03:55.802 --> 00:03:57.371
用户使用你的程序之间

00:03:59.072 --> 00:04:03.210
而且 你有更为丰富的应用内容
最高可达20GB

00:04:03.277 --> 00:04:05.179
这可是很大的空间哦

00:04:07.214 --> 00:04:10.217
而且 那样就可在系统中装更多的应用

00:04:10.284 --> 00:04:14.521
它们都是可以运行的
而且减少了管理存储的需求

00:04:14.721 --> 00:04:16.822
这也意味着用户可以拍很多的照片

00:04:16.890 --> 00:04:19.091
一部分按需加载资源可能被释放出来

00:04:19.159 --> 00:04:20.494
这都是完全自动的

00:04:22.329 --> 00:04:24.998
那么我们如何来实现这个呢？
我们如何采用这个呢

00:04:25.065 --> 00:04:28.302
你要做的第一件事是要指定标签

00:04:28.368 --> 00:04:31.405
给所有的资源 你实现这个通过寻找

00:04:31.471 --> 00:04:34.074
在程序中 找出所有的资源

00:04:34.141 --> 00:04:37.044
找出每个资源在你的应用中的角色

00:04:37.477 --> 00:04:38.645
和你需要它们的时间

00:04:40.113 --> 00:04:42.416
然后在Xcode中指定标签

00:04:42.482 --> 00:04:43.784
标签一点儿都不神奇

00:04:43.851 --> 00:04:45.085
它们只是字符串

00:04:46.453 --> 00:04:50.023
只是一些你想要的字符串
第一级 任意东西

00:04:50.891 --> 00:04:52.726
它们可以被应用于单独的资产

00:04:52.793 --> 00:04:58.632
或者一个单独的资源 一个声音文件
一个纹理 一张图片 无论什么东西

00:04:58.699 --> 00:05:01.902
纯数据
或者它们可以被指定给整个文件夹

00:05:02.769 --> 00:05:05.205
而且 每个资源可以有多个标签

00:05:05.272 --> 00:05:07.074
因为它有可能有多个角色

00:05:08.609 --> 00:05:10.944
让我们回过头
看看GreatGame这个应用

00:05:11.011 --> 00:05:13.547
看一下那些资源

00:05:13.614 --> 00:05:15.916
把这些资源按照角色分类

00:05:16.450 --> 00:05:19.520
在这个例子中
这是一个非常明了的基于级别的应用

00:05:21.021 --> 00:05:23.390
而且它有总是需要的资源

00:05:23.457 --> 00:05:25.392
这些就是 比如你的启动页面

00:05:25.459 --> 00:05:27.294
你的启动加载页面 或者是设置页面

00:05:27.361 --> 00:05:28.362
这一类的东西

00:05:28.428 --> 00:05:32.499
它有给每一级别提供的资源

00:05:32.966 --> 00:05:36.637
或者购买项目或者应用内购买的东西

00:05:38.138 --> 00:05:40.474
对于这些标签 是非常直接明了的

00:05:40.541 --> 00:05:42.609
只要给他们和它们角色一样的名字就行

00:05:44.912 --> 00:05:47.648
所以当我们做这些 当我们看这些时

00:05:47.714 --> 00:05:49.917
我们给这些东西打标签的策略是什么呢

00:05:49.983 --> 00:05:52.853
只要给主程序集的资源

00:05:52.920 --> 00:05:56.156
那些程序始终确实需要的资源

00:05:56.924 --> 00:05:59.459
你的加载页面
你的程序启动页面 这类东西

00:06:00.861 --> 00:06:04.631
然后你给另外所有的东西打上标签

00:06:05.432 --> 00:06:09.403
每个标签可被应用在最多512MB的

00:06:09.503 --> 00:06:11.138
资产或者资源

00:06:11.572 --> 00:06:15.309
然而 我们强烈建议你
遵循64MB左右的限制

00:06:15.375 --> 00:06:18.111
因为那样会使下载更快

00:06:18.178 --> 00:06:20.013
而且让用户更加不易察觉

00:06:20.881 --> 00:06:23.750
每个资源可以都多个标签

00:06:24.218 --> 00:06:26.887
只要你用了其中的一个标签

00:06:26.954 --> 00:06:29.890
就会提取所有对应的资源

00:06:31.391 --> 00:06:34.962
所有我们已将所有东西归类并打上标签

00:06:35.028 --> 00:06:36.730
让我们看一下运行时的情况

00:06:38.131 --> 00:06:41.568
在运行时 我们尝试让API尽量简单

00:06:41.869 --> 00:06:44.071
实际上 这只是一个类

00:06:44.638 --> 00:06:47.074
有一个资源请求类

00:06:47.674 --> 00:06:51.678
你要创建这个类的一个实例来管理所有

00:06:51.745 --> 00:06:53.413
按需加载资源的读取

00:06:53.914 --> 00:06:56.717
它通过一个标签或者一组标签来创建

00:06:56.783 --> 00:06:58.785
而且它有一些其它的选项来管理它

00:06:59.686 --> 00:07:03.023
你可以用它来开始和结束资源的访问

00:07:03.090 --> 00:07:06.426
开始访问会触发下载 如果需要

00:07:06.793 --> 00:07:09.429
结束访问会告诉系统 嘿 我结束啦

00:07:10.364 --> 00:07:12.799
在这个对象中 你也可以设定优先级

00:07:12.866 --> 00:07:16.270
如果你有一个特别大的下载
或者一个特别慢的网络连接

00:07:16.336 --> 00:07:20.174
你可以追踪进度
而且也有可能会遇到错误

00:07:20.707 --> 00:07:22.342
我们马上会降到

00:07:22.409 --> 00:07:23.911
关于这个类有一个有趣的东西是

00:07:23.977 --> 00:07:25.879
每一个实例都是一次性的

00:07:25.946 --> 00:07:28.215
它们是非常轻量级的 非常容易被创建

00:07:28.282 --> 00:07:32.252
这意味着当你创建一个实例
开始访问它

00:07:32.319 --> 00:07:35.088
在你调用结束访问之后
这个对象就完了

00:07:35.489 --> 00:07:36.323
创建一个新的

00:07:39.026 --> 00:07:43.096
有一个非常重要需要记住的概念是

00:07:43.163 --> 00:07:47.701
请求和访问是不关联的

00:07:48.535 --> 00:07:52.406
所有当你请求

00:07:52.472 --> 00:07:54.675
从当你要使用这个资源时
我们是可以的

00:07:54.741 --> 00:07:56.543
我们会在预测加载讲这些

00:07:56.610 --> 00:07:58.312
所有我们可以预测用户将要干什么

00:07:58.378 --> 00:08:00.447
来保证他们永远不会看到那些加载界面

00:08:01.849 --> 00:08:03.617
让我们来看一下真实的代码

00:08:05.752 --> 00:08:08.922
初始化一批资源请求是相当直接的

00:08:08.989 --> 00:08:12.092
只要给它一组标签
然后你就有你的请求了

00:08:12.659 --> 00:08:15.028
如果你想要开始访问那些标签

00:08:15.095 --> 00:08:18.365
调用开始访问 它有一个完成句柄

00:08:18.432 --> 00:08:20.767
那个完成句柄会被错误地调用

00:08:20.834 --> 00:08:23.036
如果有错误的话 或者它会被正确调用

00:08:23.103 --> 00:08:24.938
那么你的资源就是可利用的了

00:08:25.606 --> 00:08:28.742
为了得到资源 使用包API

00:08:28.809 --> 00:08:31.311
抓住一个NS包实例 对不起

00:08:31.378 --> 00:08:34.815
包实例 重命名 从请求中

00:08:34.881 --> 00:08:38.085
只要使用正常的资源请求方法

00:08:38.150 --> 00:08:39.753
于包 来控制它

00:08:41.355 --> 00:08:44.358
当你结束了之后
调用结束访问是非常重要的

00:08:44.424 --> 00:08:47.060
这告诉了系统你已经用完了这个资源

00:08:47.127 --> 00:08:48.862
需要重点指出的是 那不意味着

00:08:48.929 --> 00:08:51.365
系统就会真的删除资源

00:08:51.431 --> 00:08:53.333
系统是非常懒惰的

00:08:53.400 --> 00:08:56.537
它们不想做额外的工作
删除东西的额外工作

00:08:58.038 --> 00:09:02.409
所以当你加载资源的时候
你可以控制优先级

00:09:02.476 --> 00:09:04.711
比如 你要在玩一个游戏

00:09:04.778 --> 00:09:06.246
用户改变了他们的想法

00:09:06.313 --> 00:09:07.915
你就下载这个级别的资源

00:09:07.981 --> 00:09:09.516
现在你需要下载级别5

00:09:10.217 --> 00:09:11.952
你开始于开始访问

00:09:12.019 --> 00:09:13.987
你可以继续 你可以改变加载优先级

00:09:14.054 --> 00:09:18.325
来把优先级提到5级或者降到3级

00:09:18.392 --> 00:09:20.561
如果你觉得他们可能返回
或者你可以结束它

00:09:21.562 --> 00:09:23.530
它只是一个值 从0到1

00:09:23.931 --> 00:09:26.600
但是有特别紧急的优先级

00:09:27.501 --> 00:09:30.771
有时候 会播放器会关闭

00:09:30.838 --> 00:09:33.140
而你又无法预测

00:09:33.407 --> 00:09:36.143
你需要立即下载所有东西

00:09:36.510 --> 00:09:40.747
在这种情况下
这种特别紧急的加载优先级

00:09:40.814 --> 00:09:41.882
就能被用到了

00:09:41.949 --> 00:09:43.817
它会挂起所有其它的下载

00:09:44.284 --> 00:09:46.220
也会最大化吞吐量

00:09:46.286 --> 00:09:47.754
所有没有网络节流

00:09:48.255 --> 00:09:51.692
也会最大化中央处理器使用
专门用于下载

00:09:54.995 --> 00:09:57.397
最后 会有有条件请求

00:09:57.631 --> 00:10:00.367
有条件请求可以用来检查

00:10:00.434 --> 00:10:02.536
资源是否已经被下载

00:10:03.203 --> 00:10:05.973
如果你还记得在我说结束访问的时候

00:10:06.039 --> 00:10:08.542
不一定要删除资源

00:10:09.443 --> 00:10:11.178
播放器已经在玩一个游戏

00:10:11.245 --> 00:10:13.180
他们已经玩过了1 2 3 级

00:10:13.247 --> 00:10:15.549
你已经结束对1 2 3级别的访问

00:10:16.617 --> 00:10:18.652
他们退出游戏
下线后再做了其它一些事情

00:10:18.719 --> 00:10:20.354
当他们回来 重启游戏

00:10:20.854 --> 00:10:22.589
他们想要重玩1级

00:10:22.956 --> 00:10:24.591
你可以有条件地使用

00:10:24.658 --> 00:10:27.327
或者说他们想要选择不同的级别

00:10:27.394 --> 00:10:30.130
你可以条件地使用开始访问

00:10:30.531 --> 00:10:32.065
来检查什么级别已经被下载了

00:10:32.132 --> 00:10:34.902
给它们指示什么已经可以玩了

00:10:35.302 --> 00:10:37.171
或者如果它们进入了一个级别

00:10:37.237 --> 00:10:40.040
在每个级别中
你已按照角色分解你的资源

00:10:40.107 --> 00:10:42.176
可能你优化了级别的第一部分

00:10:42.242 --> 00:10:45.112
只是展示数和刷子和敌人

00:10:45.179 --> 00:10:47.548
正好那个时候在磁盘上

00:10:47.614 --> 00:10:49.850
当你在后台下载余下的部分

00:10:50.450 --> 00:10:52.219
所以所有都是关于你可以

00:10:52.286 --> 00:10:54.454
避免加载页面

00:10:56.490 --> 00:11:00.727
如果这些项目已经被下载了
那就会像开始访问一样地工作

00:11:02.095 --> 00:11:04.865
同样 需要调用介绍访问

00:11:04.932 --> 00:11:08.702
就算你得到回调 那它也是假的

00:11:08.769 --> 00:11:11.371
你决定不去触发下载

00:11:11.438 --> 00:11:12.840
总是调用结束访问

00:11:14.942 --> 00:11:18.078
现在你有了一个可以工作的程序

00:11:22.749 --> 00:11:24.384
但是让我们看一下首次启动

00:11:26.787 --> 00:11:28.822
特别看一下这个时间轴

00:11:29.823 --> 00:11:31.491
我们会沿着时间轴

00:11:32.226 --> 00:11:35.729
从用户在商场中
购买这个应用的那一刻开始

00:11:35.796 --> 00:11:37.631
应用被下载 被安装

00:11:38.765 --> 00:11:41.468
和第一次启动
然后我们需要做的事情

00:11:41.535 --> 00:11:44.471
我们要做的第一件事 开始访问1级

00:11:44.771 --> 00:11:47.941
这会触发一个下载
然后播放器开始这个游戏

00:11:48.575 --> 00:11:52.079
然后到达2级 我们也是开始访问

00:11:52.312 --> 00:11:53.981
它会下载 用户在那等待

00:11:54.081 --> 00:11:56.483
用户继续玩 重复这个流程

00:11:56.550 --> 00:11:59.052
3级 下载 等待 玩游戏

00:11:59.987 --> 00:12:03.023
甚至对于可购买的项目 程序内购买

00:12:03.423 --> 00:12:05.125
下载 等待 玩游戏

00:12:07.060 --> 00:12:09.630
这不是一个好的用户体验

00:12:10.664 --> 00:12:13.534
让用户经常地看到加载页面
这是不行的

00:12:13.600 --> 00:12:14.635
我们不想这个样子

00:12:14.968 --> 00:12:16.336
所以我们要做的第一是

00:12:16.403 --> 00:12:19.206
充分利用功能和按需加载资源

00:12:19.706 --> 00:12:23.510
这是自带的功能 来优化首次启动

00:12:23.577 --> 00:12:27.247
我们要做的第一是使用初始安装标签

00:12:28.282 --> 00:12:30.984
接下来我们要使用的是预获取标签

00:12:33.220 --> 00:12:34.755
有了这些

00:12:35.055 --> 00:12:38.926
那么1级会在应用购买的时候
被下载和安装

00:12:39.426 --> 00:12:42.496
2级会紧跟着被下载和安装

00:12:42.896 --> 00:12:45.666
用户可以开始玩了

00:12:47.067 --> 00:12:49.169
让我们看一下预测下载

00:12:49.236 --> 00:12:51.038
但先看一下

00:12:51.104 --> 00:12:53.040
如何配置初始预提取

00:12:54.274 --> 00:12:57.344
所以初始安装标签

00:12:57.411 --> 00:13:01.081
这些在Xcode中
被标记的标签需要被下载

00:13:01.148 --> 00:13:03.450
作为出程序安装的一部分

00:13:04.084 --> 00:13:07.387
最多可以有多达2GB的资源
这是很多的

00:13:08.488 --> 00:13:11.358
这是在App Store上
显示的程序大小的一部分 实际上

00:13:11.425 --> 00:13:13.994
当下载进度条开始的时候

00:13:14.061 --> 00:13:16.930
表明初始安装标签也开始了

00:13:18.098 --> 00:13:20.400
预提取标签是稍有不同的

00:13:20.934 --> 00:13:23.470
你可以有任意多的预提取标签

00:13:23.537 --> 00:13:27.307
最高可达4GB减去初始安装的大小

00:13:28.308 --> 00:13:30.477
它会遵循Xcode中指定的一个排序

00:13:30.911 --> 00:13:34.615
预提取标签在初始化之后立即被下载

00:13:35.249 --> 00:13:36.884
它们不会阻止应用的启动

00:13:37.651 --> 00:13:40.687
所以用户可以进入游戏并开始玩了

00:13:40.754 --> 00:13:43.257
尽管预提取的东西在后台被下载下来

00:13:44.291 --> 00:13:45.726
在Xcode中

00:13:46.894 --> 00:13:48.862
用户界面是这个样子的

00:13:48.929 --> 00:13:53.400
这是资源标签检查器 在目标编辑器内

00:13:53.467 --> 00:13:54.635
对于你的应用

00:13:55.002 --> 00:13:57.671
它有三部分 初始 预提取

00:13:57.738 --> 00:13:59.640
和按需标签的下载

00:14:00.207 --> 00:14:01.208
你一开始移动这些东西

00:14:01.275 --> 00:14:04.011
这些会和你的应用一起打包

00:14:04.077 --> 00:14:05.779
同时被安装

00:14:06.713 --> 00:14:10.317
预提取
会按照你在屏幕上看到的顺序被下载

00:14:11.051 --> 00:14:13.453
最后 按需的下载

00:14:13.720 --> 00:14:17.591
是只有你开始访问那些标签的时候
才被下载

00:14:19.960 --> 00:14:21.495
回到我们的时间轴

00:14:21.795 --> 00:14:23.664
我们非常简略地讲过预测加载

00:14:23.730 --> 00:14:25.165
那这到底是什么意思呢？

00:14:25.232 --> 00:14:27.000
我们开始初始化

00:14:27.301 --> 00:14:28.602
得到我们的预提取

00:14:28.669 --> 00:14:30.904
我们仍然让我们在3级的时候在等待

00:14:31.505 --> 00:14:35.676
若我们开始访问3级标签对应的资源

00:14:36.043 --> 00:14:37.845
在1级或者2级的某些时候

00:14:37.911 --> 00:14:41.949
这样可能在用户到达那里的时候
那些资源就已被下载并能被使用了

00:14:42.649 --> 00:14:44.218
同样对于购买项目

00:14:44.551 --> 00:14:49.022
如果在你的应用 游戏 不管什么中
有一个特殊的时间点

00:14:49.089 --> 00:14:52.125
你认为有可能或者你希望玩家将要

00:14:52.192 --> 00:14:55.562
做一个程序内购买
那就在那里开始访问

00:14:55.896 --> 00:14:58.298
只有当你得到返回后 你才能访问它们

00:14:58.365 --> 00:15:00.634
但是至少它会在那里 不会有等待

00:15:00.734 --> 00:15:04.438
现在我们得到一个大的绿色时间轴
和一个非常高兴的用户

00:15:06.173 --> 00:15:09.743
我们已经讨论了这个基于层级的游戏

00:15:10.344 --> 00:15:12.212
这是一个非常线性访问的模式

00:15:12.746 --> 00:15:14.815
它非常容易创建漂亮的幻灯片

00:15:14.882 --> 00:15:16.016
这不是真实的世界

00:15:17.384 --> 00:15:21.555
在一个线性访问模式中
大部分资产会被使用

00:15:21.622 --> 00:15:23.524
它们大部分会被按照顺序地使用

00:15:23.924 --> 00:15:26.460
你的标签大小不是那么得关键

00:15:26.527 --> 00:15:30.330
因为你始终可以在用户之前得到访问

00:15:31.932 --> 00:15:35.035
但是问题是 当然

00:15:35.102 --> 00:15:36.537
这里没有什么是线性的

00:15:37.371 --> 00:15:38.639
特别地

00:15:38.705 --> 00:15:43.076
很多时候 应用都是随机访问模式

00:15:43.911 --> 00:15:45.712
播放器可以播放任意一个地方

00:15:45.779 --> 00:15:48.148
或者有些东西可能被不同的级别所共享

00:15:48.215 --> 00:15:50.784
或者他们可能选择特定的配置

00:15:50.851 --> 00:15:54.421
或者他们可能购买了一些应用内购买项
在这种情况下

00:15:54.488 --> 00:15:57.991
目标是尽量多地预测

00:15:58.058 --> 00:16:00.160
尝试在用户需要之前把东西下载下来

00:16:00.227 --> 00:16:02.329
但是在你需要下载的时候

00:16:02.396 --> 00:16:04.164
在那一刻真的需要时

00:16:05.065 --> 00:16:07.100
坚持小的标签组

00:16:08.035 --> 00:16:10.571
这样就会下载得很快

00:16:11.205 --> 00:16:13.640
而且你可以有前瞻性地下载标签组

00:16:13.707 --> 00:16:16.710
可以继续了 只是猜测什么将会被需要

00:16:17.377 --> 00:16:20.047
让它们就那样 下载到磁盘 因为

00:16:20.113 --> 00:16:22.216
当然 我们有这个智能缓存机制

00:16:22.282 --> 00:16:25.752
它会在后台运行 确保删除正确的东西

00:16:25.819 --> 00:16:27.287
如果磁盘满了的话

00:16:28.488 --> 00:16:30.757
再强调一遍 结束访问并不意味着删除

00:16:30.824 --> 00:16:33.293
如果你下线了
而且你提前下载了一些东西

00:16:33.360 --> 00:16:34.828
然后你根本不需要它 没关系

00:16:34.895 --> 00:16:36.797
只要结束访问 它可能还是在那里

00:16:36.864 --> 00:16:39.633
当你以后需要它的时候

00:16:41.001 --> 00:16:43.670
现在有另外一种模式
这是一种在两者之间的

00:16:44.805 --> 00:16:46.807
那是探索性访问模式

00:16:47.174 --> 00:16:49.476
那是...你想

00:16:49.543 --> 00:16:52.012
从一个村庄到另一个村庄类似的情况

00:16:52.613 --> 00:16:54.848
在这种情况下 存在有限的预测

00:16:55.282 --> 00:16:57.317
很多可能不会被使用

00:16:58.585 --> 00:17:01.622
但是你经常在一个分支上
当你在一个分支上的时候

00:17:01.688 --> 00:17:03.790
你可以下载一个标签的子集

00:17:03.857 --> 00:17:05.459
用户左转 右转

00:17:05.526 --> 00:17:07.560
所以我要下载向左的标签和向右的标签

00:17:07.627 --> 00:17:09.896
当用户做出决定后

00:17:10.464 --> 00:17:13.634
打算向右

00:17:13.700 --> 00:17:15.002
让那个下载停止

00:17:15.801 --> 00:17:18.571
关注右边 开始预测下一步

00:17:21.141 --> 00:17:23.877
所以现在这个应用可以正常工作了

00:17:23.944 --> 00:17:28.048
我们得到了一个非常棒的用户体验

00:17:29.049 --> 00:17:31.418
但是让我们看一下一些实现的细节

00:17:31.485 --> 00:17:33.353
在页面的背后进行着的

00:17:34.555 --> 00:17:37.991
你可以关注一下以进一步优化用户体验

00:17:41.828 --> 00:17:45.566
特别地 正如我所说的 程序包

00:17:45.799 --> 00:17:50.137
在iOS上被限制为4GB
在tvOS上被限制为200MB

00:17:50.204 --> 00:17:53.106
但你可有多达20GB的按需加载资源

00:17:53.173 --> 00:17:56.577
它们中的最多2GB可以
和应用一起被下载和安装

00:17:57.077 --> 00:18:01.882
最多4GB可以被预提取
减去那2GB或者最多2GB的安装

00:18:02.749 --> 00:18:05.018
还有一些数据要记住

00:18:06.353 --> 00:18:09.957
同一时间最多可以有2GB的活动资源

00:18:10.290 --> 00:18:13.660
所以你开始访问最多2GB的标签

00:18:14.228 --> 00:18:16.430
那些会被下载 然后就是可用的

00:18:16.496 --> 00:18:17.464
这非常棒

00:18:17.664 --> 00:18:20.267
当你超过了2GB 会发生的是

00:18:20.334 --> 00:18:25.038
开始访问方法会得到一个NS错误

00:18:25.105 --> 00:18:28.675
这表示用完了带标签资源的空间

00:18:28.909 --> 00:18:32.279
你需要对一些标签集结束访问

00:18:32.346 --> 00:18:35.382
来释放一些空间
使得更多的资源能被访问

00:18:35.749 --> 00:18:39.052
重复这一点是
因为有另外一个困惑的地方

00:18:39.820 --> 00:18:43.056
如果你有2GB的已经下载好的标签

00:18:43.490 --> 00:18:45.092
而且你想要访问更多

00:18:45.158 --> 00:18:48.295
你访问其中的500MB

00:18:48.362 --> 00:18:51.798
固定另外的250MB
那500MB资源

00:18:51.865 --> 00:18:53.800
可能不会被删除

00:18:53.967 --> 00:18:55.569
它们还在而且是可用的

00:18:55.636 --> 00:18:58.238
但是这只是告诉系统
如果情况变得不好了

00:18:58.305 --> 00:19:00.107
它可以去删除它们

00:19:01.775 --> 00:19:06.313
任意一个标签 最多可以到512MB
尽量坚持64MB或者更小

00:19:09.049 --> 00:19:12.019
你已经有最多1000个资产包

00:19:13.220 --> 00:19:16.890
资产包是什么鬼呢 还没提过这个词

00:19:17.991 --> 00:19:22.062
资产包来自于Xcode编译系统

00:19:22.129 --> 00:19:24.131
这是你的应用生成和管理的方式

00:19:24.198 --> 00:19:27.134
这是按需下载资源被编译在一起的方式

00:19:27.201 --> 00:19:28.969
通过商店来管理

00:19:30.170 --> 00:19:32.673
看一下我们GreatGame
在这个情况中

00:19:32.739 --> 00:19:34.708
一个角色扮演游戏 这无所谓

00:19:35.509 --> 00:19:39.112
我们有标签 非常的典型

00:19:39.847 --> 00:19:42.449
资源会被重复使用

00:19:42.516 --> 00:19:44.751
东西会被使用在1级到2级

00:19:44.952 --> 00:19:47.187
敌人变成了朋友 诸如此类的东西

00:19:47.921 --> 00:19:53.560
所以我们在这里有这两个资源
它们在2级的时候被使用

00:19:53.961 --> 00:19:57.631
所以它们标记了1级和2级的标签

00:20:01.368 --> 00:20:03.203
所以我们的标签集看起来是这样的

00:20:03.303 --> 00:20:07.674
我们有四个带一个标签的资源
和两个带两个标签的资源

00:20:08.642 --> 00:20:11.311
当我们至于四个标签的时候

00:20:12.246 --> 00:20:14.114
最后会有六个资产包

00:20:14.548 --> 00:20:18.418
如果你考虑一下一个随机访问的游戏

00:20:19.253 --> 00:20:20.954
这就会变成一个阻碍

00:20:21.455 --> 00:20:25.459
若你很多资源被很多不同的角色共享

00:20:25.526 --> 00:20:30.197
比如很多资源有
5个 10个 15个标签

00:20:30.497 --> 00:20:33.901
那么所以这些的叉积会超过

00:20:33.967 --> 00:20:36.770
1000个标签
或者1000个资产包的限制

00:20:36.837 --> 00:20:38.939
这时需要注意的

00:20:41.008 --> 00:20:45.612
所以在游戏或者应用的生命周期内

00:20:45.679 --> 00:20:48.048
当然 你会有程序更新

00:20:48.448 --> 00:20:51.618
你想要提升用户体验 让用户回来

00:20:53.453 --> 00:20:56.957
按需下载资源被优化

00:20:57.024 --> 00:20:58.659
为了程序的更新

00:20:59.693 --> 00:21:01.828
可能有一点点令人惊奇

00:21:02.763 --> 00:21:04.998
但是如果你仔细想想 这是合理的

00:21:05.332 --> 00:21:08.735
特别的 我们以1.0版本的游戏开始

00:21:09.803 --> 00:21:12.439
我们在游戏中
有一堆的资源 一些带标签的

00:21:12.506 --> 00:21:14.041
和一些在主要包里的

00:21:14.107 --> 00:21:16.009
然后我们发布第二版

00:21:16.076 --> 00:21:18.412
我们在主包里面做了一些改动

00:21:18.478 --> 00:21:20.814
我们可能给1级增加了一下资源

00:21:21.348 --> 00:21:23.217
对2级更改了一些东西

00:21:23.283 --> 00:21:24.785
我们增加了一个全新的级别

00:21:25.919 --> 00:21:27.754
这些都很好

00:21:27.821 --> 00:21:30.157
那在升级的过程中会发生什么呢

00:21:32.392 --> 00:21:36.330
第一件事情是当你更新资源的时候

00:21:36.396 --> 00:21:41.268
更新带标签的资源
没有什么是被自动重新下载的

00:21:41.568 --> 00:21:44.171
当它第一次被访问时 它会被重新下载

00:21:45.706 --> 00:21:48.342
我们不想重新下载教学级别

00:21:48.642 --> 00:21:50.811
当用户已经远离这个了

00:21:52.846 --> 00:21:55.916
所有没被更改的资源会待在磁盘中

00:21:56.984 --> 00:21:59.019
不需要下载 它们就可以被访问

00:22:00.587 --> 00:22:03.290
新的资源
它们会在被访问的时候被下载

00:22:03.624 --> 00:22:06.727
所有 再说一遍
系统对待这个是非常懒惰的

00:22:06.793 --> 00:22:10.898
在这种情况下 因为我们不能预测
我们会对应用做什么样的改动

00:22:10.964 --> 00:22:13.667
会被需求各种各样的状态 或者用户

00:22:13.734 --> 00:22:14.968
在你的应用留下的东西

00:22:15.369 --> 00:22:16.637
我们将其交给你决定

00:22:16.703 --> 00:22:20.841
触发开始访问来触发上传

00:22:20.908 --> 00:22:22.109
和下载新东西

00:22:22.176 --> 00:22:24.444
实际上 在第一次启动时
你可能想要开始

00:22:24.511 --> 00:22:27.247
和开始访问一些你改变过的东西

00:22:27.314 --> 00:22:31.018
以此确保在用户主要到之前
就让这些资源是可用的

00:22:33.053 --> 00:22:36.790
所以 这个的最佳实践

00:22:38.392 --> 00:22:42.262
避免对带标签资源的不必要的修改

00:22:43.163 --> 00:22:44.464
比如

00:22:44.531 --> 00:22:47.668
我们有过一种情形
当有人做了一个拼写的改变

00:22:47.734 --> 00:22:49.670
令人惊奇的是所有东西都被重新下载了

00:22:49.736 --> 00:22:51.171
当第一次访问它的时候

00:22:53.273 --> 00:22:57.477
如果你改变了这个资产包里的一个资源

00:22:57.845 --> 00:23:01.648
这会触发下载整个资产包 这只是一个

00:23:01.715 --> 00:23:03.183
具体的实现

00:23:03.517 --> 00:23:04.518
所以请牢记

00:23:04.585 --> 00:23:06.954
你应该做的是 比如

00:23:07.020 --> 00:23:10.891
在我们给1级
增加一些额外资源的情况下

00:23:11.458 --> 00:23:14.027
我们可以让1级更新一个标签

00:23:14.094 --> 00:23:16.797
然后开始访问它们 下载

00:23:16.864 --> 00:23:19.900
当它们都可以使用的时候
然后运行用户运行1级

00:23:21.802 --> 00:23:23.303
保持那些标签一致

00:23:25.606 --> 00:23:28.709
从一开始 你要设计好

00:23:28.775 --> 00:23:32.646
可更新内容和静态内容的分离

00:23:35.082 --> 00:23:38.685
所有这些意味着 你可能有一个标签

00:23:38.752 --> 00:23:40.954
对于你的程序中的单一的角色

00:23:41.255 --> 00:23:44.258
可能你想要把那个标签分隔成多个标签

00:23:44.324 --> 00:23:47.194
当它是可能永远不会改变

00:23:47.261 --> 00:23:48.662
和少数会被改变

00:23:52.366 --> 00:23:56.503
所以这些如何组成智能内容缓存的呢

00:23:58.639 --> 00:24:02.709
对于tvOS
这个操作系统的目标之一

00:24:02.776 --> 00:24:07.214
是永远不让用户注意到这个用法

00:24:08.282 --> 00:24:10.017
永远不需要删除东西

00:24:10.851 --> 00:24:12.452
永远不需要去考虑它

00:24:13.854 --> 00:24:15.122
作为这个的一部分

00:24:15.189 --> 00:24:18.392
有一个完整的
缓存管理系统和自动清理系统

00:24:19.359 --> 00:24:22.763
系统会清理到磁盘上的资源

00:24:22.829 --> 00:24:24.998
当磁盘空间快满了的时候

00:24:25.499 --> 00:24:28.268
有多个不同的级别
从优先级最低的开始

00:24:28.335 --> 00:24:29.736
会清理缓存这些

00:24:29.803 --> 00:24:32.005
然后一步一步地到越来越高的优先级

00:24:33.307 --> 00:24:35.909
所以 再强调一些这点

00:24:36.844 --> 00:24:41.415
当你用完了资源的时候
一定要结束访问

00:24:41.481 --> 00:24:43.050
这并不意味着资源会被删除

00:24:44.384 --> 00:24:46.687
智能内容缓存

00:24:46.753 --> 00:24:50.123
有很多变量告诉系统关于清理的顺序

00:24:50.591 --> 00:24:55.329
显然的 最长时间没被用的先被清理

00:24:55.929 --> 00:24:58.532
你也可以控制保留优先级

00:25:00.367 --> 00:25:03.770
保留优先级是一个信号
对于打包资源请求

00:25:04.505 --> 00:25:08.275
这是一个0到1的数值 只是用来表示

00:25:08.342 --> 00:25:10.911
系统以什么样的顺序删除东西

00:25:11.645 --> 00:25:14.348
它独立于你的应用 所以不会作弊

00:25:15.182 --> 00:25:16.850
它不会帮你把所有都设为1

00:25:16.917 --> 00:25:20.354
它只是表示当真的需要的时候
我们会吹走一切

00:25:20.821 --> 00:25:23.357
如果你的程序在运行

00:25:23.924 --> 00:25:27.594
它会是系统最后一个清理的资源

00:25:31.398 --> 00:25:33.534
这是非常重要的

00:25:33.600 --> 00:25:35.736
不要使用临时变量和缓存

00:25:36.570 --> 00:25:41.508
显然若你需要一下临时的东西或者缓存
你可以使用

00:25:42.609 --> 00:25:44.778
但是因为我们无法知道

00:25:44.845 --> 00:25:47.581
在临时缓存中的数据的结构

00:25:48.582 --> 00:25:53.053
系统会认为
它们是在低优先级时 就可以被清理的

00:25:53.620 --> 00:25:55.756
它们会被清理 而当它们被清理了

00:25:55.822 --> 00:25:57.357
它们是被整体地清理了

00:26:00.093 --> 00:26:01.962
所以 最后

00:26:03.630 --> 00:26:04.665
总结一下

00:26:06.533 --> 00:26:08.168
使用按需加载资源

00:26:08.235 --> 00:26:12.573
特别是对于tvOS
按需加载资源的使用

00:26:13.307 --> 00:26:16.210
真的提供了更加优化的用户体验

00:26:16.677 --> 00:26:18.912
它影响了网络连接

00:26:19.313 --> 00:26:21.682
在iOS上 事情变得更加的棘手

00:26:21.748 --> 00:26:24.685
但也有很多成功使用它的方式

00:26:27.054 --> 00:26:28.889
它会使得应用更小

00:26:29.223 --> 00:26:32.893
这会减少用户获取的时间

00:26:33.460 --> 00:26:39.099
从商店到你用户玩上你的游戏
使用你的程序

00:26:40.200 --> 00:26:42.202
用你的内容做所有的事情

00:26:45.239 --> 00:26:46.840
你有了更多的应用内容

00:26:46.907 --> 00:26:51.879
现在你有了最多到20GB的空间
放任意你想的东西

00:26:54.581 --> 00:26:58.285
而对于用户 他们不需要考虑这个

00:26:58.352 --> 00:27:00.654
他们可以安装任意多的应用

00:27:00.721 --> 00:27:02.523
他们没有一个障碍

00:27:02.589 --> 00:27:04.558
他们也不需要考虑存储

00:27:05.926 --> 00:27:09.997
这就是按需下载资源的优化

00:27:10.864 --> 00:27:12.065
更多相关的信息

00:27:13.534 --> 00:27:15.602
请参考我们的网页

00:27:16.103 --> 00:27:19.506
在本周的早些时候也有许多相关的演讲

00:27:19.806 --> 00:27:21.241
我建议大家回顾一下

00:27:21.308 --> 00:27:22.176
谢谢