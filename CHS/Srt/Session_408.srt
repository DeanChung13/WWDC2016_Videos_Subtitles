00:00:19.119 --> 00:00:20.621
介绍Swift Playgrounds

00:00:20.687 --> 00:00:21.522
早上好

00:00:24.057 --> 00:00:25.092
早上好

00:00:27.427 --> 00:00:29.897
非常感谢大家
我是Matt Patenaude

00:00:29.963 --> 00:00:32.031
我是Playgrounds团队
的工程师

00:00:32.098 --> 00:00:36.136
欢迎参加演讲408
“介绍Swift Playgrounds”

00:00:36.770 --> 00:00:40.374
我非常激动成为这个团队中的一员

00:00:40.440 --> 00:00:44.278
今天我们要给你们展示一下
天哪我们要给你们展示很多东西

00:00:44.478 --> 00:00:47.047
好的
让我们开始吧

00:00:48.382 --> 00:00:50.584
目前为止你们已接触
这个应用有48个小时了

00:00:50.984 --> 00:00:53.020
所以我确定你们中很多人
已经看到这个了

00:00:53.086 --> 00:00:56.223
但是也可能你们中有些人设法
抵制住了它的诱惑

00:00:56.290 --> 00:01:00.327
Swift Playgrounds
确实是iPad令人激动的新应用

00:01:00.527 --> 00:01:02.629
它能让你用Swift编程

00:01:02.896 --> 00:01:06.767
让你用手指直接感受
Swift的强大

00:01:07.568 --> 00:01:11.104
如果你对编程没有什么经验
这个应用对你很有用

00:01:11.238 --> 00:01:14.474
我们有很棒的学习编码的课程

00:01:14.608 --> 00:01:16.743
你可以从应用上直接下载

00:01:16.810 --> 00:01:20.280
我们把它设计的吸引人
而且令人激动

00:01:20.447 --> 00:01:22.616
无论你处于什么编程水平

00:01:22.850 --> 00:01:26.253
别的不说 你可以用它
制作出漂亮的舞步

00:01:30.190 --> 00:01:32.092
如果你对编程略有经验

00:01:32.159 --> 00:01:34.561
我们也为你准备了很棒的起点工具

00:01:34.628 --> 00:01:35.829
像这个形状模板

00:01:35.896 --> 00:01:39.600
它能够让你用
颜色和触摸这样的东西做实验

00:01:39.666 --> 00:01:43.070
这在iPad上都是独一无二的
别的地方你不会看到

00:01:43.403 --> 00:01:46.306
如果你已经习惯于Xcode中
的编程工具

00:01:46.406 --> 00:01:51.278
你可以把你的iOS编程工具中的
代码更新到Swift 3

00:01:51.445 --> 00:01:54.448
它们在Swift Playgrounds
和iPad上都会运行得很好

00:01:54.781 --> 00:01:56.550
我们认为它确实是令人激动的产品

00:01:56.617 --> 00:01:59.286
我们知道你会用它做出
令人称奇的东西

00:01:59.386 --> 00:02:01.421
好的 我们有很多东西展示给你们

00:02:01.555 --> 00:02:05.592
今天的演讲分为三部分

00:02:06.493 --> 00:02:09.329
首先让我的同事Max上台

00:02:09.429 --> 00:02:11.632
他会演示如何使用这个应用

00:02:11.698 --> 00:02:14.401
包括神奇的触摸反馈和手势

00:02:14.468 --> 00:02:17.070
这绝对是iPad的独一无二的体验

00:02:17.704 --> 00:02:19.473
然后是Jonathan

00:02:19.540 --> 00:02:22.442
他会演示如何编译
更有吸引力的内容

00:02:22.509 --> 00:02:23.610
用Swift
Playgrounds

00:02:23.677 --> 00:02:26.280
使用新文档格式的新特征

00:02:26.380 --> 00:02:28.916
最后Izzy会上台 他要演示

00:02:28.982 --> 00:02:30.784
你可以做的一些很酷的东西

00:02:30.851 --> 00:02:33.153
一旦你有更多时间
玩这个软件

00:02:33.220 --> 00:02:35.155
闲言少叙 有请Max

00:02:40.794 --> 00:02:41.628
谢谢Matt

00:02:42.863 --> 00:02:43.697
谢谢Matt

00:02:44.031 --> 00:02:47.201
首先让我们看一个截屏

00:02:47.367 --> 00:02:49.603
它是Swift Playgrounds的截屏
我们可以看到

00:02:49.736 --> 00:02:51.738
界面的不同组成部分

00:02:51.805 --> 00:02:57.144
在屏幕的左侧是源代码编译器

00:02:57.211 --> 00:02:58.846
右侧是实时视图

00:02:58.912 --> 00:03:01.915
源代码编译器由几个区域组成

00:03:01.982 --> 00:03:06.086
一个区域
是Playground注释

00:03:06.453 --> 00:03:09.122
你可以看到这儿有很多注释

00:03:09.389 --> 00:03:12.059
它可以分散在每个页面之内

00:03:12.326 --> 00:03:16.363
这是一个内容丰富的文本
帮助你了解文档的信息

00:03:16.763 --> 00:03:19.366
下面有一个源代码的实例

00:03:19.566 --> 00:03:22.803
在这儿你完成所有的编程代码

00:03:23.370 --> 00:03:26.340
在屏幕的底端有快捷菜单

00:03:26.907 --> 00:03:29.209
中间是代码补全

00:03:29.376 --> 00:03:31.712
这取决于光标处的代码

00:03:32.179 --> 00:03:35.115
左面是撤销和恢复按钮

00:03:35.315 --> 00:03:38.385
右面有两个——是几个快捷按钮

00:03:38.585 --> 00:03:40.053
一个是删除按钮

00:03:40.420 --> 00:03:44.191
另一个按钮用于插入行
第三个用来弹出软键盘

00:03:44.491 --> 00:03:46.793
这些按钮将帮助到你

00:03:47.127 --> 00:03:50.430
如果你不想用键盘编程的话

00:03:50.864 --> 00:03:53.600
右面是实时视图

00:03:54.168 --> 00:03:57.337
在这儿能实时看到代码的执行情况

00:03:57.671 --> 00:04:00.841
下面有运行代码按钮

00:04:02.042 --> 00:04:04.077
按下它将编译和运行你的代码

00:04:04.645 --> 00:04:08.215
顶部的左边有文档按钮

00:04:08.282 --> 00:04:09.750
可以选择你的文档

00:04:09.917 --> 00:04:12.452
这个按钮用来显示内容的列表
它能显示

00:04:12.553 --> 00:04:16.023
文档中所有的章节和页面

00:04:16.723 --> 00:04:19.125
还有两个按钮用于浏览页面

00:04:19.593 --> 00:04:22.796
右边是工具菜单

00:04:23.297 --> 00:04:25.666
资料菜单和工具菜单

00:04:26.233 --> 00:04:28.168
让我们看看它们里面是什么

00:04:29.203 --> 00:04:32.873
在资料菜单下是代码片段

00:04:33.507 --> 00:04:37.211
旁边是图像列表

00:04:37.277 --> 00:04:39.880
你可把这些图像添到
playground或文档中

00:04:40.080 --> 00:04:42.382
第三个是文件列表

00:04:42.683 --> 00:04:47.821
你可以从其中选择
添加到你的文档中去

00:04:48.956 --> 00:04:52.359
在工具菜单下你可以
找到应用的帮助

00:04:52.526 --> 00:04:54.895
文档的术语表

00:04:55.329 --> 00:04:58.098
这两个按钮可以分享有关文档的东西

00:04:58.165 --> 00:05:01.335
例如录屏 把你的操作录制下来

00:05:01.668 --> 00:05:05.472
截屏 把实时视图的图像保存下来

00:05:05.772 --> 00:05:09.710
最后是还原按钮
可以把页面还原到初始状态

00:05:10.310 --> 00:05:12.446
现在我们在文件浏览器中

00:05:13.080 --> 00:05:16.250
你可以看到这儿有很多文件

00:05:16.350 --> 00:05:19.453
我要打开Playground的
形状模板

00:05:19.686 --> 00:05:20.654
它们都在这儿

00:05:21.221 --> 00:05:25.492
这儿只有一行代码
让rectangle等于某个值

00:05:25.993 --> 00:05:28.362
我想在实时视图中画一些长方形

00:05:28.495 --> 00:05:29.763
我认为这非常有趣

00:05:29.830 --> 00:05:31.298
下面我要在值上点击

00:05:32.633 --> 00:05:35.369
你会看到在底部出现了代码补全

00:05:35.435 --> 00:05:37.404
这儿有许多不同的选项

00:05:37.471 --> 00:05:40.007
我要找到长方形

00:05:40.741 --> 00:05:44.845
通过点击代码补全并且向左
拉动滚动条浏览整个代码补全

00:05:44.912 --> 00:05:48.916
这是长方形
点击它 它就会插入到文档中

00:05:49.449 --> 00:05:53.086
注意在屏幕的左方出现了
一个橘黄色圆圈儿

00:05:53.287 --> 00:05:55.656
这说明这行代码有问题

00:05:56.323 --> 00:05:59.426
点击它 它告诉我这行代码有错误

00:05:59.493 --> 00:06:03.564
我需要在长方形后面加上括号
这儿有修复选项

00:06:03.630 --> 00:06:07.167
你可以点击第一个
它就会插入到文档中

00:06:07.234 --> 00:06:08.635
橘黄色的圆圈儿消失了

00:06:09.169 --> 00:06:13.607
现在点击我的代码
可以看到我画了一个长方形

00:06:14.074 --> 00:06:15.142
它是正方形 但...

00:06:18.345 --> 00:06:20.247
现在注意当我们把光标下移的时候

00:06:20.614 --> 00:06:22.716
在代码补全中出现了长方形

00:06:22.850 --> 00:06:25.185
我点击它 然后点击圆点

00:06:25.252 --> 00:06:27.120
现在它列举出了所有的不同属性

00:06:27.187 --> 00:06:29.289
和函数 我可以把它们用在长方形上

00:06:29.623 --> 00:06:32.693
为了看的更清除

00:06:32.893 --> 00:06:35.262
我们改变一下边框的颜色和宽度

00:06:35.495 --> 00:06:37.531
让我们输入边框颜色

00:06:37.831 --> 00:06:40.067
这儿有一个等号运算符 点击它

00:06:40.434 --> 00:06:43.303
我们得到一个占位符
代表某种类型的颜色

00:06:43.770 --> 00:06:47.708
注意代码补全中的第二项
是一个灰色方框

00:06:48.075 --> 00:06:51.678
这意味着我们可以插入
所见即所得的颜色

00:06:52.246 --> 00:06:55.549
点击一下我们得到一个白色的方框

00:06:56.116 --> 00:06:59.753
点击方框会出现一个快速编辑器
可以改变颜色的值

00:07:00.220 --> 00:07:02.723
Swift Playground中
有很多快速编辑器

00:07:02.789 --> 00:07:04.224
这只是一个颜色编辑器

00:07:04.291 --> 00:07:08.195
我把颜色从白色变成黑色
点击运行代码

00:07:08.662 --> 00:07:10.464
现在边框变成了黑色

00:07:10.531 --> 00:07:14.201
现在看上去不太清楚
我要增加边框的宽度

00:07:15.102 --> 00:07:17.471
点击长方形 点击圆点

00:07:18.238 --> 00:07:22.543
点击边框宽度和等号
现在出现了一个数字盘

00:07:22.809 --> 00:07:26.180
它也是一个快速编辑器
我们可以快速输入一个数字

00:07:26.346 --> 00:07:30.851
输入四 噢 点击运行

00:07:31.285 --> 00:07:33.720
现在看起来清楚多了

00:07:34.755 --> 00:07:37.658
现在我要
我想编一个程序

00:07:37.824 --> 00:07:41.828
当我在实时视图中移动手指的时候
会画出一串正方形

00:07:42.362 --> 00:07:44.131
我要写更多的代码

00:07:44.198 --> 00:07:47.668
我要把实时视图隐藏
让我有更多的空间写代码

00:07:47.734 --> 00:07:49.803
我要在屏幕的中央点击并且按住

00:07:49.870 --> 00:07:51.772
它会把屏幕分为左右两半儿

00:07:51.839 --> 00:07:54.107
现在拖动到右侧使实时视图消失

00:07:55.309 --> 00:07:57.878
现在点击源代码

00:07:58.612 --> 00:08:01.515
Swift Playgrounds
有一个很好的软键盘

00:08:01.582 --> 00:08:04.117
当你想用屏幕键盘编程的时候
可以使用它

00:08:04.184 --> 00:08:06.753
让我点击菜单中的向上按钮
把软键盘显示出来

00:08:07.221 --> 00:08:09.690
注意每个键的上方都有一个替代值

00:08:09.756 --> 00:08:10.924
后面我们会详细讲解

00:08:11.592 --> 00:08:13.961
我们首先使用canvas对象

00:08:14.094 --> 00:08:17.965
它在playground形状里
以便和实时视图进行互动

00:08:18.131 --> 00:08:21.335
让我键入C-a-n
我们有了canvas对象

00:08:21.635 --> 00:08:25.339
输入Shared
得到shared canvas

00:08:25.772 --> 00:08:27.207
现在输入Drag

00:08:27.674 --> 00:08:30.677
注意Swift
Playgrounds模糊匹配了

00:08:30.744 --> 00:08:34.181
onTouchDrag handler
仅仅通过输入Drag

00:08:34.381 --> 00:08:38.284
我点击一下就得到了
一个函数的占位空间

00:08:38.652 --> 00:08:42.389
点击回车就会扩展占位符的空间
让我们输入更多的代码

00:08:43.222 --> 00:08:46.927
现在我想创建一个程序
能随着手指拖动产生许多长方形

00:08:47.494 --> 00:08:50.864
我要做的就是把刚才的代码添加进去

00:08:51.231 --> 00:08:56.170
点击下面的大括号
并按住它 向下拖动

00:08:56.336 --> 00:08:58.405
把前面的代码包含到大括号内

00:08:59.706 --> 00:09:01.175
下一步就是

00:09:01.275 --> 00:09:04.545
我要把长方形的中心
设置为我点击的地方

00:09:05.112 --> 00:09:10.117
让我们加入一行代码
设置长方形的中心位置

00:09:10.450 --> 00:09:15.923
为canvas共享的当前触摸点

00:09:16.256 --> 00:09:18.625
它是一个数组

00:09:19.326 --> 00:09:22.095
如果我点击并且按住H
然后向右拖动

00:09:22.629 --> 00:09:24.198
就得到了数组的下标括号

00:09:24.631 --> 00:09:27.634
下面我点击并且按住P得到零号元素

00:09:28.735 --> 00:09:31.572
现在关闭代码视图 看看实时视图

00:09:32.139 --> 00:09:35.676
点击运行代码就可以开始画图了

00:09:36.910 --> 00:09:37.744
耶

00:09:44.885 --> 00:09:47.387
现在我在屏幕中央点击并且按住

00:09:47.588 --> 00:09:50.757
向左拖动把代码视图关掉
现在我可以在整屏幕上作图了

00:09:52.025 --> 00:09:55.229
我很喜欢它 有点儿艺术性
我要把它发送给Matt

00:09:55.295 --> 00:09:57.631
我要点击工具菜单

00:09:57.698 --> 00:10:02.536
你可以把实时视图截屏保存下来

00:10:04.004 --> 00:10:05.772
其实有很多程序在运行

00:10:06.540 --> 00:10:10.177
幕后做了很多工作
使playground这样运行

00:10:10.544 --> 00:10:11.845
有请Jonathan

00:10:11.912 --> 00:10:15.148
他会给我们演示

00:10:15.682 --> 00:10:21.655
Playgrounds内部的
工作原理

00:10:22.322 --> 00:10:23.490
好 Jonathan

00:10:31.031 --> 00:10:32.332
谢谢 Matt和Max

00:10:33.767 --> 00:10:35.636
iPad上的
Swift Playgrounds

00:10:35.702 --> 00:10:39.573
让你使用和在Mac上创建的
同样的Swift 3 Playground文档

00:10:39.640 --> 00:10:41.508
你也可以在iPad上创建它们

00:10:42.075 --> 00:10:45.579
你可以使用AirDrop、iCloud
Drive和其它文档提供者

00:10:45.646 --> 00:10:47.948
来转换文档并且在这些环境中
运行它们

00:10:48.015 --> 00:10:49.483
这很有趣

00:10:49.917 --> 00:10:52.953
在传统的
Playground文件格式之外

00:10:53.120 --> 00:10:56.290
iPad的Swift Playgrounds
引入了一种新的文件格式

00:10:56.356 --> 00:10:58.525
它利用了新的环境

00:10:59.193 --> 00:11:01.929
Playground Books
提供更多编程代码块

00:11:01.995 --> 00:11:03.864
可以创建交互的题材

00:11:03.931 --> 00:11:06.633
在其中你希望别人也可以一起探究

00:11:06.700 --> 00:11:08.135
你想给他们展示一些东西

00:11:08.202 --> 00:11:09.369
下面

00:11:09.436 --> 00:11:11.805
我要向你们展示一些新功能

00:11:11.872 --> 00:11:15.142
以及你们如何利用这些新功能

00:11:16.877 --> 00:11:21.748
首先Playground Books
是由按章节分组的页面构成的

00:11:21.949 --> 00:11:25.452
并且在此基础上生成了内容列表
这是为了利于浏览

00:11:28.255 --> 00:11:31.825
Playground Books提供了
一种新类型的页面叫做剧情画面

00:11:31.959 --> 00:11:35.762
这非常有用
如果你想进行全屏展示

00:11:35.996 --> 00:11:38.232
在你讲述故事的过程中

00:11:38.298 --> 00:11:41.168
你看 我们的内容团队
很好的应用了它

00:11:41.235 --> 00:11:43.437
把大的构思用有趣的方式展示出来

00:11:45.372 --> 00:11:48.008
当你介绍概念的时候
你可以使用词汇表功能

00:11:48.075 --> 00:11:51.044
动动手指就可以
把术语和它们的定义联系起来

00:11:51.378 --> 00:11:54.147
这些术语和定义集中起来

00:11:54.214 --> 00:11:56.016
储存在某个地方以供参考

00:11:58.385 --> 00:12:02.356
满是Swift代码的
Playground页面令人生畏

00:12:02.422 --> 00:12:06.560
有时你不想从你要展示的细节处分心

00:12:06.760 --> 00:12:09.763
Playground Books
使学习者能够集中精力

00:12:09.830 --> 00:12:11.365
这是通过使用编辑区域实现的

00:12:11.798 --> 00:12:14.968
你用特别的注释
注释你的Swift代码

00:12:15.469 --> 00:12:17.938
它们开始是空白的
学习者可以在以后添加进去

00:12:18.238 --> 00:12:21.241
这会减少你的分心
特别是在早期阶段

00:12:21.308 --> 00:12:23.710
当你尽力展示一个
复杂概念的时候

00:12:26.046 --> 00:12:29.716
Playground Books
让你标记不想显示的代码

00:12:30.250 --> 00:12:33.420
隐藏代码区使你能够
灵活的运行、创建

00:12:33.487 --> 00:12:36.757
和删除代码
在中间的某种工作区中

00:12:36.924 --> 00:12:39.026
最初把细节隐藏起来
是一个很好的方式

00:12:39.092 --> 00:12:40.827
然后你可以拉开窗帘儿

00:12:40.894 --> 00:12:43.897
在你准备好的时候魔术般的展现
已经创建好的代码

00:12:46.133 --> 00:12:48.502
Playground Books
让你可以配置快捷按钮

00:12:48.569 --> 00:12:50.470
它们在代码补全菜单条上显示

00:12:50.537 --> 00:12:54.341
你可以指定或者删除标示符、
模块、关键字等等

00:12:54.608 --> 00:12:56.810
在注释中定制那些内容会出现

00:12:59.947 --> 00:13:02.950
用新的文件格式
你可以配置实时视图

00:13:03.050 --> 00:13:06.486
在页面加载时实时视图立即呈现出来

00:13:06.753 --> 00:13:08.956
它在一个独立的进程中
运行Swift 代码

00:13:09.022 --> 00:13:12.526
完全独立于
编辑器中输入和运行的代码

00:13:12.826 --> 00:13:15.996
编辑器代码在左侧
实时视图代码在右侧

00:13:16.063 --> 00:13:18.765
他们用一个特殊的XPC机制通信

00:13:19.032 --> 00:13:22.035
下面我们要看看这是怎么实现的
你可以浏览

00:13:22.369 --> 00:13:25.405
我的演示
这样你就可以使用这个机制了

00:13:25.472 --> 00:13:28.175
交互式可视化是一个很好的方式

00:13:28.242 --> 00:13:31.345
在编辑器中创建代码
同时代码立即运行

00:13:33.547 --> 00:13:36.016
如果你想一边思考

00:13:36.083 --> 00:13:38.352
一边创建实现某个东西

00:13:38.552 --> 00:13:41.255
你可以为键入的代码
提供提示内容

00:13:41.355 --> 00:13:43.957
学习者可以通过点击
提示按钮得到提示

00:13:45.359 --> 00:13:48.595
如果他们成功的完成了任务
你可以让他们知道

00:13:48.896 --> 00:13:50.163
通过一条成功消息

00:13:52.766 --> 00:13:55.702
Playground Books
记住你对每个页面评价

00:13:55.769 --> 00:13:59.072
学习者在内容列表中
可以看到他们已经完成的内容

00:13:59.139 --> 00:14:03.243
使用这些提示和评估机制
可以使你更有动力设计下去

00:14:05.646 --> 00:14:09.383
你还可以访问文档中的
一个简单的键/值库

00:14:09.483 --> 00:14:13.320
这样你可以跟踪偏好
或者甚至更高级的进展

00:14:13.420 --> 00:14:15.956
当学习者在一页一页浏览书的时候

00:14:17.824 --> 00:14:19.860
Playground Books
是可重置的

00:14:20.260 --> 00:14:22.963
做出的改变都存放在一个独立的区域

00:14:23.030 --> 00:14:26.967
它们独立于主文件内容以外
如果学习者选择

00:14:27.467 --> 00:14:31.171
他们可以把页面恢复到
第一次打开时的状态

00:14:32.439 --> 00:14:34.575
整个文档也可以重置

00:14:34.842 --> 00:14:38.011
每个页面都是原始状态
键/值库也被清除

00:14:38.111 --> 00:14:40.848
评估可以重置
它们可以重新开始

00:14:43.283 --> 00:14:46.753
最后 但同样重要的是
在developer.apple.com上

00:14:46.820 --> 00:14:48.822
你可以看到该格式的文档

00:14:48.922 --> 00:14:50.657
我们要确保你知道它是如何运行的

00:14:50.724 --> 00:14:54.127
你就能够定制自己内容产品工作流程

00:14:54.194 --> 00:14:55.295
让奇迹发生吧

00:14:55.662 --> 00:14:57.598
从这些例子和参考开始吧

00:14:57.664 --> 00:15:00.534
仔细研究甚至把Playground
Books读烂学到更多东西

00:15:00.601 --> 00:15:03.103
Playground Books是
我们内容团队创建的

00:15:10.477 --> 00:15:11.478
好你们明白了

00:15:11.545 --> 00:15:13.213
现在我想介绍一本
Playground Book

00:15:13.280 --> 00:15:16.550
它是我创建的
我想向你们展示

00:15:16.617 --> 00:15:18.252
从作者的角度你会体验到什么？

00:15:18.385 --> 00:15:20.754
所以本书的读者

00:15:20.821 --> 00:15:23.690
是你们这些Swift的用户

00:15:23.757 --> 00:15:26.627
你们甚至用过
Mac上Playgrounds

00:15:26.693 --> 00:15:29.630
但是Playground Book格式
是新事物

00:15:29.696 --> 00:15:31.832
你们也想进一步
了解它的工作原理

00:15:31.899 --> 00:15:34.067
我编辑这本Playground
Book旨在创建

00:15:34.134 --> 00:15:37.137
一个实时的参考演示
演示这些新的

00:15:37.204 --> 00:15:40.007
在线实时视图是如何工作的
以及你如何同它交流

00:15:40.641 --> 00:15:42.142
现在开始

00:15:42.209 --> 00:15:44.144
还有什么比...

00:15:44.912 --> 00:15:46.313
用一个
Playground Book

00:15:46.380 --> 00:15:49.082
来演示
Playground Books

00:15:49.149 --> 00:15:51.451
的新特性的更好方式呢？

00:15:53.187 --> 00:15:55.189
听起来有点绕

00:15:55.255 --> 00:15:56.456
好的 那么...

00:15:56.957 --> 00:15:57.991
我们开始吧

00:15:58.058 --> 00:15:59.293
这儿有文档浏览器

00:15:59.359 --> 00:16:01.195
我要找出
我的Playground Book

00:16:01.261 --> 00:16:03.197
点击“同实时视图交流”

00:16:04.264 --> 00:16:07.401
你可以看到实时视图
立即开始运行了

00:16:07.467 --> 00:16:08.802
注意编辑器上的代码

00:16:08.869 --> 00:16:11.371
甚至还没有编译
它根本没有运行

00:16:11.438 --> 00:16:14.274
我所写的代码在一个独立的进程中

00:16:14.374 --> 00:16:18.145
在线实时视图显示
了一个漂亮的小脸

00:16:18.212 --> 00:16:19.646
它是Em

00:16:19.847 --> 00:16:22.349
它是一个Swift程序
它喜欢

00:16:22.416 --> 00:16:24.251
玩“敲 敲”游戏

00:16:25.185 --> 00:16:27.821
在简介页面上我们可以看到

00:16:27.888 --> 00:16:30.224
游戏是为了交谈逗乐

00:16:30.424 --> 00:16:32.693
学习者不需要详细了解

00:16:32.759 --> 00:16:36.330
我们是如何把消息发送给实时视图的

00:16:36.396 --> 00:16:38.599
我只想让你们觉得很有趣

00:16:38.732 --> 00:16:40.901
上面附加了有趣的描述

00:16:41.168 --> 00:16:43.637
我们要做的是发送信息

00:16:43.704 --> 00:16:45.906
使用下面的Say函数

00:16:46.507 --> 00:16:48.475
这些字符将被发送到另一面

00:16:48.575 --> 00:16:51.078
它们会启动对话状态机

00:16:51.144 --> 00:16:55.516
这是Em运行的一个程序
随着笑话继续它会不停的运行

00:16:55.582 --> 00:16:57.918
我们从这儿开始
这儿已经填好了一个字符串

00:16:57.985 --> 00:17:00.220
“敲 敲” 我只要按下
运行代码按纽

00:17:00.721 --> 00:17:02.689
Em会回答 “你是谁？”

00:17:02.756 --> 00:17:05.392
左边的代码被编译运行

00:17:05.492 --> 00:17:08.462
用Say函数奇迹就发生了

00:17:08.529 --> 00:17:10.130
字符串被传递到另一面

00:17:10.196 --> 00:17:12.299
过一会儿我们会讲解
奇迹是如何发生的

00:17:12.866 --> 00:17:13.934
让我们继续

00:17:14.001 --> 00:17:16.103
我要说“Boo”

00:17:16.170 --> 00:17:18.137
我在使用外接键盘输入

00:17:18.204 --> 00:17:19.806
因为我不想让内置键盘

00:17:19.873 --> 00:17:21.241
占去屏幕

00:17:21.508 --> 00:17:24.077
点击运行代码按扭
字符串被传送过去

00:17:24.744 --> 00:17:25.846
“Boo！是谁？”

00:17:27.414 --> 00:17:29.016
“你在哭吗？”

00:17:30.484 --> 00:17:31.618
点击运行代码

00:17:37.224 --> 00:17:40.527
Em正确的识别了
这个敲敲笑话是经典的

00:17:40.594 --> 00:17:42.763
让我们再试一次
看看它会怎样

00:17:42.930 --> 00:17:45.599
我需要重启Em的对话状态机

00:17:45.666 --> 00:17:47.768
我要开始 键入“敲 敲”

00:17:47.835 --> 00:17:51.171
点击运行代码按钮
编译和运行 传送字符串

00:17:51.271 --> 00:17:52.906
字符串通过线缆传到另一面

00:17:53.207 --> 00:17:54.074
“你是谁？”

00:17:54.641 --> 00:17:58.011
UInt Swift的无符号整数类型

00:17:59.613 --> 00:18:00.547
“UInt是谁？”

00:18:01.448 --> 00:18:04.818
“你对更好笑的笑话感兴趣吗？”

00:18:13.493 --> 00:18:16.463
看起来你们赞同Em此时的回应

00:18:16.964 --> 00:18:18.332
很不幸 但是...

00:18:19.633 --> 00:18:23.070
我们在这儿用这个想法做了个实验

00:18:23.136 --> 00:18:25.305
好的进入下一页

00:18:25.372 --> 00:18:28.575
奇迹的秘密被揭开了

00:18:28.642 --> 00:18:30.777
你可以看到Say函数的具体代码

00:18:30.844 --> 00:18:34.515
这些代码把字符串传送给
实时视图进程

00:18:34.882 --> 00:18:37.217
过一会儿我们再看里面的细节

00:18:37.551 --> 00:18:39.453
这是一本Playground Book

00:18:39.520 --> 00:18:43.257
它不断的监听在线实时视图的API

00:18:43.323 --> 00:18:44.825
这是从作者的角度看到的

00:18:44.892 --> 00:18:47.194
你也可以在下面的页面中学习到

00:18:47.261 --> 00:18:50.297
如何发送更复杂的命令给Em

00:18:50.364 --> 00:18:52.399
你可以配置它识别新的设置

00:18:52.466 --> 00:18:54.034
改变笑话的模式

00:18:54.101 --> 00:18:57.171
你甚至可以把笑话模式
储存在键/值库中

00:18:57.371 --> 00:18:59.606
在以后你可以加载它们逗乐

00:18:59.673 --> 00:19:01.742
在下一次你打开
Playground Book的时候

00:19:02.342 --> 00:19:05.946
Playground Book

00:19:06.013 --> 00:19:07.114
可以和我们的演讲资料一起下载

00:19:07.181 --> 00:19:08.882
演讲后你可以查阅一下

00:19:08.949 --> 00:19:11.018
现在我们要进一步了解

00:19:11.084 --> 00:19:13.854
从作者的角度看 它是如何运行的？

00:19:20.427 --> 00:19:23.664
Playground Books是
一个特殊的文件格式

00:19:23.797 --> 00:19:27.601
以适应在触摸设备上教授这些概念

00:19:27.734 --> 00:19:29.036
例如iPad等设备

00:19:29.903 --> 00:19:32.673
他们是扩展名为
.playgroundbook的文件夹

00:19:32.739 --> 00:19:35.976
操作系统认为它是一个文件包

00:19:36.109 --> 00:19:39.479
你可以使用任何编辑器
在Mac上编辑

00:19:39.546 --> 00:19:41.548
你可以使用Xcode
你最喜爱的文本编辑器

00:19:41.615 --> 00:19:43.250
使用你的版本控制系统

00:19:43.317 --> 00:19:46.119
编译自己的定制内容管理工作流

00:19:46.186 --> 00:19:49.456
如果你需要 还可以在Playground
Books中生成内容

00:19:50.490 --> 00:19:53.126
我们看看这个包是由那些文件组成的

00:19:53.293 --> 00:19:55.329
这个包包括文件和文件夹

00:19:55.395 --> 00:19:59.032
以及使所有一切运行的
Swift代码资源库配置

00:20:00.367 --> 00:20:02.135
这是简要的概述

00:20:02.202 --> 00:20:04.371
后面我们会再详细讲解

00:20:04.438 --> 00:20:06.607
先让我们看看所有一切
是怎么组织起来的

00:20:07.541 --> 00:20:09.409
在文件包的根目录

00:20:09.476 --> 00:20:12.179
有一个文件夹叫内容
你会猜到

00:20:12.346 --> 00:20:14.381
这儿存放你编写的内容

00:20:16.049 --> 00:20:18.452
里面有两个文件夹
你会认得它们

00:20:18.519 --> 00:20:20.454
如果你以前写过playgrounds程序

00:20:20.888 --> 00:20:23.590
Sources文件夹
存放全局Swift文件

00:20:23.657 --> 00:20:26.193
这些文件已经编译好了
供每个页面使用

00:20:26.260 --> 00:20:27.528
在你的
Playground Book中

00:20:28.061 --> 00:20:30.531
你甚至不需要导入它们

00:20:30.597 --> 00:20:33.033
任何声明为public的文件
都可被其它页面使用

00:20:33.100 --> 00:20:34.568
一旦你打开页面

00:20:35.102 --> 00:20:36.436
然后是Resources
文件夹...

00:20:38.338 --> 00:20:40.807
包含页面需要的资源

00:20:40.874 --> 00:20:43.243
储存有你的图像文件、
声音文件和其它资源

00:20:43.310 --> 00:20:46.847
你可以通过文件名加载它们
就可以把它们拖到相应的文件中

00:20:47.281 --> 00:20:50.217
注意这两个文件夹在根目录上

00:20:50.284 --> 00:20:52.986
文件包的根目录
因此它们中的所有文件

00:20:53.053 --> 00:20:56.056
在整本书中的每一个页面都可以使用

00:20:56.323 --> 00:20:59.326
如果你愿意 你可以把它们限制到
只能在某些章节使用

00:20:59.393 --> 00:21:01.862
通过把Sources和
Resources文件夹放置在那儿

00:21:02.062 --> 00:21:03.297
甚至限制到只能在某个页面使用

00:21:03.363 --> 00:21:05.832
并且你可以在其他页面中
不分享这些东西

00:21:05.899 --> 00:21:08.268
完全由你决定
定制化是供你使用的

00:21:09.536 --> 00:21:12.072
下一个文件夹是Chapters文件夹

00:21:12.139 --> 00:21:14.942
正如你所料 它由章节组成

00:21:15.075 --> 00:21:18.879
每个文件夹含有一个或多个页面

00:21:19.279 --> 00:21:21.815
每个页面是一个文件夹

00:21:23.050 --> 00:21:25.352
它含有可以和你互动的内容

00:21:25.419 --> 00:21:28.322
当在应用中使用
Playground Book时

00:21:28.555 --> 00:21:32.559
我们首先看看这个文件
Manifest.plist

00:21:32.726 --> 00:21:36.730
它是一个特殊的配置文件
设置页面的工作方式

00:21:36.897 --> 00:21:39.466
打开这个文件
它看起来是这个样子的

00:21:39.566 --> 00:21:40.767
我们会慢慢看
不要担心

00:21:41.201 --> 00:21:45.005
Manifest文件是属性的列表
是键和值的词典

00:21:45.072 --> 00:21:47.641
Swift Playground
用它决定一个文档页面

00:21:47.708 --> 00:21:49.610
如何工作

00:21:50.010 --> 00:21:52.379
这些manifest文件
用于配置章节层和

00:21:52.546 --> 00:21:54.948
文档层的行为

00:21:55.015 --> 00:21:57.551
例如内容列表中的内容排序

00:21:57.851 --> 00:21:59.887
今天我们准备主要讲解
一下页面的manifest

00:21:59.953 --> 00:22:03.757
因为它对刚才显示中你看到的
内容影响最大

00:22:03.824 --> 00:22:06.994
我们看看每一个配置机制

00:22:07.060 --> 00:22:08.795
是如何影响页面的

00:22:10.230 --> 00:22:14.768
属性列表的第一个键是名字
你可以猜到

00:22:14.902 --> 00:22:17.905
它设置文档顶部的名字
它也用在

00:22:17.971 --> 00:22:19.306
内容列表中

00:22:21.308 --> 00:22:24.811
下一个键实时视图模式
控制实时视图的工作方式

00:22:24.878 --> 00:22:26.313
当页面第一次被打开时

00:22:26.513 --> 00:22:29.983
通常实时视图是隐藏的
直到它在代码中被激活

00:22:30.050 --> 00:22:32.553
或者学习者让它显示在屏幕上

00:22:32.619 --> 00:22:35.422
如果我想让它
在页面打开时立即显示

00:22:35.489 --> 00:22:39.092
我可以把这个键改为默认可见

00:22:39.459 --> 00:22:40.894
我就得到了我想要的行为

00:22:43.063 --> 00:22:47.534
PosterReference键
设置

00:22:47.601 --> 00:22:49.736
在Resources文件夹中
查找一文件

00:22:50.404 --> 00:22:53.106
这个文件会成为一个海报
它会覆盖

00:22:53.173 --> 00:22:56.343
实时视图区域
在实时视图进程

00:22:56.410 --> 00:22:59.179
在页面打开后运行以前

00:22:59.246 --> 00:23:02.583
你看
一旦实时视图进程开始运行

00:23:02.649 --> 00:23:04.751
海报图像就消失了

00:23:05.219 --> 00:23:07.588
我们就可以看到下面的
实时视图的内容了

00:23:09.690 --> 00:23:12.626
LiveViewEdgetoEdge键是
一个布尔值

00:23:12.693 --> 00:23:15.829
它决定实时视图的内容区域是否

00:23:15.896 --> 00:23:18.899
扩展到视窗的边界

00:23:18.966 --> 00:23:21.602
并且在下面显示运行代码按钮

00:23:21.668 --> 00:23:22.870
就像在这儿看到的一样

00:23:22.936 --> 00:23:25.539
我想把它设成这样我就选择是

00:23:26.573 --> 00:23:28.876
如果你把LiveViewEdgetoEdge
设置为否

00:23:28.942 --> 00:23:31.011
并且你为实时视图设置了背景颜色

00:23:31.078 --> 00:23:32.246
就是这样的

00:23:32.513 --> 00:23:35.115
注意它嵌入的的边界

00:23:35.382 --> 00:23:37.584
它没有被运行代码按钮覆盖

00:23:37.651 --> 00:23:42.122
你来决定用哪种模式
根据你的内容

00:23:42.422 --> 00:23:47.094
例如如果你需要视图
全部控制触摸区域

00:23:47.160 --> 00:23:49.229
就把LiveViewEdgetoEdge
设置为否

00:23:49.329 --> 00:23:51.098
就会得到你想要的结果

00:23:53.667 --> 00:23:57.004
Playground日志模式
控制内联结果

00:23:57.070 --> 00:24:00.607
你会看到在编辑器每一行
的右端有一个返回值

00:24:01.074 --> 00:24:05.179
在这个例子中
我的实时视图报告了需要的结果

00:24:05.245 --> 00:24:07.548
我就把PlaygroundLoggingMode

00:24:07.614 --> 00:24:11.752
设置为关闭
它会完全关闭内联结果

00:24:14.021 --> 00:24:17.357
现在我已介绍了Playground
文件格式的互动功能

00:24:17.424 --> 00:24:20.227
它们使应用非常有趣

00:24:20.627 --> 00:24:23.497
让我们看看这个文件
Contents.swift

00:24:25.299 --> 00:24:29.269
你们都已见过了
Contents.swift文件

00:24:29.770 --> 00:24:32.439
无论是全屏而是位于左侧

00:24:32.506 --> 00:24:34.074
位于实时视图的左侧
就和现在一样

00:24:34.474 --> 00:24:37.811
编辑器中所有的内容
来自Contents.swift文件

00:24:37.878 --> 00:24:40.848
当你点击运行按钮时
文件中的所有内容

00:24:40.914 --> 00:24:43.417
和它引用的所有内容被执行

00:24:44.818 --> 00:24:48.689
在我的简介页面中
Contents.swift是这样

00:24:48.889 --> 00:24:53.260
顶部是Playground注释
用以帮助描述软件的功能

00:24:53.360 --> 00:24:56.630
你的目标、如何得分和操作说明

00:24:56.697 --> 00:24:58.465
通过阅读页面

00:24:58.532 --> 00:25:00.367
可以了解如何和软件互动

00:25:01.301 --> 00:25:04.071
以前用Playgrounds写过
软件的人会认得它

00:25:04.538 --> 00:25:06.740
它是标准的Playground注释

00:25:08.542 --> 00:25:10.744
这儿有几行代码
用来创建页面

00:25:10.811 --> 00:25:13.580
真正的操作就会实现

00:25:14.047 --> 00:25:17.050
但是我不想让这一部分被人们看到
至少在这一页上

00:25:17.384 --> 00:25:20.153
所以我用特别的魔术注释
来标记隐藏代码块的开始

00:25:20.220 --> 00:25:21.889
和结束

00:25:22.222 --> 00:25:24.691
这两行之间的代码被隐藏了

00:25:25.125 --> 00:25:27.461
但是在运行的时候 它们会被执行

00:25:27.594 --> 00:25:29.963
但是当你打开这个页面的时候
它们不会显示

00:25:30.030 --> 00:25:31.765
在iPad的Swift
Playgrounds中

00:25:33.433 --> 00:25:35.802
这个Playground
page的真正工作

00:25:35.869 --> 00:25:38.138
是从这个语句开始的
就是对Say函数的调用

00:25:38.205 --> 00:25:40.174
而Say函数被写在隐藏代码中

00:25:40.574 --> 00:25:43.710
现在我想确保学习者

00:25:43.777 --> 00:25:47.014
来到这个页面
填入函数参数的时候

00:25:47.080 --> 00:25:49.249
不会不小心造成编译错误

00:25:49.716 --> 00:25:53.520
我使用了可编辑代码区

00:25:53.754 --> 00:25:55.489
把特殊的魔术注释

00:25:55.556 --> 00:25:58.091
放在可编辑代码区的首部和尾部

00:25:58.258 --> 00:26:00.327
只有在这儿可以输入代码

00:26:00.961 --> 00:26:03.297
只要你高兴 在页面上添加
多少个这样注释都可

00:26:03.564 --> 00:26:07.434
一旦你用了这个注释
只有在这个区域能够输入内容

00:26:07.501 --> 00:26:10.370
这正是我所需要的
学习者可以随便输入

00:26:10.437 --> 00:26:12.206
他们仅仅能够改变字符串

00:26:14.007 --> 00:26:17.311
高级的Playground的作者
会注意到这个占位符的语法

00:26:17.511 --> 00:26:20.914
这些尖括号和＃号
会产生一个透明圆形罩

00:26:20.981 --> 00:26:22.482
显示在编辑器中

00:26:22.783 --> 00:26:25.419
学习者点击它
就可以键入任何内容

00:26:25.485 --> 00:26:27.688
来代替原来的内容

00:26:27.888 --> 00:26:29.790
这种方式很好的提示了

00:26:29.857 --> 00:26:31.258
应在某地方进行怎样的操作

00:26:33.594 --> 00:26:36.964
刚才我总结了
Contents.swift中内容

00:26:37.130 --> 00:26:39.032
对左侧边框的总结

00:26:39.099 --> 00:26:40.901
现在我们转向

00:26:40.968 --> 00:26:45.606
右侧边框
看看在线实时视图中发生了什么

00:26:47.040 --> 00:26:51.245
介绍页面有一个文件
叫做LiveView.swift

00:26:52.546 --> 00:26:53.881
这就是

00:26:54.348 --> 00:26:56.683
首先我们导入
PlaygroundSupport

00:26:56.850 --> 00:26:58.952
那些以前用
Playgrounds编辑过的人

00:26:59.019 --> 00:27:02.289
对XE Playground很熟悉
它是一个框架 让你能访问

00:27:02.356 --> 00:27:03.790
页面环境

00:27:04.024 --> 00:27:05.959
现它被重新命名了
它是新的而且升级了

00:27:06.026 --> 00:27:09.229
它叫Playground Support
你可用它继续开发软件

00:27:10.564 --> 00:27:13.400
我们请求当前的
Playground页面

00:27:14.935 --> 00:27:18.372
然后在页面上我们设置了
实时视图的属性

00:27:18.438 --> 00:27:22.276
把它设置为一个新实例
叫做FaceViewController

00:27:22.676 --> 00:27:24.745
FaceViewController
是从哪儿来的呢？

00:27:25.078 --> 00:27:26.680
它是Swift代码的一部分

00:27:26.747 --> 00:27:29.516
储存在文档根目录的
Sources目录中

00:27:29.816 --> 00:27:32.553
这是我创建的代码库

00:27:32.619 --> 00:27:34.621
能够在所有页面中共享使用

00:27:34.688 --> 00:27:37.824
这儿我写下的所有代码
只要被标记为public我都可以引用

00:27:39.193 --> 00:27:40.994
现在如果你愿意 你能够

00:27:41.061 --> 00:27:45.299
在LiveView.swift文件
里面写下所有的实时视图代码

00:27:45.365 --> 00:27:47.034
谁也阻止不了你那样做

00:27:47.367 --> 00:27:49.436
但是然后你要把文档拷贝到

00:27:49.503 --> 00:27:51.705
其它的Playground
Book页面中

00:27:51.772 --> 00:27:53.807
来共享同样的实时视图动作

00:27:53.907 --> 00:27:56.210
我的Playground Book
文档的所有页面

00:27:56.276 --> 00:28:01.515
我仅仅使用了这三行代码作为设置
就使Playground

00:28:01.582 --> 00:28:03.450
使在线实时视图运行

00:28:03.517 --> 00:28:05.052
它们都共享了FaceViewController

00:28:05.118 --> 00:28:06.820
我只要把这个文件拷贝到

00:28:06.887 --> 00:28:09.022
需要使用它的任何页面中

00:28:11.158 --> 00:28:13.160
那些以前编辑过
Playgrounds的人

00:28:13.227 --> 00:28:16.230
可能感觉这个代码很熟悉

00:28:16.296 --> 00:28:18.265
这不就是设置实时视图吗

00:28:18.332 --> 00:28:20.834
如果你在Contents.swift
中这样做的话

00:28:21.668 --> 00:28:24.538
是的 你仍然可以这样做

00:28:24.738 --> 00:28:28.075
如果你选择这样做的话
它在主进程中运行

00:28:28.509 --> 00:28:30.978
和编译器的所有代码一起运行

00:28:31.044 --> 00:28:35.482
那真的很有用
因为你能够访问实时视图对象

00:28:35.549 --> 00:28:39.686
你可以获取page.liveview
把它投递到FaceViewController中去

00:28:39.753 --> 00:28:41.388
然后和操作别的东西一样操作它

00:28:41.455 --> 00:28:45.158
调用它的方法 改变它的属性
它就是你的进程的一部分

00:28:45.659 --> 00:28:47.828
但是那意味着实时视图仅仅是活动的

00:28:47.895 --> 00:28:50.230
当编辑器中的代码运行的时候

00:28:50.364 --> 00:28:53.767
只有当学习者按下运行代码
按纽时它才开始启动

00:28:54.067 --> 00:28:56.737
学习者按下停止按钮

00:28:56.803 --> 00:28:58.672
或者学习者在编辑器中输入时
它就会停止

00:28:58.805 --> 00:29:02.309
如果代码中有编译错误它不能运行

00:29:02.376 --> 00:29:04.444
这些代码现在正在编辑器中输入

00:29:05.979 --> 00:29:09.683
这就是为什么在线实时视图

00:29:09.750 --> 00:29:11.585
和LiveView.swift
引入的原因

00:29:11.652 --> 00:29:16.757
如果Playground Book页面中
有一个文件叫做LiveView.swift

00:29:17.057 --> 00:29:19.826
就自动生成了在线实时视图

00:29:19.893 --> 00:29:22.596
页面打开时这个文件就运行了

00:29:22.896 --> 00:29:24.865
并且它在一个独立的进程中运行

00:29:24.932 --> 00:29:28.368
那太棒了
因为那样它就一直在运行

00:29:29.536 --> 00:29:32.573
即使编辑器中的代码没有运行
或者不能编译

00:29:33.240 --> 00:29:36.610
换来的是你不能把实时视图投递到

00:29:36.677 --> 00:29:38.912
FaceViewController实例中
并且和它交流

00:29:39.012 --> 00:29:40.480
就像你们以前那样

00:29:40.681 --> 00:29:43.450
你必须使用某种跨进程机制

00:29:43.517 --> 00:29:47.054
来回传递消息 并且...
我们后面会详细讲解

00:29:48.589 --> 00:29:51.291
我们在Contents.swift的主进程中
有了这个代码

00:29:51.592 --> 00:29:55.262
这是编辑器中的代码运行的主进程

00:29:56.463 --> 00:29:59.566
我想把字符串“敲 敲”
送到另一侧

00:29:59.633 --> 00:30:02.035
我们首先要导入
PlaygroundSupport

00:30:02.569 --> 00:30:04.438
我们访问当前页面

00:30:04.771 --> 00:30:07.541
我们请求页面的实时视图

00:30:07.608 --> 00:30:10.511
我们没有把它投递到
FaceViewController中去

00:30:10.611 --> 00:30:14.715
我把它投递到这个特殊的类
PlaygroundRemoteLiveViewProxy中

00:30:15.215 --> 00:30:17.551
这个类的实例用来的

00:30:17.818 --> 00:30:21.021
通过线缆在两个进程之间
传递信息

00:30:21.154 --> 00:30:23.790
如果这个条件投递成功了

00:30:23.857 --> 00:30:26.426
那就是代码中的一个队列
它运行在

00:30:26.493 --> 00:30:30.597
主进程中
你就会得到这个页面的在线实时视图

00:30:30.664 --> 00:30:31.899
我们把这个作为消息

00:30:32.432 --> 00:30:34.801
假设这些都好了
我们已经把它投递过去了

00:30:34.868 --> 00:30:37.738
现在实时视图运行了
我们有代理

00:30:38.405 --> 00:30:39.640
我们设计了一个消息

00:30:40.807 --> 00:30:43.477
消息传送机制使用
PlaygroundValue

00:30:43.544 --> 00:30:46.947
它是个枚举类型的值
我们一会儿会详细介绍

00:30:47.014 --> 00:30:49.049
看看这一行你可能会猜到

00:30:49.116 --> 00:30:52.719
我们设计的一个字符串

00:30:52.786 --> 00:30:55.189
“敲 敲”
然后我们把这个消息

00:30:55.255 --> 00:30:57.357
传递给代理

00:30:57.658 --> 00:30:59.793
调用发送方法把它传递出去

00:31:01.161 --> 00:31:05.232
Contents.swift中的
代码会把字符串

00:31:05.299 --> 00:31:09.169
传递给实时视图代理
然后实时视图代理

00:31:09.236 --> 00:31:14.174
把它传递给另一侧的监听方

00:31:14.241 --> 00:31:17.811
我们需要连接FaceViewController
从而能够接收到消息

00:31:19.580 --> 00:31:21.548
在我们的代码库中

00:31:22.082 --> 00:31:25.853
我们已经扩展了FaceViewController
我们说过它遵循

00:31:25.919 --> 00:31:29.089
PlaygroundLiveView
MessageHandler协议

00:31:29.289 --> 00:31:33.493
那意味着我们必须实现接收方法
以获得PlaygroundValue值

00:31:33.861 --> 00:31:37.397
它将会被调用
因为FaceViewController

00:31:37.631 --> 00:31:42.669
是实时视图 因为我们把它的值赋给了
page.liveview属性

00:31:42.736 --> 00:31:45.772
这就是实时视图代理所知道的
作为队列

00:31:45.839 --> 00:31:47.841
它需要接收消息

00:31:49.176 --> 00:31:51.612
在消息内 我们取得消息的参数

00:31:51.678 --> 00:31:55.582
查看它携带的枚举类型
抽取相关的值

00:31:55.649 --> 00:31:57.985
我现在仅仅关心字符串
因此我们就使用

00:31:58.051 --> 00:32:02.322
if case let语句检查
这样如果是为真

00:32:02.389 --> 00:32:05.459
这个枚举的值就
绑定给标识符文本

00:32:06.059 --> 00:32:08.495
现在在if语句中有一个字符串

00:32:08.795 --> 00:32:09.997
我们要继续进行下去

00:32:10.130 --> 00:32:11.632
在这种情况下 我们把它传递给

00:32:11.698 --> 00:32:14.201
函数processConversationLine

00:32:14.334 --> 00:32:17.104
它会启动Em的对话状态机

00:32:19.406 --> 00:32:23.010
那么我们如何把信息
传递给另一方呢？

00:32:23.076 --> 00:32:25.179
例如我们设置了当你在脸上
点击时要显示的信息

00:32:25.245 --> 00:32:27.748
我们得到了字符串“Hello”
如何把它传递回去呢？

00:32:28.081 --> 00:32:29.349
我们如何做呢？

00:32:31.418 --> 00:32:33.954
好的 首先 在实时视图进程中
你需要一个机制

00:32:34.021 --> 00:32:36.623
能够触发发送消息
我已经选择

00:32:36.723 --> 00:32:39.693
在脸上设置一个
触摸手势识别器

00:32:39.760 --> 00:32:41.929
那会回调触摸方法

00:32:42.362 --> 00:32:43.530
一旦你触摸脸部

00:32:43.597 --> 00:32:47.668
我们设计一个PlaygroundValue
消息 发送一个字符串

00:32:47.734 --> 00:32:51.872
例如“hello”
然后我们对自己

00:32:51.939 --> 00:32:55.876
调用发送
把这个消息发送给另一侧

00:32:55.943 --> 00:32:57.878
现在发送方法来自哪儿？

00:32:58.345 --> 00:33:00.747
好的 通过声明我们遵循

00:33:00.814 --> 00:33:03.250
PlaygroundLiveView
MessageHandler协议

00:33:03.317 --> 00:33:06.653
它会锁定我们的类
它是自动完成的 很方便

00:33:07.254 --> 00:33:10.824
在协议扩展中定义了发送方法
它有一个默认的实现

00:33:10.891 --> 00:33:14.761
因为这个类是实时视图
调用发送方法

00:33:14.828 --> 00:33:17.764
会仅仅把消息传送给实时视图代理

00:33:17.831 --> 00:33:20.133
它会到达另一方

00:33:21.201 --> 00:33:22.102
就像这样

00:33:22.402 --> 00:33:23.704
你在脸上点击

00:33:24.204 --> 00:33:26.940
产生“hello”字符串
并且被传送给实时视图代理

00:33:27.574 --> 00:33:30.377
现在实时视图代理要把消息

00:33:30.444 --> 00:33:33.347
传送给另一侧的监听方

00:33:33.680 --> 00:33:35.482
看看我们怎么把它们联通起来？

00:33:36.650 --> 00:33:39.920
我们需要设置很多东西
因为按照默认

00:33:40.153 --> 00:33:41.054
你在Contents.swift中
写的代码

00:33:41.154 --> 00:33:43.757
会停止运行

00:33:43.824 --> 00:33:45.559
在到达最后一条语句的时候

00:33:46.059 --> 00:33:47.694
然而在本例中我们不想这样做

00:33:47.861 --> 00:33:50.664
我们想让信息异步出现

00:33:50.764 --> 00:33:52.366
也就是晚一些出现

00:33:52.499 --> 00:33:54.768
我们要先抓取
Playground页面

00:33:54.835 --> 00:33:57.504
然后告诉它我们不想让它停止

00:33:57.771 --> 00:34:00.807
通过把needsIndefiniteExecution
属性设置为真

00:34:02.075 --> 00:34:04.878
我们请求实时视图代理
就像我们前面做的那样

00:34:05.078 --> 00:34:06.947
现在我们需要有某个东西

00:34:07.014 --> 00:34:09.815
作为可以接收消息的代理的代理

00:34:09.917 --> 00:34:13.687
现在我要开始
已经有一个类了

00:34:14.353 --> 00:34:15.422
注意它遵循

00:34:15.489 --> 00:34:18.458
PlaygroundRemoteLiveView
ProxyDelegate协议

00:34:18.525 --> 00:34:22.563
这意味着我必须实现remoteLiveView
Proxy的接收方法

00:34:23.230 --> 00:34:24.130
好啦

00:34:24.197 --> 00:34:26.266
它将会被实时视图代理调用

00:34:26.333 --> 00:34:29.837
我们可以把
Playground的值分开

00:34:29.902 --> 00:34:31.737
使用if case let语句

00:34:31.905 --> 00:34:34.675
可以对文本进行一些处理

00:34:35.775 --> 00:34:38.812
它定义了代理
我们要把它们联通起来

00:34:38.879 --> 00:34:41.215
我们要把它实例化
然后把它的值赋给

00:34:41.348 --> 00:34:44.150
代理的代理参数 或者代理属性

00:34:44.384 --> 00:34:45.752
现在完成了

00:34:46.353 --> 00:34:48.322
现在我们有
FaceViewController

00:34:48.422 --> 00:34:49.656
你的脸上点击一下

00:34:49.755 --> 00:34:52.359
“Hello”打包作为
PlaygroundValue

00:34:52.426 --> 00:34:55.362
被传送给实时视图代理
然后再传送给

00:34:55.429 --> 00:34:58.198
我们刚刚创建的代理类

00:34:58.265 --> 00:35:01.568
它接收到消息
奇迹就发生了

00:35:04.037 --> 00:35:07.107
我想指出这个PlaygroundValue
枚举值让我们

00:35:07.241 --> 00:35:10.944
有更多的选项
可以静态的声明原始值

00:35:11.011 --> 00:35:14.848
我们可以在两个进程之间
来回传递它们

00:35:14.915 --> 00:35:18.986
你可以直接使用这些枚举值
就像在刚才的幻灯片中看到的那样

00:35:19.186 --> 00:35:24.291
你也可以把对话操作
定义到Playgroundvalue中

00:35:24.358 --> 00:35:26.226
可以使用自己的数据结构

00:35:27.394 --> 00:35:31.098
另一个好处是键/值库
也使用Playgroundvalue

00:35:31.164 --> 00:35:35.302
现在任务完成了 可以从这个模型中
导出或者导入数据

00:35:35.402 --> 00:35:39.873
这种工作可以用于双向进程通讯
和保存语句

00:35:42.109 --> 00:35:47.347
记住Contents.swift在
左侧运行的进程中

00:35:47.514 --> 00:35:49.616
它被称为主进程

00:35:49.850 --> 00:35:54.254
如果在你的Playground Book
页面中有LiveView.swift文件

00:35:54.354 --> 00:35:58.926
它将会执行
在独立的在线实时视图中运行

00:35:58.992 --> 00:36:01.261
它在右侧的进程中运行

00:36:01.328 --> 00:36:04.731
它的机制和我们以前的不同
所以请研究

00:36:04.798 --> 00:36:08.202
我们的参考实例和文档
看看它是如何工作的

00:36:08.268 --> 00:36:10.604
所以你可以利用这些新玩意儿

00:36:11.872 --> 00:36:15.776
在编辑Playground Books的讨论
快要结束的时候

00:36:15.843 --> 00:36:21.048
我想告诉你们 作为内容编辑者

00:36:21.348 --> 00:36:24.918
你在iPad上实现了伟大的想法

00:36:25.285 --> 00:36:28.989
然后你把它同步到Mac上
看一下 你会注意的

00:36:29.056 --> 00:36:33.227
在顶部出现了一个和Contents
文件夹并列的新文件夹

00:36:33.360 --> 00:36:37.397
这儿记录了编辑器中
发生的所有变化

00:36:37.531 --> 00:36:41.969
所以不要惊讶
当你在iPad上编辑内容

00:36:42.035 --> 00:36:44.905
疯狂的在编辑器中输入
和改变内容的时候

00:36:44.972 --> 00:36:46.940
你认为它们都存进了
Contents.swift中

00:36:47.007 --> 00:36:49.409
但是当你在Mac上打开它的时候

00:36:49.476 --> 00:36:52.579
Contents.swift文件
回到了开始的状态

00:36:52.646 --> 00:36:54.414
你做出的所有改变去哪儿了？

00:36:54.481 --> 00:36:55.816
这就是设计

00:36:56.817 --> 00:37:01.255
iPad上的Swift Playgrounds
从未改变编辑内容

00:37:01.588 --> 00:37:04.324
Swift Playgrounds储存了
学习者改变的文本的dif格式的文档

00:37:04.424 --> 00:37:06.960
位于Edits文件夹中
可能的话我们会重新加载它们

00:37:07.027 --> 00:37:08.795
这会使内容保持原始状态

00:37:08.862 --> 00:37:11.398
这也是为何Playground
Books可以被重置

00:37:13.967 --> 00:37:16.970
以上是简要介绍

00:37:17.204 --> 00:37:21.375
新的Playground Book
格式底层设计的一部分

00:37:21.575 --> 00:37:24.978
刚才说过 请到
developer.apple.com上

00:37:25.078 --> 00:37:27.915
获得参考文档和实例

00:37:27.981 --> 00:37:30.117
仔细分析我们内容团队设计的
Playground Books

00:37:30.184 --> 00:37:33.453
那儿都有 我们想保证
你有足够的资源

00:37:33.520 --> 00:37:35.022
创造出炫酷的东西

00:37:36.924 --> 00:37:39.493
现在我让你们体验了

00:37:39.560 --> 00:37:42.729
作为作者在创造Playground
Books时的感受

00:37:42.930 --> 00:37:46.900
但是正如你们所料的
这个应用仅仅可以供你们涂鸦

00:37:46.967 --> 00:37:48.302
就像某种便签簿一样

00:37:48.368 --> 00:37:49.670
但是它很棒！

00:37:49.903 --> 00:37:52.306
下面有请我的同事Izzy

00:37:52.372 --> 00:37:56.176
展示一下他用Swift
Playgrounds做的一些东西

00:37:56.343 --> 00:37:57.177
Izzy

00:37:59.179 --> 00:38:00.380
谢谢你！Jonathan

00:38:02.583 --> 00:38:04.451
谢谢你！Jonathan
太棒了！

00:38:04.985 --> 00:38:08.488
现在直接进入我们的演示

00:38:11.892 --> 00:38:16.396
像你们一样 我对从星期一以来
发布的这些特征

00:38:16.463 --> 00:38:19.366
和这些APIs也很兴奋

00:38:19.433 --> 00:38:24.905
尤其是 我确实非常感兴趣的
一个编程领域是

00:38:24.972 --> 00:38:27.975
我记得是程序内容生成

00:38:28.041 --> 00:38:30.210
这个思想是计算机能够生成某个东西

00:38:30.310 --> 00:38:33.881
而且这个东西和现实世界很相似
这非常令我着迷

00:38:34.181 --> 00:38:37.351
所以当我看到GameKit
添加了支持这个的API

00:38:37.451 --> 00:38:40.954
我禁不住想立刻上手

00:38:42.556 --> 00:38:47.494
我还不太确信我需要的是什么
但是当我看到这个新的APIs

00:38:47.561 --> 00:38:50.731
我看到他们添加了这个新函数叫做
GKPerlinNoiseSource

00:38:50.797 --> 00:38:54.701
在应用中有帮助
显示了所有的文档

00:38:54.768 --> 00:38:55.903
如果我点击这儿的帮助

00:38:56.403 --> 00:39:00.807
我们可以看到
GKPerlinNoiseSource有一些特性

00:39:00.874 --> 00:39:04.878
让它能够生成自然现象
例如云和土地

00:39:04.945 --> 00:39:06.680
那听起来正是我想要的

00:39:07.781 --> 00:39:10.417
有了这个
我仅仅写几行代码

00:39:10.484 --> 00:39:11.985
我就把它转换成一张图片

00:39:12.219 --> 00:39:13.820
我想看看我的图片

00:39:14.655 --> 00:39:15.989
如果运行playground

00:39:16.056 --> 00:39:18.825
对于你们习惯于在桌面系统上
使用Playgrounds的人来说

00:39:18.892 --> 00:39:21.628
你会注意到在视图的右边
有一个结果工具栏

00:39:21.695 --> 00:39:23.630
也许你们一些人以前没有看到这个

00:39:23.697 --> 00:39:27.734
在你的playground运行时
每一行产生一个结果

00:39:27.935 --> 00:39:33.540
我在上面点击
会弹出内容的执行结果

00:39:33.874 --> 00:39:37.311
现在有点儿小
我写上更多的代码

00:39:37.544 --> 00:39:39.980
能够让它放大一点并且保持像素不变

00:39:40.314 --> 00:39:41.748
因为我考虑到像素问题

00:39:41.815 --> 00:39:43.617
后面我们再详细讨论

00:39:43.817 --> 00:39:47.521
现在我们有了一个更大的图像
我们可以用

00:39:47.588 --> 00:39:48.789
添加视图按钮
把它添加到代码中去

00:39:50.290 --> 00:39:52.492
让我们滚动代码的时候
它会随着一起滚动

00:39:53.961 --> 00:39:57.397
现在它很大
我们想让图像看起来是个图像

00:39:57.464 --> 00:40:01.368
我们制作了噪声
我们还想用它生成3D土地

00:40:01.468 --> 00:40:04.238
我们要做的是
一个像素一个像素地完成

00:40:04.304 --> 00:40:08.075
整个图片
当图像是深色时

00:40:08.175 --> 00:40:10.677
我们想让它成为3D土地图像
的较低区域

00:40:10.744 --> 00:40:14.748
当图像是浅色的
我们想让它成为土地的较高区域

00:40:14.815 --> 00:40:16.683
你可以看到在右上角

00:40:16.750 --> 00:40:19.386
是颜色较深的区域
那将是较低的区域

00:40:19.486 --> 00:40:22.756
在左下角是浅色区域
那将是较高区域

00:40:22.823 --> 00:40:27.861
所以我仅仅写了用户界面图像
的一个小扩展

00:40:28.195 --> 00:40:31.932
它是一个8位灰度的图像
沿着横向

00:40:31.999 --> 00:40:35.068
和纵向排列
它被称为地块

00:40:35.502 --> 00:40:38.472
在每个位置有8位灰度值

00:40:38.705 --> 00:40:40.774
我们还想把它向上排列

00:40:41.175 --> 00:40:45.746
因为我们的图像非常小
十乘十像素的

00:40:46.613 --> 00:40:50.484
8位图像有255个值 听起来有点高

00:40:50.551 --> 00:40:52.653
所以我写了一个小的bucket函数

00:40:52.719 --> 00:40:54.488
仅仅为了证明它能运行

00:40:54.555 --> 00:41:00.127
我取尽了所有的整数值

00:41:00.527 --> 00:41:06.900
你可以看看这儿的弹出图像
它成了一个漂亮的梯子函数

00:41:08.335 --> 00:41:11.939
我们的取值范围仅仅是从0到4
而不是从0到255

00:41:12.005 --> 00:41:15.275
然后用图像块填充我们的图像

00:41:15.609 --> 00:41:18.445
我们得到一个这样的图形

00:41:19.112 --> 00:41:20.714
很有趣

00:41:20.814 --> 00:41:25.052
看起来很酷
但它还不是真正的3D土地

00:41:25.118 --> 00:41:29.656
你看在我的图像中每一个点
有一个关联的高度值

00:41:30.424 --> 00:41:32.960
它还不是我想要的

00:41:33.360 --> 00:41:35.696
我常常在这儿卡住

00:41:35.796 --> 00:41:38.966
我还没有深入了解3D APIs

00:41:39.032 --> 00:41:42.469
来生成我想要的3D土地模型

00:41:42.536 --> 00:41:47.174
我也没有任何3D技巧
像设计师那样手工实现

00:41:47.541 --> 00:41:48.542
但是我恰好知道

00:41:48.609 --> 00:41:53.013
学习编码playground
里面有一个创建你的世界页面

00:41:53.080 --> 00:41:57.117
我可以用它来继续我的试验

00:41:57.184 --> 00:41:59.586
所以我来到
学习编码playground

00:41:59.653 --> 00:42:02.189
这就是那个页面

00:42:02.322 --> 00:42:06.360
这是创建你的世界页面
我仅仅是运行它

00:42:06.927 --> 00:42:09.930
你可以看到
我们正在云中漂浮

00:42:11.365 --> 00:42:13.600
我要把以前写的代码粘贴过来

00:42:14.067 --> 00:42:17.037
我要输入一些代码
先让我把实时视图隐藏起来

00:42:18.505 --> 00:42:20.807
这儿有我们的

00:42:22.209 --> 00:42:28.949
这儿以前是赋值的语句
现在我想把它变成一个3D世界

00:42:29.249 --> 00:42:34.721
现在创建你的世界页面为我们提供了
一个世界 这正是我们想要的

00:42:34.988 --> 00:42:38.192
在我的世界上我们可以放置

00:42:40.260 --> 00:42:41.094
地块...

00:42:42.496 --> 00:42:44.264
这是位置的x和y坐标

00:42:44.331 --> 00:42:48.902
我们不需要考虑值
我们需要设置一个高度

00:42:51.205 --> 00:42:53.073
我们想要调用bucket函数

00:42:54.107 --> 00:42:54.942
在我们的值上

00:42:56.076 --> 00:42:58.478
然后是高度

00:43:01.481 --> 00:43:03.083
我们想显示一些地块

00:43:06.420 --> 00:43:09.790
我很喜欢这个动画
我想让它多次运行

00:43:10.624 --> 00:43:11.859
如果我运行这个...

00:43:17.664 --> 00:43:21.401
哦 我忘了加括号 和Max一样

00:43:23.537 --> 00:43:24.671
如果运行它

00:43:27.708 --> 00:43:30.978
你可以看到
我们在我的世界上堆积地块儿

00:43:31.712 --> 00:43:34.014
运行的很快
但这并不是我想要的

00:43:34.081 --> 00:43:37.117
地面上有一些奇怪的空白

00:43:37.718 --> 00:43:38.852
我不想那样

00:43:38.919 --> 00:43:41.088
我不是在创造飞行岛那样
的魔幻世界

00:43:41.154 --> 00:43:43.056
我想让它看起来更像地面

00:43:43.290 --> 00:43:45.125
所以让我们停止

00:43:45.559 --> 00:43:48.829
起初我不理解为什么产生了
这些空白的地面

00:43:48.929 --> 00:43:50.697
但是经过思考以后 我知道了

00:43:50.998 --> 00:43:52.999
显然是因为高度是0

00:43:53.066 --> 00:43:55.702
因为范围是从0到4
而不是从1到5

00:43:55.802 --> 00:43:57.671
0处没有任何地块

00:43:57.871 --> 00:44:00.841
所以有0的地块儿可以设置为水域

00:44:01.341 --> 00:44:03.710
如果高度

00:44:05.279 --> 00:44:06.613
小于1

00:44:08.048 --> 00:44:09.183
在我们的世界上

00:44:10.584 --> 00:44:13.620
我想放置为水域

00:44:17.691 --> 00:44:19.459
现在若我点击If语句

00:44:20.127 --> 00:44:23.330
用我们的结构化编程助手
可以加入一个else语句

00:44:23.564 --> 00:44:26.834
放入前面的语句

00:44:29.870 --> 00:44:32.005
现在我想让它速度加快

00:44:32.072 --> 00:44:35.309
我的世界有一个速度指令

00:44:36.443 --> 00:44:38.011
我想提高速度

00:44:40.781 --> 00:44:41.815
让我们...

00:44:43.884 --> 00:44:46.153
好 完美

00:44:46.820 --> 00:44:49.289
好 让我们运行一下 看看结果

00:44:54.428 --> 00:44:56.230
现在你可以看到 我的世界中有了水

00:44:58.799 --> 00:45:00.000
太酷了

00:45:06.440 --> 00:45:09.877
我们从API草稿和一个
空白的playground开始

00:45:10.444 --> 00:45:14.515
然后我们碰到了障碍 我们来到
学习代码playground

00:45:14.615 --> 00:45:16.083
学习代码playground

00:45:16.149 --> 00:45:18.619
对于初学者来说是非常非常有价值的工具

00:45:18.685 --> 00:45:23.290
对于熟练的开发者来说它也是
强大的平台 它可以帮助他们

00:45:23.390 --> 00:45:24.858
浏览APIs
实现他们的想法

00:45:26.226 --> 00:45:27.427
所以真是太酷了

00:45:27.494 --> 00:45:31.532
现在你可以有整套的
iOS APIs

00:45:31.598 --> 00:45:34.001
其中包括有像Core
Bluetooth这样的东西

00:45:34.101 --> 00:45:36.537
我要换到另一个iPad上

00:45:39.606 --> 00:45:42.743
这有一个playground
使用core Bluetooth

00:45:43.844 --> 00:45:45.212
可以和外部设备通讯

00:45:48.315 --> 00:45:52.619
这是一个Sphero
SPRK Plus机器人

00:45:53.620 --> 00:45:56.290
我们能做的是
我要将它放置在地面上

00:45:56.356 --> 00:45:58.025
因为我们需要一些空间

00:45:58.392 --> 00:45:59.526
现在我能做的是

00:46:02.196 --> 00:46:03.430
当我运行我的代码时

00:46:05.199 --> 00:46:06.266
Sphero

00:46:07.668 --> 00:46:10.804
会闪烁 并且开始开动

00:46:11.705 --> 00:46:14.107
现在它以方形路线移动

00:46:14.408 --> 00:46:21.281
从iPad上我使用Core
Bluetooth控制第三方机器人

00:46:21.348 --> 00:46:22.850
太有趣了

00:46:31.458 --> 00:46:34.695
我想让它更有趣一些

00:46:34.795 --> 00:46:36.763
我先把它先隐藏起来

00:46:38.699 --> 00:46:39.867
我要做的是...

00:46:42.970 --> 00:46:44.438
添加一些颜色代码

00:46:47.641 --> 00:46:49.977
有结构化编程助手

00:46:50.043 --> 00:46:54.781
我们可以拖拽成了一个数组
添加一些元素

00:46:58.151 --> 00:46:59.920
我要设置这些颜色

00:47:06.960 --> 00:47:09.496
你知道这都是一些很熟悉的颜色

00:47:09.563 --> 00:47:12.533
但我的手指放不上去

00:47:18.672 --> 00:47:22.242
在rest函数中
我们要让它重复其中的三种颜色

00:47:33.954 --> 00:47:36.023
不要白色

00:47:36.490 --> 00:47:38.992
我们把它设置成其它颜色

00:47:46.567 --> 00:47:49.970
让我们再看一下

00:47:51.738 --> 00:47:52.739
运行代码

00:47:56.109 --> 00:48:01.582
现在当我们开动Sphero时
颜色在不断变化

00:48:10.290 --> 00:48:11.291
停止

00:48:12.492 --> 00:48:13.627
确实很有趣

00:48:13.827 --> 00:48:16.997
现在让Matt回来做个总结

00:48:24.304 --> 00:48:25.839
非常感谢Izzy

00:48:26.073 --> 00:48:28.475
真是太酷了

00:48:31.478 --> 00:48:32.946
今天我们看到了很多

00:48:33.480 --> 00:48:36.617
首先是Max
他展示了

00:48:36.683 --> 00:48:39.920
如何使用Swift Playgrounds
中很棒的触摸控制

00:48:39.987 --> 00:48:43.557
用各种方式和Swift代码交互
以前我们从来不能做到

00:48:43.624 --> 00:48:47.294
Jonathan演示了如何编译
吸引人的内容

00:48:47.361 --> 00:48:50.030
使用Playground
Books中的新特性

00:48:50.430 --> 00:48:55.536
你可以在编辑程序的同时
浏览或者关闭程序的执行结果

00:48:55.836 --> 00:48:58.639
Izzy给你们展示了你可以不受

00:48:58.972 --> 00:49:01.041
学习代码中的内容的限制

00:49:01.108 --> 00:49:04.678
你可以使用iOS SDK做实验
和物理设备交互

00:49:04.745 --> 00:49:07.447
甚至构造你自己的世界

00:49:08.782 --> 00:49:12.052
我们认为你能用
Swift Playgrounds

00:49:12.186 --> 00:49:14.788
做很多很酷的东西

00:49:14.922 --> 00:49:16.823
我们都等不及要看你能用它做出些什么

00:49:18.659 --> 00:49:19.660
谢谢

00:49:23.230 --> 00:49:26.200
更多信息请参阅
developer.apple.com

00:49:26.266 --> 00:49:27.467
这是演讲408

00:49:28.202 --> 00:49:31.104
还有一些相关的演讲可能你会感兴趣
查阅一下吧

00:49:31.338 --> 00:49:34.408
感谢所有的人
请关注WWDC的其它部分