在Instruments中使用时间分析器
早点分析 经常分析
下午好
我叫Kris Markel
我是Apple性能工具团队的工程师
今天我们谈谈在Instruments中使用时间分析器
这是我们的议题
我们要从分析开始讲
分析是什么及如何使用它
然后我要演示一个示例
使应用的速度更快 工作量更少
最后 确保应用有非常棒的用户响应
在我们开始讲正题之前让我们谈谈为什么要这样做
原因就是我们想提供一种优秀的用户体验
我们想让用户喜欢用我们的应用
我们想让他们喜欢用我们应用是因为应用的速度很快
速度像猎豹一样快
可以节省他们的时间来做更多的事
我们想确保用户的设备一整天都有电
这样他们一整天都能使用设备
而你的应用一定不想成为那个
在电量消耗表上排名第一的应用
最后 我们想确保流畅的滚动
在我们的应用中有迅速响应的UI这样用户就会喜欢用它
我们该如何实现呢？
我们要用一种叫做分析的技术
这种分析技术回答了关于应用的两个问题
做了多少工作？
做了什么工作？
若你尚未注意到标题
我们要使用一种叫做时间分析器的工具来实现
时间分析器回答了另一个问题
应用什么时候做那个工作？
时间分析器是应用中Instruments的一部分
Instruments是很多工具的集合
这些工具都是用来测定应用的各个方面的
怎么用呢？
嗯 非常简单
从Xcode产品菜单中选择Profile
让我们现在来操作一下
好的 首先 我要给你们演示一下我的应用
让你们了解它的功能
我的应用使用了照片框架来查找
用户的图库检测是否有图片副本
我现在要操作一下
如果我的测试数据中有很多副本就得等一会儿了
那么 它给出了一个很大的数
好的 完成了
现在 我要选择一些照片
找一张好点儿的图 这张吧
然后应用就会使用核心图像面部识别功能
这样我可以给人脸上添加一双金鱼眼
然后应用就使用CoreMotion中的力学UI
当你摇动设备时金鱼眼会跟着一起晃动
好的 这就是应用
让我们继续分析它正在做什么
那么从Xcode产品菜单中正如我刚说过的 选择Profile
这将生成应用的一个发布版本
然后开启Instruments开始测定
生成分析用的一个发布版本很重要
因为你希望能从编译器中获得最优结果
这得等会儿
它正在把应用复制到设备上
好了
现在 Instruments开启了
它会显示模板选择器
你可以了解Instruments都提供了哪些工具
今天 当然了我们要用时间分析器
我要点击选择按钮
若你从未用过Instruments
这个用户界面看起来可能有点儿吓人
但是很容易上手
我要做的就是点击左上角的这个记录按钮
开启应用 并开始测定
让我们实际操作一下
好的 那么现在 应用开启了
正在启动 好了
对吧？我要做副本检测
等一下
好的
然后 我要做副本检测了
让我们看看是否开始获得数据了
好了
好的 完成了
现在 我要选择照片
然后我要挑出一张照片
添加一双金鱼眼
摇动一下
现在不管那张图了
然后停止记录
点击停止按钮
现在我们可以看到
有一个应用正在做什么的高级概览
时间分析器给出了两张图表
Instruments的顶部是时间线视图
第一张图表是CPU的使用情况
就是应用使用了多少CPU
我可以把鼠标悬停在图表上查看精确数值
第二张图表是应用所处的生命周期
以及所延续的时间
这让我有了一个很好的概念关于应用做了多少工作
以及是什么时候做的
但是 我如何了解应用正在做什么呢？
要了解该信息 我们要往下看Instruments的调用树视图
就是这个详细视图中的一部分
调用树视图呈现了所收集的通过比重合计的
调用栈样本并显示在详细视图中
这是什么意思呢？
嗯 以图形显示比文字说明更显而易见
让我们来看一个图表
在这里 时间向右运动
这是我们那个非常简单的应用
我们有一个主方法这是调用method1
这是调用method2
在这个时间点
时间分析器要从应用中获得一个调用栈
看起来是这样的
就跟你在Xcode中的调试器中看到的调用栈是一样的
但在Instruments或时间分析器中 后续的每一行都会缩进
正因为如此 才能创建一个树结构我们一会儿就会看到了
时间在继续
哦 然后它记录了那个调用栈
然后记录了在那个调用栈内
出现每个方法或函数的次数
时间继续我们可以看到method2结束了
method1调用结束了的method3然后又调用了method2
然后我们继续 已经过了一毫秒
时间分析器要取第二个样本
在这个示例中 第二个样本看起来跟第一个样本一样
我们要继续 更新表
只是为每个数增加了增量
时间还在继续
现在我们看到应用正在做不同的事
主方法直接调用了method2然后调用了method3
时间分析器就在这儿取了另一个样本
现在 我们看到了一个不同的调用栈
在这个示例中 只有两个方法
然后 我们更新表这是一个树的分支
现在我们了解了 主方法有时调用method1 有时调用method2
我们知道每种方法被调用了多少次
那么 时间继续 我们收集更多的样本
这些样本恰巧跟第一次的样本完全一样
我们要适当地更新表
现在 让我们看看这个表说明了什么
要注意一点 时间分析器实际上并不是在测定持续的时间
它并不是记录哪个方法什么时候开始
什么时候结束 然后做个减法
而是把这些样本集合到一个有用的汇总中
当你在时间分析器中查看时间值时
实际上不是一个持续时间的测定
而是样本时间乘以样本个数
在绝大部分情况下 是1毫秒
这的确有一些副作用
其中一个就是时间分析器并不会区分
被重复调用的是连续运行的方法
还是稍纵即逝的方法
我们实际上可以看到在调用树中
method1和method2出现的样本个数相同
从时间分析器的角度来说它们做了同样多的工作
但我们知道 实际上method1被调用了两次 运行时间很长
而method2被调用了四次运行时间很短
时间分析器还集中分析CPU的使用情况 对吧？
它回答了这个问题应用正在做什么工作？
另一个结果是它不一定会捕捉一切
事实上 表中遗失了什么？
没有method3 对吗？
如果你有执行起来非常快的函数
或执行起来很快而且非常频繁地调用的方法
这些方法将不会出现在调用树中
实际上没问题这就是我们想要的
因为那并不会影响
所产生的工作量
那么现在 我们对调用树有了更好的理解
让我们看看如何通过它使应用的速度更快 工作量更少
好的 让我们回去看时间线
我想看一下第一大块CPU的使用情况
可以看到 在大量时间内CPU的占用是100%
那么 我想确切了解那时应用正在做什么
我恰巧知道那时我正在做副本检测
预计那个工作量会很大所以我一点儿都不吃惊
但无论在哪儿你占用了大量CPU资源
通常总是能让它更快一些
所以 为了更好地了解这里正在发生什么
我要用触控板 放大 然后松开
我可以更好地了解在这个时间段到底发生了什么
然后我要点击并拖拽时间线视图
这样可以应用一个筛选器
现在调用树只能显示在那个
时间框架内所收集样本的数据
如果你注意看 你会看到
调用树实际上显示的数据变少了
只显示了这个时间段的数据
现在 让我们更详细地看一下调用树
你将在这儿看到几个栏
有比重和自比重 然后是标识名
比重代表调用树出现的
指定部分的样本百分比
你将看到比重旁边还有个时间
正如我之前讲过的那不是持续时间
而是样本时间乘以样本个数
然后还有自比重
实际上是在那个方法内所花费的时间
而非在它调用的其他方法内所花费的时间
你在这里可以看到 这些是0
如果你关闭这个 还是0
仍然是0
这就告诉我们 你知道的在样本中主方法的比重是99%
但其实这些全部也是在UIApplication主方法中
无论是什么方法都要调用UIApplication的主方法
我们不会一个接一个地显示这些
我要使用Instruments 8中的新功能
我按下选项键并点击显示三角按钮
这样能得到一个更好的显示
这将会关闭调用树
除非调用树中有真正令人关注的数据
如果我们继续往下滚动
我们可以看到我们实际上有一些方法
有自比重
其实若我查看这个特定的release调用
我可以看到 它的比重是117毫秒跟它的自比重一样
那么它所有的时间都花在它自己身上了
没有调用任何后续的函数或方法
其实 你知道的 通过查看这些
我看到这里调用了很多Objective-C执行时间
实际上它们的自重都很大
这些运行时间方法已经被无限高度优化 运行起来非常快
通常是时间分析器不会捕捉的那类东西
因为运行速度太快了
但是它们已经被显示出来了于是我知道通常它们会被频繁调用
所以才在样本中出现
这通常是循环很多Objective-C对象的情况
你将看到这会在轨迹中显示出来
调用树体现的第二点是看右边
我们可以看到调用树的哪部分来自哪个库
特定的方法调用
并且在这里 我们能看到这是随着照片框架出现的
实际上是按照层级排列的
滚动到右边
我们可以看到这里有一行来自应用的代码
这行代码导致了工作量的产生
你知道的 这行的比重是0
它自己没做任何工作
但是它却触发了所有工作
我不能再加快Objective-C发布调用的速度了
但我能看到是否可以少调用几次
所以 我要双击这行
把我带入代码中
Instruments给每行添加了一个样本个数的注释
那么 看这个方法我能看到大部分时间
都花在红色背景行那儿
但是如果我再仔细看一下我实际上能看到其他东西
我嵌套了四个循环
事实上 每个循环重复整个照片采集的过程
这是很典型的一个
叫做N次方行为的例子
如果我向这行代码中代入更多数据
速度会变慢 越来越慢
因为我知道会运行大量数据这很不好
所以我想改变这种情况
我要进入Xcode
这是我的代码
避免嵌套四个循环的典型方法是使用基于集合的实现
我不再赘述了 我要继续
创建一个新算法用来执行副本检测 使用...
使用一个计数集合和另一个查找副本的
集合
现在 让我们看看我实际上做了点儿改变
再一次 我要进入产品菜单
我要选择分析
它会重新创建我的应用并把它安装在设备上
因为Instruments已运行了
它会立即开始记录
那么 当它把应用复制到设备上时让我们看一下 已经开始分析了
这是Instruments
我的应用已经开启了
好的 它开始记录了 我要缩小
好的 我要缩小这样我们就能看到数据了
我要执行副本检测
副本 所有照片
我可以看到数据进来了
实际上是以分钟为单位记录的我还以为是秒
好的 那么副本检测实际上速度更快了
事实上 我们再也不会看到贯穿时间线的那个长条了
这是个不错的变化
我想继续重新测定应用剩余的部分
选择一些照片
添加一双金鱼眼
摇动一下
然后就不用管那张照片了
现在应用是静态的不应该做任何工作
但是让我们看看时间分析器怎么说
停止记录
加载一分钟才有数据
哇哦
好的 我可以看到在调用的末端
占用了一些CPU资源
并不多 但我希望是0
所以我要继续 看看它做了什么
我再次通过触摸板进行放大
拖拽并选择看看这里发生了什么
然后继续点开查看正在发生什么
查看调用树
这次我看到在CoreMotion中有大量的调用 对吧？
且我知道我的应用正在此做什么
它正在使用CoreMotion进行检测并移动眼睛
但如果查看上边的调用树
实际上这个调用树中没有我的任何代码
我并没有执行任何可以直接引起使用CPU的操作
但我应用中的某些东西使CoreMotion做了不该做的
关于应用 我知道的是
我发现当不看屏幕的时候
我不能关闭CoreMotion监控
让我们继续改一下
返回Xcode
实际上我已经写好了所有方法
只需要调用即可让我们把它们添加到这里来
然后我们停止观察这儿
好的 现在让我们测定这个
并确保会发生我们所期待的改变
再次Instruments会重建应用
并把它放在设备上
因为Instruments已经开启并正在运行 它会再次开始记录
这一次 我要提前放大
我点击筛选器外面 移除它
好的 一旦应用在设备上安装
Instruments就会再次开启对它的记录
好的 就是这样
好的 这一次 我要继续只添加照片
然后我要滚动到一张照片那儿
选择它
添加眼睛
摇动一下
让我们再稍微放大点儿
选择一张新照片这样屏幕上就没有眼睛了
然后停止记录
看看是否发生了我们所期待的变化
一旦Instruments完成数据处理 我就放大这个末端部分
我可以看到在末端CPU的占用率为0
所以应用不再做它不需要做的工作了
那么 让我们回顾一下我们做了什么
第一件事是用轨迹面板计算
应用做了多少工作以及什么时候做的
这样就很容易找到想要关注的区域
并且触控板很容易操作轨迹面板或时间线
但用鼠标控制也不错
使用option键-拖拽和control键-拖拽放大和缩小
我们在轨迹视图上找到了一个占用许多CPU资源的区域
我们想让它速度更快
所以我们继续 放大对那个区域进行筛选
我们查看了调用树 我们发现
产生工作量的地方是应用中的那个部分
然后我们往回看调用树直到看到我们的代码
应用中的哪个部分产生了这样的工作量
即使不是应用自己产生的？
我们看一下代码 考虑一下
挠挠头 吃一个三明治
我们发现了可使它速度更快的方式
所以我们实现了那些变更
并证实了实际上会让它的速度变得更快
在这个例子中这是个意义重大的改进
结果是我们节省了用户的时间
当用户使用我的应用来查找副本时
他们再也不用看那个旋转的加载图标了
会很快地完成
关于减少工作量我们能做什么呢？
我们再关注一下轨道视图上的一个区域
这一次并没有占用很多CPU资源
而CPU的占用量出人意料
我们放大 加上一个筛选器
我们看一下调用树
这一次 我们再看一下框架我们看到的是CoreMotion
但没有诱发我们的代码
所以这次 我们得用另一种方式来思考我们的应用
是应用的哪个部分导致了这个工作量？
我们又一次 也许休息一小会儿再吃个三明治
想想如何使应用停止产生那个工作量
让它不再出现
我们继续 重新分析应用
验证了我们所期望的修改
事实上 结果是我们显著提高了
应用运行时的电池续航能力
无论任何时候 CPU都可以归0并进入休眠
这就意味着有效地节省了用电量
即使我们的CPU占用量很低仍然会有电量消耗
那么现在 我们变快了工作量变少了
让我们使应用的响应更积极一些吧
应用的工作方式
是主线程完成所有用户界面的工作
承担了响应用户输入并更新视图的任务
无论如何处理用户输入都有一个主线程
主线程有一个运行循环只是监听一个队列
叫做事件队列
并等待事件在事件队列中出现
事件出现时 它把事件发送到UIApplication或NS应用实例
然后把事件传递到应用的响应链中
如果应用想响应那个事件
那么它会继续并诱发你的代码
然后你可以在这里的调用栈中看到这个
这是我应用中的调用栈
我们可以看到 有主线程
所有应用的主线程都是以调用主函数开始的
在这里 我不清楚这些函数具体有什么作用
但是显而易见都跟运行循环相关
我看到有函数handleEventQueue
很显然 这个函数是从事件队列中把一个事件取出来 并进行处理
我可以看到它把事件传给了UIApplication
然后传到响应链最后传给了我的代码
在这个例子中这是一个按钮的IB动作
然后我的代码就执行了操作
那么 这对于保持应用积极响应来说有什么意义呢？
嗯 忙时 主线程不能处理队列
因为它会开始备份备份你的用户事件
然后结果是 变得磕磕绊绊不顺畅
最糟糕的情况是你的应用变得完全没有响应
此时用户会关闭应用也许会从设备上删除应用
因此 释放主线程很重要
这样就能很快地响应用户输入
现在 有了这种方案
让我们看看可以对应用做出哪些改进使它能更积极地做出响应
好了 这次我要缩小轨迹视图
现在我想要关注的是这个CPU占用比较多的区域
在这里 我看到CPU的占用率远远超过100%
也许可以对这里进行优化
而我恰巧知道 这是我给图片添加眼睛的时候
那么我再一次使用触控板进行放大
点击并拖拽 加上一个过滤器
现在看一下调用树
这次 我想特别关注主线程做了什么
我可以看到 实际上主线程
在样本中的出现频率为63% 64%
因此我就明白了 在这个时间段正在进行一些工作
但我想确切地知道做了多少工作
为此 我要继续 看右上角
我们可以使用不同的策略和Instruments
因此 你可以按照CPU或线程浏览数据
这一次 我想按照线程来看数据
实际上我可以让它变大点儿以便查看
在左侧的这里 你可以看到应用中的所有线程
主线程在顶部
所以我可以看到主线程的CPU使用情况
在这里 很明显 达到了100%
在这种状态下它绝不会响应用户事件了
也不能处理队列了
如果它正忙于处理应用中的工作
那么 主线程到底在做什么？
这一次 我要点击右侧的扩展详细视图
这将显示在主线程上做了大部分工作的调用栈
因为我的主线程是从左侧选出来的
所以我在这里滚动我可以看到这是运行循环
然后在这里我看到了我的代码
这是添加眼睛的代码
然后正在做更多的添加眼睛的工作
然后这里正在调用查找面部
所以这是应用中的面部检测代码
然后我们可以看到下一行调用了图形核心
如果我在详细视图中点击这个它将展开那行的调用树
再一次推导出我的代码
我没必要在主线程上做面部检测
这并不是响应用户输入也不是更新视图
因此可以挪到后台线程上去实现
那么 这是执行面部检测的代码
我可以看到面部检测完成后
它会继续调用displayEyes方法
这里要注意一个重点displayEyes会更新UI
因此这是主线程上的工作
所以 我需要做的是在后台线程上执行面部检测
切回主线程 更新UI
哦 好了
好的 谢谢
此处不应有掌声
但我接受你们的夸奖
好了 这是在后台实现这个功能的代码
我要快速讲一下
进入后台的一个队列
然后调度查找面部代码
正如我刚说过的我们要调回主队列
更新我们的UI
这一次在做分析时
我会按住运行按钮 选择分析
可以实现同样的功能
很可能会相当快
哦 我删除了代码
让我们再做一次
那么因为我已经实现了我只需要继续并...
这个结果满意吗...
点击分析按钮 好了
它会创建我的应用
并在设备上安装应用
好的 Instruments应显示
并开始记录我的应用了
哦 我要切回Instruments视图
然后 让我们缩小一下看看进来的数据
好的 很快让我们给应用添加一些照片
然后执行眼睛检测
好了 那么在这里我们能看到那个大的CPU峰值
停止记录
现在 让我们看看是否实现了我们所期待的变更
我要再次使用触控板放大图表的这个区域
点击并拖拽时间线视图加一个过滤器
现在 如果我们查看一下调用树
实际上我在这里看到主线程在样本中的比重只有4.8%
这是个好迹象
我已经知道主线程的工作量正在减少
两个辅助线程分担了更多的工作量
那么让我们切到线程策略
在这里 我可以看到
实际上 主线程在绝大部分时间里是完全被释放的
谢谢大家
让我们返回幻灯片
谈谈我们刚才做了什么
为了使应用更积极地做出响应
我们发现了一个区域在这个区域中CPU占用率很高
我就放大那个区域 添加了一个过滤器 这是很常见的操作
我们做的就是
关注主线程
因为我想确保我的应用持续地做出积极响应
我摘出主线程上的一些非UI类的工作
然后把那些工作挪到后台线程上去实现
你很可能猜到了下一个步骤
我验证了我所做的变更
确保应用正如我所期待的那样
结果是我得到了更好的用户体验
当执行面部检测时我的用户界面将持续做出响应
这很棒
关于优化 有几点建议
我们今天所做的修改相对简单
但确实增加了应用的复杂程度
一般来说
优化范例是用简化换取性能
关于优化
但很幸运 因为我早在开发阶段就做了分析
我并没有等到最后才做
我现在有时间验证应用是否运转正常
如果我觉得必要 我可以添加额外的单元测试或UI测试
关注比较复杂的地方仍然能正常运行
在你发布应用之前
是你能做出修改的最后机会
所以真正的收获是它会持续地分析你的应用
尤其在你添加新功能之后
要早做分析
要不间断地做分析
有时候可以只分析运行时间看能发现什么
你很快就会取得重大进展
因此运行分析还是有好处的可以了解是否正在发生有趣的事
关于时间分析器的一些最佳范例
总的来说 你的分析
要尽可能地接近客户要运行的东西
因此你要一直分析发布版本
最佳范例
你不仅需要在编译阶段进行优化
还需要在你客户要使用的发布版本上进行优化
你要一直在设备上做分析
模拟器不能给你提供有用的数据
要在能支持的最老、最慢的设备上做分析
有一条很好的规则
如果能在较慢的设备上很好地运行
那么 在较快的设备上一定能更好地运行
你想让所有用户在使用你的应用时都有非常棒的体验
就算用的是较慢的设备也一样
要尽可能使用大数据集合
在我的示例中 有时候用户的相册中有成百上千
或成千上万张照片
分析应用如何在那种环境下运行非常重要
因此我可以确保客户在打开应用时应用能顺畅运行
那么 总结一下
如果你希望客户因为应用能节约时间而爱上你的应用
有助于他们实现全天电量充沛
并且你的UI响应顺畅
然后 你要做的是早做分析并经常分析
如果你想了解更多信息请看这个URL
这里有一些相关的演讲
去年我们做了一场“深度分析”的演讲
有关于时间分析器的更多详细信息 你可以了解一下
今年 我们做了一个名为深度解析系统跟踪的系列演讲
讲的是当时间分析器力不从心时
如何使用系统跟踪工具
谢谢大家祝你们度过一个美好的下午