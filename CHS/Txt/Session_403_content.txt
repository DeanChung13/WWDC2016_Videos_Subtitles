SWIFT API设计准则GRAND RENAMING
谢谢
欢迎 我是Doug Gregor
在这里 我要跟同事Michael Ilseman
谈论关于设计的问题
因为好的设计能提高效率
而好的API设计能帮助我们使用Swift语言
写出清晰 简练 优美的代码
这一点完全正确无论是当你在为上百万
其他开发者编写API时
还是你在自己的应用里为自己写代码时
因为好的设计真的很重要
所以...
今天我们将介绍Swift API设计准则
这些是我们要介绍的Swift 3的新准则
我们将介绍这些准则背后的原则
对其中一些准则进行讨论从而了解
如何构建优质的Swift API
然后 我们会讨论下Grand Renaming
我们将用这个名词来指代这些准则
在你日常所有API中的应用
包括Swift标准库
Cocoa和Cocoa Touch API
现在 这个Grand Renaming将影响你的很多代码
基本上使用Swift 2语言的所有代码
在Swift 3中都将有一定程度的改变
所以...没错！
所以 我们将讨论下这对你的代码意味着什么
以及如何应对开始适应Swift 3的思维
最后 我们将讨论下我们的一些新工具和技巧
以便将C和Objective-C API
映射到优美的Swift API
这可涉及大量的概念和原因解释啊
你关于准则的最大疑问可能是:
为什么？
为什么在使用Swift两年后
我们要改变你日常工作接触的所有API
答案可以归结为语言的特点
因为每种编程语言都有自己鲜明的特点
都有自己的句法风格
但这又不光是句法
也是一种语言选择做出的
一种折衷
它是倾向于安全还是性能？
你是更喜欢数学的精炼性
还是更喜欢清晰易读的东西？
你看一下Swift代码就能马上读懂代码
这里 你能够看到Swift呈现出关于特定事物的观点
它使用结尾闭包
所以控制流能很好地用于库和API
它有可能选项 所以你必须时刻记住零值的可能性
而不能简单忽略这种可能性的存在
这样 使用Swift语言时你会有Swift的感觉
但这不光是语言引起的
而实际上是你日夜使用的API引起的
而且API必须与语言的特征融合
这样 你才能得到优美的Swift代码带来的一致全面的体验
这里是一些Cocoa和Cocoa Touch API
这些API的设计基于针对Cocoa的编码准则
你可能之前读过这些准则希望你读过
这些准则提倡在API设计中
注重清晰度和一致性
而过去十多年我们已将这些准则
应用到成千上万的API
用于开发Cocoa和Cocoa Touch平台
以及我们使用的绝妙的API
现在 而这些准则针对
具有不同特征的另一种语言设计
所以 当你将为Objective-C写的
所有API毫不修改地放到Swift中
就会看起来个性不合
这些API不怎么Swifty
这又意味着什么呢？
不Swifty？
你听到很多人这么说
不过 本质上这就是为什么在成千上万
开发者使用Swift平台两年后
现在是进行重新评估的时候
因为我们拥有更广大的开发者社区经验
可以了解在Swift代码中什么是有效的
所以我们开始设计API设计准则
尝试规定 怎样算是构建具有Swift特征 即Swifty的API
以及帮助所有人使用我们喜爱的语言
构建更加一致和清晰的API
现在你在左下方能看到SE-0023
这是Swift的演变提案编号
其中包含所有的API设计准则
在整个演讲过程你将看到这些提案编号
此外 你可访问Swift.org
查找这个提案代码了解关于Swift语言
这一特定变化的详细信息
不过现在让我们讨论下准则本身
Swift API 设计准则的主要原则是
在使用时清晰明了
就是你的API在他人代码中显示时能够清晰明了
我们喜欢简练的代码
但清晰明了是最重要的方面
这比写出简练的代码要更重要
虽然如此 Swift中确实也有简练的代码
Swift代码确实会更简练
看到Swift语言时我们能感到该简练性
而在讨论各种导入Swift或使用Swift写的应用时
我们可以实际衡量这种简练性
不过这要源于使用正确的语境线索
让我们更深入地了解下这些准则并看一下一些API
现在 我们先讨论下使用
为什么要关注使用站点呢？
嗯 一方面这不过是简单的数字游戏
你写你的API只要一次
而人们会多次看你的API代码
或者API文档
但API真正重要的大多情况下
API被看到次数最多的时候将是处在上下文语境中
周围有大量其它代码
当你处在这样的语境中
你就拥有所有额外丰富的语境信息
你拥有局部变量及其名称和类型
你拥有相关API的使用
而你的API的目的不是站起来说：
“嗨 我在这儿我信誉好 名号大”
你的API的目的是适应其它代码
从而产生完美的结果
那么 当你关注用例时一定要避免
去针对不好的代码进行优化
这一点绝对会发生有的人写代码
会对所有的变量使用A、B和C这样的名字
这样的代码不再清晰
而仅凭API并不能改善这种不好的代码
你能做的就只是让其它代码更啰嗦或更不清楚
所以请关注适当的用例
关注好的代码针对好的代码去调整API
这里 让我们实际看一个具体的例子
那么 让我们首先看一个API
从集合中删除一个项目
首先 我们将它命名为“removeItem”
听起来不错但这是我犯的第一个错误
这不是用例
这只是简要的名称
那么 让我们显示今天我想到的一个用例
不要问为什么
他知道 将项目“ted”从好友列表中删除
现在 你会注意到该用例中实际有两个东西
指示参数是什么
这两个东西都试图对参数进行描述
其中一个是单词“item”也是名称的一部分
另一个是参数“ted”
即一定类型的某个局部变量
这两个符号中 变量“ted”实际能更好地描述
参数是什么
它是处在语境中的
在语境中读取此调用时你会知道这个局部变量是什么
它表示一定意义它具备强类型
所以这里的问题实际可能是
单词“item”描述性不够强
也许改为“removeObject”
我们会觉得舒服点
不过也许事实也不是这样
因为无论如何我们很可能用的是值类型
所以这只是活跃性的错误
我们可以改为“removeElement”
好 Swift语言的集合也使用element术语
不过 这样也不起作用
而且 如果我们开始写下不同的用例
实际上可能会更不清晰
我想将“caffeine”
这个元素从有机化合物列表中移除
这是误导性的错误的
“咖啡因”不是元素
它是元素组成的化合物
所以 这里我们试图使用一些无伤大雅的词
来描述参数 这实际让我们写出了更模糊的用例
好
所以 可能问题是我们应该停止
将这些看似无伤大雅的概括词用在那里
我们应该特别具体
将“ted”这个人从好友列表中移除
这句英语有点怪
我不会这么说 我只会说“remove(ted)”移除ted
不过进一步讲
如果我这么做了如果对这种一般性的API
我做到了特别具体 那么我会期待任何时候都很具体
现在 有一个概念性的API即 只是将某个项目
从集合中移除 而该项目在源数据库基中有不同的名称
这样就更难理解了
很难识别出我们实际说的
是在不同语境中的同一样东西
所以 Swift API设计准则采取了不同的方法
略去不必要的单词
如果一个单词不能使使用站点更清晰
就不用这个单词
所以我们可以只是说从好友列表中“remove(ted)”
这样读起来很顺
这种做法之所以在Swift中如此出色地实现
原因之一是 Swift有强大的静态类型系统
可以确保你不会写出无意义的代码
或者对代码解释错误
所以 强大的静态类型系统能确保
你允许移除的参数
是相应集合中的元素
如果你要做出任何失策的举动
比如 试图从好友列表中移除“caffeine”咖啡因
你会收到编译器发出的错误消息告诉你代码不符合逻辑
所以 我们讨论了使用站点的可读性
我们排除了很多的单词
你可能因此觉得我们追求的是简练的代码
事实并非如此我们想要清晰的代码
不过...
清晰的代码也需要达到适当的平衡
不能过短或过长
如果想知道什么代码过长
过长的代码是包含不必要额外信息的代码
过长的代码实际会影响清晰度
因为 在读这种冗长代码时你的脑子在做什么？
它在努力筛除所有额外的噪声
筛除所有冗余的不必要的东西
从而找到代码中实际的信息
而这个平衡的另一端也不可取
如果你的代码过于简练
那么你可能遗漏必要的信息
以致使代码难以理解
什么表明代码过于简练
如果你在读代码你发现自己会总是参考
API文档因为API本身描述不够清楚
则说明代码过于简练
所以我们要找到中间最佳的平衡点
使代码既清晰
又简练
这样 了解API和API工作方式需要的所有信息
都在语境信息中
这实际上是Swift语言本身的原则
所以 这里我提供一些代码
在这些代码中实际存在
Swift中不需要的冗长信息
就是这些直白的类型注解
这些注解没有增强代码的可读性
仅通过读API你就可以了解这些类型是什么
实际上 在Swift中你很可能不会这样写代码
你可能会匹配这种类型信息
让静态类型trebicore
帮你作注解从而使代码更简练
也仍然清晰可读
当然 类型很重要
类型就在那里
如果你需要确定特定的类型是什么
而这样能有助于你理解
当然 你可以选择获取答案只需在Xcode内单击
那么 让我们看一下另一个API
并讨论下什么时候实际需要一个单词
才有助于描述参数
我们以这个小API为例即 将“子视图”
添加到某个“主视图”中的某个特定点
因此 我们写出用例
记住始终从用例开始
想一下用来描述参数的词
在第一种情况下单词“child”用在了
这个“视图”参数中也就是我们第一参数
“child” 表达了什么信息吗?
嗯 从静态类型系统中我们知道
边栏会是某种视图
但单词“child”可以说明操作中
此参数的作用
它表明了这里的参数将成为“child”
它建立了层次结构
这确实是很重要的信息便于我们了解这个API的作用
现在 第二个参数中存在“atPoint”和“origin”
“origin”会是什么？嗯 它将会是CGPoint
这个API会使用CGPoint
这里除了CGPoint你也提供不了什么
所以这个单词不能表示实际意义
它只是在重复说明强静态类型系统中
已经存在并将被Swift语言
实施的信息
所以去掉这个词你不需要它
现在看看这里调用站点的样子
如果大声读出来你在“origin”添加“child”边栏
读起来语法很对
这是这种
特定API设计准则的原则之一
即 我们力争达到使用点通顺并语法正确
这里的例子 从我们的好友列表中移除“remove(ted)”
就具备这种特点
现在 让我们看看一个非常相关的API
这个API是要移除特定的元素
如果我们看 比如移除特定位置某项目的API
读出来
从集合中移除之前好友的位置
读起来不对
这不是位置的集合
而是人的集合
让这句话实际读起来符合逻辑 我们要说“remove at”
让我们读出来：
在之前好友的位置移除
请注意我们澄清API行为的方法
是放入第一个参数标签 以描述
参数与该方法的关系
这就涉及命名和命名的概念
所以 在Swift中一个函数的名称包括
所谓的基名称在这两个API中即“remove”
以及参数的所有参数标签
所以这两个相关的API它们有相同的基名称
即“remove” 因为它们属于相同操作方法系列
即从集合中移除某项目
但它们的参数标签不同
因为它们做的事情不同
一个是按照身份移除元素
另一个是基于在系列中的位置移除元素
所以略微不同的API拥有不同的名称
现在 你可以基于类型信息进行重载
如果两个API拥有同一复合名称
但只有当API的语义
相同时你才能这样做
所以这里你可以重载
没有参数标签的附加名称从而将字符
或字符串附加到某些文本
因为它们根本上属于相同的操作
它们只是出于方便起见被重载到不同的类型上
现在写出第一参数标签后
同样 你需要保证用例读起来符合语法规则
这包括方法的基名称
以及参数标签
所以这是我第一个API：removeBoxes (withLabel:WWDC)
注意这读起来顺不顺
注意 这个API内有一个介词短语
所以这有点像英语语法本质上这个短语是“withLabel”
它描述参数与移除方框的实际操作
之间的关系
当存在这些介词短语中之一时
将它放在第一参数标签上以描述第一个参数
如果你根本无法构成符合语法规则的短语
也可以使用第一参数标签
因为如果将第一参数放在那儿
具有一定误导性
所以这里 我们有“viewController”我们说“dismiss(true)”
那是什么？我不能把布尔常数到处乱放
所以 要让这句符合语法规则
我需要在那儿放上一个参数标签
解除“viewController”
变成动画Animated为真
所以这是附带的额外信息
第一参数标签将它分解开所以读起来很顺
而且很清楚 我们解除的就是实际的视图控制器
你可以访问Swift.org阅读其它若干规则
但本质上 你仍会在某些情况下略去第一参数标签
这些情况下在API中仅仅是有自变量
就读着很顺：
在好友的起始索引处插入“michael”
这读起来很顺
我们不需要第一参数标签使它读起来通顺
所以我们将标签省略
好
在继续之前我们稍稍再介绍下命名
在对方法进行命名时基于方法的副作用命名
所以 请使用英语动词和命令
告诉接收方“做某事”
所以这里 我们可能说我们有好友集合
对它进行反转“viewController”　请显示
“Organic compounds”请附加
对吧？这些是采取的操作
我们基于采取的操作命名
现在 我们有一些方法其主要作用就仅仅是
返回某值
我们使用名词
描述返回的东西
所以 这里我们可以要求获取按钮的背景标题
或者好友阵列的后缀
当你在处理值类型时
有时情况是这样的你拥有本质上相同操作的
转变和未转变形式
这里我们喜欢称作
使用我们喜欢称作“ed/ing规则”的东西
这来自英语语法
基本上你要从动词形式开始
所以这里 我们有“reverse a collection”
你命令X自身反转
而对于更像是名词的其他形式
使用“ed规则”
我们要求X被反转
我们描述我们想要的结果
这就与转变形式对应
而“ed规则”不适用时
一般适用“ing规则”
通常这时这里有一个参数
我们有一个文档目录
我们可以对目录附加路径组件
这就是转变我们告诉它附加这个
现在我们有未转变形式
给我这个文档目录附加这个特定的路径组件
所以这些规则 以及许多其他规则 在Swift.org上
作为API设计准则文档的一部分 都有描述
强烈推荐大家进行阅读
并努力在自己的API中应用
不过 当然
只有实际广泛应用了这些准则才会变得有趣
所以我们要进行Grand Renaming
就是将这些准则
应用于Swift标准库
应用于Cocoa和Cocoa Touch API
以及应用于指向性地
改进API 如Core Graphics以及Grand Central Dispatch
这些准则可用在所有情况下让这些API经过Swifty整容
从而在Swift中更美观
我之前稍微提到Grand Renaming的规模
所以 这是一个小Swift应用的截屏
应用叫做Lister这个应用已经发售几年了
在从Swift 2迁移到Swift 3时Lister是样本应用之一
大家可以看到左边有很多.swift文件
基本上 整个项目中每一个Swift文件
都因为从Swift 2到Swift 3的过渡而改变了
如果你们留意这里中间和右侧窗格中的一些细节
你们可能发现这些Cocoa API名称都变了
所以 这里有很多改变我们将就此进行介绍
不过 非常有趣的是这些你们可能
已使用很长时间的Cocoa API这些API是一样的
但现在 一个特定的API有两个不同的名称
一个名称适用于Objective-C
另一个名称适用于Swift
作为Swift程序员大多时候你不必在意这一点
你完全可以在Swift名称下工作
使用你生成的界面和文档
所有材料都将显示Swift名称Swift名称就是你要应对的
不过 有时你跟系统交互这种情况下
你实际上确实需要Objective-C名称
比如 如果你要激活目标操作
所以 这里我们实际需要
为目标操作提供选择器
我们有这个字符串参数
在这里写什么呢？
我不知道你可以看看生成的界面
或者在Twitter之类网站上问你的Swift编程朋友
你能得到答案这没问题
但是 请不要这样做
因为这个链接非常非常薄弱
这个字符串参数非常容易输错
它跟上面你实际想要调用的方法之间的链接很薄弱
为此 在Swift 2.2中我们引入了#selector
#selector非常简单就是一个表达式
它接收Swift方法的名称
然后产生该方法的Objective-C名称
你不需关心Objective-C名称是什么
编译器会搞清楚
当然 这一点最棒的是
Swift确保存在该方法
确保该方法向Objective-C公开
并计算出正确的名称
当然这可防止重构
可以使用代码补全
让你享受更舒适的开发体验
这意味着你无需担心Objective-C名称
在Swift 3中 对此进行了延伸 你也可以参考属性的
接受方和设置方
所以我们完成了
实际能计算的Objective-C方法名设置
这使用起来非常简单
你只需输入参数标签设置方或接受方
就可以分别获得设置方或接受方
然后参看Objective-C属性
当然编译器会验证
该属性是否存在并向Objective-C公开
为该属性获取正确Objective-C名称
现在 提到Objective-C方法名
选择器并不是唯一字符串类的东西
我们也有项路径当作为字符串参数
编写而没有任何验证时项路径是出了名的难写对
所以在Swift 3中我们也将引入#keyPath
#keyPath的作用跟你们料想的一模一样
你可以参考圆点间隔的属性访问序列
编译器会验证这些属性实际上是Objective-C属性
获取正确的名称
然后生成我们传递到框架中的字符串
所以通过#selector和#keyPath
你基本不需要担心Objective-C名称
你只需要使用Swift名称编程
然后停留在这套Swift名称里
你无需游走于边界两边
现在 有的情况下你确实需要考虑
Objective-C名称为何
你可能有一个混合项目里面有Objective-C代码
需要关联到你Swift代码中的名称
像这样的名称：“handleDragWithSender4”
在Objective-C中时感觉就是不太对
所以这些情况下你可以使用@objc属性
在圆括号中 输入你想要的确切的Objective-C名称
该名称会体现到你生成的标头和所有元数据
等等当中这样你能够具体控制
Objective-C名称
但是你Swift代码的其他部分都无须在意这一点
当然 这个@objc具备名称 适用于属性
适用于方法、类和协议
任何可以从Swift向Objective-C公开的对象
你可以在这里控制名称
所以对于Swift代码你可得到漂亮的Objective-C API
好
Swift 3 发生了很多改变
Swift语言本身让你无需考虑
Objective-C名称
然而当你确实在意Objective-C名称时
它又让你可以获取所需的掌控力
我们有这些工具帮助你
所以Swift 3迁移器进入Swift 2代码并将它
迁移到Swift 3名称和Swift 3语法
这涉及很多变化
但这些工具可以帮助你渡过难关
适应Swift 3下的工作
Swift 3迁移器是很棒的工具
但它不能迁移你的肌肉记忆
当然也无法迁移从堆栈溢出复制粘贴的所有代码
所以 Swift编译器也可以为你提供帮助
Swift编译器了解所有这些API的
Swift 2名称和Swift 3名称
所以如果你在一些Swift 2代码中编写或复制
编译器会识别旧的API名称并向你提供诊断
使用Fix-its更新代码帮助你快速适应并工作
此外 我们引入了相近差错检测
在实施可选协议方法时可用
所以 当你在实施委托时 这个功能很棒
你犯了个小错误
你想要实施的委托方法名称错了
现在你收到警告消息附带Fix-it 以便修复名称
这样你可以放心你的方法会被准确调用
现在 我想将舞台交给我的同事Michael
他将介绍将C和Objective-C API映射到Swift
所以Swift很了不起
但如果你是Objective-C开发者呢？
或者你的项目是混合项目呢？
所有Objective-C API在Swift中都有
它们一直都在那里
但正如Doug解释的这些API是针对另一种语言设计的
在Swift中 它们日渐显得有点格格不入
所以今天我将展示你将如何控制局面
使你的Swift用户获得应有的优质API
我会先开始展示几个Objective-C API
它们被导入到了Swift 2中
这里有两个方法saveToURL forSaveOperation
和revertToContentsOfURL
不过这些确实没有体现Doug介绍的API设计准则
里面有很多冗余的类型信息
我们没有有效地利用第一参数标签
第一参数标签
我会先开始介绍你在Swift 3编译器中
自动免费获取的功能
Swift 3改进了Objective-C API的导入方法
Swift编译器将检查方法名并使用语法正确的提示
以便推断第一参数标签
Swift编译器将检查名称
从而消除冗余类型信息
编译器甚至可以推断一般Objective-C习惯用语的
默认参数如完成处理程序
或选项集
同时 有新的值类型如连接到NSURL的URL
所以导入时我们只需直接导入
要了解这些值类型的详细信息 请访问
今天随后的“Swift基础的新特性”
所以 自动推断非常棒
但根本上它是启发式推动的
编译器不懂读心术
它不知道你的意图
经常你需要指定自己的名称
为此 我们扩展了NS Swift名称
现在 自从Swift 2起NS Swift名称就存在了
但在Swift 3中 我们支持完整的复合命名
复合名称是基名称加参数标签
所以这种情况下我们有两个方法
它们执行语义十分相似的操作
但它们的不同点基本在于它们处理参数的方式
所以在同样的基名称约束下我们导入它们
但我们说我们希望它等于此定位标记或
大于等于此定位标记
现在方法名可以推动你朝向Swifty API行进一大步
但行进的距离仍然不够远
这里 我有一些简单的代码可以创建标准的
格利高里日历
但如果你看一下这个这真的不怎么Swifty
尤其是NSCalendarIdentifierGregorian
这是个普通的字符串全局变量
普通字符串全局变量这可不是使用Swift编程的方法
这就是我们戏谑为字符串型API的东西
而这种API使用字符串
这一定程度上导致简单错误的发生
没错 故障很简单开发者可以马上发现
但是此API的用户必须记得这是什么
以及这不是可以用在这里的有效字符串
这样对用户造成了不必要的认知负担
所以 为什么这个API是这样的？
我们都知道为何该API是这样的因为它来自Objective-C
但该API来自Objective-C的事实
这是实施信息
而这种实施信息泄露了
在Apple我们并不喜欢信息泄露
要搞清楚哪里出错了
让我们看一下Objective-CAPI如何映射到Swift的
我们的全局变量作为全局变量进入 当然
但除了全局变量的名称外
没有什么可以告诉你
这是针对特别具体的API的特别具体的字符串
现在 我们可以尝试添加typedef以试验并暗示我们的意图
但是typedef不过是个类型别名
它是旧类型的新名称
所以这实际上不能解决这里的问题
所以 API会是什么模样
如果我们要在Swift 3中重新设计？
我们可能会在字符串周围形成新的包装类型
从而获取一些强类型
而这些全局变量相反 会是静态属性
所以在Swift 3中 我们引入了仅针对该用例的新属性
你可以通过NS ExtensibleString Enum访问该属性
当你想要告诉Swift编译器
围绕字符串形成新的包装类型时
你可将此添加到typedef
导入程序将围绕此为你创建新类型
任何此类型的全局变量将作为此类型的
静态属性自动导入
因为这是可扩展的我们在这里选择一个结构
就是说 其他模块可能需要定义自己的结构
而如果它们定义了 它们也将作为静态属性被导入
到该结构的延伸部分
现在 在幕后Swift编译器会直接将此映射到
潜在的存储值中
意味着这其中没有额外的经费或装箱
或中间过程
所以 让我们关注使用站点
因为好的API设计始终关注使用站点
过去如此...
以后也如此
因为类型语境更清楚
我们甚至可以只是说“.gregorian”
下次 我会自己开始领头鼓掌
同样 在Swift 3 NSCalendar中现在 它作为日历为我们所知
这是个小改进
所以 我们有方法名以及类型
我们还有什么？
好 我们有大象
就是说 我们在屋内有大象
我们一直假装看不见它
但它始终在那里
它就是C
现在 通过Objective-CAPI已经面向对象了
所以导入时 我们只需更改几个字符串 添加几个类型
这相对简单
但是C呢？
我将主要介绍核心图像
现在 核心图像是一种非常流行的API
基本每个Swift应用都会用
这是一种强大的API但它的外观和感觉都像C
让我们从一些代码开始
我这里有两个函数
第一个转换 嗯...
进行转换并旋转特定偏移量
第二个函数跟踪红色路径
现在 两个函数都不怎么复杂
而且细节并不重要
但我只是想看看这看起来怎么样？
感觉如何？
继续 等等
所以 如果你注意你会发现代码完全充斥着
全局变量和全局函数
当然 我们不怎么喜欢全局函数
或全局变量
所以我们怎么拿到一个这样的API
然后使它变Swifty？
我们如何使它有Swifty的感觉？
好 为此 我们再次看一下NS Swift名称
你可以使用NS SwiftName将全局作为类型成员导入
让我从全局变量开始向你展示我的意思
在这里 顶部有C的定义
下面是生成的Swift界面
下面是Swift使用站点
将重点关注Swift使用站点
并改进Swift使用站点
我们添加NS Swift名称并使用typename.membername
从而告知Swift编译器应将kCGColorWhite
作为CGColor上的静态属性导入
当然 Swift使用站点现在可以使用正确嵌套的属性
当然 如果类型语境清楚
用户甚至可以略去CGColor
新的核心图像有很多不同的全局函数
可以创建不同类型的CG Affine Transform
这是CGAffineTransformMakeTranslation
以及CGAffineTransformMakeRotation在所有这些上面
但在Swift中我们更喜欢初始值设定项
所以我们使用TypeName.Init并提供参数标签
以便告知Swift编译器
这应该只是一个初始值设定项
我们使用参数标签
以便明确参数的角色
你也可以作为实例成员导入
使用特殊参数标签self
以告知Swift编译器
将参照self插到什么参数中
所以现在CGContextFillPath仅仅是一种方法填充路径
当然Swift使用站点
只是像是方法一样调用它
编译器将获取圆点左边的内容
将其插入相应的参数位置
就按照特殊参数标签self指示
我们可编写更复杂的代码
你可以在Swift名称前加上接受方或设置方
告诉编译器将此函数
作为计算的属性导入接受方或设置方
ArtistGetName
ArtistSetName现在就是
计算属性Artist接受和设置方
让我们关注使用站点
因为好的API设计始终关注使用站点
以前 我们会使用全局函数
记住艺术家曾用名
并使用另一个全局函数设置新名称
现在 我们的用户可以直接使用计算的属性
所有情况下经费成本都是零
编译器看到myArtist.Name时就会将其
直接映射到相应的C函数
而不调用任何包装或中介或覆盖
你也可以使用NS Swift名称嵌套类型
还记得先前我们创建了新的标识符类型吗？
好 你可以使用typeName
好 成员名称
嵌套类型名称从而嵌套类型名称
所以 这种情况下我们得到了Calendar.Identifier
现在 我们喜欢新的NS Swift名称
我们这么喜欢它
以致于我们完全彻底发狂了
这里不要鼓掌
仅在核心图像中
我们就将它用在超过600个API中 600个
现在可以鼓掌了
这确实很疯狂
那么 让我们再看看之前的代码
之前 我们的全局变量
全局得非常痛苦现在它成为成员了
而且因为类型语境更清楚了
我们甚至可以略去类型名称
我们的全局函数现在是方法
实际上 现在我看着这个我觉得代码更简单了
我们不需要额外的变量结果
所以现在代码读起来...
读起来非常美自然又Swifty
我们获取转换
进行翻译
进行旋转然后翻译回去
非常简单
继续
CGColorCreateGenericRGB
以及所有其他很多很多创建颜色的方法
这些现在是带有参数标签的初始值设定项
当然 先别鼓掌
而且 当然CGContextAddPathContextPath
以及所有其它疯狂冗余的东西
它们现在都是方法
我们希望你们喜欢这些新的API
所以 总结下 首先我们展示了Swift中新的API设计准则
好的API设计始终关注使用站点
第二 我们了解了Grand Renaming
也是我们熟悉的：“哦 不！什么都变了”
但是别慌一切还好
名称改进了代码更清楚了
你得到迁移工具了
最后我们介绍了Swift编译器的新功能
以便于你拥有自己的Great Renaming
要了解更多信息请访问该站点页面
网址为developer.apple.com并浏览Swift.org
开源Swift项目的主页上
你可以看到Swift的所有演变
我也显示了核心图像
不过Grand Central Dispatch有自己的Great Renaming
使用的方法跟我今天展示的很多相同
所以 星期五请关注Swift 3中
使用Grand Central Dispatch技术的并发程序设计
星期五