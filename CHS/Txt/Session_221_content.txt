优化按需加载资源
欢迎来到优化按需加载资源
我是tvOS工程师团队的Bill Bumgarner
在这个演讲上 在去年的WWDC上
在这一年的开发者厨房
我们已经讲了如何使用按需加载资源
本场演讲中 我们想要关注在
如何优化资源的使用 特别是
如何打磨用户体验 来真正地创造
一个极好的用户体验
我们来看一下这些动机的一个基本概况
如何指定标签 API的使用
然后讲一下如何优化首次启动
如何优化运行中的用户体验
同时也会讲一下优化应用更新
和一些实现的细节
所以为什么
为什么要按需加载资源
对于一个传统的应用程序
它是由应用程序的二进制值和一堆资源所构成的
这些一起组成了应用束
它被组合在一起 上传到商店
你们的用户可以下载并安装它
慢慢地 他们会下载和安装一堆的应用
但是如果你看一下这些应用的使用模式
我们会发现只有一部分的资源被经常用到
另外一些资源可能只被用了一次
在程序介绍或类似的其它地方
而这会导致占用大量的磁盘空间
这也意味着用户不得不在一定程度上思考
关于什么是他们要保留什么的什么是不要保留的
我们不想让我们的用户变成系统管理员
所以在按需资源应用中我们想要尝试优化的是
优化资源的使用
在它被使用的时候
同时保证它是可得的 早于用户注意到
它需要被下载
所以在传统应用的基础上 我们把资源
分成绑定的资源和按需加载资源
它们不是真的存在于系统里当应用被安装的时候
现在 在过去的一年中有一些错误的概念
关于tvOS应用的大小
有一种说法是我们把它限制在200MB以内
这不是真的
tvOS上主程序集限制是200MB而对于iOS
它可以最大到4GB无论如何 在这两种系统中
它们的按需加载资源可以达到20GB
所以按需资源
它们提供了动态加载的内容它可以按需提供
或者可以在应用安装时被下载
它是托管在App Store上的包括托管不同版本
所以升级不是问题
显然若你有一个用户坚持使用旧版本它还是能工作的
它们在程序安装过程中是可以下载的
在运行的时候 如果有请求它们也是可以下载的
而且你可以控制下载的优先级
而且你可以调整优先级
因为用户可能改变他们的想法
去做他们想做的事情
同时 所以这些和系统一起
提供了智能的内容缓存和智能清理
这样 我们就让用户远离了系统管理的工作
对于你的的应用来说 好处是变小了
这意味着它更快了和加速了下载
意味着这个时间间隔变短了在用户点击购买按钮和
用户使用你的程序之间
而且 你有更为丰富的应用内容最高可达20GB
这可是很大的空间哦
而且 那样就可在系统中装更多的应用
它们都是可以运行的而且减少了管理存储的需求
这也意味着用户可以拍很多的照片
一部分按需加载资源可能被释放出来
这都是完全自动的
那么我们如何来实现这个呢？我们如何采用这个呢
你要做的第一件事是要指定标签
给所有的资源 你实现这个通过寻找
在程序中 找出所有的资源
找出每个资源在你的应用中的角色
和你需要它们的时间
然后在Xcode中指定标签
标签一点儿都不神奇
它们只是字符串
只是一些你想要的字符串第一级 任意东西
它们可以被应用于单独的资产
或者一个单独的资源 一个声音文件一个纹理 一张图片 无论什么东西
纯数据或者它们可以被指定给整个文件夹
而且 每个资源可以有多个标签
因为它有可能有多个角色
让我们回过头看看GreatGame这个应用
看一下那些资源
把这些资源按照角色分类
在这个例子中这是一个非常明了的基于级别的应用
而且它有总是需要的资源
这些就是 比如你的启动页面
你的启动加载页面 或者是设置页面
这一类的东西
它有给每一级别提供的资源
或者购买项目或者应用内购买的东西
对于这些标签 是非常直接明了的
只要给他们和它们角色一样的名字就行
所以当我们做这些 当我们看这些时
我们给这些东西打标签的策略是什么呢
只要给主程序集的资源
那些程序始终确实需要的资源
你的加载页面你的程序启动页面 这类东西
然后你给另外所有的东西打上标签
每个标签可被应用在最多512MB的
资产或者资源
然而 我们强烈建议你遵循64MB左右的限制
因为那样会使下载更快
而且让用户更加不易察觉
每个资源可以都多个标签
只要你用了其中的一个标签
就会提取所有对应的资源
所有我们已将所有东西归类并打上标签
让我们看一下运行时的情况
在运行时 我们尝试让API尽量简单
实际上 这只是一个类
有一个资源请求类
你要创建这个类的一个实例来管理所有
按需加载资源的读取
它通过一个标签或者一组标签来创建
而且它有一些其它的选项来管理它
你可以用它来开始和结束资源的访问
开始访问会触发下载 如果需要
结束访问会告诉系统 嘿 我结束啦
在这个对象中 你也可以设定优先级
如果你有一个特别大的下载或者一个特别慢的网络连接
你可以追踪进度而且也有可能会遇到错误
我们马上会降到
关于这个类有一个有趣的东西是
每一个实例都是一次性的
它们是非常轻量级的 非常容易被创建
这意味着当你创建一个实例开始访问它
在你调用结束访问之后这个对象就完了
创建一个新的
有一个非常重要需要记住的概念是
请求和访问是不关联的
所有当你请求
从当你要使用这个资源时我们是可以的
我们会在预测加载讲这些
所有我们可以预测用户将要干什么
来保证他们永远不会看到那些加载界面
让我们来看一下真实的代码
初始化一批资源请求是相当直接的
只要给它一组标签然后你就有你的请求了
如果你想要开始访问那些标签
调用开始访问 它有一个完成句柄
那个完成句柄会被错误地调用
如果有错误的话 或者它会被正确调用
那么你的资源就是可利用的了
为了得到资源 使用包API
抓住一个NS包实例 对不起
包实例 重命名 从请求中
只要使用正常的资源请求方法
于包 来控制它
当你结束了之后调用结束访问是非常重要的
这告诉了系统你已经用完了这个资源
需要重点指出的是 那不意味着
系统就会真的删除资源
系统是非常懒惰的
它们不想做额外的工作删除东西的额外工作
所以当你加载资源的时候你可以控制优先级
比如 你要在玩一个游戏
用户改变了他们的想法
你就下载这个级别的资源
现在你需要下载级别5
你开始于开始访问
你可以继续 你可以改变加载优先级
来把优先级提到5级或者降到3级
如果你觉得他们可能返回或者你可以结束它
它只是一个值 从0到1
但是有特别紧急的优先级
有时候 会播放器会关闭
而你又无法预测
你需要立即下载所有东西
在这种情况下这种特别紧急的加载优先级
就能被用到了
它会挂起所有其它的下载
也会最大化吞吐量
所有没有网络节流
也会最大化中央处理器使用专门用于下载
最后 会有有条件请求
有条件请求可以用来检查
资源是否已经被下载
如果你还记得在我说结束访问的时候
不一定要删除资源
播放器已经在玩一个游戏
他们已经玩过了1 2 3 级
你已经结束对1 2 3级别的访问
他们退出游戏下线后再做了其它一些事情
当他们回来 重启游戏
他们想要重玩1级
你可以有条件地使用
或者说他们想要选择不同的级别
你可以条件地使用开始访问
来检查什么级别已经被下载了
给它们指示什么已经可以玩了
或者如果它们进入了一个级别
在每个级别中你已按照角色分解你的资源
可能你优化了级别的第一部分
只是展示数和刷子和敌人
正好那个时候在磁盘上
当你在后台下载余下的部分
所以所有都是关于你可以
避免加载页面
如果这些项目已经被下载了那就会像开始访问一样地工作
同样 需要调用介绍访问
就算你得到回调 那它也是假的
你决定不去触发下载
总是调用结束访问
现在你有了一个可以工作的程序
但是让我们看一下首次启动
特别看一下这个时间轴
我们会沿着时间轴
从用户在商场中购买这个应用的那一刻开始
应用被下载 被安装
和第一次启动然后我们需要做的事情
我们要做的第一件事 开始访问1级
这会触发一个下载然后播放器开始这个游戏
然后到达2级 我们也是开始访问
它会下载 用户在那等待
用户继续玩 重复这个流程
3级 下载 等待 玩游戏
甚至对于可购买的项目 程序内购买
下载 等待 玩游戏
这不是一个好的用户体验
让用户经常地看到加载页面这是不行的
我们不想这个样子
所以我们要做的第一是
充分利用功能和按需加载资源
这是自带的功能 来优化首次启动
我们要做的第一是使用初始安装标签
接下来我们要使用的是预获取标签
有了这些
那么1级会在应用购买的时候被下载和安装
2级会紧跟着被下载和安装
用户可以开始玩了
让我们看一下预测下载
但先看一下
如何配置初始预提取
所以初始安装标签
这些在Xcode中被标记的标签需要被下载
作为出程序安装的一部分
最多可以有多达2GB的资源这是很多的
这是在App Store上显示的程序大小的一部分 实际上
当下载进度条开始的时候
表明初始安装标签也开始了
预提取标签是稍有不同的
你可以有任意多的预提取标签
最高可达4GB减去初始安装的大小
它会遵循Xcode中指定的一个排序
预提取标签在初始化之后立即被下载
它们不会阻止应用的启动
所以用户可以进入游戏并开始玩了
尽管预提取的东西在后台被下载下来
在Xcode中
用户界面是这个样子的
这是资源标签检查器 在目标编辑器内
对于你的应用
它有三部分 初始 预提取
和按需标签的下载
你一开始移动这些东西
这些会和你的应用一起打包
同时被安装
预提取会按照你在屏幕上看到的顺序被下载
最后 按需的下载
是只有你开始访问那些标签的时候才被下载
回到我们的时间轴
我们非常简略地讲过预测加载
那这到底是什么意思呢？
我们开始初始化
得到我们的预提取
我们仍然让我们在3级的时候在等待
若我们开始访问3级标签对应的资源
在1级或者2级的某些时候
这样可能在用户到达那里的时候那些资源就已被下载并能被使用了
同样对于购买项目
如果在你的应用 游戏 不管什么中有一个特殊的时间点
你认为有可能或者你希望玩家将要
做一个程序内购买那就在那里开始访问
只有当你得到返回后 你才能访问它们
但是至少它会在那里 不会有等待
现在我们得到一个大的绿色时间轴和一个非常高兴的用户
我们已经讨论了这个基于层级的游戏
这是一个非常线性访问的模式
它非常容易创建漂亮的幻灯片
这不是真实的世界
在一个线性访问模式中大部分资产会被使用
它们大部分会被按照顺序地使用
你的标签大小不是那么得关键
因为你始终可以在用户之前得到访问
但是问题是 当然
这里没有什么是线性的
特别地
很多时候 应用都是随机访问模式
播放器可以播放任意一个地方
或者有些东西可能被不同的级别所共享
或者他们可能选择特定的配置
或者他们可能购买了一些应用内购买项在这种情况下
目标是尽量多地预测
尝试在用户需要之前把东西下载下来
但是在你需要下载的时候
在那一刻真的需要时
坚持小的标签组
这样就会下载得很快
而且你可以有前瞻性地下载标签组
可以继续了 只是猜测什么将会被需要
让它们就那样 下载到磁盘 因为
当然 我们有这个智能缓存机制
它会在后台运行 确保删除正确的东西
如果磁盘满了的话
再强调一遍 结束访问并不意味着删除
如果你下线了而且你提前下载了一些东西
然后你根本不需要它 没关系
只要结束访问 它可能还是在那里
当你以后需要它的时候
现在有另外一种模式这是一种在两者之间的
那是探索性访问模式
那是...你想
从一个村庄到另一个村庄类似的情况
在这种情况下 存在有限的预测
很多可能不会被使用
但是你经常在一个分支上当你在一个分支上的时候
你可以下载一个标签的子集
用户左转 右转
所以我要下载向左的标签和向右的标签
当用户做出决定后
打算向右
让那个下载停止
关注右边 开始预测下一步
所以现在这个应用可以正常工作了
我们得到了一个非常棒的用户体验
但是让我们看一下一些实现的细节
在页面的背后进行着的
你可以关注一下以进一步优化用户体验
特别地 正如我所说的 程序包
在iOS上被限制为4GB在tvOS上被限制为200MB
但你可有多达20GB的按需加载资源
它们中的最多2GB可以和应用一起被下载和安装
最多4GB可以被预提取减去那2GB或者最多2GB的安装
还有一些数据要记住
同一时间最多可以有2GB的活动资源
所以你开始访问最多2GB的标签
那些会被下载 然后就是可用的
这非常棒
当你超过了2GB 会发生的是
开始访问方法会得到一个NS错误
这表示用完了带标签资源的空间
你需要对一些标签集结束访问
来释放一些空间使得更多的资源能被访问
重复这一点是因为有另外一个困惑的地方
如果你有2GB的已经下载好的标签
而且你想要访问更多
你访问其中的500MB
固定另外的250MB那500MB资源
可能不会被删除
它们还在而且是可用的
但是这只是告诉系统如果情况变得不好了
它可以去删除它们
任意一个标签 最多可以到512MB尽量坚持64MB或者更小
你已经有最多1000个资产包
资产包是什么鬼呢 还没提过这个词
资产包来自于Xcode编译系统
这是你的应用生成和管理的方式
这是按需下载资源被编译在一起的方式
通过商店来管理
看一下我们GreatGame在这个情况中
一个角色扮演游戏 这无所谓
我们有标签 非常的典型
资源会被重复使用
东西会被使用在1级到2级
敌人变成了朋友 诸如此类的东西
所以我们在这里有这两个资源它们在2级的时候被使用
所以它们标记了1级和2级的标签
所以我们的标签集看起来是这样的
我们有四个带一个标签的资源和两个带两个标签的资源
当我们至于四个标签的时候
最后会有六个资产包
如果你考虑一下一个随机访问的游戏
这就会变成一个阻碍
若你很多资源被很多不同的角色共享
比如很多资源有5个 10个 15个标签
那么所以这些的叉积会超过
1000个标签或者1000个资产包的限制
这时需要注意的
所以在游戏或者应用的生命周期内
当然 你会有程序更新
你想要提升用户体验 让用户回来
按需下载资源被优化
为了程序的更新
可能有一点点令人惊奇
但是如果你仔细想想 这是合理的
特别的 我们以1.0版本的游戏开始
我们在游戏中有一堆的资源 一些带标签的
和一些在主要包里的
然后我们发布第二版
我们在主包里面做了一些改动
我们可能给1级增加了一下资源
对2级更改了一些东西
我们增加了一个全新的级别
这些都很好
那在升级的过程中会发生什么呢
第一件事情是当你更新资源的时候
更新带标签的资源没有什么是被自动重新下载的
当它第一次被访问时 它会被重新下载
我们不想重新下载教学级别
当用户已经远离这个了
所有没被更改的资源会待在磁盘中
不需要下载 它们就可以被访问
新的资源它们会在被访问的时候被下载
所有 再说一遍系统对待这个是非常懒惰的
在这种情况下 因为我们不能预测我们会对应用做什么样的改动
会被需求各种各样的状态 或者用户
在你的应用留下的东西
我们将其交给你决定
触发开始访问来触发上传
和下载新东西
实际上 在第一次启动时你可能想要开始
和开始访问一些你改变过的东西
以此确保在用户主要到之前就让这些资源是可用的
所以 这个的最佳实践
避免对带标签资源的不必要的修改
比如
我们有过一种情形当有人做了一个拼写的改变
令人惊奇的是所有东西都被重新下载了
当第一次访问它的时候
如果你改变了这个资产包里的一个资源
这会触发下载整个资产包 这只是一个
具体的实现
所以请牢记
你应该做的是 比如
在我们给1级增加一些额外资源的情况下
我们可以让1级更新一个标签
然后开始访问它们 下载
当它们都可以使用的时候然后运行用户运行1级
保持那些标签一致
从一开始 你要设计好
可更新内容和静态内容的分离
所有这些意味着 你可能有一个标签
对于你的程序中的单一的角色
可能你想要把那个标签分隔成多个标签
当它是可能永远不会改变
和少数会被改变
所以这些如何组成智能内容缓存的呢
对于tvOS这个操作系统的目标之一
是永远不让用户注意到这个用法
永远不需要删除东西
永远不需要去考虑它
作为这个的一部分
有一个完整的缓存管理系统和自动清理系统
系统会清理到磁盘上的资源
当磁盘空间快满了的时候
有多个不同的级别从优先级最低的开始
会清理缓存这些
然后一步一步地到越来越高的优先级
所以 再强调一些这点
当你用完了资源的时候一定要结束访问
这并不意味着资源会被删除
智能内容缓存
有很多变量告诉系统关于清理的顺序
显然的 最长时间没被用的先被清理
你也可以控制保留优先级
保留优先级是一个信号对于打包资源请求
这是一个0到1的数值 只是用来表示
系统以什么样的顺序删除东西
它独立于你的应用 所以不会作弊
它不会帮你把所有都设为1
它只是表示当真的需要的时候我们会吹走一切
如果你的程序在运行
它会是系统最后一个清理的资源
这是非常重要的
不要使用临时变量和缓存
显然若你需要一下临时的东西或者缓存你可以使用
但是因为我们无法知道
在临时缓存中的数据的结构
系统会认为它们是在低优先级时 就可以被清理的
它们会被清理 而当它们被清理了
它们是被整体地清理了
所以 最后
总结一下
使用按需加载资源
特别是对于tvOS按需加载资源的使用
真的提供了更加优化的用户体验
它影响了网络连接
在iOS上 事情变得更加的棘手
但也有很多成功使用它的方式
它会使得应用更小
这会减少用户获取的时间
从商店到你用户玩上你的游戏使用你的程序
用你的内容做所有的事情
你有了更多的应用内容
现在你有了最多到20GB的空间放任意你想的东西
而对于用户 他们不需要考虑这个
他们可以安装任意多的应用
他们没有一个障碍
他们也不需要考虑存储
这就是按需下载资源的优化
更多相关的信息
请参考我们的网页
在本周的早些时候也有许多相关的演讲
我建议大家回顾一下
谢谢