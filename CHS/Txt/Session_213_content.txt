利用现代最佳实践优化现有应用
大家好
好啦
我叫Woody在Apple做软件工程
欢迎大家参加本次大会欢迎在座的各位
还有在家在线观看的各位
在接下来的40分钟里我想跟大家讲几点内容
我们来看看通过一些方式 你今后可以
开始减少你的技术负债
我们再来看看资源目录
看看新的设计模式
不完全是新的 但是设计模式
希望你们使用依赖注入
讲座的后半段会更新一下
我去年关于LivePlaygrounds的讲座
那么我们就开始吧
去年的讲座 在一个实验室中
我见到其中一个观众...
在描述一个场景
描述一件我想你们中许多人都熟悉的事
你的老大给了你一堆功能的要求
这些功能会产生收入 你想获得报酬于是你照做
然后你有客户
他们想要修补让他们头疼的错误
你以你的工作为傲所以你也想做那个
有些技术负债要解决
有时我认为开发软件
就像搭Jenga积木
第一个版本比较稳定你开始往它上面叠加东西
然后它开始变得不稳定之后就崩溃了
所以 你得退一步
可能要先解决一些低层次的问题
带着这些问题
你才来参加WWDC
我们叠加在新的API上
我们给你一个新的Swift版本它打破源代码的兼容性
但引入了一些新的功能
而且有提醒你所以不要抱怨它
然后我们引入了新平台和新扩展点
及一些现有的应用例如Siri和Messages
如果你想把自己的角色定位为开发者作为一个运行循环
所有这些事都被挤进去
你知道会发生什么有太多东西了
那么你要做什么？
有些什么事是你可以开始
为今年秋季做准备？
首先 如果你支持iOS 8和9的部署目标
你会覆盖95%的设备
真的没必要把那些部署目标设置在7
不要它了
事实上 大概的想法是
你采用当前的推送版本 即9.3
然后将你的部署目标设定在上一个版本 也许是8.4
但不要再到8.3或8.2了
因为你的客户不会得益于
我们对8.4的下行版本所执行的优化
当我们在今秋公布iOS X时
将你的部署目标设置为9.3
下一个 问题导航
解决那些问题
检查然后修正它们
当我们告诉你...有...
当我们告诉你有不建议使用的API
不建议使用API是出于一系列原因
包括实现更好的错误处理
或作出更好的报告 或允许更多性能
或只是增加灵活度在参数返回值中
而且真的没有理由不升级
到
新的API因为我们就告诉你
我们告诉你用什么
那么 就用它 转到那些
接下来 你可能要决定你要将警报视为错误
我们已用Objective-C有一阵子了
但现在我们在Xcode 8中对Swift也有了
没错
我想我是第一个告诉你们这个信息的人
我非常喜欢这个想法 很棒
将警报视为错误 这样它就会强迫你和你的团队去解决问题
太容易会忽略那些黄色的警报
而且过后再回来处理它们然后你没有
那整个就成技术负债了
而且
你觉得这样有用吗 如果你...
搭建也许一个1.0版的新项目
一个新应用 然后你对你的团队说我们要发布1.0
但我们没有绘图还没有
上面没有任何图标
我们要发布它 然后将那些在.1版本里做补充
那根本行不通 没人会那样做这就是用户如何与你的应用互动
嗯 实际上是许多但不是所有用户与你的应用互动
许多人利用辅助功能与你的应用互动
该功能已嵌入操作系统
所以 你为什么要发布你的应用
为需要它或使用它的人带绘图但里面又没有辅助功能？
那不公平
解决关于辅助功能的技术负债
为其添加支持辅助功能
是你的用户界面的一部分和绘图一样
它是嵌入Xcode的
对此你可使用InterfaceBuilder编程也容易
我们有许多能识别区域的API
你应该用那些 你可以少写些代码
尽管那个不算新的
但这些是
Dimension和MeasurementFormatter若你有菜谱或健康类应用
你一直在metric和imperial之间转换
在你自己的代码上
不要那些了 用我们秋季将发布的代码
我们想要你支持Peek Pop和Quick Actions
好吗？
你知道吗如果你现在有iPhone 6S
你可能已经习惯...我们来按这个看看它会做什么
没有 我们按那个看看它做什么
那个会做点什么很难察觉
那会有多棒如果我们的每个应用
已经支持Peek Pop和Push及3D触摸？
接下来
要运行Swift Migrator用Xcode 8开发者预览
如果没有迁移你的代码提交错误报告并告诉我们
那我们就有机会修正它
等你在秋季实际运行Migrator
在Xcode 8最终版本上
它就很可能可以用
如果它不能用
我们用API解决我们自己的技术负债
公共界面是一样的
但执行可能会在不同版本之间有变化
可能是你使用任何API的方式
不是我们所预期的
你就有一个边缘案例
那你也将其告诉我们这就是为什么我们做这些预览版
我们想要你提交错误报告
报告并不只是走廊的玩笑
不只是在开发者论坛写文章
也不只是发送电邮给Apple
提交错误报告的恰当方式是...
是这个BugReport.Apple.com
填写空白处
你填完后会获得一个号码用那个号码你进入
并发帖到开发者论坛
有很多Apple工程师浏览开发者论坛
我们想听听你的意见
但当你在那些组里提交或报告一个问题
你没附上错误报告号码
我们很难在内部跟进和追踪它
所以 得那样做
接下来
你可能...
不是非常喜欢向我们提交错误报告
因为你提交它们了之后...
然后你等啊等 石沉大海
你没得到任何回应
用Whitney Houston的歌词说孤单的错误报告去哪儿？
它们好像进入一个巨大无比的黑洞因为你永远得不到任何回应
或者你觉得也许
你在一个工程师面前得到回应而那个工程师
有点不理会你所说的
我只是想和你们保证不是那样的
我加入Apple后的第一件事就是我搜索了一下
错误追踪系统问题追踪系统
以寻找我当时作为一个外部开发者时提交的所有问题
当中许多问题都有跟踪我只是从未得到来自它们的任何反馈
我想跟各位说 如果你的确提交了错误我们的确会查看它们
另一件事是 你可能花很多时间提交错误
很多时间你可能是在做一些样本代码
你在试不同的设备检查回归
这样做很好
你花了可能半个小时或一个小时
然后你提交它 然后它回来说是个复本
然后你就觉得 刚浪费了生命的半个、一个小时
为了别人做过的事情
我只想简单讲讲复本
因为复本首先不是表决系统
不像是 如果你复制别人的错误 一字不漏
然后你用同样的东西提交一个新错误
我们说 对此有一个表决我们会先修正它
不太像是那样子
我们怎么处理它们即使它们是复本
只是意味这这两个是相关的
我们也需要复本不是为了表决的目的
但因为我们可以有五个人提交相同的根错误 相同的根问题
前四个
没有给我们足够的信息去找到它
但也许是你的报告也许是你的第五个
尽管是个复本
但是当中的信息是我们所需的让我们找到问题
事实上
一个在Apple待了几十年的工程师
说了一句很风趣的话
在几个星期前
Paul说每个错误报告跟一片雪花一样独特
应该是这样的
好 那么小结一下今天先讲的部分是
修正你的警报替代不建议使用的API
本地化你的应用 如果还没的话
使用辅助功能
或支持辅助功能获取Peek和Pop
然后看看下一个版本的Xcode
给我们一些关于它的反馈
接着讲资源目录
是时候为各位讲讲资源目录
如果你还没有文件在你的文件导航里 像这样
去获取它们放在资源目录里像那样
方法...
是你从文件菜单中添加一个目录
你无须只添加一个目录
你可在项目中添加许多目录
也许你正在做一个应用是个卡片游戏
那么 你有个目录用于卡片的正面图像
第二个目录用于卡片的背面图像 我们可以做到
举个例子 你可能让你的图形设计师
从App Store免费下载Xcode
为你创建资源目录
然后发送给你或在代码库里检查
我们也能做到
复制文件到资源目录时它们正是复本
我们从不参考原始位置
那么 它们的确参与版本控制
为了迁移你的项目你点击big plus键
选择“从项目导入”
我们会给你一列合资格的资源
从文件导航迁移到资源目录
像这样你迁移了你的图像资源
如果你之前...
习惯使用bundle APIpathForResource等等
那已经不能再用了因为一旦我们编写了应用
图像不是周围自由浮动的所以你找不到任何东西
但如果你使用...
已被命名的图像
我们可找到它们若其在资源目录里
而且我们可以找到它们如果它们只是自由浮动
仍在你的文件导航里
这个API出来已有一阵了API图像名有许多优点
超越仅仅只能从图像目录中找到内容
资源目录
例如 它内部缓冲
第一次你以名称找一个图像
我们加载它我们给一个参考
第二次你以名称找同样那个图像
我们对同一个东西返回另一个参考
那不是文件内容的API如何运作的
每一次文件内容会加载新图像
它更加高性能
尤其当你滚动表格使用已被命名图像时
我们支持一个资源的多个表现
所以 使用已被命名图像
你给它一个名称
API名称
你让框架考虑你正在运行的设备
考虑显示屏的分辨率 视网膜
非视网膜 Plus设备上的视网膜
而且可能有其他区别因素
对于媒体资源例如设备中的内存容量
或者设备所支持的Metal的版本
你得到一个图像返回
有两大类资源类型对于你可以考虑的图像
我们有缩放图像
例如PNG
JPEG
然后我们有单矢量图像
比如PDF或SPG
我们对待它们有点不同
在逐个资源的基础上
你可以说这个资源会变成矢量型
那个资源会变成缩放
你通过指定比例因子来实现
我讲讲一些缩放图像
然后再讲讲矢量图像
对于缩放图像
在这个例子中我们已经叫你们提供三个不同版本的绘图
从1X设备非视网膜到2X和3X
如果我们找不到由于你没有包括
2X和3X 我们拿1X的图像将它放大
它就变成
在更高端设备上或更高密度设备上使用的图像
同样
如果你只是提供给我们3X的绘图我们在运行时间将它缩放
这两个情况不是那么理想
这个情况中 若我拿1X图像将它放大用于iPhone 6S Plus
它看上去非常凹凸不平
它会有一种视觉上的效果叫图形失真
它不是很理想
嗯 你的客户不会喜欢它
这个 初看时你能会想 哦
我只是提供3X绘图让你缩放
但那样有个巨大的问题 因为
要缩放一个3X图像我们要打开一个3X图像
它非常大
然后...
我们提取像素 为它创建一个缩放版本
它可能是一、两个数量级更大
所以 想想这个
你在使用一个设备 比如5S、5C
上面没必要用3X图像但你只提供3X图像
那么 我们从使用的内存的基准线开始
没问题但是然后我们得加载3X图像
转换它 去掉3X图像然后留下这个缩放的版本
这样临时造成一个内存峰值如果你行的话
可能会没问题
如果你行 我的意思是如果你幸运的话可能会没问题
但 假设你滚动表格视图
你在滚动时我们得不断做这个
突然你应用的内存使用一下子膨胀了
知道当你使用过多内存会发生什么事吗？
有谁知道的 大声说出来
对 没错我们终止它
它死机了
由于你没有提供绘图所以 请提供绘图
事实上 你可以非常轻松地用进程来实现这个 或者
不是用进程 而是Automator工作流程
你给它一个3X图像让它缩放 给它个名称
缩放它 给它个名称 很好
把那些扔进你的资源目录
而如果你想要 你可以
这是另外一个最佳实践使用这个命名惯例
非视网膜的只是Align Justify.PNG
然后添加2X、添加3X和其他两个
然后当你拖放它们三个到资源目录
我们找到一个命名惯例
我们创建一个资源用三种不同的呈现
相对于三个不同的资源
对于矢量资源
矢量资源很神奇因为文件包括
一套如何绘图的指示
相对于让它预先栅格化
它是同一个图像 不是三个版本同一个图像缩放到不同的大小
当你指明你要使用
单矢量缩放提供一个矢量图像
在构建时间 我们将它栅格化成我们需要的不同大小
对你来说更简单
这像是你可能会对工具栏图像会做的事
以及导航栏图像
看 缩放因子 单矢量
也可能二者结合
你可以设置缩放因子为矢量和比例
你提供给我们一个矢量图像
好像方框里那个叫做All
然后 如果你想覆盖任何其他比例因子
你只要提供那些作为其他矢量图像
或PNG、JPEG缩放图像
然后当我们创建它如果你丢失某些资源
我们会根据矢量图像将那些栅格化
在那个All方框或目标
否则 我们会使用所提供的缩放图像
Xcode 8中新的功能是你可以调整压缩
快出来
你可以调整压缩那么 比如对于一个JPEG图像
你想用有损数据压缩但也许对于一个PNG
我们不想要任何压缩因为它将是
工具栏上的一个项目
我们不想看到它有任何伪影
你可解决的一个问题通过用资源目录
以防如果栅距还不够强
是修正该问题或为我们解决一些问题
我们指的是圆角
圆角的问题是我们有自适应的UI
那么
你的按钮可能包含文字标签契合得非常好
直到应用在另一种语言中运行
然后它改变了大小
当我们改变按钮大小时我们会想保留
它漂亮的圆角
你获得圆角按钮的方式首先是
Interface Builder里面 选择一按钮并指定一背景图像
然后我们将其应用为背景
在这个例子中我有一个资源叫做圆角矩形
我将它应用为我的背景矩形
但你可要看到在两个不同大小的按钮中当它拉伸之后
看上去非常糟糕
那么 你可修正的一种方式是
你一直都在用的方法就是使用可拉伸图像
你说 我想在两边都保留X数量的像素
行 但是今天讲座的一个主题是
你写更少的代码而更多地依靠框架
以及我们提供的工具
所以 这个是被嵌入资源编辑器
叫做资源切片器
你可以使用它去指定
红色的部分 不要拉伸这些
不要使它们变形
照亮的部分 重复这些像素
通过那样做 你得到
完美的圆角而且你不必为它写任何代码
这是你的图形设计师可以做到的事
作为资源目录的一部分
好的 接下来
讲讲设计模式 叫做依赖注入
首先讲讲我们想要修正
或尝试改变的 透过引入这个
我们有UITextField它用代理
代理叫做UITextFieldDelegate
好 当中它包含关于文本框的方法
比如textFieldShouldBeginEditing
OK？
我们有WCSession
WCSession代理
代理中有什么？关于WCSession的方法
你可以看到这当中的模式
我们用这个来打破
我们有应用代理 当然它有方法
关于应用程序对象
但我们在当中也插入其他东西
比如数据库 实际上最后什么都有
包括厨房水槽 堆叠起来
我们这样做因为很容易
通过应用程序对象返回
获得共享对象计算它然后检索它
但它是太过强的耦合
在你的视图控制器和应用代理之间
而你的应用代理不是真的需要在那个位置
反而...
像这样的一个模式 当中每个视图控制器指向某些共同的对象
也许是你储存在你的应用代理中
你可以转换它
利用依赖注入你将模型对象
那个视图控制器所有的然后你将它向前传递
给下一个视图控制器当视图控制器呈现时
目的是你给视图控制所需的一切去运作
那么 对于Mail你有一系列邮箱
显示一系列邮箱的一个视图控制器
会有一个模型对象代表一系列邮箱
你点击当中的一个邮箱
另一个视图控制器会显示那个邮箱中的信息
中间那个
然后你向前传递那个邮箱
它显示那些然后你继续向前传递
你那样做的方式 以一个Segue
是覆盖prepareForSegue然后将它传送至repair
你那样做的方式如果你是在做编程展示
是对实例化中所见按钮的行为中
视图控制器将模型对象传递到那
该技术好处是...
你的视图控制器现在是独立的
他们没有这些强烈的联系和依赖
你可以不断重复使用它们
返回的话 你有一些选择
你可以做我们所做的通常是写一个协议
执行它
于是有通知返回说视图控制器被撤消
然后也许更新你的模型你可以传递一个闭包
你可以按参考传递对象模型
或者 你可以
如果你使用在线segue
与覆盖prepareForSegue是一样的
以两种方式发生前进和后退
我们喜欢这个的另一个原因是...
因为视图控制器很像乐高积木
它们可以单独地重新排列
以创造新的结构
在此情况下iPhone SE的整体用户体验
对于你的应用将是不同的
不同于iPad 12英寸iPadPro 12英寸
如果你的视图控制器是独立的要做到那样很容易
好的
那么 去年在 WWDC
我做了一个演讲 是关于...
Playgrounds、现代化UI
及Objective-C和Swift互操作性
自从那以后 我们添加东西到Playgrounds
是我们去年还做不到的东西我想向大家展示其中一些
用那
我们来做个演示
那么 这是那个元素周期表应用我去年向你们展示过
从那之后 它被更新了一点
例如
颜色有点变化
不是按物质的状态气态 液态
现在它是按物体的种类像过渡金属 金属 卤素
那类的东西
我们还添加了支持以将它展开于是它实际看上去
就像个元素周期表那样是个集合视图
我要给大家展示部分代码
这个代码库改动的其中一项自从上次你看到它之后
是数据模型已移至Swift
现在我有一类代表原子元素
像是氮或氧
还有一类代表一个集合
所谓的 不好意思 周期元素
这个类将元素实例化
单独的原子元素
通过在属性表中读取
我将其也储存在我的应用这里
但既然我已将数据模型移到Swift
我可向大家展示Playground中的数据模型
去年我做这个时 先打开一个新的Playground
新建文档 playground
去年我做这个时 我只是在代码和Playground之间复制粘贴
当你不断这样做时
你的Playground变得很大有很多代码
于是 现在Playground有子文件夹
用于源代码和资源
我可以将我的模型对象
放进源文件夹
然后我们在幕后编写它们
然后隐式导入其所有公用符号
到Playground中使其供你们使用
这意味着...
如果我将这个资源文件 我的属性列表
将其放入资源文件夹
使其对Playground可用
我可以到Playground这里
实例化一个原子元素的例子
这是锎
像那样
所以 能够将这些源文件
自动导入你的项目中
从源文件夹或资源文件夹中
我认为是个强大的方法
使你的Playground本身保持小而精
同时当中又能含有更多内容
那么 除此之外自从去年以来还发生了其他事...
影响了这个应用
国际纯粹与应用化学联合会
确认发现了4种新的元素
于是一下子 我在应用中嵌入的这个属性列表文件
看似不再是个好主意了
我想我们可以修正它我们就把它放上线
于是我建立一个小小的网页服务器
这次放一个JSON文件包含所有元素
然后想法是 当我的应用开启时
起初它会使用嵌入的数据文件
那样如果没有网络连接的话
仍然会有东西让客户看
这也是我们推荐你用的模式
然后我们做个背景检查
在其中我们会检查是不是有文件的更新
如果有 我们将它放进缓冲文件夹
然后我们在应用里指向它
我要在Playground里作出网络请求
为此 我们有一个类之前称为NSURL Session
现在称作URL Session
显示在这里
我们抓住这个Session...
我喜欢这个Session的原因是当我在第24行唤起它时
我给它一个完成处理程序
因为这个在背景中异步运行
去到网络请求让我的代码继续运行
当请求要么超时
要么数据进入时做这个回调
在第28行的回调中
你可以看到我打印出一个元素在这里
但你实际上看不到它在那儿
那是个问题
所以 想想这里在干什么
我们有一运行中Playground我们让它实施背景操作
在未来一个不确定的时间
我们得到回调说这是我们想做的
但Playground通常像脚本一样运行
从第一行一直到末尾 然后结束
关键词是“通常”但不一定是这样
我们可发起一个运行循环
在Playground中执行异步操作
为此 我们导入一个新模块叫做PlaygroundSupport
然后你让Playground做无限运行
然后它永不停止一直在处理
那么 现在如果我往下滚动到这个部分
你会看到我得到回调
那是镉
好了
接下来我要扩展去年的内容
去年我展示了一个绘图一个圆角的“核心图像”的图像
这次我不想绘制一个图像预览它
在Playground中做一个全表格视图控制器
Playground中有些新功能可以让我们做到
我们就打开一些空白
在我的应用中
叫做View
我要做一个UI表格视图控制器的子类
这就是
选中的区域
我执行那两个方法是每个表格视图
和表格视图控制器都需要有的
对象数量 或者 抱歉 而是...
项目数量 自写的索引路径和返回本身
我想看到它变实时
所以这次我们要做的是...我们实例化视图控制器
然后使用PlaygroundSupport模块
是我已经导入的就在第4行的那个
我抓住Playground的实时视图
将那个视图
变成Assistant Editor它已不再为Assistant Editor
而是实时视图
看到没？是实时表格视图
它可以滚动 是活动的
谢谢它不只是个静止图像
它是个真正互动的表格视图
如果你想尝试我们的部分新代理方法
或现有的代理方法
可将其丢进Playground然后和它们互动
无需再把这个放入模拟器中
现在我把它们放在一起
具体来说 我有了这个背景网络请求正在发生
在我检索数据后我要重新加载表格视图
我给大家展示看看
首先 注释这个
为了向你们证明它完全从那个网站加载数据
我要更改这个...
于是我有一个空白的元素列表
好
我有一个空白的元素列表
当网络请求返回它是回调 它被指定了
我刚拉进的新元素列表
然后我们重新加载表格视图
好的 继续
那是你所期待的吗？
不是我第一次看到时所期待的
那肯定是Xcode中的错误
我在Apple.com提交错误报告
但它实际上不是
它是我代码中的一个错误 不管信不信
它是我代码中的错误现在看发生什么
我们有这个背景操作进来
这个背景操作有一个背景操作
不是在主线程上
UI在主线程上
那么
在我的闭包中完成处理程序
我不能从那里更新主线程
当我重新加载表格视图时我尝试这么做
当我点击单元格
我们使其无效这就是为什么它们会刷新
然后你可以在当时看见它们
这个东西我们可以修正我们在Swift 3有新的东西
是Swift API用于Grand Central Dispatch
所以
不用我们之前有的C API
现在我可以说一个调度队列排在主队列
什么类型的操作？异步的
我们不再需要那个
现在是我要在主线程上做的
现在它弹回主线程
就在那儿
调度队列 谢谢Swift中的调度队列
Swift中的实时视图和无限运行
让我们转回到幻灯片
谢谢那么 小结一下
前面所讲的
或者刚才演示的重点
一些其他小建议
当我拖动那些文件到源文件夹
或资源文件夹时它们是被复制而不是被参考
而且 只有标志为公用的方法
标志为公用的方法、属性、数据类型等
才会在Playground中可供你使用
你可能添加公用说明符 因为
Swift中默认的可见性说明符是内部的 不是公用的
我提到使用缓冲文件夹
现在 我们仍然有些设备是容量受限的
客户尝试查看操作系统的新版本的更新
他们发现不够容量
所以 在那种情况下当设备容量不足时 我们所做的是
我们查看缓冲文件夹
删除在全部应用程序缓冲文件夹里找到的任何东西
这样我们就释放了空间
我们需要你帮忙做这个
如果你正临时下载数据你没存放在缓冲文件夹
请存放在缓冲文件夹
接下来
我觉得会很干净利落的是将
又这样
将...
使用依赖注入的视图控制器
重新排列使之适合不同平台
那么 我要转回到演示
打开Bluetooth
将视图控制器放在tvOS上
好 就是这样
我已匹配Siri遥控器到我的Mac所以我可以通过模拟器来使用它
和之前的代码是一模一样的
一样的视图 一样的表格视图所有的东西都在那
我可以翻过去 看到...
周期表 像这样
我得到漂亮的电视效果当我滑动表格单元
及其集合视图
是相同的布局代码和视图控制器
和我之前有的一模一样
呃
几乎一样
我添加这行代码 这样当我...
选择集合视图单元时你可以获得重点那个项目
且我使用OS Compiler指示
说明这仅适用于tvOS
除此之外 都是相同的代码
这有点让我想到一点如果你有想过你
将一个应用从一个平台拖动到另一个平台
但没有任何实际改动你可能是做错了什么
然后检查人机界面指南
只为了看你如何让那个平台和那个应用
在那个平台上更自然 感觉上更...
更像它是属于那里的
我们来举个例子
假设你开发了一个应用是做类似基于云的会计
然后也许你有一个iPad版本在这个iPad版本上
用户填写发票
合理
不合理的是 在我看来
要在60英寸的电视上填写发票
你不会那样做你怎么会那样做？
这不是个你会在tvOS开启的应用
但是你的应用的iPad版本也许有一些很棒的可视化效果
关于公司是如何运作的
也许你有一些图形或图表
那些在电视上会很棒
你可以有一个应用版本
具备实时状态面板显示公司的运作
也许在公司的会议室
它就放映出来 播放动画显示更新信息
它是相同的数据模型是相同的数据访问
但你将数据转化得让它更适用于
它运行的平台
思考一下如何将我们拥有的相同的数据
转化成可用于那个平台？
总结
将你的应用现代化是个不断进行的过程
我们希望你尽可能多地依靠框架
若你可摆脱你应用中的代码
使用我们在框架中提供的代码
你可以维护更少的代码
我们希望你那样做
我们希望你今天开始查找Xcode的问题
用Swift转换器
希望你用更少的对象间依赖关系来设计打造你的应用
这样你会更容易重新编排你的应用
最后 我们希望你考虑将你的应用引入我们的其他平台
通过转化你的数据模型
有一些相关的讲座你可以查看
就是这些
除此之外 你可以查看
这场讲座的链接我就讲到这
谢谢各位