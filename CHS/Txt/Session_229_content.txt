使用TVMLKit开发应用
好的
大家下午好 欢迎来到TVMLKit应用开发的第二部分
有许多优秀的应用
使用TVMLKit开发出来放在App Store上
一些应用使用自定义样式
带给用户与众不同的体验同时扩大了应用的知名度
今天我格外的高兴
同你们进行交谈 并且告诉你们如何
提升应用到另一个水平
这需要通过扩展TVMLKit
扩展接口
同时也需要JavaScript中提供的功能来实现
通过上述方式基本上能让你的应用脱颖而出
甚至会有属于自己的品牌
TVMLKit是一个功能完备的框架
我们也试图确保
你在思考如何构建你的想法时
你只需要考虑两个扩展点即可
在上半场演讲中
我将告诉大家如何
在TVMLKit中通过扩展模板的方式来扩展用户界面
下半场演讲
我的同事Christopher将会讲解
如何增强你的应用通过添加程序功能
到JavaScript引擎支持TVMLKit的JavaScript引擎
让我们谈论扩展模板的内容
首先第一件事情每一个人都会遇到的是
他们使用的TVMLKit就是模板的概念
模板在TVML中定义 就是TV标记语言
他们使用XML描述屏幕上显示的内容
当人们看到了这里
他们会说嘿
我知道它 它是浏览器
我敢向你保证那绝对不是浏览器
TVMLKit是一个功能强大的模板引擎
但那并不意味着你只能使用我们提供的模板
实际上 Apple自家的应用同样使用TVMLKit
但是以巧妙的方式扩展
使它可以和原先的
框架共存仍能良好的运行在tvOS上
让我们看一个例子
这是App Store上的应用
App Store的主题有一个要求
一个shelf中只能存在一个cell
你能看到他们复用了TVMLKit提供的
一个图片控件和三个文本控件
除了这些他们还有自定义布局
使用了自定义的聚焦动作
另一个例子是我们非常熟悉的
是对于购买按钮的印象
App Store的主题要求
购买按钮必须反映出应用程序的不同安装状态
你是否正在购买应用
应用是否被安装或者已经下载
所有的这些都通过复用TVMLKit提供的模板来实现
这些主题就是今天我想特意展示给你们的
尽可能复用TVMLKit
并且尽可能的扩展我们没有在模板中提供给你的样式
这就是模板
如果你已经使用了TVMLKit它遵循一系列的路径
当你把TVMLKit注入到框架中最后会在屏幕上显示
TV标记语言由许多元素组成
命名各不相同
当它进入到框架中后会被传递到TVElementFactory
TVElementFactory是注册中心
它记录着所有的元素
它能够将元素翻译为相应的数据结构
框架能够识别的数据结构
我们使用TVInterfaceFactory类
生成用户界面
然后将他们显示在屏幕上
这就是TVML如何显示到屏幕的过程
让我们看一下扩展模板的过程中会发生什么
当提到模板的扩展就像添加你自己的标记那样简单
在TVML中将标记发送给框架
它会经历相同的处理过程
它会进入到TVElementFactory紧接着被转译
但是当自定义的元素碰到TVInterfaceFactory
因为框架不了解你的用户界面
框架会针对自定义元素询问你
当你将界面给框架后
TVInterfaceFactory将把自定义的元素显示在屏幕上
就是如此的简单
现在你知道每个过程是如何工作的
让我们来看一下它们的具体实现
你需要考虑三个步骤
当你想扩展模板的时候
首先是定义标记符号
标记在TVML中基本上就是XML
你有一个想法
就是你的用户界面在屏幕上会怎样显示
你必须将它转译为一种结构
一些类似于
使用标记本身就可以标识什么应该显示在屏幕上
在我们的例子中 我们想在stackTemplate上显示一个banner
banner会有一个动画背景
假如你想有能力控制动画你可以在TVML中使用一个开关
因此 myBanner这个元素会有一个animated属性
除此之外 我们再添加一个按钮
但是因为不需要额外的功能
我们可以使用TVML提供的按钮
这就是按钮的一种形式
现在你会构想自己的用户界面
在标记中会如何显示
你需要告诉框架
这就像将你元素的唯一标识注册到框架中那样简单
在应用控制器启动之前注册操作需要执行一次
以便框架能够意识到
所有的元素需要特别处理
上面的过程很简单就像告知TVElementFactory
你想要关联一个TVViewElement类到
你自定义的元素上
TVViewElement是基础的数据结构
用来转译你的标记
让框架能识别这些标记
除TVViewElement外
我们还可以使用它的两个子类
TVImageElement用于处理图像
TVTextElement用来处理文本
既然我们已经注册了这些元素
现在处理第二步 第三步时你那边会有小部分工作
但是我们试图让事情保持简单接下来只有两个步骤
你要做的第一件事是创建一个建造者接口
创建的接口必须遵循TVInterfaceCreating协议
这个特别的对象会
提供你的用户界面当框架需要的时候
有一些回调函数你需要实现
这些函数需要遵循TVInterfaceCreating
协议声明返回你想要的UI类型
下一步是当你调用你建造类的接口时
框架会对你的界面进行配置然后将界面返回给我们
像我之前强调的尽可能复用TVMLKit
我们已经做了很多工作去保证
在tvOS上运行时内置元素在性能、外观和体验上的表现是良好的
让我们来看一个例子
建造者的接口是什么样子
在这里我们有一个MyInterfaceCreator类
这个类遵循TVInterfaceCreating协议
因为我们仅对特定的视图更感兴趣
我们可以去实现makeView元素
还需要实现existingView的回调方法
一旦实现这个类后 你需要做的是
使用TVInterfaceFactory注册这个类的实例
让我们具体看一下makeView这个元素
我们可以看到TVMLKit
给你提供了一个元素和一个可选的existingView
在这个例子的banner中
我们只需要检查这个元素自身的名字
我们需特别注意myBanner这个元素
当我们发现和它类似的元素时
我们要创建这个视图的实例
因为myBanner有一个元素属性
我们可以很容易的筛选到这个元素
利用这个元素提供的回调函数
然后将这个元素转换到视图上
我们在这个视图上还有一个按钮
因为它是一个TVMLKit按钮
这样做是简单的就像
为特定的元素调用TVInterfaceFactory
然后会为myBanner元素返回它所需要的视图
最后当然也会返回你需要的视图
在框架默认方法中
必须返回nil
我们已经谈论了很多视图的内容视图控制器的内容呢？
TVMLKit提供视图控制器样式是
一个shelf有很多lockup
用这种样式进行水平方向扩展
或者是网格垂直方向上的扩展
使用TVMLKit的回调函数
返回这些视图控制器
你可以使用你自己的视图控制器替换默认的视图控制器
这种用法类似于makeView
在这个实例中我们仍然提供相应元素的existingViewController
我们希望最终返回的是existingViewController
现在你会想原来如此
本质上就是视图的集合
视图的集合是许多带有cell的视图
这就是如何对自己的lockup进行定义
这个例子够深刻吗？
App Store有一个特殊的要求
一个布局仅有一个cell和特定的行为
就像你看到的其他的东西是UMLKit的扩展
标题的上下浮动依赖于
焦点是否位于元素的范围内
在将要推出的tvOS 10中
我们允许你指定自定义视图集合的cell
允许你为cell自定义布局
最重要的是你可以拦截焦点事件
当cell获得焦点的时候
为了达到这种效果你需要做两件事情
首先是用我们最新的API
它允许你对我们视图集合的CellClass进行设置
当我们使用特定元素的时候
我们在屏幕上构建用户界面
框架通过使用makeView来允许你进行自定义
对相关的cell进行配置返回界面给我们
我们提供可自定义的视图集合cell
将视图集合的条目加入队列中
使用已有视图自身的参数
接下来我将请Parry上台
为你们展示上面提到的界面是如何工作的 Parry
视图集合条目的自定义展示
谢谢你Jeremy
大家好 我是Parry我将给大家展示
如何在TVMLKit自定义cell
自定义cell是简单的
如果你想像多个shelf那样使用TVMLKit集合
还有网格 但你想添加自己的cell
通过自定义布局和聚焦机制来展示你的内容
我将向你展示一个基于TVMLKit制作的简单应用
稍后
我将使用自定义cell对它进行扩展
使得应用的显示效果更好
让我们开始吧
我把屏幕转接到我的电脑上
我使用Xcode打开我的应用
我会基于TVMLKit进行编码
让我们看看这个应用
这个应用可以使用户浏览他们的相册
应用中使用到的JavaScript和同XML相关的文件
都存储在我的电脑上
我们可以大体浏览下这些文件
现在显示的是应用的一个页面
这个页面会把用户的相册展示出来
你可以看到stackedtemplate
还有一个不错的banner
背景图
它有一个shelf是用来展示相册的
每个相册其实通过lockup呈现
每一个lockup嵌入了来自相册的图片
最后相册展示出来
除了使用一些自定义样式使得lockup变得大一点
我没有自定义TVMLKit
现在它是没有TVMLKit的应用
运行程序看一下它的展示效果
接下来我将在Apple TV上运行
这就是我在stackedtemplate文件中提到过的应用
别致的banner在顶端
它的shelf在底部
我觉得超出范围的那部分还是挺不错的
这是奏效的较大的lockup能使得它看起来不一样
我觉得还能做得更好一点
考虑这种情况
除了从相册中取一张照片
显示在当前的页面上
要是我们选择多张相片
选中的照片来自于相册
使用那种方式将相册放到文档上会怎样？
让我们想一下
如何构建图像的拼图
当相册没有被选中
或者当相册没有获得焦点时将图片加入到九宫格中
那听起来挺酷
但不止于此
它将关于相册的上下文信息传递给用户
用户可以看到相册中的许多图片
真是一个使用TVMLKit自定义cell的不错例子
让我展示如何使用它
我将切回我的电脑
我想做的第一件事情是
像我刚才所说的创建一个特定的标记
它是视觉表现的呈现形式
对你的用户界面来说
根据XML的规则使得TVMLKit可以被理解
所以我将在这里
就像你看到的 它也是一个带有shelf的stackedtemplate
但是除了lockup之外它还有有一个新的元素
就是我刚才创建的叫做FlyoutCell
展示的就是我刚才创建的那个条目
我称它为flyout因为图片看着像从里面飞出了一样
就像描述中提及的
我想在cell里放多张图片
因此
cell里面有多个图片子元素
有一点需要注意
对所有自定义的cell来说
它们需要有三种样式
它们是宽和高
在tvOS 10中添加新的样式
是TV focus margin
TVMLKit使用宽和高
在集合视图中给cell适合的边框
使用TV focus margin作为默认大小
当元素获得焦点时便可以知道将边缘扩大多少
它使用这个信息创建
适合的间隔在两个shelf之间
也会去重新调整shelf header
当移动到cell下它便获得焦点
现在我们有了规格那下一步该做什么？
需要将新元素加入到TVMLKit中
让我们快点做
让我们看一下AppDelegate
在应用中有didFinishLaunchingWithOptions方法
我将删除这些代码
我之前写的 就像上面那样
使用我刚添加的FlyoutCell元素
使用TVMLKit中的TVElementFactory
TVMLKit希望我们对建造者的接口做出提升
通过对它进行扩展以便我可以对cell进行配置
对吧？所以让我们快点完成它
这就是TVMLKit要求的全部配置
让我们看一下这些类的实现
从ExtendedInterfaceCreator开始
对于自定义的cell你需要实现两个API
首先
collectionViewCellClass类
要求用它映射你的自定义元素
到你使用的collectionViewCellClass类
第二个是makeView要求
使用你的元素配置你的cell
让我们快速填充空白的地方
用我以前写过的一部分代码
对自定义的cell进行映射
利用collectionViewCellClass类
同样的
利用映射去配置collectionViewCell类
特别注意的是已存在视图的参数
总是有效的
因为TVMLKit将它加入队列
从视图集合中为了使它显示出来
对于自定义的cell它将会出现在这里
在跳转到flyoutcell配置前
让我们看一下Flyoutcell类本身
这就是FlyoutCollectionViewCell类
我使用它展现flyoutCell
你可以看到 它就是
UICollectionViewCell的子类
在类内部没有使用TVMLKit做任何事情
它仅仅是cell的类
我可以在原生应用或其它应用中使用它
需要指出的是它接受
图片视图的数组
那些数组用来显示视图的内容
这些图片是我们想要展示的
在我们扩展TV视图元素的接口中
让我们回到要扩展接口的地方补全这些代码
这就是需要展示的内容 不是太多
但是挺重要的
我遍历所有的子元素
提取出图像元素
简单的重复使用TVMLKit为我们创建图像
现在除了没有显示图像之外它是相当棒的
因为我们使用的是网络图片
它允许我们对图像进行缩放裁剪来使用给出的范围
以便用户界面可以更好的展示
它同样做了缓存以便我可以在其他地方重复使用这些图片
因此复用TVMLKit的视图和其他的功能是很有好处的
我建议你们使用它
我们已经对代码进行了完善
并且和TVMLKit相关的类能理解我们的元素
还有一件事情需要去做
回到我刚才展示的stacked文本中
将所有的lockup替换为我们刚添加的FlyoutCell
我现在回到了那个地方
移除掉这些lockup
添加FlyoutCell
现在有三个相册有三个FlyoutCell进行填充
每一个FlyoutCell有...
四张图片在它里面
当你添加这些cell的时候不要忘记添加样式
那是强制的要求
我们添加了所有的东西然后回到应用中
看一下修改之后的样子
我将切换到Apple TV
上面是flyoutcell
你可以看到现在比展示一张图片的效果更好了
它看起来更生动
特别注意cell只是适用于TVMLKit
间隔是合适的 甚至相册的封面
随着cell获得焦点视图会进行上下移动
感觉像是TVMLKit内置的控件然而它的确是你添加的
你的界面实现了
自定义cell的确是非常容易实现
它允许你添加许多数值到你的应用中
通过复用TVMLKit提供的
同时会允许你使用你的方法进行展示
谢谢
谢谢你Parry
我认为Parry花了很多时间构建FlyoutCell
比实际中利用TVMLKit进行显示
在继续进行之前让我们快速回顾下前面的内容
最开始提到了扩展模板
定义一个标记去描述你的用户接口
用TVElementFactory注册上面的接口
然后将它转译成视图元素
提供可扩展建造者的接口以便你能声明自己的用户接口
可以随时停止在屏幕上构建的UI
更重要的是
使用TVViewElement的属性和特性
去配置你的用户界面在显示到屏幕之前
这就是关于扩展模板的全部内容
挺简单的
我们看到你们用它构建自己的应用挺兴奋的
在继续之前我们要告诉你一些需要注意的事情
你的用户界面通过TVML中的元素展示出来
这个文件可以在任意时间更新
举个例子 带有lockup的shelf在搜索模板里
当你进行搜索时 shelf会使用JavaScript进行更新
显示的内容会改变
这就是内容的更新
现在
当我们重新构建用户界面文档的更新就会发生
我们需要调用接口的建造者
你需要在元素中查看更新的类型
并且能看出什么地方进行了更新
举例来说 孩子有可能会变得淘气
作为称职的父母
你不想放弃你的孩子
因为那样做不太好
相应的尽可能复用cell 复用视图
在我们返回banner的那个例子中
在TVMLKit生态系统中我们不是好公民
我们没有复用所有视图
让我们看看能否改变这种局面
挺简单的就更改两行代码
在这个例子中我们把existingView看作回调的一部分
我们尽力做出我们期望的视图
在MyBanner视图中
如果不是我们期望的实例化一份新的拷贝
因为我们有TVMLKit按钮基于TVMLKit
我们也必须做正确的事情
通过传递到TVInterfaceFactory进行复用
现有视图参数
在特殊的例子中
因为MyBanner是一个比较简单的视图
在任何时间更新它都是没问题的
我们不需要去看更新的类型
除非你的视图 结构是相当复杂的
出于性能的原因 我们建议你
看一下更新的类型找出更新的部分
这是...
你需要改变的第一行
现在
在tvOS 10的新特性就是明暗的视觉表现
若你使用TVMLKit自定义的视图
你可以去监听这些特征来做出或明或暗的变化
我们有阐述tvOS新特性的演讲还会告诉你需要做的
我建议你们仔细看看
外观的适配
在这个例子中你需要了解TVMLKit的规则
复用我们的组件 谢谢你
我建议你检核样式更新的提示
从元素更新类型过程中
它会告诉你视图
是明或是暗的表现形式
复用文档灵活更新
对你来说是仅有的方法
来更新你的视图展示或明或暗的效果
因为他们是你需要复用的TVMLKit组件
更重要的是我们需要转到TVInterfaceFactory
这样才能完成这些显示工作
如果你有原生的应用又或者你有自己的视图控制器
你在应用中使用了TVMLKit
你可以让框架混合使用它们
这就像定义一个模板元素那样简单
再次强调 通过元素工厂注册它
通过加载特定的模板构建我们的用户界面
返回你的视图控制器所有的设置就完成了
另一种方法在你已存在的原生应用使用TVMLKit
是获得我们提供子应用的导航控制器
你已经学习了如何创建TV应用的控制器
我要强调的是在这个例子中你不用指定一个窗口
因为我们已经有一个窗口了
选择你要在导航控制器中显示的视图控制器
一旦你有了TV应用的控制器
获得它的导航控制器并且展示它
另一种方法是使用UIWindow的实例
在这个例子中你需要指定窗口参数
一旦JavaScript启动或者应用逻辑执行了
TVMLKit做正确的事将你窗口的键值隐藏
接下来Christopher将会和大家谈论
如何扩展应用的功能
通过调用JavaScript
Chris
谢谢Jeremy
大家好 我是ChristopherTVMLKit的工程师
刚刚我们看了如何在TVMLKit中扩展模板引擎
使用自定义的标记
实现我们自己的视图和视图控制器
还有视图集合的cell
你也可扩展TVMLKit的脚本引擎
通过使用JavaScriptCore实现
实现你自己应用中的特定功能
在JavaScript中或暴露给JavaScript
有三种方式来将代码注入到JavaScript的运行环境
在你的TVML应用中
让我们看一下
首先 你可以在运行时加载额外的JavaScript库
第二 你可以使用原生代码直接交互
同JavaScript的上下文在你的应用中
触发JavaScript中的函数或者传递数据
在两个运行环境之间
第三 你可以使用原生类
将原生类传递到JavaScript
通过简单的类约定使你的脚本可以访问它们
在JavaScriptCore中
让我们详细的了解下这些方法
从最简单的开始
JavaScript库
当你的应用开始加载最先发生的事情是
TVMLKit会加载JavaScript文件
文件里面会包含app.onlaunch回调
应用的控制权会交给你TVML应用的JavaScript
启动过程必须等待直到application.js文件加载运行
在app.launch执行完成之前
如果说你的应用比较庞大你可以对代码进行切割
把代码放到许多独立的文件中加速启动时间
这是TVMLKit普遍支持的形式
允许你加载额外的JavaScript
在应用运行时的任何时候
你的JavaScript库其中可以定义变量
和函数并且可以被所有的脚本使用
让我们看一下TVMLKit JS提供的全局函数
一般情况下你能在app.onlaunch上进行调用
你也可以在其他的地方进行调用
这个函数使用脚本URL的数组和完整的回调函数作为参数
当回调函数执行后
你可以使用变量和函数
我们在脚本库中定义的
但是还有一些事情需要注意
当你调用执行脚本的时候
TVMLKit JS会执行这些代码
在你的JavaScript文件中会调用其它函数
所以在相同的文件中不要多次调用执行脚本
同样要注意如果你的脚本依赖其它的脚本
你需要以正确的顺序加载它们
执行脚本会并发的根据URL下载脚本文件
然后会一次执行它们
如果其中任何一个脚本没有获取到其它脚本也不会执行
当回调完成后要检查成功的参数来确保
JavaScript库是可获取到的
最后 我想告诉大家
尽管TVMLKit提供了许多类似网页的接口
可是你的TVML应用不是网页浏览器
可能发现许多JavaScript库能很好的帮助你开发网页应用
但在TVMLKit中有可能出现不兼容的情况
尤其是你依赖浏览器功能的时候
比如全局的window对象或者全局的document对象
记住那些就可以了
但是不要限制你自己
在你的TVML应用中使用JavaScript
你能进入到JavaScript运行环境
从原生的代码中
可以将应用的UI事件传递到JavaScript中
或者在JavaScript和原生之间上传和拉取数据
TVML中 你JavaScript运行环境是被TVMLKit
的一个叫作TVApplicationController类管理着
JavaScript在单独的线程中执行
所以你需要对进行交互的时机进行调度
最简单的形式是你只需要简单的调用函数
在TVApplicationController上然后将block传递进去并执行
当block执行后你将获得JS上下文环境的引用
在这里你可将字符串当做JavaScript代码执行
你可以在对象上触发函数
你可获取和设置JavaScript的属性使用原生的变量
你不能持有JSContext
或者在block之外的任何地方使用
由于JavaScript运行在单独的线程中
你需要注意你不能执行任何阻塞操作
当你执行block的时候
否则会在主线程中出现死锁
获得关于JSContext和JavaScriptCore更多信息
请访问 WWDC 2013中JavaScriptCore部分
让我看这个例子是如何调用JavaScript代码的
从Swift应用中
这个显示的Swift代码是TVML应用代理里面的
我们已为UIApplication的代理方法实现了一个stub
来处理自定义的URL方案
如果我们想把URL传递到JavaScript中
需要让appController去执行block
在JavaScript的执行环境中
当block执行完之后我们将得到JSContext的引用
从这儿我们可以访问相应的属性
直接在JavaScript的全局对象上
我们可以得到原生的变量和对象且能将其作为JavaScript属性
或者就像这个例子中 作为函数的参数
我们触发打开URL的全局函数
函数在JavaScript中定义然后将URL字符串传递进去
URL来自UIApplication代理回调
我们暴露新的函数
在我们的TVMLKit应用中
并且将应用的事件传递到JavaScript中
接下来 让我们谈论桥接
使用本地变量是如此的简单
在JavaScript中使用这些变量就像使用字符串
数字和数组那样简单
这些已经在JavaScriptCore处理了
如果你想使用自己的类
你所要做的是遵循类之间一些简单协议
JavaScriptCore也会为你的类进行连接
让我们看一下
这儿有三个主要的步骤
首先你必须声明一个自定义扩展自JSExport的协议
JSExport存在于JavaScriptCore中
第二 我们需要使用Swift定义我们的类
扩展这个协议后然后将它暴露给原生类
第三 对我们的类进行实例化
或者将这个类本身暴露出来
在TV应用控制器的代理上进行回调
在控制权被交到JavaScript之前准备JSContext
在应用启动期间
让我们看一个方法如何去
对StoreKit进行包装
如果我们想把购买的函数暴露给
给JavaScript
我们开始定义我们的协议
在这里我们会指定属性和方法
使用JavaScriptCore为我们提供连接
这里 我将把它作为stub
看到我们扩展了JSExport且定义了StoreKitWrapperProtocol的协议
下一步我将为StoreKit创建一个包装类
扩展自NSObject并且实现自定义的协议
再次强调 我保留了存根的细节
但是你要在存根出定义你的原生函数
这函数你在JavaScript中调用
最后 我们实现TVApplicationControllerDelegate方法
在执行应用的JavaScript上下文环境中
这些会在app.onlaunch执行之前调用
并且允许我们去暴露我们自己的函数
在将控制权移交给JavaScript之前
这就是关于原生语言调用JavaScript的全部内容
我们定义了一个原生类
我们使用使用上述步骤使这个类可访问
对我们TVML应用JavaScript来说
在这个会议上 我们已看到如何利用原生功能
提升你的TVML应用
你可以使用自定义的标记扩展模板
为你自己的视图和视图集合cell
在你的原生应用中你可以获得TVMLKit
或者在TVMLKit中使用你的原生视图控制器
你甚至可以在TVMLKit中扩展脚本的环境
连接原生类 应用程序事件
和加载额外的库
我们已经展示给大家它是多么的简单去构建应用的特定功能
在你的TVMLKit应用中自定义自己的品牌
在构建复杂应用时TVMLKit提供的API是比较简单的
构建高质量的应用和小的开销
我希望你能看一下TVML指南
还有TVML目录下的应用实例
获取更多的关于扩展和使用TVMLKit的信息
你也可以访问Apple开发者网站
查看编程指南 示例代码和文档
还可以留意今年 WWDC 2016的其他演讲内容
特别是使用TVMLKit开发应用的第一部分
里面展示了构建一个完整应用的全过程
谢谢 希望大家在WWDC 2016余下的演讲中玩得愉快