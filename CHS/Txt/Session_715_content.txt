神经网络和加速
下午好 欢迎来到“加速”演讲
我是Eric Bainville...
我是核心OS向量和数值团队的一员
我们组提供对CPU性能优化的库
优化性能的库通常意味着我们要与底层的东西打交道
能提供大计算量的函数比如 求矩阵积
傅立叶变换 之类的
大多数这些函数被包括在Accelerate框架里
我们有 像vImage一个用于图像处理的库
它能被用于类型转换
也能用于对图像的几何变换
挨着vImage你们会看到vDSP
它主要被用于信号处理像傅立叶变换
和其它信号处理的用途
然后 我们有BLAS一个用于线性代数的库
它已经很老了它创建于70年代
几年前我们添加了SparseBLAS
用于向量和矩阵的稀疏计算
我们也在LinearAlgebra里提供了LAPACK
一个用于线性代数的高级库
在Accelerate之外我们还有一些库
比如simd 它包含了一组标头
能让你们对向量指令和类型直接进行读写
但它们不会操控CPU的向量单元
它们介于中层和外层不会改写汇编代码
我们还在去年添加了compression
用于无损压缩
对所支持的CPU我们为所提供的技术进行了优化
所以 当你们拿到新手机我们为它的代码进行优化
这样你们就不用为此担心了
好 那今天...
首先 我们来简单地回顾下compression
然后 我们将介绍两个在Accelerate里新的库
BNNS 它是一组用于神经网络低级计算的函数
还有Quadrature
它是一个用于求函数数值积分的小型的库
之后 我的同事Steve会上台
介绍simd的新添项
好 首先 在我们开始之前
让我向你们简单介绍下Accelerate的使用
基于你们对语言的选择
你们要用import或include导入函数的声明
之后 你们要链接Accelerate框架
那从Xcode的你们的项目设置里你们要浏览至
target然后点击build phases
出现一个窗口
点击Link Binary With Libraries
打开它
好的
点开这里有个小加号的地方
你们会看到一个所有能被链接的库和框架的列表
Accelerate在第一个
好的
那如果它不在第一个在上面有个搜索栏
若要找compression输入compression
我知道compression一定会在里面
好的 现你们就在使用Accelerate了
好
那compression...
记得当去年Sebastian
在平台详情咨文介绍LZFSE时
我们都不知道他们是谁
但今天我们要宣布对LZFSE开源
你们可以在GitHub上找到它
我们以BSD许可的形式发布它
让我提一下 你们会想用它的理由
这些是平台比较在LZFSE
和zlib之间 使用相同的选项
我们的编码速度要快1.4倍解码速度要快2.6倍
好的这就是我们的compression
现在让我们来看下BNNS
“基础神经网络子程序”
这个名字看起来很像BLAS
BLAS是指“基础线性代数子程序”
如我之前所提它起源于70年代
BNNS提供了一组低级计算例程
我稍后细说
我们只做低级计算
像求矩阵积 但针对于神经网络
在我细讲它的作用
和相关的API之前
让我们来回顾下神经网络
假设我们有这样一个网络
我们训练了它去识别动物
那作为输入 你们有一个图像
然后 你们有这个橘色的大框
在橘色的框里这个红色的框代表了权值
这些是这个网络的参数
作为输出 我们有四个值
这些是相应的概率对于是一只猫 一只狗
一只长颈鹿或一条蛇
好的　那首先你们要训练它
假设你们有个猫的图像
你们通过网络处理这猫的图像并得到一个答案
这是最高的概率它说是只狗
呵呵 这就是你们需要训练它的原因
事实上是只猫 那你们要做的是
反向传播正确答案
如果我稍许改动下权值 会怎么样
那现在这个网络会稍偏向猫的方向
你们要使用大量的图像做这个成千上万次
在某一刻
你们会有一个训练好的网络能正确回答
每一个请求
如果是只长颈鹿
它会说是只长颈鹿因为你们正确地训练了它
好的　这就是神经网络所能做的
注意训练和推测的区别
在推测时 我们不改变权值
那一般来说 假设你们有这样一个应用
你们要在线下做这些训练
当你们创建应用时做你们的训练
那当你们改动应用时你们要改动权值
和网络拓扑
最后能让它在设备上进行推测
好的那在这个橘色的框里有些什么？
让我给你们个例子
若你们去了“Metal的新特性第二部分”演讲
一个昨天的讲座你们已经见过了个更大型的例子
一个场景识别网络
和一个对笑脸识别网络的展示
这都是些进阶的网络它们有成百上千的层面
这个是五年前最前沿的技术
它描述了一个百数位识别网络
那作为输入你们有个小型的图像
一个对手写的捕捉
然后它被递入各个层面
这里你们有个5x5的卷积
输出会是一个含五个图像的堆栈
这个输出是五个有着不同权值的卷积
然后 你们添加另一个层面
你们对这五个图像应用更多的卷积
你们会得到一个更大的堆栈
包含五十个5x5像素的图像
那这样 你们从图像空间
一层层地来到了特征空间
这些小型图像的内容变得越来越抽象
最后就只有特征
那会告诉你们那是个零或那是个一
这是你们想要的输出
好的
那通过使用少量的层面
你们可以达到目的并且效果还不错
那在这些卷积之后我们把这些5x5x50的值
作为一个大型的向量
对其应用一个全面连接层面
其实就是求个大型的矩阵积
它会将所有值混合然后输出一组100个值
在这个模型里 被称为隐藏层面
之后你们需要最后一步使这100个值
混合在一起然后产生10个你们你们想要的输出
这里 你们在计算未来空间
这里的每个数值对应着成为一个具体数字的概率
好的
这就是这个网络的结构
如你们所见我们有两个不同类别的层面
这正是我们在BNNS所实现的
我们提供对这些层面的计算部分
好　在我们开始讨论计算
和相关API之前让我向你们展示些数字
这里我们将用Caffe作对比
它是一个知名的神经网络计算程序包
这是Caffe有关卷积的部分
我们有14个不同卷积的大小
在这里 你们可以看下
这是Caffe的处理时间...
这是速度所以值越高越好
通过Caffe处理这些卷积
这是你们用BNNS所得的结果
从平均来看 BNNS要快2.1倍
如果你们有更大的卷积
你们可以几乎达到快4倍的速度
好的　这就是所有的数字
现在让我来介绍下BNNS的构架
它是一个低级计算函数的集合
与BLAS十分相似这也是我们将其取名为BNNS的原因
它并不知道什么是神经网络
这意味着那是你们要知道的事
它只提供计算的部分
并且它只执行推测
事实上
我觉得 在设备上运行训练不合理
成本太高
你们会要有数以万计的图像和计算
这不会合适
那一般来说 推测会在线下完成如我所述
你们会在应用上执行推测
我们提供三个不同类别的层面
卷积层 池化层
和全面连接层
为什么？ 因为...
实际上 在现代的网络你们会花费百分之七十五的时间
于计算卷积
接下来是池化层
使用约百分之十五
全面连接层也会花费许多时间
但你们通常在网络的末端看见它
像在例子里见到的 只有两个
在末端的全面连接层
但这还是要花费许多时间
好的　现在我们了解了构架
我将细讲这三个不同类别的层面
和我们计算些什么还有如何通过API来创建它们
让我们从卷积层开始
这是一个卷积
它使用一个输入图像
一组权值 中间橘色的矩阵
然后输出图像里的每一个像素
是通过计算对每一组输入像素
与权值的的积
之后将结果相加得到你们上方的像素
你们要对每一个输出像素执行上述步骤
那如果你数下这是个四维的循环
因为你们要循环x和y
还有内核的维数
现实里 要比上述更复杂些
因为我们的输入不仅是一个图像
我们有一堆图像
那我们要复制权值
并知道在每一层我们在计算此卷积
然后再将它们相加
获取我们的输出像素
那现在循环就是五维的了
我在公式里添加了IC参数
这其实不是我们要计算的
因为我们还要有个输出堆栈
那实际上 我们在卷积里是在做这样的计算
我们重复这个多次每一次为一个输出层
那现在我们有个六维的循环
这意味着 即使每个维度都很小
像在这个例子里我们没有大于264的
这的确很小 但你们将它们相乘
你们会有几十亿的操作
这相当于几十毫秒的计算量
那对大很多的整个网络来讲
你们会有数以兆计的浮点运算操作
这相当于几秒的CPU时间
好的　一个在卷积层的计算
怎样通过BNNS来实现？
那首先 你们要描述你们的输入堆栈
你们要指定图像的尺寸
通道数
还有在内存里的分层
包括两行之间的增量和两层面间的增量
还有很重要的是
他们的储存类型
举例 我们使用32位浮点数或甚至64位浮点数
在神经网络里我们无需这样的精确度
一般人们会用16位浮点数
那很好 因为这会削减一半的储存空间
那本来20兆字节 我们只需10
如果你们能用整数8位的整数
那你们只需5兆字节
同样 一般你们的输出也无需任何精确度
所以 你们可以使用与输入相同的类型
你们需要对输出堆栈作相同的设定
然后 你们要描述卷积自身
这包括内核的尺寸
对输入的0填充
x和y在循环里的增幅
还有 你们要重复
输入和输出的通道数还有权值
那是之前中间橘色的部分
列出权值 同样你们可以设置不同的
储存类型给权值
一般你们将其设定为16位或8位
因为那可以降低内存使用和储存空间
当你们完成了这些
你们能用这个函数来创建卷积筛选器
你们告诉它 这是我的输入堆栈
那是我的输出堆栈那是我的卷积 创建一个筛选器
你会获取一个筛选器对象然后用它
对你们的数据应用卷积
在你们使用完它之后
你们调用销毁筛选器
来移除它并释放资源
以上就是关于卷积层的内容
现在 让我们来看下池化层
池化要比卷积简单些
要计算一个输出像素
你们要使用一组输入像素
然后取最大的平均值
这就是你们的结果
你们要对所有通道的所有像素重复这样的计算
这就是这公式所形容的
同样 为池化层创建一个筛选器
你们要描述输入和输出堆栈
与之前一样你们也要描述
池化层自身
同样 包括内核尺寸 填充 增幅
这里没有权值
那要使用哪个函数来计算输出
使用最大平均
在你们完成这些后你们就可以创建筛选器
获得一个和之前相似的筛选器对象
最后我们支持的层面是全面连接层
它尽管被称为全面连接层这里有个隐藏的矩阵积
作为输入你们有一个向量然后你们要将它与一个矩阵相乘
加入向量偏量然后获取你们的输出
就是求个矩阵的积
这里 你们的向量里没有图像
所以 你们要描述向量 它的大小
与数据对应并且你们要指定使用的类型
用于储存这些值 你们可以使用32或16位浮点数或整数
然后你们要通过矩阵的尺寸来描述这个层面自身
和矩阵的系数
偏量不在演示稿里但你们有偏量
之后 你们可以创建一个卷积筛选器
同样与之前的筛选器相似
接下来是怎样应用筛选器
你们将输入数据当作输出数据
和你们的筛选器你们有两个应用它们的函数
叫作筛选器应用如果你们只有一对输入和输出
如果你们有很多对
你们要调用筛选器批量应用
你们告诉它对数
并且怎样从一对到另一对
就是怎样在内存里迈进
好的 这些就是关于BNNS的内容让我们总结下
BNNS是一组针对神经网络计算的低级函数
很低　我们着重于计算我们完善它
我们提高它的处理速度
但它不知道什么是神经网络
它只针对于计算
我们优化它让它变得更快 更省能源
最主要的是他支持各种数据类型
以上就是BNNS的内容
接下来 Quadrature
我们收到请求...
许多人要我们开发一个用于求数值积分的库
那 这就是
好 那还记得你们在学校里学的
它能计算一个函数在区间a b上的积分
也就是在曲线和轴之间绿色的部分
那要使用这个你们首先要描述函数
你们要提供一个回调
我们做的改动之一与之前的
旧的库里不一样的是
回调接收一组点并求值
通常当你们计算积分
你们要在许多点上计算函数值
如果你们有一个向量化的回调能提高速度 那很好
你们可以使其更快通过使用这个多x的回调
它会通过x递给你们多个值
你们填入每一个对应的y的值通过计算f(xi)
这就是你们的函数然后要告诉它如何计算积分
那我们提供了三个计算积分的方法
它们有不同的的复杂度和运行时间
有些还可以积分至无限
你们可以在Quadrature标头找到更多的细节
你们也要指定输出的误差
和细分区间的最大数量
用于计算结果
然后你们将它递入integrate函数
你们还要告诉函数 a和b
你们也要递入一个点用于接收误差
它被称为估计误差
它会在结果里返回估计误差
和状态我们接受计算的状态
因为如果你要求一个很低的误差
有时无法被转换
那我们可以在状态里看到
这就是Quadrature所有内容
现在让我请Steve上台
他会来讲下关于simd的新添项
十分感谢 Eric
我是Steve Canon
我与Eric一起在向量与数值团队工作
Eric刚才将你们带回了学微积分的日子里
我现在将带你们前进些
来到线性代数
我们有这样一个很有用的模块叫simd
它能提供几何操作和向量操作
针对C、Objective-C、C++和Swift
它很好地对应了Metal着色语言
它能与SceneKit和Model I/O紧密结合
还有各种图形的库
如果你们在写向量相关的代码来执行
小型的3x3、4x4之类的线性代数的操作
这个库就是你们想要的你们就不用去自己写了
我们有大部分你们想要的
如果没有 可以请求我们添加它
它十分的快 让我们来细看
那有些什么？
我们有一大堆类型
有浮点数的向量和双精确度的向量
有带符号和不带符号的整数像2、3和4
我们还有相同尺寸的浮点数和双精确度的矩阵
这些只是在所有语言里都有的
在C、C++和Objective-C里
还有其它许多类型
那些会对你们写自己泛型的向量代码很有用
但我将着重于共有的子集
在所有的语言里和平台上在今天的讲座里
显然 我们还有类型相关的操作
有一般的算术操作
用于向量和矩阵
还有我们所熟悉的几何和着色函数
若你们有过任何着色编程的经验
大多数你们想用的 这里都有
我现在来展示个小型的例子
这是一个相同的函数被用三种语言编写
有Objective-C在最上面有C++在中间
Swift在底部
你们可以看到模版
在各个语言之间有些不同
只是因为函数声明在这些语言之间有所不同
但如果我们注意实际计算的部分
在各语言里 基本上都一样
同时 它也很对应
你们在数学里表达的方式
不会有许多奇怪的函数调用
你们也不用写for循环之类的
你们能自然流畅地写你们的代码
我们替你们翻译
编写变得友好和简单
这用Metal代码写看起来也一样
那这里凑巧已经有了reflect函数
在库里面
那你们就不用自己编写了
在各种语言之间调用函数像很多在model I/O里的
能通过使用接受这些类型的Objective-C API
很不错
向量类型是编译器的扩展
在C、Objective-C和C++里
在Swift里它们被定义为structs
但编译器知道如何为你们映射它们
所以 你们根本不用做任何事
这里有个简单的例子
若我有个Objective-C的函数
我在这里调用某个对向量类型执行操作的函数
并且我想调用那个函数
通过Swift使用Swift向量类型
我可以成功的这么做
我无需做任何进阶的事
这些类型都有相同的布局
所以 没有转换开销之类的
相似的 对于矩阵
Swift的矩阵类型布局和
C、Objective-C和C++类型相匹配
那如果我要使用它们这里我有Swift
我来创建一个Swift的类型通过C的类型
我所要做的就是使用init函数
很好用
没有任何的计算开销
就好像 不知不觉地改变了类型
相似的 我可以使用C的矩阵属性
如果我要通过C的类型调用C或Objective-C或C++的函数
我们今年有些新的东西我想向你们展示
我们有三个新的函数
simd orient和simd incircle还有simd insphere
它们已被重载为支持许多不一样的类型
和不同的长度 之类的
基本上所有在simd库里的都这样
所以 仅管我们只有三个新函数
实际上 有许多新东西
我会从orient开始讲
orient让我们回答这样的问题：
一组向量是否都朝向正面？
如果你们不记得线性代数意思是
它们是否遵循右手螺旋法则？
你们可能记得在物理里见过它
或 相等同的是否有正值的行列式？
如果在座的有数学专业的你们现在会抗议
一组向量是没有行列式的
我的意思是你们把它们
放到一个矩阵里
计算矩阵的行列式
是不是正的？
那我们为什么关心这个？
这很明显
你们能用这回答许多计算几何的问题
会很有用
比如 这个三角形是面朝我还是背朝我？
如果你们想象个四面体
有两个面朝着你们
也有两个面背着你们
如果你们在进行图形操作
知道面朝你们的面会是很有用的
因为那些是你们要处理的面
相似的 如果我有一个点和一条线我想回答这样个问题
点在不在线上或 如果不在 那它在线的哪侧？
我能用orient判断去回答那个问题
那 这看起来很简单的样子的确很简单
除了实际回答这个问题可能会很难
当点离线很近时我们会在下面细说
这里有个这样的例子
在显示的右侧 我有个平面
我会在平面上加些点
我有三个点a和b还有c
我将使用的simd orient查询它们的朝向
由于我们是通过逆时针的方向
从a到b到c
我们说它们是正朝向
这是在平面里对正朝向的定义
如果我们移动其中一点变成顺时针方向
现在就是负朝向了
那如果我移动点c让它正好在a和b之间的线上
那它们共线 朝向是0
或许 你们会说它是虚的
判定点是否正好在线上一般是件很难的事
特别是利用浮点数的坐标
因为朝向数值的不稳定性
由于浮点数的取舍
如果行列式的结果接近0
你们很有可能得到一个错误的符号
对于一些算法来说这无关紧要
但对于其它算法你们可能会遇到无法收敛的情况
或 当使用它时你们也许会获得错误的的结果
像在碰撞检测之类的情况里
能回答这个问题变得很重要
还有像使用三角网格建立模型之类的
这会是个重要的问题要求有准确的答案
让我们来看个难回答的例子
我在平面里建立两个向量u和v
它们几乎相同
它们只有一点点的不同
我在右侧将它们放大了很多倍
那样你们能看见它们的不同
如果我将它们按真实比例来画它们会全部重叠
如果我们用通常的方式来计算朝向
我们会得到结果0因为浮点数的取舍
这是个简单的结果为0的例子
如果维度大于2x2
我们会得到一个完全错误的符号
不只是结果为0当它不应该是0时
但若我们使用simd orient函数
我们会得到一个很小的正数
是正确的结果这些是正朝向的
我要提醒的是不要诠释
这个极小的正数对任何情况都有意义
这不是一个行列式的值
有时候是行列式的值
但有时只是有个准确的符号
所以 我们这里真正关心的是这个数字的符号
那我们是怎么做到的？
这些我今天像你们展示的几何判定
都是使用自适应精度
我们计算至我们需要的位
来获取正确的结果
这让我们在大部分的时候能很快返回正确的结果
但如果我们要进一步
进行精确的计算为你们取得正确的结果
我们也可以这么做
你们可以相信这在你们代码里会给出正确答案
你们不用担心
Incircle很相似
我们在平面里取三点
那决定一个圆
你们会注意到它们是 正朝向的
围着圆　这很重要
如果我在圆里加个点 x
然后simd incircle能告诉我点是否在圆内
如在圆内 我得到个正值
如在圆上 我得到0
如在圆外 我得到个负值
insphere也是相同的
只是现在是三维的了
我需要四个维度来定义球体
我设定点x然后得到相应的结果
我向你们展示一个之前提过的例子
判断一个三角形的面是正对还是背对着你们
这里我有个简单的struct用来在Swift里代表三角形
三角形由三个点定义我把它们放一个集合里
我用这个判定IsFacing来告诉我
三角形是否面对相机
那通常你们的计算方式是
运用叉乘积来计算一个对三角形面的法向量
然后计算它与对着相机的向量的点积
如果值为正那三角形正对着相机
我们可以简化这些代码并准确计算结果
通过使用simd orient判定
那我的代码变简单了
它很快 还能给我正确的答案
这都是我想要的
这就是我们尝试着在Accelerate实现的
给予你们简单的东西
用于复杂的数学计算
那我们今天向你们展示了许多新的东西
我们有些全新的库
我们有BNNS用于神经网络
我们有Quadrature
我们还有些新的功能
simd里的orientation和incircle
这每一个新功能和库
都是为回应开发者的需求所添加的
所以 我们很想知道你们所想要的
通过我们能添加的东西能简化你们的计算工作
我们想给予你们简单的接口
它能让你们有效率地完成你们要做的事
我们今年还做了许多其它的事
在vImage里Eric在简介里带过的
我们有一组全套的几何操作用于交叉存取的色度平面
这绝对是最频繁的请求
我们在近年里所收到的
所以 我们很乐意地添加了它
如果你们不知道那是什么无需担心
但如果你们知道那你们会明白它的有用之处
我们还扩展了
vImage里的转换例程用于新的格式
这为许多你们或许听说过的关于深色的东西奠定了基础
所以这个对那来说很重要
我们提高了性能
针对vDSP里的交织复杂格式
通过FFT 我们支持交织和截面布局
复杂和虚的部分
要么被分开 要么放在一起
我们一般使用截面布局进行操作
我们推荐这么做但如果你们只有交织的数据
你们现在可以使用FFT它们很快
我们也提高了所有Level II BLAS操作性能
有些是由你们所见到的BNNS员工发起的
有些是我们所预见并跟进的机会
Accelerate里还有许多新的东西
许多改进了的东西
每当有新处理器发布我们一定会针对它们进行优化
我们想解决所有的那些低级计算细节
让你们能注重于编写高级算法
基于低级细节层面
让你们能达成你们想做的
总结下我们想成为你们一站式购物的地方
为计算的算法
我们能提供给你们的实现是准确
快速和节省能源的
并且我们会针对新硬件进行优化
当它们发布时这样你们就不用为此担心
如果你们想自己优化那我们有了新的芯片
你们就需要对其更新
如果你们交给我们来处理
那你们就不用担心了
继续提交你们的请求我们很高兴能收到它们
我们今天在实验室和你们许多人交谈了
我们已经得到了许多将来的请求
能将雷达归档我们想要这个功能
如果你们想见到更多相关信息这个讲座的连接在这里
我也推荐你们去看下前几年的讲座
有关于这些库的其它方面有用的细节
有两个很好的关于Metal的演讲
我高度推荐你们去看下昨天的演讲
特别是如果你们对这些感兴趣的话
十分感谢你们的到来