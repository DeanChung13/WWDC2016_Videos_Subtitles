Cocoa的新特性
上午好
我叫Ali Ozer
我和我的同事们
谢谢
我和我的同事Raleigh Ledet还有Taylor Kelly
来自Cocoa框架团队将给大家讲讲
今年Cocoa的新特性
我们的议程非常简单
首先 继AppKit和Foundation新特性
之后的API更新
关于API更新方面我想跟大家讲讲
我们主要有两类API更新
第一 由于新Swift API指南导致的API更新
第二 我们做的一些常用API改良
让我们开始吧
无论你昨天是否听过
今天上午 我们有关于Swift新API设计指南
并且这些指南包含Cocoa约定和实践
我不过是要提醒你这些东西是什么
使用清晰和一致性命名
追求流畅的使用大家都知道 调用的地方读起来
应该像英文短句命名增强
和不可变方法保持对应一致sort与sorted
append与appending还有避免缩写
这些都是我们多年来使用的主要指南
我们把它写成文档
在以前WWDC大会上我们也讲过
正如这次演讲你看到的一样
现在我们把这些指南做了更新
使用了Swift的特性 比如强类型
类型推断 还有重载
并且确保我们的API在Swift中能表现出来
我来讲下API中的一些关键不同点
由于这些改变的结果
一方面 我们消除了重复和不必要的单词
显然使我们的API更加敏捷
你昨天可能听了
昨天有个例子
如Chris Lattner关于“详情咨文”的部分
这里有另外一个例子contacts.arrayByAddingObject
比如这样的一个方法调用“数组”和
“对象”并不能真实反应这个调用
所以这个名字现在改成了contacts.adding(person)
在NSColor这个类上还有另外一个例子
NSColor.blueColor我们现在NSColor类上
Blue已经是一个颜色了
color这个单词其实在这调用中不需添加
所以在新的指南中
它将变成NSColor.blue
不过需要注意的是我们仍然追求清晰
这是NSColor另一方法NSColor.textColor
文本本质上不是一个颜色其实
谈论文本的颜色可能会产生混乱
文本是代表颜色的RGB值还是其它的？
所以在此案例中 我们没改变这个方法
还是作为NSColor.textColor
跟它之前一样
另外一些关键变化是类型的利用
这里有个例子document.readFromURL ofType
现在这个API将变成document.readFrom ofType
你会注意到我们移除了这个单词... URL
从我们的方法签名中
那是因为第一个参数的类型就是URL
根据类型推断Swift知道该如何去处理它
通过移除这个单词
其实在NSDocument上现有三个阅读方法
他们都准确的命名了同样一件事从ofType读取
并且它是作为第一个参数第一个参数的类型
URL 数据或者FileWrapper
把它们区分开来
现在这需要注意的一件事情就是利用
第一个参数
这里从此以后就被拉到了括号内
我们这样做是基于大量的案例
例如 当第一个参数表现成介词短语的一部分时
我们会把这个短语拉到括号内正如你这看到的一样
你可以从我们的API中看到大量这样的例子
可能大家也注意到第二个参数ofType
我们并没有把类型这个单词从API中移除
因为这个参数是一个字符串而且字符串是弱类型
我们其实要一个单词来描述它们的角色
而这里的角色就是我们打开的文件类型
所以我们在API中保留了类型这个单词
现在很多框架和标准库API都被改变了
基于这些新的指南
并且把Objective-CAPI映射到
Swift的输入者也使用了这些新指南
不过你可能会注意到有些API还需要进一步调教
我们已在些API中做了如textColor API
前面提到过的它是一个例外
若你在Swift中暴露Objective-C API
你可能需要使用一些
像NS Swift Name它可以让你覆盖默认的
输入者做的事情
大家知道移植器转换你的——
移植器可将你现有Swift 2代码
转换成Swift 3并且它还会帮你使用这些新命名
在你现有的代码中 当然
Swift API设计指南讨论
在此之前你可以
从视频中获取一些细节
关于这些指南和它们的影响
现在我们已经有很多常用的API改良
有些我们已经完成有一段时间了有些我们还将继续做
我们来快速过一下
可空性
去年我们已经在这方面做了很多
它通常用来声明是否有参数返回值
属性可以为空或者是否可选
今年我们一直在持续完善它
例如 该方法在10.11版本中标明
返回一个可选值
NSMenu中的addItem方法但在10.12版本中 它并没有标明
返回一个非可选值因为我们决定
它永远无法真正返回空值而且
最好由你的代码来反应出来更为适当
当然 也更简单一点
我们一直在改进属性把getter和setter对
转换成正规属性
今年我们同样在实际中使用了Swift的能力
来声明类中的属性
例如 这是NSWindow中的一个新属性
你会在后面的演讲中听到这个
allowsAutomaticWindowTabbing
这是在Swift中一个真实类中的属性
你还会注意到我们同样有能力
在Objective-C中做到这样
在Objective-C中你也可定义类属性
使用语法@property class
同样特性引入到了Objective-C中
这确实很酷
这有个Core Data的例子NSPersistentStoreCoordinator
在10.11版本中 它有这个方法registeredStoreTypes
现在它被定义成了类的属性
它是一个只读属性
所以它只有get方法正如你这里看到的一样
同样在Objective-C它也变成了类的属性 如你看到的一样
泛型我们把它应用到了
集合类中不过它们真的
不仅用于集合
它们还用于其它任何地方
我敢肯定 你已经意识到了
这里有一个Core DataNSFetchRequest的例子
这里是10.11版本中定义的方式非常简单
在10.12中 我们前进了一步
添加了一个ResultType类型参数
我们同样在其它一些API中添加了一些东西
如这execute方法
返回一个这种结果类型的数组
因此 这个用例现在就变成这个样了
你从一个管理对象获得请求
比如员工
然后往前继续执行它
现在返回值被自动推断为
一个员工数组
现在这个例子会是这样不过我们希望
在将来的版本中我们可以像这样表达得更干净
这确实很酷
所以从这两行编译器可以推断
返回类型是一个被管理了的对象数组
我们一直在改进枚举命名
来看一个我们在这方面已实施的例子NSColorPanelMode
变化是——这是一个Swift用例
你看它并非很吸引人
是因为.NSCrayonModeColorPanel非常冗长
变化就是我们把通用后缀拉到前面
变成前缀使得Swift里的名字
更清晰一点
你知道 出现这点的地方
用例就是.crayon
这是它之前的样子
这是它现在的样子 相当清晰
在枚举这一块
我们同样对字符串枚举做了改进
Swift支持字符串值的枚举
许多Cocoa API都会暴露一组字符串
无论打开或者关闭的API在我们的API中
我们来看一个字符串转换的例子
在Swift 2中我们有一堆全局常量
NSStringTransformLatinToGreek等等
有一个APIstringByApplyingTransform
把这些字符串作为它的第一个参数
在Swift 3中我们添加了一种新类型
叫StringTransform还有一个扩展我们给它定义多种值
比如LatinToGreek
有API叫applyingTransform
它第一个参数现在是官方的StringTransform
所以这个字符串参数现在是StringTransform
类型更加安全
现在 注意这里有一个开放式枚举
这里面你可以定义你自己的值
我演示下如何做到这点
你可以继续添加一个扩展
到StringTransform然后定义你自己的类型
现在这里的值就是ICU库接受的值
用于做转换
你可以使用任何有效的ICU提供的ID
它转换成一个ICU拥有的需要出版的东西
这些我们API中并不暴露
所以 你可以定义你自己的出版转换
然后把它传给API如果它是一个内置的
字符串枚举同样在Objective-C可以使用
通过使用这两个宏给开放或者封闭式的集合
这是添加字符串转换声明的方式
在10.11中 那是我们已有的方式
在10.12中 有一个新字符串转换类型
被定义成NS ExtensibleString Enum
我们同样使用了Swift能力来改进
在一个类型中嵌套声明另一种类型
看一个NSData的例子
我们有一个可选的集合NSDataWritingOptions
NSData类有一个APIwriteToURL使用了这个值
在Swift 3中它变成NSData类
嵌套了WritingOptions如你在此所见
使用这个API实际上是指向
WritingOptions显然是更加清晰更好作用域
除了这些嵌套的改变你可能注意到一些其它的东西
那就是类型的变化
你可能注意到我们现在提供了一个空集合默认值
大多数我们需要传入可选值时
意味着我们不在需要传入可选参数了
你可能还注意到这里NSURL变成了URL
你可能已听过这个了
不过我们后面还会有关于它的更多谈论
现在 我离开舞台前的最后一个主题是...
noescape
好的 noescape声明
一个闭包的执行在函数调用后将不会退出
我的意思是什么？
这里有一个NSCollection view的方法performBatchUpdates
它有两个闭包参数
你可能注意到了第一个参数标记为noescape
意思是这个闭包的执行
将完成执行
在API performBatchUpdates方法返回之前
第二个参数没有标记为noescape
意思是这个闭包的执行将可能发生在
函数返回之后
所以 这对你来说是一个好的暗示
同样对编译器也是一个好的暗示
这个技巧同样适用于Objective-C
我们可以使用NS NOESCAPE来装饰闭包
以达到同样的效果
这些就是我们常用API变化的概览
现在大家拥有的版本中
我们已完成了所有想要做的事情
将会有一些字符串枚举变化
类属性变化将会在其它版本中出现
我们将会应用到更多的API中
接着我们来谈谈关于AppKit
我将给大家邀请RaleighLedet上台给大家讲讲
谢谢
谢谢 Ali
大家 上午好
大家看到 在过去的一年里我们在AppKit上下了很多功夫
现在我们深入一下来讲讲窗口捕捉
当你在macOS Sierra下拖动一个窗口
当你靠向一个边缘的时候将产生边缘粘连
还有与另外一个窗口的顶部对齐
甚至是在缩放大小的时候
所以现在将窗口对齐就简单多了
或者以你想要的方式来缩放大小
我们付出很多努力在这里提供摸索
来确保我们只提供捕捉行为
第一时间推测你想对窗口做些什么
在你的应用中获取捕捉行为的方式就是
让系统来为你处理窗口的拖拽
如果你自己跟踪鼠标
然后手动控制窗口的位置
你将会绕开窗口捕捉我们会恰当地放置窗口
在这里你要求我们放置它正如我们之前的发布
如在keynote上看到的我们现有了窗口tabbing
这是一个TextEdit的例子有三个文档tab打开
关于窗口tabbing其实他们就是多个窗口
所以此例中有三个tab的TextEdit
其实就是三个不同NS窗口支持
所以我们做的只是对这些当中的每一个窗口
只将一个tab设置可见就认为是可见
若你检查NSWindow的.visible属性
它将返回真
只不过仅有可见的tab才正真被渲染到屏幕上
我们将其它窗口隐藏到窗口服务器级别
所以它们没有被渲染也不占用任何资源
而且我们自动处理这些过程
那如何给窗口添加一个New Tab呢？
创建一个新的窗口然后将它排到前面
然后我们将会继续恰当地为你创建一个tab
然后放置在窗口中
如果你要移除一个tab将你的窗口过滤掉
然后我们将继续为你移除掉tab
这些都是自动玩完成的
现在如果用户缩放了窗口我们将仅仅
缩放与当前激活的tab相关联的窗口
我们不会花费时间
去处理其它窗口当用户并不想切换到它们的时候
不过当用户要切换到其它tab中的某一个时
在那时AppKit将会继续
适当的缩放窗口重新渲染它
然后将窗口服务器等级的隐藏属性修改
所以用户得到的是无缝的体验
一个窗口拥有多个tab尽管在这背后
我们只是处理了三个窗口
我想谈一些大家需要做的东西
当你准备给你的应用采取tab
这依赖于你的应用
是什么类型
如果你有一个例如类似基于NSDocument一样的应用
或者non-NSDocument的应用
你需要做些什么
如果你已经存在一个tab实现
我讲围绕这一节来讲解用一些大家可以使用的API
在你的应用中去定制tab
若是基于NSDocument的应用你不需要做什么
这基本上是自动的其实此处TextEdit
我们几乎完全是修改了0行代码在TextEdit上
它完全支持标签而且在这个方框下运行的非常正确
若是基于non-NSDocument的应用它大部分是自动的
不过你可能需要做的是开启
New Tab按钮在你的应用里
New Tab按钮在这里是一个附加的按钮
在所有tab的右边
要开启这个按钮 你需要实现newWindowForTab NSResponder
在你的NSWindow子类中重写
或者在响应链中某个更高的地方
例如NSWindow代理
或者NSWindow控制器或者NSWindow文档
如果你在其中任何一个地方实现了重写
AppKit将会看到它并且将继续
自动为你开启New Tab按钮
如果你有自己已存在的tab实现
你可能需要禁用
AppKit的自动窗口tabbing行为
这里是这个类的属性
NSWindow的allowsAutomaticWindowTabbing
这是一个类属性在你的应用启动之初
叫做NSWindow
allowsAutomaticWindowTabbing等于假
这里将关闭AppKit的tabbing行为
然后你将可以继续使用你自己的tabbing实现了
这里非常重要你需要在应用启动
且开始将窗口展示出来前调用它
你只需要在你的应用中添加tab支持
它大多数情况下是自动工作的
不过这里有些API你可以用来自定义一些事情
首先 用户可以定义一些行为
指定在系统中他们想要的tabbing方式
且他们可以在系统设置中来这么做
你获取用户设置
通过在NSWindow上用户tabbing设置的类属性
它们可以设置为手动始终或者仅仅tabbing
在它们全屏的时候
在剩下的这些属性和函数中
我讲给大家讨论下实例属性以及
NSWindow的函数
一旦你有了一个NSWindow实例
你可将它设置为tabbing模式
默认情况下这个tabbing模式是自动的
也就是说我们将使用用户的tabbing设置
不过你可以将它设置为首选或者禁用
取决于你的窗口类型和你的需要
当我们把窗口分组到一起变成一组tab的时候
我们只想把类似的窗口分组到一起我们判断的方式就是
通过查看tabbing的标识符
若有相同tabbing标识符窗口
我们就可以把它们以tab的方式分组到一起
默认情况下 AppKit会使用一种启发式搜索并且
从你的利益角度出发生成一个tabbing标识符
我们检查这些东西例如窗口的子类名称
窗口的属性 文档
还有一些其它各种属性然后尝试生成
适当的tabbing标识符
这种方式运作得非常好
如果它在你的应用中运作不够好的话
或者你想要更多的控制它
你可以手动设置tabbing标识符
AppKit将会遵守它
你无法获取到哪些窗口被分组到了一起
通过tab中的某个窗口实例
获取所有tab窗口
注意它会返回一个可选数组
它可返回空 而且如果tab栏不显示它必然返回空值
这里根本没有关联的tab
你可以手动添加其它的tab窗口将它们分组到一起
因为这些都是窗口这正好说明了API名称
当你添加一个tab窗口而不是添加一个tab自身
添加了tab窗口之后可以使用
NSWindowOrderingMode进行排序它将使tab跟其他
tab关联起来进行排序
AppKit会给菜单添加一些新项
也就是说在窗口菜单下添加了一些项目
以此来帮助用户在tab之前进行导航
比如选择下一个或者上一个tab
这只是NSWindow上的IB动作
而且你也可以基于你自己的用户界面元素来编写它们
例如 你可能想要一个按钮来切换tab栏
你可以将那个按钮连接到窗口
toggleTabBar IBAction
NSWindow将为你处理切换tab栏
上面就是关于窗口捕获和tabbing的所有内容
让我们继续来讲下关于右-左的支持
我们在AppKit上做了很多工作
来加强现有的右-左的支持
大家这里看到的截图是运行在阿拉伯语中的TextEdit
标题栏是翻转过来的
滚动条被放到了另外一边
甚至New Tab按钮也放到另一边
并且所有的小属性
还有各式各样的标题栏按钮都翻转了
非常符合右-左用户的期望
我想从三个不同的级别来讨论从右-左的支持
系统级别会发生什么当用户设置了他们的本地化
在系统设置面板中
它会对应用产生什么影响
你的应用会表现成什么样
依赖于你对本地化的支持
然后下降到内容层面
就是在NSView级别
如果需要的话你可以进一步重写一些东西
直接使用用户界面布局
然后我将会围绕着一节
通过一个非常不错的开发技巧来帮助你
给你的应用提供右-左的支持
首先 让我们从系统层面开始讲
这里的关键点是一致性
我们需要保持一致性的表现
在用户设置为右-左的系统中
所以不管你支持哪种本地化
在你的应用中我们想要让所有菜单栏
在一个右-左的系统中从Apple这个菜单项开始
在这里放在其它的菜单项的右边
这里同样适用窗口的标题栏
所以交通指示灯将翻转到另一边
所有不在内容区域的东西
都将翻转到另一边
不管你的应用中支持的是何种本地化
给用户提供一致性的体验
现在降级到应用层面我们将不能自动这么做了
因为我们不想打断任何
你的应用中可能有的设定
所以强烈的建议你添加右-左的支持
在你的应用中添加犹太人和阿拉伯人本地化
一旦在有了这些本地化
在应用层面
所有的滚动区域将自动无视垂直滚动和标尺
NSBrowser将自动翻转
在这个层面 我们同样需要一致性
所以不管何种用户界面布局方向的任何内容区域
我们都想要滚动条保持一致性都在同一侧
下降到内容层面
默认情况下用户界面布局方向将会匹配
你的是应用如何设置的
在大部分情况下这正是你所期望的
不过有一些例外
也就是说 如果你有一些类似媒体控件
或者空间控件 或者时间控件
它们始终是一样的布局从左往右
对于左-右用户和右-左用户来说都是这样
所以你可以修改用户界面布局方向
并且下面这些AppKit中的控件都支持那样做
所以自动布局将不会在这个阶段中
不过在即将到来第二阶段中我们将开始使用父容器
来决定哪边是头哪边是尾
版本中已有的表格视图
和outline view会适当的调整它们的列
NSPageController可切换动画且这个列表还在继续
我们在AppKit中有很多对右-左的支持
让AppKit做繁琐的工作
给你的用户提供一个右-左更好的体验
我答应过给大家一个开发技巧
我已使用这个技巧一整年了
我发现它难以置信的有用
在Xcode中 你可以修改项目体质
在Options选项中修改你的应用的语言
设置成右-左虚拟语言
这可以让你的应用
在开发语言中运行对我来说它就是英语
大家看到这里TextEdit运行在英语当中
但是它在所有控件中使用了右-左翻转
所以窗口标题栏被翻转了
滚动区域的滚动条翻转了
大家看到所有小的子项和
标题栏所有按钮都翻转了
所以这是一个非常简单的方式让你获得右-左的支持
并且确保所有的东西在你的原生语言下运行正确
在这里仅仅涵盖了我们在AppKit中做的事
还有很多东西可以讨论
在“国际化用户界面新特性”的演讲中
在星期五上午9:00于Nob Hill举行
他们涵盖了更多东西在桌面方面
比如WebKit 文本布局资源管理
他们还包含iOS上右-左的支持
强烈推荐大家也关注下这个讨论
让我们来讨论下promise拖拽
若你还不熟悉promise拖拽就是
当用户从你的应用中拖拽一个文件
但是在磁盘上其实并没有这个文件
你只是许下个promise
你将会写入到用户想要释放的地方
这就是一个文件promise拖拽
从一开始我们就在OS X中支持promise拖拽
在macOS Sierra中我们升级了文件promise拖拽
将会更加现代化使用NSFilePromiseProvider
和NSFilePromiseReceiver对象
现在这些对象允许文件promise拖拽
来支持拖放群集
若你对拖放群集还不熟悉
其实就是当你拖放多个元素时
它们会形成中间拖动
这依赖于目标应用
将会对它们做什么
使用这两类的文件promise拖拽可支持拖拽群集
它们基于UTI
它们完全是尊从writer和reader样板
即你可使用NSPasteboard上基于元素的API
同这些对象一起工作
如果可能的话它们会适配文件
所以你不用担心文件的适配
我们会自动包装文件适配的读
和写 从你的利益角度出发
并且反过来它们也是兼容的
它们反过来也兼容基于无元素的文件promise API
也就是说你只需要关心一个API
如果你实现了一个NSFilePromiseProvider
你现可提供文件promise
给任何使用新NSFilePromiseReceiver API的人
或者那些在现有应用中
使用基于无元素API的人
他们同样可以接受你的promise文件
就像NSFilePromiseReceiver一样
你也可以接受文件promise
从任何使用NSFilePromiseProvider的地方
或者使用基于无元素API的地方
所以如果你想在拖拽中提供一个文件promise
当用户开始拖动时你需要创建一个promise
通过创建一个NSFilePromiseProvider实例来实现
如果你想要给每个promise的文件
都创建一个实例
你需要提供一个NSFilePromiseProvider代理
这个代理将负担承重的任务
把文件写入到磁盘上
同时 目的地将调用这个promise
你将会被询问提供目的地的文件名称
现在你知道目的地在哪里了
你就可以弄清楚文件名了
不过请不要在这个时候写入文件因为它还没被包装成
文件适配而且我们发现
拖动中还有一些其它项目
当拖动结束之后
我们知道了所有需要知道的信息
再来调用代理 然后询问你promise要写入到的URL
并提供一个完成的处理器
在这个时候 它们都包装成了文件适配写入
然后只需要写入文件到提供的URL
然后调用完成的处理器让文件适配知道
你已经完成了写入
若你想要接受一个文件promise
你首先需要注册view
在你想要允许任务发生的地方
这通常由view.registerforDraggedTypes完成
你需要添加的拖动类型就是NSFilePromiseReceiver
readableDrappedTypes
这非常简单
现在一旦用户拖动一个文件promise到这个view上
你将会得到拖拽消息
然后你想得到promise对象
可以使用基于元素样板API
访问这个对象的forClassesNSFilePromiseReceiver.self来获得访问
你将会得到一个NSFilePromiseReceiver对象的数组
你但你有了NSFilePromiseReceiver对象
你可以调用这个promise里面的
通过调用receivePromisedFilesatDestination options
operationQueue reader
然后它将迅速的从这个函数返回
reader块还没有被调用
我们将在后面返回来调用
一但源文件写入所有的promise
现在我们继续返回过去调用reader块
在指定的操作队列上
现在 这点非常重要你没有指定NSMainOperationQueue
给这个操作队列或者你将
打断你的应用在等待源进程
完成文件写入的时候
这过程需要一些时间
而且你不想应用被打断在这整个过程中
这就是关于文件promise拖拽所做的事
它有更简单的的API可以使用而且可以同拖拽群集工作
还可以通过样板支持基于元素API
让我们继续来讲下我们做的一些改进
针对各种容器视图
我们从集合视图开始
对于集合视图 预想你可以滚动
内容可以在任何背景视图上滚动
这就是你可能已有的
现在你可以告诉背景视图跟随上下文一起滚动
通过设置backgroundViewsScrollsWithContent为真
它们将会一起滚动
我们同样已经支持可选浮动header和footer
你可以把这里的文档header设为浮动
然后内容区域滚动将会在它下面
使用NSCollectionView的浮动布局这将非常的简单
只需要设置sectionHeadersPinToVisible为真
或者sectionFootersPinToVisibleBounds为真
如果你想要footer为浮动
NSCollectionView将会
适当的处理 基于你的行为
你也可以可选折叠任何部分
到一个单独的水平的可滚动行
正如你这里看到的一样而且还有少许旋转效果
当你水平滚动的时候
通过toggleSectionCollapse IBAction可以非常简单地做到这点
在NSCollectionView上
现在这个消息的发送者需要是一个视图
在你的区块header或者一个继承自区块header的视图
NSCollectionView才能准确的确定
哪个区块需要切换折叠
一旦在header或者派生的视图中有按钮
你需要将区块的header实现NSCollectionView
SectionHeaderView协议它仅仅只是
把你的按钮链接到sectionCollapseButton的插口
然后NSCollectionView将可以可以找到你的按钮
并且自动隐藏和显示它
依赖于内部有足够的内容
在这个区块来折叠
NSTableView将重绘所有的子视图
当索引值为-1
负1是我们的特殊数表示
扩展你表格中的所有行和列
因此 当你调用reloadData
并且索引包含负1时
我们将替你自动重载所有行
这个仅从10.12版本开始支持
因此在10.12或更新版本中
NSOutlineView也将自动加载它的表格
相关联的也会重新加载
另外 OutlineView现在体验更好
通过数据源返回
这个功能非常有用 但若你的应用真想
保持我们原有的刷新行为
你可以设置stronglyReferencesItems为假
你就可以使用10.12之前版本的行为
然后 Taylor Kelly向前
来和你谈谈网格视图
谢谢Raleigh
首先我想谈NSGridView视图
这是和NSStackView相似的一个新视图类
我们实现了创建和管理
约束你的布局
但如同StackView创建线性布局显示
NSGridView创建相交的行和列
你在偏向窗格的UI中会经常看到
是的 这些不同的行列
会自动调整
标准的定义
它支持基线 头部 底部 对齐
它支持GridView设置整体间距
作为每个行列之间的间距
类似电子表格应用 它支持单元格合并
因此 一个单一的视图可以跨越多行或多个列
如同分隔符做的一样
它还支持动态隐藏行和列的显示
不改变GridView结构的情况下
例如 当我们点击这个复选框
我们可能想隐藏显示偏好按钮
我们可以通过获取包含按钮的行
并设置其隐藏属性为true
GridView将自动刷新界面
还有几个可以改进我们自动布局
一个是清理AppKit布局周期
视图不在需要使用布局
或者不需要层的参与
通过设置needslayout为true
下一个界面显示时 它会调用布局
这样布局显示时不再被调用两次
对于层的支持我们减少了隐性脏布局
因此减少布局
这个实现方式很好
但是 如果你遇到布局
在你调用时没有响应
确认你设置了needsLayout
所有这一切都使它更容易成为你的子视图手动布局
所以你可以重写布局而不需要调用super
计算子视图宽架 设置并返回
你要确保没有
将自己的视图和其他视图混淆
若在视图布局中发生这样的情况
它设置自己的框架或父类的框架
这将弄脏视图的布局并导致额外的布局
如果一直存在这就是我们说的布局环
这个很难去调试
所以在macOS 和 iOS
我们已经介绍了新的布局环的调试
所以你可以更好的理解哪儿布局有问题和为什么
布局的改变添加的API到父类
因此 你可以知道父类的含义
即使不使用父类接口你也需要申请
除此之外时间现在是可以为null
因此 如果你正在使用该属性一定要处理的是零的情况
另外 接口支持新功能
用于自动布局的添加
因此在一个单独文件或
在一个单一的视图层次结构中你可以使用常量
这是非常好的
NSGridView布局环调试的详细内容
在周五“自动布局有何新特性”中讲解
在这里我想谈谈颜色
特别是全范围的颜色
所以sRGB是一个漂亮的流行色彩空间
通常是使用隐含的颜色代替未指定的空间
我们大部分的显示器有一个sRGB色域
新的5K iMac和iPad Pro 9.7英寸屏
都包含这些更新的显示器可以显示更生动的颜色
具体地说 他们正在使用P3色域
比起sRGB色域
它可以显示很多更充满活力的绿色和红色
所以你的应用可以显示照片
更精确的颜色可以展示这些更具活力的
颜色让界面看上去更加真实
举颜色的一个例子绿色
正好是Pantone的2013年度色
它超出了sRGB范围
所以以前显示器不能显示这个颜色
但是使用P3可以完美显示出来
你的照片也包含这些更鲜艳的颜色
特别是红色和橙色
讽刺的是 投影机甚至在家里的电视
其实不去显示这些颜色
所以你不得不承认它们很特别
如果你想用这些颜色
有新的色彩空间displayP3它让你可以拥有
这包含sRGB和其它的色彩空间
NSColor中有新构造方法displayP3红色 绿色 蓝色 阿尔法值
它允许你在颜色空间中创建一个颜色
UIColor具有相同的构造函数具有相同的效果
另一种方式具有广泛的颜色
采用的方式我们调用扩展范围sRGB
所以用色彩空间时你通常被限制
元件值从0到1
且你可在色域范围内选择任何颜色
比如蓝色 通过这些值
但你不能代表一个颜色这就是色域之外
所以sRGB不能代表这个绿色的颜色
扩展范围sRGB使用相同的基色
和相同的白色点为sRGB但允许部件
采取值小于0或大于1
所以它可以代表这个绿色通过一个负的红色和蓝色的值
和一个大于1的绿色值
这恰好也是P3绿色的原始值 因此
扩展范围的sRGB你可以代表全范围
你需要的颜色在显示器上
这也有一个彩色空间extendedSRGB
和现有的NSColor
以及UIColor已经在使用的函数
先前提供的颜色使用sRGB
现在将接受较少的值小于0或大于1
给你回一个扩展范围的sRGB色
这是非常方便的
考虑一个重要的事
这些更广泛的颜色色域颜色深度
所以sRGB理论上可以表示在其色域任何颜色
但每比特8位
你也只能解决数量有限的 是的
这里的黑色空间只是非寻址颜色
使用8位每组件
当你扩大色域 增加该色域的音量
但保持相同的位深度
你是可寻址的色密度下降
你能够指定的颜色丢失精度
这就是为何我们建议
工作时这些更广泛的色彩空间中 如P3
你用16位比特使用每个组件
它内存和存储数量翻倍
但给你成倍增长更多可寻址颜色
因此 我们认为 权衡是值得的
需要使用什么API考虑到这些更深的颜色
好了 好消息是大多数都是自动的
所以NSWindow将自动使用较深的支持存储
有了这些更高的位深度宽色域显示
即使你拖动它在整个屏幕
如果你需要一个方法明确控制
你可以设置深度限制属性为你选的值
视图和层内窗口会自动
继承该位深度唯一的例外是OpenGL视图
你应该用相关的像素格式的API
在macOS和iOS的CALayer有一新内容格式的属性
允许你再次明确控制它使用比特深度
所以这是你可以利用的优势在你的应用广泛的颜色
我们也提高了部分系统性能 能够更好的利用
这些广泛的色彩
一个例子是彩色面板
所以 在iMac左边
颜色盘会显示
开始
它实际上会显示和允许从全方位的P3的颜色
超出sRGB正常颜色轮也会允许
然而 你也能右键单击颜色轮
并明确选择工作区色彩空间
因此 即使在这些以前的显示器不能使P3的颜色
你仍然可以允许选则他们
RGB颜色选择器始终允许你
选择颜色替换你工作空间
但它也允许你改变表示
从8位值从0到255到浮点数
所以你又能得到精度更高
工作时有了这些更广泛的色彩空间
这些颜色面板的变化是所有的应用程序完全免费
没有任何的接口需要调用
工作具有广泛的颜色星期四的谈话涵盖更多
如目录支持WebKit支持
我建议你更新出来如果这些东西使你感兴趣
因此 下一个主题是状况项目改进
所以状态项的事情
底部的菜单栏
这些是先前的使用要求
私有API来实现但现在大多是免费的
首先是排序
现在你可以命令点击拖动任何项目排序它
内部和外部的系统项目
你也可以用键盘焦点转到您的项
甚至激活菜单项内
这一切最好的部分 这是完全自动的
没有API选择或链接检查
所以所有的项目都是命令点击拖动重新排序
和任何菜单设置的项目将参与键盘导航
如果他们有一个自定义的目标活动他们会被跳过
其次是隐藏和去除
您现在可以命令单击并将一个项目从状态栏中拖动
移除通知该更改
甚至编程恢复
不同的排序这就需要选择
没有状态项目将自动移除
你可以通过设置现状项目的行为
包含removalAllowed
你可以编程读/设置
甚至得到KVO通知这个变化的利用可见属性
如果你的应用是一个状态栏的应用
它只表示意义是在状态栏图标
有无文件图标或其他的方式要退出它 你可以设置它
自动退出清除
通过设置terminationOnRemoval行为
所有这一切都会为你保存位置
和可见的状态所以你不必担心
为了保持使用自动保存名字
我们自动生成这种基于项目指标
你在你的应用程序中创建的
但如果你创造它们一些非确定性的顺序
或者只是想拥有更明确的控制
您可以设置自动保存的名称你选择一些标识符
这样的状况项目改进
很多都是免费的和一点点的调整
你真的可以使他们在应用程序中更好使用
下一个是控件构造函数
所以这些新的构造函数在现有NS控制
这使它很容易得到标准的外观和感觉
例如 不同类型的按钮分段控制
图像视图 滑块标签和文本字段
所以这些类型的已有的
Interface Builder对象库
这使得它很容易使用盒子的性能
他们跟标准的系统设置合适的字体大小 颜色和文本颜色
他们支持不同的情境
浅绿色充满动感的标签看起来很棒
甚至盒子中充满动感的暗色
没有额外的安装
这将对你代码起何作用我想向你举例说明
这是创建一个复选框前
需设置相当多的属性
不幸的是我们真的只关心其中的三个
标题 目标和行动
复选框 以及标题 目标行动 剩下的
这是非常好的
更多的一点 哦
等着
所以这就是创造一个静态标签
只是屏幕上的一些文字
而在这里 我们关心的只是字符串值
有文字的标签 又是这样的
所以 这非常棒
它是从盒子里出来的
它出来的盒子可以用带或不带自动布局
所以 如果你要定位约束
你还需要设置translatesAutoresizingMask
IntoConstaints为假像你其他的视图一样
所以如果你已经有了类做这些事情
我们仍然建议移动到这些新的系统
因为你会确保你的控制有标准的外观
感觉现在和未来
我最后想谈的是API的改进
我只覆盖了一些这些适用于我们所有的框架
这些申请AppKit
我还想谈谈适用于AppKit的另外两点
首先是弱委托
所以我们已经添加了新的归零弱委托的支持
对于不同的代表和数据不同类别的源
所以你不再需要明确这些属性
当引用们被释放
它仍然支持非弱引用的对象
在这种情况下 它会回到原有的分配
或不安全的 不保留语义
我们也经历过并确定了
我们所有的类显式并宣布其指定的初始化
这些是和他们以前一样有效的
但现在只是在实际的接口中声明
有一个例外NSCursor
所以 如果你是子NSCursor请看发行说明
你应该正确处理
与所有的新声明指定的初始化
你应该确保你是正确的在你的类的处理
所以如果你以前没有
你可能会有这些错误问题
这也许是微妙的错误
在Objective-C现在看到的编译警告
在Swift 你要去获得建立失败
所以你要确保你妥善处理这些不同的情况
这是AppKit最新内容
在这一点上我想翻过去
有请Ali讲述“Foundation有何新特性”
谢谢你 Taylor
所以这里有一些东西这是新基础
现在进入主题
现在你看到了NSURL成为URL
我想我们昨天也谈到了一点
我们把NS前缀在Swift中添加了快捷键
现在 你可能知道地基大的子集
实际上用Swift核心库
作为Swift 代码部分
是可用的在其他平台上 如Linux
我们要匹配的命名样式这部分的基础
随着公约的建立通过Swift标准库
而不使用前缀
因此 我们的类型很多没有了NS前缀
在基础和Swift中正如你所看到的
NSFormatter变成了Formatter等等
最后两个 NSData和NSURL是一个特殊类别的一部分
我会提到这一点
现在 这正在发生只有在基础上修改
这不是我们应用的东西
到我们的其他框架甚至在基础
这只是应用于一些API
我们不把这NS放到API
本质上依赖于Objective-C
例如 NSObjectNSProxy NSAutoreleasePool
我们也不把它的API在特定的平台
事实上在其他平台上不可用
比如NSUserNotificationNSXPCConnection
在另一个情况是类这也暴露了值类型
所以在这里 我们正在暴露数据 网址 等等 但
我们也将NSData NSURL
等等我的意思是
现在先让我解释一点关于值类型
你可能已经熟悉值类型
我们有这个概念在基础很长一段时间
这些类型的值是重要的 而不是身份
比如NSString NSDataURL  Array等等
现在 由于一些基础的API已经有这些值类型的语义
我们已经提前并将它们最为Swift值类型添加
我们已经做的全套API
这当然是字符串 数组 字典
和设置已经作为值类型
在Swift中  他们是可用的在标准库中
所以现在这里的这些类型是暴露结构在Swift中
他们有价值的语义类型这意味着他们可以直接变异
如果他们有意义的可变性
你可以使用let或者var突出异变
在你声明他们的时候
这些也符合Swift协议
正如你所期望的
现在已有的类的API仍然保持在case
在我们创建这些值类型
让我看看这里的案例研究
一个例子是数据我已经提到的那个
所以现在我们的结构数据类型
这是数据值类型
这是我们期望的数据类型在编程过程中使用最多
这是前进的类型然而 我们也有NSData
这是NSObject和NSMutableData子类
这是一类NSData本身
现在NS类型仍然存在因为如NSMutableData
不是很容易迁移所以他们不会迁移它
我们的另一个原因是NS类型有时你真的
要继承这些类型
你知道 你可以子类化NSData或者NSMutableData
提供一些专业化的实现
当然 你可以这样做类类型 如您在这里看到的
所以这些都是一些原因为什么NS类型仍然存在
现在 让我们来看一看这里有些差异
NSData类有一个长度属性
这个被命名为数在结构版本
因为它与其他Swift标准库更一致
如写入方法 范围和许多其他方法
保持相当完整
他们遇到相同的方法 除非你会注意到
NSRange和NSData已成为指标范围
在数据结构的版本 这是更符合Swift库
最后你会注意到这一变异的功能 如添加
是不可以在这直接值类型数据
在NSData中它在NSMutableData类中
所以这些都是一些的差异 你会看到
在值类型与类类型之间
现在我不准备说更多关于这个内容
今天下午有一个谈话“Swift基础有何新特性”
在任务室里
我鼓励你们参加并听到更多关于这些内容
现在我们有几个基础新类型
代表测量的量
这里的主要类是单元类
这是一个抽象的类型代表单位 如英里
摄氏度 公里每小时 等等
然后我们有一个类维度这是一个单位的子类
这代表单位家庭如长度
温度和速度 等
因此 在此 我们有单位类
我们有子类维度然后我们的子类
如单位长度 单位温度单位速度 和一堆更多
有一个辅助类单元转换器可以
单位之间同一单位家庭转换
有一种结构测量它是一个类
在Objective-C在Swift中作为一个值类型
结构测量相结合的值 如10
用一个单位 如英里
所以这基本上现在是一个测量
最后锦上添花
我们有测量格式化程序类
将一个测量
并将其显示给用户区域中的用户
所以它会显示10英里的用户在美国这里
但会显示16公里 例如在欧洲
使用欧洲系统的用户
所以它会为你做的转换并向用户展示正确的数据
我们有很多已定义即可用的单位家庭定义
这是全套
所以这些尺度的子类
在其中的每一个单位家庭
我们实际上有多个即可用的单位
让我们看一看单位的温度
你会看到温度有三个标准单位
开尔文 摄氏和华氏
UnitTemperature类中这些都被定义为类属性
许多其他尺寸也有一些单位规定
知道彼此之间如何转换
更好的消息你可以添加你自定义的单位
我们提供它们将使用现有的
而且你也可以添加你自己的单位家庭
你可以听到更多关于这个的内容星期五下午4点
测量和单位
DateInterval是新类型我们已添加到基础版本
它表示一个日期间隔
它有三个属性开始 结束和持续时间
相当直观 当然 这些都不是
完全独立 但它们作为三个独立的属性
除了这些属性
DateInterval能够做到检查日期是否在日期间隔内
或是否两个日期间隔重叠等
当然日期间隔在格式化时很有用
通过DateIntervalFormatter类
这就是我们这是我们去年发布API
有个从String修改过来的API接口
现在我们从API到String只需要一个日期间隔
如此相当简单
现在在这里让我告诉你们一个关于公共服务通告
处理日期和时间
所以处理日期可能是复杂的
现在 这不是这里建议的
好吗 我不是医生
让我们说你想要表示10秒时间
你创建个DateInterval类
开始时间和10秒
这可能是正确的无论你试图做什么
无论你试图怎样处理10秒
但是让我们说你是试图代表一天
你也可能这样写你的代码
24乘以60乘以60表示一天的秒数
这是一个数字24小时内的秒数
它往往不是正确的
原因是因为一天并不总是24小时长
一个月并非总是31天
年不总是365天 等等
我们总是把那些记在心里但是有时一天
23小时 或者有时24小时 25小时 如你所知
所以取决于你想做什么通过DateInterval表示日期
你想设置一个闹钟吗正是从现在开始的24个小时
你想在第二天同一时间发出一闹钟吗
你可要小心了
通常情况下正确的解决方案涉及使用日历类
你会遇到这些问题
而且幸运的是他们的解决方案上面所提到的从2013年开始
常见的数据的解决方案和时间的问题
我建议你回去重新看看
ISO8601 DateFormatter是基础类中新提供的API
这是一个格式化日期类
谢谢
很显然你们中的一些人
以前使用86018601是一个标准
这是一个用于指定日期的交换格式
在明确的方法中
所以这是一个单独的类和DateFormatter相比
因为不向DateFormatter
它是用户本地化的日期8601格式是非本地化
你知道这是交换格式所以这是一个单独的类型
我们决定让事情变得简单
使用起来非常简单
所以创建一个格式化
给自己一个日期又没有关系的建议
简单地问格式化程序为日期转为字符串
它会返回你的格式
现在DateFormatter可以两种方式实现
所以你实际上可以
哦 顺便说一下这是调用的输出 正如你所看到的
就要到午餐时间
这里是 此格式化程序还有其他的方式
也做解析
所以你可以自己格式化并要求从字符串转换成日期
它会返回你的日期
所以它是双向的
这默认是RFC 3339它是一种格式
然而有选项可让您指定
一些行为 如果你需要的话
现在让我快速的告诉你们我们提供的其他功能
URL有一堆新的属性
如一个文件和一系列其他的典型路径
像音量是否加密等
你可以阅读所有这些在发行说明中
有一个新类URLSessionTaskMetrics
这个类可以帮助你收集网络资源
加载性能信息
所以你可以看看应用程序的网络性能
PersonNameComponentsFormatter是新版本我们提供的一个API
正如你所知道的 它需要一个名字
它以一个区域设置适当的方式来格式化
在这个版本中其实现在可以解析名称
所以你给它一个名字它会返回你
名字 姓 等等
这是一个不错的工作
由于它采用了一种基于真实数据的统计模型
最后
但也有一些棘手的名字
所以不要期望太高
DateComponentsFormatter
是我们最新的版本中添加的
除了长短类型
我们现在有一个简单的风格你可以格式化日期
下一个发布也许我们会添加boxer风格
好吧 这就是基础
核心数据 只是一个简短的提及核心数据
你已经看到一些API的改进
在核心数据与泛型
有更多的新的API在核心代码里
比如generational查询持久性存储
NSFetchedResultsController类现在在系统OS X中可以使用
对不起 是macOS系统
周五上午10点你将听到所有这一切“核心数据有何新特性”
还有一个我想大喊出来的
我们每年都在这里告诉你关于新的API
介绍了新技术
你可能并不总是处于一个方式通过这些API
因为你在做其他事情
或者你等一个版本
好吧 如果你想得到一个概述关于最近我们已经添加的API
APIs是重要的创建用于Mac的现代应用
这个谈话是给你们的
它将涉及很多主题他们将有
其他感兴趣的演讲不只是在本届 WWDC
往届 WWDC 也有
它也适用于每个人各年龄 不同经验水平
这也是星期五下午5点
所以我希望你在这里
好的 那么这是网页你可以了解更多信息
请读AppKit与基础版本说明
您可以在我们的开发工具站点中找到
它是一些原始信息很多我已经谈到了
这是我们提到的有关演讲
还有更多的课程
非常感谢大家