统一日志和活动追踪记录未来
欢迎大家来到“统一日志和活动追踪——记录未来”
感谢大家能在周五晚上来到这里
我是Steven Szymanski
真没想到这个时间还有这么多人来听
我是Steven Szymanski将会主持大部分演讲
稍后我会邀请Matthieu Lucas上台
那么我们开始吧要讲的内容很多
我开始先做个简单的介绍
然后讲讲新的日志系统背后的基本概念
这是这周才引入的新系统
一会儿做个简短的演示
然后再回过头来讲解如何真正使用它
如何使用API怎么使用这些工具
再讨论一下我们心目中的最佳操作
然后讲一下如何收集你创建的记录
最后讲一些弃用的界面
那么开始吧
先讲一点背景
如果你已经听过几场演讲你就知道在2014年
Apple引入了“活动追踪”的概念
它能跟踪所有的工作
代表某些操作在整个系统里运行
这个工作可以在一个应用里完成
可以在应用调出的一个框架库里完成
甚至可以代表应用在另外的进程里完成
我们同时引入的另一个概念
就是故障和错误
这种特殊类型的日志事件会引发额外的工作
让系统收集额外数据
作为开场白的最后一点
就是我们意识到Apple已有一些记录API
而且希望演讲结束后你能明白我们为什么要介绍
这个新的API以及它如何与其他人相互关联
那么这个项目的目标是什么？
首先我们想要做的是创建
一个公开公共且有效的记录机制覆盖整个系统
既能用在用户模式下也能用在内核模式下
目标
其中一个目的是为了尽可能多的收集信息
同时 最小化观察者效应
这里的观察者效应指的是我们开发者都有的体验
当你遇到问题将一些日志粘贴到你的代码
问题一下子就没有了因为你改变了时间
我们想要一个无痕的记录界面
在你调出代码的时候对代码的影响最小
如何实现这一目标就是这场演讲我要具体讲的内容
首先 我们压缩数据
这样就能在磁盘上存更多的信息
却不占用更多空间
另外一件重要的事就是我们延迟了许多工作
我们能做的所有事情都是在显示信息的时候
而不是在收集信息的时候所以我们想要延迟到那个时候
这是我们采用的主要方法来避免观察者效应
另外我们做的就是用新方法来管理消息的生命周期
我们的想法是不同种类的信息
可能在系统里停留的时间不同
要尽可能让你想要的信息真正出现在
你实际去研究和使用它们的时候
背景情况是我们想要能
打开系统里尽可能多的日志无论在任何时候
而不需要回去再说
“能否打开这个再给我一个新的日志”
我们要看到所有越多越好
另外一个动机是
我们想把隐私完全融入系统里
这个我一会儿也会细讲
那么这个新系统的主要功能是什么？
就是用新改进的方法分类和筛选日志消息
因此我们将为你提供新的工具
让你能给日志信息分类
这样在需要查看日志的时候
能更简单的找到你要的信息
特性
另外很重要的一点是日志系统会为你收集调令源的信息
所以你不再需要传递文件和代码行
去确定这个调令来自哪里
我们自动为你收集好
这里还有很多新的内置分类符
让我们可以为你处理二进制数据的格式
这样你就不用花时间做这个了
我们有个新的Console应用和一个新的命令行工具
我们用它们来访问所有的功能
我们所有的平台都支持它
macOS iOS watchOStvOS和所有的模拟器
它同时也可用于...
用于这周发布的CC++和Objctive-C版本
不久之后也会支持Swift
那么现在给你一些小预告
这是现在使用的Console应用就是你看到的这样
而这是新Console的样子
这里我要指出
仔细看看高亮的这一部分
这个树状图向你展示的是一个特定活动
不断从一个进程到另一个进程的过程
这样你就可以直观的看到所有的工作情况
它们代表你所请求的操作
那么我们先来打个基础 讲讲理论
以及背后的抽象概念
首先 采用
如果你想使用新的统一日志系统你一开始要做的
就是使用这周新发布的SDK来进行创建
如果这样做
所有遗留的API NSLogasl log和message syslog
所有这些都会被重新引入新系统
你一行代码都不用改就可以开始使用这个系统
当然如果要使用这些新功能就要开始使用新的API
但是如果你什么都不做直接使用新系统创建
它们就都被引入新的日志架构
另一方面如果你不想开始使用
新的日志系统并且继续用旧的SDK创建
那么你的系统不会有任何变化
采用
下面来讲新的文件格式
在新的系统里日志数据是以二进制形式压缩在磁盘里
叫做.tracev3文件
这些文件现在的保存路径为/var/db/diagnostics
其辅助文件的路径为/var/db/uuidtext
现在可以用新的工具访问这个数据
我们有新的Console新的命令行工具
你还要记住一点
就是由于数据以二进制格式保存
你必须使用新工具来访问
所以你不能再用grep命令查找日志而必须用我们的工具
来浏览日志
还有另一种新的文件类型.logarchive
这是为了实现数据可移植性
其实.logarchive文件是信息的集合
来自/var/db/diagnostics和uuidtext
它们集合到一个文件里
这样就能更方便邮件传输添加到故障报告等
这个系统背后的另一个新概念是
子系统和分类
日志消息现在可以与一个子系统和一个分类联系在一起
它可以用来控制日志消息的筛选和显示
一个子系统实际上可以包含很多个不同的类别
而且你可以使用很多子系统和分类只要你需要
举个例子你可能有一些应用
并定义一个子系统为com.your-company.your-application
它有三个分类setupinprogress和teardown
在同一个应用里
你还可以定义另一个子系统com.your-company.test.your-application
只包含一个分类测试
你可以用它们来控制日志消息的显示
日志行为这是这个系统的核心所在
每个日志消息都有一个级别由你创建使用的API决定
有三个基本级别：DefaultInfo和Debug
还有两个特殊级别：故障和错误
每个基本级别有两个特征
既可以在系统范围内定义给某个子系统
也可以给子系统里定义一个特定类别
第一个是指是否可用
如果你发出指令它是否真的能生成一个log line
要注意默认消息总是可用的
你无法关闭默认消息
另一个特征就是你可以定义所有级别
是要保存到磁盘还是内存
看上去应该是存到磁盘里
但是我说的是存到内存里
新的统一日志系统
保存了大量的内存中环形缓冲区
一些日志消息可以被转到这里
然后这些消息只会在故障和错误时存到磁盘里
这很有用尤其是对很快就过期的消息来说
假设你有一个消息
这个信息基本上已经没用了
你所能看到的就是这个消息最后的版本
无论何时你收到一个日志都没有必要把几百个
不同的备份存到磁盘上
如果存到缓冲区它就可以在故障与错误中找到
而且就是你需要的最后一版
而不用存一堆额外的东西
这些级别是有顺序的
也就是说 若你定义Debug给磁盘
那么信息也会引入磁盘
所有这些行为都可以自定义
通过安装文件或者在macOS上使用log命令
会立刻出现什么样的标准行为呢？
如果你没有安装一个特定文件的话
Default级别的消息总是可用
标准配置下他们会进入磁盘
Info级别的信息可用但是他们进入内存
Debug级别的信息是关闭的他们不可用
当然因为处于关闭他们哪里也去不了
那么另外两种类型的消息就是故障和错误
故障和错误通常都是开启的并总是存入磁盘
现在花点时间来讲讲隐私
你知道Apple十分重视客户隐私
作为指导原则我们设计的所有产品
在我们的应用 服务以及OS的新版本
都要尊重用户的隐私
所有的开发者 包括你们在座的各位都跟我们有一样的责任
如何在日志里体现呢？
我们想避免的是不小心记录了
能够识别个人信息的日志
这样其他人就可以从日志数据中提取信息
因此 动态字符串集合 阵列和对象等
都被认为是包含隐私的数据
静态字符串和标量被认为是可公开的
稍后我们会进一步讲讲怎样控制它
现在来看故障和错误
我之前讲过作为活动追踪的一部分
我们引入了故障和错误的概念
它的一个基本理念就是
我们在故障和错误上下更多功夫
就能保存更多的信息
错误指的是一个问题
出现在不同应用或者库里
对于错误我们查找内存缓冲区
收集来自相关进程的所有日志消息
并保存到磁盘上作为错误的一部分
相对而言 故障代表的是系统中更广泛的问题
是更大型的故障
针对故障我们查找存储缓冲区
收集相关进程的所有日志消息
以及这个活动涉及到的所有进程
实际上我们还收集了一些其他系统信息
它们可能对我们有用
故障与错误以及所有作为它们的部分而收集的日志数据
都实际上存到了单独的一套日志文件中
这样做是为了不让正常的日志把他们挤掉
因为这会导致它们超出份额占用更多的空间
也就是说故障和错误的数据会一直存在
甚至比正常的日志数据还长
好的 现在我来做一个很直观的介绍
看看系统如何在细节大量丢失的情况下工作
这是个比较宽泛粗略的讨论
好了 每一个进程里
有一个小缓冲区的集合我们会把日志消息存在这里
这些缓冲区实际存在于与日志守候进程共享的内存里
缓冲区满了的时候日志守候进程就会开启
把数据压缩进它的一个更大的缓冲区
当这些大的缓冲区也满了的时候我们可以把它们存到磁盘上
也可以再利用将它们作为内存缓冲器的一部分
架构
那么最后会做的就是
请求在线流式日志数据
比如你在Console上想看到的日志
是在一出现就实时记录的
我们执行的方法是
立刻做一个IPC连接到诊断守候进程
它会分发日志消息给所有的客户
副作用是
它会极大的影响在线流式日志数据的性能
基本上我们做了很多努力来节省力气 提高日志的速度
这样你的代码就不会有观察者效应
因为我们给每个调令都做了IPC
另外要注意的是每一类消息是如何
不管从应用还是某个子系统还是绕过这些路径
如果通过配置等等来改变
我讲的差不多了请Matthieu Lucas上台
来为大家实际演示一下如何使用Console应用
谢谢 Steven
就像Steven在一开始说的那样
今年我们引入了全新的Console应用
我们重新用Swift编写
我们想创建一个新的日志系统
让你们的开发能够更简单
让我们来看看这个应用
这是新的界面
你能看到布局其实没怎么变
中间还是主要流式
顶部是不同的操作边栏是不同的来源
先来看看边栏
你还是能看到不同的报告
系统报告或者用户报告还有不同的遗留日志
它们可能都有系统路径
但是这里你看到有一个新部分
我们现在可以显示所有连接到你的机器的设备
也会显示当前的机器
我们可以支持iOStvOS和watchOS设备
所以你可以连接所有你有的设备
现在再来看看主要流式
现在 日志流由两个视图组成
一个是消息视图一个是活动视图
就跟Steven之前说的一样
在活动视图里你可以看到活动的分层
以及相关的消息如果有的话
细节会显示在底部这里
现在转过来看看消息
这里你看到有一大堆消息
那么为了能包含Debug和Info消息
你需要在Action菜单里手动操作
这样他们就能和默认的流一起显示
现在我们来多看一些...
我开几个应用来创建一些日志
这里现在能看到出现了更多的信息
能看到不同的消息类型
通过这些彩色的点在类型这一栏
灰色的是Info消息
黄色的是错误红色的是故障
深灰色的是Debug
如果没有点就是默认类型
你也可以展开或者折叠你的消息
直接在行内使用左右箭头
或者使用这里的视图菜单选项
展开或折叠
只要你点一个消息
你就能看到有关这个消息的所有细节
就在下面这个细节视图里
所以说我们可以展示给你所有信息
只要是有关这个日志的这就是新的日志系统的一部分
那么现在我们来展示一下进程还有它来自哪个库
你们看到这一个
它就accountsd下的Accounts.framework
你还能看到更多的信息在我们收集所有新日志的时候
你现在看到我们有子系统 分类
活动ID线程ID或PID
现在再看看这个iPad
我连接的iPad只有一个最基本应用上面有些数字
我们要找到它们通过浏览不同的功能
首先我们最小化栏的布局
我可以右击上方这里
然后添加一些新的栏
我就添加子系统和分类
然后把它挪到这里
现在这个布局是永久的你不用再设第二遍
现在我们可以看到这个设备上有很多信息
为了精确你的搜索
我们有两个方法
你可以首先右击一个消息
然后你能选择不要子系统
不要进程或者只显示一个特定的进程
这样我们开始就可以减掉特定的分类
假设我们要widgets不出声
第二个方法就是
在这里直接打字输入
所以你看到 我们只添加了一个自定义的token给widget
假设我只想看Bookmarks应用
就是这个应用在我的设备上出错了
这样一来 这里就只有来自Bookmarks的消息了
而没有分类widget
那么再来添加一个token只显示错误类型
现在看到的消息就只来自于Bookmarks
没有分类widget并带有一个错误类型
我们可以看到网页视图的不同的错误
这就是我们如何直接关联到要查找的内容
为了之后能修正错误你只要保存它
通过点击右上方的保存键
名字就叫Bookmark Errors
你可以看到所有你保存的搜索都会显示在这个部分里
你可以重新排列它们愿意的话也可以删除
你会有两个默认保存的搜索
就是全部信息和故障及错误
现在来转到活动视图
看看能否找到更多有关这些日志的情况
能否简单的重制这些错误
这里我们看到不同的活动
这些活动的视图基于同样的搜索机制
所以我们可以使用同样的功能并且保存
这里我们看到
不同孩子的Bookmarks活动
我们可以看到当时是在准备转换
然后我们检索一个对象打开细节视图
然后设定细节视图下载网页视图
现在你就可以看到信息直接显示在底部的视图
这些都是有关这个活动的信息
这个消息是记录在这个活动里的所以才会显示在这里
我们现在看到这些消息
这两个错误是加载网页视图活动的一部分
那么我们就知道了是什么情况
导致了这个错误
那么现在我们添加一个分享选项给Console
你只要选择一些活动或消息
直接分享给某个人或者给备注
我这里就只添加为备注以便以后的调试
下一个问题
另外一个可用的输入是日志档案
在桌面上有一个日志档案
是另外一个设备之前生成的
如果你也有一个双击它
Console会打开它
你可以看到无论何时你点开它
它就会下载所有的东西
你还可以看到
这里保存的筛选跟我们之前说的一样
那么为了能看到这个特定的日志文档
是否包含了同样的错误消息作为流的当前设备
我们只要点击它它就会自动重新应用同样的筛选
这里就看到错误是一样的
同样我们也可以在活动视图查看同样的活动
这就是Console的全部内容我要请Steven回到舞台
谢谢
十分感谢 Matthieu
我十分喜欢新的Console很好用
那么我们来讲讲新的统一日志系统
以及如何实际使用
首先我们来总结一下所有新的API
Os_log是基本的日志API用默认模式记录
Os_log_info是一个调令默认发送日志消息给内存
也用于你想收集的额外即时信息
Os_log_debug用于十分频繁的调试
另外还有os_log_error和os_log_fault
用来生成故障和错误信息
最后一个调令是os_log_create
它能创建一个日志对象让你自定义你的行为
就这一点我们再深入讲一下
因为它对你们来说应该是最不熟悉的
相较于其他内容而言
调出os_log_create由两个参数组成
子系统的名字和分类的名字
它要做的是创建一个线程安全的单例对象
来控制你传递的日志调令行为
在默认情况下这是个系统范围内的行为
但是你可以自定义为某种特定的行为
通过使用配置或者日志命令行工具
使用方法就是简单地将它作为第一个参数传递
给所有其他调令
这里我调出os_log第一个参数为log
它是从os_log_create返回的值
它所做的就是制造一个引用给分类
和用这个日志对象定义的子系统
跟每个用到的日志消息存在一起
以便以后可用在后端上筛选和显示消息
如果你无所谓有没有自己的子系统和分类
那么另一个办法就是传递一个os_log_default
只是我们一直提供的默认日志对象
它没有子系统或分类
但是它很有用如果你不需要那种控制的话
内置类别格式化
我们都花费了大量的代码去把二进制信息转换成字符串
以便我们记录
统一日志系统可以帮你完成大部分这样的工作
通过为常见的类别提供内置格式化
更重要的是
我们省去了转换工作直到我们要显示日志消息的时候
所以你不需要为转换而苦恼
在生成日志消息的时候
避免所有不同类型的观察者效应
这点我们多讲一些
对于一些常用的值这里有内置的解码
语法不是％d
而是％（time t ）d
这就是说这个十进制的值
你传递的实际上是一个time_t
那么在打印的时候印出的就是一个time字符串
同样的对于错误你要写 ％（errno ）d
这样这个错误就会被转换成肉眼可以辨识的格式
我们还有一个新的基本时间格式％P 不是小写p
这已经不是新闻了
你可以用它来显示任意二进制数据
所有常用类型都有解码器比如％（uuid t ）
这里列出了我们现在使用的所有代码
包括所有不同类型的时间值
errno和uuids还有所有不同类型的网络ID
而且我们很期待未来还有更多的代码出现
那现在讲讲以参数为单位的隐私
隐私现在基于参数处理并以一个参数为单位
标量和静态字符串被认为是公开的
另一方面动态字符串 集合和对象被认为
含有隐私信息除非你特别说明
那么这个行为就可以重写以一个参数为基准
以前会写％@来表示
“我想把这个对象包含进我的日志”
而现在你要写％（public ）@来告诉我们这个对象
以及这个对象里的所有内容都是公开的不用担心
另外如果你有一个事件里面的一些数值
出于某些原因是隐私的你就可以写％（private ）d
让这个数据记录为隐私信息
这样你就可以把隐私和格式结合起来
那么我可以写％（public, uuid t ）.16P
来表示这里有一个uuid
它是公开信息并且已格式化
那么我们再讲讲实例
看看写代码的时候会产生什么不同
日志消息简化
这是我们以前用的方法
好的首先你要检查并声明
当前的日志层级是否在发出任何调令前可用
然后你要声明你要显示一个uuid
你要做的第一件事就是调出unparse 转换成字符串
碰巧你还有一个套接字地址
这个之后也要转换成字符串
然后调出NSLog包括所有已经转换的元素
当然你还要传递这个函数的名字
以及file和line的数字
完成后不要忘了
释放为套接字地址所创建的字符串
这就好了
下面来看看新方法
简单地调出os_log_info它可以帮你检查日志级别
这种情况下我传递默认的日志对象
我在格式字符串里定义所给的参数是一个uuid和一个套接字地址
就不用再做转换
现在我什么也不做直到我们要显示它的时候
然后我只要传递参数就这么简单
在我做示例的时候让我多说一下
使用其他API的例子
这里我做了一个log_create定义了一个子系统和分类
子系统是com.apple.logging.example
分类就是普通分类那么这就是我一般的日志对象
我要做一样的事情 但这次我创建了一个分类timestamp
然后写个简单的调令
调出os _log 使用general_log对象传递字符串 日志完成
这里有个更有趣的案例
我调出os_log_info
这之后会进入内存缓冲区
并只保存在有故障和错误的时候
在我的格式行里我定义％（public ）s给filename
因为filename是个动态字符串
所以我们假设它是隐私信息
除非你特别声明它是公开的
下面这是个比较复杂的例子
我打开一个文件检查到一个错误
如果它返回一个错误我就调出os_log_error
在我的格式行里就会声明这个filename是公开信息
我声明给格式定义errno为errno
这是另一个相似的例子这一次我调出fstat
但糟糕的是我调出的fstat是在打开文件之后
所以如果我收到报错就可能有奇怪的问题出现
因此我调出os_log_fault同样类型的参数
最后一步就是调出os_log_info
但是这一次我传递timestamp日志对象
然后基本上我会丢掉这个文件的所有timestamp
这就意味着当我打开浏览Console的时候
我可以简单地筛选并说
我只要看timestamp数据或者我不想看timestamp数据
因为我要看其他数据
新的统一日志系统不是此次发布的唯一改变
我们还改进了活动跟踪系统
活动 是最优先被保存和再利用的对象
创建操作让你能控制
不同活动对象之间的关系就在你创建它们的时候
还有一些新的API是观察你的代码活动
改进的活动API
这里就是所有的新API
这个新的os_activity_create跟os_log_create一样
都是创建一个日志对象只是在识别一个活动的时候
你可以使用两个调令在你的代码上
os_activity_scope和os_activity_apply
我一会儿让你们看几个例子看看他们的运行有何不同
最后就是os_activity_label_useraction它将活动标记为
基于UI的用户活动
那我们用个例子来说明
首先调出os_activity_create创建init活动
注意这个函数的第二个参数
是常量os_activity_current
这就是说这个init活动是附属于
当前活动的不论这个活动是什么
现在我开始做os_activity_create为验证活动
但是第二个参数是我刚建的init活动
这样我就给这些活动手动创建了一个层级结构
现在我有了一个代码块
准备好了我大括号里还有一些代码
第一件事就是调出os_activity_scope
然后传递这个验证活动
意思就是这个代码块里的其他代码
被认为是这个活动范围之内的直到我点击结束括号
不用再记得要在结束时调出os_activity_end
它会自动完成
当你离开这个scope的时候你就不再是这个活动的一部分了
我们提供的另一调令是os_activity_apply
先传递活动对象再传递这个代码块
然后它就会运行这个代码块并以这个活动为执行范围
工具
Matthieu已经为你们展示了新的Console
那么我就快速过一下它的功能
你可以浏览系统中的活动内容
可以打开日志档案
可以使用新的日志检测的活动中心视图
你可以使用高级的筛选和搜索
还可以看到设备的日志
现在我仔细讲讲新的命令行工具
它提供了跟Console完全一样的功能
但是是用命令行
要想获取在线流式日志消息只要写log stream
如果要漂亮一点
你可以写log stream--predicate eventMessage contains my message
它能做的就是获取所有流式日志消息
包括了my message字符串
就跟Console一样让你打开日志档案
一个日志档案可以通过日志命令显示
你可以写log_show然后给它文件名
然后它就可以显示这个日志文件的内容
你可以在macOS做的另一件事使用日志命令去更改
你的子系统和分类的配置
这里是个案例
我写了log_config --mode level:debug
然后写-system com.mycorp.myapp
这么做是为了能够记录
这个子系统的日志在你的macOS上
即将推出
我们很感谢你们将使用iOS 10来开发你的应用
但是请继续使用Mac上的macOS 10.11即El Capitan
让你能够通过El Capitan访问新日志的工具马上就会推出
但与此同时
我们煞费苦心的提供了一个变通方案
能让你的新工具在模拟器内部运行
xcrun simctl spawn booted
然后写log show system logs.logarchive
然后你就可以执行所有命令跟往常一样
另一种方法也再研究中
那么我现在开始讲最佳操作记录规则
一定要保证你的消息里只包含真正有用的信息
不要有额外的空白字或者填充数据
要保持紧凑
让我们利用内置格式化组件去做格式转换
你提前做的字符串转换越多
你的应用就显示得越慢
相比之下输出的时候再转换就好很多
避免将日志API包含于其他函数
如果你把它包在其他函数里
你就无法收集文件和行数
如果你必须要包装我们的API
那么把它们包在宏命令里不要包在函数里
只从字典和档案里记录所需要的内容
这里说的字典是指字典和数组
它们占用了磁盘上很多的空间
也就是说他们会挤掉其他人们需要的日志消息
尽可能的只记录你日志所真正需要的部分
还要避免记录到紧凑代码循环里
简单说一下我们心目中这些新API的最佳用途
Os_log是记录日志信息的基本细节
这个信息类型可能正是你需要的
能在几个小时前帮你调试问题
使用os_log_info去获取额外的即时信息
这个首先要用于很快就会过期的信息
使用os_log_debug来处理开发过程中大量的调试工作
错误出现在你需要收集额外信息
并为你的应用保留的情况下
故障是指你想要收集额外的
有关系统的信息
简单来讲讲日志收集
我们推荐Sysdiagnose来捕捉有关故障报告的数据
使用sysdiagnose
如果你使用sysdiagnose我刚刚描述的系统里的日志数据
就会出现在档案里文件名是system logs.archive
可使用key-chords来激活sysdiagnose
如果在Apple watch上
它不仅会在手表上激活也会在与之匹配的手机上激活
然后你可以用iTunes转移这个档案
给你的Mac来进行操作
这个文件就是Apple想要为你提供的
解决你给我们提出的问题
所以你可以把它附在雷达上
也可以发送给开发者技术支持
这就是各种key-chords
Shift + Control + Option+ Command + Period （. ） 对Mac OS
Volume up + Volume Down+ Power 对iOS
手机上会产生轻微震动iPad不会
在watchOS上长按电子表冠和边键一整秒
如果按的时间不够长你就只获得一个截屏
启动的时候会有轻微的触摸震动
Play/Pause + Volume Down在tvOS上
注意以前的Apple TV遥控器
得按五秒钟才能激活
弃用
这一部分我们要对一些API说再见了
首先就是所有的ASL日志API现在已经被这些新的API所替代了
所以这些旧的API就被弃用了
但这里还有一个有趣的极端情况
搜索日志数据的新API在这一版本不会被公布
意思就是现在没有能替代asl搜索功能的工具
如果你的系统完全依赖asl搜索
那就得等着使用新的日志系统了
还有一些活动API也会被弃用
现在不用再写os_activity_start和os_activity_end
而是像我展示的那样写os_activity_create就可以
然后调出scope或者apply来应用到代码块
Os_activity_breadcrumb已经被os_activity_user_label代替
Os_trace_with_payload也换成了任意os_log调令
注意这些函数在这一版本里以没有ops
所以如果你继续调用它们它们也不会进行任何操作
总的来说
新的日志系统更快也更简单也给你更多的控制力
但它的确要使用新的API和新工具
相关演讲
我提到了几次在2014年发布的“活动追踪”
这个演讲讲的就是这个内容
所以如果你想回顾一下
或者想了解更多有关这个演讲的信息请登陆这个URL
谢谢大家