用SiriKit扩展你的应用
大家好
我是Vineet Khosla
今天我将与Diana Huang和Scott Andrus一起
向你们展示如何利用SiriKit扩展你们的应用程序
在简介的部分
大家了解了一款支持SiriKit的应用由三个核心部分组成
你们有意图扩展
你们有意图用户界面扩展
当然 还有你们的应用程序
在意图扩展下我们有三个主要的方法
它们分别是解析和确认还有处理
在这个部分我们将探索三个内容
首先 我们会聊一下如何让你们的应用适用SiriKit
然后 我们会聊如何添加你们的第一个意图扩展
最后 我们会聊一下如何将你们的应用程序
UI和样式集成到Siri experience
通过编写I意图用户界面扩展
在这个部分 我们将使用最爱的聊天应用独角兽快信
你们有些人一定知道这款应用
它是一款人见人爱的应用被Siri团队内部用来
与我们的独角兽们聊天
这是一款标准的消息应用是可以用来收发信息
但它具备一些特有的不完美之处
它的特殊使得它能为我们的目的服务
今天我们将会让它支持SiriKit
SiriKit是构建在扩展之上的
但是 在你们的应用与扩展集成之前
可为其与SiriKit相适做些准备
我先介绍一些涉及到的地方
我们将会聊一下如何准备你们的应用通过转移一些你们的代码
至embeddedframeworks
Embedded frameworks是一个很好的重用代码的方式
在应用与扩展之间
转移一些代码至embedded frameworks
也将会提供给我们一个很好的单元测试的机会
然后 最后我们将简单介绍一下什么是合理的总体结构
用于构建你们的扩展
基于你们的应用所关联的意图
现在 让我们进一步得看一下embedded frameworks
你们的扩展需要执行和应用一样的任务
它要能操控意图
还有当需要时也能渲染UI
利用embedded frameworks是很好的重用代码方式
在应用之间 同样也在扩展之间
因为你们要保证用户有一个统一的体验
无论他们是从你的应用
或者是通过SiriKit进入程序
以独角兽快信为例我们找到了一些地方
应该可以被移到embedded frameworks
我们看了一下独角兽快信的网络层
这是所有关于传送
和接收信息的部分
我们意识到这一部分代码
很适合被全部移至embedded frameworks
进而 它能被我的应用和扩展重复调用
在完成以上的移动后我们看了一下数据模型
你们的应用和扩展应该使用同一个数据模型
在我们的聊天应用里 它是一个数据库
和其读写方法
它同样可以被移到一个embedded framework里
被应用和扩展调用
在完成上述的移动后我们看了一下决策逻辑
这是你们应用的业务逻辑
在早些时候我们已经提过
我们有解析和确认还有处理方法
这三个方法将与你们应用的实际业务逻辑一一对应
你们应该确保应用
和意图扩展
提供给你们用户一致的体验当他们尝试着去
完成一个任务无论他们从哪里开始
所以我们也将决策逻辑移到了一个embedded framework里
最后若你的应用与意图关联
需要让UI返回至SiriKit
那部分代码也应该被移至embedded framework
那样 你可以重复调用代码同样
提供给你们用户一个一致的体验
无论你们用户的入口点是你们的应用
或是一个意图扩展
我建议大家观看一个2015年的讲座
应用拓展最佳实践
我看了这个讲座我感到很受益
在转移了大部分我们的代码至embedded frameworks之后
这给我们提供了一个很好的机会去写一些高质量的单元测试
我知道大家会觉得这是一个老生常谈的问题
我们在座的所有工程师都十分会写单元测试
我们都遵循测试驱动开发
我相信每一次都是这样的
但我们转移这些代码
至一个embeddedframework将会提供给你们
一个新的机会去写一些高质量的单元测试
特别是针对SiriKit
你们可创建一些模拟的意图
然后写一些测试确保你们的应用
和扩展有正确的响应
你们无需实时的和Siri进行沟通
你们可以模拟期望中从Siri那里接收到的意图对象
然后 你们可以写一些线下的测试
最后 让我们来思考一下怎样构建你们的应用
使其有合理的扩展的数量
一般来说 一个应用会与多个意图关联
因为 应用要会执行多个任务
例子里独角兽快信使用SendMessageIntent
但让我们假想一下我们想添加一个新的功能
我们可以用它来进行视屏和音频通话
那问题是我们如何构建我们的扩展？
是否该把操控所有意图的意图放在一个扩展里？
但这样会使我们的代码体积变得庞大进而难以管理
我们可以使用另一种构建
虽然不是那么的简洁
把所有意图的操控分开放在独立的扩展里
那看起来不错 但你也许会
重复写些模版式的代码
也会创建一些多余的扩展
导致对内存施加不必要的压力
那在独角兽快信里
我的宗旨是
考虑如何将有关系的意图分类到一起
在我们的例子里我们觉得视频和音频的意图
可以被自然地分类到同一个扩展里
因为这样可以让我们最大限度地利用代码
同时 消息发送的意图可以被放在一个分开独立的扩展里
总而言之 没有一个一劳永逸的办法
你们是最了解你们的应用的人
你们知道你们的应用会使用哪些意图
那你们需要选择一种构件它能确保
你们的代码容易被管理 同时
不会创建过多的扩展进而 对内存施加不必要的压力
经过以上的讨论之后
你的应用已准备好采用SiriKit
为了帮助我们写我们的第一个意图扩展
我邀请Diana上台
谢谢Vineet
大家好
我是Diana Huang我想在这里和你们聊一下
如何创建第一个能与Siri交流的意图扩展
在你们的应用已经完全准备好采用SiriKit的情况下
我也将会用Xcode向你们展示独角兽快信的例子
那让我们现在开始你们需要遵循有三个步骤
首先 你们要添加一个I意图扩展 target到你的应用
接下来 你们要设置这个扩展的Info.plist
最后 你们需要看一下这个扩展的principal类
让我们来分别看一下这三个步骤
要添加一个I意图扩展 target
你需要依次进入Xcode文件新建Target
然后从列表里选择意图扩展
对于你们曾经使用过扩展的人
就和创建其它的扩展targets方式一样
现在 让我们来看一下扩展的Info.plist
我们看到现有的NSExtension关键值
然后 在里面我们看到NSExtensionAttributes
在字典里面
我们引进两个新的iOS X的关键值
分别是IntentsSupported和IntentsRestricted WhileLocked
IntentsSupported是一个必要的关键值
为描述你们的扩展的具体功能
换句话说 你们需要将一组意图类的名字添加到
在IntentsSupported下的一个数组进而才能被扩展支持
IntentsRestricted WhileLocked是一个可选的关键值
为描述锁屏状态的行为
在默认的情况下Siri限制了一些特定的域
为在锁屏状态下不被随意调用
例子有 付款域或图片搜索域
但如果你们的应用有比Siri更高的安全要求
那你们可以把想限制的意图类加入到一个数组
在IntentsRestrictedWhileLocked之下
这样就可以指示Siri请提示用户
先解除锁屏再调用你们的扩展来操控意图
现在我们扩展的Info.plist也已经被设置好了
接着让我们看看principal类
意图扩展的principal类
必须是INExtension的子类
这样符合INIntentHandlerProviding协议
这个协议只有一个叫handlerForintent的方法
这个方法的名字清楚地解释了它的用途
你们有一个意图对象你们需要返回一个Handler对象
请注意返回的Handler对象必须符合
具体的意图操控协议
以独角兽快信为例我们想支持INSendMessageIntent
那当任何时候我们传递一个INSendMessageIntent的实例
我们将返回一个符合INSendMessageIntent操控协议的handler
现在我们已经讨论过了所有的三个步骤
接下来让我们根据以上的步骤将独角兽快信在Xcode里打开
这里有我们已经在Xcode里打开了的独角兽快信项目
时间关系 我已创建好了意图扩展
让我们直接来看一下第二步
设置Info.plist
首先 让我们将它放大些那样可以看得更清楚
好的
在这里我们看见NSExtension字典
如果我们将它展开 你会看到NSExtensionAttributes字典
如果我们进一步地展开这个字典
你会看见那两个我们之前介绍的新关键值
IntentsSupported和IntentsRestricted WhileLocked
首先 为了支持INSentMessageIntent
在IntentSupported数组下添加一个项目
我们加入意图类的名字
INSendMessageIntent
然后 让我们看一下锁屏状态的行为
因为独角兽快信是一款聊天应用
被用于独角兽之间的私密交流
独角兽们很注重隐私
所以 我们决定将它锁定
用户需要先将设备解锁
才能通过Siri发送独角兽快信消息
为达到效果 我们将在IntentRestrictedWhileLocked的数组下添加一个项目
同样的 添加意图类的名字
INSendMessageIntent
这样我们就完成了对扩展的Info.plist的设置
在第三个步骤里我们看看扩展的principal类
当你们创建意图扩展 target时
一个principal类会被自动地创建
我重命名了我的principal类为UCIntentHandler
它是INExtension一个子类
这里我们还有意图方法的handler
你可以看到默认的实现返回self
它返回一个principal类本身的实例
但为了让我们的代码更清晰
更容易被扩张
如果我们想将来让这个扩展支持更多的意图
那我们要创建一个独立的intent handler类
我们现在就建立这个类
通过创建一个新的文件
取名为UCSentMessageIntentHandler
我们也将导入一些框架然后加入一些类别的声明
这里我们导入意图框架
它包含许多SiriKit API
我们也将UnicornCore框架导入
那是我们创建的embeddedframework
通过在应用与扩展之间分享代码
这就是我们的UCSentMessage IntentHandler类
它符合INSentMessage IntentHandling协议
好的现在然我们回到principal类
取代这里现有的实现
让它为传递进来的意图返回一个UCSentMessageIntentHandler的实例
类型仅限为INSentMessageIntent
至于其它的意图我们将返回nil
大功告成
我们的三个步骤
用来添加和设置你们的第一个意图扩展
现在让我们来看一下应用逻辑
希望从SiriKit的简介部分
和Vineet的重述
意图扩展和Siri的互动会被分成三个阶段
解析和确认还有处理
让我们先来聊一下解析
在解析阶段你要确认
和理清每一个意图参数值
所以 我们给每一个意图的参数提供了
解析方法在意图操控协议里
那你们或许会问我们应该实现它们之间的哪一个？
试想
你是否需要在Siri的帮助下获取
意图参数值的最终值？
如果回答是
那你或许应该要实现这个参数的解析方法
让我们来看一下独角兽快信的例子
发送消息时 我们需要收件人
为了决定最终收件人的值
我们需要在独角兽快信地址簿里查询联系人
查询结果可能是多样的
在最简单的情况下
我们只找到一个联系人
任务完成
然而 也有可能我们找到两个或多个联系人
在这样的情况下 将会很便捷
如果Siri能帮助询问用户从候选名单里挑出联系人
同样也有可能我们没有找到任何联系人
在这个情况下我们也想让Siri告知用户
那样用户或许会选一个其它的收件人
在选好了一个收件人之后我们还需要关联的信息
在这个情况下我们只需要获取一个值来继续
如果用户没能提供关联的信息
那我们希望Siri能帮助询问关联的信息
考虑到以上所有情况
听起来好像 我们应该要为收件人和信息实现解析方法
我们的确需要通过Siri的帮助从用户那取得进一步的输入
才能最终决定这些参数的最后的值
现在参数已经成功地决定了
我们到了确认阶段
在这个阶段你们有必要做一下情景模拟
试想若你们正在操控这个意图
你们是否有了所有需要的信息？
或者 你们是否能够成功地操控它？
你们要得到问题的答案外加一些额外的信息
你们可收集这些信息在为Siri的意图做准备同时
那样Siri才会适时地
传达这些信息给用户
最终用户才能做出相应的决定
关于是否想继续他们的活动
在独角兽快信里
由于我们的安全要求
我们需要用户时不时地重新验证身份
所以确认是最合适的阶段
让我们检验用户的身份状态
不管如何 我们都想告诉Siri状态检验的结果
这样Siri就可以让用户在Siri内部继续
或许调出应用结束本次Siri操作
好的现在意图也已经被确认
我们来到了最后阶段操控它
但愿这是简单直接的 对你们来说最好理解的阶段
你只需执行行动然后告诉Siri结果
在独角兽快信里
我们就只要发送消息
然后 报告消息是否被成功发送
讲了解析和确认还有处理方法与有关的概念
让我们用Xcode实现它们
这次我们将直接从IntentHandler类开始
在开始之前 一个提醒
所有这些简单的代码都会上传
如果我跳过一些细节那或许意味着
对于你们 那部分代码相对来说没那么重要
目前 无需看懂那部分的每行代码
但如果你们感兴趣你们一直都可以回到网上
然后自己查阅这简单的项目
好的
像之前所提及的
我们将实现解析和确认和处理方法
我们将为收件人和信息实现解析方法
让我们从resolveRecipients入手
在这个方法里我们要注意recipients这个参数
它由一个INPerson的数组代表
你们也可以从这个方法的签名看出
你们需要使用这一个数组的解决结果进行回调
所以 有一个一一对应的映射关系
在recipients数组与解决结果数组之间
这意味着为每一个收件人 你们要创建一个PersonResolutionResult
这里唯一的特例是
当你想创建ResolutionResultNeedsValue
或ResolutionResultNotRequired的时候
这两类型的resolutionResults
是在参数层面的解析 而其他的resolutionResults
是更多的注重于个别参数值
那在这个方法里首先我们要
试着打开Recipients对象
然后我们将循环依次获取每一个收件人
然后调出在UnicornCore框架里的 API
根据名字寻找相应的联系人
接下来我们将用一个switch语句在核对查找联系人的数量上
如之前所提到的我们将考虑不同的查找情况
两个或多个相符的联系人
只有一个相符的联系人
没有相符的联系人
如果我们找到了两个或更多的联系人
我们将创建一个PersonResolutionResult.disambiguation
用我们所找到的结果
如果我们只找到了一个联系人
我们就可以继续
我们可以告诉Siri通过创建一个PersonResolutionResult.success
用那一个我们找到的人
如果我们没有找到联系人
我们将创建一个PersonResolutionResult.unsupported
我们switch语句在此结束
你们或许感觉到我讲解这些代码的速度很快
以至于你没有机会读每一行代码
那没有什么问题
因为只要你能明白
我们有不同的resolutionResults
它们适用于不同的情况
当你们自己为结果方法实现你们的代码逻辑
你们可以上网查阅关于resolutionResults的资料
完整的关于resolutionResults的列表
然后还有它们的用途
好的
现在我们有了所有的resolutionResults
那些我们为recipients所创建的
至此 我们完成了对resolutionResults数组的构建
这样我们也就完成了最后一行代码给在我们能
从意图获取一些收件人的情况
但在如果用户根本没有收件人
那我们将创建一个PersonResolution Result.needsValue
然后结束流程 告诉Siri请提示用户输入收件人
以上就是我们result recipients的方法
接下来 我们来实现resolveContent方法
我将检查值是否存在
如果不存在
我们指示Siri请帮助我们提示用户
我们在resolveContent里首先做的
还是试着拆包这个content属性
然后查看它是否真的不为空
如果content确实已经给定
建立ResolutionResult.success
通过已有的content
否则 我们就创建ResolutionResult.needsValue
就像我们在之前那个解析方法里做的一样
并以它为参数调用completion函数
现在我们两个解析方法都已经领略了
下面我们来看确认方法
我们用它来查看用户的认证状态
在确认方法里
我们就调用Unicorn Core framework里的shared API来查看
用户是否还有有效的认证状态
如果他/她有的话
那我们就创建一个INSentMessageIntentResponse
其code参数为success而userActivity参数是nil
我一会儿会讲解怎么用这个userActivity
不过我们先来看这个情况
用户不再是已认证的状态
在这种情况下 我们就创建一个IntentResponse
code是.failureRequiringAppLaunch
所以这就是要告诉SiriSiri应该提供一个选项
让用户可以进入到我们的主应用
来登录并完成这个发送操作
好的 以上这些就是我们的确认方法
最后 我们一起来实现处理方法
在处理里我们就调用
UnicornCore框架里的shared API
来用给定的content和recipients发送信息
我们还要获取发送操作的状态
如果信息成功发送
创建一IntentResponse并以success作为code参数
否则就以failure作为code参数来创建response对象
调用completion并赋给它IntentResponse
至此 我们一起讨论了解析确认和处理方法
现在我履行之前的承诺来讲解NSUserActivity
那些IntentResponse的初始化方法会用到它
我们暂时先抛开Xcode
说到NSUserActivity
在SiriKit的背景下
NSUserActivity被用来帮你的应用恢复状态
用于它被Siri或者用户启用的时候
默认情况下 Siri会给你创建一个NSUserActivity
这是在你决定把nil赋给IntentResponse的初始化方法时的情况
并且 Siri在创建它时会以ActivityType作为intent的类名
你还可以选择用你自己的UserActivity
比如你想要加入一些自定义数据
但不论如何 Siri都会将INInteraction属性设定
在NSUserActivity对象上
这个属性是在iOS X里新引进的
而且这个对象有意图IntentResponse
还有意图处理的状态
Scott一会儿会更详细讲这个对象
现在我们再来看看NSUserActivity在我们程序里的用法
如果你比较细心地看了这段程序的话
你可能会发现在确认和处理方法里
我们一直把nil
作为userActivity参数赋给我们的IntentResponse初始化方法
这样做完全没问题
这是在假设我们的主应用会处理UserActivity的情况下
就是Siri用INInteraction对象帮我们创建的UserActivity
不过在一些情况下 比较有用的做法是
给我们的应用加入一些扩展过程中的自定义字符串
比如说
在确认方法里
当我们发现用户不再是已登录或已认证的状态时
我们便需要将一些显示错误的字符串加入到我们的主应用里
具体做法是我们创建自己的userActivity
并在.userInfo字典里设定
我们想要给我们主应用加入的显示错误的自定义字符串
然后我们把nil删掉 取而代之的是userActivity
就是我们刚创建的那个
好的 很好
所以现在我的独角兽快信主应用有了
这些显示错误的自定义字符串并且会提示用户登录
这是在用户或者Siri此时要启动应用的情况下
现在我们完成了意图扩展的所有编程
我们来看看它真正在设备上运行的效果
用独角兽快信给Scott发一条短信
说你准备好你的演示了吗
没错
好的谢谢
是的 这个非常振奋人心
我们刚用Siri发送了第一条独角兽快信信息
这绝对是棒棒哒
谢谢
不过 在独角兽快信的主应用里
当我给我的独角兽小伙伴们发短信时
我会经常用他们的独角兽昵称
所以我实际上想跟Siri说
给Sparkle Sparkly发一条短信说你准备好演讲了吗
显然Sparkle Sparkly是Scott的独角兽昵称
要实现这个功能我们就要进入我们下一个话题
就是用户特定词汇
是的
用户特定词汇
那么
这是一些自定义单词或短语它们对于你的应用独一无二
并且因人而异
在我刚给的例子中
Sparkle Sparkly以及其他独角兽昵称
在这儿都可以作为用户特定词汇
而要让Siri理解用户
所说的这些自定义词汇
你需要把它们提供给Siri
你要从你的主应用调用INVocabulary API
我重复一遍
你要调用INVocabulary API
从你的主应用里调用而不是从你的扩展里调用
好我们来看看我们在独角兽快信怎么做到的
在独角兽快信里我们有UCAddressBookManager
它管理独角兽快信自己的联系记录
而我们创建了这个方法
来更新Siri让Siri知道独角兽昵称
而一旦哪个联系记录被添加 删除或更新时 这个方法就会被调用
在这个方法里我们首先想做的是
获得一个排好序的独角兽昵称列表
并且 我们把更重要的独角兽昵称列在前面
把相对不重要的放在列表后面
像这样优先处理 我们就能帮Siri
更好地对独角兽昵称进行优先学习和配对处理
在整理好这个独角兽昵称的有序列表后
我们调用INVocabularyAPI来把它们提供给Siri
我们还要给它提供这些字符串的词汇类别
在这个例子里独角兽昵称的类别是Type.contentName
关于这段程序 我想最后提一点让你们注意
就是我们要将所有这些操作分派到不同的任务队列里
这是因为像获取你整个联系列表这样的操作
会特别昂贵而你不想因为这个来阻碍你的主线程
所以请务必用GCD
分派这些昂贵的操作到不同的任务队列
好的
现在 在我们采用了用户特定词汇API后
我可以发信息给Sparkle Sparkly和Celestra
还有Buttercup以及我所有的独角兽小伙伴们
这绝对是棒棒哒
现在我又有另外一个功能请求
在独角兽快信里
这个应用的画风
实际上比你在Siri这儿看到的还要五彩斑斓 像彩虹一样
那么 我能让我在Siri里的独角兽快信体验
和在独角兽快信主应用里的一样色彩缤纷吗
关于这个话题 我现在邀请我的队友
Scott也就是Sparkle Sparkly上台
下午好
我是Scott AndrusSiriKit的工程师
现在我们来讲讲如何让这个过程
感觉更像是跟独角兽快信互动
要做到这一点我们要用SiriKit来建立一个用户界面扩展
在iOS X里 我们引进了意图用户界面扩展点
它能让你创建很赞的用户界面扩展
来在Siri体验里提供自定义的用户界面
那么 让我们开始吧
你可能想这么做的原因是
用户界面扩展能增加你的应用对用户的影响
通过引入一个用户界面扩展
你可以在Siri体验的基础上展示你的视图
然后 你可以融入自定义的体验
这些体验相对Siri通常显示而言对你的应用更为独特
这会给开发你的应用带来很多很好的机会
这些机会具有独特性能让你的应用脱颖而出
你还可以提供用户定制
让你可以跟用户一对一互动
最后 你可以显示Siri不会显示的信息
这是你的工具库里很好的帮手
还有 它长这个样儿
那么首先 你要做的就是添加一个意图用户界面扩展
把它加到你的项目里
并把它嵌入你应用的包裹里
你便会看到Xcode给你生成的Info.plist文件
在里面 你需要找到新的IntentsSupported关键词
和你在意图扩展看到的类似
在里面 你要设置一个意图
用它来在Siri体验中展示自定义的用户界面
用户界面扩展在SiriKit中的结构其实很简单
SiriKit针对你的用户界面扩展
用互动配置
这个SiriKit 用户界面扩展里很关键的方法
你的用户界面扩展有一个主要类
它是UIViewController遵循INUIHostedViewControlling协议
它会将一个INInteraction对象
在配置这一步赋给你的用户界面扩展
现正如Diana提到的那样
INInteraction类定义一个对象
它涵盖三个重要的属性
第一个是意图对象它要经过确认
或者被你的意图扩展处理
第二个属性就是
Intent response对象你的意图扩展把它传给Siri 通过
确认和处理的completion
最后一个属性是意图处理状态一个enum值
它描述互动的状态
是你的应用和Siri间的互动
这些实现起来都是非常有用的属性
对你给Siri制作用户界面很有帮助
你的视图控制器是操纵用户界面扩展的途径 它作为一个主要类
你要用到它来创建你的用户界面它作为
UIViewController子类
你就可以用你可能习惯用的所有UIKit的强大功能
就像创建Cocoa Touch应用的用户界面一样
接着 用“互动”对象给它配置
对象由Siri经“互动配置”传给你
此外 还有别的一些参数
在这个方法里可能值得你注意
其中一个是providedViewContext参数
而在iOS X里 这是一个enum值它在两个可能值中取其一
Siri snippet或maps card
所以你可以给你的界面进行不同的配置
针对这些模态视图跟用户间不同的互动方式
而且如果你要做一个订车扩展这个会对你很有帮助
最后
你会有一个completion你调用它来让Siri知道
你已经完成对用户界面的配置
你要返回一个desiredSize
告诉Siri怎样在Sirisnippet调节视图的大小
我想我们已经知道所有要知道的东西
示范如何给独角兽快信建立一个SiriKit 用户界面扩展
好
我们回到Diana给我们铺垫的这个很棒的项目
项目用到了我们的Siri扩展它让我们能将应用嵌入Siri体验中
我们在意图用户界面扩展上更进一步
当Diana创建她的Siri扩展对象时
我们可以配套创建一个意图用户界面扩展对象
Xcode建了个分组专门在左边这儿的
项目导航器建给Siri用户界面扩展
我们打开它
可看到一些很赞的文件让我们能开始编意图用户界面扩展
首先是IntentViewController类
它是我们扩展的主要类
还有给这个类的storyboard
以及Info.plist我们先来研究这个
用它来设定我们支持的意图
在这里面
NSExtension字典里有个IntentsSupported列表
我直接在这儿加一个条目
现在 关于意图用户界面扩餐我们想做的
是在Siri显示结果时给用户展示一个用户界面
用来给其他独角兽发信息
而当显示这个界面时
我们希望它是一个聊天记录界面
希望它能彰显我们应用的“独角兽性质”
所以在这里面 我要给INSendMessageIntent添加支持
声明我们要展示一个用户界面
在Siri给我们的应用处理意图时显示
好 编好Info.plist后
我们来实现IntentViewController
我缩小页面回来
这儿有我们的IntentViewController类
注意到这是一个UIViewController的子类
遵循INUIHostedViewControlling协议
既然遵循协议就要相应地对它进行配置
要用“互动”这儿程序把它作为模块提供给我
现在我首先要做的
是把UnicornCore框架作为模块导入我的Swift文件
值得重申的是这个UnicornCore框架
是我们给我们应用实现的框架
所有独角兽应用都用到它如Unicorn Pay或Unicorn Rides
这是给我们的应用和扩展共享程序的很好的方法
我们在Diana的演示中已经很好地用了它来共享
扩展中解析 确认和处理的业务逻辑
现在我们想用它来共享用户界面
针对我们的用户界面扩展和应用
以此达到我们会有熟悉感觉的效果
不论我们在哪儿发送独角兽快信信息
我们来开始实现“互动配置”方法
在这里面
我直接设置一个size变量
一旦我完成配置后就把它返回给Siri
现在我要查看interaction.representsSendMessageIntent是否为真
这儿的用法很方便因为我已把它实现为类扩展
以UnicornCore framework里的INinteraction为基础
然后 我建一个chatViewController实例
我们用它来代表一个信息发送界面
我们两个独角兽快信应用都用上
而且我们也要在我们的用户界面扩展这儿使用
我们来配置chatViewController
用“配置”的messageContent
我还是用类扩展从“互动”中获取它
建一个UCContact模型对象
它基于“互动”的属性
接着 我把模型对象赋给chatViewController
来显示信息的收件人
最后 我用switch语句
判断“互动”的intentHandlingStatus
我们可以以此对我们的用户界面进行不同的配置
以信息是否已经发送出去作为基础
比如在这个例子中如果信息未发送
即intentHandlingStatus是unspecified inProgress或ready
就把chatViewController的isSent设为假
这说明我应该设定一个草稿式界面显示给用户
否则 如果发送已经完成我可以将isSent
在chatViewController里设为真
表明我已经发了信息而且要让用户也知道
最后我就呈现chatViewController它是一个子控制器
其母控制器是这个IntentViewController主要类
这是一个很有用的方法
来实现不同的视图控制器
针对我用户界面扩展里的不同意图
最后
我可以用iOS X里用户界面扩展的NSExtensionContext
来得到一个最大的大小
然后我默认地把它用在我的独角兽快信里
如因某些原因得不到extensionContext
我就用chatViewController的desiredSize
它对我来说够好了
这是比较乐观的一种情形
假如什么出了错给我们意想不到的“互动”
我们可以设大小为0
让Siri不要在Siri snippet里画我们用户界面扩展的视图
好
我最后要做的
是告诉Siri我已经完成实现
和配置我的用户界面
这样它就会在Sirisnippet里给我们展示
好
我有这段程序的一个版本在我的设备上运行
我们现在来看看它是怎么样的
你可以看到我有独角兽快信应用
我准备发信息给Diana
用独角兽快信发信息给Diana说
“你的演示很棒！”
于是我们这儿有一个很棒的自定义用户界面
但你还会注意到有些东西不太对
我们现在来看看是怎么回事
我们刚给你们展示了
如何用SiriKit构建你的用户界面扩展
这非常好
但你会意识到
有些东西还是有点不妥
特别是我们在Siri展示给用户的用户界面
于是我们弄了一个复制版聊天记录界面
在Siri snippet里展示
默认地 Siri对不同意图都显示用户界面
如SentMessageIntent
刚用它在独角兽快信给Diana发了信息
同理 对于我们的独角兽快信用户 我们想做的
是真正展示我们的自定义用户界面
让用户们对“独角兽性质”比较好的感觉
就在他们用独角兽快信发信息时
我们在iOS X可以做到这一点用一个可选的新协议
通过实现INUIHostedViewSiriProviding协议
你可以让Siri知道
你在把信息还是地图画在
你的用户界面扩展视图
所以你可以选择显示
不同的特定内容到你的用户界面上
并代替Siri操控这个界面
最后 当你这么做了
Siri便会调节你视图的内容
所以你要确认画出来的这些属性准确
代表了用户意愿
我们来看IntentViewController
我们刚在我们的用户界面扩展里用了它
你可以在这儿看到
如果我们实现INUIHostedViewSiriProviding协议
我们就可以实现displaysMessage属性并返回真值
告诉Siri我们正在独角兽快信显示信息内容
而这就是实现你自己的用户界面所需要的一切
在Siri里面
我们来看看这个在设备上运行的效果
我设备上有这个应用的一个一模一样的版本
我们回到我的设备上
我们来发另一条信息给Diana
用独角兽快信发信息给Diana说
“用独角兽的蹄子很难打演示的代码”
现在我们看到跟我们预期一模一样的界面
也跟我们想展示给用户的一样
我们的界面不会被Siri默认显示的界面所阻碍
这给我们一个很好的窗口来展示一个自定义的用户界面
来真正反映我们应用的“独角兽性质”的画风
现在 我最后分享一些点子
在我们今天离开之前再谈谈用户界面扩展
我想首先留给你们的
是你对待用户界面扩展时应注意考虑存储量
因为扩展是默认为暂时性的
仅仅在很短时间内展示给用户
所以系统有一个强制的比较低的存储量限制
比你在你一般的应用里可能习惯的存储量还要低
所以像MKMapView这样的视图用起来特别耗存储量
在建立你的用户界面扩展时你们要谨慎地使用这些视图
正如我们所看到的我们可以获得最小和最大的视图大小
在用户界面扩展里通过NSExtensionContext获得
这会对你特别有用特别是当你设计你的应用
而你的用户界面扩展要在很多不同大小的配置下显示的时候
但你返回给Siri的desiredSize正是你想要的
你想要的大小
所以 如果你要用不同的布局
你要确保你的程序有很强的适应性
无论如何它的外观都不错不管大小是最小
还是最大不管Siri怎么画它
总之 我们看到了几个关键点
关于延伸我们的应用来适应SiriKit
而首先要做的就是妥当地准备好你的应用
通过很好地利用共享的程序
比如嵌入框架还有实现单元测试
来正确地测试 Siri可能传给我们的不同的意图
并且规划好我们的应用来使用合适数量的扩展
我们解决了添加第一个意图扩展的问题
并实现了解析确认和处理的业务逻辑
它让我们的应用跟Siri实现很好的对接
最后 我们展示了如何在Siri里提供一个用户界面
来将我们应用自定义的独特体验融入到Siri体验之中
我们这个展示会的样本代码
以及关于SiriKit的幻灯片和一些很棒的参考文档
都会公布在我们的网站上
而且我们昨天也有一个很棒的会
叫“SiriKit入门”
我们谈了我们对SiriKit的期望以及如何将它融入iOS
我们也有关于应用扩展最佳实践的一个很棒的会
是WWDC 2015里的会我强烈推荐你们去看
特别是如果你想实现SiriKit扩展
我希望你会觉得实现你的SiriKit扩展
及你的应用能像我们实现独角兽快信一样简单有趣
谢谢