Swift Foundation的新特性
谢谢
大家好 欢迎我是Tony Parker
我在Apple带领Foundation团队
今天我在这里和Michael LeHew一起讨论
Swift Foundation的新特性
这一年来Foundation团队付出了很大的努力
改善你使用Cocoa的方式
以及Swift中Cocoa Touch的API
从Swift API设计指引开始
随后 我们研究了所有Objective-C的代码
包括Cocoa SDK使用及你自己编写的代码如何引入Swift
但是我们知道我们可以做到更好
所以 我们引入了一套新的值类型到Foundation里
同时也引入了大量很棒的针对Swift的新API
我们继续从设计指引开始
我们今年的工作围绕着Swift 3 但是
我们最初设计Swfit的目标一直没有变
我们希望你编写的代码快速 安全 表达性强
我们创建了标准库
以及围绕这些核心思想的编程语言
你们很多人也都理解了这些原则
并且根据它们建立了自己的应用程序
但是 我们都知道还有另一部分内容没有提到
那就是Cocoa SDK
你的程序也非常依赖它
甚至对它的依赖要大于Swift标准库
它需要看起来属于同一个生态系统
因为SDK在这里至关重要
有关我们如何在自己的平台上开发应用
让语言和库相互合作至关重要
所以今年我们专注于表达性
我提到表达性这个词时有两层含义
第一层意思指的是你作为应用作者的能力
你编写的Swift代码能把你的意图
传达给编译器和库
但它还有另一种意思
库需要能表达它们自己的目的
它们的设计模式
以及它们对于如何让作为应用作者的你能最方便地使用API的想法
所以在研究指引的时候
我们注重一致的体验这一概念
有关指引的决策都基于这一概念
语言和库密不可分
它们必须协同工作
举个例子库带来了一堆新的特性
很多你看到的今年我们新版平台上的特性
都源于库中的新特性你也可以把它们用到自己的应用里
提升你的开发体验
这些库在我们所有的平台中都有广泛应用
包括今年新的Swift Auto ARC和Swift Open Source
我们有Swift CoreLibs Foundation
把大部分FoundationAPI移植到其他平台 如Linux
这些库的实现经受得住考验
其中很多自OS X时代就已经存在了
有些甚可追溯到更久远
得益于Cocoa命名指引它们还带来了
一套悠久传统
这意味着当你看到一套新的API时
你马上就能明白它的工作原理以及功能
最后重要的一点是
这些库在不断更新中
除了添加新的特性
我们还在改进 修复漏洞 等等
每年发布新系统我们都会继续这样做
另一方面 Swift语言
带来了一些Objective-C所没有的特性
比如 对泛型的第一类支持
以及内置的对可变类型的支持
这些都是Swift语言安全性的重要部分
其中包括协议扩展
函数重载 以及默认参数值
这些都对如何设计Swift的API有着重要的影响
这个清单两边都没有列全我没有足够空间
可以提到的还有很多
所以我们提炼了三份关键文档
第一份是SE-0023API设计指引
所有文档都发送到了SwiftEvolution邮件列表
给你和Swift社区
一个机会参与到语言的设计和进化中
我们把这些指引视作统一的文档
无论是现在还是将来的Swift库
此外我们还有SE-0006
将这些设计指引用于标准库
提供了一套一致且可预测的原语集
我们可以把它们作为基础还有SE-0005
它大幅提升了Cocoa SDK的表达性
通过引入默认参数值
改进可选集以及编译属性
甚至在一些情况下自动采用协议
有一期关于此的演讲
你如果没看过的话建议你去看看
Swift API设计指引
这些已经算得上巨大的进步但我们知道 还可以更进一步
因为Swift的目标不止于其名
可变性是这门语言至关重要的一部分
所以我们把目光聚焦于Foundation
若你在想为何选择Foundation？
答案是它比较特别
我这么说不是因为我的工作是关于它的
Foundation在SDK中处于一个特别的位置
它的层级足够低
适用于任何我提到过的平台
但与此同时它的层级又足够高
足以建立一整套通用类型和设计模式
同样你会发现它会反映到整个SDK
我们回顾一下刚才的图片放大这里的Cocoa SDK
你会发现很多应用的日常开发中用到的框架
从UIKit到SpriteKit从WatchKit到CoreData
还有很多其它不适合放于此的Cores和Kits
有趣之处在于
所有这些都建立在Foundation的基础上
因此将Foundation<c.magnenta>视作一杠杆点
在Foundation里的一小点改动
会对整个SDK产生巨大的影响
一定程度上由于很多数值类型出自Foundation
所以我们注重进化胜过彻底改变这一观点
我们看到了标准库为你的应用开发带来的所有东西
我们不会因为新语言而摒弃已有的一切
我们做的是让语言和库更加紧密
通过同时改进双方
我们今天谈论的正是这一过程的延续
把这一点放在心上Foundation团队
在Swift Evolution邮件列表提出了两个新的提议
第一个是Foundation中数值类型的可变性
把Swift的可变性模型
应用到Foundation框架上
另一个是抛弃SwiftFoundation里的NS前缀
为Swift建立通用类型和设计模式
以适用于任何平台
这是我们今年对API做的一些改进的概述
第一点最重要的是数值语义
一套全新的数值类型在整个SDK随处可见
此外我们对命名进行了些改进
超越了Objective-C翻译成Swift能做到的
我们让这些类型采用了很多标准库协议
这意味着你的通用算法现在同样适用于Foundation类型
我们额外添加了类型安全性以及很多针对Swift的新特性
我们来快速浏览一下数值类型
数值类型和引用类型不同
主要区别于复制时的行为
数值类型在赋值或作为参数传递时会复制它们的内容
举个简单例子我有一个点
我用等号把这个点赋值给另一个点
当我修改第二个点的时候你可以看到 只有副本改变了
我没有影响两个点的内容因为CGPoint是数值类型
另一方面引用类型默认共享内容
这里我用引用类型创建些数据它们是可变数据
同样用等号把data赋值给otherData
然而这一次当我修改第二个数据的时候
你会发现它影响到了两个数据的内容
重要的是要理解这两者没有好坏之分
只是使用方式不同
我喜欢把它们看做工具箱中的不同工具
当你需要解决某个问题时可以使用它们
所以当你试着决定
你的类型是数值类型还是引用类型
你应该从对象身份和存储内容考虑
我举几个例子来解释
Foundation中有个叫OperationQueue的类
OperationQueue中有一个单例叫main OperationQueue
这个mainOperationQueue
用于放置你希望在主线程上完成的工作
所以它只有一个这一定程度上代表了身份
若我能复制main OperationQueue它就不再是主队列了
所以我们相信OperationQueue是一个引用类型
另一个例子 Cocoa SDK里随处可见的一种模式就是代理
这是一个代理或者说是URLSession的代理之一
你会发现这个代理协议有一个参数 就在这儿
名叫Session它告诉被委托的对象
它将以哪个URLSession的名义工作
这里的哪个URLSession同样暗示了身份
所以我们相信代理使用的类型通常是引用类型
从另一方面 很多类型的重点在于它们存储的内容
比如Date
这是我们新Foundation数值类型之一
Date是一个绝对的时间点
我们可以有两个具有相同值的Date
同样的绝对时间点它们是同一个Date
我们不需要讨论那个时间点的引用
如果我们查看Date的实现
正如你所见其实它只是个Double
Double我们可以本能地认为是一个数值类型
另一个例子就是Data
Data是另一个新的Foundation数值类型
Data 通常情况下你关心的是Data的内容
它所包含的字节而不是NSData对象
所以Foundation把Date设为数值类型
每次我们把它作为参数传递时都需要复制数据
很快开销会变得很大
所以我们进行了一种优化叫做写时复制
这里我建立了一些数据
看到我建立了一个Struct
但是在它内部还有一个引用
又一个合作提高效率的例子
我同时使用了引用和数值
来得到我想要的性能特征
以及重要的数值语义
如果我用等号把这个数据赋值给另一个数据
你会发现我得到了另一个Struct
但其实在内部它们还是指向同一个类
但是如果我修改这个数据那我们就需要复制数据了
修改副本我们就有了两个独立的Data
如果我继续修改第二个数据
我们可以断定Data各有独自的引用
而我们也不需要每次都去复制它
这是一种扩展 或者说其实就是同样技术的另一种使用方式
这个技术我们以前谈论过包括去年谈到的
在Swift里构建更好的应用和值类型
如果你想了解更多它的工作原理可以去看看
所以我们调查了Foundation里每一个API
总结出了这份列表我们认为它们作为数值类型很棒
你会很高兴看到很多你平时使用的类型都在列表上
包括我刚刚提到的Data和Date
还有很多别的常用类型比如URL
IndexPathCharacterSet 等等
它们当中很多不只是变成了数据类型
还增加了很多很棒的新API
为了让你们了解它们是什么样的我想有请Michael上台
谢谢你 Tony
咱们先看看Foundation枚举类型的新家
Objective-C里的枚举
以及选项集合生存在全局命名空间里
和使用它们的类型在一起
比如NSNumberFormatter定义了四个枚举
包括样式、行为、填充位置以及舍入模式
它们和NumberFormatter有一定暗中的联系
通过严格一致的命名传统
在Swift 2中 你也知道它们同样在全局命名空间里
但这就感觉不像是纯粹的Swift
Swift支持嵌套类型
所以在Swift 3里我们决定改变这些类型的位置
在它们注定应该在的地方进行声明
现在NumberFormatter拥有内置的样式
行为、填充位置以及舍入模式类型
它们的名字不再繁冗
这极大程度减少了
Foundation在顶级命名空间声明的类型数量
关系也更加明确
我们的API表达性变得更强更易被发现
还是关于枚举这个主题
很多Foundation API也使用字符串常量家族
比如Notification Name和URL Resource Key
Swift支持建立在其它原始类型上的枚举类型
可以是整型以外的类型包括字符串类型
若我们在Objective-C里也能做到这些岂不更妙？
今年 我们可以了常量现在被定义成了
类型非常具体的字符串常量
如Notification Name及URL Resource Key
以及很多很多别的
这些常量保留了可扩展性无论在Objective-C里
还是在Swift里
我们都可以对它们进行嵌套就像对待它们的兄弟整数类型一样
这样在Swift 3中使用它们非常自然 表达性也很强
另一个常见的Foundation设计模式是把状态和类型联系起来
比如standardUserDefaults
Swift对于类属性的支持可以很好地适用于这里
今年我们把类属性引入了Objective-C
它们的定义和对象属性一样
除了现在我们支持这个酷酷的类别关键词
由于我们知道它是类属性
我们不需再像Swift 2.2那样把它作为函数引入
它现在可以作为类属性出现
如同你会在Swift里定义一样
但我们没有止步于此
有些累赘的词在Swift 3中
我们彻底修改了Swift代码的显示方式
以及Swift里Objective-C代码的显示方式
所以我们的最终API更像这个
我们知道它是userDefault通过帮助把Foundation
变得更像Swift我们获取了很多好处
无论是对于Objective-C还是Swift
Tony刚才说很多Foundation类型值得变成数值类型
我谈谈其中的一些我们从Date说起
假设我们要安排一条备忘录
提醒我们什么时候该回家
我们从Swift 2.2开始引出我们的例子
假设我们有一个函数它会告诉我们什么时候应该回家
我们调用它五分钟看起来正适合我们的提醒
我们继续 你知道的把它偏移一点
有一点值得说明 NSDate是且一直会是一个引用类型
所以在这里实际隐藏着两个动态分配
一个在这里另一个在这里
在Swift 3里我们可以使用Date数值类型
所以现在我们就来使用它用法和原来类似
但是这个变量的行为和以前大不相同
特别地 我们允许内联修改
我们没做额外的事情
这两个例子做的是一样的事
除了对于数值类型我们不需要额外进行动态分配
继续我们的例子
当然了我们也可以这样内联
关于提醒事项只有把它安排在事情发生前
才是有意义的
Swift带来的最棒的是
满足某些条件时协议会自动被采用
在这个例子里Date自动遵从了Comparable协议
它赋予了我们使用小于号的能力我们现在就在使用
我们可以设定定时器但首先我们要创建它
我们要使用另一个今年的新API
就是这个看起来很棒的基于闭包的定时器API
我们用一个闭包初始化定时器
不再需要selector和target了
我们把它安排在主RunLoop上
我相信线程和RunLoop也有这样的方法
把它安排在主RunLoop上然后就完成了
这是个绝佳的例子 它展示了所有熟悉的Foundation API是如何
如此优雅地移植到Swift 3里的
这是我能在演示里展示的最具Foundation特色的代码
我有个RunLoop一个定时器及几个日期
基本上全是Foundation的内容极少的其他内容
看不到任何方括号
另一个新例子或说Fondation里另一新类型
Measurement数值类型
假设一个新例子我们关心上下班线路有多长
而且我们很幸运我们住的地方距离上班的地方
只有两条短街之隔
Measurement是数值类型并且Swift支持运算符重载
它们不仅仅是数值类型
它们还是Mathematical类型所以给它们设置运算符有实际意义
没人会轻视它或不待见它
如果我们考虑把它们加起来
我们就可以计算出它们的总和甚至对它们进行转换
转换成另一个单位
假设我们很好奇想知道去工作路上要花费多久
这个我们也能做到
只是在Swift 3里如果我们试着编译这段代码
它会失败的而且是在编译的时候失败
得益于Swfit 3中泛型和类型限制的能力
我们设计成让单位的区别
在编译的时候就可以看出来
Swift编译器可检测出然后提醒我们
我们正在进行无效转换
想了解更多Measurement类单位以及今年新引入类型的
整个新的生态系统的话记得去收听这场演讲
在周五下午 了解更多Measurements和单位
换一个例子
我说过这将是一场探索
假设我们想买几台MacBook
会使用新URLComponent数值类型
可以表达性很强地做到
从描述可变部分开始
把它作为下面的模板
遍历我们想要购买的产品
复制我们的模板然后修改这个副本
指定我们想要买的产品
在这里我们可以放心地展开这个可选类型
因为在我们的模板里把它设为了非空
继续把我们的URL打印出来我们发现可以
不进行任何内存管理创建我们想要购买的产品的链接
只需声明我们的意图指明是否可变
然后语言就会为我们处理好剩下的事
Swift 3 或者广泛地说Swift带来的另一个特性
是ProtocolComponents在很多Foundation类型中 比如Date
得到了有用的新能力这得益于新的遵循协议的方式
比如CharacterSet和IndexSet现在遵循SetAlgebra协议
你可以对它们进行并集交集 对称差集操作
根据你的需要
Data现在遵循8位无符号整数的
MutableCollection协议和MutableRandomAccessCollection协议
就像你一直认为的那样
我们来看看遵从新的协议后Data现在能做些什么
首先需要一些数据我手头上有一些Base64数据
通过普通的初始化函数进行解析
这里有个显式展开我知道这么做是安全的
因为这里只是个演示我知道它是有效的Base64值
你自己使用过程中可能需要用到try语句
我喜欢统计以及看起来很棒的图表
当你的统计用直方图的形式表现时我们要来建立一个直方图
我们需要用到后台存储使用原始的Swift数组
把它全都初始化为0
我们把data里每一字节的值作为索引
然后维护一个频率计数
由于Data是一个Collection 遍历它的字节
很自然且表达性高我们可通过一个for-in循环做到
接着我们创建直方图来看一看
这看着绝对像直方图
就像所有直方图一样里面有信号和噪声
我在这看到了不少高频率数据
我想要把它过滤出去
幸运的是Data现在是Collection了
所以我们可使用到类似Map、Reduce、Filter的功能
以及其他你喜欢的Collection函数
假设我们想要剔除所有大于三的数据
就如同声明谓词一样简单
然后我们可以就生成过滤后的数据了
作为一个CollectionData是可切分的
这些切片功能上和MutableCollection一样
或是你在Swift里见到过的数值类型Collection
修改它们会触发同样的写时复制机制
正如Tony刚才描述的它们的运行方式完全相同
Data还保留了可扩展性
通过继承隐含的引用类型
这是很重要的一句话我会详细讲个例子
来解释我的意思
举个例子 我们先创建一个自定义的NSData子类
不给它分配任何存储空间
代表一个虚拟的全是1的Collection
我们将它名为AllOnesData 描述性很强
这里我只展示一个方法的实现
获取指定的字节getBytes多少可以实现这个类期望的功能
我们把所有字节设置为1
不需要储存任何东西
接着我们创建一个它的只读对象
我们不会单纯地使用引用而是会建立一个数值类型
并把引用包含其中
我们使用了刚刚创建的新的初始化方法
它和你预期的效果一样
现在我们的ones数值类型指向全是1的数据的引用
它们是虚拟的
现在不会在内存里占用字节
现在我们来创建一个可变副本同样 我们不做任何修改
所以我们现在不需要分配或管理任何这些内存中的字节
我们准备好对bytes进行需改为了做到这一点
要用到一个今年新添的Foundation API
它是一个ScopedPointer Accessor
叫做withUnsafeMutableBytes
这比直接对data本身调用mutableBytes好得多
因为我们把对这些字节的访问限制在了
我们定义的闭包内
这很好理解
没有漫天乱飞的指针
指针只在这个小的访问器内部有效
我们实际进行修改引起写时复制机制
现在这些字节
这些复制的字节真正是可见的内存了
接着下一个例子我厌倦谈论Data了
我们来说说URL以及URL属性
为了说明这个例子
我想先说一说在Swift 2.2中我们是怎么做的
在Swift 2.2我们会请求NSURL.fileURL
以my-special-file为例
这个文件太特殊了我把它放在我的文件系统的根目录
我对三个属性很好奇
我想知道创建日期它是否是常规文件
以及出于某些原因这个文件所处卷的最大文件大小
这些在Swift 2.2只是字符串所以这只是个字符串数组
而且当我向我的URL请求资源值的时候
只会得到个普通的字典类型不包含任何类型信息
它只是字符串指向对象这意味着使用它时
需要用到很多as某个类所以我必须
暗示说它是布尔型暗示它是整数型
我一直在不停检查引用值来确保我做的是对的
除此之外修改只是针对字典类型的
所以你可以做类似这样的荒唐事情
并且每一个错误都是运行时错误
我们来看看Swift 3的改进
在Swift 3中建立URL的过程也很类似
但是我们不再使用类工厂方法
它变成了普通的初始化语法
我们现在谈的依然是my-special-file
我们不再请求字符串数组
而是使用强类型的字符串枚举
正如我之前说的一样我们要创建它们的集合
当我们向URL请求资源值时
我们得到的不再是个字典
我们会得到一个值一个新的Foundation数值类型
我们看看这个Foundation值的类型是什么
针对我们请求的三个属性
你可以看到creationDate是一个Date
isRegularFile是一个Bool
volumeMaximumFileSize是一个Integer
而且还有一点需要指出的是
URLResourceValue结构本身是惰性的
它仍然是用字典实现的
正如Swift 2 API一样没有必要
这个巨大的Struct会消耗内存
我请求了三个东西就会得到三个东西
如果你有自定义keys字典还是在那里
你请求的不是字符串而是你所感兴趣的
URLResourceKey
你可能注意到有很多问号
原因就是 恩其实有两个原因
第一个原因是你并没有请求它
所以这个创建日期就不存在
这涉及到数据的稀疏性
第二个它不存在的原因是
就是属性本身可能是无效的
volumMaximumFileSize就是个例子
我们来看看两个关于工作原理的例子
因为我们请求的是普通文件
我们完全可以显式展开这个Optional值
它会出现在此因为我们请求了它
然而 VolumeMaximumFileSize的文档里面说到
不是所有的卷或所有的文件系统
都支持最大文件尺寸这个属性所以它可能并不在那儿
这是Swift里使用if let结构的绝佳例子
有条件的设置局部变量
现在咱们说说修改
当然URLResourceValues中URL的修改API
与它新的值类型相关所以当你尝试这么做的时候
尽管这是我的特殊文件
我非常努力地说它不是常规的
编译器会在我编译的时候就会报错
而不是让我自己在运行时发现这个问题
更进一步 文件创建日期也是强类型的类型为Date
如此荒唐的事 在Siri那可能行得通但写代码的时候是不可能的
关于Foundation的探索我最后想说的一点
就是Swift的原始枚举类型
然后我们又要再一次谈谈数据了
因为有个例子真的很不错
当data拥有一个UnsafeMutablePointer时
你可以选择设置一个deallocator
Data默认支持多种类型
包括自定义deallocator
现在 Swift支持把值和枚举相关联
你经常会看到这些和整数关联
你可以在case表达式里使用它们这样你就可以
用它们做一些很酷的模式匹配但这里我们接受的是一个闭包
因为我们想把你提供的行为包含其中
我们来实际做一下
我们从一个简单的malloc例子说起
在Swift你依然可使用malloc
尽管你在演示中不常看到它
使用malloc分配内存当你把这个指针指向Data时
你可以把deallocator设置为free
语法和使用集成值一样简单
我们再看一个自定义的例子
假设我们有一个函数create_glorious_pointer
我们想光荣地释放它
以免它们受到冒犯
设置自定义deallocator非常简单只需提供一个闭包
并且确保你进行了想要进行的操作
这非常强大
对于框架开发者来说也是一个很强大的概念
因为在别的语言里 我们不得不
提供另一个基于函数指针的API
但在Swift 3里我们可以直接提供基于枚举的API
它可以简洁地表达所有内容非常有表现力
至此我们的API探索之旅结束了
但愿我们见到了不少奇妙之处
现在让Tony给大家详细讲讲Adoption
谢谢 Michael
现在你对于可能做到的事情有了一点大致了解
我们来谈谈如何在你的应用中使用
咱们先来讲讲桥接
在这个主题上我们不断迭代更新
我们把Swift 2里面的一些你已经熟悉的概念进行了扩充
用于桥接Objective-C和Swift
如果你理解String和NSString是如何桥接的
我们把同样的概念应用到了Data和NSData上
以及你看到的这里所有的数据类型
这就表示所有从Cocoa SDK引入的API
都会使用这些新的数据类型
这就是我们形成杠杆的核心思想
例如 在Swift 2.2的AppKit中
你能看到这个类名叫NSDatePicker
它允许我们展示一个UI并让你的用户选择日期
除去其他属性它有两个能够控制日期的属性
你能在这里看到它们被标成了@NSCopying
它们是NSDate引用类型的
在Swift 3不改变AppKit前提下
我们只改变了Foundation这个类现在看起来是这样的
你看 我们现在有Date结构类型了
而且我们不需把它标作@NSCopying了因为他们是数值类型
我们会帮你进行复制
进行桥接可能会有一定的性能折损
为了介绍原因我需要深入讲解一下具体细节
桥接的原理究竟是什么
桥接有两个主要策略一个针对大型类型
它会存储引用另一个针对小型类型
它会创建引用
举个例子我们再讨论一下数据
我又创建了一次data
它是一个结构体包含了一个引用类型数据
若调用Objective-C的API
将会发生的是 我们把引用交到Objective-C端处理
因为Objective-C不会处理结构体数据
它只能看懂NSData
在这个例子里也许对于同步方法调用
Objective-C的代码在任何时间都不会持有这个数据
它可以访问它随后就忘记它
仅仅保存一小段时间引用即可
你会看到许多API会长时间持有数据
通常会被标注上Copying属性
那样 在Objective-C中
Objective-C代码会调用数据的复制方法
因为它需要保护自己
以免潜在的对于原始数据的修改
从一个完全未知的来源
这意味着 当发生桥接时可能发生数据的复制
我们把它翻过来看
这里是一段Swift代码它调用了Objective-C方法
并获取返回的数据
这里 Objective-C代码创建了NSData类
当它回到Swift的时候
我们建立结构体数据并把引用包含其中
然后调用复制方法原因和上一页演示文档说的一样
这个结构体需要保持它对这份副本的控制
这样它才可以向你提供正确的语义
幸运的是 基本上所有通过这个方式接收到的来自SDK的数据
都是不可变的
这意味着 这份副本在本质上只用于保持计数
但是有一点很重要需要明白
当桥接的时候可能会出现复制操作
对于小的类型 比如Date你会发现并不存在引用
我们刚才看到了它的实现只有一个Double
所以在Swift里 若我调用了一个Objective-C的函数或方法
它接受一个Date 我们需通过桥接分配一个NSDate
那是因为Objective-C代码只知道如何处理引用类型
在Objective-C方面我们采用了很多技巧
使NSDate分配的开销很小
这点很重要 我们要明白桥接的时候会产生内存分配
所以我们优化了这些数据类型以适配Swift
在你的编码中你应该避免来回桥接
这是因为我们想让我们的编码默认是安全的
但是它确实说明在这里可能有潜在的复制操作
这是使用新的数值类型时需要注意的几点
现在咱们来谈一谈迁移
先来说说好消息
我们今天说的新类型适用于所有Swift部署目标
这些都是Swift标准库的一部分
所以你不需要等待客户
升级到我们最新版本的平台
一旦Swift 3和Xcode 8发布
你马上就可以使用它们
现在 为了帮助你我们升级了Migrator
这就代表当你打开Xcode 8里你的项目
你会看到一个类似这个的对话框我建议你点击Convert
我来展示一下Migrator可以帮你做的一些事
现在我们在Swift 2.2中有一些NSDate
我们调用它的dateByAddingTimeInterval方法
Migrator会把NSDate这个引用类型
修改为结构类型的Date
然后它会改变方法
因为它们已依据最新的Swift 3API设计指引进行了修改
无论是针对引用类型还是数值类型
我们再来举一个例子
我在Swift 2里创建了一个NSDateComponents
然后对它的属性进行了设定
我能做到这些是因为NSDateComponents永远是可变的引用类型
Swift 3里引入了新的结构体DateComponents
所以Migrator会把引用变成结构
但是它注意到你对它进行了修改所以它还会帮你把let改成var
Migrator可以帮你做很多
但有些地方如果你检查一下它做了什么
你自己可以做到更好利用我们提供的新功能
该例中DateComponents有一个新的initializer
这我们只能在Swift里做到
这个initializer为 DateComponents里的每一个属性提供了参数
这些都不是必需项而且都有默认值
你可只利用自己在乎的值创建DateComponents
比如这个例子里只提供月和日
然后把var变回let
因为初始化后你不需要改变它
最后又要说到我们的朋友Data类型了
Swift 2里我建立了一个NSMutableData
它是一个引用类型然后我给它添加了一些数据
在Swift 3里Migrator会处理好方法名称
比如contentsOfURL以及appendData
而且它会把NSData变成Data结构
但是 它没有处理NSMutableData引用类型
有些情况下 信息量不够
Migrator没办法做到我们认为最佳的选择
我们不去管它它依然能正常运行
但是如果你回去自己做一些修补
你可以做到些很酷的事情
我们可以把MutableData变成Data结构
即我们把它从let改为var
还可以删除掉options参数因为它现在已经有默认值了
我们今天谈了不少东西现在让我们来稍微回顾一下
相信这些对Foundation的改进
会让整个SDK受益
并提升你的整个Swift开发体验
一方面是由于API重命名
另外我们把握住了机会更进一步
添加了一套全新的数据类型以及很多针对Swift的新API
我们将此视为一段旅程的开始
并且在未来我们也愿意继续成为支点
我们要做很多改进
让你的Swift应用更安全 更迅速 表达性更好
有兴趣多了解的话去查看下这个URL结构
以及这些相关演讲 包括
使用Swift Open Source深入服务器端Measurement类型和Unit类型
谢谢大家