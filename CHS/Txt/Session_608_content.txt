GameplayKit的新特性
大家早上好
我是Bruno Sommer
我是Apple的游戏技术工程师
“GameplayKit的新特性”
去年 我们介绍了GameplayKit
是Apple的一个高级游戏框架
GameplayKit是一个集合
包含一些常用的架构模式数据结构和算法
这允许我们的开发者开发很棒的
引人入胜的玩法在他们开发的游戏中
GameplayKit作为你的工具箱
为了很棒的游戏体验
所以不管你要开发什么类型的游戏
不管它是游戏平台还是RPG或城市建设者
你总可以在GameplayKit中找到能方便开发的东西
并让你的游戏更加健壮
去年我们引入了GameplayKit
它由七个主要系统构成
比如实体和组件 状态机
以及我们的游戏质量无规源
今年 我们在寻路 代理和游戏AI方面进行了提升
还向GameplayKit中引入三个新的主要系统
我们有一个很强大的区域分割系统
这将允许你获得很好的表现
在游戏的运行时查询中
你必须有一个很强大的过程生成系统
来制作引人入胜的运行时内容
今年 我们也集成了
GameplayKit在Xcode游戏编辑器中
所以许多曾经只能在代码中使用的工作流
现在可以直接在数据编辑器中使用不需要重新编译
所以我们今天内容很多
我打算直接说寻路中的新功能
去年 我们介绍了障碍物图
这些是我们的图类型它们负责处理
你的游戏世界中不可同行的障碍物的集合
在名字之下 我们使用了一系列视野算法
来在障碍物之间绘制可通行区域
现在这个方法很强大
它生成了质量很高的路径
但是对较大的游戏世界而言
以及障碍物数量较大的游戏世界
计算过程强度很高
在计算并保存结果时
所以今年 我们提供给大家另一个选择
我们要引入GKMeshGraph
现在 这很类似我们的障碍物图
再一次 我们要处理游戏世界中不可通过的障碍物
但是现在我们不再使用视野直线来计算可通行区域
在这些障碍物之间
我们要将这个区域分成三角形
我们由之计算出一个三角形网状图
这样每一个可通行的点
在你的游戏世界中由仅仅一个三角形代表
这个新的三角化方法一样会生成很高质量的路径
而且附加好处是计算起来很快
保存起来成本很低尤其是对很大的游戏世界
此外 它的灵活性很高在计算节点
应该处在网状图的哪个位置时
你可以把它们放在三教中心三角的定点上
与三角形的边上以及所有存在的组合
让我们看一个小代码示例
展示GameplayKit中用网状图的样子
你们会对它的样子很熟悉
和曾经的障碍物图相较
它们都在以不同方式解决同样的问题
在这里的最上端我要制作我的网状图
我要传入的缓存半径为10
这里的缓存半径关联于你的代理的尺度
它们负责在你的世界中进行寻路工作
我们要手工的在后台提高你的障碍物的尺寸
来弥补代理尺寸
现在我要传入两点(0, 0)和(1000, 1000)
这是我的网状图要代表的游戏世界的跨度
下一步 我要设置我的网状图的三角化模式
这就是节点放置的灵活性所在
即我刚才所提到的
现在我要具体地将节点放在
三角形的定点上以及三角形的中心
最后 我们要将障碍物集合添加到网状图中
我们有一个障碍物集合与我们的游戏世界关联
而后我们要调用三角化
这会将这些障碍图托付给图
它负责运行背后的三角化算法
而后就完成了
这个图已经可以在我们的游戏中进行寻路了
除了我们的网状图之外
今年我们还介绍了寻路中定制节点类别
我们的一些图会自动的实例化它们的节点
这就是我们的格子图障碍图和网状图
在实例化的时候
你可以选择指定一个自定义节点类别来让它们实例化
这将会大有用处如果你需要附加任何自定义数据
或逻辑在你的节点上这有时会很有用
取决于你想要制作的游戏
我们要调用合适的init()
在我们生成了我们的原始节点类型时
还有 这些所有类型的图现都支持Object-C和Swift属性
所以你在访问自定义节点时不需要类型转换
这就是今年寻路中的新特性
现在让我们继续说说代理中的新特性
说些GameplayKit中有关代理的令人振奋的事情
他们是自动运动的实体
被一系列的目标和行为控制
它们也被一系列现实的物理限制所局限
比如速度 质量 躲避障碍和寻路
在此右侧 你看到一系列目标
供你使用 来达到你在你的游戏中想要的行为
比如寻找与躲避或者漫游与逃跑
原来 代理是纯2D的
今年 我们很激动地宣布我们要将其带入3D
相关类叫GKAgent3D
用户界面与2D的变形很像
主要的区别在于其位置是三个浮点
旋转也是三阶矩阵流
所有的目标和行为都被支持
有关这次改变要提到几点
我们改了GKPath来同时支持2D和3D点
考虑到遵从路径的目标
考虑到躲避障碍物目标中的障碍物
如果你要使用3D的障碍它们依然存在于一个平面上
所以你要选择一个平面对你的游戏有意义
除了将代理带入3D以外
今年我们还引入了行为成分
我们引入新类GKCompositeBehavior它是GKBehavior的子类
这是一个行为的加权集合
这和刚才行为与目标的关系很像
行为是一个目标的加权合集
它是完全可嵌套的所以你现在可以完成
很有趣的嵌套行为在你的游戏中的行为
这也使得它们更易于维护尤其当你在完成
你的游戏中的很多的行为时
让我们很快地看看代码示例关于实际情况下的行为成分
在这里的最上我要创建一个群聚行为
通过结合队列 黏合与分离这三个目标
下一步 我要些障碍物和敌人添加到游戏中
我需要我的代理来躲避
我们要制作一个躲避行为
通过结合avoidObstacles和avoidEnemies目标
然后我要结合这两个行为成为一个新的合并行为
很高效地合二为一
最终 我要制作我的代理
我要将我的组合行为设置为代理的行为
现在可以运行了
下一次我们更新这个代理时它同时会正确地尝试
来达到这两个子目标或是子行为
这就是今年代理的新特性了
让我们继续说说我们的全新空间分割系统
先介绍一点空间分割的背景知识
可能对你的游戏很重要
经常在我们完成高级游戏编程时
我们会问好多有关游戏世界的空间问题
比如 有多少敌人离玩家较近？
或是 在我的世界中所有的物品都在哪里？
或是在这一帧中哪个抛射体会击中玩家？
尤其对于更大的游戏世界
或是有大量游戏物体的游戏世界
回答这类问题可能开销很大
在游戏编程中 我们往往加速这一类的空间查询
通过使用一种叫空间分割的缓存
总览我们所提供的
在我们的空间分割系统中
这是一个树状数据结构集合 能让你
基于空间缓存游戏物体
你将物体添加到这些树状数据结构中
它们在底层会聚集为层级与桶
然后未来查询这些物体时效率就会高得多
今年 我们引入了三个这样的数据结构
供大家进行空间划分所需
我们有R-trees、quadtrees和octrees
让我们深入这些数据结构分析
先说R-tree
R-tree是一个树状数据结构
内有一系列的层级桶
每当你向一个R-tree添加一个对象时 它会进入其中一个桶
所有这些桶都附带一个包围盒与之关联
它是该桶中所有的子对象的包围盒的总和
R-tree有一个特定的规则
每当这些桶变得太大时就需要被分割
这些桶的最大尺寸是一个由用户配置的参数
我们还有一系列策略供使用
来决定这些桶应当如何分割
我们可以很简单的分割或是尝试进行线性优化
与二次的距离或是尝试降低桶之间的重叠
我将给大家一个很快的视觉样例
关于构建简单的R-tree是什么样子的
比如说 我有一个太空游戏里面有一些宇宙飞船和小行星
我要将一个宇宙飞船添加到R-tree中 它进入了一个桶
它就是那个飞船的包围盒
然后我要添加两个小行星到桶中
你可以看到它变大了来容纳这些物体
我在这个R-tree中指定了规则
当这些桶超过三个物体时需要进行分割
所以我要再向这个桶中添加第四个物体
现在这个桶太大了它需要被分割
我们要进行一个简单的线性距离分割
最后结果是两个桶
再一次 我向右侧的桶中添加了两个物体
这个桶又变得太大需要被分割开
再一次 我们要完成一次线性分割 得到两个桶
这就是R-tree在底层的运作模式了
让我们继续说quadtree和octree
我将这两个一起说
因为它们都在解决同样的问题只不过quadtree解决2D
而octree解决3D
界面是一样的
这些有一系列等级和层次的树状数据结构
在每一层中空间也被均等的分割
在右侧我有一个quadtree的示例
你可以在左上侧看到我已经将这个扇形区域细分过了
在新的被分割扇形的左上侧我再一次进行分割
所以quadtree和octree都有个与之关联最大单元扇形尺寸
这控制了这些树的最大成长深度
以及这些单元扇形的细分极限
现在 当你向quadtree与octree中添加对象时
它会被放在一个它能占满的最小隔间中
关于该最大隔间尺寸给大家一小贴士
它的关联度很高这个值很重要 尤其关于
这些数据结构的表现性能
所以你应该选择一个隔间尺寸
或一个最大隔间尺寸对游戏最有意义
一般来说 这个关联于
你的游戏世界中一些较小的游戏物体
我给大家一个构建quadtree的视觉示例
同样的示例 宇宙飞船和小行星
我向quadtree中插入一宇宙飞船
被放置在两层下的左边的扇形区域中
我要添加一些更大的物体它们被放置在更上一层
这里注意左边的小行星
它有些跨越了扇形的边界
它事实上需要处在更高一层
因为它不能很好地安放在任何一个隔间中
最终 我再添加一些更小的物体
你可以看到它们处在向下三层的位置
这就是底层的运作模式了
当你使用quadtree或是octree时
实际情况中quadtree的代码示例
最上部我要创造我的quadtree
我要传入一个quad这是我的游戏世界中的区域
我想让这quadtree代表
我们要覆盖游戏世界中(0, 0)和(1000, 1000)间的区域
我要指定最小隔间尺寸为100
这个quadtree中没哪个隔间可以小于100个单位
我在游戏世界中还有一些敌人
我要将它们添加到我的quadtree中
要注意这些敌人也有一个quad与他们关联
这就是我们的游戏世界中的敌人所处的地方
也是它们将在quadtree中终止的地方
最后 我要在quadtree中进行一次查询
我要让quadtree给我所有的物体
在quadtree的(0, 0)和(1000, 1000)之间
在我的游戏世界中
结果我的三个敌人都在这个范围中
我要在查询后获得这所有三个敌人
这就是GameplayKit中空间划分了
让我们继续说说我们的过程生成系统
先说说一点背景知识有关为什么过程生成
可能对你很重要
我相信大家都很熟悉游戏中的预制内容
这是我们在游戏运行前我们制作的内容
甚至是在游戏上市之前
这些包括 艺术家设计或是设计师设计的水平
或艺术家开发的结构或特质
这些是很棒的资产它们对许多游戏很有好处
但对于其他的游戏以及特定的题材
你会遇到一些问题因为这些资产是静态的
它们在运行时不怎么变化
所以尤其当我在寻找一种随机的感觉时
需要每次玩游戏时都感觉到新
我就不能使用这种静态的资产了
所以我需要的是过程内容
比如随机生成的世界
过程生成的结构或高度地图
我们要制作游戏中的这些过程内容
我们真正需要的是一种连贯的随机性的来源
我所尝试制作的许多这种随机元素都存在于自然中
比如世界 结构和高度地图
我们需要一种随机性能在空间上具有意义
能有一个潜在的空间模式与之对应
现在 你可能对自己说
可以直接使用随机数生成器对吗？
我可以从随机数生成器中获取一些数值
来制作我的随机内容然后就完成了
所有尝试这么做的人很快就会遇到障碍
随机数生成器的输出波动很大
连续的调用结果很难有空间上有意义的联系
尝试决定论也是很有挑战性的
每当我随机生成内容时我希望它能展示同样的内容
如果我给它同样的种子
我们要的来源应提供一致的随机性
有一种这样的来源叫噪声
噪声是一个函数它接收一个输入 并输出数值
但这个关联之间还有一些规则
对于输入中的微小变化输出的变化也很小
如果输入变化很大我就会得到随机的
但依然在空间上有意义的输出变化
在这个噪声来源中有一些隐含的模式
噪声函数对于整个输入域来说是无穷的
它无穷地伸展而且它们具有确定性
给定同样的输入我总是会获得同样的输出
所以一旦你使用这个噪声函数我们可以在特定间隔处取样
间隔与我要制作的游戏与其内容类型相关
所以如果我要随机生成世界时
它可能是坐标或是瓦片索引或是生物指数
如果我要随机生成材质时
它可以是贴图像素或是像素等等
概述一下我们所提供的
通过我们的过程生成系统和我们的噪声系统
你有一系列的噪声来源供你使用与取样
来制作游戏中有意义的内容
这些是类似于比较随机的噪声
比如Perlin噪声和Voronoi噪声
还有几何噪声源比如巨浪
与球体 脊与圆柱
以及一些常量噪声源比如西洋棋跳盘模式
或是常量噪声函数
然后你就可以组合这些噪声源成为一个噪声物体
并在其上展示一系列的变换
这些包括结合噪声源
或是转化 度量 旋转噪声源
一旦我们以某种有意义的方式将它们结合成一个噪声物体时
我们而后可以对隐含的一个区域的噪声地图 噪声函数取样
在噪声地图中 我们获取采样然后制作我们的游戏内容
让我们再深入一下聊聊我们的噪声源
现在 我们所有的噪声源输出值在负1与1之间
我们一会针对这个再多说一些
它们接收参数来调整它们的不同的噪声输出
在这些噪声函数之下
所以对于我们随机性与一致性较强的噪声源 如Perlin和Voronoi
它们可以使用GKRandomSource作为种子
它们可以接收一系列参数来调整它们隐含的模式
对于偏几何的噪声源可以接收参数来修改形状
比如球体和圆柱体的尺寸或是脊与巨浪的频率
一旦我们有了合适的噪声源
我们就可将它们结合为一个GKNoiseObject
它拥有所有必要的函数以进行变换 组合和修改
我们的噪声源以及许多常用的数学
与支持的逻辑操作
如果我尝试组合噪声源我可以做加法 乘法 取最大最小值
但若我要变换单一的噪声源时
我可以缩放、旋转、变换
或者我可以通过取绝对值取极限 取相反数来进行修改
一旦我们找到了喜欢的噪声
而后我们可以对该噪声的一个区域进行取样
对隐含的噪声函数通过一个GKNoiseMap对象
你指定一个起源与尺度
这就是我们要取样的隐含的噪声图的区域
你还需要指定一个样本数量
我们要在这个区域中对该噪声函数进行几次取样？
我取样的保真度是多高？
当我们对区域完成取样后
我们就可以获得该噪声图上任意位置的值
再说一次 我刚才提到了范围是负1到1
在运行时 你可以选择按需覆盖某些值
若你的游戏世界改变
这些理解起来并不轻松
我认为解释清楚这些的最佳方式是给出视觉例子
假设我要为我的游戏随机生成一个地图
我要根据地球的生物群系来对其建立模型
我想让它看起来很真实
沙漠 树林 北极区诸如此类
第一 这是你为了完成需求可以使用的一种方法
这里我生成了两个Perlin噪声图
我将左边的称为湿度图
在我的游戏世界的任何一点我都可以找到这张图
来决定我的游戏世界应有多潮湿或说多干燥
我将右边的图称为温度图
在我的游戏世界的任意一点我可以找到这张图
来决定我的游戏世界有多热或说有多冷
在这里需要提到我们将来还要回到这里
在湿度图中 你可以看到我在右侧有一个很干燥的点
那就是黑斑是左侧的一个很干燥的区域
再说一次 这些颜色代表我所说的输出
这里黑色是负1白色是正1
在右侧 注意到我在顶部有一个很冷的点
那又是一个黑斑
还有一个很热的在我的噪声图的右侧
我要指定在组合这些时的一些规则
以对我的游戏产生意义
这里我有一个简单2D图
在纵轴中 我有湿度在横轴中是温度
我可以使用这些规则来决定这两个图的交界
如果我有一个点它有很高的温度和很低的湿度
我就会获得一个沙漠
或者如果我有一个点温度很高 湿度很高
我就会获得一个热带雨林
所以在这里在冷的那一端
我有冻土和北极区
在中间 我有更加温和的地带
比如森林 大草原和牧场
这两个图一起使用我基于这些规则将它们组合
就获得了这样的东西
你可以看到它有一个很好很真实的感觉 还有一点
在右侧 可以看到我们有很大的沙漠
渐渐变为牧场而后变为森林地区
这与我们湿度图的干燥点相符
以及在我们的温度图中的那个很热的点
在左上方 你看到我们有
一个很大的冻土与冰冷的点
在右上方与左下方我们有一些小的热带雨林
与很高的温度与湿度相符
所以这只是很基本的例子有关你可以完成的很酷的东西
通过过程生成
这里我们只使用了两个简单的噪声图
并通过很简单的规则将它们组合获得了很漂亮很好的结果
我想邀请同事Michael Brennan上台
来向大家分享游戏AI中的新特性
Michael？
谢谢 Bruno
大家好我是Michael Brennan
我是Apple的游戏技术工程师
我很高兴今天能与大家分享
我们为游戏AI在GameplayKit中进行更新
去年与GameplayKit一起我们介绍了Minmax策略
这是一个对于各种游戏的很棒的AI方案
可以保证对你的游戏状态有最佳的搜索
它之所以能保证是通过对状态空间进行大量搜索
同时组合你对游戏中每种状态所提供的得分函数
来提供给你你的一个实体在某一点的最佳行为
但是Minmax策略的高消耗本质
使它对于那些状态空间较大的游戏并不合适
比如围棋和象棋
这就是为何今年我很高兴向大家介绍Monte Carlo策略
Monte Carlo策略是一个对状态空间的最佳首次搜索
与对状态空间的随机取样结合
来计算出你的对手的最佳行为
它完成这一点是通过首先选择一个玩家行为
使用勘探开采算法来选择该行为
然后从该行为开始模拟新的游戏
直到它达到结束状态不论是胜利 失败或是平局
而后继续沿着树迭代
它不能保证如Minmax一样的最佳行为
但是它趋近于最佳行为
Monte Carlo策略速度快
它能保证很好的表现即使是对一些游戏
有很大的状态空间比如说围棋
由于它只需要最终情况
这需要让你的游戏提供
这在你的游戏中很容易实现
它几乎是最佳的
虽然它可能不是Minmax所找到的最佳行为
它们几乎是一样的并且会随着时间增加越来越趋近
让我们说说你需要用到的元素
来在你的游戏中集成这一点
使用GKMonteCarloStrategist时你需要提供一个预算
这是它完成我们刚才说到的四个步骤所要花费的时间
你需要提供探索参数
现在 这是一个在0与1之间的值 代表要不要
选择一个行为时探索没有到达过的节点
或是你想让它开拓它去过与发现的节点来最大化优势
你当然还需要提供游戏模型
若你使用过GKMinmaxStrategist你就应该对这很熟悉了
现让我们看一很简单的代码示例
获取了游戏模型GoGameModel
我们要持有它的一个引用
及我们的Monte Carlo策略
我们要将其实例化并持有一个引用
我们先设置Monte Carlo策略游戏模型
来指向我们的游戏模型
下一步 我们要对其指定预算
设置在100左右
这意味着它要完成四个步骤模拟与迭代100次
然后我们要将探索参数设置为1
这意味着我们想让它尽可能地探索
然后我们只需要获取活动玩家的最佳行为
在该游戏状态中 找到最佳行为并将其应用到游戏模型中
就是这么简单
今年 我很激动地告诉大家我们还允许
制作自己自定义的策略
我们实现了新协议叫GKStrategist
你只需要遵守它给出游戏模型
游戏模型更新与游戏模型玩家
并实现找到玩家的最佳行为
你可以使用这个策略就像你使用我我们提供的策略一样
这就是我们在策略方面提供的新功能
现在让我们说点别的
决策制定
有许多方法来对你的游戏中的逻辑建模
其中许多已经被GameplayKit所支持
你的敌人需要制定决策来考虑大量的状态
他们需要能很快的制定决策
你可以在这里看到我们有这个很小的按钮跳跃游戏
就算是在这个简单的游戏中你的对手需要考虑
你的位置 其他敌人的位置和按钮的位置
在某个时间点谁拥有按钮
他们是否在跳跃敌人是否在跳跃
他们在一层的哪个位置
还是要考虑不少事情的
一个简单的制定决策的方法是决策树
它们是树状的数据结构使决策更易于观察与除错
它们可以是制作的或是学习得到的
GKDecisionTree让你在决定行为时能有较小的开销
它是完全可序列化的灵活性也很强
允许你创造节点
能随机进行决策并对分支委派权重
或是基于特定分支的值如果这个值是真或假的话
或是均等的满足描述
它非常的灵活允许你完成许多事情
让我们看一个简单的代码示例
你可以在这里看到我们有一个树
我们要通过一个根元素对它进行初始化
查询是否我们接近按钮
然后我们要获取该根元素节点的引用以备后用
在此之后 我们只需要从该根元素出发创建分支
一个是我们接近该按钮的情况这种情况下我们就要跳
另一个是我们并不接近的情况这种情况下我们要选择游走
我们也要获取到该游走节点的引用
通过那个游走节点我们就可以创建一些分支
一个权重是9意为在该点向左走
另一权重是1意为我们要向右走
现在 这个权重是叠加的
意思是对于左侧分支而言我们走的权重是9
因为总权重是10所以向左走的概率是90%
向右走则有10%的概率发生
然后我们要将状态打包到字典中
并将其传入树的findActionForAnswers方法来获得我们的行为
决策树也可以被建模
你只需要提供游戏数据
它就会在数据中寻找到进行决策的行为
并对该制定决策的行为找到一个合适的树
在我们的方阵中你可以看到最上的一行是深灰色的
那就是属性
内部的矩阵是我们的样例
那就是我们在游戏中不同的游戏点的样子
在右侧 我们有进行的动作
这只是我们在游戏的不同点中进行的操作
你将它传入GKDecisionTree的构造方法中
它就会找到一个决策树来适应你所记录的游戏数据
让我们看看这在游戏中的样子
这里我有一个玩家浅绿色到青绿色的玩家
对抗深蓝色玩家
使用我们刚才展示的手动创建的决策树
如你所见 它遗漏掉了一些
我们进行的操作这样我们表现会变好
让我们看另一个例子
这里你可以看到它的行为更像我们刚才的行为
如我所说 你只需要记录你的游戏数据
将其传入 你就能模拟行为就像你自己的行为一样
即在GameplayKit中今年新引入的游戏AI
它很棒我很激动能与大家分享
现在我要邀请我的同事Sri Nair上台
介绍更多有关Xcode集成Gameplay
Sri？
谢谢Michael
大家好
我是Sri Nair
我是Apple的一个游戏技术工程师
去年介绍GameplayKit时
它只能由代码驱动
你需要创建构造器完成所有的连接工作
并改变属性和值全在代码中完成
这可能会很低效原因显而易见
我很高兴能告诉大家我们对这个问题进行了优化
通过向GameplayKit引入更加由数据驱动的工作流
通过在Xcode和SpriteKit编辑器中集成它
如你所知 编辑器整合可以更快的提高
你的游戏功能的体验
它们还有助于分离工程师工作流
和设计工作流
所以现在编辑器有四个主要的新特性
帮大家加速GameplayKit开发
第一个 实体和组件编辑器
第二个 导航图编辑器
第三个 场景轮廓视图
第四个 状态机快速查看
让我们细说这四个特性
什么是组件编辑器呢？
让我们回想一下实体和组件系统是一个设计模式
其中一个游戏物体是通过实体展示
而它们的行为则是通过更小的独立组件展示
这能提供更好的代码架构与代码易用性
它们也会更易于维护和扩展
所以现在通过组件编辑器你可以将实体与组件赋给
在编辑器中的节点
并在编辑器中修改属性编辑器提供
一个基于编辑器的数据驱动的工作流
编辑器与代码紧密整合
并支持组件类和属性的自动查找
举个例子 假设你要写一个运动组件类
它派生自GKComponent添加了几个属性
并由新引入的GKInspectableKeyword注解
来展示在UI中
组件编辑器会自动探测到
这些你已经添加并展示在UI中的组件
现在你只需要选择你需要的组件
并赋给节点
一旦你添加了组件属性就被自动填充了
基于相应的数据类型
现在你只需修改这些属性并在编辑器中直接预览变更
无需退出编辑器
或是重新编辑代码来使遍历更快
并且这些所有的更新都保存在SKS文件下的一个JKC中
所有未被改变的属性值都使用默认设置代码
与节点连接相关联的GKEntity是在后台生成的
通过一个GKSKComponent
UI支持所有的常用属性类型
比如浮点 整形 布尔等等
这就是组件编辑器了
现在 让我们继续说导航图编辑器
Bruno刚才提到了
导航图 也就是GKGraph是用于寻路的目的
来找到一个物体从A到B的最佳路径
通过导航图编辑器
现在你可以直接在编辑器中创建GKGraph
你可以添加或修改节点在其间添加连接
只需要在一个窗口中点击并拖拽
这些GKGraph保存在GKScene中
你可以在之后通过代码获取并用于寻路
还有一个我们在SpriteKit编辑器中一个很有用的特性
对Gameplay Kit开发也很有用
叫做场景轮廓视图
它绘出场景元素的轮廓它们的父子层级关系
这里支持大多数标准的操作
比如添加 编辑 重排 删除等等
你在你的场景中添加的导航图也会在这里展示
在场景轮廓图中
它还可以用于锁定节点与修改可见性
它同时附带一个上下文菜单来进行选项特定的操作
很好用
最后同样重要的状态机快速查看
回忆一下 我们去年引入了GKStateMachine
它允许你在游戏中表示一种执行流
它在游戏中有许多应用
比如AI、动画、UI、等级序列等等
直到现在你都不能预览
这些状态机的样子
很难理解这些状态之间的关联
执行流 或是其当前所在的状态
为了解决这个问题我们整合了一个状态机预览工具
直接在Xcode Debugger的快速查看功能中
这允许你在代码中设置断点
在你想查看状态机的地方并点击快速查看图标
就会弹出一个当前状态机的视觉展示
它会展示状态以及其间关联
当前的状态被高亮
这里有几个关于快速查看状态机的例子
通过这些 我想演示GameplayKit中 基于编辑器的工作流
这里我要搭建一个简单的游戏
其中一个玩家捡起气球将其涂色并扔到敌人那里
这是由游戏AI模拟的敌人也可以做同样的事
所以我们有一个基本的场景
你可以在场景轮廓视图中看到
我们有一个背景和一个玩家和一些气球
所以首先 我们要尝试添加这很简单 没有进行什么行为
这是一个很静态的场景
我们通过使用键盘向玩家添加一些行为作为开始
对于这一点 我已经添加了一些组件
我们要看看刚才提到的行动组件
有几个属性来帮助行动比如速度
摩擦 加速等等
你使用GKInspectable对其注解
这样你就可以在以后在UI中处理这些属性
类似的 我又一个玩家输入组件
我们要将这些赋值给玩家
通过进入场景并在组件编辑器中寻找
在右侧检查区中
我有一个新引入的组件编辑器
现在 我可以选择玩家并点击加按钮
来将这些组件添加到节点
我们下面要添加用户输入组件
与运动组件
而后我们会看到结果
我期待用户可以通过键盘移动
太棒了 它可以在任何方向运动
除了可以之外你还能发现它不会在边界停下来
因为我没有对玩家添加任何碰撞
但我的确添加了一个碰撞组件
它主要是给玩家节点添加了物理躯体
我下面要将其赋给玩家
在完成这一点的同时我还要赋一个战斗组件
我已经添加过了能允许你捡起气球并扔出
让我们看看它的样子
太好了 现在我可以捡起气球而且它在边界处停止了
这很棒
我们下面要对敌人进行同样的操作
未完成这一点我在场景中创建了一个敌人物体
但我将其设为不可见了
所以我要在场景轮廓视图中设其为可见
而后将组件赋值给敌人
在这里 区别在于它是一个敌人输入组件
这样它就使用游戏AI而不是使用键盘
类似地 运动组件 碰撞组件
以及战斗组件
有了这些 我会期待敌人也会
捡起气球并
啊 它赢了我
这对它太简单了
但我们要让游戏更加有趣
通过一个绘制的物体向场景中投落一些气球
所以我有一个绘制的物体我要将其在场景中设为可见
而后添加绘制组件
能沿一个确定的路径投落气球
我想要向场景中添加一个导航图
这就像进入物体库并输入
“导航图”一样简单
现在 你可以简单的将导航图拖拽到场景中
我们要把导航图稍稍放大来解释这个新特性
这就是导航图编辑器
在我们操作它的同时我们要修改一些属性
我们要设置玩家的健康为2还要设置运动
稍稍加速 让玩家稍稍占优势只是一个第一等级
你好歹也是有了一些优势敌人的健康值也是2
让我们看看结果
你知道 你可以看到飞机扔下的气球
比如能捡起来扔出去的多
他赢了我一次 我也赢了一次让我们看看
好 好了
我确定我的儿子玩这个游戏时会很高兴
这解释了
GameplayKit中新的基于编辑器的工作流
让我们切换回幻灯片
来回放一下本期
今年 我们介绍了很多引人入胜的
有用的GameplayKit特性
在最开始 Bruno分享了新的空间划分系统
来在你的游戏中进行高效的空间查询
新的过程生成系统使用不同的噪声函数
来在你的游戏中创建更加动态的内容
同时对诸如寻路与代理等现存系统也有提升
Michael分享了有关游戏AI的新特性
通过游戏策略和决策树
最后我介绍了新引入的基于编辑器的工作流
在GameplayKit中带来更快遍历
希望大家认为这些新特性很有用处
我们已经等不及看到大家下一步的成果了
这是以后再看这段分享的URL
608就是本场演讲的编号
还有相关技术的其它演讲
你可能感兴趣参加
SpriteKit、SceneKit、Rendering、Game Center的新特性
及Apple Watch的游戏技术
感谢大家前来
我们希望大家在余下的演讲中度过愉快时光