制作现代化Cocoa应用
大家好 欢迎来到“制作现代化Cocoa应用”
我是Corbin Dunn
我将和同事Jeff一起来做本次演讲
我们都是AppKit的软件工程师
让我们直入正题今天我们将会讨论什么呢？
我们将涉及一大捆的话题
我们来谈论下创建一个现代化外观
如何正确拖放容器视图控制 表视图
使用系统外观storyboard设计
和其他一些酷酷的Mac特性
非常多的东西
我们快速通过一个演示应用来强调
就像我们看到的这个截图
它如何使用新特性或者如何使用已存在的特性
所有的这些技术
大多数你早已可在MacOSX 10.10或10.11使用了
10.12中的任何新技术我们都会重点指出
关于这个演示应用我们希望你能下载
尽管这个应用还不能下载不过很快就可以
并且该应用和这次演讲有关联
让我们进入正题
讨论一下如何用现代化视图
构建一个现代化外观并且你可以做什么
现代化外观意味着现代化窗口和现代化工具栏
就像这里展示的演示应用
其中一个你需要做的是使用全尺寸内容视图
这个全尺寸内容视图
允许你的内容视图进行延伸
在工具栏下面的区域这里我用白色标记强调
这意味着全尺寸内容视图
自动地在工具栏和标题栏旁模糊
不需要你做任何事
使用全尺寸内容视图非常简单
只是一个窗口样式的掩码
你可以使用.fullSizeContentView位设置它
或若你使用Interface Builder
你可直接在勾选框中的全尺寸内容视图上打勾 就可应用它了
所以如果你要使用全尺寸内容视图
你可能需要抵消在它下面的内容
例如 假如说
我们想让一些东西在工具栏或者标题栏下面
我们可能会
在那里放一个标签或什么
若我们想把标签放那里如何来完成
在工具栏或标题栏下面
如果有 比如动态高度改变
并且我们不想让这个标签拥有一个写死的Y位移
因为写死的位移实在是太糟糕了
所以我们要的是
NSWindow的contentLayoutRect属性
这是一个可观测的键值一个可观测的KVO属性
任何时候你可用它发现contentLayoutRect
蓝绿色的区域改变
在这基础上 你可以把你的视图
直接放到标题栏或工具栏下面
但是我们也鼓励使用自动布局
并且如果你使用自动布局
你可以使用contentLayoutGuide一个NSWindow上的属性
例如 在NSViewController子类里
你可能重写updateViewConstraints
并且你想创建一个约束
你得到window的contentLayoutGuide
为它标记上锚点并且你会得到一个文本区域
然后应该创建了一个约束
在这个文本区域的顶部锚点并且激活它
如果你这样做
在文本视图会自动在标题栏或者工具栏下面的区域
不用你做任何事
十分容易
接下来 关于现代化的应用你该用一个流线型工具栏
这是一个常规应用的截图
值得注意的是这里有一个明显标题栏
或者 抱歉它在顶部有一个明显的标题
并且在那应该有一个图标
若这个应用确实有一个关于这个文档的图标
如果使用一个流线型的工具栏那个标题会消失
这个工具栏将会向上移动一点
并且窗口按钮 关闭按钮等等
会和标题栏或者工具栏区域在一条直线上
做到这些十分容易
你需要做的仅仅是设置一下标题的visibility属性
为.hidden
那么标题将会被隐藏
工具栏将会被向上推并且所有的东西都会在一条线上
你何时想做这些？
你可能想为应用做这些例如shoebox应用
例如地图 日历
系统设置 具有这类属性
像是这些一个窗口的应用都非常适用这种风格
还有其他的事可以做吗？好吧 你也许想完善
标题栏或工具栏的区域
用辅助视图控制器
例如
你可能想有一个辅助视图控制器
就在标题栏下面
通过这样做你想让它自动变模糊
你不用做任何事
尺寸将会跟随窗口的尺寸自动改变
不需要你做任何事如何做到这些？
这十分简单我们有一个视图控制器子类
叫做NSTitlebarAccessoryViewController
你可以给这个视图控制器设置视图
除此之外它还暴露了一个布局属性
所以布局属性可被设置为.bottom 意思是
这个辅助将会在标题区域的底部
注意出现在它下面的文本因为
我们使用符合内容布局指导的合适的内容布局
不需要做任何事
除了设置在底部
布局属性还可以设置在leading或者trailing
意思是你可以有一个辅助视图控制器在标题区域上面
例如一个注册按钮
或者其它你想添加的
macOS X 10.12上的新特性是使用leading和trailing的能力
和之前发布的left和right相反
我们更推荐你使用leading和trailing因为它让你窗口运作得更好
当你使用从右到左的本地化
这样 例如
如果我仅仅在从右向左的模式下运行
你可以看到辅助视图控制器自动反转
到另一边什么都不用做的情况下
接下来我们 系统
可能添加我们的辅助视图控制器到你的窗口
例如 我们可能为了创造标签窗口而使用它
我们聚集多个窗口
到一个类似虚拟窗口
我们如何实现窗口分页并且你作为一个开发者应做什么？
你不需要做任何事情
若你命令一个窗口前
我们做的是寻找和那个窗口相似的窗口
相似是说寻找tabbing identifier属性
如果它有相同的tabbing identifier
我们优先聚集起这些窗口
到一个单独被做了标签的窗口
这些窗口都被认为是可视的
即使它可能是一个隐藏的标签
但我们实际将它们隐藏在核心图像中
若你使用NSDocument大量的东西 如plus按钮
在标签栏里面的将会自动工作不需要你的任何支持
但若你不使用NSDocument你可以实现一个响应链方法
新标签窗口来创建一个新文档
或在plus按钮上的新窗口
欲知更多信息请观看“Cocoa的新特性”
来了解更多的细节
关于标题栏的更多信息
关于辅助视图控制器及它们怎么和全屏幕交互的
我强烈推荐你们去看一下2015年的演讲
“改善全屏幕窗口体验”
接下来我们会谈论下核心动画
什么是核心动画？
它是一个图形渲染引擎
在GPU上做大量工作而不是在CPU上
所以任何东西都可以非常快地滚动
所以我们可以很快并且很流畅的动画
它的一个基础结构是一个CA layer
我们实际上是怎么使用图层创建布局和视图的
或者视图本身呢
这是一个你可能用到背景图层的动画实例
一个中间的图层 再来一个前面的图层做一个动画
你想用多个子视图中合成你的视图
来创造一个最终的画面
让我们看一下核心动画的属性
CALayer允许你创建你可以在屏幕上看到的内容
说到内容 CALayer有一个contents属性
这个contents属性可以是NSImage或CGImageRef
恰好呈现出你所看到的
在那个层的contents里
但你也可以在CALayer上设置其它属性
比如背景颜色
比如边框的颜色 边框的宽度
比如圆角弧度
你还可以在CALayer上发现更多的属性
看到其他可操作东西并且学会如何来操作
这有些基础的方式
用来创建一个CALayer的外观
对此 我们稍后再谈
你应该使用一个置为底层的视图
所以你将会用NSViews
仅需设置层为“是”
接下来我将为你们演示如何操作
它将会为你隐式创建一个层
意思是你可以通过draw方法提供层的内容
但如果你要使用层我们有两个更重要的方法
updateLayer和wantsUpdateLayer
接下来我将告诉你这些如何实现
何时你想使用它们
我们用核心动画来做什么
该何时用核心动画和置为底层？
我们建议你将窗口内容视图置为底层
当你将某特定视图置为底层时
所有子层也将自动变为底层
不用你为每一个子视图选择一个层
我们推荐你将视图置为底层
并且不要直接把CALayer作为子层添加
因为它自动为你做事
例如当在一个层在视网膜显示屏上显示时
我们将会做更多的设置来完成这个工作
打开“置为底层”非常简单
在窗口的内容视图 可将wants layer设为真并编码
或者 当然你可以在界面文件夹里
勾选CoreAnimationLayer
在最顶部的视图上
所以 一个重要的属性
置底层视图属性是layerContentsRedrawPolicy
你可以设置值为.onSetNeedsDisplay
它并不是NSView的默认值
意思是 作为一个开发者的你无论何时
想改变层中的内容或改变视图
你都得调用SetNeedsDisplay
这与普通的视图工作方式在语意上稍微不同
当它们移动时它们可能会重新显示在那里
改变框架的原点
这是一些你需要明确选择的
这尤其可以让动画效果更出色
所以如何使内容放到层呢？
你的视图是需要刷新的
你标记为setNeedsDisplay
并且
我们问你的视图 嘿
你为wantsUpdateLayer做了什么？
给wantsUpdateLayer的答案是什么？
在这里出现分支
若wantsUpdateLayer为是
我们会调用wantsUpdateLayer
若回答否我们会调用drawRect
所以这是一个完整的分支
必须要二选一
然后你可能会奇怪
“好吧 何时该选择updateLayer或drawRect呢”
这回到我给你们演示核心动画和NSLayer属性的位置
所以如果你可以代表你视图的表现
直接通过设置CALayer属性
这时你该使用updateLayer
这将会更高效
若你可以设置分层内容
层背景颜色 更倾向于做这些
如果不可以
这里你该重写draw或者drawRect
在子类里做手动绘制
每一个实现drawRect的事件
将有它们自己特有的backing score你可把其看作图片
因此如果这种东西太多
它将会占用太多内存
让我们快速看一个例子
用updateLayer你如何使用它
首先 你将重写wantsUpdateLayer
你会有一个
updateLayer回调通过返回真
然后将得到一个updateLayer回调
你可以设置层属性
所以我们得到视图的属性self.layer内容
还有self.layerbackgroundColor
或者任何其他的你想设置的东西这次你可以设置
我们再谈论一下现代视图
和如何为标题栏和工具栏创建一个现代化的外观
来说一下拖放和来做一些事件跟踪
对于现代化的拖放
你需要采用的是drag flocking
像视频中展示的这样
Drag flocking是每一个独立的项目
独立的移动但是会聚集在一起或同时散开
当你将鼠标放开以后
它们将会散回到初始的位置
你只需要使用NSView的方法来用drag flocking
beginDraggingSession
当传递一个数组
包含实际你想拖拽的项目
这十分简单
关于更多的复合控制像一个表视图
对集合视图我们提供代理方法供你使用
对于表视图你应该优先使用代理方法
tableView pasteboardWriterForRow
可提供一独立NSPasteboard编辑项目
为表视图的每一个被拖动的项目
与老方法相反tableView writeRowsWith
到一粘贴板
你编辑的所有东西将会在一块到粘贴板上
同样 集合视图
有两个代理方法和这个非常相似
对于集合视图你该优先使用
pasteboardWriter ForItemAt版本而非其它版本
对于drag flocking
macOS X 10.12上的新功能是对drag file promises的支持
这就是你现在才用drag flocking的原因
并且你可以用NSFile PromiseReceiver和NSFile PromiseProvider
来读和写文件promises
看下这次的演讲
“Cocoa的新特性”了解更多信息和细节
让我们看一下事件跟踪
假如你有一个窗口
并且顶部有一个按钮
所以你有这个按钮
你想让它发生的是
当你点击这个按钮时
从上到下它都像常规按钮一样工作
你将做什么来表现一个弹出
但是你也想弄清楚你点击的按钮
并且如果你拖动鼠标拖拽一个窗口
所以怎样使这些行为聚到一块呢
在现代系统上新特性中以恰当现代的方法？
好吧 让我们讨论一下事件追踪
和如何追踪事件来做到这个
这个窗口有个方法跟踪事件匹配掩码
用一个超时模式处理器
并且这个处理器是一个块回调
我们更希望你用这个方法而不是用老方法
在NSApplication
它是nextEventmatchingMask
用过去的方法你创建自己的循环
在新的方法中你仅需使用一个块回调就可以完成工作了
看下这块回调比如在那个按钮中
我们将mouseDown分成子类并重写
首先我们应在mouseDown做的
是调用窗口跟踪事件
我们想为drag和leftMouseUp追踪所有事件
如果用户点击 然后后退
我们需要停止
我们会说
我们需要调用super
因为通过那方式 每件事都会像NSButton一样正常工作
但这有额外的部分
比如 你点击并拖拽
并且如果在按钮里点击和拖拽
我们会判断你是否拖拽得足够远
如果拖拽得足够远
将不再只作为一个窗口而是去完成一个performDrag
意思是
当你传递窗口performDrag时
窗口和系统将会在那一点接替这个拖拽窗口
不能拖拽和移动窗口
通过在窗口一次次调用set frame
如果你传递给系统
一旦你传递
如果你的应用卡住了
然后
这个窗口将继续可被移动
即使应用正在运行
除此之外 其它系统特性将运行
像空间切换
当你移动到窗口顶端空白栏将会向下移动
窗口捕捉 窗口对齐
任何其它新加入的系统特性
在窗口的移动下会自动工作不需要你做任何事
所以我们希望你向下传给系统
通过调用performDrag
刚才讨论了拖拽和事件处理
让我们谈论一下容器试图控制
和如何适当的使用这些
容器视图控制我们应该使用
基于表视图的视图
你通过使用代理方法tableViewviewFor: row: 来做这些
或者你可以在InterfaceBuilder里设置一些东西
直接通过InterfaceBuilder本身
这样做的原因是你可以像视频中我们看到的那样
新特性 例如滑动删除
这仅仅存在于基于表视图的视图里
通过滑动来删除非常简单的
这有一个表视图方法
rowActionsForRow
在一个特殊的边缘
在左边或右边的边缘 抱歉应该是在顶部和底部的边缘
并且你可以返回一个数组一个或多个或没有或更多行的操作
在NSTableView的行操作中
允许你给按钮的标题创造一个字符串值
和一个处理方法
当用户点击时才触发的代码
或者滑动屏幕足够远才触发的代码
接着我们谈论下滚动视图和它的复合控制
到目前为止我们谈论的技术
例如滚动视图...比如我们获取窗口
和设置窗口标题栏显示透明
它使标题栏看上去透明
如Messages这类应用充分利用该特性
允许内容在下部显示
我们来看一下发生了什么
在一边的滚动视图显示
在标题栏/工具栏下部区域的内容并会自动将其变模糊
但是这呈现出两难处境
如何使滚动视图被自动插入
以致你不需要添加一个空行
或其他什么奇怪东西？
做这些十分方便和简单
滚动视图有个方法
或属性叫contentInsets
允许你将内容稍微向下移动一点
实际上 我们让它自动实现
我们有个属性automaticallyAdjust ContentInsets
如果你设置它为真
然后我们让滚动视图使用KVO
之前说的跟踪contentLayoutRect
自动设置内容插图
为一个合适的值
但作为开发者 你可能想更自由控制内容插图
你可能想让它更向下
来添加一切其他的帮助控件
比如一个搜索区域或者其它东西
在我们的系统中的一个例子是
Mail向下了一点添加了排序指示器
这就是我们在系统应用中的使用方式
下面说说自动布局
你应该使用自动布局
你也应该使用base localization
你所有的nymphs都该在base.lproj中
除了使用多个不同文件夹和本地化副本
你不应该使用固定写法
你想用控制去得到内在的内容大小
而不是写死大小
优先使用堆视图
使用leading和trailing属性 这些都正确
对于创建一个合理的本地化应用
我们看一下IB中的本地化选项
尤其文本方向、布局和镜像部分
文本方向有三个值
自然的 从左到右 从右到左
自然的意思是
实际的控制器将根据字符串值
你给你这个控制器设置的 如文本域根据字符串值
如果字符串是从右向左的
我们将实际把方向设置为从右向左
如果是从左到右的字符串我们将设置为从左到右
或者你可以手动设置为从左到右或者从右到左
下一个属性是userInterface LayoutDirection
对于布局非常重要
它可以从左到右或者从右到左
系统控制如表视图要参考这个属性
还可能做自动反转表的列之类的事
当设置为从右向左时
默认值根据应用值来定
有趣的是镜像属性
因为它有点迷惑
若一个镜像被设为自动
然后userInterfaceLayoutDirection
刚才我们看的最后一个属性
会自动由从左到右变为从右到左
当它是从右到左的本地化
反之亦然
它还会反转自动其他属性
像按钮单元图像的位置
按钮的图像在左面 我们会反转它
会自动放到右面
我们不会反转的一个属性是文本对齐
若你设为居中两端对齐或自然
反转它们没有意义所以我们不会反转
你可能会想
“我什么时候不需要设置镜像？”
你可能想设置镜像为否
在你想要一个控制器有一个非常实际的代表
像一个播放按钮 快进按钮或快退按钮
然后
这些是关于Interface Builder的那么在代码里你该怎么做？
在代码里你必须参考控制器值
关于userInterfaceLayoutDirection如果它设置为从左向右
你必须说“嘿 按钮
我想让图片在左面当从左到右本地化时
我想设置图像在右面当从右向左本地化”
你必须手动完成设置它
在10.12中 这个更容易了些
我们给按钮添加了一个快捷方法
一个初始化方法可以传入一个字符串
一个图片 一个目标和一个动作
还有自动反转
这是我讲的第一部分
下面让Jeff讲讲外观
storyboards和其他一些Mac特性
谢谢大家
好的 谢谢 Corbin
在这个课程我们有大量的内容去讲
所以现在我说说系统外观
这里是我们的应用
我们刚才已经看了一会儿
我们想提升下我们的UI
我们已经决定采用这个花哨的黑色外观
这通常是高级应用的外观
我们要对我们这个小演示程序有点野心
但看看这个这个看起来确实很复杂
我们有一个完全不同的系统Window Chrome
我们要所有控制器artwork改变片段控制器 按钮 滑块
所有的文本标签
需要从黑色字体变为浅色字体
看起来有很多工作
但实际上饿哦们可以用一行代码实现通过使用NSAppearance
我们需要做的是创建一个系统外观
赋值给窗口
会自动的应用所有的工作
你可以认为外观是一种颜色调节盘
我们用来解决
绘制所有的标准系统控制器
还包括所有我们命名的颜色
像标签颜色 控制器颜色
由于这个原因适时使用这些颜色很重要
不仅更适合整个系统主题
同时 如果以后主题变了仍然适合
或者以后你改变了你的外观
我们仔细的看看
这里有个面板
有许多很棒的标签控制器等等在上面
我们只需应用暗色外观
我们看到了相当戏剧性的变化
控制器artwork变了
当然其他所有的标签由深色到浅色转变
我们可以再进一步
应用这些很酷的活力效果
你刚可能已注意到一个幻灯片
那个我们应用过的外观叫做活力黑
不是说你有义务使用“活力”
而是说artwork在充满活力的上下文中看起来很棒
想要这种外观 你只需要
添加你所有控制器作为NSVisualEffectView的子视图
你会自动获得这个很棒的窗口后模糊
还有在这上面所有的很酷的渲染效果
现在 你可能认为这很棒
但我的设计师有很酷的
特定颜色针对我们的文本标签
所以我不会使用标签颜色
我也不会把其从暗变浅或者反过来
我很好 是的 我很安全
我们加点东西
我们检查下可访性面板
我们会打开中间叫做增加对比度的设置
看看会对UI带来什么影响
在左面我们有标准的面板
但是右面我们有
增加对比度开启的面板
虽然我们没有反转所有颜色
这个转换很像
有浅变深的转换
你可以看到窗口背景色变浅了
在每一个层级文本都变暗了
我们的控制器有很棒的加粗轮廓
让它和背景区分更明显 更立体
现在 当你用一个写死的颜色值
我们就不能猜测我们不能像这样调整设置
所以
如果你没有像标签颜色
第二选择标签颜色你可能在帮倒忙
对想要在他们Mac上设置像增加对比度的用户
现在说我刚暗示的视觉效果和活力
我们现在不会深入那个API
但是你可以参考我们2014年的演讲
“采用OS X Yosemite新UI的高级特性”
那是外观
是设置你应用主题的简单方式
同时能和整个运作系统的外观保持和谐
下一个话题storyboards
Storyboards是一种可以让你设计
不仅是单个组件的技术
和构成你应用的其他视图
并且在视觉上设计这些组件间的关系
在这个例子中 当我说部件时
storyboards操作的控制器
是我们的窗口控制器和视图控制器
我们用这些segues把它们连起来
在我的截图上的那些箭头
segues抽象所有的胶水代码
让这些部件放在一起
就像添加子视图 添加约束
创建弹出框一样方便
现在
一个我们需要考虑的关于storyboards的是
当我们有可分离的组件时如这些
我有一个拆分视图storyboard创建的
所有这些小组件做它们自己的事
每一部分UI都有些数据需要用
或者修改
我们不能仅从一个到另一个场景拖拽outlets或actions
当然 如果我们这么做了
它们就不是可分离的组件了
然后我们就破坏这件事的本来目的
有时 我们用的数据
不是呈锥形存在于场景中
在下面的叶子节点
有时它可能存在在窗口或者文档中
所以我们如何传递数据
从上直到叶子节点？
好的 我们有几个经验法则
不是硬性的规则
仅是几个主意我们认为对处理这个有帮助
第一个
依赖应该大体级联向下
如果你想
如果你需要某些法则
在segues中跟随箭头
如果没有其它这让你
在应用中有很好的单向信息流
这让人很容易理解
另一个是尽量减少UI结构的假设
你写死到代码里的
你设计完UI和storyboard
若你在代码里写死了一些假设
关于结构是如何放到一起的
当你想要改变storyboard时
你得来来回回
修改代码和storyboard
现在你和自己过不去
我们不要那么做
让我们把代码集中在数据上
集中在设计界面和Interface Builder上
一个我们可以用来解决该问题的技巧是
使用符合协议贯穿UI
这里有个例子
假设有一个属性在窗口控制器上
我们想自动提供那个属性
给我们视图阶梯中理解它的任何东西
在didSet中
我们会调用propagate方法
我们得到了在屏幕外定义的协议
叫作photoControllerConsumer
这代表我知道如何使用photoController
且若我们看看childViewController
会发现它遵守了我们可以设置属性的协议
同时我们自动递归传递给其所有子项
但是像
弹出或者表单展示
这些必须吗？
当你设置这样的属性的时候这些可能不存在
我们根据需要来给他们提供数据
在他们出现在屏幕之前
即prepare forsegue方法的作用
它会在展示视图控制器或窗口控制器的时候被调用
当展示发生时
在这个例子中
除了做像检查或者segue标识符
强制转换成我们希望的控制器类
然后做些特定的设置
这里我们做相同的事情
我们检查什么协议被遵守
然后设置合适的属性
此举是
它改变我们的逻辑从严格聚焦
身份变为能力
我们说我有这方面的知识
任何展现给我的
可以潜在自动获得那个知识
通过一个一致的协议
这真的很方便
再讲讲“动作”
那很常见
UI中触发的处理动作的最佳对象
实际上并没有在同一个场景
那个控制器定义的地方
这被它们自己的小场景中菜单单元证明了
完全从你的UI断开
同时
幸运的是我们有一个很棒的机制来处理这种情况
就是事件响应链
如果你来自iOS平台
你可能不会使用太多的事件响应链
就是那个小的橘黄色立方体
在每个storyboard场景上面
它是第一个相应者的代理
如果你关联了一个控制器的动作到代理上
它会自动的发送给响应链
当控制器被触发
如果在响应链中没有对象处理方法怎么办？
或者在放大的情况下
发送动作不总是很恰当怎么办？
例如我们在最大化缩放层级
我们不想让放大按钮不起作用
在我们动作之前我们可以看到
这就是UI验证的作用
我们看看一段代码会自己审查验证UI
来判断一个控制器是否是可操作的
第一步我们需要做的是请求NSApp
获得一个控制器的目标动作
这会自动遍历响应链
寻找实现那个动作的某个对象
或者可能没有发现任何动作甚至没有发现任何对象
我们想要看的第一个例子的结果
是实现NSUserInterface验证协议的任何对象
这意味着你可以主动请求
一个控制器是否有效
如果你在等式的另一边
并且你有一个控制器某些条件下有效
你可以实现这个方法
像NSMenuItem控制器和工具条单元
会自动验证那个方法
所以我们可以请求那个方法
然后 当然 有些情况下某个对象
无条件处理了那个方法
或者一个对象也没有意味着我们没有准备好处理那个动作
这是些专门应对storyboards的技巧
现在我们已经讨论了很多关于
创建应用程序设计时间方面的事情
我们看看一些面向用户的特性
可以帮助你充分利用我们的平台
首先是用户活动
NSUserActivity是这个对象
描述了你的应用现正在做什么
在看什么 在编辑什么
等等
并且
Handoff使用这个对象使这些活动在各设备间移动
有点类似把你的整个上下文在它们之间移动
我没时间来深入看整个的API
我想说这个对象确实比较简单
你可用activityType构造它
它是描述你正做的活动的唯一标识符
同时也有一个密钥需要放到info plist中
声明我是个好应用在其他设备上选择该活动
然后你填充一些基本的配置信息
来描述你的活动
一个好的面向用户的标题或者一些用户信息
基本上只是基本的必需数据
稍后跳回到那个任务
我们想让这个字典一直保持较小因为它需要频繁无线传送
我们也想让handoff交互快一点
我们也需要在代理中
添加关于上下文的绝对最新信息
在我们执行handoff之前或前一刻
它会被调用
在你标记一个活动来保存后
我们替你调用这个方法这样你可以填上最新数据
我们如何确定哪个活动是当前活动？
因为 当然 我们当然需要决定
现在我们在看什么
你可通过becomeCurrent手动管理
和NSUserActivity上的resignCurrent方法
就是说你可能需要跟踪你的用户
在你的应用上搞清楚他们点击了什么
并尝试搞清楚他们在做什么
AppKit让这些变更简单
通过让你附上活动
到响应链可以自动管理
比如
假如我们创建了一个日历应用看起来就像我们的日历应用
我们有两个活动想要放到响应链
我们有该视图更高级的活动
这整个这里的这个日视图
然后我们有一个更具体的活动对这个具体的事件
我们在这里看到
通过添加这个到响应链
当我们点击的那个事件让它成为第一个响应者
那个活动变成了最近的一个
在响应链中通过第一响应者
它自动变成了当前的
现在
你之前可能没考虑使用Handoff或NSUserActivity API
你可能没有iOS配套应用
或者你不认为Handoff特别引人注目
对你的应用和你的特定的需求
但活动不仅Handoff使用
Sierra新特性中我们在Mac上引入了Siri
Siri使用当前活动提供上下文命令
例如 若你说在某个日期提醒我这事
Siri会推断这个是指当前活动
其实它甚至会用这个活动并把它嵌入
到你的提醒里然后你可以在未来找到它
所以我们认为活动是一种通用机制
为了描述这一类信息不仅仅是为了Handoff
现在关于Handoff API的信息
我推荐大家看看2014的讲座
“在OS X与iOS中采用Handoff”
它涉及到许多高级话题
像持续流可以让你在设备间传递更多数据
下一个特性 恢复
我们有时叫状态恢复
它是Mac最棒的特性之一当你退出一个应用
然后重新启动它它会回到你离开它时候的样子
实际上 这个也会恢复
如果你的应用崩溃或者重启了机器
所有的东西恢复到之前的样子
现在 实现这个效果
我们需要
保存所有的UI状态
随着时间的推移积累
然后恢复它当应用重新启动时
明确说我们不想在模型里保存状态
它并不真正属于那里
所以一个状态恢复API给你
一个明确的地方单独保存UI状态
它给你一个好的地方恢复那个状态当你启动应用时
但是在你的UI在屏幕上展示出来之前
基本上你可在每个窗口启用它
那相当简单设置isRestorable为真
然后你提供一个恢复类
处理创建你窗口的事件
从编码的数据中
好消息是若你用NSDocumentNSDocument会处理这些
我们想要恢复什么样的状态？
我们可能选择保存
当前应用中激活的工具
我们还可能想保存侧边栏的状态
我们选择了什么 我们滑动了多少位移
我们如何来做？
好吧 若你之前用过NSCoding那是非常非常简单
第一个方法带有编码器的encodeRestorableState
你可以在任何NSResponder方法上实现
并且就像使用NSCoding一样但是这是为了控制器的高效率
另一个重要的调用是invalidateRestorableState
这就是说无论如何我的支持数据是什么
对encodeRestorableState已经在某种程度上改变了
我们将安排确保再一次保存状态
在未来的某时
并且最终简单的恢复
这确实像你想的一样非常像initWithCoder
你只需调用super
解码您已编码的所有已编码的数据
然后根据你已编码的信息设置你的UI
现在 这太容易了但是可以使它变得更容易
你只需实现一个类方法restorableState KeyPaths
请求一下super因为这是有礼貌的行为
但接着也得添加我们的关键路径
并且这是你希望的可以自动恢复的属性
或者通过系统存储和恢复
这些属性需为KVC
这些键值编码可以访问就像我们通过关键路径访问
并且它们也需要有可观察性以便于我们可以随时观察它们
当它们变得无效或者状态改变时
这是状态恢复
我们接下来看第三个和最后一个技术在云端的文件
很久以前
在云端选择文件
不得不主动选择并创建一个容器
但伴随着iCloud Drive尤其现iCloud Desktop
和文档的发展
很可能你的应用正使用文档
存于云端
这很重要因为10.12版本新特性中
本地的文件可能因为要腾出空间而被移除
这意味着你可能会正在使用一些
并不是真的在本地硬盘上的文件
我们如何处理这问题呢？这看起来非常可怕
幸运的是若你使用NSDocument
它将为你处理一切因此你无需担心
如果你没有使用你需要确定你正使用文件协调器
若你将自己注册为文件演示者
通过文件协调器API
我们将确认文件没有被程序移除
这是一件好事
接下来如果你使用文件协调器
来协调文件IO
我们将会确保方便安排你的IO
当这个文件被完全下载以后
这些在云里的文件
这有一些技术我们没有时间详细论述
但是我确实想要给你们一个提示
首先是资源目录
比在你包里松散资源更快更小
它们也可以帮助你比如广色域和从右向左
可访问性 十分重要
Cocoa搭载了功能确实强大的可访问性技术
你的应用轻松拥有的技术
你得确保
学着使用voice over和所有这些可访问技术十分重要
确保你的应用做正确的事情
你永远不应该发布一个用户界面有问题的应用
所以不要让一个UI有问题的应用上市
沙盒和XPC服务
两个不同的但有关连的技术
这两个技术可以帮你隔离代码
从系统的其他部分和其他进程中
沙盒对于MacApp Store是强制性的
但它对每一个应用都是合适的
XPC服务 可以帮助你分离出代码
到分离的进程中
这是非常棒的对一些事 如
处理一些不可信网络的数据
或者做一些分析工作
我们都认为我们的代码是最棒的
但是如我们开车时系安全带
这样在发生问题时我们会有保障
我们在短短的时间内讲了大量的内容
所以我想带你们重温一下重点内容确保你们都还记得
就像我们刚刚谈论的
我们以创造一个“现代化外观”开始
通过我们的现代化视图与窗口管道
确保你可以做出流畅的动画
接下来我们讲了拖放与事件追踪
确保你得到一个非常酷的拖动群集效果
现代化拖动file promises
接着我们讲了容器视图像是滚动视图和表视图
并且确保可以正确将其本地化
然后我们讲了系统的外观storyboards
还有一些现代的Mac特性
使Mac平台炫目 并且确实有益
这有我们演讲的永久链接你应该可以从这里找到相关资源
包括我们的演示应用下载
一旦该应用就绪
所有相关演讲已结束
我希望你出席了那些演讲
如果没有希望你一定要在线观看视频
就这样谢谢大家的参与