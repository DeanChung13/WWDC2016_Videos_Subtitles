在StoreKit中利用Swift 3进行In-App Purchase
大家好
我是Dana DuBois
在基础框架团队担任技术经理
在iOS和tvOS上框架可以帮助App Store更好发挥作用
今天我们要谈论的是众多框架中的一个
它是StoreKit
你们当中许多人知道StoreKit已经存在了很长时间
它是在iPhone的iOS 3系统中被引入的
从那时起到现在它已经被成千上万的应用使用
来实现各式各样的商业模型
报纸 杂志 游戏
甚至约会应用都使用StoreKit
它实实在在的被广泛使用着
关于StoreKit我们在WWDC 上已经谈论了很多
今年我们将要做一些新的东西
我们谈论它在Swift上的使用
听上去令人兴奋我们有些新应用接口可使用
多了一些新的东西那就是Swift API
那真是太棒了
在上周 你们中的许多人或许已经听说了
围绕着程序订阅我们发布了一些重要的通知
这同样也令我们兴奋
我想很多开发者最终会去
使用程序订阅的增强特性
我将给你们大体介绍下它的新特性
首先 分类
我们十分兴奋的宣布
分类将不再影响你选择
去使用自动更新订阅在你的应用中
但标准仍将存在
指导你如何使用自动更新订阅
但分类将不会再是一个重要的影响因素
其次 每个人都会感到兴奋
就是我们会把更多的收益给开发者
假如你保持你的订阅用户使用一年以上 那是极好的
我想那将是一大单生意
定价
我们将更多的控制权给开发者
开发者通过iTunesConnect来设置定价
基于领土之间 国家之间为他们的程序订阅
如果由于商业原因你需要调整在欧洲的定价
相比于美国来说相对于过去现在你有了更多的权限
随着定价的改变 我们将给你能力
来保存价格 为部分用户保留价格
那些已经使用了你程序订阅的用户
仅为新的用户调整价格
假如你想奖励早期的使用者
你想让他们继续使用你的程序订阅
但是你想为新的用户调整定价
现在你有这样的权利了
随之而来的是程序的升级和降级
这也是我们给与用户更多的权利...
准确的说用户可以在你的服务中选择想要的级别
假如用户想升级到白金级
或者是回到普通级别
他们可以通过管理订阅界面来进行升级或者降级
在他们的设备上
以上就是程序订阅新特性的大体介绍
更多关于程序订阅的内容
如果你想将程序订阅集成到你的应用中
你真的应当去 扩展订阅的介绍
在iTunes Connect
今天下午四点在Pacific Heights
他们将深入介绍如何将程序订阅集成到你的应用中
如何在你的应用中去管理你的程序订阅
我极力推荐你们去参加那个活动
这就是程序订阅
我要兴奋地通知大家除此外 还有新东西
那就是iMessage应用
我们在昨天的主题会中已经展示了
我们将带给大家一个全新类别的应用
在iMessage应用和iMessage中
你将可以构建自定义的扩展
我们将在这些扩展中允许In-App Purchase
在iMessage应用可以使用同StoreKit几乎一样的API
你今天或许使用着你在应用商店下载的普通应用
假如你有额外的内容发布到市场
或者在iMessage中让用户体验
现在我们支持它们了
这些特性将在iOS 10可以使用
我们为这些特性感到兴奋
我想开发者们将会很好利用这些新特性
就像我之前说过的StoreKit已经存在一段时间
人们已长时间使用In-App Purchase
但对在座的一些人它是新的东西
我将简单的介绍何谓In-App Purchase
In-App Purchase是数字内容或者服务
可以在你的应用中进行购买
然而 要清楚 它不是实体的商品
还有其他方法进行购买
这仅仅只是关于数字内容和服务
当我们谈论数字内容和服务时
还有一大堆其他不同的类型
当使用iTunes Connect对它进行配置的时候
有许多的选项需要你去确认
你需要选择适合你内容的类型
让我们来看下我们谈论的东西是什么
可以消费的商品
人们在玩某个游戏时都有一定数量的金币
流通的货币 或者在疾驰汽车里的汽油
或者是用户想要购买的一些东西
买一次 又买一次 用光剩余的时间
这就是可以被购买的商品
不可以被消耗的产品是一成不变的
它始终一成不变 只要用户想使用它
用户们能恢复它
它可以在设备之间传输
这是可消费和不可消费产品间的细小区别
同样在一个游戏中你有一把剑
或者你有一些类型的武器再或者你驾驶一辆疾驰的汽车
或者等级又或者你有一个实用的应用
你的应用或许有一个基础版本
你或许想推出一个高级版本的应用
那就是一类不可消费的产品
当我们谈论程序订阅时我们也有两种类型的订阅
有一种不能自动更新的订阅
像它的名字那样
它不会自动更新它的更新取决于你和你的应用
你的后端来管理如何去更新订阅
我们也有自动更新订阅
这些程序订阅的使用者会周期性的付款给Apple
这些都基于你在后台的配置
假如它是每月的程序订阅
每个月我们会给用户出账单
只要他们一直选择使用程序订阅
以上就是订阅的类型
让我们将In-App Purchase加入到你的应用的核心部分
我们将要快速浏览
这些种类中的所有步骤再深入了解其中的每一步
接下来我们将谈论的是如何在Swift中使用它
你清楚的知道你需要去担心什么
或者你曾经碰到的问题
太多的事情有时会让我们感到厌烦
当你在开发中解决StoreKit的问题时
一些事情需牢记
首先...
你需要准确了解你出售给用户的是什么
对于消费者就是使用你应用的用户
需要做的仅仅是辨识出这个标识
这些你将发布到应用内的标识
将立即展示给用户
一旦你拥有了这些标识你可以前往App Store
获取到这些信息
本地化和标识相关的产品信息
确定本地化的信息很重要
App Store是全球化的应用市场 你需要确保
你展示给用户的是本地化处理后的信息
一旦你有了这些信息你就可以展示你的产品
你可以去App Store发布他们出售你的产品
你的应用你做主
你可以构建优质的UI展示它们
用户会被它们吸引 然后去购买
它们将会被出售 用户会去挑选产品
立即看到产品
但是你需要为你的产品创建支付
并且把它加入到了支付队列
接下来我们谈论的内容会有许多关于支付队列
当支付的订单通过支付队列时
关于交易的通知会被推送到你的应用
推送到达时你必须做出必要的响应
就是你将如何处理这些交易
最后 当支付完成后
你需要确保应用是可以正常使用
告知用户它们支付了什么
最后通知支付队列你已经处理了这笔交易
处理完所有的事情 产品是可用的
这样这笔交易就完成了
这就是你需要采取的不同步骤如此迅速
我们将深入了解我们提到的每一步
需要特别注意的是支付队列
支付队列是应用内购买的核心
In-App Purchase购买中
对于支付和购买的状态来说支付队列是它们的来源
由于它们贯穿支付过程的始终
从用户选择商品到完成支付
需要注意
你应当依靠队列并且只能依靠队列
并且需要了解交易的过程 支付的状态
假如你使用主机去下载
支付队列将会告诉你所有的这些下载
另一个需要注意的是
如果支付队列告诉你有一笔支付
它就是有效和真实的支付
在实际过程中 我们看到过一些案例
开发者有可能自己做了缓存
开发者会知道用户点击了产品
开发者管理着支付的各种状态
然而这些应用有可能会崩溃或者会发生其它事情
用户将会在完成支付前关闭应用
用户们将会回到游戏或者其他地方
他们进行支付的页面
开发者没有必要关注这些响应
来自于支付队列
因为它们没有监听这些交易的支付
他们自己的队列没有支付队列的状态
因此你真的需要依赖支付队列
来告知你在这些支付的过程中发生了什么
在实际应用中支付队列十分重要
在这里我们需要加入一些代码
当你启动应用时用来监听和观察支付队列
我们可以在这儿的例子中添加代码
我们的didFinishLaunchingWithOptions函数
在我们启动应用的时候会最先被执行
我们用它创建监听支付交易的观察者
在这个例子中它是应用代理本身
我们把它设置到了支付队列上并且把它加入到支付队列
如果支付队列有事情发生
在我们启动应用前已经发生
我们将立即收到交易的通知
另一种被提及的是
在In-App Purchase时使用兑换码
用户进入到App Store
并且在你应用的外部使用兑换码完成了In-App Purchase
用户乐于使用In-AppPurchase进行消费
然后进入到你的应用中
如果你没有监听支付队列
产品将不可用
在应用启动的时候你需要监听支付队列
以上是关于支付队列的简记
让我们回到实现流程上来
准确理解如何添加支付队列到你的应用中
首先要做的是加载标识符
为In-App Purchase
进行iTunes Connect时会有相同的标识符
你需要定义这些标识符对他们进行命名
开发应用时要获取标识符的列表
有不同的方法来获取它们
如果你的应用十分简单
你或许仅仅需要将这些标识符复制到你的应用中
如果你的应用有基础版本和高级版本
你有可能仅仅有一个可消费的版本
你仅仅需要复制标识符到你的应用中
然而 我们看到许多应用并没那样做
它们倾向于在外部
并且从他们提供的主机上获取应用内标识符
以便应用过期后它们可以改变应用的可用性
或者准确地说可以改变呈现给用户的内容
它们这样做是没问题的完全是符合规定的
我们想要说明的是如果你这样做
请确保你的主机具有稳定性和较高的可伸缩性
是In-App Purchase流程的开始
最坏的事情是展示给用户的价格需要进行微调
当用户正在等待购买的时候
这应该是可能发生的假如你能提前抓取信息 那是极好的
如果你能在设备上缓存这些信息那就更好了
你要清楚的知道如何进行抓取和保存这些标识信息
即然你已经有了这些标识信息
你需要去App Store来抓取产品本地化的信息
同产品密切相关的信息
你可使用SK产品请求来完成这些操作
这样你就可以拿到你感兴趣的标识符
为了获得更流畅的用户体验
你需要提前抓取这些标识符
你想要知道当用户有可能感兴趣
在看到你的In-App Purchase时
你能在第一时间获得这些信息
你首先要做的是创建你的SK产品请求
你传递你感兴趣的标识符
你需要设置你的代理
它将给你的应用返回信息
当这些产品被加载的时候
你仅仅是需要调用开始那是如此的简单
代理看起来像上面那个样子
我们有产品请求didReceive函数会响应
它将传递给你从App Store上下载的所有产品
每一个产品将会保留这些信息
像本地化的标题和描述
像我之前所说的App Store是面向全球的应用市场
你是向全世界发布In-App Purchase
最好确保
你正在使用本地化的信息
来进行你的交易
比如本地化的标题和描述
甚至更重要的是价格和的价格本地化
你想提供给用户In-App Purchase价格
你需要确保呈现给用户的格式是他们能理解的
在全世界流通的货币呈现的方式是不同的
你要知道正确展示价格的重要
我们将会讲到这些
最后你拿到你的In-App Purchase内容
启动iTunes Connect时这些事会发生
我们会给出下载时长的信息
和购买相关的版本信息
就像我提到的定价该信息也很重要
当你呈现这些价格的字符时要做出正确的选择
当你呈现这些价格的时候你想要使用换算到本地的价格
将它转换到NS的数字格式
你将获得关于定价的相关信息
那个NS的数字格式将会带有价格的信息
对它进行本地化操作
假如你对它设置了货币格式你可以确信
你获取的价格信息是正确的
你要做的另外一件事情是
不要在进行货币转换的时候进行无关的排序
App Store知道如何进行本地化对货币进行转换
所以不要做任何其他无关的操作
只要把定价原本的样子用NS数字格式呈现出来
下一步就是呈现你的UI
接着将不会过多谈论产品的本地化了
你的产品你做主
你知道如何呈现你的UI使你的应用尽可能获得更高的销量
然而 一旦购买完毕
或者一旦UI被显示 我们将立即跳转
自动完成购买
添加并且创建SK支付对象完成上面的操作
并且把它加入到支付队列当中
一旦你创建了SK支付对象并且添加到支付队列当中
随着支付的进行你将会获得一个回调
通过它更新交易
这就是你刚刚添加的支付队列的观察者回调
当应用开始调用的时候
你创建了支付队列的观察者
观察者会调用支付队列的函数来更新交易
在支付进行的过程中你将获得关于支付的消息
你需要做的就是创建你的SK支付对象
将创建的对象添加到支付队列当中
消息开始陆续到来
你将会获得关于整个交易过程的信息
你可能有一条消息也许有许多条消息
你需要遍历这些交易
并且监听每笔交易的状态变化
有许多不同的状态
它们之中你最感兴趣的是购买的状态
从那儿你可以知道购买完成了
继续去激活购买
我们将获得一小部分数据使得应用的内容是可用的
然而 我想说还有另外一种状态
那就是延迟交易的状态
延迟是在iOS 8中为了购买前询问特性添加进来的
这是为了让家人共享iCloud
家里的孩子可以去进行购买例如In-App Purchase
孩子们的父母 监护人 担保人
可以决定儿童可不可进行购买
延迟的状态是你在登录状态进行In-App Purchase时
延迟状态需要获得来自父母的许可
我们看到许多这种情况并且想要将它解释清楚
如果是在延迟状态你不能阻塞你的UI
你应当以某种方式对它进行处理...
也许购买最后没有发生
允许孩子们尝试用你的应用进行购买
让孩子们返回并且继续可以使用游戏
或者是他们感兴趣的任何内容
因为延迟购买会持续一小时或几天
在他们父母审阅和同意这次购买前
不要微调 不要弹窗
仅仅是像购买从来没有发生过一样
就像你知道还没开始一样
一件我也想做的非常重要事情是
当你进行In-App Purchase时测试你的应用
就像测试你应用的其他功能一样
通过iTunes store可以实现上面的操作
沙盒环境
沙盒环境是一个特殊的环境
假如你运行的是有开发者签名的应用
你进行的所有购买都会进入沙盒环境
然而 假如你对延迟交易的测试感兴趣
没有比创建一个家庭账户更好的方法
这样你就能在沙盒环境下测试延迟交易了
假如你想在沙盒环境中测试你的延迟交易
你可以使用SimulatesAskToBuyInSandbox
你可以在你的SKMutable支付对象中创建它
你传递给你的产品
然后你设置SimulatesAskToBuySandBox标记
这个标记会告诉App Store 嘿
对待这次购买就像家里有小朋友在进行购买
一旦你将它加入到支付队列就会被发送到App Store
然后App Store将会在你的应用中返回给你延迟的状态
这种方法可以让你知道你的应用可以在儿童购买时正常工作
我们同样需要谈论一下关于错误的处理
不是每件事情都正常执行
在你的应用中也会出现错误的状态
尤其是在In-App Purchase时
你需要牢记的是不同的错误需要不同对待
我强烈建议你翻阅In-AppPurchase编程指南
或者StoreKit框架参考指南
来更好的理解使用中出现的错误
随着程序的运行会有相应的返回
需要记住的是
大多数错误是不需要你去通知用户的
许多错误是我们通知开发者的
让开发者在应用中进行处理
我有过类似的经历
我在使用开发者开发的应用我随意浏览着
我在进行网上购物
我点击了购买
确认了价格紧接着StoreKit的窗口就出现了
然后我又改变主意了我想返回看看其他东西
我选择了取消
可是取消发生错误
取消错误确实在你的应用中发生了
没有必要将取消错误的警告展示给用户
我们有时会在应用中看到这些错误
用户知道他们进行了取消操作
没有必要重复展示给他们
尽可能让StoreKit处理交易流程
再次强调我们将要谈论支付队列
支付将会在支付队列中进行处理
App Store和StoreKit会要求用户进行购买确认
他们将会给出一个价格
这个价格需要同你应用内价格进行匹配
这就是为什么确认本地的价格信息正确
是如此重要
我们会对用户进行认证
如果账单信息有任何问题
我们需处理账单问题
弹出确认框或者做其他的特殊操作都是不必要的
让StoreKit为你处理这些问题
我们谈论了进入交易队列前的一小部分
我们谈论了支付返回的一些状态
一旦你的支付变成了购买的的状态
你需要在你的应用中做出多种选择
特别的 你需要验证购买的时候
可以使用现金进行交易
我们有好几种方法来完成这些购买操作
但是再次强调 你的应用你的产品 你做主
你要特别注意你使用什么技术
你用何种安全级别验证购买的合法性
回执的验证 回执会返回给应用
在购买的最后环节
回执就像消费者拿到的账单
当你在商场进行购物或者类似的事情
回执包含购买的所有信息
还有购买的In-App Purchase
有两种主要的方法
你可以进行回执的校验
首先是在设备自身上验证
接下来是回执
你可以编写代码将它在设备上分为几部分
授权来自Apple的回执
确认回执的现金来源是有效的
做这些是为了解锁应用中的一些特性
和内容
这是你必须选择的
这些购买完全只能在客户端进行吗？
或者说如果你有服务端
你想在服务端做回执的验证
因为你想让服务器为你的内容和服务提供网关服务
为了完成上面的事情你需要将发送到设备的回执
上传到你的服务器
然后让服务器发送回执到App Store
有后台的API可以对回执进行验证
这可以做到从服务器到服务器
需要注意的一点是App Store有后台API
可以接受和验证回执
但是你不能通过你的设备直接发送回执
那样做是不安全的
如何保证来自你应用的回执是可信的
如果你想验证回执的有效性
回执应当通过你的服务器
传递到App Store的后台
让我们来深入了解下回执是什么
回执是你在进行In-AppPurchase时得到的可信记录
它包含的信息允许你知道
在这个设备上用户已经购买了应用
对开发者而言是用户在他们的设备上进行了购买
回执存储在设备上
你应用本身的容器中
回执由App Store签发并且包含一些信息
允许你验证来自App Store的回执信息
这只是针对你的应用和设备来说
如果你的应用在不同的设备上运行
对于不同的用户得到的回执也是不同的
这样做是为让你知道回执大体的样子
存储在App Bundle中
我们提供应用程序接口允许你能获得这些信息
过一会儿我们将看到它大体的样子
它是单个文件
很早很早以前回执的版本
以前每一个In-AppPurchase通常会有多个文件
但是自从iOS 7开始我们有了统一的回执
在一个文件中包含了所有的信息
它里边也包含了证书和签名信息
允许你通过这些信息验证回执
我们通过使用公钥密码标准
7容器来完成上面的操作
容器里边包含了所有信息
容器使用的是开放的标准
你有许多可以参考的信息
关于如何使用PKCS7标准容器
容器进行加载
里面包含有用的信息
是需要你去解析的
里面的编码是ASN1格式的也是公开的标准
有很多不错的标准可以选择用来做回执的验证
OpenSSL就是其中的一个
有时开发者会创建他们自己的标准
在这儿我要强调的是
这是你的应用 这是你的钱
这是你的生意
如何更好的验证回执依赖你做出的选择
你要使用什么技术
然而 不论你选择什么都会有相似的处理过程
你在支付过程中会经历的
首先 你需要在你的应用中定位回执
使用NS bundle API
上面就是它在Swift中的样子
你可通过NS Bundle进行调用
App Store回执的URL会通过上面的函数回传
它是本地的URL 在本地的文件系统
一旦你有了URL你需要把它放入NS数据中
你可以获得二进制形式的回执
需要注意你现在已经加载了二进制文件
证书会有过期时间
你必须十分小心
在核对过期日期的时候
只是因为它是发行在一定时间内
并不意味着那个有效期是有效的
在未来所有时间里
所以如果你正检查有效期
比较App Store发行receipt时间
而不是当前日期
它不像SSL握手 你每次都想检查它
只有被发行时 它才是唯一有效的
或者只有被发行时这才是唯一有效的检查日期
或者它是完全有效的根本不用检查日期
但是你要做的是检查
receipt上的根证书颁布机构
这将验证它来自Apple
你可以相信它 因为它是Apple的receipt
所以检查到根
所以再次，这只是一种给你一个想法
关于receipt内部的情况
它的有效负荷 我所说的ASN1格式
是一系列的属性
你可以把它当做一本NS字典
它包含类型和值
还有我们将要标记一些这些类型和值
那里还有比我们今天讨论的更多
你可以在线得到很多
通过我们的receipt验证编程指南
但是一些你主要想使用的是
类型2和类型3 包括捆绑标识符
和receipt的捆绑版本
希望这和你的应用程序中的匹配并且你应该检查它
所以你应该检查捆绑标识符和捆绑版本
然后要记住的一件事是
你应该在你的APP的二进制文件中使用硬编码值
这是一个更容易让我进去并改变信息列表P
如果那个是你正在使用去匹配的假receipt
相对于我同改变你程序有效负荷去匹配receipt
所以如果你真的想去确认那个receipt是
为你的程序的 使用硬编码值
你现知道这receipt是为你的应用程序的
你想去确认它是为
那些正在运行receipt的设备
这是一个小的技巧
你要去做的是看一下SHA-1哈希
它是在类型5中返回的
类型5包括这个哈希
哈希是有信息片段组成
是App Store在购买时获取的
是你在验证时获取的信息片段
特别是捆绑的标识
所以你想在你的应用中保留硬编码值
你的APP绑定标识
设备标识
这是一个或多个API用于那个
它是在iOS和macOS有些不同
但是你要加载这个设备的标识符
然后这个不透明的值
这个不透明的值是基本上一点加密熵
它是一个包含在回执里的加密盐值
它允许哈希随着时间推移而改变即使如果绑定标识
和设备标识不改变
你应该基本上获取这个在receipt里的不透明值
把它包括在你的哈希里
一旦你拥有了它 SHA-1哈希对比它同属性5
如果匹配 你知道它是你的设备
对于你的在设备上的APP是唯一的
receipt还包括你的所有in-app purchases信息
所以我们这里所看到的是全部远不止类型17
类型17是为了用户用你的应用程序所做的每次购买
它包括一条关于in-app purchase的记录
类型17的有效载荷
不是一个字符串 它实际上是另外一个ASN1文档
它拥有自己的值
所以这些看起来像什么
好吧 1701 这是购买的数量
所以我们以前讨论过消费品
用户能有购买10包硬币在你的游戏里
或者100包硬币
这将是数量 购买的数量
这是针对特定的标识符
这个产品标识符，我们以前讨论过
这个是那个标识符你用来
从App Store加载你的in-app purchase数据
如你在iTunes Connect设置的样子
标识符 这是一个交易标识符
这是一个对于交易的唯一标识符
它被用来购买
购买的日期
然后最后的一个新事物 不是新的
但是一件事我想去强调是我们也包括
自动更新订阅
订阅有效期
所以如果你正切换你的应用去订阅
那是对你非常重要的
你将会使用这种类型 你将会使用它去知道
订阅是否有效
我们是否需要去让用户去或者你需要去仔细检查
用户是否在一个有效的订阅状态
因此领域非常重要
然后另外一个注意
如果你在Store里有个应用
它是付费的并且你有兴趣
切换它到一个订阅模式
有一件事你想去确保你检查是主要的receipt里面
应用receipt本身是类型19
这包括原始应用程序版本
是应用买来的版本
所以如果我买的它是1.0版本的付费应用
并且在2.0版本你转至订阅模式
我想看一下程序的原始版本
因为我想确认我把那个用户当成付费用户
他们是或者不是一个订阅用户
我认为这是一个很差的体验如果模式转换为订阅
并且你并不尊重他们买原始APP版本
所以如果你切换成订阅模式记住这些非常重要
另外两个注意关于receipt
receipt是在购买时发行的
但是它实际上是同样可以续订的
但只针对in-apppurchase的特定的类型
所以当我们讨论可消费的和不可更新的订阅的时候
他们将会在receipt里被刷新
所以可消费和不可续订的订阅只会出现一次
他们出现刚好在交易生成之后
他们不会出现在那里
当用户刷新receipt同样在该设备上
或者当他们切换至另外一个设备
但是 不可消费和自动更新的订阅
会一直出现在用户的receipt里
你可以拿回那些东西
应该拿回那些东西通过StoreKit API
我们可以看一下那个看起来像什么
他在IOS和macOS有些不同
在iOS receipt不存在或者是无效的
你应该使用StoreKit API去刷新它
但是记住你必须拥有网络
我们需要去连接App Store
我们需要去验证用户
我们必须要知道他们真的是那些已经购买过这个东西的人
所以他们将要输入他们的密码
或者使用他们的指纹
如果你正在做一些事情如
应用每次启动刷新receipt
这绝不是一个好的模式去遵循
或者如果你正在做一些事情如在检查receipt是无效的
然后获取它，因为你知道或许有些东西
有些东西看起来不对
你想小心点你不会陷入一遍又一遍的循环中
如果你的应用崩溃而你正检查你的receipt启动
或者如果你保持检查并且它是无效的
关于的验证码就是不对的
你不想去验证和取回那个receipt
一遍又一遍
所以这些都必须要小心
这些能够在iOS完成通过
这些能够通过一个SKRecipt刷新请求完成
你设置的代理并且调用了start
这个会在代理中通知你的应用程序
当receipt被更新而且你能继续
并且处理这些交易在receipt中
就好像他们由用户购买一样
在macOS一点不同
如果receipt是无效的
你将会退出伴随着编码173
这个会告诉Finder他们替我把receipt取得
再次 这里需要网络
用户可以登录Store
这个可以完成通过调用exit 173
然后我只想去再次强调server-to-server验证
若你正在做一个自动更新的receipt并且你有
一个自动更新的订阅
如果你有在服务器上可用的内容
你可能有一个hosted implementation备份你的in-app purchases
所以如果你正在做server-to-server验证
这个会允许你去在服务器端验证receipt
那是用户获取用于他们的in-apppurchases是有效的
因此你拿到在那个设备上的receipt
你上传它去服务器
但是 我要再次强调它
不要直接发送receipt去验证receipt的端点
这是不安全的还有你不应该那样做
有件事需要注意是验证receipt的端点返回的是一个JSON
有效载荷和实际包括信息
像如果你的receipt过期了
你会从App Store那里得到最新的版本
它会包括一些关于它有效的信息
或者如果receipt的状态不对
所以再次 有在线文档
关于到底验证receipt的端点如何工作的
好吧 我们已经通过了我们已经购买了
我们已经完成了交易处理
这取决于你决定到底你怎么去验证
receipt和哪个安全层级
你将要把它放到后面还有什么技术你将会使用
你验证了那个购买是真的
那个背后有一个货币交易
使用户可以买到什么取决于你
再交易结束的时候做得很好
这里有两个方法去实现而且我们以前讨论过
你可能只有隐藏在你的应用的功能
你将要解锁的
你的一个基本版本的应用程序
一个免费的基本版本现在已经是一个专业版本
你只需要设置那个状态并且确保对用户是可用的
或者如果你有来自服务器上的内容
你需要去下载它
一堆不同的技术
一堆实现的不同方式
现在我要强调它们中的一部分
一个是Apple提供的一个更新的
是按需资源
这个方法能使你的应用程序
在初始下载的时候尽可能的小和压缩
如二进制文件
如果你要去让别的资源
关联应用程序
如果你的游戏有一堆不同的等级
而它们让你知道图片和视频关联它们
你可以在你的应用清单里把他们分解成不同的组件
按需资源是托管在App Store中
所以你不同担心托管的问题
它是可扩展和稳定的
我们已经用这个为全世界缓存
你的用户可以更快的获取他们的内容
一件事需要记住的是
它可以包含任何类型代码执行异常
所以所有的代码都在你原始的二进制文件里
但是它可以包含其他类型的你想要的内容
它只在IOS和tvOS中可用
macOS现在不支持按需资源
所以那个技术是你可能选择去使用
它去获取额外的内容在购买完成之后
如果你有兴趣想了解多一些关于它
我强烈建议你看一下“按需资源的优化”这个讲座
它在Mission里 在这个房间周四早上10点
另外一个Apple提供的技术是in-app purchase托管内容
你可以这个内容关联你的in-app purchase
在iTunes连接和再次连接
它托管在Apple服务器上
所以你不用担心主机本身
可扩展和可靠地
缓存全世界
一件事需要记住的关于这个和ODR
是这个会在后台下载你的内容
你的应用不需要运行
所以用户完成购买并且会离开你的应用
运行其他的应用而你需要去下载这些内容
那些会继续运行
每个in-app purchasable产品你有最高2G容量
所以不是所有的应用程序共有2G容量
是每个产品2G
这个iOS tvOSmacOS是支持的
所有 再次另外一个拥有Apple托管内容的方法
为你in-app purchase
让我们看一下那个可能看起来有点
一个付款通过了
用户 你验证它并且你准备去下载内容
你将在更新的交易中回调
你的付款观察者
那么我们再往下一点
你将看到你的交易
你将获知一笔其中的交易
包含一个或多个下载
你所需要做的只是回传那个下载
去“支付队列” 它会开始下载
如果你的应用程序有兴趣使用托管in-app purchase
你将拥有一个支付队列更新下载的方法
在你的支付队列观察者里
这个会给你全部的信息
关于下载当他们进来
包括像进度这样的东西会调用并让你知道进度
你会用这个去更新UI
或者时间剩余
或者如果错误发生你需要对它做出反应
这些信息会在这里
然后一旦下载完成一个URL会被提供
那是一个本地URL 就在文件系统上
所以你可以抓取它然后在那里你可以与你的内容进行交互
这是in-apppurchases托管怎么工作
但是你可能也想自托管这些内容
完全有效的事情
如果你有一个随时间变化的目录
如果你有一些不同的东西你不需要
去放到Apple托管自托管内容完全有效的选择
一件事需要记住那里有后台下载的API
你必须用NSURL会话调用
这个是托管这个内容的方法
内容可以被下载即使你的应用不是激活状态
若你扔使用NSURLConnection
那是过时的
那不是一个好的体验
对应用户来使用NSURL会话
所以这个是非常重要的对于你使用这些API
这个是它在Swift中的样子
你将要创建一个会话配置
这是一个配置你想命名为一个唯一的
对于你的应用程序用于描述那个会话是关于什么的
你将要创建会话
你要传入配置的值
你要传入代理 这将是任何对象你想要
获取这些下载的信息
你会给出队列
这个操作队列实际上是在你的代理中被调用的
什么线程和什么操作队列将会在代理里调用
所以你想要确保你创建了一个专用的
操作队列
然后开始下载 你创建了一个任务
你递交请求和与in-apppurchase关联URL
你调用继续
这个会在你的后台开始自托管in-app purchase下载
伴随着下载开始你的代理会接收到信息
它将在URL会话didWriteData方法里被调用
这会给你这个能力
你可以带入这些信息
并且它能让你去更新UI
你可能有一个进度条
或其他东西你想告诉用户
关于下载的进度
但是重要的你要记住你的应用程序有可能退出
在下载的过程中
所以当你的应用程序重启
你想把这些后台下载会话重新连接
所以在你的应用程序代理里
你会执行处理事件为后台URL会话
这会让操作系统唤醒你的应用程序
并且告诉它这个后台下载刚刚完成
或者正在进行 或者出了什么问题
所以处理事件为后台URL会话
这里会把之前使用的配置的标识符传入
你会重新创建带有标识符的配置
重新创建一个重新连接后台会话的会话
然后你要做的是那里有个完成句柄
它会被传入应用代理方法
你需要去调用完成处理程序
一旦你完成了你就完成了所有关于下载的动作
所以如果下载完成你需要去把它放入你的容器
解压它 让它工作
你需要去调用完成处理程序一旦你完成了所有工作
让OS知道你已经完成了所有工作
所以这能使资产可用
但是你还没有完全完成
即使你已经做了所有可以做的
用户已经拥有他们买到的
你还是要做另外一件事你需要告诉StoreKit
你已经完成了交易
这个很重要因为我们保留这个交易
在我们的购买队列中
我们保留它在我们的state machine
如果你的应用程序死机并且重启
或者用户离开并返回
支付队列会持续告诉你这些
它实际会持续做这些在你行为后台API调用的时候
所以这样会用光用户的数据空间
所以及时清理是非常重要的
在你完成交易之后
但是你应该确保是你做的
当内容下载完成
如果你完成了交易 然后开始下载
我们会再告诉你关于那个交易一次
所以如果下载失败或者下载出错
你不会得到更新信息
所以你要确保下载完成
然后调用完成交易
所以 再次 支付会继续在队列里直到你完成它
如果你正在下载托管内容另外一件你需要记住的
是你需要完成下载
如果你在下载完成之前完成交易
我们会停止下载
这个可以很容易被实现通过调用SK支付队列
完成交易和传递交易到支付队列
所以 用户已经使用你的应用他们已经购买了in-app purchase
他们喜欢你的内容 他们决定
你知道我的空间已经用完
我会删除应用可能我稍后会重新下载它
或者他们切换到另外一个设备
这总是很重要的他们可以要回那些
非消费型和自动更新in-apppurchase到应用里
他们需要能恢复以前的内容
所以恢复交易允许用户
恢复非消费和自动更新的订阅
消费的和非自动更新的订阅
这取决于你去管理这个状态
所以可能有一些你刚好保存在本地
可能有一些你存储在Cloud中
或者你存在自己的托管后台
这取决于你去管理你究竟想如何恢复内容
但是对于非消费和自动更新
你可以恢复它们使用恢复API
再次 我们提供API用于SK支付队列恢复
完成交易
那能够降低一个品牌的应用的更新版本
和in-app purchasereceipt
再次 你会想去观察队列
你把它加到你的应用代理 所以当然你正在观察队列
你正在获取信息
关于这些交易当它们进入
因为我们将调用
支付队列恢复完成 交易结束
这个会告诉你所有的发生的恢复
你会只想去处理它们
好像它们刚被用户购买
或者我们会告诉你错误发生了
可能你需要让用户再尝试一次
或者对应的更新你的UI
所以 观察队列非常重要
再次 一旦恢复完成你可以看看receipt
并且解锁对应的内容和功能
现在我们会感觉好点的是
你创造了自己的应用
你准备去提交它到App Store你想确保
你能通过审查
有些事情需要记住
我们刚刚讨论的恢复
你真的需要一个恢复机制
它不必要是个UI按钮
你需要一些应用内在机制去允许用户
要回他们的内容否则这不会通过审查
再次 对应非消费和自动更新的订阅
你不会在恢复中得到其他的in-app purchase类型
一件事需要记住的是
我们想让这些同购买隔离开
恢复是免费的
用户不会感到疑惑如果他们做了恢复
他们需要输入来自App Store的密码
这会消耗他们任何东西
这个在你的应用程序是非常明显的
他们做的这次恢复操作不是一次购买
这是完全隔离开的
所以你要确保的是你的UI反映
其他你想要记住的消息
对于自动更新订阅的是关于政策的
保留信息在市场文本里
确保一旦他们订阅了
他们就可以立刻得到内容
他们不需要等待直到下个阶段开始
任何东西出现
如果你订阅了你应该会马上获取一些信息
你应该获取信息
关于你应该只能通过订阅获得
而不是一堆产品或者内容
他们本可以在别处获取免费
所以 这就是一些政策
我强烈建议你看一下“APPS审查政策指南”这个讲座
我已经听说现在已经有一本漫画书关于它
所以我强烈建议你把这些全部学习一遍
因为它们一直在变化
你应该时刻关注它的变化
关于非更新的订阅这里有些其他政策
你要记住
关于隐私和确保用户有能力去参与
或退出
然后最终这最重要的事情是通过应用反馈
是如果你已经在你的应用里拥有购买它应该可以工作
你完成购买 内容就应该出现
它们应该得到信息
他们应该在那里得到内容
如果它是缺陷或者如果他是容易错误
或者如果有什么事情发生当评论人正在评论它
在应用评论环境内部
你就会在那里立刻得到评论中的问题
所以测试它
测试它在Sandbox确保一切如你期望的工作着
所以刚才总结下我们今天讨论的
始终遵守支付队列
如果你在你的应用里与in-app purchase交互
首先你的应用应该设置一个支付队列观察者
去获取信息关于支付的进展情况
你应该从App Store中获取本地化产品信息
这是通过一个SK产品请求
它会返回本地化信息
所以用户在他们国家的信息
关联到App Store账户账单信息
再次强调使用产品所在地的货币单位
这里有个SK产品返回它有一个关联的场所
你应该去使用它为了展示价格和货币信息
使用receipt去验证你的购买
再次 它们是你的购买 这是你的生意
你应该去做决定关于怎么最好的去验证receipt
是否在本地验证或者在服务器
后面是什么技术
要知道到底每个优点和缺点是什么
用那个做下你的决定
最终使内容是可用的
你可以在那个设备的你的应用里解锁它
或者你可以发出一个App Store自己的托管请求
或者你可以发出一个请求到后端主机API
使内容可用
但是用一个可靠的而且快速的方法做它
如果你自托管确保你的服务器是可扩展的
你知道缓存适度
是真的准备为了用户很好地使用你的应用
然后最终完成交易
最后一件你需要确保的事情是
交易不再存在在支付队列中
否则你的观察者将会不断的被通知
关于它当你的应用启动
这将感觉很奇怪用户可能不得不
在特定的时间进行身份验证
或者那里可能存在后台代替你应用的API正在发生
为用户使用完数据空间如果你不能完成交易
所以始终那样做
然后 允许用户恢复完成交易
你需要一个恢复机制在你的应用里
如果你有非消费或者自动更新的订阅
这会允许用户去获取之前已经购买的
更多信息请在开发者网站上
我强烈建议你返回并稍后看看它
然后两个相关的话题我们今天提到的
如果你正使用订阅在你的应用里
你应该明确的检查“介绍扩展订阅”
在iTunes Connect今天稍后的时间里
或者如果你对按需资源有兴趣
周四早晨来看一下
这是全部
谢谢