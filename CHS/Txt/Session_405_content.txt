LLVM的新内容
大家好我是Alex Rosenberg
我很兴奋能在此跟你们分享一些
Apple LLVM编译器的新特性
但首先我想讲一下LLVM
基于这个项目我们创建了Apple LLVM编译器
LLVM是一个模块框架用来建立编译器和其他相关工具
但它的使用不一定非要按照传统方法
我们都了解并且喜爱Xcode
它使用了大量的LLVM框架在里面
这个很棒的新应用SwiftPlaygrounds也加入了
也在内部使用LLVM
LLVM也是组成Metal应用内部工作的一部分
以及其他绘图应用编程接口
LVVM是开放资源
Apple长期以来一直坚持开放编译器和语言资源
Swift语言就诞生于LLVM工程
我们很高兴你们还有所有的贡献者
能推动Swift在Swift.org的进化中不断发展
这个进程和Swift的发展进程
受到的启发都来自LLVM项目的发展
LLVM有一个广阔的开放资源社区
由非盈利LLVM Foundation支持
LLVM有很强的自定义性和可组合性
通过利用同样强健和成熟的基础设施
支持Clang前端
我们为Swift编译器提供动力
想要了解有关Swift的更多信息请回顾之前的演讲
现在来简单看一些开放资源里的可用框架
以及可以如何使用它们
Clang是编译器前端支持C Objective-C和C++语言
它的代码库里有很多先进的功能
比如静态分析
编写中会用到代码迁移和代码改写
它也支持开发环境集成
比如源代码索引
以及代码智能补全这是Xcode最受欢迎的功能
开放资源工具库
帮助你利用Clang的力量使用你自定义的命令行工具
来处理源代码
想想看你能做到多少不可思议的事情
有这样完善的语法分析器运行于你的代码
LLVM优化程序这个我们会多讲一点
有一套完整的现代编译器优化
就是这个功能实现了链接时间优化
敬请期待LTO的新发展
然后我们有个后端就是最终代码生成的地方
这里是目标文件操作库
功能有汇编和反汇编
还有更高级的功能
比如即时编译可以很简单的编在一起
LLVM还有很多其他的工具由它的框架组成
让我们来看一看
作为完整的LLVM工具链的一部分
就是常见的一套二进制文件组件
包括开源社区努力做出的一个框架
用来制作链接器和其他相关工具
其他工具概览
但也许之中最出色的工程就是LLDB
LLDB结合了许多库包括Clang Swift
Code Generator以及它自己的一套调试框架
在周五 有一场很棒的演讲
关于LLDB使用技巧和窍门
这些好的特性无论是Xcode还是Swift Playgrounds
还是Apple LLVM编译器都不可能实现
如果没有LLVM开放资源社区的贡献的话
这个社区里都是跟你们一样的开发者
他们很有思想并把他们的想法带入LLVM框架
LLVM开放资源工程发展速度之快令人咂舌
这颇有挑战性无论是团队里的哪一个人
或者哪一个公司都很难赶上
我们想邀请你来LLVM.org参与这个工程
看看你能否融入这个群体贡献你独到的见解
现在我来为大家介绍Duncan
他会跟大家讲一些很棒的语言新特性
在Apple LLVM编译器里
语言支持
我们来讲讲语言支持
首先我们来讲新的语言特性
然后再讲升级C++库
最后讲新的错误和警告来帮助你完善代码
就从新的语言特性开始讲吧
Objective-C现支持类属性
这个功能一开始是Swift中的类型属性
我们将它带入Objective-C
互操作运行良好
这个例子中类属性someString声明了
使用属性语法通过添加class标志
之后这个someString属性使用点语法访问
类属性永远无法合成
你可以提供储存 一个getter一个setter在执行的时候
Objective C类属性
或者你可以用@dynamic来推迟解析到运行时
转过来看C++
C++线程本地存储（TLS）
LLVM很好地支持C++11很多年了
唯一不支持的是线性本地关键字
今年 我们添加了这个支持
我这就讲一下
如果一个变量是以线程本地关键字来声明
LLVM会创建一个单独的变量给每个线程
调出初始化器在第一次进入线程开始使用之前
退出线程的时候调出析构函数
C++类的线程本地存储支持任何C++类型
它的语法可以移植到其他C++编译器中
Apple LLVM编译器已经支持C-style线程本地存储
即便是在编译C++代码的时候
有两种可用的语法
一种是带GCC关键字另一种来自C11标准
C风格线程本地存储负载较低较C++本地线程而言
但是它也受限制
它要求使用连贯的初始化器和简单的老数据类型
哪种TLS适合我？
如果你的代码符合这些限制
你就可以继续使用C-style线程本地存储
以便获得最高性能
如果不符合就用C++线程本地关键字
这两个都很好用
线程本地变量可以帮助修复用户线程代码中的错误
要了解更多线程相关错误的信息
请观看演讲线程检查工具和静态分析
这就是我要讲的新的语言特性
C++库升级
接下来我们看C++标准库
Libc++多年来一直是默认的C++标准库
我们一直建议你们弃用Libstandardc++
在Xcode8的所有平台我们都已弃用
请你也尽快升级
Libstdc++要弃用
如果你的Xcode工程仍使用Libstandardc++
你必须要升级到Libc++
通过更改C++标准库的建立设置
Xcode工程现代化会自动完成这个升级
Libc++.dylib今年在我们所有平台上做了很大改进
它的库现在完全支持C++14还有其他的改善
Libc++Availability属性
需要dylib的标准库特性现也有Availability属性
当Apple框架要部署给过去的目标
鼓励在运行时检查
C++标准库的有效性检查在编译时就已经完成
要使用C++功能需要最新的dylib
所以你指向的平台必须支持它们
这就是C++库
在Xcode7和Xcode8之间
我们添加了100多个新的错误与警告
来帮助你找到代码中的故障
我们简单讲讲其中几个
在Xcode 7
我们给Objective-C添加了很棒的新特性叫做Lightweight Generics
这种_kindof类型修饰符具有十分重要的作用
允许隐式转换到_kindof任意子类
_kindof类层次结构之外的方法
在Xcode 8我们完善了_kindof类型的方法查找诊断
看这个例子
getAwesomeNumber在My Custom Type中声明
这是NSObject的继承类
之后getAwesomeNumber在kindof UIView中调出
这个代码是坏的因为My Custom Type与UIView没有关联
Xcode 8这里就会报错
方法类型检查调出_kindof类型
限制于同一类层次结构
完善后的类型检查也可以避免误导性的警告
当一个无关的类型声明一个名字相同的方法
在Xcode 8 _kindof类型使用起来方便多了
容器的循环依赖
接下来 Objective-C容器比如NSArray和NSMutableSet
可以包含任意对象
NSMutableSet调出“s”在这个例子里添加给了自身
这就造成了循环依赖导致了Xcode 8的警告
除了创建循环强引用
循环依赖可以避免一些方法被明确定义
无限递归
这个例子执行了阶乘函数
如果n是正值就会返回n乘以阶乘n-1
不断递归来计算答案
如果n是0 返回阶乘1还是会递归
编译器这时会收到一个警告
说所有通过此函数的路径都会调出自己
这是最典型的无限递归
这里的一个可能的解决办法就是当n是0的时候返回1
无用移动阻止返回值优化（RVO）
标准转移是C++最好的语言特性之一
它允许你定义所有者可以被传递
从一个container到另一个
转移资源比深拷贝要快
但是要将标准转移用于返回值
就阻止了具名返回值优化
通常当一个本地变量以值来返回
编译器就可以完全避免复制
在generateBars里调用标准转移使编译器移动bars
虽然移动很快但是什么都不做不是更快
LLVM现在就会警告这种无用移动
这种修复是为了避免标准移动返回值
使性能再次下降
同样 当一个函数以值接收一个参数
返回的也是一个值
编译器会自动用标准转移返回
无需额外调出
多余移动干扰样板
如标准移动在rewriteText的返回值是多余的
尽管这不会实质上减低性能
但还是降低了代码的可读性
最好还是直接返回文本
这更方便保持和连贯返回本地变量
参考隐式变换C+- range-based循环
最后这个新的警告是关于临时引用
在C++ range-based循环
这里这个循环是通过一个shorts矢量
但是循环变量 i是一个常用引量到而不是int
由于隐形变换
出现在short和int之间i 就是一个临时量
这会导致一些细微的故障
因为看上去i是在范围内指向但实际不是
编译器这时就会警告这个意外变换
一个解决办法是将 i改成一个short常用引量
另外一个方法是声明i是个临时量通过去掉引用
类似的警告也会出现
如果range没有返回任何一个引用
引用复制
一个用博尔值的标准矢量迭代器无法返回引用
所以迭代器变量b在这里就是临时量
出乎意料的是b并不指向矢量之内
于是编译器警告这个意外复制
解决办法就是去掉引用明确定义b是临时量
这些新警告包括无限递归标准移动,
和C++ range-based循环是默认启用的
要在你的expo进程中实验它们
就把它们添加到其他警告标志的设置中
新的诊断就讲完了
编译器优化
下面来讲讲编译器优化的进步
我们整体上完善了LLVM编译器
来优化你的代码的运行时性能
我们只选择了几个在今天着重讲解
我们会讲到链接时间优化的改进
重点讲新代码生成优化
然后再讲讲arm64缓存调整
链接时间优化
在过去几年里我们讨论过了链接时间优化
现在我们有重大进步要跟大家分享
链接时间优化也叫LTO
它优化了可执行文件把它们作为单一的完整单元
它在源文件中内联函数删除死代码
执行其他功能强大完整的工程优化
什么是链接时间优化（LTO）？
LTO消除了编译器和链接器间的界限
要了解LTO的工作原理
首先要看看传统的编译模型
假设我们有四个源文件
第一步是编译产生四个目标文件
目标文件链接到框架产生应用
LTO的建立一开始是一样的
都是编译源文件到目标文件
在LTO里的这些目标文件包含了额外的优化信息
这些信息让链接器可以执行链接时间优化
从而产生单一的单片集成目标文件
LTO编译模型
LTO的输出与框架相连
比如Foundation从而形成应用
LTO能让性能最大化
Apple大量运用LTO在我们的软件里
通常可执行档的速度可以提高10%相较于其他普通的发布版本
它的效果会更明显如果跟性能分析引导优化结合使用
LTO运行时性能用LTO使性能最大化
它还可以极大地降低代码长度在优化大小的时候
但是在编译时会产生成本
LTO编译时间的折中
集成优化步骤会需要大量的记忆
不能利用你所有的核
而且会不断重复出现在增量编译中
带有调试信息的大型C++项目编译成本是最高的
在过去的两年里我们一直致力于降低负载
比如研究内存用量
条件是Apple LLVM编译器与LTO和调试信息相链接
这个条越短越好
在Xcode 6占用400亿字节
LTO内存用量完整调试信息
从那时起我们就将内存用量减少了4倍
也将编译时间减少了33%
Line Tables Only调试信息水平占用的内存比LTO还少
链接LLVM自己现在只占7千兆
LTO内存用量Line Tables Only
LTO从来没有这么好过
但现在还是有编译时间折中的问题
特别是对增量编译
但我们有一个很棒的新技术可以减免这些成本
增量LTO能够扩展你的系统
它执行整体分析和内联不需要结合目标文件
增量LTO
它的建立更加快速因为它可以同时优化每个目标文件
另外由于目标文件都是单独的
而且你的缓存建立在链接器上因此增量编译能超速运行
我们来看增量LTO编译如何运行
增量LTO编译模型
编译步骤与单片集成LTO一样
为每个源文件产生一个目标文件
不需要合成目标文件
链接器运行LTO分析在整个工程里
这个分析为每个目标文件传送优化
使各个目标文件的函数内联
也会内联其他强大的全工程优化
LTO优化的目标文件储存在链接器缓存里
之后才会链接到框架以形成应用
根据计算后的运行期性能
增量LTO创立的工程与单片集成LTO差不多
有几个benchmark慢点儿另外几个快点儿
但是编译时间很快
那么来看看我最喜欢的C++工程的创立时间
Apple LLVM编译器本身
在这个表里条越短越好
最上面这一条是不用LTO建立的时间
单片集成LTO建立所用的时间远远超过上面的
用了将近20分钟可不是6分钟
创建大型C++工程的时间
增量LTO要快很多用时少于8分钟
负载只增加了25%
再单独来看一下链接步骤LTO就在这里运行
不用LTO只链接Apple LLVM编译器自身
所用时间小于两秒
在图上看不到条
因为链接器不执行任何编译器优化
单片集成LTO用时将近14分钟因为它可以用到所有的核
增量LTO用时2分14秒
比单片集成LTO快了6倍多
内存用量也很小
不用LTO单连Apple LLVM编译器所占内存
也就200多兆
跟我们之前看到的一样单片集成LTO占了70亿字节
增量LTO占用内存小于800兆
这个比例令人不可思议
所有这些结果都是新版本
以后还会更好
有了增量LTO
增量编译不会再重复无用功
再看一个例子当控制器改变时
怎么开始App的增量编译
增量编译示例
改变控制器会让链接失效
但其他的LTO目标文件还存在链接器缓存里
但若一个控制器函数被内联到主方法
那么主方法需要重新优化在LTO时间
那么我们开始构建只有控制器需要重新编译
重新运行LTO分析之后controller.O和main.O
都被优化了新的LTO目标文件存入链接器缓存
LTO目标文件就如以往一样连在一起产生应用
增量LTO提供的性能正是对增量编译性能的期待
当带有小辅助函数的源文件被更改
使用它们的目标文件会被重新优化
但对于典型的增量编译
大部分LTO目标文件直接从链接器缓存链接
最后再看一下链接到Apple LLVM编译器本身时间
最上面三条显示的时间是从之前的fresh build
大型C++工程的增量链接
如果我们更改了优化遍数的执行
单片集成LTO用时是一样的
跟fresh build一样
但是增量LTO只需要8秒
这比初始化版本快16倍比单片集成LTO快100倍
真是令人惊叹
最新的科技链接时间优化
低内存用量快速增量编译
今天就去试一下增量LTO吧
启用增量LTO
LTO的改进十分出色
但如果你用LTO处理大型C++工程
编译时间要降到最低就只用line tablesonly
调试信息层
这样调试器里可以获得许多追踪信息而且成本最低
LTO和调试信息
以上就是链接时间优化
现在有请Gerolf上台为大家讲讲新的代码生成优化
代码生成
好 接下来就讲讲代码生成优化
我们努力研究Xcode 8Apple LLVM编译器
为了能提高所有应用的性能
在这一环节我要讲其中三个
Stack packing和shrink wrapping
以及选择混合型乘加运算
首先来讲stack packing
这是关于本地变量运行时栈内存
Apple LLVM编译器一直都带有优化
努力压缩栈内存大小
Xcode 8的编译器是优化最好的
原因就是这个来看看这个例子
注意x的定义要在if陈述的作用域之内
然后看一下y的定义在if陈述之后
如果编译器不去优化这个代码片段
那么就是说x和y这两个变量
在运行时内存栈上不同的两个栈单元
但是根据C-style语言规则
一个变量的生存期结束于它所定义的作用域
这也就是编译器所利用的一点
那么来看看这对我们的两个变量有何影响
x被定义于if陈述之内
if陈述的作用域就在y被定义之前结束
当y被定义之后y就有了一个生存期
在这张图上你可以看到
x和y 以及x和y的生存期不会重叠
于是编译器就可以给它们一个相同的栈单元
这就减少了程序用的总栈内存
就可能会提高应用的性能
目前一切都是完美
但是这里有一个小小的警告
编程语言的规则有时很难去检查
所以一旦出错
你的程序可能就会产生意外的结果
技术术语就是未定义行为
我们来看个例子
注意这个指针变量
在if代码块中它的赋值是x的地址
现在看这个print陈述
这个时候x的地址通过这个指针变量而使用
这么这里所看到的
就是x的地址跑出了if陈述的作用域
这样我们的语言规则被视为是未定义行为
脱离本地地址
所幸这个修复很简单
这只是个需要注意的地方
修复的方法很简单只要拓展作用域
给x的生存期通过删除x的定义
在if陈述之外的定义在条件被检查之前
那么现在x的定义所在的作用域
就与print陈述一致了
删除很简单
请一定要尽所有努力
让你的程序符合编程语言规则
这能带来更好的体验给你
给编译器以及我们的用户
以上就是stack packing
下面来说shrink wrapping
Shrink wrapping是关于编译器生成的代码
在函数进入和退出的时候
这是一个资源管理代码
管理运行时堆栈和寄存器
这里观察到的是
这个代码并不需要作用于函数的所有路径
shrink wrapping会把这个资源管理指令
放在真正需要它们的地方
那么来看一个简单的例子
这是一个简单函数有两个参数a和b
将它们进行简单比较
如果a小于b就会调出一个函数foo
它以本地变量的位置作为一个参数
最后返回
了解shrink wrapping来看一下伪汇编代码
类似于编译器真正生成的代码
这里你看到的入口码分配堆栈内存
节省寄存器运行比较和分行
出口代码块会储存寄存器
删除堆栈并返回
如果条件正确函数foo会被调出
所以这里看到我们的程序中有两个路径
一个是直接从入口码到出口代码块
另一个从入口代码块到出口代码块
这里主要的发现就是这个资源管理指令
指令运行时栈内存和指令寄存器
只需要用在调出函数指令时
shrink wrapping所做的是识别这个条件
将这些指令移出入口代码块
移出出口代码块放到真正需要的地方
因此它缩短了生存期
资源管理指令的生存期并在这个region中将它们打包
转移到真正需要的地方
这里的region就只是调令
现在设想一下这个热代码
在你的函数里是从入到出的路径
我们就不再需要执行资源分配指令
如果这是个热点函数你会有很多这样的热点函数
你可以想象这种方法可以节省几百万个
指令让性能更好的提升
也节省应用的用电量
以上即shrink wrapping
接着我们谈谈混合加乘运算
这把我们带回到很简单的数学运算
加法和乘法
arm64处理器
有一个指令就是混合加乘指令
这个指令会计算一个表达式
比如a加b乘以c只用一个指令
选择性加乘运算
你可能会天真地以为无论何时看到这样一个表达式
最好的方法就是只生产这个指令
这也就是编译器现在所做的事情
但这一定出乎你的意料
在某些情况下生产两个指令实际上比一个要快
一个加法指令和一个乘法指令
这会让你的应用的性能变得更快
为什么？
我准备了一个简单的例子来进行演示
这个函数使用四个整数参数
并计算一个简单表达
a乘以b加c乘以d
选择性混合加乘运算
代码会是什么样子？
当编译器生成一个单一混合加乘指令的时候？
它会计算a乘以b
然后加乘运算需要等待这个结果
然后加乘运算会计算这个表达式的值
要用多长时间？
乘法需要四个循环加法也是
所以这个简单序列总共需要八个循环
当我们要生成2个乘法和1个加法
怎么可能更快呢？
那么我们来看看这个序列
首先编译器发出乘法指令a乘以b
然后计算c乘以d
最后把结果相加
秘诀在于现代处理器可以指令级并行
它们可以执行2个甚至更多乘法
两个乘法 代码更快
同时并列计算
因此在这里
两个乘法是并列执行的
所以在四个循环中我们得到的不是一个乘法的结果
而是两个
然后我们只要把结果相加一个循环里完成
现在我们看到要计算这个表达式的值
我们只需要五个循环
现在比较一下这个序列
与一个最少加乘的序列
那么在这个简单序列中运算速度快了两倍
因此使用选择性加乘运算
就可以加速计算应用里的许多简单表达式
以上就是混合加乘运算
接着我们讲arm64缓存优化
这里我要讲两个技术
编译器决定哪些数据会存在缓存里
而缓存中的数据
决定了应用的性能
在我们详细讲解编译器的工作原理之前
我想快速的回顾一下存储层次
在顶部你看到的是主存储控制程序变量
这是上面这一条
在最底下你看到是寄存器
从主存储器下载数据到寄存器十分缓慢
要链接这两个部分需要一个缓存就是临时存储
它比主存储小1万到10万倍
但是从缓存下载数据的速度要快很多
大概快10到100倍
然后数据从主存储中下载
我们下载的不仅仅是单一的寄存值
而是把一整个缓存行从主存储中下载下来
所以缓存行中包括了不止一个注册值
这个设计之所以能如此成功
是因为你的程序数据有两个局部属性
时间局部性和空间局部性
时间局部性指的是程序现在访问的数据
很快会被再次访问
空间局部性指的是程序现在访问的数据
随后还会访问相邻的数据
所以当你访问一个数组区域它还会访问相邻的域
当它访问你数据结构里的一个域
它还会访问相邻的一个域
以此类推
现在你看着这个设计
而且你觉得
从缓存里下载数据很快
那是不是可以将数据预先加载到缓存里
从主储存中加载在处理器处理其他操作的时候
这样所有数据的加载都很快
当我们需要这些数据时当程序需要这些数据时
你可能会感到吃惊
因为你的iPhone处理器已经实现了这个神奇的事情
这就是硬件预取
处理器会观察加载的每一个地址
试图在这些地址里找到模式
一旦这个模式找到
就可以预测你的程序在将来需要什么样的数据
从主存储中再次预取这个数据
在其他并行处理还在运行中的时候
将数据存进缓存最后当程序需要他们
程序可以很快的将它们从缓存中加载
那么今年我们研究了硬件结构
来看看编译器可以做到什么
让这个神奇预取使应用运行得更好
软件预取
我们找到了几个模式
所以编译器现在做的就是分析源代码
预测以后应用可能需要的数据
发出预取指令让应用获取这个数据
在应用运行的时候
预取指令执行
从主存储获取数据放入缓存中
当程序需要这些数据时
就可以很快很简单的从缓存中下载
程序就不需要再等待数据从主存储中下载
这就是软件预取所实现的魔法
到这儿....
我讲的这个优化是编译器自动为你做好的
下一个我要讲的优化
非临时存储是需要你帮助的
要了解怎么回事我们要看一看
数据存进主存储的过程
那么让我们再来看看存储层次结构
假设程序要做一个简单的任务
赋值的话假设100
给主存储变量现在的值是55
第一件事就是
本想把新值存到的旧数据的地址
加载到了缓存
由于我们从主存储加载数据
不只是加载变量的旧数据
还有相邻的数据
因为我们填写了整个缓存行
第二步把值存入寄存器
存到缓存行
存到缓存里
最后
缓存行的数据或者是需要其他数据的缓存行
还有值会在第三步从主存储返回
所以总共是三步
从主存储加载数据到缓存
缓存寄存器的值
最后将数据返回主存储
这么做的原因是数据
通常都有局部性特别是时间局部性
但是如果你的数据没有空间局部性呢？
会不会能更快速更方便的将值直接从
寄存器存入主存储...
更快地储存数据？
...只用一个步骤？
这正是非临时存储的做法
它能避免下载多余的缓存行
还有一个好处就是
这个数据不再需要不会再存入缓存
那么缓存中就存储其他数据能对应用更有用
如何指令编译器
生成非临时存储是通过一个编译器内置组件
非临时存储
那么你用这个内置来指令编译器
生成非临时存储
这需要两个参数
一个是你要存的值一个是你要存的地址
什么时候要用非临时存储？
当没有重复使用没有时间局部性
在你的代码中你可复制一大段数据
最好比缓存还多
让应用更有价值
在性能缺失的地方
所以这必须是个热循环
当全部条件无法满足时
你不会想使用非临时存储
你能获得什么？
在这一张幻灯片
我们演示的是非临时存储带来的好处
从三个含有热循环的benchmark
这个看上去跟我之前展示的例子差不多
所以这个数据告诉你对于普遍的循环体
速度可以加快30%到40%
这就是非临时存储
可以为应用热循环所做的事情
这是个漫长的进程
我们看过了很多新特性和很棒的新优化
都是新的编译器提供给应用
我们也讲了
Apple LLVM编译器是基于开放资源工程
你可以与我们互动到我们的开放资源社区来
甚至提供一些补丁给你喜爱的编译器
我们看到了这么多新的特性
比如objective类属性和C++线程本地存储支持
现在...
新的Libc ++完全支持C++14
而且有了许多新的改进特性
但是要记住Libstandardc++是弃用的
现在有更多的警告和诊断
让你的代码比以前更清楚
你也听到了这个神奇的新特性
增量LTO为你提供一样的性能
与单片集成LTO相比而且编译时间令人惊叹
之后我们讲了一些代码生成优化
可以自动加速所有应用的运行
最后我们讲的是长期的专业存储
就是编译器提供方法
而你用你的智慧然后去使用他们
所以我希望这些能说服你
我们做的新编译器是一个真的很棒的版本
我们高兴极了
请一定试一试
看看它能为你的应用做什么
你可以在我们网站上找到更多信息
这里还有更多精彩的演讲...
相关演讲
...应该会让你感兴趣
关注一下
谢谢观看
谢谢你们来到现场
祝你们在大会中过得愉快