早上好
AVFoundation回放的新进展
等待 循环 转换 扩展 优化
欢迎来到我们关于AVFoundation回放新进展的会话
我是Sam Bushell
今天我们要讲一些新添加的增强功能
这可以使得开发者在处理
难题时变得更加得心应手
所以AVFoundation提供样式广泛的API
用于多媒体活动
包括回放 拍摄 导出以及多种类型的编辑
我的重点主要在回放上
AVFoundation回放支持样式非常广泛的
存储于本地的媒体格式
在大多数情况下你可以将相同的文件
放到一个网络服务器上
然后AVFoundation可以通过网络播放那个文件
该情况下文件格式是相同的不过IO是通过网络的
我们称之为渐进式下载回放
一旦我们开始下载该文件
即使网络特性发生变化
我们继续下载的还是相同文件
HTTP直播流更为动态
一般来说 基URL引用的是主播放列表
这会带来相同内容的多个播放列表
但在比特率 格式或是语言上会有差异
而且每一个播放列表都引用
含有实际压缩媒体文件的分段
我们来谈谈今天的话题
我们要讨论
和预回放缓冲时间有关的回放变更
我们将推出一个新的API
来简化单个文件的循环播放
我们会讨论一些在底层作出的回放改进
我们会讨论让你的应用程序为广色域视频做好准备
然后我们会用余下的时间讨论一个热门的话题
回放应用中的静态时间优化
我们先从等待网络开始
缓冲中请稍等...
因为当我们在网上进行媒体回放时
我们任凭网络的摆布
我们不想太早开始否则回放会卡顿
我们不想太晚开始否则用户会放弃观看
我们想在那个完美时刻的开始播放
且在我们有足够数据时开始回放 这样我们就能够
持续播放 没有卡顿
这是现有的API
AVPlayerItem提供三个Boolean属性
playbackLikelyToKeepUpplaybackBufferFull
以及playbackBufferEmpty
playbackBuffer——抱歉——playbackLikelyToKeepUp为true的
条件是AVFoundation算法认为如果你现在停止播放
你就可以持续播放 没有卡顿
直到播放结束
playbackBufferFull为true的条件是缓冲
已经达到最大量了
如果你还没有开始回放
那就开始回放吧
playbackBufferEmpty意味着你卡住了
或者即将卡住
对于iOS 9和更早版本中的渐进式下载回放
AVFoundation客户端必须自己监控这些属性
等待直到playbackLikelyToKeepUp为true
或playbackBufferFull为true
之后再将AVPlayer的速率属性设置为1
对于HTTP直播流规则更加简单
你可立刻将AVPlayer速率属性设置为1
当用户选择播放的时候
这就会自动等待
缓冲足够的媒体文件之后再开始回放
我们精简了默认的API契约
在2016年的iOS版本中
iOS  Mac OS  tvOS
对使用iOS 10 Mac OSSierra tvOS 10及之后版本应用
HLS的规则也同样适用于
渐进式下载回放
当用户点击播放时
你可以立刻将AVPlayer的速率属性设置为1
或调用播放方法都是一样的
AVFoundation自动等待
足够多的缓冲从而避免卡住
如果回放期间网络中断然后播放卡住
速率属性仍将设置为1
所以它会再次缓冲并自动恢复
当有足够缓冲的时候
如果你使用AVKit或者MediaPlayer框架
来呈现你的回放UI
它已经支持了自动缓冲等待
并且会继续支持
若你的应用直接使用AVFoundation
然后你构建自己的回放UI
你可能需要做一些调整
所以这个新API应该叫什么？
Autoplay这个词已经用在了QTKit中
和HTML 5中但我们得出的结论是
从这个AVPlayer API的角度看
自动的部分并不是回放
而是等待
所以这个API的正式名称是
automaticallyWaitsToMinimizeStalling
但若你喜欢称它为Autoplay也行
这个网络回放现在看起来
像是有三个状态的状态机
暂停 等待 播放
我们从暂停状态开始直到用户选择播放
然后应用调用播放我们就移至等待状态
当playbackLikelyToKeepUp属性为true时
播放器会前进到播放状态
如果缓冲是空的
播放器会切换回等待状态
直到再次可能跟上播放
如果用户暂停我们会回到暂停状态
这里还有一个可以实现的过渡
回想在此次更改之前的iOS 9或者之前版本
你可以在回放可能跟上之前调用播放
回放会立刻开始
即使可能会卡住
所以我们通过提供另一种方法保留了该语义
playImmediately(atRate:)
这可以让你直接跳转到播放状态
从暂停状态或等待状态过来
要注意的是这可能会导致卡顿
而耐心的等待状态会避免这种情况
所以要注意
AVPlayer的速率属性可能不是
你所理解的意义
我们重述一遍这样大家都清楚
AVPlayer的速率属性
是应用请求的回放速率
不要和AVPlayeritem的
时基速率相混淆
那是回放实际发生的速率
我们添加了两个新的属性在
此版本中
来给大家展示更多细节
一个是timeControlStatus
这可以表达出你在哪一个状态中
暂停 等待或是播放
如果你在等待状态中
等待播放的原因属性会告诉你原因
例如 你可能在等待状态中
那AVPlayer的速率属性可能是1
因为你在等待所以timebase.rate会是0
timeControlStatus会再次表达
我在等待以特定速率进行播放
然后等待播放的原因可能是为减少卡顿而等待
所以凭借这些背景知识
我想介绍我的朋友Moritz Wittenhagen
他比我更加大胆
因为他要尝试
在台上进行现场网络回放演示
所以各位祝他好运给他一些掌声
各位早上好
我想先开始展示一下
我们在台上有的设备
这是我的iPad
你能看到这在屏幕上同步显示着
那个iPad正在加入一个
由Mac搭建的网络
这可以让我使用网络连接调节器
来限制网络连接
用于这个iPad的
这可以使用网络连接调节器的
偏好面板做到
Sam一会儿会告诉你去哪里去找
我设置了Slow Server配置文件
这会将其限制成一般的网络连接
这稍微慢于
我们想要播放的媒体比特率
目前这是关闭的
我们先不开启它然后来看看iPad在
优质网络条件下的性能
所以我这里有的只是一个选集
我可以选择一个视频
我开始选择
你看到的是视频马上就加载上了
我们看到目前没在播放
你看看这下面极好的工程UI
告诉我们所有的属性
以及功能这都和自动等待有关
这真的是从AVPlayer和AVPlayeritem中获取的
所以有这些属性可供你使用如果你需要知道
自动等待在做什么的话
因为现在我们暂停了所以这些速率都是0
当前时间是0
但有意思的是因为我们在快速的网络中
我们加载了39秒的视频
这实际上就是整个视频
然后我们目前可能跟上回放
这意味着当我现在点击播放
视频就会开始播放没有任何问题
现在我们想看看在差的网络条件下会怎么样
所以我们启用Mac上的网络连接调节器
好了
对这个视频没什么差别
因为如我所说整个视频已经缓冲完毕了
所以当我回去再次加载它
我想让大家重新注意loadedTimeRanges
和isPlaybackLikelyToKeepUp
所以开始吧
重新加载视频
现在我们看到的是
loadedTimeRange只是缓慢地增加
isPlaybackLikelyToKeepUp 为false
但终究会变成true
在那一时刻我们处在了和之前相同的状态
现在准备播放然后回放就会开始
现在我们再试一次
这一次我会在视频加载好之后马上点击播放
所以这一次我们没有足够的数据
然后就进入了这个等待状态
你看到这个转动图标告诉用户在等待回放
最终这会成为准备播放然后回放就会开始
还有一件事我们可以做那就是立刻回放
我们也试一下
我进入这个视频马上点击立刻播放
我们看到回放开始了不过之后很快就卡住了
因为我们没有足够的缓冲来将视频播完
这种情况下我们会进入等待状态
直到重新缓冲出足够的数据播到最后
以上就是自动等待的简短演示
回到Sam和幻灯片上
谢谢 Moritz
我们回顾一下中间发生了什么
当我们设置了更缓慢的网络速度
接近那部电影的数据速率
电影一开始是暂停的
当他点击播放
这就进入等待状态
因为目前回放不可能跟上
注意到这个时候播放器的速率是1
但时基速率是0
几秒钟之后AVFoundation断定
回放有可能跟上
所以它将时间控制--
它将状态设置成播放然后现在你看到
播放器速率和时基速率都是1
你可能会想到
有更多一点的细节存在于
timeControlStatus而非播放器速率属性中
记住播放器速率告诉你的是应用
所求的回放速率
timeControlStatus
还考虑到实际发生的事情
所以这些东西你可能要考虑周全
当你构建回放UI时
假如你想在家中尝试
你可能要知道如何找到网络连接调节器
这不是我们发明的东西至少不是我们团队
这是硬件IO工具下载的一部分
最简单的获取方法是顺着Xcode菜单
找到更多开发者工具
登陆后你就会在这里找到
好了 所以
如果你使用2016 SDK或之后的版本
你的应用就会表现出这样的属性设置
自动将WaitsToMinimizeStalling设置为true
你可以将那个属性设成false
如果你想回到之前的行为
你这么做可能会有这几个原因
具体说 如果你想使用setRate(time atHostTime)的调用
来用外部时间轴同步回放
那你必须选择性退出做法是自动将
WaitsToMinimizeStalling属性设置为false
否则 你会遇到友好异常
很有帮助的提醒
最后 提醒一下绝对不要使用播放器速率
来推断将来的当前超时
如果你想那么做那使用项目的时基速率
来代替它
或使用时基对象中的其他API
那是它们的专长
好了 这就是缓冲的内容
我们前进到循环的话题
我问大家一个问题
什么是循环单一项目的最佳方法
一个想法是设置监听器来
监听发出的通知
当回放抵达结尾的时候
当被调用的时候
找回到开头 然后重新开始
这个想法挺不错的
但不幸的是这会导致空白
在两次回放之间原因有两个
第一个原因是这会有延迟
这是由于通知发出
并送达到程序的时间以及第二次播放器请求
返回到回放系统的时间
第二个更为显著的原因是预滚
所需的时间
你是不可能
立刻进行媒体回放的
如果没有一些准备
有必要先加载媒体数据并解码一些数据
之后你才能开始播放出来
这个先补充回放管道
再开始回放的过程叫做预滚
所以我们想在这里做的是
将AVFoundation参与到该计划中
如果AVFoundation对回放项目B
足够提前获悉那这就可以开始预滚
然后解码在项目A播完前进行
所以这就能优化A到B的过渡了
如果项目B十分短那AVFoundation甚至可以开始
进行到项目C的过渡
实现该目的AVFoundation工具就是AVQueuePlayer
AVQueuePlayer是AVPlayer的子类 拥有一排的
AVPlayer项目 叫做播放队列
当前项目排在列阵的第一位
用AVQueuePlayer
优化不同项目间的过渡
但在循环的情况下你可以创建多个AVPlayer项目
从同样的AVAsset上面
这是另一种优化
AVFoundation无需加载
并多次暂停媒体文件
提醒一下 播放列队不是播放列表
请别加载接下来的10,000个项目
你认为你可能会在播放列队中播放
这并不高效
播放列队的目的是提供关于
将要播放项目的信息
这样AVFoundation可以优化过渡
这种设计模式是当你想无限循环
单个媒体文件的话
要制作少量的AVPlayer项目
然后将它们放在AVQueuePlayer列队中
并将行动项和属性设置成提前
当回放达到一个项目的结尾时
随着回放前进到下一个它会从播放列队中移除
当你得到完成过渡的通知时
你可将那个播放完的项目
将其当前时间设置回开头
然后将其放在播放列队的最后重新播放
我们将这种模式叫做跑步机
而且你可以自己实施这个跑步机模式
使用AVQueuePlayer
我们有示例代码来帮助大家
稍微难的一点是你必须设置键值观察
来查看项目何时被移除的
然后将其找回到开头
然后又出现在播放列队最后
如你所见 在这个代码中
我们停用了KVO观察者
当我们改变播放列队时
来避免任何递归的可能
所以很明显这是可能的
只是有一点复制
而且我们收到的反馈是
如果我们能将其变得更简单那就再好不过了
我们推出AVPlayerLooper
这会替你实现跑步机模式
你给它一个AVQueuePlayer
你给它一个AVQueuePlayer和一个模板AVPlayerItem
然后它构建少量AVPlayerItem的副本
这之后会在播放列队中循环
直到你告诉它停止
将AVPlayerLooper采用于
符号案例中的代码就变得更加容易了
所以我想给大家演示一下
在这里的iPad上面
所以这是一段示例代码
启动Video Looper
我在这里添加了我自己的一个媒体文件
然后我们将用AVPlayerLooper来播放
感觉是不是很柔和？
好了 这很明显在循环
代码如我指出的那样
非常简单
这种工具适合用于 例如
如果你有一个tvOS应用
而且你想在标题菜单后面放上循环的背景视频
好了 我们回到幻灯片
演示AVPLAYERLOOPER
我们讲了讲如何循环
我想花点时间讲讲循环什么
理想来说 如果你有音频轨和视频轨
它们的长度应该精确相同
为什么？如果音频轨更长 那这意味着
在接近结尾的时候 那一段
音频应该播放的时间 视频却没在播放
我们有一段空白的视频
所以视频应该怎么办？
应该关闭吗？
应该停在一帧上吗？
相反如果视频轨更长
那就会有一段没有音频的时间
所以当你创建用于循环的媒体资源时
要花时间确认轨道时长互相匹配
在QuickTime电影文件中
轨道时长是由编辑列表所定义的
如果用于循环的媒体资源并非完全处在你的控制之下
另一种可能是
你可以将AVPlayerItem的正向回放结束时间设置成
最短轨道的长度
从而调短另一个轨道来实现匹配
好了 接下来看看我们在
回放管道中做的优化
这可能会影响到你的应用程序
假设我们当前正在播放中
然后播放中的轨道列表发生改变
例如 我们能更改字幕语言
或者音频语言
将音频从英语换成法语
我会将字幕语言从英语换成西班牙语
或者我们可以移除正在显示视频的AVPlayerLayer
或添加AVPlayerLayer开始显示视频
在iOS 9中的所有这些情况里
AVFoundation会暂停回放
调整回放管道来匹配启用的轨道列表
然后恢复回放
在一些情况中 这甚至会导致视频
回跳到一个关键帧上
我要说我们收到了有建设性的反馈
都来自用户和开发者
所以我很高兴地宣布
在iOS 10和其他2016年的姊妹系统中
这些改变不会再导致回放暂停
在播放中的AVPlayer上添加或移除唯一AVPlayerLayer
改变字幕语言
或改变播放中AVPlayer的音频语言
或者手动停用或启用轨道
我们认为这对用户和开发者来说是一种提升
然而 这显著地改变了API的行为
所以我请各位在seed版本中查看一下
看看这是否会在应用中导致任何复杂问题
如果你发现了一个问题像是我们这边出的错误
那就请给我们反馈
使用Apple错误报告系统上报错误
像往常一样 当上报错误时
请给我们所需要的一切信息
来让我们自己再现出那个问题
我们的行业正在过渡到更广的色域上
用于数码摄影和数码视频
很多iOS开发者从来不需要应对
不使用Rec.709色彩空间标准的视频
因为那是高清视频的标准
且那也是我们自iPhone 4开始使用的拍摄标准
但是更广色域的色彩空间即将来临
你可能已看到了在最新的iPad Pro上
当运行iOS 10时
你可以拍摄并显示照片
在P3色彩空间中
一些第三方产品也在P3中拍摄视频
所以我想给大家指点一下你可以应用的API
用于你的应用中来做好准备
让你的应用支持广色域视频
当我首先要给你一些背景知识
在媒体文件中色彩空间信息是
视频轨的元数据的一部分
在QuickTime电影文件中它保存于样本描述中
在一些Codec中它还保存于Codec特定的位置
这个信息有三个主体
基色 用于明确100%红色
100%绿色和100%蓝色是什么
还有白点
传递特性
你可能听过叫做伽玛曲线
或是传递函数
这些从像素值到光级来定义映射
然后回答那是直线还是曲线的问题
这会在黑暗的区域给你更多细节
那里我们的眼睛更敏感
然后是YCbCr矩阵 是指坐标变换
从它们的RGB空间进入到用于
高效压缩的空间
所以在这里我有一些例子
若你没有听说过Rec.709相当于
视频上面的SIGB
其实SIGB是基于Rec.709的
广色域可以通过
使用不同组的基色来实现
P3基色所指定的100%红色
100%绿色和100%蓝色的值
要比Rec.709更加鲜艳
我还有一点要说
在我们的API中 我们一般是通过
使用枚举字符串来表现这些选择
因为它们更易于打印 显示以及调试
但在媒体文件中它们是通过数字表达的
这些标准标签数字是在MPEG规格中定义出的
叫做编码独立代码点
这听起来是否有点矛盾？
怎么会是编码独立代码点呢？
它会不是那么的矛盾
如果你读成Codec编码独立代码点
这个规则的目的是确保这些标签数字的
任务是以一种协调的方式
在所有Codec和文件格式中完成
所以对数字的解释会是相同的
在QuickTime MovieMPEG-4和H264中等
好 有了这些背景知识我们看看一些新的API
我们推出了一个新的媒体特性这会告诉你
视频轨标签有更广的基色
比Rec.709基色还要广
若你的应用发现这里有广色域视频
适合做的是让你的应用采取措施
将其保留下来 所以这不会压回到709的色彩空间
如果没有 最好的做法是
停留在Rec.709中处理
所以你可指定工作色彩空间
当你设置AVPlayerItemVideoOutput或AVAssetReaderOutput时
然后你收到的缓冲就被转化到了
那个色彩空间中
你还可以指定目标色彩空间
当你设置AVAssetWriterInput时
这种情况下 你提供的源图像缓冲
就会被转化到那个色彩空间中
在压缩之前
使用AVPlayerItemVideoOutput或AVAssetReaderOutput
如果你不想让图像缓冲被转化到
普通色彩空间中
那你应该设置AVVideoAllowWideColorKey为true
然后你会收到在原始色彩空间中的缓冲
这是有效保证了无论什么样的软件收到
并处理缓冲 无论是我们的还是你的
就会检查并履行那些色彩空间标签
这里有类似特性用于配置视频合成
首先 你可以指定一个工作色彩空间
用于整个视频合成
或者 如果你有自定义的视频合成器
你可以选择让其支持广色域
你可以声明你的自定义视频合成器支持广色域
并且会检查并履行色彩空间的标签
在每个源帧缓冲上
通过应用可选的supportsWideColorSourceFrames
属性和返回真值
我给大家提醒一下
比如 如果你手动创建图片缓冲
在Metal 使用像素缓冲池
然后你应该明确地设置色彩空间标签
在每个缓冲上面通过调用核心视频API
大多数开发者不需要这样做
在大多数情况下当你使用支持色彩空间的API时
用于源缓冲 这会替你将它们标记上
应众人要求 我将用剩下的时间讨论
优化回放启动时间的最佳做法
我会首先谈谈本地文件回放
之后我们去讲HTTP直播流
现在的一些优化方法可能
第一眼看上去违背常理
它们需要你从
AVFoundation角度考虑
然后考虑它何时会得到其需要的信息
来做你的应用所要求的事情
例如 这里有一段很直接的代码
用于设置本地文件回放
我们从文件的URL开始
我们创建一AVURLAsset
代表存储那个文件的产品
之后创建AVPlayerItem保持回放的可变状态
用一个AVPlayeritem保持回放
然后我们创建一个AVPlayerLayer
来将视频回放连接到我们的显示层次中
这个代码没问题 但有一点小瑕疵
你最初可能没看出来
一旦播放项目设置成播放器的当前项目
播放器就会开始设置回放管道
它不知道将来的事
它不知道你过会将设置
AVPlayerLayout
所以它设置了仅有音频的回放
当AVPlayerLayer添加时现在AVFoundation知道
这个视频也需要解码
现在它可以重新配置
音频和视频的回放
如我之前所说
我们在今年的iOS版本中做了增强
意味着微小的
回放列表变更 启用轨道列表的变更
不一定会导致中断
但理想的做法是在一开始就让
AVFoundation获取所需信息使第一次就一切正常
所以我将稍微改变这个代码
看好了AVPlayerItem到哪里连接
AVPlayer
所以现在播放器创建好了 没有当前项目
这意味着现在没有理由构建回放管道
在你添加AVPlayerLayer时不会变
不会构建回放管道
直到播放项目成为了当前项目
而到那时候 播放器会知道其需要什么
来让第一次就不出问题
我们可以概括一下
先创建AVPlayerLayer
抱歉 首先创建AVPlayer和AVPlayerItem对象
然后设置你在上面需要的属性
包括将AVPlayer连接到AVPlayerLayer上
或将AVPlayerItem连接到AVPlayerItemVideoOutput上
这可能似乎有点疯狂
但如果你只想要马上开始回放
你可以先告诉播放器进行播放之后你再将播放项目提供给它
为什么要这样做？
如果你反过来做 播放器一开始会认为
你想要显示视频开头的静止帧
它可能在这上面浪费时间
之后再得到你是真的只想要回放的消息
从实际目标开始可能节省几毫秒
我们来谈谈HLS
我们尝试用HLS来优化的时间段会更加的长
因为它们受网络IO的控制这比本地文件存储要慢得多
所以优化的潜在好处会更加显而易见
网络IO能分解成四个部分
检索主播放列表 那是你交给AVURLAsset的URL
若内容受到 FairPlayStreaming的保护
检索内容密钥检索选中的变体播放列表
用于视频和音频的合适比特率和格式
然后检索一些媒体分段
在播放列表中引用过的
现媒体分段的实际数据传输量是最多的
但在网络IO中我们要考虑往返延迟
其中一些阶段是序列化的
你无法从播放列表下载内容
直到你得到了播放列表
所以要思索的是
我们能不能在用户选择播放之前做这些事？
例如 可能在你的应用中
当内容先被选择时 显示标题卡片
然后这会让用户表明这个是不是我想播放的内容？
或我是否想阅读一些关于它的信息
所以问题是我们能不能猜测性地
做少量的网络IO
当用户识别出他们可能想要播放的内容
在确认之前？
AVURLAsset是一种懒API
它不会开始加载或暂停任何数据
直到有人向它要求
为了触发从主播放列表进行数据加载
我们需要请求它加载一个会从其中衍生出的值
像是时长或是可用的媒体特性
外加媒体选择选项
时长易于输入
你不需要提供完成处理程序 除非
你真的要用那个值来做某些事情
谈到播放列表 它们易于压缩
我们多年支持使用gzip来压缩它们
所以一定要这样做
这可能只是配置你服务器的事
如果你的内容受到FairPlay Streaming的保护
那这里还涉及一个
与你的服务器协商内容密钥的往返过程
且你可以将其更早地触发
通过设置asset.resourceLoader的
preloadsEligibleContentKeys属性为true
为了起作用 主播放列表必须包含
会话密钥声明
所以现在情况如何？
有了这些方法 我们可以开始——
它们能将主播放列表和内容密钥下载下来
即使我们还在标题卡上
这非常炫酷
变体播放列表和数据分段
还是会在我们点击播放后加载
所以你可能问自己
我们能让这种方法更进一步吗？
在2016年的新API中有一个叫做
preferredForwardBufferDuration
设置成低的时长 比如5秒
会让AVFoundation缓冲出其认为你需要的最少内容量
来开始播放
不过一旦回放开始将覆盖设置回0
来让正常缓冲算法重新发挥作用
这是一个视频方差的列表
可能会出现在主播放列表中
在尺寸和比特率上各有不同
对于配有快速连接和大电视的Apple TV来说
1080p的变体可能会是理想
对于iPhone SE
即使拥有超快的Wi-Fi连接
720p变体会是最佳选择
这已经比iPhone SE的屏幕分辨率更大了
所以选择更高的不会提升任何品质
在巨大的iPad Pro上面有很多的像素
所以我们可以选择大的变体来全屏显示
但如果我们在画中画中播放
我们不再需要那么高的分辨率
而且更低的比特率变体可以降低缓存的大小
然后帮助我们留出更多储存空间用于其他应用
如果网络连接在所有设备上都很慢
那这就会成为限制因素
这意味着这AVFoundation
需要考虑到显示尺寸
以及网络比特率 当选择变体的时候
AVFoundation使用屏幕上AVPlayerLayer的大小
来评估尺寸
所以将AVPlayerLayer设置成正确的大小
然后尽早连接到AVPlayer上
这可以隐藏在其他UI后面
如果你还没准备好显示视频
在Retina屏幕的iOS设备上目前有必要将
contentsScale设置成手动
对于比特率AVFoundation在
回放第一个开头时会陷于
难分先后的情况中
它必须选择一些变体
但不知道会得到什么样的比特率
一旦开始下载分段
它可以使用来自那些下载的统计数据
来调整变体的选择
但对于第一个变体
它没有收到任何统计数据
所以AVFoundation的基础算法就是
在主播放列表中选取第一个可适用的变体
如果那是低比特率的选项
用户开始会看到模糊的内容
但AVFoundation会马上判断出实际的网络比特率是什么
然后切换成合适的变体
但问题是如果你想尝试
提升那个最初选择呢？
记住 你要做出权衡
在最初品质和启动时间两者之间
更高比特率的第一分段需更长时间下载
这就意味着开始的时间会更长
你可能会决定最好是从更低比特率的变体开始
为了更快开始播放
做出权衡的一种方法是弄清楚
你想看到的最低可接受的品质等级
在特定大小的屏幕上 然后从那里开始
之后AVFoundation切换到更高品质上
在回放开始之后 只要网络条件允许
可能你知道AVFoundation不知道的一件事
可能你的应用刚播放了不同部分的内容
然后也许你可以使用那个回放访问日志
来更好地猜测下一个
回放站会得到的比特率
所以我们假设你得出了一个结论
基于启动品质和最近比特率统计数据
然后你要决定选择
你想以哪一个变体开始
如何将那个选择导入AVFoundation中？
这里使用了两种方法
这是第一种方法
在服务器上给变体排序
从最高到最低
就像这样
然后在你的应用里
你需要设置playerItem.preferredPeakBitRate
为你猜测的比特率
这样会使更高的比特率变体
从初始选择中淘汰掉
回放开始之后不久
你应该将那个控制重置为0
这能让AVFoundation提升到更高的比特率变体上
只要网络有提升
第二个方法
是在你的应用里动态改写主播放列表
然后把你的优先选择移动到列表顶部
为了做到这一点在AVURLAsset中使用自定义URL方案
然后应用AVasset资源加载器委托协议
这样你可以提供改写的播放列表
来回应自定义URL方案的加载请求
我还想要提醒一下你要分析你的代码
在你调用AVFoundation前看看是否出现任何延迟
特别的是 你不需等待LikelyToKeepUp
在设置播放器速率之前成为true
你现在不需要实际上 对于HLS从来不需要
确保你将AVPlayer和AVPlayerItem
从之前的回放会话中释放出来
这样它们不会在后台浪费宽带
你可以使用Instruments中的Allocations Instrument
来查看AVPlayer和AVPlayerItem对象的寿命
如果你有应用在做其他网络活动
考虑一下在网络回放时是否该将其暂停
这样用户可充分利用可用宽带进行回放
好了 总之
自动等待会将卡顿减到最少
自动播放 自动等待
这默认设置为true
如果你的应用使用今年或之后的SDK
它提供了统一的缓冲规则
用于渐进式下载和HLS回放
我们推出一个新的API叫做AVPlayerLooper
使用跑步机模式简化单一项目循环回放
在回放期间更改启用的轨道组
不会总是引起短暂停顿
我们看了看AVFoundation API
你可以用它来让你的应用为广色域视频做好准备
最后 我们谈论了优化回放启动
用于本地文件和HLS
总之 避免不必要的工作
对于你需要做的工作 试着早些去做
在这个URL上我们有与这个会议相关的更多信息
包括我们展示的示例代码
我们有一些相关会话你可能会想补看
可以现场看或者在网上观看
最下面的那个是在应用里只能点播观看的
谢谢关注 倍感荣幸
希望大家度过愉快的一周