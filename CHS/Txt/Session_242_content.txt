Core Data的新特性
大家好
我是MelissaCore Data工程师
不夸张地说这是第一年上台前没有人跟我说
祝你好运
因为我实际一个月前腿折了这是我第一天脱离石膏绷带
所以如果我一瘸一拐你们知道是怎么回事
在Core Data团队工作最好的是
实际上每年能站在这个舞台上
告诉大家我们都做了哪些新鲜有趣的事情
不可思议 我们今年做了很多 而且都非常有用
我们希望大家喜欢这些新内容
好 我要介绍一项新功能查询生成
Core Data并发领域的一些变化
我要介绍我们在Core Data堆栈配置领域
的一些新进展
及我们新添加的一些API
我们也会简单介绍下为了更灵巧利落地
与Swift集成我们都做了哪些事情
还有我们在Xcode集成方面的一些改进
内容不少 现在第一项 查询生成
查询生成是我们添加的一项新功能
不过在开始介绍查询生成前
我需要简单介绍下fault
可能有人知道Core Data常使用fault
管理对象可能是fault它们之间的关系可能是fault
如果你在使用批量提取
那你执行抓取请求获得的阵列
从NSManagedObjectContext
也会是一种非常特殊的fault
话虽这么说 什么是fault？
现在 在屏幕上有一张对象图
其中有国家 美国
州 加利福尼亚 若干的郡圣克拉拉和旧金山
以及圣克拉拉的若干城市 圣何塞和库比蒂诺
这很像是旅游指南指南书籍的一部分
你可以翻开 浏览从而在你计划游玩的
城市中找到你感兴趣的地方
不过 仅基于我们对美国的了解
这不是完整的对象图
实际上只是对象图的一部分是子图
因为我们知道美国有其他州
这些州有其他郡
这些郡有其他城市
你也知道 除此之外
我们知道美国只是众多国家之一
即使是在指南书籍中我一次想看的
也仅是一个数据集
如果我计划到圣何塞旅行
我不会关心俄勒冈或华盛顿或其它类似的地方
我甚至不会关心旧金山
我需要能够锁定这些对象到达这些目的地
如果我感兴趣
我可以随后改主意改变想要浏览的内容
但就目前短期而言当我在计划
到圣克拉拉的旅行时我不在意其它地方
这种不在意在内存中表示为
fault它是一种对象
了解在随后的某个时间点如何开始检索数据
如果我确定我想使用它
比如 我发现我朋友要结婚了
婚礼在西雅图 我想去
计划到西雅图的旅行
此时 我会再次浏览美国
下一层我想浏览华盛顿州
Core Data会自动检索
关于华盛顿的信息即使当我首次加载子图时
华盛顿信息不在内存中
你知道 我可以接着向下浏览等等...
这就是fault它是未来 或承诺
或延迟加载
这些不同的名称指的都是同样的东西
Core Data可进行这操作帮你尽量减少
在任意给定时间点内存中的数据量
我们为什么使用fault？
答案是 性能 性能 性能还是性能
性能最好的应用
是那些不做任何额外功的应用
你不会在iobus上加载任何不需要的对象
你不会在不需要的对象上花费任何时间
你也不想在用户不注意的时候
这些对象闲置在那里
推高你的内存占用
不过fault有一个小问题
基本上是这样的
这里我们再看对象图
在这个案例中我们有很多fault
我顺着树形结构向下浏览来到圣克拉拉
我想启动库比蒂诺fault
但同时
一个外部过程已经开始从网站导入数据
而且不知为何库比蒂诺被删除了
发生了什么？
我有一个fault它应开始
检索关于库比蒂诺的信息
但那里却没有任何信息了
我说过 我多次介绍不要加载不需要的数据
但在这个案例中你会问自己
我是不是实际上需要那个数据呢？
哎哟
现在Core Data中
通过NSManagedObjectContext上的shouldDeleteInaccessibleFaults
属性 你可以应对这种情况
如果你设置了这个属性然后当上下文注意到
你正在试图启动已删除对象的fault
上下文会将fault标记为已删除
并将fault的所有属性标记为零
大多情况下 这就是你需要的但有时候这也会不便利
因为你的UI不知道如何处理为零的标识符
另一种方法是预提取所有内容
使用关系小键盘进行预提取从而加载你认为你用户
可能需要的所有对象
这样 你的任务就升级了
你需要更努力了解确切地
预测用户未来可能的需要
这会很棘手 我们都知道用户是不可预测的
另一种方法存在第三种方法
始终都存在第三种方法就是写很多代码
首先在管理对象上下文中
使用带ID的既有对象确保在尝试fault前
对象位于数据库中
编写很多try catch
围绕着所有fault启动的异常处理程序
实话说 这个代码写起来可不怎么有意思
你实际上会更愿意写一些用户会使用的
有趣功能因为那才是用户
使用你应用的原因即你的应用提供灵巧功能
不过让我们后退一步
稍稍想一下你的用户与你应用的交互
用户视图和UI通常不关心
是否看到绝对的最近最新和最快的数据
我们怎么知道这一点？
让我们先想想气泵
大多数人对气泵很熟悉你有时会给汽车加油
气泵的显示屏会告诉你
你实际已经给汽车加了多少加仑或升的油
显示数字有千分位
我想问下大家在给车加油时
谁能实时读到千分位请举手
正如我所料没有人能做到
人类大脑喜欢数字
以一定间隔整齐排列这样容易理解
所以用户实际不需要最近最新的数据 他们只需要数据...
合理快速地更新
保存数据的用户对此也不在乎
正因如此Core Data才有合并策略
这些策略规定进行一连串编辑并将这些编辑保存
并与数据库中的内容混合
以及产生预期的效果
你可以选择你需要的合并策略因为你比我们更了解你的用户
那么 如果我们能够汲取这个洞见并进一步延伸会怎样？
如果我们有方法使你通过UI看到数据库中
数据的稳定视图会怎样？
如果我们有方法应对变化
更确定地更新变化会怎样？
如果我们能做到所有这些你不会再看到这个 会怎样？
现在 我可以介绍查询生成了
查询生成是一种方法
能使你的管理对象上下文
基本上 执行读取数据库中数据的操作
所有向管理对象上下文的读取操作
都将看到同样的数据视图直到你选择向前进
你永远不会再看到无法完成fault的消息
而且重要的是我们能高效完成这一操作
这永远都是棘手的部分
这些是怎么实现的？
这里有一个数据库 里面有一个对象id是1名字是fred
因为这些是幻灯片
我将进行删减
因为我需要完成此构建需要的所有资产
在传统数据库中这就是你得到的
你有一个文件 该文件有对所有数据的单一视图
但是使用查询生成
那就变成了你数据库中的第一代数据
随着过程的进行这可能会成为你的应用
它可以是导入程序可以是watch上的扩展
某物对数据库进行修改
新一代创建了
而且更多的数据被创建新的对象
此时 用户启动你的应用
创建管理对象上下文你加载数据
该上下文现在知道
它是从数据库中的哪一代加载数据
所以随着其他过程或上下文等的继续进行
并进一步修改数据库
更多代的数据被创建该上下文仍然知道它所属的代
第二个上下文出现加载一些数据 进行一些编辑
进行保存 保存之后便创建了新一代
并追踪它现在代表的一代
在本例中是数据库中的第6代
此时 如果我们在上下文1中启动fault
即使fault对应的对象
可能在第6代中已经被删除
上下文中仍可看到该对象因为它仍然在数据库中
就在标签第3代下
此时 用户可以在上下文1中略微编辑
删除一些对象 更改一些对象插入新的对象
当保存上下文时Core Data将使用合并策略
将所有这些变更与数据库中的内容合并
并创建新的第7代
以与上下文1相同的
上下文1在固定到第3代时
能够看到第3代同样地
上下文2能够对其对象作出任意操作
将对象变成fault重新启动这些fault
且上下文2将仍能看到
数据库第6代中的数据
所以 基本上它是管理对象上下文级别的
完全读取事务
我们长篇介绍了为什么上下文
本质上是对的事务
现在我们也将它们变成读取事务
使你能够在上下文的级别上立即隔离你的工作
并最小化预防性预提取等这意味着 所有人都获益
基本要点
单个上下文可以选择想要的行为
它可以决定它想要
你在iOS 9和macOS 11上适应的当前行为
我们称为已取消固定 注意看加载数据时树形结构顶端
你也可以指定上下文应固定到
数据库中任意当前的世代
当数据首次加载到该上下文时
或者 你可以指定你想要它固定到特定世代
如果另一个上下文固定到该世代
嵌套上下文将继承父级的世代
它们悄悄取消固定但是能够看到
通过父级世代查看的数据
以及父级闲置未保存的任何挂起的变更
更新一定程度上很重要我们都认可这一点
用户不想看到更新
最终 他们不希望看到10年前的数据
世代的更新发生在你通过设置
新世代标记明确告诉上下文更新时
它们在保存时更新
它们在你调用mergeChanges时更新这时它们将更新至树的顶端
既然你已经告诉上下文
你知道它应该在查看数据库中的一组新变化
它的更新是调用重置引起的
需要注意的是
当你更新世代时
已注册的对象不会被刷新你可能不想要那样
我们可以很轻松地让你这么做
如果我们选择代你做再让你取消难度会加大很多
如果你想要刷新数据
你必须调用fetch或refreshAllObjects
但是当数据实际得到更新时这样会使你获得控制
如果你想使用查询生成你必须使用SQL store
且SQL store应在wall模式下
尽管如果你尝试使用查询生成
你并未满足上述两项要求系统会正常退出
只是恢复到已取消固定的行为
我们是如何做的？
好 现在有一种opaque标记 你可以使用它
跟踪查询生成
这将告诉上下文 什么时候从什么存储加载了数据
查询生成标记有一个方法current
你可以使用它检索标记
以表明在它加载数据时上下文应固定
ManagedObjectContext我们有若干新方法
有一个属性QueryGenerationToken
它将会告诉你 上下文正在使用哪个查询生成
如果上下文取消固定则该属性为零
你可以由标记设置查询生成
或者是来自类属性的current标记
或是在另一个管理对象上下文调用
queryGenerationToken的结果
一个世代创建后该世代不会包含添加到
存储协调器的存储
如果你将数据加载到管理对象上下文
将存储添加到协调器然后进行提取
你不会从该新存储看到结果
但是它不会阻止你从协调器移除存储
尽管当你已移除从中加载数据的所有存储时
如果你尝试将数据加载到上下文
你会发现错误
现在 我将谈论并发因为
我们总是谈论并发
这是Core Data当前的情况
它的管理对象上下文是执行者
你使用perform以及performAndWait与它交互
做调度块 以便执行管理对象上下文队列
还有第三个模型或者说另一个模型
它使用confinementConcurrencyType
允许你直接对上下文发出通知
不过我们不推荐使用因为在任何线程情景下
它都很难操作正确
永久性存储协调器也是执行者
拥有同样的APIperform和performAndWait
协调器将对来自单个管理对象上下文的
请求进行序列化操作
同样也对你在坐标上使用perform和performAndWait API
直接安排的任何请求进行序列化操作
现在 我想宣布一件重要的事情
我们为在ObjC中编程
并使用手动保留释放的开发者
在执行、阻拦和等待周围添加了自动释放池
这意味着 你将负责
延长你安排的组块内
创建的任何对象的寿命
如果你想要在组块外使用这些对象
要记住进行这个操作很简单
对于 比如执行提取导致的结果
有一点不是特别明显
你还需对可能返回的NSErrors
进行此操作
这不仅影响使用手动保留释放的开发者
我们有链接时间检查这样你就不会看到此行为
直到你针对iOS X或macOS 12进行重新编译
不过让我们讨论下当今世界中存在的并发
或者说截止昨天为止世界上存在的并发
上下文1试图进行进入永久性存储所需的操作
所以它通知协调器
协调器由于清理请求锁定了
而此时 上下文2
可能作为你的UIContext想要采取些行动
并试图通知协调器
但由于协调器被锁定所以上下文2必须等待
同时来自上下文1的请求传递到永久性存储
任何需要被评估的工作得到评估
只有当这些工作完成并且执行线程返回时
上下文2才能锁定协调器
并将其工作向下分派给存储
这意味着上下文2基本上
对于上下文1在进行的所有工作都会被锁定
最终会恢复但同时你的IU
可能会比较慢
新东西 SQL存储目前有连接池
并且能够处理多个并发请求
具体地 它现在能够处理多个读取器和单个编写器
不同平台的连接池大小各异
我们已经采用了它 并将通过几张幻灯片向你展示如何更改
现在这是怎么实现的？
上下文1分派到协调器
且没有任何锁定
上下文2 可能仍然作为你的UIContext 也分派协调器
两条消息同时都向下发送给永久性存储
永久性存储随后会进行所有必要工作以发现
需要将什么消息发送到SQLite
这些消息发送到SQLite
只有在这时才进行锁定
这是标准的SQLite文件锁
SQLite进行所有必要的操作开始打开事务
对了 就是一堆SQL关闭事务
在此时结束 返回
所以 现在 我们确实已经缩小了
关键部分的范围
为什么要在意这一点？
这会使你的UI反应更灵敏
比如 当后台工作在不同的上下文进行时
你可以在主UI上
进行fault和提取操作
这直接的附带结果是
简化了应用架构
一个相当标准的模式是
人们会有一个导入程序上下文其正在从网页加载数据
而另外 主UIContext正在将数据传送到主UI
最终它们的数据位于不同的堆栈上
这是因为UI需要快速响应
它们需要关键部分的锁定尽可能小
而以前 当你必须锁定整个堆栈唯一做到的方法是
有两个不同的堆栈
这就导致了要在两者之间倒换的问题
比如 有一个管理对象上下文完成保存的通知
但它是来自完全不同的永久性存储协调器
我需要将它迁移过来
现在这不再是问题你现在可以将两个上下文
都附加到同一永久性存储协调器 它们将同时执行
你仅需进行标准的合并
而这其中的一大好处是这意味着它们共享行缓存
这样将大大降低你的内存占用
这将内存占用减半
因为 我们现在只有一个行缓存
默认情况下它是打开的它只针对SQL存储
它只有在永久性存储协调器上的
所有协调存储是SQL存储时才有效
你可以配置连接池的大小
使用NSPersistentStoreConnectionPoolMax SizeKey
你将能够确切地知道连接池的最大容量
如果你想要串行请求处理旧有行为 你可以设置为1
我们确实保留权利你已经尝试将它设置为
一百万 而这有点蠢
所以我们会使用更合理的数字
它应该立即可为你们大多数人所见
你的UI可能会响应更快
将此功能打开后我们内部最大的发现是
很多人说哇 我能写出
几百 几千行的代码
你应该试试 因为天啊 这太过瘾了
有些人...
有些人可能注意到一些小小的时间问题
若你有一个上下文上下文1有执行、阻拦和等待
上下文2也有执行阻拦和等待
最初 上下文2不会开始执行其数据块
直到上下文1的数据块返回现在事实不是如此了
所以 对于大概1%遇到这种情况的人
你的时间会发生改变
你可能需要降低带宽连接池rearchitect
而其他人
你们只需编写更新更有趣更简单的代码就行了
现在 我将邀请我的同事Scott上台
他会介绍很多其它内容
谢谢Melissa
早上好让我们介绍下Core Data设置
首先添加永久性存储
要对协调器添加永久性存储
你需要四块数据
而完成大多数操作你至少需要两块
今年新内容中 Core Data引入了一种新类型
叫做NSPersistentStoreDescription可以将所有
描述存储所需要的数据封装
同时包含方便的API可用于一般的选项
比如存储是否应以只读形式打开
协调器应使用的超时
现在默认情况下均已启用的自动迁移和映射选项
以及一个新增选项用于异步添加存储
这种新类型适用于永久性存储协调器上的一种新方法
该方法采取记录圈号附有用于描述存储的参数
以及一个可选NSError该NSError在操作失败时非零
如果你异步添加存储
你可以在回调函数中扩展条件
针对的是发布通知或推送应用UI等
时间是在成功添加存储后
这样 你应用的模型设置可以在主要线程外发生
这在启动应用时尤其有用
因为迁移可能导致延迟
记住 如果iOS注意到你的应用在启动后
一段时间仍不响应则iOS将关闭应用
这可能使迁移无法完成
但现在如果你在异步添加存储 这不再是问题
所以 那是永久性存储描述 不过
设置Core Data堆栈还涉及更多的东西
要代表Core Data堆栈你至少需要三个对象
及将它们互相联系的boilerplate样板
今年新内容中Core Data有另一类型
可以封装这些对象
及叫做NSPersistentContainer的大多boilerplate样板
它不仅...
我想很多人自己已经写过这种类型 不过...
这个不仅封装建模配置它还有名称
存储描述列表 以及从该列表中加载
尚未添加到协调器的存储描述的方法
这意味着设置Core Data所需项目boilerplate样板
从一整页代码缩减到了仅几行代码
所以现在少了很多代码让我们看看这是如何实现的
容器保证其属性始终有效
所以协调器和模型等的接收方
能够始终返回可安全使用的新对象
容器的初始值设定项基于你输入初始值设定项的
名称找到模型
还有另外一个初始值设定项它采取明确的模型参数
默认情况下 新容器在列表中仅有一个存储描述
它是SQLite附有默认选项
以及基于容器名称的文件名称
它存储在一个目录中
目录由容器上的类方法定义
而默认情况下 永久性容器
将基于你使用的平台向你返回目录
所以它会在macOS上使用应用支持目录
在iOS和launchOS上使用你的容器文档结构
以及tvOS上使用你的容器缓存目录
若你想设置自己的目录那么你可在永久性容器中
划分子类并替代直接
不好意思 默认的目录URL类方法
容器在设置Core Data时真很有用
不过它们也给一般操作带来了便利
容器有一个主队列上下文属性
叫做查看上下文你可以使用它驱动你的UI
还有一种工厂方法可以提供随时可用的
后台上下文但大多时候
你可能要使用容器的方法
来执行叫做performBackgroundTask的后台任务
所以你无需安装新的后台上下文 进行连接
然后排列数据块以便在后台进行操作
你只需将数据块传送到容器
使用performBackgroundTask的优势远不止获得简洁的代码
使用它可以使Core Data减少为完成你作业而
创建的上下文数目同时能够与连接池一起
确保你的应用响应快速即使是在重负载的情况下
说到一般上下文工作流
NSManagedObjectContext今年有一个新属性 叫做
自动合并来自父级的变更
它是布尔值当你将它设置为真
上下文会自动合并保存其父级数据的更改
这可以用于...
这真的很便利它可在父级
保存变化时用于子上下文
它也可以在同级保存到存储时用于顶层上下文
它尤其适用于世代标记
这个Melissa之前介绍过
所以如果你把UI上下文固定到最近的世代
并且启用自动合并你可以不必维护你的UI
你的fault会很安全你的对象绑定
以及提取结果控制器将保持最新
好
让我们讨论下泛型
Core Data今年采用了泛型
而且它们在ObjC和Swift中都很好用
有一种新的协议叫做NSFetchRequestResult
所有你可能看到的类型
都采用了这种新协议从提取请求
如NSManagedObject或所有的实体子类
对象ID、NSDictionary以及NSNumber
NSFetchRequest现基于结果类型被参数化
协议一致性限制结果类型在Swift中
NSManagedObjectContext上的提取方法探究提取请求的类型
一直探究到你的结果
最后 提取结果控制器
它采取了对创建它的提取请求的参数化
说到NSFetchResultsController
如果你正在使用UICollection视图 不好意思 在这儿
UICollection视图若你使用Core Data
采用新数据元预提取功能
会非常简单
你需要做的只是异步提取请求
从而从主要线程获得请求而且你应该确保
不会将对象作为fault返回
关于数据源预提取的详细信息
请查看Steve和Peter昨天的分享
UICollection视图新特点
如果你是Mac开发者我也有好消息告诉你
现在macOS提供提取结果控制器
好 让我们讨论下Core Data中的一些常见操作
从获取实体描述开始
额 这个 好了
为此 你需要实体的字符串名称
以及一个管理对象上下文
创建提取请求同样需要字符串常数
以及类型转换如果你想利用新的泛型
最后是创建新的管理对象
其中三样都有 包括字符串常数
上下文参数以及类型转换
今年 这些操作都变得简单了
因为我们改进了对象子类的管理
实体描述现在是子类上的类方法
别担心 这样更好
这一类也有工厂方法
可用于创建新的完全键入的提取请求
最后 你可以创建新的管理对象
只需直接使用子类的初始值设定项
还有一件事值得介绍
那就是执行提取请求
我之前提到过 上下文提取方法在Swift经过参数化
但ObjC不支持方法级别的泛型
所以我们也添加了像语义之类的执行者以提取请求
所以你只需从提交到上下文的数据块内
调用执行方法
就会返回正确键入的结果
针对模型子类的新API可以简化很多事情
不过我猜想你可能真正期待的是
重新生成你所有的子类
但不用担心 因为
这应该是你需要处理它们的最后一年
因为Xcode 8现在能够为你自动生成该代码
你可以按实体配置代码世代
Xcode会把生成的代码写入你项目导出的数据
所以不会导致未经你手的代码对源树造成污染
你无需编辑这些文件
因为当你变更模型时
代码会自动重新生成
但如果你想进行
在子类中添加自己的实例变量等操作
那么你也可以告诉Xcode仅生成一个类别或扩展
然后你可以拥有类本身
在Swift中 为使用该功能你需进行的操作是
导入你实体所属的模块
该模块通常也是你代码所属的模块
但是在ObjC中 你还需要了解一些其中的工作原理
ObjC中最需要了解的是Core Data模型标题文件
每个模型都有自己的标题文件你需要将它导入
以便访问所有该模型生成的类
如果我们放大 看一下生成的其他文件
了解为生成类而配置的实体
Xcode创建了两个标题你在自己生成类时
可能已看见过因而可识别出
其中一个声明类界面
另一个声明管理属性
在ObjC中了解这点通常很重要
因为如果你在生成一个类别
那么Xcode不会生成类界面
模型的标题将会直接导入类别
没有类界面就无法声明类别
所以生成的代码的预期是能够
在以该类命名的项目中找到标题
这是你拥有的文件如果它不在你的项目中
那么你就无法构建你的目标
让我们稍稍离开幻灯片看一看
这些新东西能为你带来什么
我打开了Xcode 8
我们将创建新的Xcode项目
并使用iOS主明细应用
我们今年更新了模块以便使用新UI
所以 如果我们将这个保存在某位置 然后转至应用代理
接着我们会看到
我们这里使用的是永久性容器
我们将母版视图控制器
与容器的视图上下文连接
如果我们切换到母版视图控制器
我们可以看到在创建新对象的地方
我们已经在使用Core Data生成的子类
初始值设定项
我们不再使用KVC
我们可以在管理对象上直接设置属性
如果我们命令单击就会转到生成的文件
如果我们返回 看一下如何设置提取结果控制器
好了
我们能看到在事件分类上
引发提取请求工厂方法
这里没有额外明确的键入
当我们创建提取结果控制器但是它的类型
非常小如果我们在这儿放大
它的类型通过提取请求传递
这意味着 其它地方
比如prepare for segue
好了
当我们从提取结果控制器获得对象
会返回正确的类型
这样 都好了我们不再有任何类型转换
不过 我不想让这个应用像默认设置这样
在母版视图控制器中显示时间戳
所以让我们在这里给事件实体添加一个标题属性
我们希望它是字符串类型
好了 我们重建并保存了模型
如果我们返回到这儿转至配置单元格
我们可在这里删除相应代码
使用Xcode的自动完成功能
获取我们刚刚在模型中设置的新属性
同样 如果我们命令单击它
将更新所有的代码
这其中最大一个隐性的好处是
如果你使用手动生成的子类
甚至KVC 如果你更改属性的名称
你最后可能遇到非常奇怪的故障
因为你的项目会编译
但如果实际调用时你会遇到运行时错误
因为注册表项路径不再存在
子类生成自动处理所有这些
这就是自动分类生成
以及Core Data新API的一些工作实例
最后 让我们介绍下SQLite的新特性
操作系统附带的SQLite库
有一些你在其它地方找不到的新功能
首先是多线程声明
Apple平台上的SQLite没有线程安全连接
多线程故障很难诊断
有时是因为它们通常显示为崩溃报告
SQLite深处只有一个线程
为使这些问题更容易被识别和重现
系统SQLite支持新的环境变量
该变量可以启用多线程声明
当它们启用时你将在SQLite中看到两个线程
两个线程均使用同一连接
SQLite始终通过可使用SQLite3 config进行配置
支持用户定义的记录功能
但是应在库初始化之前调用该功能
而库初始化可能已经发生
SQLite的可配置性很棒
不过我们在运行建模系统该系统有内置记录设施
所以现在有另一个环境变量
将SQLite记录送到系统日志
最后 我要介绍下文件操作
所有的数据库由一组文件表示
当文件操作在多个文件中进行时
文件操作不可能是原子的
这样的结果是所有的文件操作
本身都是不安全的
从Unix文件API到NSFileManager 所有的
这一点确实很重要
我想分享几个实际的例子
表明问题如何产生
比如 我发现目录中有两个数据库文件
我的代码要进行清理所以删除了两个文件
在删除数据库时
日志之类的东西连接到数据库文件
该数据库无法访问日志
所以系统无法识别数据库
就立即报告错误
因此影响你的应用
除非你能保证目前没有任何东西
将来也不会有任何东西试图连接到数据库
否则删除文件都是不安全的
比如 我有wall模式的数据库
该数据库正在使用中
由于某种原因 数据库最终被移开
当数据库在新位置打开时
相应的连接创建了新的日志和锁定文件
现在你就有两个连接
分别使用不同日志和锁定
不久 它们就会损坏数据库
这些例子可能有些牵强不常见
但是总共有超过十亿的设备
可能发生问题
对每个可能文件的每个可能的操作
都可能导致使用你应用的用户遇到问题
如果用户数据丢失 就会很慌乱
硬链接非常不好
不要对数据库文件使用硬链接
所以 今年的新内容是操作系统附带的SQLite库
充分利用分派源
如果非法操作对文件产生影响
数据库连接会报告错误
系统自身解决数据损坏问题
大多情况下 损坏已经发生
所以为帮助你识别并纠正这些问题
我们添加了另一个环境变量该变量可以使连接
在发现非法操作影响其文件时立即作出声明
如果你想知道
数据库损坏的更多原因
SQLite在网站上有指导手册
名称是“如何损坏SQLite数据库文件”
幸运地是 这些问题是可以避免的
如果你直接使用SQLite你应确保
只有一段代码拥有该数据库
该段代码应进入专门的文件访问
所以文件在打开时无法被修改
若你正使用Core Data你应该是在用
永久性存储协调器内有一个API
可以始终安全地用于SQLite数据库
无论是数据库打开与否
replacePersistentStore可将一个数据库更换为
另一个数据库的内容
而destroyPersistentStore
可以安全删除数据库中所有内容
并留下空白的数据库
好 上述就是今年Core Data的新特性
简要回顾下 我们新增了一项叫做查询生成的功能
这种功能可以使你即刻看到数据的稳定视图
我们现在使用支持连接池以及永久性存储协调器
这样可以同时允许多个读取器
作为单个编写器使你在进行大量数据操作的同时
能够保持漂亮的界面
Core Data设置更简单了
新API也使Core Data使用更简单
它在Swift中尤其好用
这得到Xcode全新集成的全面支持
我们在SQLite中也有新功能
可以使一般问题的调试更简单
要了解更多信息
请查看我们的开发者网站是在演讲242
如果你想了解更多可以参考Swift新特性
以及Cocoa的新特性
感谢大家的到来