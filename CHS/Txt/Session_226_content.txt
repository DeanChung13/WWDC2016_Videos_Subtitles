CloudKit新特性分享无限渴望
下午好 欢迎来到第226场演讲
CloudKit新特性
我是Paul Seligman
CloudKit客户小组的工程师
我今天很高兴能跟你们在一起
聊一聊最新的消息
和新的特性关于CloudKit的生态系统
我们今天讲什么？
今天首先我们要简单了解一下什么是CloudKit
然后我们换个话题讲一讲Telemetry
这是一个新特性可以让你想象
CloudKit支持的应用如何工作
我们会讲到API的改进和可用性
我们还会讲到Sharing
这是个新功能可以让用户
能够分享数据
但同时又能完全控制他人的访问权限
什么是CloudKit？
CloudKit是一种技术让你能够
使应用数据和用户数据
随时随地可用
CloudKit是一个框架给你访问iCloud数据库的权限
CloudKit被大量使用于Apple产品
它让你们相信我们努力的贡献
它让我们自信能够连接到
数千万用户
CloudKit可用于所有Apple平台
现在 我简明扼要地介绍一下CloudKit
就是过去几年我们为引进CloudKit所做的几个方面
我建议你们去听听下一场演讲
如果你想要更多的了解生态系统
我还要推荐这几场演讲
他们更详细地讲解了CloudKit的具体方面
通过这些方法你可以让你和你的应用
利用CloudKit的优点
现在 所有的演讲都已发布到网上且相互关联
developer.apple.com/CloudKit
这里所列的东西
是使用CloudKit的开发者必须要熟悉的东西
我们一个个讲先从Container开始吧
Container是一个机制通过它可以上传数据到iCloud
所以 Notes会用到Container
照片会用到Container
当应用在CloudKit创建时
它也需要有自己的Container
如果我们看看Container内部就会发现它里面装的都是数据库
直到上周这就是我们的数据模型
Container有两个数据库一个公用的和一个个人的
引进了分享后我们就用了第三个数据库类型
分享数据库
这个之后细讲
存储的基本单位在CloudKit里是一个record（记录）
它是一组键值对
通常映射到一个目标模型不对 是数据模型中的一个目标
现在 我们不会把记录松散的存储在数据库里
而是将它们封装在Record Zones（记录区）
一个记录区可以存很多个记录
一个数据库可以有很多个记录区
不同的数据库支持不同类型的记录区
公用的和个人的数据库都有一个默认的记录区
这是你所有记录的归属除非你特别指定另外一个
个人数据库也可以包括自定义的记录区
这是由你的应用创建并上传到数据库
最后 新的分享数据库由分享类记录区组成
有了分享功能后这个列表上就多了一个新的核心概念
就是Share的概念
Share是record的子类并同样地
与Records一起存在记录区里
你可以把Record想成你想要分享的东西
Share代表的就是你如何分享它们
比如参与者和许可
同样 这个一会儿再说现在只要知道有这么个东西
我们在Apple的很多系统中使用CloudKit
所以我想花点时间来着重介绍我们的几个客户
在公用数据库里有一些应用可能是你用过的
WWDC应用和News应用
特别是News应用它要将文章内容和图片等
保存到公用数据库里
这是公用数据库最大的好处
它存的数据是你希望所有用户都能访问的
与之相对的就是个人数据库
个人数据库是你存储用户私人数据的地方
这里面有几个是Apple的应用
包括iCloud Backup和iCloud Drive
iCloud Photo Library和Notes
我很高兴地跟大家宣布两个新功能
Notes Collaboration和Activity Sharing
都是创建于CloudKit Sharing之上
因此Notes和Activity应用
是使用分享数据库的应用
2年前 我们引入了CloudKit通过提供两个本地框架
一个是iOS 另一个是macOS
去年我们这个家庭扩大了
新添了tvOS数据库框架
还有两个网络框架
CloudKit JS和CloudKit网络服务
网络框架可以让用户访问CloudKit数据
无论是在网上
还是在没有其他本地框架的平台上
今年我们继续扩大来完善这个家庭
就是添加了watchOS本地框架
我们这就有了一个可用的CloudKit本地框架
覆盖所有Apple平台
那么现在我们来慢慢了解
今年的一些值得注意的针对平台的改进
从macOS开始吧
我们要与你们分享的这个大好消息
就是你不再需要通过MacApp Store来分发应用
只要好好利用CloudKit
使用iCloud forDeveloper ID新特性
你可以直接授权应用使用CloudKit
和其他iCloud服务通过你的许可配置
接下来我要讲的是服务器对服务器
这个功能已经推出了几个月了
它让你能够
使你的服务器直接与CloudKit服务器对话
就像管理用户一样
你的服务器可向CloudKit验证自己
通过使用一个公用/个人的密钥对
是你已在CloudKitDashboard建好的
你可以设置你的服务器
让他们有完全权限改写公用数据库
这是个很好的方法让你从服务器导入数据给CloudKit
或者从CloudKit导出数据到服务器
或者让两套数据更新保持服务器和CloudKit一致
CloudKit作为watchOS的本地框架被引入后
你就有了另一个机制让你的Watch应用
和iOS应用进行更新
这样一来你可以将CloudKit想成一个代替
watch连接性框架的选项
CloudKit有一个亮点
就是独立功能性
CloudKit使用NSURLsession
我们的网络连接使用最好的可用界面
如果你的watch是连接到iOS设备
我们会将通过iOS设备通信
但是watch同时也可以直接与CloudKit服务器对话
只要有Wi-Fi
现在我们来展示完整版本的CloudKit API
引进了CloudKit作为watchOS的本地框架
你就可以写出差不多的使用CloudKit的应用代码
在所有的Apple平台上
比如Activity应用就使用了它
写出CloudKit相似代码用于iOS和watchOS
来开展活动“分享明天”
注意我说的是相似代码不是一样的代码
当你编写代码并部署给各种Apple平台
你要记住每个平台的优势和限制
也就是说有时你会打破资源的上限
你必须要时刻记得CPU的特性
存储空间
网络特点比如延迟和吞吐量
你可以用这些决定与服务器对话的频率
以及想要传送的数据量
同样 测试仍是最好的办法来调整你的应用去适应平台
保证用户能获得最佳的体验
现在我来换个话题讲讲Telemetry
Telemetry是一个新功能
让你可以形象化
CloudKit应用的运行情况
Telemetry表现为
一系列图表 可见于CloudKit Dashboard
你可以通过它们看到你在公用数据库中的行为
或者是你在不同的用户个人数据库里行为的集合
你可以观察这些图表
这样就能了解每时每天每周每月的数据
你可以选择查看整个应用
也可以集中观察某一种操作
那现在就看看它长什么样
这就是CloudKit Dashboard你可能很熟悉
我请你们看看左下角这个新的UI元素
性能标签
当你选择性能标签
你可以访问一系列图表
告诉你你的客户都在做什么
它们分两类
第一个是性能图表示的信息有
每秒的操作量
以及你的请求的平均大小
你可以通过观察它想象公用或个人数据库中的数据
在不同时段的情况
也可根据不同操作类型观察
现在显示的这个图我们叫做正确性图表
我要你们注意的是客户端错误
它告诉你你发出的请求中有百分之多少
导致了客户端错误
那么 客户端错误
是一种错误的子集是CKOperation可能会产生的报错
正是这个子集
才使你的应用能解决错误并采取行动
比如你可能要保存一个记录
但是服务器上有一个与之冲突的记录改变
又或者你试图获取更改
从一个记录区但服务器不知道
这两种情况都会认作客户端错误从而显示在这张图里
通过形象化你的错误趋势
我们希望你可以利用它来发现
客户发现异常频繁的错误数量的情况
我们之前说过
错误处理很重要特别是对CloudKit支持的应用
区别能正确处理错误的应用
和不能正确处理错误的应用
就在于区别功能性应用和非功能性应用
重要的是它是编写基于CloudKit的应用的一部分
所以我们希望你能好好用这些图
来发现你需要检查的地方
看看你的客户是如何处理错误的
要了解更多如何处理错误的知识
我推荐你们参加明天的一个演讲CloudKit的最佳操作
我们会拿出一部分时间深入探讨正确的错误处理
接下来我要说说API的一些改进
这些都是上届 WWDC后新出的
实际上我要讲四点希望你们能仔细听
首先是长时间操作
长时间操作是一个机制让你不需要重复
你已经对服务器完成的工作
所以按照现在的情况应用关闭 操作就停止
所有它执行的未完成操作也会关闭
即使这个操作马上就能完成了
通过延长你的操作时长
操作的时长可以超过应用的生存期
它们会继续运行CloudKit也会继续缓存
本地缓存服务器的反馈
当应用再次运行的时候操作又继续运行
那么我们只要返回给你本地缓存中的缓存就可以
在很多情况下这个可以完全消除
网络连接再一次往返
关于创时间操作的更多细节我们明天再讨论
最佳操作 9点欢迎你来参与
下一个我想讲的话题是从我们的开发者那里听来的
是关于不良连接下CKOperation的行为
我想为你们描述的场景是我们有一台设备
设备的网络假设可用
但是我们收不到任何流量两个方向都没有
另外提一下你实际可以模拟这个场景
通过使用网络连接调节器
这是一个很棒的开发者工具可以模拟类似的情况
现在 CKOperation是NS操作的子类
因此它有QualityOfService属性
如果操作被标记为用户互动或用户发起
那么在不良网络环境下
我们会在1分钟后停止并给出连接超时的报错
如果你的操作有任意一个其他的QualityOfServices
我们会继续尝试最多七天
这大概不是你理想的状态
另外 如果你选择不设置
一个明确的QualityOfService在你的CKOperation中
我们会帮你选一个就是utility
所以如果都算上很多开发者报告说
“都5天了怎么我的操作还没完成”
所以我们要解决这个问题
解决办法是两个新的API
第一个用来解决网络无活动
我们视它为CKOperation的TimeoutIntervalForRequest属性
默认为1分钟
这个时间是我们等待封装传送的时间
如果在这段时间内我们没有看到任何流量进出
我们会停止操作并告诉你网络连接超时
我们还会设置一个端到端超时
表现为CKOperation的timeoutIntervalForResource属性
这个默认时长为7天这一段时间是用来
等待整个网络往返一次
也就是从你的设备到服务器然后再返回
我要提醒大家一个CKOperation可能发出多个网络请求
去完成它的任务
因此一个CKOperation所需时间会超过你的预期
只要有所进展能传递就可以
下面来讲讲如何有效地获取
一系列记录更改
当服务器里有很多记录区的时候
我们在研究分享功能的时候发现客户会看到更多的记录区
比你过去见过的要多
以前你的解决方法是
从数据库中截取一整列记录区
通过使用CKFetchRecordZonesOperation
但是这会产生几个问题
我们不想轮询也不想去截取
一整列记录区然后从服务器上下载
所以我们不再建议使用这种方法
我们用两个新的概念代替了它
第一 CKDatabaseSubscription
这个新类型可以被激发
当数据库里出现任何更改的时候
即便是在一个你不曾了解的记录区
第二个就是CKFetchDatabaseChanges操作
这是一种操作让你可以请求服务器
给出一列记录区里面包含了未完成更改
从过去的某个节点开始
那么现在你有了一列记录区你想从中截取更改
如何做到呢？
以前的方法是发出CKFetchRecordChanges操作
传递单一记录区从这个区里获取更改
我们不想让你逐个枚举所有的记录区
所以我们立刻弃用了这个操作
取而代之的是一个全新的操作名字听上去差不多
CKFetchRecordZoneChangesOperation
它实际上是个批次接口覆盖了以前的操作
让你可以
从多个记录区获取记录更改信息
只要一个网络往返就能完成
那么我们就来切实看一下
这是一个数据库几个记录区
每个记录区都有一系列记录
而客户更新过了所有更改
现在又出现了几个新记录
你的客户由于已经存了CKDatabaseSubscription
会造成服务器生成推送并发给客户
然后 使用CKFetchDatabaseChangesOperation
你可以向服务器请求一列包含未完成更改的记录区
这个例子里就是第一个和第三个
有了这个记录区列表
你可以发起CKFetchRecordZoneChangesOperation
请求所有的记录和所有更改的记录区
完成在一个网络往返中
最后我要讲讲如何快速的获取更改
在多个记录存在一个服务器的记录区的情况下
如果你以前用过CloudKit获取记录
那你会比较熟悉moreComing标识
它定义在CKFetchRecordChangesOperation
用来告诉你这里不仅有我们给你的更改
服务器上还有更多你能获取的更改
需要随后发起CKFetchRecordChangesOperation
这个方法有几个问题
第一就是我们已经发出了检查标识的逻辑
并且发起了另一个操作对所有其他客户
这有可能再次失败
第二就是在你考虑要不要获取并尾接新的操作
通过尾接指令的时候
CloudKit是空闲状态
我们想把两个问题都解决
所以我们利用了我们创建的全新操作
CKFetchRecordChangesOperation来改变这个模型
不再是我们告诉你这里有更多可用的更改
而是你告诉我们
你想通过新的fetchAllChanges属性做什么
它的定义为真时
CloudKit会从服务器获取一批更改
交给我们的客户
然后立刻返回服务器获取下一批更改
这就让运转持续进行
一边开始拉取网络数据一边是你的处理进程
我们认为这应该是个常见的行为
所以将它设定为这一新类的默认行为
因此 新的CKFetchRecordZoneChangesOperation
默认的是获取整个记录
从指定的记录区
你可能会想如果你有了一个大记录区
比如说服务器上用户的iCloud Photo Library
这就意味着后续的操作就要获取记录区中的所有记录
需要很长一段时间完成
所以我们想能迅速恢复
如果操作中途失败的话
我们不想重新下载已经从服务器上获取的批
因此我们给这个新类添加了新的回调
RecordZoneChangeTokensUpdatedBlock
在给出一批更改之后
我们会告诉你一个最新的服务器更改token
那么你写的代码要做到两件事
首先你要commit
每个你从服务器获得的记录的更改
第二要缓存这个服务器token
如果操作在未来某个节点失败了
你可以发起一个新的CKFetchRecordZoneChangesOperation
传递给已经本地缓存好的服务器token
然后直接从断掉的地方继续操作
不需要重新下载已经从服务器下载过的批数据
这4个API的改进功能是我们希望你们能好好利用的
如果你正在编写基于CloudKit的应用
接下来 我要换一个话题了
让我们有请Jacob Farkas上台来为我们讲解Sharing UI
SHARING UI你和我的分享空间
谢谢你 Paul
我是Jacob Farkas是CloudKit小组的工程师
今天我要讲的是
如何将CloudKit分享界面添加到你的应用中
而且只需要写几行代码
我们已介绍了CloudKit新类型就是CKShare
这是CKRecord的子类
它负责存储两种重要的信息
第一 分享的信息
第二 分享给谁
那么我们来看个例子
这是个人数据库
这里有一个备注在个人数据库里
我们想分享它
因此 我们要创建CKShare
并把那个记录作为root record（根记录）来对它初始化
创建Share必须使用根记录
所以Share里必须有内容
接下来我们要保存这个Share和根记录
要同时存到服务器
这么做是因为CKRecord有一个新属性
就是我们正在创建的Share的一个引用
通过同时保存根记录和Share
这个引用会与你刚刚创建的Share联系起来
我们不仅要定义分享什么
也需要定义分享给谁
因此我们在CloudKit里创建了新的lookup服务
这个lookup服务会利用一个电子邮箱
然后转给一个CKShare使用者
你可在Share上设置这个Share使用者
将Share存到服务器
现在他的iCloud账户就可以访问Share了
我们也支持通过电话号码寻找用户
或者通过CloudKit用户记录ID
现在我们希望用户可以控制他们分享数据库里的动态
不想让这些记录反复不停地出现
用户需要能控制它这样才能
接受这个Share并加入它
这就是说我们需要一个方法去告诉其他用户
我们分享了东西给他们并邀请他们
并且告诉他们需要加入
这个就是通过URL来实现
每一个分享都带一个URL作为它唯一的身份
如果用户在iOS按一下这个URL或者macOS上点击它
接受UI会显示出来
询问他们是否要加入这个Share
如果是 会跳转到应用
他们会看到这个Share的内容
URL最好的一点就是如果用户使用比较老的平台
或者是不支持分享的平台
它会转到iCloud.com
这样我们也能让他们看到Share的内容
告诉他们如何接受并加入这个Share
那么就把这个URL放进电子邮件
然后发送给我们邀请的其他参与者
他们会收到这封邮件 点击它
然后在他们的分享数据库里
就可看到这个Share和Note是我们创建并分享给他们的
这里最精彩的就是这个分享数据库
实际上是个视图可以看到用户的个人数据库
所以 如果另一个用户有权限访问Share
并且更新了这个Note
我们会看到同样的更改出现在我们的个人数据库中
那么我们来看一看UI里这个是什么样子
好 我们做了Note并添加了分享
平台是macOS X Sierra
通过使用我们今天发布的CloudKit分享API
就会看到一个新的Share AddPerson按钮出现在上方
点击它
会收到一个新的菜单选择如何分享URL
当我们点击分享
系统UI会调令Notes...
告诉Notes要存下这个Share
以及根记录给服务器
一旦成功系统UI会跳出一个写邮件的窗口
这里可以邀请其他用户
点击发送
系统UI就会将这个Share存到服务器
寻找参与者
然后再把邮件转发给其他用户
那么换到iPad看看这里另一个用户
我们看到了刚发出去的邮件
我们可以点这个URL
然后会询问我们是否要加入这个Share
如果选是我们会直接跳转到Notes
Share会显示Note开始下载
现在我们就把这个Note分享给其他用户了
如果对Note进行更改在发起人的界面
比如说我取消选择列表上的牛油果
添加青柠为另外要买的东西
我们会看到分享给我们的note也变了
那么现在看看背后的代码
你们现在可能已经很熟悉CloudKit框架了
也就是CKRecord和新的CKShare目标存在的地方
如果要使用新的系统分享UI
你可以在macOS下的AppKit里
和iOS下的UIKit里找到
首先我们来看iOS分享API
在调出UI之前当然要先创建一个Share
我们就用这个根记录创建Share
我们会设置几个属性让UI显示这个Share
标题和缩略图
然后我们接着创建UI云分享控制器
我们用刚建的Share对它初始化然后传递给他一个准备处理器
这个准备处理器会被调出
当要把这个分享记录保存到服务器时
这个处理器会创建一个CKModifyRecordsOperation
保存记录和Share到服务器
完成之后就会调出完成处理器
下面我们就要设置一个属性给这个UI云分享控制器
其中一个属性就是available permissions
我们可以选择是只公开分享这个Share
还是只给参与者读或写的许可
我们还要设置presentation controller源视图
让添加朋友的弹窗出现在我们点击按钮的地方
我们定义自己为代理
这样我们就可以收到UI活动的返回
最后调出Present这时
跳出一个这样的弹窗
这时 如果你已经保存了这个Share到服务器
就可以只用Share调出UI云分享控制器
然后它会显示一个被邀请用户的列表
让他们管理Share上的用户
也可以按他们的意愿停止分享
所有的事情系统UI都为你考虑好了
macOS分享API跟这个十分相似
所以我们就快速过一下着重讲一下不同之处
首先创建一个NSItem provider
用它注册CloudKit Share
这个处理器看上去跟我们之前看到的一样
你要把记录里的Share保存到服务器
完成后 调出完成处理器
接下来你要创建一个NSSharingService
这个分享服务的代理就是你自己
然后调出perform
通过刚刚创建的NSItem provider
最后 NSSharingService可以回调
所以 如果你设置Share的可操作选项
你就要回调Share选项
macOS上Share创建的UI是这个样子
如果要在Share上修改参与者界面是这样
如果一个用户接受你的应用的分享
你的应用就会发布
然后收到这个回调ApplicationuserAcceptedCloudKitShare
回调中包含Share元数据是根记录中的Share
是用户刚刚同意的
这个iOS的操作很像
除了用的是UIApplication而非NSApplication
最后 你要告诉系统你的应用支持CloudKit分享
这要通过CKSharingSupported key实现
就在info P list里
我们还要高兴地宣布我们已经把完全分享支持添加到了
CloudKit JavaScript库
这样只要你在网上就可以创建和接受Share
而且我们已经提供了一些UI让你可以用来管理Share
你现在就可以在CloudKit目录里试试看
现在我要将舞台转交给我的同事Vanessa
她会为你们深入讲解分享
谢谢你 Jacob
嗨 下午好
我叫Vanessa Hong
我是CloudKit服务器小组的工程师
今天我们要深入了解分享通过展示一些常见的使用场景
首先从被分享的数据讲起吧
之后我们会逐步深入
讲解CKShare对象中的internal
之后我们讲讲如何调出分享API
如果你想创建自定义的UI的话
最后结尾讲一些特别需要注意的事项
现在就开始吧
Jacob展示了如何分享一个单一记录
但是用户想分享的有时不只是一个单一的记录
可能是很多记录
可能已经连接了CKReferences
但是你的应用只想让参与者看到这个记录的一部分
这就是为什么我们要在CKRecord上引进新的域
叫Parent Reference
设置Parent Reference
可以在任何你想在包含于分享结构层的记录上
这个设置甚至可以在用户决定分享之前完成
当用户确实要分享
你可以只用根记录创建CKShare
之后所有产生的记录
都会通过Parent Reference链接到这个根记录
并且自动存入分享结构层
那么来看看在分享数据库里是什么样子
一个分享数据库只是一个视图可以看到用户的个人数据库
所以它不包含任何具体的记录
当一个参与者接受了一个Share他们只能看到分享给他们的内容
所以他们看到是分享的那个层次
也就是说这些记录没有复制
只有一套数据并存在所有者的个人数据库中
也就是说所有者和所有的参与者
都通过同一套记录互动
这种争用最后可能会导致冲突
要学习如何处理冲突
我推荐你们
2014年 WWDC的一场“高级CloudKit”演讲
现在 可读/写参与者就可以修改 删除和添加记录了
但是我们又不想让他们随意添加东西
到别人的数据库里
比如他们不能随意添加根记录
也不能添加没有Parent Reference的记录
即便是它能连接到分享结构层
所以要通过分享数据库正确的添加新纪录
就要设置Parent Reference并连接到分享结构层
这样即便你添加新的记录给参与者
通过分享数据库
新的记录只存在所有者个人数据库里
这就意味着
所有参与者添加的记录都不计入所有者的配额
因此创建的份额不受影响开发者的份额也不受影响
所有者的个人数据库是唯一保存这些记录的地方
所以我们只能让他们不影响所有者的份额
这就是如何分享多个记录
我们来近距离研究下分享数据库
这里我们有两个Share来自两个不同的所有者
但是两个Shares名字一样那怎么区分？
我们忽略了一个十分重要的细节
就是所有CloudKit的记录都存在记录区里
而这个区是由CKRecordZone ID定义的
这个区的名字
是你创建的自定义的区的名字
其所有者的个人数据库中
所有者的名字就是所有者的用户记录名字
这个例子中的两个区 有同样的名字但是属于不同的所有者
假设第一个所有者分享了一些东西但是在不同的区
那么当你调出FetchDatabaseChanges API时
这个新的区会出现
之后当你调出FetchRecordZoneChanges
你会看到新的记录和Share
假设第二个所有者分享的东西在现有的区里
这个区已经存在所以不需要再建新的
我们只要再利用
当调出FetchChanges API时
你会看到这个区发生了变化新的记录出现了
这就是我们的分享数据库
那么再深入一层看看CKShare对象
在所有者创建Share之前得有要分享的东西
因此 记录代表了Share的内容
CKShare代表了如何分享
我们要讲的是如何分享
就像Jacob说的
每个CKShare都是一个CKRecord但有附加属性
我们之前讲过了这些属性如何应用于Share的生存期
所以如果重头开始所有者就要创建一个Share
还要决定Share的publicPermission如何
这个例子里所有者决定是none
因为他想要邀请参与者
假设他邀请了两个参与者
他们的状态是自动接受邀请
之后所有者就要考虑给每个邀请者什么样的权限
然后所有者保存Share后就会收到Share的URL
这里会发生两件事
第一是这个Share有一个声明
声明说
只有两个参与者可以接受这个Share
所有者是唯一知道该URL的人
只有他能将这个URL告诉其他人
所以即使他把这个URL告诉了100个人
还是只有两个人可以接受这个Share
当一个参与者通过URL接受了这个Share
接受之后他们的接受状态就会变成已接受
然后Share的权限就是所有者给予他们的权限
假设所有者想要创建一个更加开放的分享
就让我们重头开始
所有者设立一个Share
将公用权限设置为只读或者是可读/写
他没有邀请任何人只是保存这个Share
之后他获得了这个分享的URL
这时仍然有两件事会发生
第一是Share有一个声明说任何人都可以参加
所有者还是唯一知道URL的人
他负责告诉其他人
假如他告诉了100个人那么所有这100个人都能参加
他们也要通过这个URL参加
然后出现在Share里的参与者状态变为已接受
他们的权限来自于Share的publicPermissionfield
这就是你如何创立一个分享和接受一个分享
Share的第二个阶段就是当参与者退出时
当然参与者可以退出分享
通过删除分享数据库里的CKShare对象
这同时会删除分享数据库里的分享记录
要明确的是CKShare仍然存在
它在所有者的个人数据库里
只是这个参与者
不再出现在Share里也不再是被邀请的状态
但是所有者对他的Share有完全掌控
他可以删除任何一个人
假设他想把所有人都删了
他就要删除CKShared对象
从他的个人数据库里清除
这会删除Share根记录的pointer
这时所有者就回到初始状态就是未分享状态
接着我们来讲讲CKShareParticipant对象
如果你见过这个对象在生存期开始之前
你会看到接受状态和许可
但是现在看一看UserIdentity类
这有lookupInfo
是指参与者是如何被邀请到Share的
所以这里会有他们的邮箱电话或者用户记录ID
名字分为姓和名
它会在参与者接受这个Share的时候弹出
每个CKShareParticipant会分到一个iCloud账户
那么假设所有者邀请了4个人
我们能找到前两个人的iCloud账户
但是后两个人没有
但是这没什么问题
CloudKit会创建一个临时占位符
给第三个和第四个人
而且只有第3和第4个参与者
需要证明
他们持有的邮箱地址和电话号码
是所有者邀请他们时提供的这就是验证过程
这个过程会将邮箱或者电话与账户联系在一起
这样就不需要再走一遍验证过程
这就是我们现在在分享中的所有对象
那么接下来我们聊聊分享API
如果你想创建自定义UI
你可以调出我们的API有两种方法
代表所有者你可以帮他们设立一个Share
代表参与者你可以帮他们接受一个Share
watchOS和tvOS没有内置的系统UI
所以你可以让你的用户
用另一个平台建立和接受一个Share
之后这个Share的数据在所有平台上就都可用了
或者你也可以调出我们的分享API
你要这么做
代表所有者你要帮他们添加参与者
你需要寻找他们通过邮件 电话或者用户记录ID
然后转换成CKShareParticipant对象
一旦获得了CKShareParticipant对象
就要添加到分享里
然后调出CKModifyRecordsOperation来保存这个分享
现在你的应用就获得了这个分享的URL
当然你可以决定是应用还是所有者
来把这个URL告诉别人
当一个参与者接受一个分享第一步都是从URL开始
首先要将URL转换成CKShareMetadata对象
然后将这个元数据传递给CKAcceptSharesOperation
现在 参与者就会显示在分享中并且是已接受的状态
这个已接受的API也有一些限制
从隐私角度来说我们无法返回他们的姓名组件
那么验证程序不可用
如果你收到这个报错
或者iCloud账户的Boolean为假
那么你要让你的用户亲自打开这个URL
这样可以触发系统或者网络
让他们通过验证过程
以上就是分享API
现在我们再来说说你的用户
应用的用户可以邀请任何他们想邀请的人
通过邮件或者电话
这就意味着
应用的潜在用户要远远多于现在的用户群
这些被邀请人可能没有安装最新的操作系统
他们甚至可能没有Apple的产品
所以当他们点击这个URL我们会把他们转到网页
以Notes为例这就是他们看到的画面
他们会被要求加入分享然后他们就可以看到分享的内容
他们可以与这个Note互动就像在设备上一样
但是这是个Note网页应用存在于iCloud.com
你的应用如何呢？
默认的情况下你的用户会看到这样一个界面
这里有你的应用的图标并要求你的用户使用最近使用的设备
这不是最理想的用户体验
所以我有一些好消息要告诉你
你可以到CloudKit Dashboard设置一个fallback URL
如果被邀请人点击了这个分享给他们的URL
我们会把他们重新导向你的fallback URL
我们会在后面添加token代表Share的唯一URL
这样你就可以立刻让他们接受share
然后显示分享的数据
现在我希望你们都等不及要开始分享了
这是最后一点你们要知道的
CKShare是最新的记录类型
这种类型与CloudKit其他类型一样
可以在上面创建自定义域你可以运行查询指令
你也可以第一个在开发环境下创建新记录
创建的最简单的方法
就是使用用户身份登录开发环境
然后从你的个人数据库分享点什么
这样就会触发记录类型的创建
然后去CloudKit Dashboard部署scheme给production
如果不这么做
那么用户在production环境下创建分享时就会出错
因为记录类型还没成立
这就是最后我要讲的
那么 今天你们了解了
CloudKit可用于所有平台包括watchOS
它也可用于网络通过CloudKit JS
Telemetry在CloudKitDashboard可用
这是个很好的办法来视觉化你的应用的行为
包括错误趋势
API有了很多改进包括长时间操作
QualityOfService还有最新fetch changes APIs
现在你也全面了解了我们的新功能 分享
你看到了这个系统UI
你知道了如何创建自定义UI
通过调出我们的分享API
你也看过了所有我们用在分享中的对象
包括分享者的存在周期
我打赌你们回去后会设置这些fallback URL
那么 感谢你们与我们分享这样的体验
我想请大家关注这场演讲“CloudKit的最佳操作”
就在明天早上九点
这场演讲很精彩让你了解如何能有效率地使用CloudKit
谢谢你们的到来希望你们享受 WWDC 的其他会议