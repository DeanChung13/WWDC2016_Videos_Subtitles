应用启动时间优化
早上好 欢迎来到406演讲“应用启动时间优化”
我叫Nick Kledzik我将和同事Louis
带大家一起讨论 如何启动进程
你们可能会想 这个主题适合我吗？
所以我们请了专业的开发营销团队做了一些调查
得出的结果是有三组人群将会从本演讲中收益
第一组 是应用开发者他们的应用启动很慢
第二组 是不想在第一组的应用开发者
最后一组是任何对操作系统的运作感到好奇的人
所以本次演讲分成两个部分
第一部分更注重理论第二部分更注重实际
我负责第一部分
我将会带你一起看看发生的步骤
一直到主函数
但是为了理解所有的步骤
首先需要上一个速成课关于Mach-O和虚拟内存
首先快速讲一下Mach-O的部分术语
Mach-0是运行时可执行文件的文件类型
第一个类型是可执行文件应用里最重要的二进制文件
也是应用扩展文件的主二进制文件
Dylib是一个动态库在其他平台上
用的是你可能会熟悉的名字：DSO和DLL
我们的平台上还有另一种类型叫捆绑包
捆绑包是一种特殊的Dylib是不能进行链接的
只能在运行时用dlopen()函数打开它
Mac OS的插件会用到
最后是图像图像指的是任意这三种类型
我会常常提到图像
最后 是框架该名词在我们的领域如雷贯耳
但就本主题而言
框架是一个Dylib周围有特别的目录结构
存储该Dylib需要的文件
我们来看看Mach-O图像格式
Mach-O图像分成数段
按照惯例所有的段名都是由大写字母组成
每一段都是页面大小的倍数
该例中 TEXT段大小是3页DATA和LINKEDIT段大小是1页
页面大小由硬件决定
arm64处理器的页面大小是16K其他都是4K
另一种查看方式是分区
编译器常常会忽略分区
分区是段的子范围
分区不用遵循页面的大小
但是它们是不重叠的
最常见的段名是TEXT DATA LINKEDIT
实际上几乎每一个二进制文件都包含这三段
你可以添加自定义段但一般不会给它赋值
这些是用来做什么的？
TEXT是文件的开头
它包含了Mach的头文件任何机器指令
以及任何只读常量 比如C字符串
DATA段是重写段
它包含了所有的全局变量
最后是LINKEDIT段
它不包含全局变量的函数
它包含变量函数信息
比如名称和地址
你可能还听说过通用文件什么是通用文件？
假设你生成一个64位的iOS应用
现在你有一个Mach-O文件
当你也想让它在32位的设备上运行
Xcode里会发生什么变化？
重新生成时 Xcode会生成另一个单独的Mach-O文件
这个是为32位生成的armv7
之后这两个文件合并成第三个文件
叫作 Mach-O通用文件它前端有一个头文件
所有的头文件都有一个所有体系结构的列表
它们的偏移值也在文件里
该头文件也是一个页面的大小
你也许想问为什么段都要是页面大小的倍数？
为什么头文件要一个页面的大小为什么要浪费那么多空间？
这就涉及到我们下个主题 虚拟内存
什么是虚拟内存？
你们当中可能有人知道软件工程里的格言
任何问题都可以通过添加一个间接层加以解决
所以虚拟内存解决的问题是
所有这些进程存在时该如何管理所有物理内存？
所以他们添加了一个小的间接层
每一个进程都是一个逻辑地址空间
映射到RAM的某个物理页面
这种映射不一定是一对一的
逻辑地址可以不对应任何物理RAM
也可以多个逻辑地址对应同一物理RAM
这样带来很多种可能
能利用虚拟内存做什么呢？
首先 如果有一个逻辑地址不映射任何物理RAM
当进程要访问该地址时就会产生页面错误
内核将停止该线程
并试图找出解决方案
下一点是 如果有两个进程
有两个物理地址 映射同一个物理页面
这两个进程共享一样比特的RAM
进程之间开始共享
另一个有意思的功能是基于文件的映射
不用把整个文件读入RAM
而是可以调用mmap()函数告诉虚拟内存系统
我想把这部分文件映射到进程里的这段地址
为什么要这么做？
不用读取整个文件 通过设置该映射
第一次访问这些不同的地址时
如同已经在内存里读过
每次访问未访问过的地址时
都会导致页面错误内核会读该错误页面
将会造成读取文件迟缓
现在可以把所有功能集中
关于我告诉你的Mach-O可以发现
Dylib或图像的TEXT段可以映射到多个进程
将会造成读取迟缓
而所有这些页面可以在进程间共享
DATA段呢？DATA段用来读写
有一个策略叫写入时复制
这和Apple文件系统的克隆很相似
写入时复制所做的是它积极地
在所有进程里共享DATA页面
只要进程只读有共享内容的全局变量
但是一旦有进程想要写入其DATA页面
写入时复制开始
内核会把该页面复制
放入另一个物理RAM并重定向映射
所以该进程有了该页面的副本
这把我们带到了 脏vs干净页面
该副本被认为是脏页面
脏页面是指含有进程特定信息
干净页面是指内核可以按照需要重新建立的页面
比如重新读取磁盘
所以脏页面比干净页面要昂贵许多
最后一点是 页面也有权限界限
这指的是 可以标记一个页面
可读 可写 或可执行或它们的任何组合
所以我讲到了Mach-O格式关于虚拟内存的一些内容
看看它们是如何一起工作的
我先往前跳一步先简单讲讲Dylib是如何操作的
一会儿我会和你们一起来看 但现在
我想讲一下它在Mach-O和虚拟内存之间是如何映射的
这里有一个Dylib文件我们没有把它读到内存
而是把它映射到内存
所以 在内存里该Dylib文件本应该占用8个页面
看一下 不同是有这些“全零填充”
大部分全局变量的初始值都是零
所以静态链接器进行了优化
把所有值为0的全局变量都移到了尾端
然后不占用任何磁盘空间
取而代之我们利用虚拟内存的特性
该页面第一次被访问时告诉虚拟内存 把它填满0
所以它不需要读取
Dylib必须要做的第一件事是查看Mach头文件
在内存里 在该进程里
它将查看内存的顶盒
此时 那里是空的没有内容映射到物理页面上
所以产生页面错误
到那时内核意识到它被映射到了一个文件
所以它将读取文件的第一页
放入物理RAM设置其映射
现在Dylib可以真正通过Mach头文件开始读取
它这么做了 Mach头文件说
“看看LINKEDIT段上的这条信息”
再一次 Dylib跳下去查看进程1的底盒
这又会产生页面错误
内核又读入RAM的另一个
LINKEDIT的物理页面Dylib现可期望一个LINKEDIT
进程 LINKEDIT将会告诉Dylib
对DATA页面做一些修正让dylib可运行
所以 同样的事又发生了
Dylib现从DATA页面读取数据
但是有一点不同
Dylib 想要写回一些内容修改DATA页面
此时 写入时复制出现了
这个页面变脏了
所以脏RAM的8个页面将会是什么？
若我只用malloc()函数分配8页内存 然后读了一些内容进去
我将会有8个页面
但是我只有1页的脏RAM和2页干净的
如果第二个进程加载同一个Dylib 会发生什么？
在第二个进程里Dylib经历相同的步骤
首先它查看Mach头文件
但这次内核说
“在RAM某处我已经有这页了”
所以内核只简单地把映射重定向重新使用该页面 没有任何IO操作
LINKEDIT也是如此 更加快速
我们来看DATA页面
此时 内核必须要看看在DATA页面
干净的副本是否还存在RAM某处
如果还在 就可以重复使用如果不再 就必须要重新读取
在该进程种Dylib会让RAM变脏
最后一步是LINKEDIT
只在Dylib进行操作时被需要
所以它可以提醒内核 当它完成时
它不再需要这些LINKEDIT页面
当有别人需要RAM时 可以回收它们
现在有两个进程在共享这些Dylib
每个进程都本应该有8个页面也就是一共有16个脏页面
但现在我们只有2个脏页面和1个干净的 共享页面
我还想补充说明两点安全如何影响Dyld
两点安全问题会影响Dyld
首先是ASLR 地址空间布局随机化
这是10年或20年前的旧技术
基本概念是把加载地址随机化
第二点是 代码签名
你们当中的很多人都有代码签名的经验在Xcode里 代码签名是指
对整个文件运行一个加密哈希算法
然后在文件上签名
为了在运行时进行验证整个文件都必须要重新读取
所以在编译阶段我们让Mach-O文件的每一个页面
都进行自己的加密哈希算法
所有哈希都储存在LINKEDIT里
这使得你的每个未被修改的页面
在被读取的过程中都能得到及时验证
好的 速成课结束
现在我将带你们一起从exec()讲到main()
什么是exec()？exec()是一个系统调用
当你进入内核 说
我想把这个进程换成这个新程序
内核会抹去整个地址映射指定的可执行程序
ASLR把它映射到一个随机地址
下一步是从该随机地址 回溯到0地址
把整个区域标记为不可访问
意思是 不可读 不可写 不可执行
该区域在32位处理器下至少4KB大小
64位处理器下至少4GB大小
这样可以捕捉任何空指针引用
捕捉任何指针截断
Unix诞生的前几十年一切都很简单
我只需映射一个程序把指针引用指向它 开始运行它即可
然后共享库被发明出来
那么谁来加载Dylibs？
人们很快意识到情况太过复杂
不想让内核来做这件事
所以人们新建了帮助程序在我们的平台上 叫作Dyld
在别的Unix平台可能听说过它名字LD.SO
当内核完成进程的映射它现在映射另一个Mach-O文件
调用Dyld进入该进程到另一个随机地址
把指针引用指向Dyld 让Dyld完成进程启动
现在Dyld在运行进程
它的工作是加载所有依赖的Dylib
让它们全部准备好开始运行
我们一起来浏览这些步骤
底部有很多步骤和一个时间线
我们浏览这些的时候 也会浏览时间线
首先 Dyld是否需要映射所有的依赖Dylib？
什么是依赖Dylib？
要找到它们 首先要读取主可执行文件
的头文件 内核已经映射好的
在该头文件里有一个所有依赖库的列表
都必须要进行分析
所以必须要找到每一个Dylib
如果每一个Dylib都找到了它就须打开和开始运行每一个文件
它需要确保是一个Mach-O文件
对它进行验证 找到它的编码签名在内核里对它进行注册
然后它可以在该Dylib里的每一段调用mmap()
好吧 这非常简单
你的应用知道内核Dyld
Dyld说 噢这个应用依赖A和B Dylib
加载它们两个 完成了
当然 实际情况要更为复杂因为A.dylib和B.dylib
自身也可能依赖dylib
所以dyld必须再做一次同样的事
为每一个dylib
而每个dylib可能依赖于某个已加载或新的东西
它决定是否已经加载如果否 则需要加载
所以 如此继续
最终所有的都加载了
如果你看一个进程系统里的一个普通进程
都会加载1到400个dylibs这个加载数量很大
还好大部分都是OS dylibs我们做了很多工作
在建立OS预计算时
和与缓存那些dyld要做的工作来加载这些内容
所以OS dylibs加载速度非常非常快
现在所有dyibs都已经加载完成
但它们都彼此独立我们必须要把它们绑在一起
这就是修复
关于修复有一点 我们已经知道
因为编码签名的存在我们无法修改指令
那么dylib该如何调用另一dylib？
如果无法修改指令 怎么调用？
我们把老朋友找回来加上许多旧的间接引用
所以我们的code-gen即动态PIC 即地址无关代码
代码可以加载到该地址 并且是动态的
也就是说 地址间接地被分配
也就是说为了让一个调用另一个
code-gen实际上在DATA段里新建了一个指针
该指针指向我们想要调用的位置
代码加载该指针 跳向指针
所以所有的dyld都在修复指针和数据
修复有两种 重设基址和绑定
它们的区别是什么？
重设基址是指如果有一个指针指向图像范围内
需要做出的所有修改
第二种是绑定
绑定是指 如果指针指向图像范围外
它们必须进行不同的修复
我来带大家一起看看其步骤
但是首先 如果你觉得好奇有这么一个指令
dyldinfo还有很多选项参数
你可以在任何二进制文件上运行就可以看到所有的修复
该dyld将必须该二进制文件才能让他准备好
这就是重获基址
过去你可以为每一个dylib指定首选加载地址
该首选加载地址是一个静态指针
和dyld一起合作比如 若把它加载
到该首选加载地址 所有指针和数据
本应该内部编码的 都是正确的
那么dyld就不用做任何修复
但是现在 因为有了ASLR
dylib加载到随机地址上
它滑到了其他地址也就是说所有那些指针和数据
都还依然指向旧地址
所以为了修复它们我们需要计算滑动值
也就是移动距离并且对每一个内部指针
都添加该滑动值
所以重设基址是指遍历所有
内部数据指针然后为它们添加一个滑动值
概念非常简单 读 添加 写读 添加 写
但是这些数据指针在哪里？
这些指针在段里的位置都编码在LINKEDIT段里
此时 所有映射都已经结束
当我们开始重设基址时
实际上在所有DATA页面上都产生了错误
然后对页面进行修改 产生写入时复制
所有重设基址有时会非常昂贵由于所有这些I/O
但是有一个技巧  就是按顺序操作
从内核的角度来看它认为数据错误按顺序产生
当它如此认为时 内核会进行预读
这样I/O成本将降低很多
下面来讲绑定
绑定针对那些指向dylib范围外的指针而言
这些指针通过名称进行绑定实际都是字符串
本例中LINKEDIT段里的malloc
也就是说该数据指针需要指向malloc
所以运行时dyld需要找到实现该符号的位置
这需要很多的计算 遍历查找符号表
一旦找到 就把值存到该数据指针里
计算复杂度比重设基址高得多
但是I/O很少
因为重设基址已经完成大部分I/O
下一步 ObjC有很多DATA结构
DATA结构类也就是指向方法的指针
以及高光指针等等
几乎所有都已经被修复通过重设基址或者绑定
但在ObjC运行时还需要一些额外的操作
首先ObjC是一门动态语言
可以把一个类用名称实例化
即ObjC运行时 必须要维护
一张表格 包含所有名称及其映射的类
每次加载的名称 都将定义一个类
名称需要登记在一个全局表格里
接下来 在C++里你们可能听说过脆弱的ivar问题 抱歉
脆弱的基类问题
在ObjC里不存在该问题因为我们做的其中一种修复就是
动态改变所有ivar的偏移值在加载时
接下来 在ObjC里 可以定义类别
就是改变另一个类中的方法
有时候 它们在那些位于另一dylib且在图像范围外的类里
此时 那些方法修复必须已经完成
最后 ObjC基于选择器是唯一的
所以我们需要唯一选择器
现在我们完成了所有的DATA修复
现在我们可以进行所有
可以静态描述的DATA修复
现在是进行动态DATA修复的时机
在C++里 有一个初始化器
可以指定 等于你想要的任何表达式
该抽象表达式 此时需要运行
此时开始运行
所以C++编译器生成
初始化器来完成那些抽象DATA的初始化
在ObjC 有一种方法叫+load方法
现在+load方法已经被否决不建议使用
建议使用+initialize
若有+load方法 此时它开始运行
现在我有了这张大图
顶端是主可执行文件所有的dylibs依照这张大图
必须要运行初始化器
按什么顺序运行呢？我们选择从下往上
原因在于
当初始化器运行时可能会调用一些dylib
你需要确保那些dylib已经准备好被调用
所以从下开始运行初始化器
一直往上到应用类
可以很安全地调用依赖的内容
但所有初始化器完成时
我们实际已经最终调用的主Dylib程序
理论部分熬过来了
你们现在都是了解进程如何启动的专家了
知道dyld是一个帮助程序
它加载所有的依赖库
修复所有DATA页面
运行初始化器 跳转到主函数
那么该如何把这些理论应用到实际中？
我把该主题交给Louis
他将会为你们讲解非常实用的技巧
谢谢你 Nick
我们都曾有过这样的经验把手机从口袋里拿出来
按下主屏幕按钮
轻轻点击想要运行的应用
点击 点击 再点击
不断点击 因为它停止响应了
当这种情况发生时 非常令人沮丧
我想把这个应用删了
我叫Louis Gerbarg研究Dyld
今天 我们讲讨论如何让应用立即启动
可以让用户满意
首先 我们来讨论
在这部分演讲中 要涉及的内容
我们将会讨论启动速度要多快
用户体验才足够良好
如何测量启动时间 因为会很难测量
标准的测量应用的方法
在代码运行前无法使用
我们将一起看一张列表代码的常见原因...
抱歉 我们将一起看一张列表
表上列有应用启动慢的常见原因
最后 我们将讨论一种解决所有缓慢问题的方法
我将先剧透一部分演讲后面的内容
少做点事
我不是说应用应该减少功能
我是指你的应用在运行前应该减少操作
我们想让你搞清楚如何推迟一些启动行为
从而只在启动前一点点时间进行初始化
让我们讨论目标 想要多快启动
不同平台上的启动时间也有所不同
但是 一个好的经验法则是
400毫秒是一个不错的启动时间
原因在于
在手机上有启动动画显示给用户一种持续感
在主屏幕和应用之间
当你看着它在运行时
这些动画占用时间 并且动画
会给你一个机会隐藏启动时间
显然 根据情况会有所不同
应用扩展程序也是应用启动的一部分
它们启动的时间不同
手机 电视和手表是不同的设备
但是400毫秒是一个好目标
启动时间永远不要超过20秒
如果超过20秒 OS会终止应用
以为它进入了死循环
我们都曾有过这样的经验
点击一个应用 回到了主屏幕
它不响应 就这么消失了
这就是它被终止了
最后 在最慢的支持设备上进行测试这很重要
这些计时器都是常量值
在我们平台支持的所有设备上
如果在iPhone 6S上你达到400毫秒
现在测试的结果 也许刚好达到
很有可能在iPhone 5上达不到
我们回忆一下Nick的演讲中提到的
启动时需做什么要解析图像映射图像
重设基址图像绑定图像
启动图像初始化器 调用主函数
如果听上去很多操作 没错我说说就觉得很累
而再之后
还必须调用UIApplicationMain()在ObjC应用里可找到这个函数
或在Swift语言写的应用里进行隐式处理
还有一些操作
包括运行框架初始化器
以及加载nibs
最终 在应用委托里收到回调
我之所以提最后这两个操作是因为它们都计算在
我之前说的那400毫秒的时间里
但本次演讲中我们不讨论它们
如果你想更好地了解它们
在2012年有一个演讲iOS应用性能响应
我强力推荐你们找出来看看
但是现在我们就不再提了
我们继续
还有一点 热启动和冷启动
启动应用时 分热启动和冷启动
热启动是指
启动时应用已经在内存里
或者因为已经启动过 之前退出了
但还在内核的磁盘缓存里
或者因为你刚把它复制过去
冷启动是指启动时应用不在磁盘缓存里
测量冷启动时间通常更为重要
冷启动时间更为重要的原因是
当用户重启手机后启动应用
或很长时间后启动应用
这时非常需要一个快速启动
为了测量冷启动时间必须在每次测量之间重启设备
说了这么多如果你正致力于加快热启动时间
冷启动时间应该也会随之加快
你可以通过快速开发周期加快热启动
但是请时不时地测试一下冷启动
在主函数启动之前该如何测量时间？
dyld里有内置的测量系统
可以通过设置环境变量访问
DYLD_PRINT_STATISTICS
安装OSes时候就可用了
它打印了很多内部调试信息
并没有什么用
它缺少了某些你可能想知道的信息
今天我们就来改进
在新的OS里进步显著
它会为你提供更为相关的信息
应该会提供可操作的方法加快启动时间
将会在seed 2可用
对此我还想讲一点
加载每一个dylib调试程序都必须暂停启动
才能解析应用的符号
加载断点
通过USB线 将非常费时
但是dyld清楚这一点它把调试时间
从注册时间里减出去
所以不用为此担心
但是你会注意到它因为dyld会显示
比你从墙上钟表中所观察到的数字精细得多
这是预期的和能够接受的
如果你看到了那个数字 一切都是对的
我只想让你们记下这一点
我们继续
在Xcode里设置环境变量
只需打开方案编辑器 如此填写
完成后会有一个新的控制台日志输出
控制台输出被记录
看上去是什么样？
这就是输出看上去的样子
底部的时间条代表它不同的部分
再添加一个内容
为那400毫秒的目标添加一个指示器
在这个应用上并没有达到
如果看顺序 这就是基本步骤的顺序
如Nick讲的启动应用的顺序
我们按照顺序来看
加载dylib
关于加载dylib
还有看到的速度缓慢 需特别了解的是嵌入式dylib 会非常昂贵
所以Nick说 平均每个应用包含100到400个dylib
但是OS dylibs很快因为构建OS时
我们预计算了大量dylib数据
但是我们开发OS时做不到每个应用里的每个dylib
我们无法预计算你要嵌入应用的dylib
所以加载时必须要经过一个慢得多的过程
其解决方案是 少用dylib
而这将非常困难
不是说完全不能用
但是 有很多方法可以合并已有dylib
可以使用静态存档把dylib用这种方法链接到应用
还可以使用延迟加载也就是使用dlopen()函数
dlopen()会带来细微的性能和正确性的问题
实际之后会带来更多的工作量但现在被延迟了
所以 这是个可行的选项
但是必须要仔细思考清楚
如果可能的话 我会反对这么做
这里有一个应用 有26个dylib
加载它们需要240毫秒
如果我把这些dylib合并成两个dylib
那只需要20毫秒就可以加载
所以这些dylib都在还可以使用它们
在应用和扩展程序间共享功能
但是 限制dylib数量将非常有用
我理解这是一个权衡
在开发舒适度
和面向用户的启动时间这两者中做选择
因为dylib越多你就可以越早开始生成
和重链接应用 开发周期就会越短
所以理所当然应该用它们
但是试试用有限的数量这个目标不错
我会大概建议 用半打应该不错
现在我们修复好了dylib数目
继续看看下一个速度缓慢的地方
绑定和重设基址要350毫秒的时间
如Nick所说的
重设基址由于I/O会更慢一些
而绑定会计算上昂贵
但它已经完成I/O
所以I/O是为了它们它们交加在一起
时间也交加在一起
如果我们深入看一下
时间都耗在修复DATA段里的指针
所以我们必须修复少一些指针
Nick介绍了一个可以运行的工具
可以看到在DATA分区修复指针的信息 dyldinfo
还能显示正在哪些段和分区操作
你会很清楚地了解到在修复什么
比如 如果看到一个符号在ObjC分区ObjC类
很可能你有很多ObjC类
你可以做的一件事是 减少
ObjC类对象和ivars的数量
有很多编码样式都鼓励很小的类
只有一个或两个函数的
这些特殊的模式可能会导致速度逐渐变慢
当你越加越多时 更要格外小心
有100个或者1000个类不成问题
但我们见过有的应用有5000 1万 1万5 2万个类
这样将会增加700或800毫秒
的启动时间因为内核要把它们读入页面
还可以做一件事
可以试试减少使用C++虚拟函数
虚拟函数新建 我们称作 V表格
和ObjC元数据相同
因为它们都新建结构
在必须要被修复的DATA分区
它们比ObjC元数据小
但它们对于某些应用来说 作用显著
还可使用Swift structsSwift通常用的数据要少一些
带有指针做相关修复
并且 Swift更为内联
可以更好的使用codegen减少消耗
所以 转为Swift语言也是一个好方法
还有一点
要小心机器生成的代码
曾经有过这样的例子你可能描述某个结构
用DSL或一些自定义语言
然后有一个程序从中生成其他代码
而如果这些程序中有很多指针
它们将变得非常昂贵 因为生成代码时
会生成非常非常大的结构
我们看过这样的情况生成了兆量级的数据
但好处是 比较容易进行控制
因为你只需改变代码生成器
不使用指针而用别的比如偏移基址 结构
将收益良多 来看看本例中
加载时间怎么样了
我至少有1万个类 实际上有2万个
太多了都无法一次显示完整
如果减少到1万个类
启动时间也减少了
这部分的启动时间从350毫秒减少到20毫秒
现在 除了初始化器
其他都在400毫秒以内 做得很好
关于设置ObjC
Nick说过所有它做的工作
它要注册类 要处理非脆弱ivar
还要注册目录 还要让选择器变成唯一
我不想在此处多花时间
原因在于
这些问题我们都已经解决
通过之前对重设基址数据和绑定的修复
那里所做的所有减少和你想在这里做的完全相同
我们这里就坐享其成
很短的时间 8毫秒
但我们并没有特别对它进行操作
最后 来看一下初始化器
消耗时间长达10秒钟
这里我将讲得比Nick更深入一些
有两种类型的初始化器
显式初始化器 比如+load
Nick说我们建议用+initialize取代它
将导致ObjC在运行时初始化代码
当类被实例化时 而不是文件加载之后
或者在C/C++里函数可以带有一个属性
可以导致函数像初始化器一样生成代码
这是显式初始化器
我们宁愿用调用点初始化器取代
要调用它可以用dispatch_once()函数
或者跨平台代码里pthread_once()
若是C++ std::once()
所有这些函数基本上都有相同的功能
这些函数的代码
只会在第一次点击时运行 仅此一次
dispatch_once在系统里很优秀
第一次执行之后
几乎等同于无操作 直接跳过
所以我强烈建议不要使用显式初始化器
接下来是隐式初始化器
如Nick所描述的那样隐式初始化器
大部分来自C++的全局变量带有非默认初始化器…
非默认构造函数
你可以选择用之前提到的
调用点初始化器取代它
当然有很多地方可以把全局
换成非全局结构或指针指向想要初始化的对象
还有一个选项 你没有非默认初始化器
在C++里初始化器调用POD普通纯式数据
如果对象只是普通纯式数据
静态链接器
将会为DATA分区预计算所有数据
只把数据放在那里
不一定要运行 不一定要修复
最后一点
很难找到它们 因为它们是隐性的
但是编译器会收到警告——Wglobal-constructors
如果这么做 会有警告
只要产生其中一个
所以把它添加到编译器用的标志里是个好方法
还有一个选项即用Swift重新编写
理由是
Swift有全局变量并且会被初始化
它们确保在使用前被初始化
但是其方法不是用初始化器
在后台使用一次dispatch_once()
使用了一种调用点初始化器
所以转为Swift语言将会做到这一点
所以这个选项我强烈建议
最后
在初始化器里请不要调用dlopen()
它将带来巨大的性能问题 原因很多
dyld在运行时 是在应用启动之前
我们可以做一下诸如关闭锁定的操作
因为是单线程
当dlopen()出现在那种情况下
初始化器的运行发生了改变
可能会有多线程 必须要打开锁定
将会带来巨大的性能下降
还会带来细微的死锁和未定义行为
还有 不要在初始化器上开始线程
也是出于同样的理由
若必要可以设立一个mutex
优先mutex甚至会有
预定义的静态值你可以用run no code设定
但是实际上在初始化器里开始线程
会带来潜在巨大的性能和正确性问题
这里有一些代码
有一个C++类有一个非默认初始化器
网络连接出现问题
请稍后再试
谢谢你 Siri
我有一个非默认初始化器
调试时还有 可能我注释掉了
好 已经缩短到50毫秒
总共
有足够的时间可以初始化nibs
还有其他的操作 状态不错
我们已经浏览完毕
我们一起来讨论 我们应该了解什么
如果启动时间冗长
首先用DYLD_PRINT_STATISTICS测量时间
添加到检测性能的测试工具里
所以你可以追踪应用是如何超时的
这样可投入编写而不会在几个月后发现
调试出现问题
为了缩短启动时间 可以采用的方法有
减少已有dylib的数量
减少已有ObjC类的数量
以及删除静态初始化器
还有可用更多Swift语言加快速度
因为Swift真的很强大
最后 不鼓励使用dlopen()
它会带来细微的性能问题 很难诊断
可以通过屏幕上的URL获取更多信息
本周还将有很多相关演讲
再说一次 2012年有一个关于应用性能的会话
涉及到应用启动的另一部分
如果感兴趣 强力推荐观看该演讲
感谢各位的到来希望你们这周过得愉快