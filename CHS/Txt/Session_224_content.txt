iMessage应用和贴图 第二部分互动信息
下午好
欢迎来到“iMessage应用和贴图 第二部分”
我叫Alex今天协助我的是Stephen
他将负责演示
在演讲的第一部分 Bhaskar
和Lily介绍了贴图 贴图包
和简单的iMessage应用
专注于为信息提供贴图数据
今天我们将要来讲解互动信息
我们将更深入分析iMessage应用
及Messages框架
什么是互动信息？
在我背后的信息文本里可以看见高亮显示的一条
这是Messages扩展提供的一种特殊类型的信息泡泡框
可以看见它在截屏里被高亮显示
Messages扩展可以让用户新建互动信息
并可以把它们插入输入框如这里所示
还可以让用户回复一条互动信息
只需点击文本里的该互动信息即可
此时扩展将会全屏显示 如这里所示
用户可以和该扩展进行互动编写一个答复
然后扩展可以把新内容插入信息中
它会显示在输入框 用户可以发送
我们现在欢迎Stephen上台
他将在模拟器上演示一个应用实例
我将演示一个完整的iMessage应用
是我编写的
其中所有的API都会在今天的演讲中学到
如果看向模拟器这里可以看到一个图标
来自我的iMessage应用叫“冰淇凌”
点击它iMessage应用将开始运行
在Message范围里
所有粉色背景的UI
都是扩展提供的
iMessage应用是一个合作的冰淇凌贴纸制作应用
可在此看到我过去做好的冰淇凌贴纸
点击“添加”按钮
iMessage应用将会全屏显示
这里会提供良好的制作贴纸用户体验
选择一个冰淇凌蛋卷iMessage应用会退出
显示一条互动信息到输入框供用户发送
在iOS 10 我们添加了支持
让用户自己编写和测试iMessage应用
就在模拟器里面
回到对话列表
可以看到模拟对话的两个终端
点击第二个 显示接受信息的模拟器
点击 iMessage应用运行进入
冰淇淋制作过程的下一步
我选择自己最爱的口味 薄荷脆皮
显示该信息 发送
现在 如果回到第一个对话
或者第一个对话的最后
点击该信息
选择冰淇淋的最后一个部分 撒料
发送
现在我有了一个制作完整的冰淇凌
事实上 若回到iMessage应用
可以在冰淇淋历史清单中看到
作为一个贴图 可以应用到任何地方
这就是互动信息的一个简单例子
请Alex回来继续讲
谢谢你 Stephen
这是关于iMessage应用部分功能的一个很棒的快速演示
我们来讲讲如何用API实现
我将讲解四点
首先 我将会概括浏览API
然后第二点稍微讲解一下扩展生命周期
第三点 我们将会讲解
如何用API编写信息
第四点
稍微讲讲信息是如何被发送的
首先概括浏览API
iMessage应用正在运行
以简洁显示模式 这是一个扩展
扩展有一个主类
对于iMessage应用来说这将是
MSMessagesAppViewController的一个子类
总而言之
MSMessagesAppViewController是
UIViewController的一个子类 为扩展提供UI
在扩展上面 有一个对话
更确切地说 是对话文本
它通过MSConversation对象表示在API中
最后是信息本身
在文本里有这个泡泡框
通过MSMessage类表示
可以看到在本幻灯片中 还有两个类
MSSession类和MSMessageTemplateLayout类
它们为如何发送信息提供相关控制
以及信息该如何在文本里显示
继续讲解iMessage扩展生命周期
在这里有一个时间线如果一个扩展启动
可能从应用抽屉里 将会启动一个进程
此后不久 调用didBecomeActive(with conversation)
传入一个对话对象
代表应用运行时的对话
因为这是UIViewController的子类
我们也调用了viewWillAppear和viewDidAppear
当扩展出现在屏幕上时
如果应用从屏幕消失 会发生什么呢？
我们把它称为“退出活跃”
将会发生的事是 首先会收到viewWillDisappear
和在主类的viewDidDisappear调用
然后将会 抱歉
然后将会调用willResignActive(with conversation)
此时 我们马上就要切断
Messages和扩展的连接
此时是可以进行对话操作的最后时间
之后某个时间点 进程会被终止
强调一下 这是因为进程
建立在扩展上 而扩展是短暂的进程
它们会迅速终止
来看一下
现在有一个进程在运行在信息中显示UI
用户将会和该UI进行互动
编写一个信息 看看API如何处理
首先创建一个MSMessage对象
为该对象设置一些属性
在本例中设置一个Https URL
所以信息有一个URL属性
然后编写一些关于冰淇淋的细节
在该URL的查询字符串中
唯一可以产生
这些信息的平台是iOS
但这些信息将要发送给macOS和watchOS
当信息发送给macOS时
它们会在对话文本里全保真显示
点击文本中的一个信息
将会试图在浏览器中打开该URL
所以如果在这里提供了一个https URL
浏览器将会为用户
在macOS上显示该信息
继续 这里还有一个accessibilityLabel属性
屏幕阅读器读取文本时将会使用
所以 为它设置一个信息泡泡框的描述
用屏幕阅读器的用户会看到
关于泡泡框丰富的描述 显示在文本中
最后我们来讲布局
后面会多讲一些相关细节
我们用布局对象指定
文本中一条信息的外观
现在只有一个布局MSMessageTemplateLayout
可以为它设置一些属性将会影响制作泡泡框
这里有一个图形属性 取一幅UI图片
为屏幕上高亮显示区提供内容
还有一个mediaFileURL属性
mediaFileURL和image一样的区域提供内容
但在这里可以提供UI图片不支持的内容
比如可提供一个指向本地视频文件的URL
一个短视频就会循环播放
在文本里信息泡泡框的背景中
让我们再多关注一下这两个属性
首先注意到如果图片和URL都被提供
图片的优先级将会高于URL
我们对尺寸有一些建议
这些属性提供的资产的尺寸
我们建议为资产提供的尺寸
大约是300x300pt
可以提供稍大或稍小的资产
我强烈建议在这里多多测试资产大小
为了找到最适合应用的尺寸
所有这些资产和贴图一样都三倍显示
iMessages将会对这些图片进行缩放
当别的设备接收时显示合适大小
根据接收设备屏幕分辨率
mediaFileURL支持格式有PNG JPEG GIF和视频文件
视频文件是指 支持任何
可在Media Player框架里播放的视频
建议参考Media Player框架文档
获取更详细信息
关于该媒体文件还要做一点
当发送时 我们会对资产进行转码
这是为了对其在网络中传送进行优化
最后我建议在该图片中不要加入文字
我说过 这些图片都会按比例缩小
显示在屏幕为1倍或2倍的设备上
但我们要求按照3倍提供
如果在该图片上添加文字尤其是字体小的文字
当这些图片缩小时 文字将看不清楚
但是注意到我们在例子里确实这样做了
图片上方有一些文字
我们来讲解如何在不降低质量的条件下实现这点
布局对图片有一些额外的属性
都是文本属性
它们在信息里被转换
然后在接收设备上绘制
这样就可以把文本在接收设备上
尽可能显示得非常清晰
这里显示了图片标题
这是画在图片上方的文字
在左下角
我们还有副标题 也是画在图片上的
就在图片标题下面
还有这些字幕属性
都是在图片标题下方的标题栏绘制
就是屏幕上的灰色区域
所以 有了字幕 跟踪字幕
第二字幕 跟踪第二字幕
如果来看字幕属性
有可能忽略所有
或都设置为空
如果这么做了
就会有一个底部没有字幕栏的泡泡框
就会看上去这个样子
最后要说明的一点
泡泡框左上角有一个图标
该图表是Messages在内容上方提供和绘制的
通常都会是iMessage应用图标
就是发送信息的应用的图标
我们继续讲解
如何发送编写的信息
为了实现这点 需要一个MSConversation的实例
可以通过主类的activeConversation
有了一个对话后调用insert(message)
传入编写完成的信息
确保处理好任何返回错误
这样做可以让信息显示在输入框
当然 如演讲第一部分所提到的
也可以发送其它类型的数据
我们支持发送文本 附件
当然还有贴图
当输入框的内容完成
用户可以通过点击蓝色的“发送”按钮发送
这里我要说明 扩展没有办法
真正自动发送一条信息
我们总是想让用户来决定
把什么样的信息发送给朋友
现在我把讲台交还给Stephen
他将讲解该如何在示例项目中实现
再次感谢 Alex
我把之前用的示例iMessage应用拿出来
然后把它剥离到最基本的结构开始
冰淇淋贴图之前制作的
历史列表都还在
但你会发现点击“添加”按钮时没有反应
在Xcode里
显示了MSMessagesAppViewController子类
我覆盖了周期方法didBecomeActive(with conversation)
调用super 然后调用presentChildViewController
它是我写的一个帮助方法
将会初始化一个IceCreamHistoryController
并加入ChildViewController
这就是目前的代码
我现在想要做的是
当点击“添加”按钮时
就会开始制作贴图的进程
该IceCreamHistoryViewController有一个委托协议
我有一个MessagesViewController扩展
将符合该委托协议
通过调用historyViewController
AddButtonTapped
在这里我将要触发功能
还要添加一个帮助方法
叫作composeMessage(for iceCream)将会接受一个IceCream对象参数
然后返回到一个MSMessage可以用于对话中
要实现这一点 新建一个URLComponents实例
再把该URLComponents的QueryItems属性设置为
模块的queryItems属性
下一步是
新建一个MSMessageTemplateLayout实例
并把该布局的image属性设置为模块的渲染模式
我还想为信息设置字幕
我会在上面这里声明
现在我准备好新建MSMessage对象
声明一个MSMessage实例
把URL属性设置为我的components的URL属性
然后设置布局和accessibilityLabel属性
为了演示简单 我重新使用了messageCaption
作为accessibilityLabel属性
现在信息已经建立完成要发送到对话中
我要引用activeConversation
然后调用conversation.insert
把信息插入 写好了
已写好composeMessage函数
这里我要调用它
通过HistoryViewControllerAddButtonTapped方法
我总会从添加或传递一个新的IceCream实例开始
现在在iOS模拟器中运行
启动iMessage应用
等待调试器载入 点击加号按钮
信息显示给用户可以发送
因为我并没有真正选择冰淇凌的部分
我只是有一个冰淇淋的图片框
可以看到信息下面的字幕
开头开得不错
但是我想离开始时的那个演示更近一步
当我点击加号按钮时
我想马上进入贴图制作UI体验
为了实现 需要介绍一个新概念
在这里iMessage应用正显示为简洁显示风格
我可以选择让iMessage应用
显示为展开显示风格 通过添加代码
在这里不再调用composeMessage(for:iceCream())
而是在父类上调用
requestPresentationStyle方法参数为枚举expanded
这将触发一个生命周期回调方法 叫作
willTransition(to presentationStyle)
调入super实现
然后调用帮助方法
为该显示风格显示其正确的子视图控制器
现在我的presentChildViewController
总是显示当前的IceCreamHistoryViewController
所以我需要改变显示风格改变的逻辑
这样才可以显示正确的视图控制器
首先要添加一个参数 这样我才知道
正在处理哪个显示风格
然后我要把这段代码改为
只显示historyViewController
当处于简洁显示风格时
如果正处于展开显示风格
将声明一个新的IceCream实例
让我的controller成为IceCreamBuilderController的一个实例
传入刚刚声明的iceCream
最后 在我把它添加为子视图控制器以前
需要移除所有之前的子视图控制器
清理视图层次结构
现在我需要更新帮助方法的调用地点
这里我将把正在等待的显示风格传递给方法
在didBecomeActive(with conversation)方法中
为它传递当前的显示风格
可以把它作为父视图控制器的一个属性
应该没错
最后——事实上让我们
先看看这样能不能实现
点击加号按钮
我的iMessage应用进入展开状态
正在显示冰淇淋制作体验
然而 你会发现点击“选择”什么都没发生
这是因为我的iceCreambuilderviewcontroller
也有一个委托协议 也有一个扩展
在这里的视图控制器上抱歉有点太快了
该委托协议
通过iceCreamBuilderViewController方法实现
didSelect iceCreamPart,for iceCream
只要点击选择按钮 该方法就会被调用
这里正好可以调用我写的帮助方法
composeMessage我将传递
更新过的iceCream给它
我还要做的一件事是调用dismiss方法
因为iMessage应用已经完成内容准备
我想要iMessage应用退出
为用户显示完成消息
启动应用 点击加号按钮
选中一个冰淇凌蛋卷
退出iMessage应用
互动消息准确地显示 用户可以发送
这就是如何发送互动信息
的一个快速演示
交回给Alex
谢谢你 Alex 非常棒
所以
Stephen为大家介绍和演示了如何使用API
添加内容到一个对话并发送
Stephen还介绍了显示风格
我们将进一步讲解其更多细节
我们有两种显示风格 简洁和展开
左边是简洁风格 右边是展开风格
这两种风格之间有一些不同
在简洁模式 无法访问键盘
而且也
无法横向滚动 以及无法辨识滑动手势
这是因为在简洁模式用户可以向左或向右滑动
在iMessage应用之间快速切换
然而 还是可以访问输入框
不论何时在简洁显示风格里调用插入信息
信息都会马上插入到输入框里
用户可以立即看到
后续调用插入信息
将会用新的信息取代当前信息
这里你可以允许用户反复编写信息
看到它在输入框里的进展
直到满意后 就可以发送
与此相对的 在展开显示风格里
显然无法访问输入框
但却可以访问横向滑动手势辨识和滚动
也可以使用键盘
用户随时可以在扩展中进行转换
在两种风格间转换 只需点击上方的图标从展开转换到折叠
从而转换到简洁风格
在简洁风格下可以点击屏幕下方的图标
把应用展开成展开显示风格
当在使用iMessage应用时响应需要非常及时
在应用显示的的区域
任何时候转换发生时
都会出现主类的回调
转换开始后 将会调用willTransition(to:presentationStyle)
最后 当转换结束时
将会调用didTransition(to:presentationStyle)
如Stephen所演示的你可以要求显示风格为展开
或简洁 只需调用requestPresentationStyle方法
在主类中
如演示里所提到的可以调用dismiss
iMessage应用将退出并显示键盘
我们继续讨论如何回复信息
这里介绍两种情况
一种情况是扩展处于非活动状态
文本里有一个用户点击的泡泡框
我们首先来看这种情况
之后回来看第二种
再看看时间线 应该看上去很熟悉
用户点击泡泡框
进程启动
经过完全相同的步骤
和应用从应用抽屉启动的过程一样
将会调用didBecomeActive(with conversation)
然后是viewWillAppear和viewDidAppear
这些步骤完成后
应用将会显示成展开显示风格
我们总以展开显示风格展示应用
当用户点击一个按钮启动 抱歉
是点击文本里的泡泡框来启动
现在来看第二种情况扩展已经处于活跃
本例中 正处于简洁显示风格
再看一次时间线
这次 点击泡泡框 应用处于活跃
所以 不会调用willBecomeActive或者didBecomeActive
将会调用willTransition
(to presentationStyle)方法
然后调用didSelect方法带有message和conversation参数
在主类上进行调用
让你知道用户点击了文本里的泡泡框
并选中一条信息
最后当展开显示风格转换完成
将会调用didTransition(to presentationStyle)
在两个时间线的最后
应用的UI显示展开显示风格
而你想访问被点击的信息
实现方法是用MSConversation的selectedMessage属性
可以从当前活跃的对话中获得
在主类上
你会想要把选中的信息显示在UI上
并允许用户编写回复
再次请Stephen上台
他将做最后一个演示如何在示例应用中实现回复
好的 刚才离开时正有一个准备发的信息
我会把它发出去
回到对话表
打开对话的另一端
可以看到收到的信息
点击该信息iMessage应用正常启动
然而 冰淇凌制作体验
并没有显示冰淇凌制作过程的下一步骤
我还没办法选择冰淇凌球
这是因为每次显示当前的视图控制器
总是传入一个新的冰淇凌模块对象
我需要做的是 找到对话中的选中信息
如果信息中存在冰淇凌模块对象就要使用
回到上面这里
到新建IceCreamBuilderController实例的地方
引用activeConversation
使用一个可失败构造器
查看对话中的信息
如果构造失败 就意味着没有进展
我就会新建一个冰淇凌模块
如果存在 则传入进展中的冰淇凌
还要确认的一件事是要传入正确的字幕文本
根据选中的冰淇凌零件
为了实现 需要传入一个新参数给方法
就是selectedIceCreamPart
这个messageCaption我要变成一个声明
为字符串类型然后使用switch方法
在selectedIceCreamPart上来选择合适的messageCaption
我还要需要更新调用该方法的地址
这里 传入新的参数
当启动iMessage应用时
点击加号按钮 发出第一条信息
回到对话表 进入对话另一端
点击接收到的信息
现在冰淇凌制作视图控制器显示正常
可以选择冰淇凌球
我可以选择薄荷脆皮
发送
再回到对话的另一端
选择撒料
这就是发送和接收互动信息的情况
以及如何合作完成一个任务
然而 可以看到在对话界面里
那些未完成的冰淇凌让对话看起来有点乱
我并不想看未完成冰淇凌
我只想看冰淇凌成品
我想折叠所有之前的信息
也许可以留下那些信息的简明总结
为了实现 我将使用一个新的对象MSSession
把信息合到一组
这里当编写信息时
移动activeConversation引用
当声明session对象时
查看selectedMessage是否存在于会话中
如果是 则选择该信息将会在同个分组中继续
否则 新建一个MSSession对象
然后把该session传入这里
到MSMessage构造器
另一件事是
当信息折叠时提供一个很好的信息总结
这里声明一个变量叫summaryText
这里我会选择显示不同的summaryText
根据不同的selectedIceCreamPart
我可以把summaryText变量传给MSMessage对象
好了
哦 可能需要指定
这下完成了
现在启动iMessage应用
进行制作冰淇淋的过程
冰淇凌看上去不错吧
选择冰淇凌口味
可以看到折叠起来的摘要文本
当发送信息时可以看到
如果我回到对话的第一部分
再次点击信息
现在我觉得巧克力撒料不错
发送后 冰淇凌信息完整了
但是只显示了一张图片
整个文本中都有很好的摘要说明
并且 当进入冰淇凌应用之后
可以看到全新完成的冰淇凌贴图
可以任我所用
完成了 这就是完整的示例应用
这个例子展示了如何编写
一个互动贴图制作应用
但是可以用这种方法做任何事
可以集合各种优质服务
编写优秀的合作游戏我迫不及待想看看你们的成果
交回给Alex
谢谢你 Stephen另一个非常棒的演示
Stephen实现了回复
并引入了新的对象MSSession
来看一下MSSession
之前在演示里看到的
是含有很多未完成冰淇凌的乱糟糟的文本
我们看到如何用MSSession
把它进程处理 变成
像这样的 更为干净整洁 非常好
实现它我们用了MSSession对象
新建一个MSSession
对第一条信息
是对话的一部分 我们传入新建的会话
进入该构造器 有了这个会话信息
还可以设置摘要文本
我们利用对话的insert(message)发送
如之前所见
当回复一条会话信息时
我们不想新建一个会话而是再次使用已有的会话
我们可以获取当前会话
从当前对话中
activeConversation.selectedMessage
selectedMessage将有一个session属性
如果它是一个会话信息
然后我们取出该session属性
传入信息构造器 如之前所见
在这里summaryText提供了文本
在对话文本中对信息进行总结
现在也可以忽略该属性 把它设为空
如果这么做的话
在文本中就没有summaryText的入口
但是信息还是会参与到会话行为
我们讲解了API的基本要点
也看到该如何编写一个非常简单的iMessage应用
可以在朋友间发送互动信息
我们将继续讨论API的一些高级特性
我们将从主类上更多覆盖方法开始
然后继续讨论分组对话
最后讨论如何辨别某一特定信息的发送者
首先 当用户发送一条信息时
我们意识到也许应用想知道发生了什么
比如 若你是一个游戏 用户做出移动
我们需要知道什么时候更新模块记录这次移动
这需要在信息缺失发送出去之后发生
所以 我们有一个didStartSending(_message)方法
在主类上当用户点击发送按钮时会被调用
这点很重要
并不意味着
信息已经真正被发送
只是意味着用户点击了发送按钮
然后它传递了发送消息的企图
同样我们还有一个方法叫做didCancelSending
发生在当用户点击十字
在信息泡泡框的右上角
didCancelSending可以清除
任何编写该信息时 累积的的资源
最后 我们还有didReceive(_message)方法
didReceive(_message)方法发生在
被调用 当应用正在运行或处于活跃
一条信息来自一个接收者
对话的某一个参与者
这非常有用 比如
如果应用有
如果用户正在编辑一条会话信息
在同一个会话中另一条信息进来
这是状态更新 你需要更新显示该状态的UI
让我们继续讲解分组对话
iMessage应用可应用到分组对话中
当建立分组对话时需要考虑这些问题
我们在这里
有一个示例对话 来自三个朋友Amber Ben和Chris
Ben给每个人发送了冰淇凌
然后他发送了一个问题给Amber和Chris
你们想要在冰淇凌上面加什么撒料
巧克力酱还是彩粉？
Amber将要回复巧克力酱
Chris将要回复彩粉
这两个用户将在完全相同的时间回复
现在关注一下Ben
看看他的设备对收到的信息会做何种处理
首先 Amber的回复先到达Ben的设备
不久以后 就是来自Chris的回复
你可以发现Amber的回复变成了摘要信息
Chris的回复显示在对话最后的泡泡框里
另一种情况也是如此
需要注意的是
只有点击的信息在iMessage应用里可用
所以例子里我们无法访问Amber的回复
这该如何处理？
现在 我们建议把状态储存在云端
也就是说MSMessage的
来自和发给对话参与者的URL属性
只需要作出表示会话的标记
然后你会接收到会话当前状态
当用户点击一条信息
以及当用户发送一条信息时
你应该把当前会话状态存入云端
继续 我们讨论发送者标识符
回到Amber Ben和Chris的对话
在这个情境Amber回复了想要巧克力酱
Chris还没有回复
再次关注Ben的设备
这里有一条信息 但不知道是谁发的
但是我们可以找出相关信息
这里有发送者参与者标识符
抱歉 重说一遍
这里有参与者标识符
Apple对用户隐私非常非常重视
我们非常尊重客户的隐私
我们完全不对iMessage应用显示任何联系人信息
取而代之我们提供了这些参与者标识符
在Ben的设备上他有一个本地参与者标识符
这是一个UUID在该设备上代表Ben
他还有两个远程参与者标识符
代表了对话中的其余参与者
本例中 有两个Amber和Chris
看一下进来的信息
我们看见该信息有一个发送者标识符
它将映射一个Ben的列表中的本地参与者标识符
回到大图来看Amber和Chris的设备
正在发送的信息有发送者标识符
它们映射到每一个发送信息的设备本地标识符
可以利用这些标识符
获取对话中参与者的数量
可以把信息归属于一个发送者所以一旦接收了某条信息
带有特定的发送者标识符
然后接收了第二条有着相同标识符的信息
你知道它们都来自同一个用户
还可以和网络服务相结合
可以用于帮助确定身份
还有一点
可以在这些标识符或标识符字符串
前面加上一个$符号 写在任何传递给
MessageTemplateLayout文本属性的文本中
同样 你还可以把这些标识符写入
要传递给summaryText属性的文本中
当信息显示UI
在泡泡框里的文本带有这种类型格式时
它将会把标识符替换为
其标识符映射的联系人姓名
每一个设备的标识符都是唯一的
若你留意之前的幻灯片里
每台设备的每个人的标识符都是不同的
它们的范围局限在iMessage应用的安装里
这指的是
这些标识符本身将在一定时间内保持恒定
但若用户删除了iMessage应用之后重装
就会有一个完全不同的
标识符集合 在同样的对话里
你可以取得发送者参与者标识符
在MSMessage使用senderParticipantIdentifier属性
还可以通过对话取得本地参与者标识符
利用localParticipantIdentifier属性
还可以取得远程参与者标识符列表
从remoteParticipantIdentifier属性
这就是我们要讲的API的高级主题
再讲一下支持平台
互动型信息将会在这些平台上提供
watchOS 3、 macOSSierra和iOS 10
在这些平台中 只有iOS 10会真正产生信息
在macOS Sierra用户可以点击对话文本中的泡泡框
传递给信息URL属性的URL
将会在Safari里打开
只有https或http URL才行
在watch上 可以把互动信息传给
可以写回复的设备
我们也支持旧平台备用
这些消息也可以在watchOS 2、 iOS 10
iOS 9和OS 10.11上发送
但是会以备用格式发送
有两条分开的信息
第一条是模版布局提供的图片
第二条是信息提供的URL
再次强调 如果是https URL将会发送
如果是数据URL 则不会发送
我们在备用消息中只发送https或http URL
这就是本次演讲的全部内容
总结一下
本周我们介绍了Messages框架iMessage应用
在本演讲的第一部分Bhaskar和Lily为我们介绍了
贴图集 并演示了
如何编写可以建立贴图内容的iMessage应用
今天 我们一起编写了发送互动内容的iMessage应用
还讲了如何在分组对话中实现等
我十分期待看到你们大家
走出去利用该API所做的成绩
迫不及待想看到大家的产品 就这样
其它详细信息可以浏览本次演讲的网页
在developer.apple.com
我们还有一个相关演讲
如果你还没有看过“iMessage应用和贴图 第一部分”
请到网站上观看
演讲到此结束
感谢Stephen的演示
谢谢你们大家的到来