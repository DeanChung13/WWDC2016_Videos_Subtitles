Xcode源代码编辑器的使用和扩展
大家好
欢迎来到“Xcode源代码编辑器的使用与扩展”
我是Mike 是Xcode工程师
我是你们和beer bash之间的必经之路
那我们今天要讲的是什么呢？
嗯我们马上开始
我将给大家展示XCode 8中一些新增的很棒的功能
但这还不是全部
我还会给大家展示一些非常有帮助的功能
这些都已经集成在今天正运行的Xcode中
你可能对这些并不了解
但是我觉得它们非常酷
我每天都用它们来快速编辑和操控Xcode的源代码库
需要说明的是我这里给大家展示的所有东西
在Xcode中的都是标准集成的
然后我的同事Chris会到台上来
教大家如何拓展我们所提供的东西
并教大家如何进一步扩展Xcode源代码编辑器
你可以编写扩展程序
让编辑器做一些你经常要它做的事情
然后你甚至还可以分享这些扩展程序
给你的朋友同事甚至全世界
在源代码编辑器中你将会注意到的第一个东西
或者你只要在今天会场上抬头环视一下就会看到
我们新的源代码字体SF mono
这是mono space对系统字体San Francisco的致敬
我们的字体专家特意设计了适合显示屏retina的SF mono字体
还精心设计了
程序代码符的各种符号字体
即便在很小的尺寸上都清晰可辨
大家将注意到的下一个是
看我正在编辑器中来回移动的地方
就是我们对当前编辑行会进行高亮显示
这样一目了然很快就可以定位当前编辑的地方
每个内置的Xcode主题都有精细的
人工配置的高亮颜色但也可自定义
所以你可以按自己喜好将它改得尽量醒目
或者如果你不喜欢这样的也可将它设置为完全透明
你可能已经熟悉我们的注释和取消注释的命令
也就是“/”命令对吧？
对了我们增加了一个新的命令
你可以点击选项键并使用“/”命令把它调出来
这样就插入
一个资料注释
因此
这可以直接用于任何类函数 类 结构体或它们之上
你也知道这些东西是一种结构性的码位元素
此外
大家还会注意到此处这些小占位符
众所周知这些用来描述你的类函数
或讨论参数
throws描述或者大家都知道的
描述一些有关返回值的重要内容
真正有价值的是这些片段性的资料
你在代码中添加的会在快速帮助中出现
还会在代码完成窗口的底部出现
还有请注意我们提供了
新的SF mono字体
提供了更多选择而不仅局限于常规和加粗
资料注释使用SF mono细体
而关键字使用SF mono中等
只是更亮更粗一点
相对于文件中其它内容都使用的SF mono常规字体
不同于大多数其它mono space字体
我们给SF mono配置了完整的磅数表
从细体到半粗体再到黑体
我们还引入了斜体差异配置项
这可以保持每个字符之间的间距
即便是对需要强调的内容进行精准自定义也可胜任
下面讲下一功能我将展示如何跳转到另一个文件
我通过按下Command及Shift O实现快速打开
并输入几个字符转到我的TimerViewController
大家可能之前见过这个
这是文档条目菜单
通过按Control 6就可以打开这个菜单
它拥有所有的类、结构体、枚举、属性
该文件中所有的东西
但这并不是最有趣的部分
你知道吗当这个菜单弹出只要你一开始输入
它就会对项目进行过滤？
然后你就会注意到此处
这个小小的“待修正”注释
实际上就有个小的创可贴图标在上面
我觉得这很可爱
接下来...
转到这儿进入my load view 类函数
在这儿你可以看到每个图片都有一种颜色
我们一直在等设计师为我们提供
其实我昨晚才弄了这些P&amp;G's
我把它们放进jogger资源目录
这样我们就能真正
在下面的库里看到它们
这个用于Timer Button
接下来我要从这儿选择当前行的末尾
通过按下Control E并同时按住Shift键
我将按下CommandSpace调用代码完成
现在仔细看
我要使用代码完成窗口直接分配这张图片
我只需要输入t b就可以获取我的Timer Button
你还会注意到和Xcode 7.3一样的代码完成窗口
现在用了相同的模糊匹配算法
与快速打开、文档条目菜单
甚至在资料窗口的新搜索所用算法一样
在左边你还可以看到图片的预览
这样你就能知道所选择的是否正确
接下来...
在源代码中就在这儿Boom
这是图文并茂的
因此库里的的每一张图片
不管是来自资源目录
还是仅仅作为项目的参考
现在都可以从代码完成窗口中看到
在源代码编辑器中
接下来让这生效的方式就是插入一个Swift特定实体
在源代码中这对Swift编译器是已知的
而且它解除了对指定UIImage图像的调用
这样你就可以看到所有图片都放置有序而不仅仅是名称字符串
且对颜色也进行了同样处理
接下来我要从这儿选择当前行的末尾
并调用代码完成和类型颜色
当我在此处敲击Return会发生什么呢
大家会注意到我把非常整洁的颜色选取器调出来了
从这儿我只需用向下的方向键
选择一种颜色就像这样就可以选择优雅的绿色
需要知道很重要的一点是所有这些图像和彩色文字
都是全键盘导航的
若我在某个文本上按住Shift和回退箭头并点击Return
就会把颜色选取器再次调出来
而且你知道我还是可以用方向键选择
但是如果这些弹出来的颜色不是你正要找的
大家看如果这刚好不是我正要找的
你可以使用最近的颜色
这也是和InterfaceBuilder共享的
或者你可以点击这儿下面的其他按钮
它会调出标准的系统颜色面板
在这种情况中我其实只是想取样这种非常优雅的海军蓝就从这个按钮
因为在我构建它时这就和该按钮是绑定的
但我们此处还是有点小错误
此处的颜色文本是UIColor
但我们将其指定的层是cgLayer所以应该需要cgColor
所以我可以很快解决这个问题就像这样
希望这样已经讲清楚了图像和颜色文本
实际上都是完整分类和检查的在Swift中是实的对象
我下面想要给大家演示的
其实并不是一个新功能它甚至不是Xcode的功能
它实际上属于标准的CocoaText系统的一部分
从macOS 10.0之前就这样
这就是查找粘贴板
大家可能之前没有注意过
如果你进行了查找可能通过选择一些文本
比如说此处Pause 然后使用Command C将其复制到粘贴板
再使用Command F调出查找框
然后通过Command V将它粘贴其中
相同的搜索过程也会出现在其他应用程序中
这很奇怪不是吗？
嗯
这是因为查找粘贴板是...
它其实是跨应用程序工作的就像众所周知的剪贴板
它与剪贴板是并存的而且两者可以同时存在
所以实际上就有一个非常酷的技巧如果你有一些东西
想要保留在剪贴板中而不被清除
但是如果你仍然想要搜索
比如从这儿开始搜索
你只需要按下Command E
就会把它直接推送到查找粘贴板中
然后这样就可以让你点击Command G
并循环遍历该文件中所有匹配的内容
现在如果你只是想在同一文件中快速查找和替换
我们也提供一条专门的命令
如果你按住Command Control E
实际就会对整个范围内的全部内容执行编辑
这样就修改了本文件中所有该符号的实例
所以这里我可以给这个类函数加上ED
因为started听起来更好一点
而且...
这种方法可以大大节约时间我自己就经常使用它
现在如果你想要做的是移动大约几行
你也不需要剪贴板来完成
实际上我们提供了一条专门的命令来完成这个
若此处选择几行并按住CommandOption Bracket
你会注意到我其实可以移动整个区块
在if函数和其它类函数的里面或外面移动
它们只是在你的代码里整体挪动
这确实很棒
如果你每次只在同一文件中操作
但若你想在其它文件中进行交叉查找
例如若我想找出所有的timer实例
你可以通过按住Command F和Shift完成
实现在整个项目内查找
这里我就...
把timer加入到我的查找粘贴板中进行搜索的
这实际上是我最近才被告知的一个特性
我不需要点击进入查找导航框其实就可以开始
通过上下键选择这些结果
此处Command G也可以实现
唯一不同的是我仅按住了Control键
同时按下了Command G
这样就可以遍历所有的结果
在所有不同的文件内遍历
包括InterfaceBuilder文档
以及其中所有的实例和匹配记录
通过按住Shift可逆向实施
与Command G效果一样
所以我不知道我知道有些人其实
把这些记下来
但是你真的不需要记因为在Xcode中其实就有个地方
提供了所有这些命令的完整列表
及其相应的按键
这就在Xcode参数设置窗口中
在这儿在按键绑定设置窗格中
你其实可以进行搜索
搜索任何涉及到的东西
你可以查看所有的结果
还有如果你含糊地重新调用
可能会有某种显示命令
你可以按下Command J
这实际上也就是搜索键盘快捷键
这确实很强大
如果你不喜欢我们为Xcode所有内置命令而设置的键盘快捷键
你可以从此处自行设置
此外……
如果我们的内置命令不够
且/或者刚好无法完成
你经常希望代码编辑器做的事情
我想邀请Chris上台
教大家如何添加自定义的命令Chris
谢谢你Mike
如Mike所说我是Chris今天我要向大家展示
如何通过源代码编辑器扩展Xcode
现在向大家展示如何向源代码编辑器添加个人命令
使之成为编辑器菜单的一部分
你的命令可以修改用户的文本
以及该文本内的选项
说到运行导航
与一些其他类型的应用程序扩展不同
你可以将任何数量的命令作为Xcode源代码编辑器的扩展来实现
我们将Xcode扩展建立在应用程序扩展的基础上
这是我们所有操作系统扩展性的基础
既然Xcode拓展即是应用程序拓展
各个run函数即在各自进程中并能执行所有在该进程内接受的命令
且不会对Xcode或其他扩展造成干扰
当然作为应用程序扩展Xcode扩展也是沙箱型的
并通过各种权限来完成脱离该沙箱所需做的事
Xcode只能访问Xcode扩展
以及在运行时所需的文本与元数据
以此来执行相关操作
它们无法访问项目结构
以及磁盘上的用户文件
为什么我们要这样设计呢？
当然...
为了稳定性
我们希望确保Xcode能尽量稳定
对我们所有的用户
以及安全性考虑
应用程序扩展是我们提供给大家来
增强操作系统及我们现有工具的方式
并同时能保持整个系统的完整性
当然还有运行速度方面的考虑
应用程序扩展是建立在Mach信息与XPC之上的
并且是完全异步的
因此它们能快速运行且不会降低用户的速度
还有另一个原因
我们决定将应用程序扩展
作为Xcode扩展的基础
这是为了将它们放到Mac APP Store内
就像所有其他应用程序扩展一样
Xcode扩展被嵌入到了一个主应用程序中
该主应用程序是一个理想的载体
来搭载你的扩展偏好或配置信息
例如为了控制
用户实际希望从你的拓展中能够使用的命令
并且这也是一个搭载其他任何
你希望该拓展所提供的UI理想载体
因为Xcode所能做的是提供有关
你的各命令的菜单项
成为了应用程序便能进而实现应用程序扩展
便能在Mac App Store上找到Xcode扩展
当然你还可以登录你的应用程序和你的Xcode扩展
通过你的developer ID并对其按照你的意愿进行分配
现在我们来谈谈关于
Xcode是如何激活你的扩展的
为保证最佳性能
Xcode会查找你的扩展并自动将其启动
在Xcode启动过程的早期
XCODE扩展生命周期
在你的用户使用扩展之前
源代码编辑器扩展并不像一些其他类的应用程序扩展
只能使用一次之后便不能使用了
实际上Xcode会尽可能将你的扩展
维持为可用状态
因此它可以发送任何用户想要调用的命令
现在当你的扩展启动时
如果它需要即刻进行任何工作
Xcode将向它发送extensionDidFinishLaunching
对于启动来说只要够快那就是一个好的地方
没错 你需要尽可能地让启动过程够快
这样一来你的用户就能
随时使用该扩展
为了帮你实现这一目标
Xcode将保证你的扩展与
其他扩展的启动是异步进行的
且与Xcode的启动也是异步的
现在当你的扩展启动时
Xcode会询问它的指令
指令可以来自两个地方中的一个
通过默认函数可以得到一个项
info.plist文件中的NSExtensionAttributes字典类中
该文件指定了你的扩展中的所有指令
不过你还可以提供
关于你的扩展类中的commandDefinitions的属性重写
重写info.plist文件返回值
因此 若你的扩展拥有指令动态列表
其中有描述因为下载了新的JavaScript
这些JavaScript实际是用来运行那些指令的
它能提供一个新的集合
现在一旦Xcode收到你的指令
它会给每个扩展分配
扩展所对应的编辑器菜单的子菜单在用户编辑源代码时
并按字母顺序列出扩展名
就像在finder中一样
所以对用户而言它们都在稳定的地方中
从自身运行到Xcode运行
然而因为指令的顺序通常很重要
而且通常传递大量语义
Xcode将保留你所发出指令的顺序
并将该顺序在菜单中排列出来
现在来谈谈指令调用
当然 用户可以从你的菜单项中选择指令
也可以通过个人设置的快捷键来实现
你的指令对象将被实例化并发送调用指令和回调指令
调用指令打包所有
这些命令执行所需的数据和元数据
当工作完成 指令将使用回调程序
来告诉Xcode 工作完成
让我们看看实际的API
我们有个简单的协议
你所有的命令类都需要符合它
如我所说它已进行了一次调用和completionHandler回调
并且该调用仅携带一些简单的数据
且具有一个commandIdentifier
该commandIdentifier在info.plist文件内或命令定义数组内进行设置的
而且这能使你区分多个
受控于同一命令类的命令
毕竟其中涉及很多命令特别是对于编辑源代码而言
而它们之间的区别却很小
大家可能希望通过同一个命令类来执行多个任务
并仅处理各任务中的若干不同特定实例
该标识可让大家找出
用户调用的命令
我们还提供了一个属性
你可将cancellationHandler设置为“开启”
若用户取消了你的命令 那么cancellationHandler即被调用
并且如果你的指令花费时间过长它也会被调用
我们将会在演示部分对其进行略微深入的讲解
最后当然调用过程也包含
有关用户使用的文本缓存
该Source Text由
另一个目标实例一XCSourceTextBuffer来表示
除文本之外　还有许多元数据
我们给大家一个统一的类型标识
让Xcode认为文本包含的文件是对应的
如此大家就可以使用Swift源代码
XML数据ObjC++ 头文件等各种文本格式进行编写
我们还为该文件提供了Xcode的缩进设置
所以当你在文件内对文本进行变更时
你依然遵循用户期望Xcode做的事
当它缩进该文件时
因为tabWidthindentationWidth
及是否使用TabsForIndentation间存在微妙的相互作用关系
为此我们还提供了大量有关它们如何协同工作的详细信息
大家可在头文件查阅该信息
因此我鼓励大家找出该头文件
并确切了解它们是如何相互协同的
现在我们提供用户通过两种不同方式正在使用的文本
如果你需要将该文本处理为单数据流
即通过管道将其输送到一个命令行工具
你大概会希望使用
completeBuffer
该缓存代表用户正在使用的文本
代表作为单一字符串的整个文件
然而如果你仅需要对文本进行微小变更
那该方法的效率会很低因为你的扩展需将
所有的缓存发回Xcode
因为我们为之提供了可变数组属性
其中包含文件中的文本行
我们发现当采用源代码编写工具时
实际上采用行与列抽象化要远优于
仅使用单一而庞大的文本缓冲区
并且通过成为可变数组
还可以让Xcode实际追踪你进行的变更
所以我们只需要发回个别你所进行的更改
不需要发回整个缓存
这确实能提高编辑扩展的性能
除了提供文件中的文本行
我们还为文件中的选项提供了可变数组
总会有至少一个选项
要么是用户的插入点要么是选项
因为Xcode编辑器是构建在Cocoa Text系统之上的
所以我们同样支持多重选项
如果你想要改变选项
你要做的就是改变该可变数组
且该数组中存在的都是SourceTextRange对象
调用SourceTextRange替换NSRange
因为我们真的相信
我们提供的行与列抽象
对于大多数文本编辑来说是最好的方法
这就是为什么源区域能替代一个位置和一段长度
成为实际起点与终点的原因
那些位置都在行抽象与列抽象中得到表示
我将向大家演示如何创建
个人Xcode扩展
我先到演示机这边
然后...
我把笔记本放在这儿
给我留下深刻印象的是刚才Mike关于
Swift文本 Swift色彩和图像文字的描述
我真的很想在我自己的代码中使用它们
因此我觉得我该
创建一个新的源编辑器扩展
它可以自动将任何UIImage或UIColor的使用方法转变为
相应的Swift文字
我只需创建一个新的Xcode项目
以及一个新的OS X应用程序
毕竟我的应用扩展
和Xcode扩展都得在应用程序内部执行
然后创建这个并把它命名为Chris文字
然后赋予一个叫做com.example的组织标识符
点击“下一步”然后我把它放在桌面上
现在我已经创建了我的项目
我要向其添加一个新的目标
且添加一个OS X应用程序扩展目标
你可以看到
新的Xcode源代码编辑器扩展模板就在该列表的末尾
然后我把它命名为...
Chris Convert to Literals...
搞定
当我点击Finish时
Xcode就会提出供激活目标的建议
就像其他应用扩展一样
然后点击接受
现在让我们来看看Xcode为我生成的代码
在这个转换为文字的组别里
Xcode添加了一个类这个类表示我的扩展本身
这只符合XCSourceEditor扩展协议
并且它还为类函数和属性添加了模板
如果我想重写的话我可以对其取消注释
并提供自己的实现
但现在我还不想这么做
我认为没必要让它来执行这个特定的项目
我们来看下一个文件
在下一个文件SourceEditorCommand中
有我的第一个命令类
正如我向你们展示的那样它符合XCSourceEditor命令
并且仅在vocation类函数控制下单独执行
现在让我们看一看Xcode创建的info.plist文件
你可以看到在我的扩展属性中
Xcode添加一组XCSourceEditorCommandDefinitions
这是一个字典数组
该字典为命令指定了需要实例化的类
要使用的标识符
以及命令应具备的菜单项名称
我把它的名称改为ConverttoSwiftLiterals
然后接受
将镜头缩小 返回到命令界面
现在我要作个小弊因为代码已经写好了
我使用代码片段把已经写好的代码嵌进去了
我把这称为Chris Demon大家可以看到实际上代码并不是很多
所以我只需循环文件中所有的行
如果该行中存在一个UIColor或UIImage调用
我仅使用对应的Swift字面语法去替代它
然后如果行已经改变了
那我就得替换行数组中的行了
我并不是替换数组中的每一个行
我当然不是修改整个缓存区
我只修改实际需要修改的行
而且我还对修改的行保持追踪
因此之后我还可以构造
一组选择来表示那些行
我设置了那些选项
之后仅需调用我的完成处理程序
让Xcode知道我的命令已完成
我在建议的程序列表中见到了Xcode
如果我点击运行大家认为会发生什么
当然除了建立我的扩展程序之外
你可以看到
我们为大家开发了另一个Xcode实例来测试大家的扩展程序
我们实际还提供一点视觉差别
我们在dock里将图标变得更黑
并且对“欢迎来到Xcode”窗口内的图标也加黑
清晰明了
你会清楚地知道这个Xcode正在对一个扩展进行测试
我现打开Mike的Jogger项目
因为我注意到有些UIImage和UIColor
还没有转换
大家可以另外看到一种情况
我们在活动视图的顶部对UI进行修改
以此来特别说明
Xcode正在测试一个扩展
Mike给我留下了一些真正想要的UIImage和UIColor实例
我认为作为字符会更好看
所以我查看一下编辑菜单
看到了Chris Convertto Literals扩展
还看到了Convert toSwift Literals命令
现在如果我返回我最初的Xcode
然后设置一个断点在这下面
如果我现在实际运行我的命令...
你会发现什么也没有
因为在断点处就停止了命令
在第一个Xcode调试程序中
所以你其实可以把Xcode调试器
和需承载的LLDB的所有资源都用于调试你的扩展程序
我继续演示
我们把这里的断点删除
如果返回就可以看到
Xcode对所有我改变的行都进行了强调正如我告诉它的一样
以上便是所有关于使用新Swift字符格式进行转换的内容
现在来谈谈我实际希望在非常常规的环境下进行的操作
这很容易　我可以很快完成
只需对我的新命令添加一个密钥绑定
在Key Bindings界面下的Xcode偏好选择中进行操作
搜索我的命令名称我记得是以Chris开头
这就是Xcode的Key Binding
我把它命名为commandoption control/
便于记住是吧？
现在我们来看幻灯片
来说说...
一些我很关心的事
当使用Xcode扩展时你会感受其速度之快
那是因为文本编辑是用户同步进行的
用户们只想把他们的手放在键盘上
不停地操作
即使调用你的扩展
你的扩展也不应该阻止
用户操作的连续性
现在为了防止
在你的扩展和用户之间发生竞态条件 Xcode会锁定那些
用户工作时产生的文件变化
在用户调用扩展时
幸运的是大家不必担心
如何协调大家所造成的改变以及来自用户的改变
从另一方面讲这意味着...
如果你的扩展时间过长我们认为几秒钟就算过长
从用户锁定到开始编辑文件这段时间
那么...
我们该怎么办？
我们允许用户取消该命令
我们会提供一个取消指令的按键标示
我想系统正在尝试告诉我
这张幻灯片在这的时间太长了
我们来关掉它然后继续
Xcode能为我们的用户保证快速操作
通过早早地启动扩展并尽可能长时间地
使其保持激活状态
所以一旦调用它们就能发送命令
正如我们前面讨论过的通过使用行数组
来确保各位的扩展数据传输在性能方面得到优化
当用户需要取消一个命令
可以点击Xcode界面的取消符号
当用户点击取消
他们可以继续操作
现在...你的扩展任会接收
取消命令并仍然需要对它做出反应
但是用户不关心这点
当然有几个方法
你的扩展也可以对Xcode的运行有所帮助
你的扩展可以尽可能快地启动
你的扩展得为用户
执行你的命令做好准备
你可以在我们所有的异步编程模式下使用GCD
以确保你最大可能利用用户的系统
并尽可能快地返回Xcode
当然...
如果没必要你可以避免更换所有的文本缓存
最后就像我说的你需要快速处理取消指令
因为在你的指令完成取消之前
它对用户而言都是不可用的
今天Mike向大家展示了许多关于
Xcode源代码编辑器的出色的新特性
比如我们能够添加文档注释
以及在Code Completion中支持Swift color和Swift image字符
还展示了一些添加的最新功能
这些功能已经添加进了Xcode7.3 比如模糊代码完成
我向大家展示了Xcode源代码编辑器扩展是如何工作的
以及如何创建它们
我已迫不及待地想看到各位通过我们的新API作出的成就
大家可以获得更多可用的信息
在我们 WWDC 16 网站页面上
还可以收看一些相关课程的视频
特别说明Optimizing AppStartup Time不适用于应用
它仅适用于应用扩展
因为它搭载了大量相同的技术
我们对Xcode的介绍也非常棒
适合于想要了解Xcode开发环境动态的人
当你实现扩展时用户们会为此充满期待
最后我们有些前些年推出的节目
讨论应用扩展意味着什么
以及实现它们的最佳方法
我们今晚也会参加这个盛会因此...
感谢光临 WWDC 大会
若有任何疑问 可以届时向我们提问