Metal的新特性 第一部分
各位早上好
谢谢
我叫Aaftab Munshi
我和我的同事十分激动地
与大家分享Metal的新特性
macOS Sierra和iOS 10中
不过开始我先着重说说今年我们关于Metal的演讲
在 WWDC
昨天我们有两场演讲谈论了将Metal采用到
你的应用程序中
今天我们有三场演讲
所以这一场 外加两场演讲覆盖了Metal的新特性
之后还有另一场演讲其中我们会讲
Metal着色器优化
那么我们...
看看我们将要讲的功能
在第二场演讲中我们要谈的功能是
函数或着色器特殊化以及写入资源的能力
例如来自片段和顶点着色器的缓冲和纹理
广色域 在你的应用程序中使用广色域显示 以及纹理资源
还有在Metal性能着色器上添加的一些新内容
具体是通过Metal在GPU上使用辅助卷积神经网络
本次演讲中
我们将谈谈
我们在工具上加入的一些改进
我们认为大家一定会喜欢的
我们也让资源堆和资源分配更加快速
给你更多的控制
我们将谈谈那个资源堆和无记忆渲染目标
然后我将谈谈曲面细分
所以开始吧
好了 首先
我们花一点时间去理解
为什么需要曲面细分
我们看到应用程序例如游戏
渲染越来越多的逼真视觉内容
所以这意味着为了渲染那么多内容
我们需要能将精细的几何图形发送给GPU
我们要将输入发送过去
这意味着需要处理非常多的三角形
这会极大增加存储带宽
一件非常好的事是
如果我们能将这个发送给GPU的
几何图形只描述成一个低分辨率的模型
名为Core Smash
然后让GPU生成高分辨率的模型
事实上 这就是曲面细分的功能
曲面细分这种技术你可以用它来放大并细化
几何对象的细节
我们必须要符合两个重要的要求
第一个是那个生成的高分辨率
三角形模型不能存储在显存中
我们不想占用带宽
第二 所使用的方法需要是可编程的
所以我们来看一个例子
这是GFXBench 4.0的截图
是一款由Kishonti发布的测试程序
其注重的一个关键功能就是曲面细分
这张截图是没有使用曲面细分而渲染出的汽车
你看看那些轮圈
多边形很明显你不会开种车的
对吧？
就连车身板件上都有裂纹
因为这就是实际发送过去的几何图形
你能看到 没有很多三角形
这很好--正是我们想要的
曲面细分的功能是将那个输入的几何图形
变成这个样子
我认为这十分炫酷
如果你看看线框图你可以看到是GPU负责生成
现在我们渲染出非常多的三角形 是吧？
这就是曲面细分的威力
好了 我们来看看曲面细分如何在Metal中工作的
所以就像Metal那样
我们想采用全新的设计方法
我们想设计出--
即使现在有支持曲面细分的API
你可能很熟悉
我们想要的是易于表达的东西
易于使用
而且我们不想保留任何性能
我们认为我们做到了希望你也会认同
在这次展示之后
曲面细分在macOS Sierra和iOS上可以使用
搭载A9处理器
好了 我想谈论的是
用于曲面细分的Metal图形管线是什么样的？
如何使用曲面细分渲染我的几何图形？
以及如何将它应用到我的应用程序中？
所以开始吧
现在 当你用Metal将基元发送给GPU
你发送的是三角形线条或者是点
有了曲面细分 你发送的东西我们称其为面片
简单来说面片就是参数曲面
是由样条曲线构成但这意味着什么？
你可能听过Bezier面片或B样条面片之类的东西
你通过一组控制点来描述面片
所以这个图中你看到的是B样条面片
所以你有16个控制点或者是控制顶点
曲面细分的作用是简单来说 允许你控制
使用多少个三角形来渲染这个面片
所以你会决定“我不想要很多的三角形”
“我不在乎它什么样”
所以你可以决定四个三角形就足够了
然后你会得到多边形的外观
或你决定 “我真的想让它看起来精致又平滑”
这会需要更多的三角形不过这是由你控制
所以我们开始
当我们做曲面细分时图形管线中的第一阶段
我们称之为曲面细分内核
它的作用是将面片
我们讲了带有控制点的面片 作为输入
并决定“我需要将它细分成多少？”
“我想让GPU生成多少个三角形” 对吧？
这种信息是在曲面细分因子中捕捉到的
我会在几个幻灯片之后稍微谈谈这些因子
你还可以生成额外面片数据
如果在随后阶段中需要的话
关键的是这是一个可编程阶段
意味着你要写代码
一旦你写完了生成了曲面细分因子
下一阶段叫做镶嵌器
这是一个固定函数阶段所以没有代码可写
不过你确实会得到配置它的旋钮
所以它使用那些曲面细分因子然后将面片分解成三角形
镶嵌器在这里的关键作用是它不将
生成的三角形列表存储在显存中
除了其生成的三角形列表之外
对于三角形列表中的每个顶点它会生成我们所称的
参数坐标 U和V值
它将这个和控制点一起使用
来计算在表面上的实际位置
镶嵌器会生成三角形
今天在Metal中当你想渲染基元时
你将三角形发送给GPU
首先会发生什么？执行顶点着色器
在这里是镶嵌器生成三角形 所以...
如果你逻辑思考一下下一阶段就会是顶点着色器
确实如此
我们将其称为后曲面细分顶点着色器
因为它在由镶嵌器生成的三角形上运行
所以它会在三角形的顶点上执行
三角形由镶嵌器生成的
然后会输出变换位置
如果你熟悉DirectX这个着色器所扮演的角色
和DirectX中的域着色器相似
好了 之后剩下的管线都是一样的
我们有光栅器和片段着色器
你可能会问 “所以我需要写这个计算内核
来生成曲面细分因子吗？”
“我能使用顶点或片段着色器吗？”
你当然可以
事实上 你根本不需要编写着色器来生成这些因子
你可能预先计算好它们了
你就能将它们加载到缓冲中然后将其传给镶嵌器
所以你有很多控制
不过如果你在GPU中生成这些因子
我们建议你使用计算内核
因为你知道吗？
这会允许我们将那个内核和其他绘制指令异步运行
所以让你提高性能我认为你们会喜欢的
让我们更进一步
你不需要每一帧都运行这个内核
因为你知道吗？
如果你已经计算了曲面细分因子--
假如你决定
“离镜头更近的物体会有更多的曲面细分”
“更远的物体就没那么多”
一旦计算完了 之后根据物体的运动方式
我可以应用一个刻度然后镶嵌器会接受它
所以管线真的十分简单我们有四个阶段
我们拿它和没有曲面细分的图形管线相比
没有曲面细分的话我们有三个阶段--
顶点着色器 光栅器和片段着色器阶段
有曲面细分的话我们添加了新的阶段 镶嵌器
这是固定函数 所以你不需要写任何着色器
然后顶点着色器成为了后曲面细分顶点着色器
我们认为这很容易理解
希望你们会认同
好了 如何用曲面细分来渲染我的几何图形？
这里我要讲四点
我们先看看后曲面细分
或后曲面细分顶点着色器
这与普通的顶点着色器有何不同？
如何传递我的面片输入
我跟你说过镶嵌器是可以配置的
我们来看看如何配置之后绘制面片
看看这就是新的着色器跟旧的着色器一样
事实上 你声明后曲面细分顶点着色器
要使用顶点限定符
除此之外你还要指定这个属性
写着“这是作用于面片的”
这里有两种面片--四边形和三角形面片
你看到它边上的数字了吗？
那个数字就是告诉你那个面片作用于多少个控制点
如果你有普通的顶点着色器你会传递
一个顶点ID输入
现在你将patchID作为输入传递
还记得我告诉你镶嵌器生成参数UV坐标吗？
那就这个position_in_patch输入
之后 如果你有普通顶点着色器
你要将其作为stage_in传递
我们在stage_in传递的面片输入
其他东西你就进行计算
然后就生成变换的顶点输出
这实际上会完全相同
因为下一阶段 无论有没有曲面细分 都是光栅器
好了 我们看看面片输入
如果你有普通顶点着色器你会在着色器中将顶点输入
描述为结构体
如果你将数据类型解耦合了 这意味着
布局和产生顶点输入的缓冲
无法匹配着色器中的声明
之后你要使用MTLVertexDescriptor
来描述布局
这里有两种面片输入一种是每面片输入
还记得我告诉你的这里有一个或以上的控制点吗？
所以我们也需要将它们指定为输入
不过你指定它们的方法看起来一样
你用MTLVertexDescriptor将面片输入数据的
布局在内存中指定
我之前展示过这个幻灯片我们还将输入作为stage_in声明
你使用属性索引在着色器中将元素识别为输入
通过MTLVertexDescriptor中相应的声明
因为会有不止一个控制点
基本上 我们要使用模板类型来对其声明
我会在下一个幻灯片上讲的
我们来看一个例子
这里我有我的控制点数据上面有两个元素
我使用0和1属性
每面片数据是2和3属性
我们将这两个组合一起
这是每个面片的面片输入
注意那个控制模板类型patch_control_point
这就在告诉Metal的着色编译器
“这是引用控制点输入”
还记得我告诉你的这个数字16吗？数字多少无所谓
这也在告诉Metal着色编译器这里有多少个控制点
现在我们有了为获取面片输入所需的所有信息
所以我们将它作为stage_in传递
非常简单
我认为
好了
我如何配置旋钮呢？
这里有属性
你可以设置在MTLRenderPipelineDescriptor中
几个例子是你可以告诉镶嵌器
你想用的三角形生成方法
叫做分区模式
你还可以指定最高曲面细分等级
我们认为这是非常有用的
因为这允许你控制所生成的几何图形最大量
由GPU为曲面细分物体生成
记住镶嵌器需要读取这些因子
所以你需要指定产生它们的缓冲
所以使用setTessellationFactorBuffer API
来完成
这些因子会说明沿着边缘将这些面片细分成什么程度
还有在内部
所以我们有两种面片
如果是三角形面片会有三个边和一个内部
如果是四边形那就会有四个边和两个内部
所以你将它们指定为半精度浮点值
传递进去
然后是绘制
现在 当你绘制基元时
你发送的三角形由GPU渲染
你要么调用drawPrimitives或者drawIndexPrimitives
你指定起始顶点顶点数量
如果你的顶点索引不是连续的你就传递一个索引缓冲
要想绘制面片你就调用drawPatches
或者drawIndexedPatches
你指定起始面片面片数量
如果你的控制点索引不是连续的你就指定一个索引缓冲
所以这是一对一映射
然后这里有DrawIndirect变体
它们的功能是你不指定出
哪个是起始面片以及面片数量
以及当你进行绘制调用时的其他信息
相反 你传递一个缓冲
这些信息会填写在其上面
通过一个在GPU上运行的指令 就像你在
drawPrimitives上做得那样
如果你不知道如何使用drawPrimitives
drawPatches的效果非常相似
所以我们认为这非常易于使用
好了
稍等
我给你展示了什么是Metal曲面细分
以及使用方法
在座很多人可能熟悉
或者已经在你的应用程序中使用了曲面细分 通过DirectX
或者OpenGL
你会注意到Metal曲面细分有点不同
别担心
我们设计的Metal曲面细分可以极其直截了当地
将你现有的曲面细分代码转移到Metal上
例如 在过去几周里我们与Unity合作
在极短的时间里他们能够
将Metal曲面细分整合到他们的引擎中
他们是这样评价的
我们非常激动地宣布对Metal曲面细分
Metal Compute和在Unity中编写原生Metal着色器的功能支持
将于今年晚些时候推出这十分令人激动
而且我们也与Epic合作来有效地将
Metal曲面细分整合到Unreal Engine 4中
而且Epic计划将于今年晚些时候发布对UE4的支持
所以我们有UE4 我们有Unity支持Metal曲面细分
让我给你展示曲面细分在这些游戏引擎中的实际效果
通过演示两种常用的渲染技术
叫做适配曲面细分和置换贴图
好了
我们有一个简单的演示...
由几位Apple工程师开发的
使用Unreal Engine 4
我们已经关上曲面细分然后看看线框图模式
你能看到没有很多的三角形发送给GPU
非常好这正是我们想要的
我们要将发送给GPU的几何图形量维持得越少越好
我们启用曲面细分看看会发生什么
你能看到现在GPU生成了非常多的三角形
适配曲面细分这种技术允许你控制
重要地方的几何细节
在这个例子中
我们决定离镜头更近的物体需要更多的细节
所以绘制上更多的三角形
相反 远处的物体则不会
蓝色的区域代表着曲面细分量最少的区域
然后红色的区域代表着
曲面细分量最大的区域
我可以展示随着我将滑动器向右滑动
我可以用它来增加曲面细分级别
你能看到更近的物体变成了红色
好了 我们将线框图关掉
如果你跑动随着我们通过这个洞穴
你可以看到这里有更多的细节 对吧？
如果我将曲面细分关掉所有的细节都没了 丢失了
打开曲面细分看起来非常惊艳
所以这个例子演示了如何使用曲面细分
在我的应用程序中构建丰富的视觉场景
我想感谢那些在Epic的能人他们让这一切成为现实
所以下一个演示...
是置换贴图...
在Unity上运行
这里我们渲染出一个球体
我们看看用了多少个三角形来渲染这个球体
不多 对吧？
大概有3000个三角形
置换贴图指的是一种技术
允许你置换几何图形来创建惊人的细节
其做法是使用一个置换贴图 是一种纹理
所以你从纹理查找从这个纹理
之后用它将顶点位置偏移
或者如果你想的话你可以按顺序地做
不过置换贴图需要
你要绘制数量众多的
非常小的三角形
否则不会有效它创建一个工件 只是裂纹
不过这没问题的
我们可使用曲面细分它是专门做这个的
因为我们还想要将3000个三角形
更小的三角形发送给GPU然后用曲面细分来生成它
我们将线框图模式关掉
我们启用置换贴图
如你所见 现在球体上的细节非常惊人
如果我将线框图模式打开
你可以看到我们生成了非常多的三角形 而且都非常小
实际上 我们看看这个置换贴图的动画效果
你能看到形状变化我们放大来看看细节
你可以看到自阴影的出现
自阴影在这里出现的原因是
因为我们在改变几何图形
与在座很多人可能熟悉的凹凸贴图技术不同
那只是创建虚假的现实
所以这是另一种技术你可以用上曲面细分
在所渲染的应用程序中创建出惊人的细节
还有 非常感谢Unity提供这个演示
演示曲面细分实际效果
好了 所以...
Metal曲面细分还可以用于加速数字内容创作工具
例如 OpenSubdiv是由Pixar发布的开源库
它会实现高性能细分表面
实际上 它集成到了多个
第三方数字内容创作工具
例如Autodesk的Maya
OpenSubdiv使用曲面细分来渲染这些细分表面
Apple在OpenSubdiv中加入了Metal曲面细分
我很激动地在这里宣布我们计划将这些变更
今夏晚些时候在OpenSubdiv开源项目上发布
这是Pixar的评价
如你所见 Pixar非常激动看到在iOS和macOS中
实现了OpenSubdiv上的原生Metal
好了 现在你可能会问“那我呢？”
“我如何将现有的曲面细分代码转移到Metal中？”
我来展示给你看
所以我们以DirectX为例不过对OpenGL的规则也是一样的
这是带有曲面细分的DirectX图形管线
我们有三个新的阶段--其中两个是可编程的
它们叫做外壳和域着色器
然后我们在中间有镶嵌器
那我如何将它转移到Metal中？
注意域着色器的位置正好在镶嵌器的后面
这让你想起其他我在Metal管线中展示的着色器吗？
“我想是吧”
没错 后曲面细分顶点着色器不过你知道吗？
曲面细分的域着色器就会成为新的顶点着色器
就像你可很容易将HLSL或GLSL顶点函数移动至Metal中
你可以非常容易地将这些域着色器移动到
后曲面细分顶点着色器
镶嵌器是完全相同的没有改变
所以就是这个东西这两个着色器
顶点和外壳着色器
我们要将它们放入内核中
那么我们看看如何去做
我们看看一些因为我们已经有了顶点着色器
这意味着这里可能有顶点描述符在运行时
由应用程序所描述
因为数据可能会解耦合
这意味着我要声明stage_in但我无法在内核中stage_in
对吧？不过现在可以了
我们添加了支持
所以就像在顶点着色器中你使用stage_in来说
“这是我的顶点输入”你可以用stage_in来说
“这是我的每线程输入”
而且你可以指定实际数据布局
在MTLStageinputOutputDescriptor中
表现相同
非常相似于MTLVertexDescriptor
有一些你指定的东西有一点不同
因为这是用于计算的而不是顶点的
然后 要观察两点
DirectX或OpenGL的曲面细分顶点着色器执行于
面片的控制点
外壳着色器有这两个函数
一个是在控制点上执行
另一个是在面片上执行
每面片外壳函数才是真正生成
你的曲面细分因子
那最好的做法是？
将所有这三个函数转化成Metal函数
然后我们写一个Metal内核来调用这些函数
不过别担心我们不会做函数调用
Metal编译器会将它们内联的
我们来看看这是怎么起作用的
基本上 每个线程会调用控制点函数 用于顶点的
和外壳的
假设这里有16个控制点所有第一个线程调用顶点
和控制点外壳函数
第二个也是一样如此类推
它们产生的任何间歇数据如果想分享的话
会放入线程组内存中
就是高性能极低延迟的本地内存
我们不会去使用显存
之后 如果有16个控制点这就会有16个线程
在上面运行
只需其中一个执行每面片外壳函数
这意味着通常会遇到栅栏之后你只会执行
其中的一个线程会执行外壳函数
你会遇到条件性检查 会说
“我的线程是在线程组ID0吗？之后调用这个”
这个函数会将曲面细分因子输出到
显存中
如果你有额外想要输出的面片数据 你可以做到
如果你真的非常想输出控制点数据 你可以做到
但我们发现在大多数情况中控制点数据只是通过
是这些现有API中图形管线的性质
需要你将它们传递过去
不过你只是让它们传递过去不要写出来
你已经在缓冲中有了
好了 让我总结一下
我希望给你展示了MetalTessellation是很简单的
而且易于使用
我们从头开始设计专注性能
我展示了将你现有的曲面细分代码应用到Metal中是很简单的
在iOS和macOS上可用
现在轮到你们了
展示出来 使用曲面细分并创建一些惊艳的画面
在你的应用程序中渲染
我想感谢大家抽出宝贵时间我将请上我的同事 James
他将谈谈关于资源堆
和无记忆渲染目标谢谢大家
好了 谢谢你 Aaftab
本次演讲的下一部分我很激动地介绍
在iOS和tvOS上可用的两项新Metal功能
资源堆和无记忆渲染目标
这些功能可以让你控制你的资源管理
从而实现更大的CPU和内存效率
我将首先介绍资源堆之后再讲无记忆渲染目标
资源堆是Metal中的一个新的较低开销资源管理选项
你早就可以在Metal中创建缓冲和纹理了
那为什么还要另一种方式？
在设备上通过现有Metal API
创建资源是既容易又方便的
而且很多开发者很赞赏这种简单
另一方面
随着Metal应用渲染越来越丰富复杂的场景
你会寻求更完善的Metal资源控制
来解锁更大的CPU和内存效率
这就是我们推出资源堆的原因
资源堆可以实现快速的资源创建和绑定
通过资源子分配
资源堆的灵活性会节省你的内存
通过允许多个资源在内存中取别名
最后 资源堆的效率和灵活性的实现是靠
你控制资源依赖性跟踪
通过使用显式指令同步
我们来深入了解这些功能
从资源子分配开始
在谈子分配的细节之前
我们首先讨论为什么基于设备的资源创建耗费巨大
创建单个资源
使用Metal设备涉及多个步骤
分配内存准备内存用于GPU
清除内存保证安全
最后创建Metal对象
每一步都需要时间而大多数时间
都花在内存操作上
不过也有这种情况当你需要创建资源
在性能关键的路径上并且不出现性能故障
纹理流就是一个例子
或者也许你有一个图像处理应用
需要生产多个临时纹理来执行一个滤镜
绑定资源的成本
对于指令编码器来说也会成为性能问题
Metal必须跟踪每个绑定到指令编码器
的独特资源来确保GPU能够访问内存
对于复制的场景这个成本也会水涨船高
资源子分配解决了这两个性能问题
记住资源创建中开销大的部分
是在内存操作中
有了资源堆你可以提前执行
内存操作在游戏循环之外
资源堆解决了绑定成本做法是允许你
从单个堆中对许多逻辑资源进行子分配
通过从一个堆中对多个资源进行子分配
Metal跟踪的是一个内存分配而不是每个资源的内存分配
这会显著降低你的驱动过载
我们给资源创建做对比
在Metal设备和新的Metal资源堆之间
当你使用设备创建资源
Metal会分配并准备一个内存块
然后创建Metal对象
对于四个资源 Metal会分配并准备四个内存块
这与MTLHeap相比
将MTLHeap用于资源创建时
你首先要提前创建堆对象
内存会按请求的大小分配并准备一个内存块
如果你在渲染循环之外提前做了这件事
资源创建中开销大的部分就完成了
要从MTLHeap中创建出四个资源
Metal只需要保留一块堆的内存
然后创建资源元数据
这会更加快速
现在来看看当我们想释放一些资源时会发生什么
当基于设备的资源释放后Metal对象就会被破坏
不过设备也会释放内存资源分配
另一方面当释放堆资源时
只有对象被破坏内存还由堆所占有
所以在设备上创建新资源
会引起另一次高开销内存分配
而堆可以快速将闲置内存再分配给另一个资源
我给你展示这有多容易
用Swift对Metal资源进行子分配
所以跟很多Metal对象一样
Metal资源堆有一个相应的描述符对象
我们创建堆描述符然后将大小设置成
支持堆的内存量
凭借堆描述符我们可以请求设备
给我们创建一个堆对象
记住 这个操作会比较慢所以要提前做
例如当应用启动时或是内容加载时间
有了这个创建出的堆我们可以调用其资源创建方法
这看起来非常眼熟因为名称和参数
与设备上的名称和参数相同
在进行下一个话题之前
我想分享一些使用资源堆进行子分配的最佳做法
最重要的一点就是使用资源堆
在性能关键的路径上创建资源
使用设备去创建资源不是专门
用于游戏循环的资源堆是专门的
分配大小不同的资源可能会导致堆内存出现碎片
如果资源有不同的生命周期
所以使用多个堆并按照大小将资源装好
来限制碎片的影响
你可以还在想如何选择合适的堆大小
Metal在Metal设备上提供了两种新的方法
来查询纹理和缓冲的大小与排列
使用这些查询来帮助你计算所需堆的大小
好了 我们来看看资源堆的下一项功能：资源别名
资源别名允许多个动态资源
占用相同的内存
因此减少了资源的总体
内存占用
动态资源的内容每一帧都是再生成的
内容包括阴影贴图G缓冲数据
或是用于后处理的临时纹理
我们这里有一个堆包含两个非别名的资源
与这个包含两个相同资源的堆相比
不过现在用了别名
你能明显看到使用别名的资源
可以放入更小的堆中
我们将资源别名应用到这个游戏帧中
阴影贴图过程会渲染一组阴影贴图
用于场景中的每个光源
所以在这里的堆中我们有多个阴影贴图
在主过程的碎片加工中
着色器会采样阴影贴图来判定
是否每个对象都在阴影中
在主过程结束后阴影贴图的内容
就会被完全消耗
它们会在下一帧中再生成
在主过程结束后我们会执行后处理链
这个可能包含多个离屏渲染过程
每个都执行特定的滤镜像是模糊或者高光
这些滤镜会将其内容存储进纹理中
来将滤镜结果传递给链中的下一个阶段
这里的要点是阴影贴图的
内容和后处理纹理
从来不是同时使用的
所以为何不共享内存呢？
我来给你展示如何用Swift创建这些别名资源集
这第一部分应该看起来眼熟
首先我们请求设备创建一个堆
然后我们创建三个阴影贴图
现在我们看到了一个新方法makeAliasable
通过在堆资源上调用makeAliasable
你告诉那个堆将资源的内存视为闲置的
阴影贴图仍在启用中但是它们的内存可以自由
被堆再分配给新的资源
现在当我们在相同的堆上创建后处理纹理时
它们可以作为阴影贴图占用相同的内存
现在我们来谈谈一些最佳做法
用于资源别名
为了实现动态资源的内存再使用最大化
调用资源创建方法
在一个帧里资源所使用的相同序列中
允许你调用makeAliasable
会允许你交错makeAliasable调用
当资源内容被消耗的时候
而且你要将动态资源和静态资源保持在分隔的堆中
静态资源一般无法进行别名而且会导致
动态资源无法互相使用别名
由于堆的内存碎片
接下来我将谈谈如何实现堆资源的
同步指令访问
目前我们讨论了凭借子分配实现的快速资源创建
以及通过资源别名实现的高效内存使用
但要记住资源堆是快速灵活的
因为你控制堆资源的同步
你在设备资源上不必这样做
但与设备资源不同Metal不知道
指令会什么时候修改堆资源的内容
例如当渲染过程将新内容存储到纹理中
Metal也不知道你何时会将堆内存的
解释从一个别名集改成另一个
不过为了正确性 Metal需要知道何时指令会更新堆资源
这样其他指令可以安全地读取结果
这尤为重要
因为GPU可以并行执行多个指令
为了实现堆资源的同步访问
你的应用程序会创建并管理GPU栅栏
来在指令之间沟通资源依赖性
我们深入看看GPU栅栏的工作原理
GPU栅栏就是时间戳
是GPU执行时间轴上的一个参考点
你可以用栅栏编码两种行动来同步指令
指令可以更新栅栏将时间戳向前移
当指令完成后
而且指令可以等待栅栏
在执行之前 等到GPU触及最新的栅栏更新
那我们回来看看之前的游戏帧
我会展示给你如何使用栅栏
来实现别名堆资源的同步指令访问
这就是示例帧这个帧有三部分
但现在我们有五个方框因为两个渲染阶段
渲染过程分成了顶点和片段处理步骤
我们有阴影过程主过程
最后是后处理过程我们会使用计算来执行
Metal指令是按顺序提交给指令队列的
所以可能目前不清楚
为什么我们需要指令间的同步
不过GPU是并行机可以并行地
执行多个指令
我们iOS和tvOS产品中的GPU可以执行顶点
片段和计算指令全部并行执行
将GPU的利用率最大化
GPU甚至可以同时执行多个帧
好了 现在你可能会发现一个问题
看看这两个突出显示的指令
它们都是在同时更新
别名堆资源
我们要使用栅栏来修复它
首先我们将栅栏带入
后处理指令更新栅栏
所以阴影指令片段处理阶段
可以等待栅栏
现在这两个指令不再同时执行了
我将展示给你如何使用Swift
给栅栏更新和栅栏等待编码
首先 我们用设备创建栅栏
这是新方法--不带参数
接下来 我们编码后处理计算编码器
在第一帧的结尾
我们首先创建computeCommandEncoder
然后编码分派
在我们结束编码器之前我们首先更新栅栏
这样后续指令可以等待直到这个指令执行完成
在下一个帧中我们会编码阴影渲染
我们创建renderCommandEncoder
在commandBufB中代表指令缓冲
用于下一帧
不过在绘制场景之前我们首先编码栅栏等待
来等待到GPU上的后处理完成
注意这一次这里有两个参数
第二个参数叫做beforeStages
渲染指令在两个阶段中执行--顶点和片段
所以Metal允许你指定特定的需要
等待栅栏的阶段
在我们的例子中只有片段阶段需要
访问堆资源所以我们指定片段阶段
最后 我们可以安全地渲染我们的阴影贴图
因为我们知道这个指令只有在
前一帧的后处理完成后才会执行
让我谈谈一些指令同步的最佳做法
你知道如果使用堆你必须使用栅栏
来同步指令访问
但你有这个控制是因为你非常清楚
你的资源是如何使用的
而且你的应用程序会有更高的CPU效率
如果使用Metal为你进行跟踪
例如只初始化一次的纹理
并且未被修改是不需要跟踪的
另一个例子
一起使用的资源可以通过单个栅栏一同跟踪
所以让我总结资源堆的主旨
凭借子分配更快速创建资源
通过资源别名更加有效使用内存预算
然后使用GPU栅栏实现GPU指令间的堆更新同步
好了 现在我想介绍另一项在iOS和tvOS上可用的新功能
无记忆渲染目标
这听起来有点魔幻
不过我会给你展示几乎所有Metal应用都能使用该功能
只通过一行代码就节省大量的内存
无记忆渲染目标这种纹理
不将任何系统内存分配给纹理内容
没有任何内存存储纹理内容
剩下的就是纹理元数据
例如纹理尺寸和内部纹理格式
很明显 这节省了大量的内存
但什么时候能用无记忆渲染目标呢？
你可以将它们用于未保存的渲染过程附件
大多数Metal应用会有一些附件与
存储不在意行动或多重采样解析有关
而且用于那些渲染过程附件的纹理可以是无记忆的
要制作无记忆渲染目标
你可以像平常创建纹理那样
使用额外存储模式标记
MTLStorageModeMemoryless
这就行了
该功能只支持iOS和tvOS因为它依靠于
A7及其之后GPU的砖墙式渲染架构
我来给你展示其工作原理
在你的右边我们有两个渲染过程附件
一个色彩附件一个深度附件
A7及其之后GPU以每次一个分块执行渲染过程
利用快速的GPU分块存储
在GPU的核心
GPU分块存储包含分块大小的
深度 模板以及色彩附件的代表
这个分块存储是完全隔离于
纹理支持和系统内存
在Metal中 你的加载和存储动作控制着
如何初始化GPU分块存储 以及是否
将GPU分块存储的结果复制回系统内存里
如果附件未从内存中加载
而且未保存在内存中
你可以使那个附件的纹理变得无记忆
来消除内存分配
接下来 我会描述一些很常见的情景
你可以将该功能应用到你的应用上
深度附件经常在3D场景中用于启用深度测试
不过A7及其之后GPU的深度测试是完全在
GPU分块存储中进行每次一个分块
深度测试不需要使用系统内存
如果你不保存深度纹理为之后过程所用
那就将纹理变得无记忆并节省下内存
我来给你展示另一个机会
当执行多重采样渲染时
A7及其之后GPU在GPU分块存储中进行所有渲染
MSAA色彩附件纹理会被使用
只有在你选择保存采样数据以备后用
不过大多数应用会选择多重采样解析存储动作
这直接源于从GPU分块存储
到解析色彩附件纹理
在那种情况下 确保多重采样色彩附件纹理是无记忆的
而且这会节省大量的内存
如你所见 采用该功能所带来的节省是显著的
通过将1080p深度纹理变成无记忆的
你的应用会省下将近8MB空间
若你在12.9英寸iPad Pro上渲染原始分辨率
深度缓存的节省会高达20MB
而且将四倍多重采样渲染目标变得
无记忆 会节省下更多4倍之多
所以使用无记忆渲染目标来最大程度使用
你的应用程序的内存预算
使用这省下的空间降低你游戏的内存占用
或更好用省下的空间
在游戏中加入更加精美独特的内容
我想邀请Jose上台告诉大家关于Metal工具上的所有改进
谢谢 James
除了Metal API上新加的出色功能
我们在Metal Developer Tool上有一些出色的改进 给大家展示
首先我们会谈谈Metal System Trace的新功能
之后介绍一项新功能叫做GPU Overrides
我们有一些非常激动人心的新功能
登录到GPU Frame Debugger
什么是Metal System Trace？
在之前的Metal演讲中我们出示了这个图表
展示了Metal在CPU和GPU上的工作情况
Metal System Trace这一套工具可以将其可视化
帮助你了解你的Metal应用程序的时间轴
通过整体图形管线从CPU
到GPU再到显示器
去年 WWDC 我们推出了iOS平台的Metal System Trace
我极力推荐去观看去年的展示
来更好地总览MetalSystem Trace
之后在秋季我们加入了tvOS支持
今天我们很高兴宣布MetalSystem Trace
登录macOS 帮助你榨干最后一滴性能
在所有Metal平台上
我们全方位地改进了MetalSystem Trace
扩展我们报告的事件
对于资源事件
我们将高开销的资源操作变得直观 例如选取数据
从系统内存到显存
这种案例中我们能看到macOS中的绘制
这导致了GPU执行延迟
Metal SystemTrace还显示调试组
这让你更容易让你了解跟踪中的指令编码关系
在macOS上 我们支持同时跟踪多个GPU
这对一些使用案例来说这难以置信
比如你在不同GPU之间分配工作
在iOS上我们现在显示定标器工作量
所以当你遇到延迟时可以进行诊断
通过旋转或缩放你的视图
你现在可以将种类更多的工具
与Metal SystemTrace一同使用
例如Time ProfilerFile Activity
Allocations 还有更多
甚至不同的视图 例如CPU数据这会展示CPU核心时间片段
这会帮助你将Metal事件与内容进行关联
深入了解
系统运行应用程序的情况
允许你诊断像是由CPU停滞引起的GPU饥饿
由于错误的I/O操作
Metal SystemTrace会捕捉大量的数据
所以我们让解释和导航变得更容易
使用新的工作量突出显示
你可以注重于任何指令编码器或编码缓冲
随着它在管线中通过
通过键盘导航支持
你可以将你的选择快速地在跟踪中移动
最后我想介绍PerformanceObservation
PerformanceObservation是给你呈现
潜在问题的完整列表这是我们在
跟踪中通过分析找到的
从显示面耗时过长
到意外着色器汇编
或者高GPU执行时间
Performance Observations替你发现你在寻找的事件
你能从PerformanceObservation列表直接导航
所有这些新功能会允许你
调整你的Metal应用程序使其如你所想的那样流畅运行
现在为了展示我们在GPU调试上做出的出色改进
让我交给我的同事 Alp
演示GPUFrame Debugger
谢谢 Jose
我今天有很多出色的功能要给大家展示
我们直接开始吧
我的应用在这里运行
漫游过美丽的地形细节由曲面细分做到了极致
在线框图中查看这个地形该多好
去查看每一个三角形
好消息是 我们最新的功能GPU Overrides
让你能够修改你的Metal渲染
直接从调试栏当应用还在运行时
我们有多个不同的覆盖你可以混搭使用
包括线框图模式
我们切换到线框图模式来看看地形的曲面细分程度
显示每个三角形
你可能想要调整曲面细分来找到
性能和视觉品质之间平衡
通常你需要回去更改你的代码重新编译 然后运行
但是有了GPU Overrides你可以
直接从Overrides菜单试验曲面细分比例
我们将比例设置到25%
现在我们有更少的三角形而且还丢失了一些有趣的细节
我们试试75%
我认为这个效果更好我们看看没有线框图的样子
可以 我喜欢这个
这比开始少了很多三角形
不过还是有全部的细节
外加提升的性能 我可以在场景中加入更多炫酷效果
如你所见 GPUOverrides这工具非常有助于
初次诊断场景中的
一些视觉和性能问题
接下来我们捕捉这一帧来给你展示一些功能
来极大提升你的调试工作流
帧捕捉已经完成
我在查看地形资源来看看地形面片的情况
在Resource Center中切换到所有GPU对象
你能看到所有的纹理和缓冲
我们这里有全部的资源
我要一个个地查看
来找地形资源会花一些时间
这就是新的筛选条发挥作用的时刻
你可以按这里的任何属性进行筛选 例如标签
类型 大小或者细节
因为我标注了所有的资源我就只按地形筛选
在这里 我有所有用于渲染地形的资源
现在我找到了地形面片缓冲
我想做的是看看它用在什么地方
通过简单的拖放我可以筛选功能导航器
给我展示所有用于地形面片缓冲的调用 就像这样
在这个案例中 我使用计算得知了它的计算位置
以及当渲染地形时它的读取位置
这个筛选十分强大
我还可以使用绑定资源的
其他任何属性来筛选绘制调用
例如 如果你按sRGB筛选
你会看到所有绘制调用使用的纹理
都是sRGB像素格式
这是很自然的方式快速地在帧上导航
接下来 我们进入绑定GPU对象
来看看我们是如何使用资源来渲染地形的
在绑定模式中你的资源归入在
不同的部分中基于使用它们的
Metal管线阶段所以你知道到哪里去找
看看顶点阶段
地形面片是一个绑定到多个绑定点的缓冲
拥有不同的偏移量
我们使用唯一的缓冲来检查数据
所有的顶点数据的布局
排列整齐 除了这是来自带有面片的Metal函数
所以这使用了与后顶点函数完全相同的结构体
我们这里有颜色数据
它识别颜色单词然后在这里显示
值的真正颜色
因为这是包含不同数据类型的大型缓冲
我用新的MTLBuffer API添加了一些调试标记
这会让你极其轻松地找到你想要的东西
通过布局菜单你可以直接跳入
其他你想检查的可用布局
查看单个缓冲是很好的
更好的是新的输入属性视图
让你看到所有的顶点数据
与顶点着色器的视角一样
输入属性从你的实例中收集所有数据
曲面细分因子缓冲和stage_in数据
之后提供给你单个视图来一同查看它们
在这个案例中我们用多个面片渲染实例
我可以看出什么数据属于实例的哪个面片
所以这简短介绍了
GPU FrameDebugger上的一些最新功能
我们切回幻灯片做个总结
演示GPUFrame Debugger
你刚才看到了一些最新的GPUFrame Debugger功能
我想再告诉大家两个
有了新Extended Validation模式GPU Frame Debugger可以
进行更加深入的应用分析
在选择最佳纹理使用上提供推荐
或者资源的存储模式
你可以从Xcode方案编辑器中启用这个模式
独立Metal LibraryProjects的新支持
让你创建Metal库在多个应用中共享
或者将多个库包含在一个应用中
就像其他任何框架或库
使用我们讲的功能
能极大提升你的工具体验
现在我们总结本次演讲中看到的内容
我们看到通过曲面细分给Metal API新增的功能
资源堆和无记忆渲染目标
之后我们展示了改进的工具
Metal System Trace和GPU Frame Debugger
一定要看看下午的第二部分
我会讲讲关于函数特殊化
和函数资源读写
广色域和纹理资源
以及Metal性能着色器的增加功能
有关更多本次演讲的信息请访问这个网络连接
你可以补看视频 并得到资料和示例代码链接
我们昨天的演讲十分精彩你可以在线观看
这个下午 我们有Metal的新功能 第二部分
之后高级Metal着色器优化就在这个演讲厅
感谢大家的到来祝各位 WWDC 过得愉快