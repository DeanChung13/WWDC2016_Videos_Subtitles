安全的新特性
下午好！
欢迎大家
感谢各位前来听安全的新特性
我叫Lucia Ballard我管理Apple的安全传输团队
与我的同事Simon一起
我们将向大家讲讲我们一直从事于的大量新内容
来帮助你为客户提升安全
所以 我希望在座的很多人之前已经听过Evone的演讲
那个演讲非常好地概述了我们这么做的原因和内容
而且是我们系统安全的根本性支柱
这里我们会深入到更多的详细信息
所以内容会有这些
首先 我们会谈谈iOS中关于网络安全的一些变更
之后我们会讨论几个对我们加密API的更新
然后Simon会谈谈macOS上的平台安全
所以 直接进入网络安全
如果你用手机像我一样频繁
你就会知道手机积累了数量惊人的信息
关于你的私人生活
而且很多是通过网络传递的
无论是你在阅读的文章或是给朋友发送的消息
所有这些点点滴滴的信息即使从单个看起来无关紧要
但累积起来 可以非常惊人地描述出这个人
所以在Apple我们有理由认为
所有这些信息都应该默认得到保护
我们认为HTTPS是新的HTTP
所以对于每个通过网络加载的资源
你应该为你的用户提供机密性和数据完整性
另一个关键点是并非每个HTTPS都是平等的
HTTPS基于SSL或按现代的说法是TLS
并非这个协议的所有版本都会提供足够的安全保护
给你的用户来抵抗攻击
所以基于这些原则
去年我们推出了App Transport Security
App Transport Security
指的是你做的所有加载使用NSURLSession
或甚至是更旧的NSURLConnection API
你需要使用最顶级牢靠的TLS连接
首先 这意味着TLS版本1.2该版本推出有一段时间了
但只有该版本能够完全抵抗
我们所知的一切漏洞像是BEAST攻击
或者POODLE攻击或其他名字可怕的漏洞攻击
这也意味着你必须使用强大的加密方法
像是AES-128或更强大的密码
以及有SHA-2签名的证书
因为有SHA-1签名的证书很容易受到攻击
最后 这还意味着正向保密
这种方法可以在服务器和客户端之间交换密钥
这会带来十分惊人的属性意味着哪怕将来那个证书...
那个服务器证书被盗取了
你无法显示出来
过去发生的任何通信内容
所以把这些都结合在一起
我们认为 你就有了一个安全的连接
可以保护客户的数据
现在 我们知道这需要一段时间来赶上
App Transport Security的步伐 所以我们还推出了特例
你可以全局关闭
或你可以为特定域名设置特例
你知道那个域名无法快速转成TLS
现在我想知道在座的有多少人在思考 “没错
我去年设置了那个特例
之后就没再考虑了”好吧 现在是重新考虑的时候了
因为今年我们会开始在
App Store上施行App Transport Security
这会在2016年底开始生效
这意味着对于大多数特例
你需要提供正当的理由
所以 对于所有这些特例
真正关闭了App Transport Security
或其关键属性像是使用TLS 1.2
你首先需要说明你要使用该特例的理由
对于其他特例像是正向保密
我们意识到对它们的支持并非完全通用
所以目前会自动授予这些特例
不需要任何理由
例如 如果你在使用一个伙伴服务器
而且你无法控制他们提供的加密套件
我们能够让你继续和那个服务器对话
我们还添加了一些新的特例来使其易于采用
例如 如果你在使用Streaming Media
而且那个媒体文件已经批量加密了
我们可以能够通过AV Foundation提供特例
让你不需连接TLS就能加载那个媒体文件
我想说清楚我们还是认为正确的做法
是将TLS用于一切上面
但有些情况下我们可以提供特例
来帮助你更顺利地过渡
我们还提供网页内容特例
这里有时候你的应用需要加载网页上的任意内容
当然 你无法保证那是使用HTTPS的
所以如果你用WKWebView
那你可以将这个密钥设置在应用的Info.plist里面
NSAllowsArbitraryLoadsinWebContentKey
之后所有的这些加载都会免去
App Transport Security要求
但你应用所做的其他事
像是和你自己的服务器对话这还是会得到保护的
所以这是App Transport Security
但我们还在整个系统上为TLS做变更
因为加密套件不断进化
与抵御攻击相比 发起攻击的能力不断变得越加高效
所以无论你的ATS设置是什么
我们现在为所有使用我们网络API的人默认禁用了RC4
我们还在Secure Transport中禁用了SSLv3
所以即使你下入到我们的底层API
你还是无法使用SSLv3
研究已经远远超越这两项技术了
我们不认为它们能为我们的用户提供有效的安全
所以被禁用了
其他的算法也开始过时了
特别的 SHA-1变得越来越容易受到攻击
3DES也是
所以 如果你知道你依赖于这些算法
现在该放弃它们了
而且我发现在场的很多人是应用开发者
而且不负责自己的后端
所以你需要联系
你公司或其他负责托管后端的那些人
来确保他们放弃
对这些老旧算法的依赖因为这些算法要被弃用了
现在非常适合你去检查加载内容的状态
使用HTTPS 并且确保你能使用App Transport Security
然后你就能快速通过应用审核了
所以这就是App Transport Security
确保一切都是用牢靠的TLS进行加载的
不过牢靠的TLS是不够的
你还需要确保你用来验证TLS连接的证书
能表示正确的服务器
所以我想谈谈几个不同的技术
我们今天使用它们来帮助你确保你是真正
连接到正确的服务器上
当你在建立这些安全通信的时候
所以首先我们回来
来稍微谈谈当今证书的工作原理
所以如果你要连接一个服务器
那个服务器一定要有一个由证书权威机构发放的证书
那个权威机构会验证主机名
然后说 “没错 挺好的你确实是example.com
这是你的密码证明”
当你连接的时候服务器会发来那个证书
但这不总是完美的机制
如果有攻击者设法得到了你主机名的证书
那他们就能提供那个证书
而客户端无法分辨出
攻击者的服务器和你自己的服务器
如果证书权威机构出错的话 这就会发生
或更糟的情况
这个证书权威机构被入侵了
有其他人使用他们的私人密钥来进行签名
所以今天我很自豪地宣布我们将加入到
证书透明度的工作中去
证书透明度是一种技术
使用了已发布证书的公开可验证日志
这些日志从各种源中收集证书
所以有很多证书权威机构参与进来
但事实上任何人都可以提交日志
之后 这些日志会发布密码证明
表明这个证书已被记录然后客户端可以检查那个证明
这里的做法有很多
证明可以嵌入到证书中
或可以在TLS握手中交出
或可以通过OCSP装订传输这一点我过会再细说
所以这是其工作原理的简单概述
首先 证书权威机构
不仅向服务器发行证书
还将证书发送到日志那里然后添加到公开日志上
之后日志会发送一个有签名的证明表明这个证书已被包括进去
然后服务器将它和原始证书一起
交给客户端
这意味着你可以一同验证这一对
所以证书透明度使发起攻击变的更加困难
基本上这让攻击者身处困境
如果攻击者可以从未参与的权威机构那里得到一个证书
他们无法得到那个密码证明
因为那个日志中包括着证书
所以他们只能交出证书然后客户端就可以拒绝
或者
如果他们使用参与的证书权威机构
那么那个被感染的证书会被记录
然后可以公开查看这就让你有机会
在证书权威机构级别撤销证书
所以我们认为这是一种至关重要的技术
来让你确认与你对话的那个证书
的确是你要对话的那个证书
所以你可以这样试试
你可以使用相同的info.plist
你用它设置了应用的传输安全配置
这是新的关键字所以对于每个例子
有一个参与的证书你设置上关键字
然后你的客户端会拒绝任何
无法证明其有公开日志的证书
我们当前的策略大概要求
你需要有至少来自两个日志的证明
这些日志...我们会将认证的新日志添加上去
若你的证书能用在Chromium上基本上在我们这里也能行
有更多的信息
关于通用技术的在certificatetransparency.org
所以我鼓励你去查看一下
证书透明度是这个生态系统中的一个重要部分
当它无法完全代替吊销
这还有最后一步当你发现了
证书由于某种原因出现缺陷你必须要终止对其的信任
所以我想花几分钟时间
来谈谈我们推荐的做法
这叫做OCSP装订
这种标准已经推出很多年了
但是我们认为现在是时候
让大家转移过去真正开始采用它
因为现在对它的支持已非常广泛了
OCSP装订是对在线证书状态协议的增强
并且解决了大量的问题
所以回顾一下这就是OCSP的工作原理
我们有同样的设置
证书权威机构向服务器发放证书
每一次客户端连接那个服务器
客户端就会看到那个证书并且想知道证书是否仍然有效
所以它会请求证书权威机构
就在TLS握手过程中间
然后证书权威机构说
“是的 证书仍然有效” 或者“不是 抱歉证书无效的 不要相信”
这有一些问题
其中之一是速度慢
你处在获得资源的握手过程中
你不想等待一些其他实体来进行连接
尤其是当那个服务器关闭了你可能要等待一段时间
另一个重大问题是这会稍微泄露出
关于你在线活动的信息
你的证书权威机构会看你连接了哪些主机名
因为每次你连接的时候你都发送一个响应
OCSP装订解决了很多这些担忧
所以工作原理基本上是这样
进行请求的不是客户端而是服务器请求证书权威机构
证书权威机构将一个有签名的响应交回服务器
由证书权威机构签名
这样就可以信任它了
之后服务器将这个证书和承诺一并
发给客户端 表明证书是有效的全部一致 全部是同一个握手过程
所以这意味着
你的吊销信息会可靠迅速地送达过来
没有多余的等待没有任何担忧
而且会保护用户的隐私
因为他们唯一建立的就是返回你服务器的连接
你可能注意到这个图表看起来和证书透明度的图表相似
那是因为你可以使用相同的机制
来传递证书透明度证明
只要你的证书权威机构参与进来
你可以在一次握手中一同发出所有的信息
如我所说 OCSP装订广泛地支持于
多种操作系统而且还能向后兼容
所以你今天就可以启用在Apache上 在GenX上
你的后端托管在什么地方都行
而且现在完全支持所有的Apple平台
所以如果可以回顾
总结我们在网络安全上的进展
现在是时候前进到应用传输安全标准上了
这是牢靠的算法和牢靠的密码 TLS 1.2
正向保密和SHA-2证书
还有 现在是时候开始对证书透明度进行试验了
寻找参与的证书权威机构
然后整合到这个生态系统中
还有 一定要启用OCSP装订
这样我们就万无一失了而且要知道你可以确保
建立安全的返回服务器连接
所以这就是网络安全
现在我想花几分钟时间来谈谈一些加密改进
所以 首先是SecKeySecKey是我们的算法
不好意思 是我们用于非对称加密操作的API
在这次版本中 我们统一了macOS和iOS上面的API
SecKey现在支持所有的常见操作用非对称密钥
RSA 和 ACC 进行的操作
所以这是用非对称密钥进行签名和验证
这意味着SecKey完全替代了在macOS上被弃用的CDSA调用
而且它还替代了你可能使用的SecTransform
来用非对称密钥进行加密
所以我们强烈推荐前进到SecKey上
我们还将它嵌入到新工具包中叫做CryptoTokenKit
CryptoTokenKit是对加密设备的系统支持
所以那张你用来证明身份的小卡片
在企业中用的那种或者是USB token
现在我们直接整合了这些
而且它们可以整合到系统服务中
所以这意味着这些Token内容可以在keychain中获得
如你所料
而且Token操作可以通过使用SecKey API实现
这是一个复杂的话题其中有很多的深层内容
所以请到security lab见我们
我们可以详细讨论你的使用案例
所以感谢大家的关注接下来我将交给Simon
来谈谈在平台安全上的新内容
非常感谢你 Lucia
大家好 我是Simon Cooper我负责管理信任工程团队
我将谈谈安全上的新内容
但首先我想谈谈...稍微谈谈
软件是如何传输到Mac上的
稍微谈谈Developer ID
然后我会谈谈Gatekeeper
和围绕Gatekeeper的一些打包问题
我们先开始谈谈软件是如何传输到
我们几个平台上的
所以对于iOS 你可以从App Store上获取应用
你能使用Xcode来创建并运行应用然后将它们安装在你自己的设备上
这有一些Enterprise Program
允许你将内容传输到设备上并进行管理
你会发现所有这些安装机制
都是由iOS平台在背后处理完成的
所以现在我想稍微谈谈macOS
所以你还可以通过Mac App Store获得应用
而且这种获取应用的方法十分不错
你还可以得到有Developer ID签名的应用
你还可以使用Xcode
来创建你自己的应用然后使用传统命令行UNIX工具
来以普通的UNIX方式创建内容
所以我们回来稍微谈谈Developer ID
所以什么是Developer ID？
Developer ID允许你在App Store之外传输应用
这些应用通常使用网页浏览器下载完成的
Developer ID Program会发放给你一个Developer ID签名身份
当你以该身份给应用签名时应用会得到Gatekeeper的特别对待
实际上 在Xcode 8中有一些改进的流程
允许你正确地导出有Developer ID签名的应用
所以我们要做的是改变Developer ID Program
昨天已经宣布了
我们允许Developer ID和iCloud协同使用
所以Developer ID现在可以使用iCloud的功能
这包括iCloud DriveiCloud Keychain
Push Notifications和VPN
所以这意味着什么？
这意味着你可以传输iCloud驱动的应用
在App Store之外
你现可使用Developer ID将数据分享给
你的iCloud驱动的iOS应用
你能将新的Developer ID应用部署回macOS 10.9
所以大家一定想知道何时能够做到如此
你今天可开始iCloud Development测试
使用Xcode 8工具
你肯定也注意到了当你在做iCloud测试的时候
这有一个开发和生产环境
当你在部署你的iCloud应用时
你要在生产环境中部署
然后要等待即将发布的seed
这样才能开始测试
当你那么做的时候请使用Xcode 8中的新流程
因为这会确保你是在生产服务器中进行部署
Xcode团队还让我提醒大家
除非你使用GM工具否则请不要发布应用
所以Developer ID的另一边是Gatekeeper
Gatekeeper允许我们控制哪些应用可以在你的机器上运行
然后这是Preference Panel
在El Capitan中的Preference Panel上面
有这些选项 你可以运行来自Mac App Store的应用
可运行Mac App Store和未识别开发者的应用
或者你可以运行来自任何地方的应用
当你第一次运行应用时Gatekeeper会运行前提示你
其实我们在Gatekeeper上做了些更改
而且我们对Sierra中的Gatekeeper UI也做更改
我们改变了默认选项而且那些默认选项会是
你可以运行Mac App Store的应用
你可运行Mac App Store和未识别开发者的应用
现在如果Gatekeeper出于某种原因拒绝你的应用
这通常在这个Preference Pane中会出现一个按钮
让你打开...继续打开
不幸的是 在seed版本中这项功能并不起作用
但会在之后的seed版本中得到修复
我还想说我们没有改变
基本机制和策略的工作方式
所以如果你已经完成管理配置
或者使用命令行工具和策略工具
你可以重新启用Allow Anywhere
我想稍微谈谈Gatekeeper上的其他一些变更
但是我首先要谈谈重新打包问题
和为解决该问题而开发的Gatekeeper加强的地方
现在重新打包成为了一个问题
是由于某些应用编写的方法
有一些类型的应用
在编写的时候延伸到了其本身之外
并且使用了外部资源
这些应用可能以多种方式传输
而且它们可能确实有正确的签名
但是它们所延伸的外部资源可能没有签名
它们可以是代码或是等价代码
可以是库可以是插件
甚至可以是HTML内容
你可能没注意到本地的HTML内容
如果含有JavaScript这就可以访问你的整个系统
这些资源还可以是Lua Scripts或Python Scripts
或甚至是Apple Scripts
所以问题在哪？
如果你将这两个东西一起放入容器中
然后以这种方式传输应用可能通过压缩文件或磁盘镜像
或者使用ISO镜像然后你将应用放入容器中
然后你将资源放在应用旁边
当应用运作并和外部资源对话时
它就会加载这些有潜在危险的东西
你会发现这里的应用有绿色的边框
表明有签名
它延伸到了外面到签名的外面
并尝试接触这些潜在资源
所以如果我将那个应用重新打包
我不是将它和外部资源一同打包
那是你们开发者想放入的内容
我是将恶意内容放进去
之后当用户运行应用
他们不会得到你的体验
他们体验到的是恶意代码
如果那个恶意代码是一个动态库
比如你可能把它放入一个插件目录里了
那这几乎可以肯定你的应用将不会
执行你所预期的事情
所以我们将其称为重新打包问题
有一些内容并非直接受到打包问题的影响
那些内容是从Mac AppStore中传输过来的应用
这是获取应用的最佳方式
其他内容
可以不受直接影响的
是你使用带有签名的AppleInstaller Package来安装应用
这不意味着说一旦应用安装完成
就无法重新打包并传输到另一个机制中
但实际的Apple Installer Package
在延伸到外部资源的方面是没有问题的
有些内容是会受到影响的
前提是你传输应用的方法是用压缩文件或磁盘镜像
或者如果你将内容组合在
ISO镜像中以及其他任何一种存档格式
还有可能的是如果在你的磁盘镜像
的结构中你组装应用的方式
是使用一种组合将各处的资源
组合到一起那你也可能受到影响
所以在此问题上我们需要你们的帮助
由于这个问题我们还需要保护我们客户
我们需要做什么？
如果你传输某些内容
其中有带签名的应用和一些外部资源
你可能通过压缩文件或磁盘镜像 或ISO镜像来做
我们要请求你们换成使用磁盘镜像
我们请求你们这样做的原因是我们现在可以给磁盘镜像签名了
你可以用macOS 10.11.5来给磁盘镜像签名
这是El Capitan的当前版本
或所有之后发布的OS X
你可以使用共同签署工具来给应用签名...
来给磁盘镜像签名不好意思
这基本上会将
外部资源和应用绑定在一起
这些签名实际上嵌入在磁盘镜像中
并随着磁盘镜像附带
而且这个有签名的磁盘镜像与旧的OS版本相兼容
现在我想说一些打包建议
避免打包问题的一种方法是...
重新打包方法就是完全避开它
将你的资源放入应用捆绑包中
之后给整个内容签名
如果你只发布单个应用捆绑包
你应该考虑通过Mac App Store传输
你一定要给应用签名
或许在压缩文档中打包
不过请在发布前验证那个签名
或者 如果你有复杂的安装
你可使用带签名的AppleInstaller Package
对于容器
还有应用和资源还有磁盘镜像
请使用并换成有签名的磁盘镜像
容器中的所有内容都要签名
所以其内部的应用也应该签上名
而且你应该给磁盘镜像签名
并请在发布前验证所有的签名
关于打包的最后几点
如果你将个性化和许可信息添加到你的应用上
在下载的时候
请在应用的捆绑包路径上使用扩展属性
这是描述该做法的技术说明
那就是Tech Note 2206
你也可以通过给个性化磁盘镜像签名来做到这一点
这里有一些你一定不要做的事
给应用签完名之后不应进行修改
因为这会破坏代码签名
当Gatekeeper来验证你的应用时 就会出现问题
你绝对不可以传输签名被破坏的应用
然后请不要传输ISO镜像了
现在我想谈谈Gatekeeper增强
这是我们为攻克这一问题而开发出来的
这重点是为了保护客户
这个机制我们称之为Gatekeeper Path Randomization
它补充了所有现有的Gatekeeper保护
而且对于Mac App Store的应用没有任何变更
当你升级Sierra时也没有任何变更
对于任何之前在你系统里运行的应用
这个机制对任何新下载的应用起作用
并且适用于无签名磁盘镜像上的应用
我来描述一下究竟这种机制是如何生效的
这是一个复杂对象
这可能在你的下载文件夹里
而且可能是一个解压缩文件
或者可能是一个已装载的磁盘镜像
包含你的应用和那些额外资源
所以 当你双击应用时
当应用运行后它会被重新转移
通过一些技巧
放到文件系统里的一个随机位置
而且它不能访问资源
所以 这会终止重新打包攻击
所以在一些情况下这种重新转移是不会发生的
如果用户明确地移动应用只是移动应用本身
如果他们将应用和其他东西一同移动
那这个机制不会关闭
如果用户只移动应用本身可能移动到/Applications
那这个机制会被关闭
如果给磁盘镜像签名那这就不会发生
所以任何从带有签名的磁盘镜像运行的应用
这个机制将不会得到应用
这种机制也不会起作用
若你使用带签名的AppleInstaller Package安装软件
这也不会应用于任何来自Mac App Store的应用
所以简要来说本次演讲中的两个收获是
给你传输的内容进行签名然后检查内容是否有效
所以关于本次演讲的更多信息可以在这里找到