UIKit应用基于协议与值的编程
大家下午好 欢迎大家的到来
我叫Alex 我和Jacob今天将会跟大家谈一下
如何使用值类型和协议
来提高应用的性能
我们今天的重点是
一个叫做局部推理的东西
局部推理的意思是当你看眼前的代码时
你不必考虑其他代码
与那个函数如何互动
你之前可能有过这种感觉
而这就是那种感觉的一个称呼
比如 也许你刚加入一个新团队
你要看大量的代码但是环境很少
你能明白那一个函数正在实现什么功能吗？
所以了解这个信息是非常重要的
因为这样维护起来更容易
写起代码来更容易
测试起来更容易
首次参与编码也更容易
所以我们要谈一下局部推理会如何
在模型视图控制器设计范例环境下
改善我们的UIKit应用
就是Cocoa所使用的模型存储数据
视图呈现数据
控制器在两者之间协调
我们需要一个真实的应用来验证我们的答案
不幸的是在Apple中我们实际上有一个问题需要解决
我要跟你们说个秘密
关于我们每年是如何准备 WWDC 的
工程师都有梦想
他们要呈现他们所梦想的东西
无论用什么方式 我们要了解这些梦想 并把它们记录下来
但我们注意到许多工程师实际上在工作时
就不再记得他们的梦想了
他们忘了自己的梦想
所以我和Jacob开发了这款很棒的应用
可让你们记起自己的梦想
该应用就叫Lucid Dreams
我要展示去年人们的一些梦想
有些人梦想成为麒麟
这是认真的
很奇怪的是 有些人
仍然被工作压力问题所束缚
他们更想离开办公室去骑车
有些工程师甚至梦想成为Crusty
那就是我们应用的灵感
由于我们将在演讲中使用这个应用
我想快速给你们展示一个演示
这样你就能明白这个应用是做什么的
如果我们启动应用你会注意到它会把我们带到
我们现有的梦想列表中
如果你轻触其中一个梦想你可以编辑它
并且在顶部可以看到预览
可以向下滚动并添加一些特效
比如激光束和雨
然后往回滚动到原来的位置你可以看到梦想的预览
麒麟有激光束、雨和喷火特效
编辑完成后
返回梦想列表
这就是这个应用
我们要认真努力地思考如何写出更优秀的代码
所以我们去年参加了一些很不错的Swift演讲
这些演讲的主题是值类型和面向协议的编程
的好处
这些想法非常强大
我们想要利用它们
因为它们可以帮助改善应用中的局部推理
所以我们用这种不一样的思考方式写出了这个应用
现在你可能觉得有些想法很陌生没有关系
我们首次尝试这些技术时
我们也觉得很陌生
所以不要担心 继续听我们讲
我们会快速地谈一下模型层中
值类型的好处
去年已经谈过了所以我们要快速回顾一下
然后我们重点讲如何在视图控制器层
使用值类型
因为我们认为绝大部分人认为他们不会利用值类型
即使它们有一些切实的好处
在演讲中 我会演示如何使用值类型和协议
使代码变得可测试
你刚刚看到了这个很棒的应用我知道你想测试
我们已经发布了示例应用
你可以自己下载 查看代码
并记录你自己的梦想
好了 现在 是时候谈模型层了
那么梦想是什么？
梦想是模型类型
会在应用中呈现梦想
梦想可以是描述、创造物和一组特效
正如你刚才在UI上看到的一样
我想展示梦想类型的一个版本
是我们去年在应用的第一个版本中使用的
最开始我们的梦想类型是一个类
类有引用语义
意思就是引用同一个实例会共享存储
这样的共享很含蓄
这为什么会是个问题呢？
嗯 假如某人尝试修改dream2的描述
如果我们关注dream1我们会非常吃惊
因为变量的值在我们的控制下发生了变更
这非常影响局部推理
而且我们自己的应用即使通过了测试
恰有这种漏洞
为什么会这样呢？
这个图表显示了应用
第一个版本中的关系
有些关系可以同时兼具明显和含蓄
有些关系既可以是单向的又可以是双向的
有些关系甚至既可静态又可动态
所以这些关系可以变得非常非常复杂
那么当我们尝试测试它自己的
梦想类型时发生了什么呢？
嗯 即使你创建一个能自己支持自己的梦
也不会在应用中反映实际情况
因为实际存在更多的依赖性
这样很不好
我们可以通过使梦想类型成为有值语义
的结构来解决这个问题
意思是每个变量都有独立的存储
改变其中一个变量的值
不会影响其他变量的值
如果我们修改dream2的描述
我们只能修改dream2的描述不会影响dream1的描述
这就确保梦想不会涉及
我们之前所看到的复杂关系
这也证明了我们有局部推理的能力
因为没有代码能改变在我们的控制下正在使用的值
接下来讲使用值类型
我们刚看到了我们是如何在模型层中利用值类型的
而且在模型层使用值类型实际上是没有任何争议的
但你们就不想在我们应用的其他部分
利用我们刚刚看到的这种好处吗？
实际上可能会很吸睛
我想引用一句话是我最近在因特网上看到的
说“只在简单的模型类型上使用值”
听起来一点儿都不励志
但我们会相信从因特网上看到的所有东西吗？
答案是不会 如果你不了解的话
那么 在接下来的演讲中
我们主要谈如何在应用复杂的
模型数据中使用值
同时我们将证明因特网上的那种说法是错误的
好的
让我们邀请Jacob上台讲一下视图层
谢谢Alex
我真的很乐于跟你们讲我们是如何与视图一起
使用基于协议的编程
我们在应用的表视图单元上花了很多时间
我们对它们的布局进行了精心设计我们想要实现
完全显示出人们所梦想的麒麟
当开始开发应用时我们写了这些布局
作为UITableViewCell抽象子类
比如 这个简单布局 我们把它叫做DecoratingLayoutCell
它左侧显示了一点儿装饰
右侧有大块的内容
然后 我们做了一个布局单元的具体子类
添加具体逻辑 比如显示梦想
我们做了这种分离 因为我们想
在不同的地方重新使用布局
但随着开发的继续
我们发现越来越不好用了
它能帮助我们在不同的单元重新使用布局
但很难在表视图外使用
比如 我们有个详细视图
显示梦想的更多信息
但我们不能在那儿重新使用布局单元
我们想找到更好的方式来构造
以便我们能在表视图单元上使用布局
同时也能在普通UI视图中使用布局
我们还想在应用中添加SpriteKit
显示那些很酷的粒子特效
并且我们也想在SpriteKit节点中使用布局
这就是我们的目标 我们用从Swift学到的东西来实现这个目标
虽然我要具体地讲布局
我想让你们记住一点
这些技术可以在整个应用中使用
好了 我们开始吧
这是我们以前的布局单元
有两个视图
但这个布局逻辑实际上不需要被困在单元内
只需要一些数学和几何学就能算出一组框架
让我们从不让单元只是作为普通结构开始吧
它仍会有两个视图
我们可以把所有布局逻辑放在一个方法中
可以调用方法 显示布局
只做了这样小小的变更
我们就拥有了非常独立的代码
这些代码知道如何实现布局仅此而已
然后 我们可以更新梦想单元使用新结构来展示它的子单元
好消息是我们现能在UIView子类中
使用独立代码了
现在 这个布局逻辑已经跟表视图单元不挂钩了
我们可在任何UIView中使用
还有一个好处
我们能独立使用布局
可以非常方便地做单元测试
我们只需要创建一些视图
并把它们添加到布局中
然后在一个已知的矩形中展示出来
再然后 我们只需要验证
结果展示的框架是否正是我们所期待的框架
我们的测试不必创建表视图
或等待正确的视图布局回调函数起作用
只需要通知布局开始运行然后验证输出
这是我们得到的其中一个好处
新布局的结构很小、很紧凑
这种变更使它更容易对这个代码进行局部推理
如果我们想了解对布局的测试
我们只需要了解那个独立的小结构
我们不想考虑 哪组视图
它可能会使用或覆盖
好的 现在让我们返回DecoratingLayout代码
现在 这个代码只知道如何显示视图
但就像我刚才所说的我们也想用这个
支持SpriteKit
所以 我们不想复制这个代码
但SKNode并非UIView子类
所以这里没有可用的通用超类
那么我们如何把这两者结合到一个单一布局中呢？
由于我们的布局在这些子类中所实现的唯一功能
是设置它们的框架
这是我们需要的唯一功能
我们可以通过协议来实现这个需求
我们要做一个协议
这个协议只有一个单一框架属性
这样还不流畅我们要稍微改进一下
然后 我们使用这个协议作为子类的类型
而不是把它们做成视图
最后 我们可以使用追溯模型
使UIView和SKNode遵守新协议
现在 我们有一个能在两种类型中使用的布局了
这是使用协议 的好处之一
并非为实现多态的超类
我们可以使用协议把这个功能添加
到不相关的类型并在两种类型中使用
现在 我们的布局不再依赖于UIKit了
我们能做的另一件事是
把同样的体系带到AppKit中并支持展示NS视图
非常简单
我觉得这很酷
我们已经很接近了
但仍然还有要改进的东西
当我们在视图中使用DecoratingLayout时
我们想把所有内容添加为子视图
类似地 当我们在SpriteKit场景中使用它时
我们把内容添加为子节点
但现在 内容和装饰可以是有框架的任何类型
意思是 比如我们的内容可以是个UIView
而装饰是一个SKNode
但相反 我们想让布局只有一组UI视图
或只有一组SK节点作为其子布局
那样 我们就能把它们添加到相应的父布局中
现在Swift有一种方式就是用泛型表达
我们可以把布局更新为通用类型
类型参数叫child
然后我们可以使内容
和装饰属性使用child作为它们的类型
这就正好提供了我们想要的结果
我们可以强制它们是同一种具体类型
这样我们的DecoratingLayout
就只能有UI视图或只包含SK节点的视图
因此 泛型是一个很棒的工具可使我们对代码中的类型
拥有更多的控制
泛型的另一个好处是
编译器能获得关于代码功能的更多信息
因此可以进行更多优化
你可以从了解Swift的性能演讲中
更详细地了解这些信息
那是场不错的演讲可以了解Swift如何运作
以及如何写出迅捷的Swift代码
好了 我们现有一个不错的DecoratingLayout实现
但是我们的应用还包含许多其他布局
比如这个级联布局
这个布局类似于我们刚看到的DecoratingLayout
右侧都显示一大块区域
左侧有详细的装饰区
我们不想粘贴复制代码来创建这个新布局
那样可能会失去一个创建两者
都能使用的共享抽象的好机会
我们要如何共享这个代码呢？
你们之前几乎都用过的一个共享代码的工具是继承
但如果用继承你的确是有了代码
但是请不要尝试读取这个代码
而且你还要考虑超类可能会有什么功能
以及子类想要变更或覆盖什么
除了只考虑你正在用的代码
你还要考虑把分散在应用中的
大量代码结合在一起
而这只是冰山一角
很多时候你还要从框架类继承
如UIView或视图控制器
还有大量数量级的代码
所以 继承是另一个
要使用局部推理的地方
但我们可以通过合成更好地共享代码
合成是一个简单的想法只是把一些小片段结合在一起
构建一个较大的片段
但是当合成时你可以了解那些独立的片段
你还可以强制封装
而不需要担心子类或超类
在抽象中产生漏洞
但合成也不是个新功能
你以前可能在Objective-C或其他语言中用过
以前我们实现布局的其中一种方式是
把视图组合到一起
你可能会写一个UIView
执行级联布局行为
再写另一个UIView执行装饰布局行为
然后你可能会将这两者作为子视图添加到表视图单元中
但是有一个大问题
就是类实例的消耗很大
当你创建另一个对象时你会有一个额外的堆式分配
这比视图更糟糕
因为需要做很多工作来支持视图
使视图能实现像绘制和事件处理这样的功能
正因为如此 我们非常努力地尝试把视图数量最小化
所以创建一个不能绘制的视图
并且只作为布局抽象是一种很大的浪费
这也是为什么合成视图方案不太好的原因
但通过Swift 我们得到了一个好得多的方式进行合成
就是用值类型
结构是轻量级的 因此我们可以使用多个结构
而不需要付出像类和视图那么多的消耗
因为结构有值语义所以就更好了
使用值类型会有更好的封装
可以同时使用这些片段来进行合成
而不需要担心别人修改你正在使用的代码
那么 让我们在布局中应用吧
嗯 我们可以这样写出布局中的级联部分
使用所列出的子布局的一个数组
然后 我们想用DecoratingLayout构成布局
获得最终效果
但是还有另外一个小东西需要改变
这些布局只能有UI视图
或SK节点的的子布局
让我们推广一下 这样我们可以使用布局并把它们合成到一起
我们为子布局使用的布局协议需要一个框架属性
永远不需给那属性调用getter
我们永远只需要给它设置新值
我们并不关心子布局是否有框架
我们只想使子布局
在指定矩形中展示自己
因此 让我们改变一下方法
当我们决定其中一个子布局的矩形后
我们将告诉那个子布局要在那个矩形中展示
UIView和SKNode仍会遵守我们的协议
当它们被要求在矩形中展示时它们将用它来设置它们的框架
但现在 我们也可以使布局遵守这个协议
它们已经知道如何布局
当给它们一个框架时它们只需要分割那个矩形
并提供给子布局
我们现需稍微变更一下DecoratingLayout
允许它在子布局的类型上有更多的灵活性
我们稍后会进行详细解释
现在 我们能创建我们喜欢的布局了
通过把CascadingLayout和装饰布局
合成到一起
这种合成可以使我们以一种声明的方式
创建这样的高级布局
示例代码中还有更多的例子
当你创建自己的应用时
当你需要重新使用代码或自定义一些行为时
请尝试用合成 这个工具很好用
那么我之前提到了我们添加
布局内容
到超级视图或SpriteKit场景中
重点之一就是以正确的顺序添加这些内容
比如 我们的CascadingLayout希望它的子布局按一定的顺序排列
这样可以显示成一竖排 一个在另一个的上面 就像这样
我们可以扩展协议来支持这种需要
我们将在布局协议中添加一个属性
返回它的内容
我们的合成布局将以正确顺序
返回所有内容
然后叶视图和节点只返回自己
但又一次 如果我们只把内容类型作为协议
就会允许产生混合环境
作为内容的UI视图和SK节点
因为我们把这些子布局添加到了父布局
我们只想实现同类集合
只有UI视图或只有SK节点
为了强制实现这个目标 我们可以向协议中添加一个关联类型
关联类型就像是一个类型占位符
一致的类型选择想要使用的具体类型
协议的关联类型是我们要放在
布局内容的数组中的类型
这就允许我们写出一些只知道如何展示视图
并指定其内容类型为UIView的代码
类似的 我们也可以写出只有SK节点作为内容的布局
这种类型的安全性非常好
跟以前一样 我们不想通过布局的通用版本
分别给视图和节点写布局
我们仍然拥有支持两者的单一布局
对于内容类型
我们只使用子布局的内容无论内容是什么
意思是我们可以创建DecoratingLayout
要么只能跟UI视图一起使用要么只能跟SK节点一起使用
这两个都是强型的因此我们可以取出它们的内容
并准确地了解它们
它们仍然可以共享所有的布局逻辑
相关类型是使协议变得更健壮的一个好方法
现在我们改进了布局协议
我们还可重新访问DecoratingLayout的子布局类型
在这里我们需要它们是同一种类型
如果都是UI视图用起来没问题
但若我们想把CascadingLayout和UIView一起用就不行了
就像我们之前在合成中谈到的那样
我们真正想要的是使所有内容都拥有同一种类型
让我们更新一下布局
我们可以改变结构 使它有两个不同的通用类型参数
每个子布局一个
然后 我们还可以添加通用限制来要求
那两种类型有同种类型的内容
这就使我们准确地表达出了限制条件
子布局的内容必须是同一个类型的
这就是我们完成的协议
表达了我们的布局抽象
比我们之前那个协议要好得多
这个协议有实际意义
它是一整套操作
表达了它作为布局进程的一部分的意义
你还可以查看我们的示例应用了解一切运作的
详细信息
包括我们如何用它
在后台线程上实现渲染图片的布局
我们可以利用新布局协议的最后一点
就是单元测试
我们可以写一个有框架属性的结构
使结构服从我们的布局协议
然后我们可以改变单元测试在单元测试中使用这个结构
而不是使用布局中作为子布局的UI视图
现在 布局只会在这些简单的结构上设置框架
意思就是 我们的测试跟UIView是完全隔离的
并且只依赖于我们自己的布局和测试结构的逻辑
我们在不使用GUI的情况下对布局进行单元测试
我认为Crusty一定感到自豪
这些是如何在应用的视图层以一种
你想象不到的方式使用类型和协议的一些示例
我们还了解了一些不错的通用Swift技巧
你可以随意应用
首先 我们了解了如何通过使用值类型
改进局部推理
然后我们了解了如何使用通用类型
来得到更好的类型安全和灵活的代码
我们还了解了值的合成对于自定义
和创建复杂的行为来说是个多么棒的工具
现在让我们欢迎Alex回到台上 谈一下
我们对应用中控制器的处理
谢谢Jacob
现在我想重点谈一下我们如何在控制器层中使用值类型
让我们谈一下应用的撤销功能
我们在梦想列表中实现了撤销功能 很好用
但我们注意到有个小漏洞
就是不能撤销最喜爱的创造物功能
为了重现这个漏洞我们可以轻触最喜爱的创造物
目前有只粉色麒麟是我们最喜爱的创造物
现在让我们把它变成龙
变更完成 我们只需要轻触右上方的完成按钮即可
好了 我们已经修改了最喜爱的创造物
但问题是 如果我们摇动设备来撤销 什么也不会发生
所以这是一个漏洞
让我们看一下代码看看为什么会这样
目前 在视图控制器上有两个模型属性
一个是梦想的模型属性一个是最喜爱的创造物的模型属性
这在UIKit应用中是个很典型的安排
尤其是当模型增加和功能增加时
再一次 我们只有梦想功能
那么我们实现了撤销 这很棒
但当我们添加最喜爱的创造物功能后
我们的撤销代码就不见了
漏洞的产生是因为忘了添加那段代码
要修复这个漏洞我们可以添加另一个代码路径
实现最喜爱的创造物的撤销功能
听起来像是一个噩梦
因为每次要添加另一个模型属性时
我们就不得不添加另一个代码路径来实现撤销
这很糟糕
我们不希望这样
我们往回退一步
当我们添加更多的模型属性时
想要找到一个更好的解决方案
那么方案就是把这些模型属性合成
到一个单一值中我们的模型结构
撤销逻辑会按照那一个类型单独运行
请注意 模型仍然有值语义这很重要
那是因为它是由两个别的值合成的
这个方法很棒
因为现在两个模型属性
只有一个单一代码路径
如果我们添加另一个模型属性
我们仍然有一个代码路径
这很棒
我们可以通过把两个模型属性挪到视图控制器上的
新模型结构中实现
这样 我们要做的就是向视图控制器添加新的模型属性
这也是我们的构造方式
但现在 我们需要实现撤销代码
我们如何实现呢？
嗯 我首先要展示的是常见的实现方式
以及我们为何认为这种方式有漏洞
左侧是视图控制器的当前模型值
右侧是运算和撤销堆栈
在应用的原始版本中
我们认为撤销堆栈是一系列的小步骤
每个步骤都能响应对第一个模型的修改
和匹配的视图
比如 在第一个撤销步骤中
我们要移除用户刚添加的梦想
然后我们要从那个表视图中删除那一行
然后继续下一个撤销步骤
在这个撤销步骤中
我们要把模型重新变回粉色麒麟
那么这个分别修改并更新
视图个体模型属性的方法
很容易出错
因为你需要精确地匹配模型中的变更
和视图中的变更
如果失败会导致模型和视图
之间的很多矛盾
最后就会得到这样的漏洞
我确定你们所有人都遇到过这样的问题
我总会遇到这样的问题
很难进行调试
为什么很难调试呢？
嗯 让我们再看看
我们最初的撤销堆栈
这些不可撤销的变更实际上是从哪儿来的呢？
嗯 每个不可撤销的变更都来自我们的视图控制器
并且每个不可撤销的变更都会影响顺序
当我们向应用中添加功能时出错的几率很大
我们的代码中并没有可以
让我们在模型和视图更新之间推理一致性的地方
这很不好 因为太复杂了
让我们寻找一种更简单的方式来处理撤销
如果不记录小的变更
堆栈中的每一条都只是个完整的新值
完整的新模型
现在 在模型上
实施撤销就非常简单了
只需要用堆栈上的模型替换当前模型即可
这样我们就不用再担心顺序问题了
然后我们只替换值
这样我们就解决了模型的问题
我们还要解决如何更新UI的问题
在视图控制器中 无论什么时候只要模型发生变更
我们就调用modelDidChange方法
我建议你下载这个示例
了解这个方法具体是如何运作的更多信息
在那个方法中我们需要找到
新旧模型值之间的不同点
并更新我们的UI进行匹配
比如 我们可以查看
旧模型中最喜爱的创造物是不是跟
新模型中最喜爱的创造物不一样
如果不一样 我们就更新表视图中
包含最喜爱的创造物的那一行
在对象中有一个更好的实现
就像我刚提到的那样我建议你查看
关于更新UI的更多信息
最后 我们只需要注册撤销逻辑
把模型重设为旧值
这很棒因为我们现在只需要一个
或者说我们只需要在一个地方注册撤销
这有什么好处呢？
正如我们所看到的 为了更新UI我们生成了一个单一代码路径
所有操作都按顺序独立进行
以前并不是这样的
这能帮助我们对代码进行局部推理
和UI更新代码
我们还能了解值之间是如何恰如其分地组合在一起的
如果单一值的属性有两个值
那个值仍然会有值语义
好了 让我们谈谈如何在有模型属性的控制器层
使用值类型
在控制器的UI状态属性中
我想实现同样的功能
你以前看过这个屏幕
这是梦想列表
但这个视图控制器有许多不同的状态
我要给你们展示视图控制器的状态图
因为它跟我们一个很酷的功能有关
就是和朋友分享梦想
让我们来看一下
这是基本状态图
我们要从浏览状态开始
轻触顶部的分享按钮
将会把我们带入选择状态
然后选择要分享的梦想
然后轻触完成按钮返回分享状态
分享完成后我们会回到浏览状态
用起来很流畅
但让我们再快速返回选择状态
你会注意到 我们可以通过轻触
左上角的取消按钮停止分享
这将把我们带回浏览状态
你会看到导航栏看起来显示的是正确的
因为它又显示分享按钮了
但其实在应用中有一个很小的UI漏洞
是由一种不一致状态导致的
表视图左侧的UI
仍然可见 并仍然允许用户选择梦想并分享 这样是不对的
当我们返回去调试这段代码时
我们看到某些状态属性
在状态变更时并没有被全部清除
在这种情况下即使我们进入了浏览状态
我们忘记去清除选择状态的
某些属性
让我们再看看状态图看是否修复了这个问题
这里的每个状态都有相应的属性
并且这些属性是视图控制器上的属性
状态属性的个数
随着应用功能的增加视图控制器中的
增长可能会很迅速
在这种情况下 重点是我们的属性是相互排斥的
那么 当我们浏览时我们就不分享
当我们分享时 我们就不选择
但是 我们写这段代码的方式是当你设置一个属性时
你需要清除其他所有属性
这很容易出错
我们要如何解决这个问题呢？
嗯 枚举非常适合处理相互排斥的值
我们把所有UI状态属性都转成了枚举值
然后 我们只需要通过使用枚举把状态属性添加到视图控制器即可
 我们可以确保状态是相互排斥的
这很棒因为我们之前发现的无效状态漏洞
现已不可能再发生了因为它受类体系的迫使
这个方案也意味着我们的状态变更
是突然发生的不需要任何可能的中间状态
因此我们不需要协调该死的属性
和隐含的时间依赖性
此外 使状态多合一
更容易以用户
上次离开时的完全相同的状态启动应用
我真心推荐你们再次查看和下载这个项目
看我们是如何在应用中实现状态修复的
好了 我们今天讲了很多内容
开始讲了改进应用中的局部推理
通过把值类型和协议引入
到基于模型视图控制器的应用
我们是如何实现的？
开始是通过把梦想类型做成结构
使模型有值语义
使我们更容易对代码进行局部推理
因为我们的梦想变量没有隐含的分享
然后Jacob展示了如何创建小组件
如DecoratingLayout和CascadingLayout
这些小组件利用了通用协议
确保通用组件可以在视图、中重新使用
SpriteKit节点和图形渲染
这使我们得到了更好的局部推理
因为每个类型都是小的、可测试的、分离的值类型
然后我们了解了如何利用视图控制器上的模型属性
合成到单一类型中
这使我们更容易用单一代码路径实现撤销
即使我们的模型类型有更多的属性
这个方案还给了我们一个更新UI的代码路径
使我们更容易理解
独立视图控制器的UI逻辑
最后 我们了解了如何把相互排斥的状态属性转成
视图控制器上的枚举值
这降低了UI为不一致状态的潜在几率
并且这也是我们今天讨论的值类型
但是 如果你下载示例项目
你将看到项目中的更多信息
而且我们整个应用也使用了很多值类型
除了我们需要用控制器或视图对象的地方
现在 UIKit要求把这些作为引用类型
但是我们仍然把绝大多数功能挪到了值类型中
我们今天讲了很多 我希望你回家
的时候头脑里要记得这几点
第一是通过合成而不是继承
进行自定义
你再坐在办公桌旁
绘制类图来解决问题时
我希望你考虑如何使用合成
而不是继承来解决那个问题
这样你就能获得我们今天讲到的值类型的各种好处了
第二个技巧是给通用的可重复使用的代码使用协议
你可以做可重复使用的小组件
很容易进行局部推理和测试
我强烈建议你们查看
我们是如何用通用类型而不是类层次
在那个示例中实现的
我们还展示了如何利用值语义
需要记住的重点是
如果有由其他属性组成的值
较大的值也会有值语义
最后 我们谈了局部推理
局部推理实际上是个非常通用的技巧
并不是UI编程专用的
也不是移动开发专用的也不是Swift专用的
这是所有编程语言的
一个非常重要的方面
当你回到办公室并开始编码时
我希望你思考 无论是哪种语言
如何使用那块代码看那块代码如何支持局部推理
Swift如此强调值类型绝不是偶然
因为它们是个非常重要的方面
可以让你对代码进行局部推理
就是这样了
你可以从这里找到示例代码和更多相关资源
我强烈建议你们这样做
我们还有一些相关演讲我们在演讲中也提到了
我建议你们观看相关视频
谢谢大家 希望你们在WWDC期间过得愉快
优化应用的网页内容
大家好
欢迎来到“优化应用的网页内容”
我是Jonathan Davis
网络技术的推广人负责Safari和WebKit
现在我要先说明一些事情
很多人说我长得像Edward Snowden
但我向你保证 我不是他
但这么多卫星在头顶盘旋大概都是来抓我们的
除此之外 我很激动地要展示些新东西
它们可以帮助你提升应用网页内容的性能
我们一直都知道
性能是提供最佳用户体验的关键
若你是个应用开发者并在应用里用了WebViews和JSContext
而且你很关心性能那你就来对地方了
说到性能
在当今时代里性能其实就是指电池寿命
我认为电池寿命是最终的有限资源
它带来很不同的结果如果你能拨出最后一通电话
或者发出最后一份重要的文件在电池耗光之前
性能对用户来说事关重大
他们所选择的应用不会让设备变慢
而且耗电量低
我们的经验就是根据用户的反馈和各自的体会
性能很重要因为电池寿命事关重大
所以今年我们致力于提供更好的工具
来找到和修复网页内容的性能问题
现在我们为应用提供了工具比如Swift
还有Objective-C代码比如Instruments
我们还提供了网络检查器帮助网页开发者创建网页和网站
但不要觉得因为你选择了
在应用中用网络技术就没有其他工具可用了
实际上我今天展示给你的所有工具
就是开发给人们既能帮助他们建设网站
也能让他们在应用里用网络技术
那么我首先要向你展示
如何把网络检查器连接到JSContext的WebViews
这样在你需要它的时候它就会立刻出现
之后你会了解一些新的功能
它们能让你了解JavaScript代码如何分配时间
以及这些新功能如何帮你迅速找到性能上的问题
如果你想要看到网络内容的内存使用情况
我们也给网络检查器增添了新的时间线我都已等不及想展示了
它们会帮你节省很多时间来找到内存过大的问题
准备好了？那就开始吧
第一件我们要做的事
是把网络检查器连接到应用里
在应用里使用网络技术有很多原因
如JS context里的一些JavaScript模块
可以让你轻松交换逻辑并无编译地添加新的模块
可能有些人正在tvOS应用里使用TVML的 JSContext
另外一个使用网络技术的原因就是你要显示的网页内容
比如第三方网站的一个网页
这个网站你不能控制
可能就要用到Safari视图控制器
如果不是你也许可以去听听
去年的演讲“介绍Safari视图控制器”
但如果你显示的内容是你自己的或者你可以控制的
或是可自定义的HTML CSS或JavaScript编写的内容
或者是可以提升应用体验的内容
WKWebView是最好的选择
它实际上是个矩形把网页内容拉入应用
它引入了iOS 8和OS 10 Yosemite
若你还在使用WebView或者UIWebView
那你一定要考虑升级到WKWebView
事实上 升级到WKWebView可以让你利用
Nitro JavaScript核心引擎和四级JIT编译器
这能大大提升速度
若想了解更多WKWebView信息
我推荐2014年的演讲介绍了现代化的WebKit API
那么去年我们给WKWebView添加了很多优秀的功能
比如 加载文件URL和自定义用户代理字符串还有WK网站数据存储API
现今有了iOS 10和macOS Sierra我们改进了3D-touch支持
现在你的应用就可以执行这些好用的
Peek和Pop事件在WKWebView里
就像我之前说的因为你选了
在应用里应用网络技术
并不意味着你没有工具可用
不论哪种情况你可连接网络检查器
发掘网页内容或JavaScript活动情况
但使用网络检查器前你必须要激活develop菜单
只要上传Safari设置然后找到“高级”标签
然后在底部你会看到这个复选框
写着在菜单栏显示Develop菜单
那就点击它
Develop菜单就会出现在Safari的菜单栏里
为让网络检查器连接到iOS设备
你要开启一个设置
在iOS的设置应用里点击Safari
然后拉到底部 点击“高级”然后把检查器设置打开
现在你就可以把设备连到Mac上
在Safari里检查Develop菜单
Develop菜单里有些很酷炫的东西
你之前可能从未注意到过
就是你能看到设备的列表
这里有已连接的iPhoneMacBook Pro和模拟器
要连接一个设备并开始使用这些工具
进行调试那么只要选择Device菜单
就会收到 当前设备上运行的WebViews和JSContexts 的列表
这里的Mac应用并没有使用WebKit
而用JavaScript
所以我可以直接连接它并使用工具
iOS里的应用只会出现在用Xcode创建和运行的时候
但是说到Mac应用你还要做一件事
就是保持应用的完整性我们不会让任何人下载你的应用
并用网络检查器巡查你的应用
所以你要添加这个授权
到应用本地开发的授权文件里
你可能已经有了一个授权文件
如果没有创建一个也很简单
你只要创建新的plist拓展名为.entitlements
并且Xcode的创建设置里定义一个代码签名的授权传递路径
这个要在开发的时候添加
之后在运行应用的时候删除
一旦有了这个授权
你的设备和应用就出现在Develop菜单
这样就可以连接了
轻松把网络检查器连接到JSContext和WebViews上了
我们已正常运行了网络检查器和应用
该谈谈网络检查器里新功能了
我想首先讲讲分析JavaScript代码
分析JavaScript
JavaScript的分析器已经存在挺长时间了
今年它变得更好
更有效率能帮助你迅速找到
哪里调出的JavaScript成本最高
原因很简单
新的分析器采用了取样技术不会影响性能
比以前好太多
我们的分析器在编译器能用之前的时代
实际是个翻译器
但是现在我们有了这个强大的四级JIT编译器
那么这个分析器就真正成为样本分析器
样本分析器告诉你代码把时间都用在哪里
帮你解答哪个代码占用的时间最多？
它在运行程序中的取样以每毫秒为单位
并且短暂地停顿执行
并快照所有正在运行的代码
它还可以取样
在代码运行于JIT编译器所有四级的时候
所以它的取样速度跟你代码的实际速度差不多
由于断点处理会导致代码去优化
我们暂时不管它们
那么当你分析的时候你就可以了解网页应用的真实性能
使用样本分析器对性能几乎没有损害
这就意味着当你分析代码的时候
速度高达以前的30倍
这就让代码分析过程更快也更简单
而且收到的数据也更准确
这个进步真令人振奋 因为我们团队和网络检查器团队
能利用它来发现可以提升速度的地方
就在网络检查器本身
好了现在我们有了样本分析器
看看如何利用网络检查器帮我们找到问题
这个内容很多但是可以简单的拆分开来
更方便的是这都是你已经熟悉的代码
当我们说到分析JavaScript时
意思是在Events里为JavaScript记录时间线
这就是Events视图
显示了一列单独而且具体的JavaScript事件
特别的是这里都是D3库的代码
所以它能更方便调试代码
和分析代码在你正在使用的库里
而且这里的每一条都是代码运行的事件
这是代码进出JavaScript核心引擎的情况
包括了监听事件的回调
比如动画框架的条目是在请求动画框架处理器
脚本评估条目显示JavaScript文件
的上传和首次评估
这里还有一些时间信息
告诉你运行的代码所花费的时间
所以如果有哪个超过了10或15毫秒
你就快要打破
60帧每秒的流畅性能底线
Events视图很有用但是还有另一个视图
是我们为你添加的叫做Call Trees视图
如果你用过其他分析工具那么对这个应该很熟悉
只要点击这个菜单然后转换到Call Trees视图
现在显示了调用堆栈里函数的累计运行时间
这个叫做Top Down视图
你可以用它深入发掘Call Tree
来找到耗费大量时间的热函数
但我最喜欢的视图是Bottom Up视图
它能直接让我找到最热的函数
就是取样最频繁的函数
这里罗列的是调出的函数
按照用时从大到小分类
它反转了Call Tree让你能直接对比各个函数的耗时
你能准确地看到耗时最多的地方
你可以展开这一条并按照路径返回
找到耗时最多的函数
你就能知道这个成本最高的代码是何时何地调出的
那么关于这部分有请我的同事
Brian Burg上台为大家展示
谢谢你 Jon样本分析器很好用
因为它可以提取十分复杂的内容
并进行分析让你看到十分精确的信息
而且你可以让它跑的更快
为了给你们展示我要用我制作的iPad应用
叫做卫星跟踪器在这里看看
卫星跟踪器会展示给你现在或任何时间
卫星所在的位置
你可以选择地球上的不同地点
也可以选择不同的卫星
不同的时区
这很棒吧
如果你担心头上盘旋的卫星
要带个锡纸帽子以防万一这个应用就是理想之选
但是这里有个小问题
如果很多卫星或者很多卫星组件
像这样挤爆了那么帧率的波动会很大
这肯定不是60帧每秒
它会一直波动
这样就可以用样本分析器来查找
发生了什么为什么这么慢
我们要做的就是打开Safari并进入Develop菜单
找到这里的iPad并连接上
那么我要做的第一件事就是进入Frames视图
看看现在的位置帧率如何
那么开始记录
我再转回iPad
做点什么
比如转动一下
或者换一个卫星
换个时区
好了现在回去看看
好的把这个缩小
所有的性能就都显示在这里了
有的时候是60帧每秒像左边这些
在中间则上下都有
因为我们在更改视图
这一些就太慢了
我想知道出了什么问题
那么我就转到Events视图
点击JavaScript和Events时间线
重点看看样本分析器的数据
就像Jon之前演示的那样这里的Events视图
会显示所有运行循环里的内容
这个例子里就是动画和模拟
就是我们在不断地渲染帧
这不是很有用因为无法找到耗时最多的地方
那么我们转到Call Trees视图
这里我们看到Top DownCall Tree
集合显示了所有的渲染帧
都是最耗时的地方
展开这个就能看到D3有一个Timer函数
它调出一些代码画了一些场景
这些场景包括卫星
和时间等
这个很棒能让我们了解代码在做什么
但是如果要想找出哪个函数最耗费
最好还是去看Bottom Up视图
这里我们列出了所有函数无论谁调用它们
我们看到这个fillText
和tangent是最耗费的两个
那为什么会调出tangent呢？
我们展开这一行看看调令来源
就在这里是_plotSatellites
好像正在计算转换用来绘制地球
好的这些看着都很正常
也许我该找出数学课本让它算得快一点
现在看看fillText
换个画面回到这里的应用
我们正在当前时间上绘制文本也在每个数据点上绘制
这说得通
但是如果仔细看我们实际上把这个时间画了两次
这就有点奇怪
所以我们展开这一行
就能看到调令来自哪里
这里我们好像一次画了两个不同的前景
这大概不是我们想要的
那么来找找哪儿出了问题
如果像这样画了两个前景
那么我们的工作量实际就是所需的两倍
为了让你的记忆更清晰记住我们有个平面地图
然后有这个地球它在转动
那么现在回到代码
找一找是什么控制着两个地图的切换
估计哪里弄错了
改变地点的时候我们会让两个地球互换
这是 updateLocation
好的 因为已经有一个地图就不再需要另一个
这是有道理的因为这里我们添加了隐藏类
就为了不让它显示出来
这里在_globeMap我们定义running值为真
在整个运行中
而且在place中声明我们显示的不是_globeProjection
这是对的
当我们显示平面地图
我们不会显示地球它也不会运行
这个平面地图看上去好像
一直在运行UI也在运行
这也挺奇怪的
那么我们回到地图试着做点儿什么
这里我们选择这个数据组
然后进入Earth
它的帧率要好于只做世界地图
那么这就很有道理
我想我们在世界地图活动的时候画了两张地图
但是在平面地图的时候只画了一个
那么我们就在这里改变这个条件
糟糕应该反过来
好的 先停下看看有没有修复
回到iPad
好的这看上去很流畅
来到这里
恩 很好
看上去不错
那么我们再去检查时间渲染
看看是不是60帧每秒
那么回到Frames视图
然后开始记录很不错
我转动地球的时候有点慢
但稳定度看上去...
不错绝对在60帧每秒以下
在这里有一个条只要低于它就是好的
现在卫星跟踪器快了很多
我们就知道什么时候带上帽子
这很棒
这就是个简单的例子关于如何使用样本分析器
来发现最繁忙的内容并让它运行的更快
下面Jon会跟大家讲讲内存和分配
谢谢 Brian
你看到了分析很迅速
它能让你了解代码的真实速度
这样你就能获得十分精确的数据
再看看JavaScript和Events时间线
并用它们找到缓慢的回调处理器和定时器
或者在Events视图里缓慢的脚本初始化
请用新的Call Trees视图来了解耗时
因为它们会沿着你选择的时间线堆积起来
记着Bottom Up是你的新朋友
它能帮助你找到最需要优化的地方
那么现在我们已经看过了新的样本分析器
和新的JavaScriptCall Trees视图
我很激动能用更好的工具来优化CPU时间
这样就能给用户快速的体验
并帮他们节省了电池
这真的不错现在我们继续
看看性能的另一方面
就是了解内存都去哪儿了
你肯定想更有效率地使用网页内容的内存
因为这是有限资源
有效地使用内存可以优化网页内容的比例
并能处理大型数据组
而且内存占用过多会降低性能我们并不想这样
它也会让你的网页内容崩溃
这更非我们所愿
好消息是若你运行WKWebView它会以单独的进程运行
不会让整个应用崩溃
但是这仍然不是一个好的用户体验
为了帮你解决这些问题我们添加了两个新时间线
给网络检查器和Safari 10
当启动新网络检查器新时间线就默认关闭
所以要打开它们
你只要点击Edit就在时间线上面
就可以配置自己想看的时间线
这样就可以只研究自己想用的那个
就和Instruments应用一样
只要开启新的时间线就可以记录新的时间线了
但你可能不想让它们同时运行
JavaScript和Events时间线样本分析器
虽然负载较少但还是有
而JavaScript Allocation的时间线会添加更多进程
在垃圾回收过程中这会影响性能
那我们就一直开着Memory时间线
那么在记录一个时间线的时候你会看到这个
这个新的Memory时间线图表显示了内存如何分配
到不同的目录里在不同的时间
这里有一系列图表
帮你了解内存的使用和划分
Breakdown表显示了内存如何分配给
JavaScript和图画和构成页面的分层
以及其他引擎相关的网页
Max Comparison图帮你研究内存高峰
这里有一个高的水印
帮你观察过去的内存问题
你甚至可以分离各个峰通过选择一个特定的部分
或者在一个峰值周围选择一个特定的时间段
然后你就可以使用下面的目录分类
来看看是什么造成了大部分高峰
这里的每个图表都是独立测量的
所以你可以清楚地看到不同时间的变化
JavaScript里的峰值显示的是
大量新对象被创建和引用的地方
其中包括的对象有字符串对象和函数
以及所有支持它们的引擎数据比如结构数据和编译代码
当你看到JavaScript的用量下降
就是说垃圾回收在回收内存
图片显示了分配给图片的内存
这些图片都通过解码显示
这里的图片数据比较大
通常用于可以在视口显示的图片
层显示的是图层内存
分配在WebKitstileGrid复合层
和其他引擎层
页面就囊括了所有其他的东西
引擎所追踪的所有内容
比如DOM和页面风格以及字体渲染数据
内存缓存和系统分配
所以这个分类能让你很好的保证
内存用量符合你的预期
若你有很多JavaScript内容你要明白
JavaScript会是分类图表里用量最多的一类
在时间线图表里你可能会随着时间看到更多变化
但是对于多图片的页面比如画廊
那么分层和图片目录就可能是最大的
随着时间变化也更多
这就是Safari 10里最新的Memory时间线
Memory时间线的补充就是新的JavaScript Allocations时间线
你不仅能看到不同时间里内存的变化
还能更细的探究
JavaScript Allocations的真实情况
对此我们有个强大的工具JavaScript Allocation Snapshots
快照的强大之处
是你可在JavaScripts堆里对一个时刻进行快照
然后你就可以深入看到所有被分配的东西
但是更强大的是你有两个快照的时候
你就可以回头再看并进行对比
对比快照是我们最强大的工具之一
它可以解答我是不是做了不必要的分配？
一定要利用它因为你需要多个快照
这也就是为什么默认每10秒照一次
不仅要在记录开始还要在结束
快照是在时间线上设计的所以它们能连到
其他时间线上发生的事情
在这里其他的都被我关了
这些快照在下面列出并附了一些细节
比如堆的时间和大小
要了解一个特定的问题
就通常需要在开始和结束的时候快照
围绕你认为内存会出问题的地方
这里有三个技巧
你可以依赖自动快照每10秒一次
或者可以亲自快照就按快照键
或者用代码执行
最简单的找到问题的方法还是改代码
调出takeHeapSnapshot API
传递一个自定义的标签参数它可以是任何
之后能帮你识别它的东西
还有你要做一对快照
在你认为导致问题的代码的前后
你还可以通过快照来使用这个代码
在一个循环内的工作之间
分析内存
下面讲讲要时刻牢记的几点关于takeHeapSnapshot API
要记住快照会增添一些额外的进程在垃圾回收进程中
这会影响性能所以你一定要注意
你的代码是否频繁的发射快照
你也要捕捉到前后不同的信息
当代码在一个循环之间的某个时刻运行时
不要留下这个
如果你把它留下对大部分用户来说没问题
但一旦有人运行网络检查器它们就会使用所有的快照
你大概也不想这样
所以要记住在启动前一定把它们删除
那么这些快照都显示了什么？
让我们来看一看
你只要点击时间线上的快照图标
或者在快照列表条目里点击Arrow按键
你看到的这一列对象都是之前分配在堆里的
快照有两个视图
这是Instances视图
展示了堆里的对象列表按照类来分组
另一个是对象图像视图
这实际上概括了所有东西
所有的所有
如果你很熟悉这个代码
它就能很好地帮助你确认事情或者找到相应的位置
但是实际上更有用的视图
是在Instances视图里
它的强大在于你可以轻松地找到对象
不论他们在属性路径里藏得多深
这里的Count可以帮你意识到潜在的问题
就是它们无法达到预期的时候
比如我能否实现4000多个字符串对象？
你可以展开这个Classes来看看所有分配到这里的对象
然后判断什么是什么通过这么多不同的线索
Class是一线索
另外就是对象的实际属性
这能让我们很快了解什么是什么
但是最简单的了解对象的方法
就是悬停在这个对象识别器上你就会看到这个
这里实际上显示的是到对象的最短路径
它告诉了你究竟是什么让这个对象保持活动
它基本上总会给你你需要的答案
特别是在JavaScript的垃圾回收里
这就是能立刻解开疑惑的方法
但是它最重要的功能和最关键的要点
在于它能比较两个快照
看看这个当你已经收集了一些快照
只要点击此处“比较快照”按键
然后选择Baseline快照再选一个对比
一下子
你就有了一个新的对比快照可以研究
这个十分有意义
因为现在只能看到新的对象
在两个点之间在两个快照之间
展开对象类分组可以看到所有的对象分配
预览中显示了它们的名字和类似遥测数据的东西
这里就说明它是卫星对象
这里的弹窗显示_Satellites Array属性
由于这是一个快照对比
卫星的对象都是新分配的
这是个很重要的线索显示代码在做什么
那么为了让你们实际看到这些新的存储功能
我要有请Brian回到台上来做另一个演示
谢谢 Jon
我把卫星跟踪器给了我的朋友Ed
他熬了一夜在玩这个
他很开心因为他从来没有被卫星跟踪过
但是这就有个问题
它运行时间越长最终会变得越来越慢
这在我看来很像传统的内存
打开时间越久就越慢
我想在卫星跟踪器里用这些新存储工具来看看
我们是否泄漏了一些内存
那么第一件事
我的iPad在这儿
我要回到网络检查器...
并且检查这个应用
我要做的第一件事
在我不知道问题在哪儿的时候就是要使用Memory时间线
它会告诉我页面上大概发生了什么
那么我们开始记录
转回来
我在两个卫星之间来回切换
也许我会在这里添加一些效果
好的我在来回切换
好了现在去时间线看看
在时间线概览中你看到一个堆积线形图
显示了所有不同的部分和相关的大小
如果你点击这里会看到更多的细节
那么这个页面上没有图片
都是画布
分层也很平面
页面有些波动有些内容在垃圾回收
没有问题
如果你仔细看看JavaScript你会看到...
虽然有些东西被垃圾回收
但是整体来说它还是在随着时间堆积
如果我们运行一整晚那估计会堆积更多
下一步就是启用heap快照或allocation快照
这样我们就能找到随着时间而分配的内容
为了实现这个我们要开始新的记录
这有个快捷键Shift 点击或Shift 空格
这样就会启动新的记录而不是继续之前那个
等等我忘了改时间线
去掉Memory
选上Allocations
好了开始记录
回到iPad
添加了小小的takeHeapSnapshot键
我已给控制台添加了一些takeHeapSnapshot的调令
用于切换两个卫星小组和其他操作
对这个记录我要转动地图
然后不断在两个卫星中切换
我们还要看看Spy Satellites看上去也有关联
好了 你会发现开始有点卡了
因为我们给JavaScript堆里的所有东西拍了快照
因此产生了很多对象
这会大幅降低应用的速度
所以一定不要拍很多快照
只在重要的时候拍
这里你可以看到方块里的S就是我们拍的快照
放大一下能看到
随着时间过去内存十分稳定的增长
当我们开始在两个卫星之间切换的时候
如果我们要研究这个像Jon说的那样
我们就要启动对比来看看是什么被拦住了
那么我们就对比快照9和11
立刻我们就看到很多东西
被分配在9和11之间并且仍然在活动中
这就清楚地说明了它们被留存了
虽然我们并不想这么做
那么我们来看看这些都是什么
这是些阵列
看上去这个阵列里全是坐标
你知道在应用的不同部分我们会用大量的坐标
但是如果我们停在这里就会看到它的路径
它们好像是被保存于trajectoryHistory
这是我们用来制作追踪卫星的东西
好的这样不错
但是我想不应该
再在已不显示的卫星里用trajectoryHistory
这好像是个bug
我们也分配了一些对象
但奇怪的是在快照9和11之间
我们之前已经看到这些卫星
那么我就不想再给每个卫星创建新的对象
我们只要直接使用它们只要我们已经为他们获取了资源
然后这里有了很多坐标和遥测
好像正在重新解析什么
我不太确定那么...
在这个视图里我们有很多对象
你不能读取所有
所以我想做的就是找出很特别的那一个
那么在这个快照里
我们有很多字符串阵列和对象
但只有一个Promise
它停留在两个快照之间
所以我认为应该调试这个
那么我就找到代码看看是哪里在用Promises
因为好像它与别的什么一起被泄露了
于是搜索Promise
好了 这是D3库这是使用它的代码
好的来看看这个
好了 在［听不清］里我们常常在卫星之间切换
代码是loadDataset
有人写了评论太好了
这里看上去好像有人请求我们改变卫星
那么这里就可以异步从URL下载数据
当它返回我们就要解析
然后使用卫星绘图库 做更多的解析
然后我们把它存到卫星列表上
这都很不错但是回到检查器
我们好像每次都泄露该Promise
如果你更仔细的想想
如果切换到已经下载的数据组会怎样？
我们甚至都没有检查过这个事情
你仔细的看看这里
每次在两个卫星之间转换
我们就发出一个新的网络请求
如果我们进入这个时间线
就会看到我们在不断请求同样的垃圾数据
这是正常的如果回到代码 发出请求
解析的时候会产生大量的对象
然后我们把它推入卫星阵列
就目前来看它怎么都不清楚
我们好像一直在做无用功然后不断泄露
所以这里我们要做的
是检查我们是否已经解析了这个卫星对象
因为这是Promise
如果它确实存在我们可以调出.then
由于这已解决下一次评估Promise的反应时
它就会进行检查并将卫星放到地图上
那么在这里添加代码
如果不存在我们就创建一个
好了 现在停下来看看有没有效果
我们就要回去重新连接
这是我们的应用开始记录吧
当我们回到应用我就打开快照
打开一些效果
然后往南走
好的 间谍卫星
卫星的科学实验
科学实验
好了
如果我们回到这里我们看到内存的增长大大降低
大概在1兆而不是四五兆
那么这里可能有更多的泄露
但是在快照结束的时候我们的内存
跟刚开始渲染的时候一样大
这样我们就修复了这个特殊的泄露
这就展示了我们如何使用Allocations和Memory时间线
来解决像这样的应用的内存泄露问题
这很不错因为应用可以用更多的操作
有了diffing功能
我们就可以深入观察我们所关心的卫星里的变化
好了卫星跟踪器就讲到这
你回来吧 Jon
谢谢 Brian
你看到了真是不可思议的迅速和简单
这些新的时间线让内存零问题
所以请记住Memory时间线是了解
内存的使用情况和造成内存高峰的原因
这样你就知道该去哪里找问题
然后使用多个Heap快照在JavaScript Allocations时间线里
以便单独放大造成内存增长的代码
还有不要忘了删除takeHeapSnapshot
在代码运行之前
要记住性能所受的影响
是JavaScript Allocations时间线记录时产生的
那么以上就是新的时间线工具
可用在Safari 10的网络检查器上
我想你一定会爱上它们
在结束之前我还想再说几点
我要建议你们重新考虑下WKWebView
如果你还没有换掉它
在Safari设置里打开Develop菜单
连接网络检查器到你的应用
然后开始利用这些新功能
节省大量时间Bottom Up视图和Call Trees用于
找到最需要优化的地方
Memory时间线可以快速看到内存高峰的情况
Heap快照可以轻松查找和比较对象分配
时刻关注新功能的更新
今年网络检查器和WebKit有更多内容
可以让你利用应用的网页内容
来创造绝佳的应用内的用户体验
除了Brian和我今天为你们展示的功能
我们团队过去一年也为网络检查器添加了很多内容
Quick Open会让你直接跳到页面加载的资源
尾调用堆栈现在可显示调试器里的尾调用优化函数
初春的时候在OS 10系统下我们引进了Safari 9.1
并更新了网络检查器
它显示了Elements标签下DOM Tree里的Pseudo Elements
这里还有一个新的视觉风格边栏
可能你还没注意到
网络检查器是一个开发者工具
作为WebKit开源项目的一部分
WebKit是网页浏览器引擎用来支持你的应用
驱动WebViews和JSContext
当然它也是Safari背后的动力
在过去一年里我们为WebKit添加了好多新功能
我们对ES6100％支持
我们改进了对IndexedDBStandard的支持
还添加了Shadow DOM支持WebDriver和CSS变量
以及Picture Element
所以真的是很多内容而且作为开源项目
一旦有新的出现你就能知道
你们在座大部分人肯定都想能利用它工作
如果你们想对这些内容作出改进
完全有机会
因为WebKit是开放资源
你可在WebKit.org上找到更多WebKit项目信息
WebKit团队及其背后的工程师们会在博客上写他们的开发工作
实际上我们现在有两个博客
关于Memory时间线和样本分析器
就是今天讲的内容
所以如果你想了解更多可以去那里看看
我们还有一个功能状态页一目了然的列出了所有更新
针对网页标准进程
这里还有链接可以下载WebKit夜间建构
和最新的浏览器Safari技术概览
每几周更新一次附带更新的WebKit引擎
所以你可以在WebKit上尝试这些新的实验性功能
它们每两周改进一次
我们团队投入了大量精力给SafariWebKit和网络检查器
网络检查器团队可以使用这些新性能特性
就像我们今天展示的那样去查询问题并提高性能
对网络检查器本身
我已经迫不及待想看看你们会做些什么
想了解更多信息请观看这个演讲
在developer.apple.com下载幻灯片
这周的前几天有很多场相关演讲
过去几年也有不少
这些都能在developer.apple.com上找到
那么代表Brian 我自己和Safari与WebKit团队
感谢你们的到来祝大家在接下来的WWDC中过得愉快
优化应用的网页内容
大家好
欢迎来到“优化应用的网页内容”
我是Jonathan Davis
网络技术的推广人负责Safari和WebKit
现在我要先说明一些事情
很多人说我长得像Edward Snowden
但我向你保证 我不是他
但这么多卫星在头顶盘旋大概都是来抓我们的
除此之外 我很激动地要展示些新东西
它们可以帮助你提升应用网页内容的性能
我们一直都知道
性能是提供最佳用户体验的关键
若你是个应用开发者并在应用里用了WebViews和JSContext
而且你很关心性能那你就来对地方了
说到性能
在当今时代里性能其实就是指电池寿命
我认为电池寿命是最终的有限资源
它带来很不同的结果如果你能拨出最后一通电话
或者发出最后一份重要的文件在电池耗光之前
性能对用户来说事关重大
他们所选择的应用不会让设备变慢
而且耗电量低
我们的经验就是根据用户的反馈和各自的体会
性能很重要因为电池寿命事关重大
所以今年我们致力于提供更好的工具
来找到和修复网页内容的性能问题
现在我们为应用提供了工具比如Swift
还有Objective-C代码比如Instruments
我们还提供了网络检查器帮助网页开发者创建网页和网站
但不要觉得因为你选择了
在应用中用网络技术就没有其他工具可用了
实际上我今天展示给你的所有工具
就是开发给人们既能帮助他们建设网站
也能让他们在应用里用网络技术
那么我首先要向你展示
如何把网络检查器连接到JSContext的WebViews
这样在你需要它的时候它就会立刻出现
之后你会了解一些新的功能
它们能让你了解JavaScript代码如何分配时间
以及这些新功能如何帮你迅速找到性能上的问题
如果你想要看到网络内容的内存使用情况
我们也给网络检查器增添了新的时间线我都已等不及想展示了
它们会帮你节省很多时间来找到内存过大的问题
准备好了？那就开始吧
第一件我们要做的事
是把网络检查器连接到应用里
在应用里使用网络技术有很多原因
如JS context里的一些JavaScript模块
可以让你轻松交换逻辑并无编译地添加新的模块
可能有些人正在tvOS应用里使用TVML的 JSContext
另外一个使用网络技术的原因就是你要显示的网页内容
比如第三方网站的一个网页
这个网站你不能控制
可能就要用到Safari视图控制器
如果不是你也许可以去听听
去年的演讲“介绍Safari视图控制器”
但如果你显示的内容是你自己的或者你可以控制的
或是可自定义的HTML CSS或JavaScript编写的内容
或者是可以提升应用体验的内容
WKWebView是最好的选择
它实际上是个矩形把网页内容拉入应用
它引入了iOS 8和OS 10 Yosemite
若你还在使用WebView或者UIWebView
那你一定要考虑升级到WKWebView
事实上 升级到WKWebView可以让你利用
Nitro JavaScript核心引擎和四级JIT编译器
这能大大提升速度
若想了解更多WKWebView信息
我推荐2014年的演讲介绍了现代化的WebKit API
那么去年我们给WKWebView添加了很多优秀的功能
比如 加载文件URL和自定义用户代理字符串还有WK网站数据存储API
现今有了iOS 10和macOS Sierra我们改进了3D-touch支持
现在你的应用就可以执行这些好用的
Peek和Pop事件在WKWebView里
就像我之前说的因为你选了
在应用里应用网络技术
并不意味着你没有工具可用
不论哪种情况你可连接网络检查器
发掘网页内容或JavaScript活动情况
但使用网络检查器前你必须要激活develop菜单
只要上传Safari设置然后找到“高级”标签
然后在底部你会看到这个复选框
写着在菜单栏显示Develop菜单
那就点击它
Develop菜单就会出现在Safari的菜单栏里
为让网络检查器连接到iOS设备
你要开启一个设置
在iOS的设置应用里点击Safari
然后拉到底部 点击“高级”然后把检查器设置打开
现在你就可以把设备连到Mac上
在Safari里检查Develop菜单
Develop菜单里有些很酷炫的东西
你之前可能从未注意到过
就是你能看到设备的列表
这里有已连接的iPhoneMacBook Pro和模拟器
要连接一个设备并开始使用这些工具
进行调试那么只要选择Device菜单
就会收到 当前设备上运行的WebViews和JSContexts 的列表
这里的Mac应用并没有使用WebKit
而用JavaScript
所以我可以直接连接它并使用工具
iOS里的应用只会出现在用Xcode创建和运行的时候
但是说到Mac应用你还要做一件事
就是保持应用的完整性我们不会让任何人下载你的应用
并用网络检查器巡查你的应用
所以你要添加这个授权
到应用本地开发的授权文件里
你可能已经有了一个授权文件
如果没有创建一个也很简单
你只要创建新的plist拓展名为.entitlements
并且Xcode的创建设置里定义一个代码签名的授权传递路径
这个要在开发的时候添加
之后在运行应用的时候删除
一旦有了这个授权
你的设备和应用就出现在Develop菜单
这样就可以连接了
轻松把网络检查器连接到JSContext和WebViews上了
我们已正常运行了网络检查器和应用
该谈谈网络检查器里新功能了
我想首先讲讲分析JavaScript代码
分析JavaScript
JavaScript的分析器已经存在挺长时间了
今年它变得更好
更有效率能帮助你迅速找到
哪里调出的JavaScript成本最高
原因很简单
新的分析器采用了取样技术不会影响性能
比以前好太多
我们的分析器在编译器能用之前的时代
实际是个翻译器
但是现在我们有了这个强大的四级JIT编译器
那么这个分析器就真正成为样本分析器
样本分析器告诉你代码把时间都用在哪里
帮你解答哪个代码占用的时间最多？
它在运行程序中的取样以每毫秒为单位
并且短暂地停顿执行
并快照所有正在运行的代码
它还可以取样
在代码运行于JIT编译器所有四级的时候
所以它的取样速度跟你代码的实际速度差不多
由于断点处理会导致代码去优化
我们暂时不管它们
那么当你分析的时候你就可以了解网页应用的真实性能
使用样本分析器对性能几乎没有损害
这就意味着当你分析代码的时候
速度高达以前的30倍
这就让代码分析过程更快也更简单
而且收到的数据也更准确
这个进步真令人振奋 因为我们团队和网络检查器团队
能利用它来发现可以提升速度的地方
就在网络检查器本身
好了现在我们有了样本分析器
看看如何利用网络检查器帮我们找到问题
这个内容很多但是可以简单的拆分开来
更方便的是这都是你已经熟悉的代码
当我们说到分析JavaScript时
意思是在Events里为JavaScript记录时间线
这就是Events视图
显示了一列单独而且具体的JavaScript事件
特别的是这里都是D3库的代码
所以它能更方便调试代码
和分析代码在你正在使用的库里
而且这里的每一条都是代码运行的事件
这是代码进出JavaScript核心引擎的情况
包括了监听事件的回调
比如动画框架的条目是在请求动画框架处理器
脚本评估条目显示JavaScript文件
的上传和首次评估
这里还有一些时间信息
告诉你运行的代码所花费的时间
所以如果有哪个超过了10或15毫秒
你就快要打破
60帧每秒的流畅性能底线
Events视图很有用但是还有另一个视图
是我们为你添加的叫做Call Trees视图
如果你用过其他分析工具那么对这个应该很熟悉
只要点击这个菜单然后转换到Call Trees视图
现在显示了调用堆栈里函数的累计运行时间
这个叫做Top Down视图
你可以用它深入发掘Call Tree
来找到耗费大量时间的热函数
但我最喜欢的视图是Bottom Up视图
它能直接让我找到最热的函数
就是取样最频繁的函数
这里罗列的是调出的函数
按照用时从大到小分类
它反转了Call Tree让你能直接对比各个函数的耗时
你能准确地看到耗时最多的地方
你可以展开这一条并按照路径返回
找到耗时最多的函数
你就能知道这个成本最高的代码是何时何地调出的
那么关于这部分有请我的同事
Brian Burg上台为大家展示
谢谢你 Jon样本分析器很好用
因为它可以提取十分复杂的内容
并进行分析让你看到十分精确的信息
而且你可以让它跑的更快
为了给你们展示我要用我制作的iPad应用
叫做卫星跟踪器在这里看看
卫星跟踪器会展示给你现在或任何时间
卫星所在的位置
你可以选择地球上的不同地点
也可以选择不同的卫星
不同的时区
这很棒吧
如果你担心头上盘旋的卫星
要带个锡纸帽子以防万一这个应用就是理想之选
但是这里有个小问题
如果很多卫星或者很多卫星组件
像这样挤爆了那么帧率的波动会很大
这肯定不是60帧每秒
它会一直波动
这样就可以用样本分析器来查找
发生了什么为什么这么慢
我们要做的就是打开Safari并进入Develop菜单
找到这里的iPad并连接上
那么我要做的第一件事就是进入Frames视图
看看现在的位置帧率如何
那么开始记录
我再转回iPad
做点什么
比如转动一下
或者换一个卫星
换个时区
好了现在回去看看
好的把这个缩小
所有的性能就都显示在这里了
有的时候是60帧每秒像左边这些
在中间则上下都有
因为我们在更改视图
这一些就太慢了
我想知道出了什么问题
那么我就转到Events视图
点击JavaScript和Events时间线
重点看看样本分析器的数据
就像Jon之前演示的那样这里的Events视图
会显示所有运行循环里的内容
这个例子里就是动画和模拟
就是我们在不断地渲染帧
这不是很有用因为无法找到耗时最多的地方
那么我们转到Call Trees视图
这里我们看到Top DownCall Tree
集合显示了所有的渲染帧
都是最耗时的地方
展开这个就能看到D3有一个Timer函数
它调出一些代码画了一些场景
这些场景包括卫星
和时间等
这个很棒能让我们了解代码在做什么
但是如果要想找出哪个函数最耗费
最好还是去看Bottom Up视图
这里我们列出了所有函数无论谁调用它们
我们看到这个fillText
和tangent是最耗费的两个
那为什么会调出tangent呢？
我们展开这一行看看调令来源
就在这里是_plotSatellites
好像正在计算转换用来绘制地球
好的这些看着都很正常
也许我该找出数学课本让它算得快一点
现在看看fillText
换个画面回到这里的应用
我们正在当前时间上绘制文本也在每个数据点上绘制
这说得通
但是如果仔细看我们实际上把这个时间画了两次
这就有点奇怪
所以我们展开这一行
就能看到调令来自哪里
这里我们好像一次画了两个不同的前景
这大概不是我们想要的
那么来找找哪儿出了问题
如果像这样画了两个前景
那么我们的工作量实际就是所需的两倍
为了让你的记忆更清晰记住我们有个平面地图
然后有这个地球它在转动
那么现在回到代码
找一找是什么控制着两个地图的切换
估计哪里弄错了
改变地点的时候我们会让两个地球互换
这是 updateLocation
好的 因为已经有一个地图就不再需要另一个
这是有道理的因为这里我们添加了隐藏类
就为了不让它显示出来
这里在_globeMap我们定义running值为真
在整个运行中
而且在place中声明我们显示的不是_globeProjection
这是对的
当我们显示平面地图
我们不会显示地球它也不会运行
这个平面地图看上去好像
一直在运行UI也在运行
这也挺奇怪的
那么我们回到地图试着做点儿什么
这里我们选择这个数据组
然后进入Earth
它的帧率要好于只做世界地图
那么这就很有道理
我想我们在世界地图活动的时候画了两张地图
但是在平面地图的时候只画了一个
那么我们就在这里改变这个条件
糟糕应该反过来
好的 先停下看看有没有修复
回到iPad
好的这看上去很流畅
来到这里
恩 很好
看上去不错
那么我们再去检查时间渲染
看看是不是60帧每秒
那么回到Frames视图
然后开始记录很不错
我转动地球的时候有点慢
但稳定度看上去...
不错绝对在60帧每秒以下
在这里有一个条只要低于它就是好的
现在卫星跟踪器快了很多
我们就知道什么时候带上帽子
这很棒
这就是个简单的例子关于如何使用样本分析器
来发现最繁忙的内容并让它运行的更快
下面Jon会跟大家讲讲内存和分配
谢谢 Brian
你看到了分析很迅速
它能让你了解代码的真实速度
这样你就能获得十分精确的数据
再看看JavaScript和Events时间线
并用它们找到缓慢的回调处理器和定时器
或者在Events视图里缓慢的脚本初始化
请用新的Call Trees视图来了解耗时
因为它们会沿着你选择的时间线堆积起来
记着Bottom Up是你的新朋友
它能帮助你找到最需要优化的地方
那么现在我们已经看过了新的样本分析器
和新的JavaScriptCall Trees视图
我很激动能用更好的工具来优化CPU时间
这样就能给用户快速的体验
并帮他们节省了电池
这真的不错现在我们继续
看看性能的另一方面
就是了解内存都去哪儿了
你肯定想更有效率地使用网页内容的内存
因为这是有限资源
有效地使用内存可以优化网页内容的比例
并能处理大型数据组
而且内存占用过多会降低性能我们并不想这样
它也会让你的网页内容崩溃
这更非我们所愿
好消息是若你运行WKWebView它会以单独的进程运行
不会让整个应用崩溃
但是这仍然不是一个好的用户体验
为了帮你解决这些问题我们添加了两个新时间线
给网络检查器和Safari 10
当启动新网络检查器新时间线就默认关闭
所以要打开它们
你只要点击Edit就在时间线上面
就可以配置自己想看的时间线
这样就可以只研究自己想用的那个
就和Instruments应用一样
只要开启新的时间线就可以记录新的时间线了
但你可能不想让它们同时运行
JavaScript和Events时间线样本分析器
虽然负载较少但还是有
而JavaScript Allocation的时间线会添加更多进程
在垃圾回收过程中这会影响性能
那我们就一直开着Memory时间线
那么在记录一个时间线的时候你会看到这个
这个新的Memory时间线图表显示了内存如何分配
到不同的目录里在不同的时间
这里有一系列图表
帮你了解内存的使用和划分
Breakdown表显示了内存如何分配给
JavaScript和图画和构成页面的分层
以及其他引擎相关的网页
Max Comparison图帮你研究内存高峰
这里有一个高的水印
帮你观察过去的内存问题
你甚至可以分离各个峰通过选择一个特定的部分
或者在一个峰值周围选择一个特定的时间段
然后你就可以使用下面的目录分类
来看看是什么造成了大部分高峰
这里的每个图表都是独立测量的
所以你可以清楚地看到不同时间的变化
JavaScript里的峰值显示的是
大量新对象被创建和引用的地方
其中包括的对象有字符串对象和函数
以及所有支持它们的引擎数据比如结构数据和编译代码
当你看到JavaScript的用量下降
就是说垃圾回收在回收内存
图片显示了分配给图片的内存
这些图片都通过解码显示
这里的图片数据比较大
通常用于可以在视口显示的图片
层显示的是图层内存
分配在WebKitstileGrid复合层
和其他引擎层
页面就囊括了所有其他的东西
引擎所追踪的所有内容
比如DOM和页面风格以及字体渲染数据
内存缓存和系统分配
所以这个分类能让你很好的保证
内存用量符合你的预期
若你有很多JavaScript内容你要明白
JavaScript会是分类图表里用量最多的一类
在时间线图表里你可能会随着时间看到更多变化
但是对于多图片的页面比如画廊
那么分层和图片目录就可能是最大的
随着时间变化也更多
这就是Safari 10里最新的Memory时间线
Memory时间线的补充就是新的JavaScript Allocations时间线
你不仅能看到不同时间里内存的变化
还能更细的探究
JavaScript Allocations的真实情况
对此我们有个强大的工具JavaScript Allocation Snapshots
快照的强大之处
是你可在JavaScripts堆里对一个时刻进行快照
然后你就可以深入看到所有被分配的东西
但是更强大的是你有两个快照的时候
你就可以回头再看并进行对比
对比快照是我们最强大的工具之一
它可以解答我是不是做了不必要的分配？
一定要利用它因为你需要多个快照
这也就是为什么默认每10秒照一次
不仅要在记录开始还要在结束
快照是在时间线上设计的所以它们能连到
其他时间线上发生的事情
在这里其他的都被我关了
这些快照在下面列出并附了一些细节
比如堆的时间和大小
要了解一个特定的问题
就通常需要在开始和结束的时候快照
围绕你认为内存会出问题的地方
这里有三个技巧
你可以依赖自动快照每10秒一次
或者可以亲自快照就按快照键
或者用代码执行
最简单的找到问题的方法还是改代码
调出takeHeapSnapshot API
传递一个自定义的标签参数它可以是任何
之后能帮你识别它的东西
还有你要做一对快照
在你认为导致问题的代码的前后
你还可以通过快照来使用这个代码
在一个循环内的工作之间
分析内存
下面讲讲要时刻牢记的几点关于takeHeapSnapshot API
要记住快照会增添一些额外的进程在垃圾回收进程中
这会影响性能所以你一定要注意
你的代码是否频繁的发射快照
你也要捕捉到前后不同的信息
当代码在一个循环之间的某个时刻运行时
不要留下这个
如果你把它留下对大部分用户来说没问题
但一旦有人运行网络检查器它们就会使用所有的快照
你大概也不想这样
所以要记住在启动前一定把它们删除
那么这些快照都显示了什么？
让我们来看一看
你只要点击时间线上的快照图标
或者在快照列表条目里点击Arrow按键
你看到的这一列对象都是之前分配在堆里的
快照有两个视图
这是Instances视图
展示了堆里的对象列表按照类来分组
另一个是对象图像视图
这实际上概括了所有东西
所有的所有
如果你很熟悉这个代码
它就能很好地帮助你确认事情或者找到相应的位置
但是实际上更有用的视图
是在Instances视图里
它的强大在于你可以轻松地找到对象
不论他们在属性路径里藏得多深
这里的Count可以帮你意识到潜在的问题
就是它们无法达到预期的时候
比如我能否实现4000多个字符串对象？
你可以展开这个Classes来看看所有分配到这里的对象
然后判断什么是什么通过这么多不同的线索
Class是一线索
另外就是对象的实际属性
这能让我们很快了解什么是什么
但是最简单的了解对象的方法
就是悬停在这个对象识别器上你就会看到这个
这里实际上显示的是到对象的最短路径
它告诉了你究竟是什么让这个对象保持活动
它基本上总会给你你需要的答案
特别是在JavaScript的垃圾回收里
这就是能立刻解开疑惑的方法
但是它最重要的功能和最关键的要点
在于它能比较两个快照
看看这个当你已经收集了一些快照
只要点击此处“比较快照”按键
然后选择Baseline快照再选一个对比
一下子
你就有了一个新的对比快照可以研究
这个十分有意义
因为现在只能看到新的对象
在两个点之间在两个快照之间
展开对象类分组可以看到所有的对象分配
预览中显示了它们的名字和类似遥测数据的东西
这里就说明它是卫星对象
这里的弹窗显示_Satellites Array属性
由于这是一个快照对比
卫星的对象都是新分配的
这是个很重要的线索显示代码在做什么
那么为了让你们实际看到这些新的存储功能
我要有请Brian回到台上来做另一个演示
谢谢 Jon
我把卫星跟踪器给了我的朋友Ed
他熬了一夜在玩这个
他很开心因为他从来没有被卫星跟踪过
但是这就有个问题
它运行时间越长最终会变得越来越慢
这在我看来很像传统的内存
打开时间越久就越慢
我想在卫星跟踪器里用这些新存储工具来看看
我们是否泄漏了一些内存
那么第一件事
我的iPad在这儿
我要回到网络检查器...
并且检查这个应用
我要做的第一件事
在我不知道问题在哪儿的时候就是要使用Memory时间线
它会告诉我页面上大概发生了什么
那么我们开始记录
转回来
我在两个卫星之间来回切换
也许我会在这里添加一些效果
好的我在来回切换
好了现在去时间线看看
在时间线概览中你看到一个堆积线形图
显示了所有不同的部分和相关的大小
如果你点击这里会看到更多的细节
那么这个页面上没有图片
都是画布
分层也很平面
页面有些波动有些内容在垃圾回收
没有问题
如果你仔细看看JavaScript你会看到...
虽然有些东西被垃圾回收
但是整体来说它还是在随着时间堆积
如果我们运行一整晚那估计会堆积更多
下一步就是启用heap快照或allocation快照
这样我们就能找到随着时间而分配的内容
为了实现这个我们要开始新的记录
这有个快捷键Shift 点击或Shift 空格
这样就会启动新的记录而不是继续之前那个
等等我忘了改时间线
去掉Memory
选上Allocations
好了开始记录
回到iPad
添加了小小的takeHeapSnapshot键
我已给控制台添加了一些takeHeapSnapshot的调令
用于切换两个卫星小组和其他操作
对这个记录我要转动地图
然后不断在两个卫星中切换
我们还要看看Spy Satellites看上去也有关联
好了 你会发现开始有点卡了
因为我们给JavaScript堆里的所有东西拍了快照
因此产生了很多对象
这会大幅降低应用的速度
所以一定不要拍很多快照
只在重要的时候拍
这里你可以看到方块里的S就是我们拍的快照
放大一下能看到
随着时间过去内存十分稳定的增长
当我们开始在两个卫星之间切换的时候
如果我们要研究这个像Jon说的那样
我们就要启动对比来看看是什么被拦住了
那么我们就对比快照9和11
立刻我们就看到很多东西
被分配在9和11之间并且仍然在活动中
这就清楚地说明了它们被留存了
虽然我们并不想这么做
那么我们来看看这些都是什么
这是些阵列
看上去这个阵列里全是坐标
你知道在应用的不同部分我们会用大量的坐标
但是如果我们停在这里就会看到它的路径
它们好像是被保存于trajectoryHistory
这是我们用来制作追踪卫星的东西
好的这样不错
但是我想不应该
再在已不显示的卫星里用trajectoryHistory
这好像是个bug
我们也分配了一些对象
但奇怪的是在快照9和11之间
我们之前已经看到这些卫星
那么我就不想再给每个卫星创建新的对象
我们只要直接使用它们只要我们已经为他们获取了资源
然后这里有了很多坐标和遥测
好像正在重新解析什么
我不太确定那么...
在这个视图里我们有很多对象
你不能读取所有
所以我想做的就是找出很特别的那一个
那么在这个快照里
我们有很多字符串阵列和对象
但只有一个Promise
它停留在两个快照之间
所以我认为应该调试这个
那么我就找到代码看看是哪里在用Promises
因为好像它与别的什么一起被泄露了
于是搜索Promise
好了 这是D3库这是使用它的代码
好的来看看这个
好了 在［听不清］里我们常常在卫星之间切换
代码是loadDataset
有人写了评论太好了
这里看上去好像有人请求我们改变卫星
那么这里就可以异步从URL下载数据
当它返回我们就要解析
然后使用卫星绘图库 做更多的解析
然后我们把它存到卫星列表上
这都很不错但是回到检查器
我们好像每次都泄露该Promise
如果你更仔细的想想
如果切换到已经下载的数据组会怎样？
我们甚至都没有检查过这个事情
你仔细的看看这里
每次在两个卫星之间转换
我们就发出一个新的网络请求
如果我们进入这个时间线
就会看到我们在不断请求同样的垃圾数据
这是正常的如果回到代码 发出请求
解析的时候会产生大量的对象
然后我们把它推入卫星阵列
就目前来看它怎么都不清楚
我们好像一直在做无用功然后不断泄露
所以这里我们要做的
是检查我们是否已经解析了这个卫星对象
因为这是Promise
如果它确实存在我们可以调出.then
由于这已解决下一次评估Promise的反应时
它就会进行检查并将卫星放到地图上
那么在这里添加代码
如果不存在我们就创建一个
好了 现在停下来看看有没有效果
我们就要回去重新连接
这是我们的应用开始记录吧
当我们回到应用我就打开快照
打开一些效果
然后往南走
好的 间谍卫星
卫星的科学实验
科学实验
好了
如果我们回到这里我们看到内存的增长大大降低
大概在1兆而不是四五兆
那么这里可能有更多的泄露
但是在快照结束的时候我们的内存
跟刚开始渲染的时候一样大
这样我们就修复了这个特殊的泄露
这就展示了我们如何使用Allocations和Memory时间线
来解决像这样的应用的内存泄露问题
这很不错因为应用可以用更多的操作
有了diffing功能
我们就可以深入观察我们所关心的卫星里的变化
好了卫星跟踪器就讲到这
你回来吧 Jon
谢谢 Brian
你看到了真是不可思议的迅速和简单
这些新的时间线让内存零问题
所以请记住Memory时间线是了解
内存的使用情况和造成内存高峰的原因
这样你就知道该去哪里找问题
然后使用多个Heap快照在JavaScript Allocations时间线里
以便单独放大造成内存增长的代码
还有不要忘了删除takeHeapSnapshot
在代码运行之前
要记住性能所受的影响
是JavaScript Allocations时间线记录时产生的
那么以上就是新的时间线工具
可用在Safari 10的网络检查器上
我想你一定会爱上它们
在结束之前我还想再说几点
我要建议你们重新考虑下WKWebView
如果你还没有换掉它
在Safari设置里打开Develop菜单
连接网络检查器到你的应用
然后开始利用这些新功能
节省大量时间Bottom Up视图和Call Trees用于
找到最需要优化的地方
Memory时间线可以快速看到内存高峰的情况
Heap快照可以轻松查找和比较对象分配
时刻关注新功能的更新
今年网络检查器和WebKit有更多内容
可以让你利用应用的网页内容
来创造绝佳的应用内的用户体验
除了Brian和我今天为你们展示的功能
我们团队过去一年也为网络检查器添加了很多内容
Quick Open会让你直接跳到页面加载的资源
尾调用堆栈现在可显示调试器里的尾调用优化函数
初春的时候在OS 10系统下我们引进了Safari 9.1
并更新了网络检查器
它显示了Elements标签下DOM Tree里的Pseudo Elements
这里还有一个新的视觉风格边栏
可能你还没注意到
网络检查器是一个开发者工具
作为WebKit开源项目的一部分
WebKit是网页浏览器引擎用来支持你的应用
驱动WebViews和JSContext
当然它也是Safari背后的动力
在过去一年里我们为WebKit添加了好多新功能
我们对ES6100％支持
我们改进了对IndexedDBStandard的支持
还添加了Shadow DOM支持WebDriver和CSS变量
以及Picture Element
所以真的是很多内容而且作为开源项目
一旦有新的出现你就能知道
你们在座大部分人肯定都想能利用它工作
如果你们想对这些内容作出改进
完全有机会
因为WebKit是开放资源
你可在WebKit.org上找到更多WebKit项目信息
WebKit团队及其背后的工程师们会在博客上写他们的开发工作
实际上我们现在有两个博客
关于Memory时间线和样本分析器
就是今天讲的内容
所以如果你想了解更多可以去那里看看
我们还有一个功能状态页一目了然的列出了所有更新
针对网页标准进程
这里还有链接可以下载WebKit夜间建构
和最新的浏览器Safari技术概览
每几周更新一次附带更新的WebKit引擎
所以你可以在WebKit上尝试这些新的实验性功能
它们每两周改进一次
我们团队投入了大量精力给SafariWebKit和网络检查器
网络检查器团队可以使用这些新性能特性
就像我们今天展示的那样去查询问题并提高性能
对网络检查器本身
我已经迫不及待想看看你们会做些什么
想了解更多信息请观看这个演讲
在developer.apple.com下载幻灯片
这周的前几天有很多场相关演讲
过去几年也有不少
这些都能在developer.apple.com上找到
那么代表Brian 我自己和Safari与WebKit团队
感谢你们的到来祝大家在接下来的WWDC中过得愉快