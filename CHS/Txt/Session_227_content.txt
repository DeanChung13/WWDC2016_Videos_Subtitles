watchOS 3性能架构设计
大家下午好 欢迎来到watchOS 3性能架构设计
我是Tyler McAtee
稍后你会看到我的同事Todd Grooms
今天我们会讨论在Apple我们思考性能优化的方法
和我们怎么样创建watchOS 3
我们从2-Second任务开始说
它是什么 它对watchOS 3的设计有什么帮助和影响
对你的应用架构意味着什么
我还会讨论一下设计策略是怎么影响性能的
同时展示一个新的详细分页API
它可以减少不必要的导航时间
最后 Todd会上台展示我们如何
利用这些想法并应用到watch股票应用上
我们从2-Second开始
我们专注于这个理念作为经验法则
和Apple Watch交互感觉是怎样的
什么是2-Second任务
2-Second任务是用户想要完成操作
或看Apple Watch而学习
这些任务应该在几秒内完成
这几秒应该从
开始交互到结束衡量
从用户抬起手看Apple Watch开始
到他们放下手结束
一些2-Second任务的例子可能是这样
查看通知 设定定时器或者开始锻炼
今天我们会了解下
我们对系统做的一些重要变动
解释这将怎么影响开发者
思考你的WatchKit应用的性能
完成一个Apple Watch任务的第一个瓶颈
是访问到相应应用 花费的导航的次数
Apple Watch上打开一个应用最快的方法
是通过点击一个complication
只鼓励开发者实现一个complication
如果他们有相关数据去显示
大多程序 例如信息 邮件和手机并没有complication
为了增加Apple Watch的可操纵性
和同时给用户提供更多选择去定制化
现在在watchOS 3上应用都有complication
这些启动complication对于从表盘上快速访问
你喜欢的应用是很有用的
对于你的应用我们也鼓励你去适应这个规则
实现一个complication无论是否有数据显示
新的watchOS 3中我们为你带来了dock
通过按压侧键开关用户可以调用dock
且快速浏览所有他们最爱的应用程序
浏览这些应用程序是非常快和容易的
我们想要我们的用户能够使用这些最爱的应用程序
并且使他们准备好加载好
而不是必须等待
因为这个应用已开始运行了
在watchOS 3中为了记录这些所有的应用程序
一个用户选择放在表盘上或者在他们的dock中
应用将在系统中保持运行或暂停在内存中
这样当他们和应用程序交互时
他们只需等待恢复 无需重新启动
但是系统只有固定大小的内存
并且在一个在系统中应用需要成为一个好的公民
因为最多可以有10个dock应用5个complications
同时还有系统应用 进程等等
你要记得你仅是庞大生态系统中的一部分
因此你需要尽可能只用你需要的资源
这个系统 因为生态系统的自然性
我们的系统提高了固定内存数量的上限
一个WatchKit的应用可使用的量
如果应用超出这个限制
我们的系统将会终止应用连哭的机会都不给你
因此内存可以被其他的程序使用
限制不是目的
尽量别用光内存
事实上 它应该远不及限制
现在在watchOS 3上的限制是30兆字节
每个WatchKit应用程序但这个将来可能会改变
所以有什么好的技巧控制应用的内存使用？
用合适于watch屏幕尺寸的图片
这个不仅可以控制内存使用
而且将会有助于提高整体性能
{\an2因为这让watch不用做额外去调整图片大小的工作
用大小合适的数据集不要去下载大量的数据集
如果你只显示很少的数据在屏幕上
如果你只显示一个数据对象的属性
不要下载或保存其他属性
如果你能控制API下载数据
让我们看这个简单的应用
因为watch将可能显示
一个更浓缩的信息版本
这将会帮助节省大量的网络流量
你的watch会处理它
瞬时数据和内存也会减少
最后 重要的是释放你不再使用的对象
花些时间过一遍你的代码
并且确定你只保存必需的东西
因为用户选择的应用放在他们的表盘上
或者在dock中 系统会让它们保持存活和悬挂在内存中
它们更多的是被恢复而不是被启动
因为这个 对于watchOS 3
我们想要集中优化的关键是恢复时间
现在应用程序将不经常被恢复
因为它们将被保存在内存里但也因为它们在dock里
当用户在dock栏中滑到你的应用
应用会被恢复
当用户滑过应用应用将会被暂停
这种经常恢复和暂停的行为
是watchos3中应用典型的方式
理解软件生命周期中哪一个方法
用来做主要工作
哪一个用来做不重要的工作很重要
来看一下不同的生命周期方法
在watchKit扩展代理会遇到
你的代理中看到的第一个方法是ApplicationDidFinishLaunching
当程序第一次运行时 它将会被调用
并且这是一个不错的地方来执行应用应用的最终初始化
像其他任务一样 这只需要被执行一次
在你的代理中接下来看到的是
applicationDidBecomeActive
只要你的应用在系统中变成活跃应用 这个将会被调用
重新开始任何一个之前被暂停的任务
或者没有启动 只要有需要将会刷新用户界面
一旦应用从活跃变为非活跃状态
applicationWillResignActive会被调用
这可能因为某些类型的临时中断而发生
例如一个打进来的电话或者通知
当用户按下侧键来唤醒dock时
或者当用户退出你的应用时
并且它将会过渡到后台运行状态
当你的应用不再活跃并且被调到后台
applicationDidEnterBackground将被调用
当你的应用返回到前台时
applicationWillEnterForeground将会被调用
这些函数只有在程序从后台到前台时才会被调用
或者当程序从前台到后台所以在程序第一次启动时不会被调用
另外 有些生命周期方法和接口控制器相关联
AwakeWithContext会被调用
在你的接口控制器第一次实例化的时候
这是一个好位置对那些只需要做一次的工作
当界面激活时willActivate将被调用
或者能够更新的时候它将会被调用
在界面对于用户确实可见之前
一旦用户完全看见界面
didAppear被调用
如果你有在恢复时需要做的工作这些方法是是合适的位置
如果需要做的比较多 你最好
把任务分发到后台的队列
这样这些方法可以完成并且你的应用能够完成恢复
一旦你的应用暂停了
在接口控制器中willDisappear将被调用
当用户界面不再对用户可见时
或者用户界面无效并且不再更新
didDeactivate将会被调用
这些方法是取消任何繁重任务的地方
你在willActivate和didAppear中启动的任务
理解这个生命周期非常重要
并且明白这些方法可能被重复频繁的调用
我想通过一个例子
一个程序是怎样遇到这些事件在它的生命周期中
我们将会从一个程序开始为了这次课程的目的
程序在前台和后台都没有运行
当用户点击你的应用
第一个方法将进入到WatchKit扩展代理中
didFinishLaunching和didBecomeActive
还有接口控制器将会接收到awakeWithContext
willActivate和didAppear
现在你的应用正在前台运行并且是活跃的
但是当用户按下侧键开关调出dock时会发生什么呢
此时你的应用不再是前台活跃的应用
这是系统应用
所以你的代理将会调用applicationWillResignActive
当用户继续选定你的应用
程序将会在前台一直运行一直在被CPU执行
更新用户界面
一旦用户滑走你的应用
系统将会悬挂你的应用
所以你的界面控制器将会调用willDisappear和didDeactivate
并且应用的didEnterBackground会被调用
现在这里你的应用刚进入后台
因此系统可能唤起你的应用
为了一个后台快照任务
了解更多这些快照任务看看我们今早的课程
保持你的watch应用持续更新
你的设备接口控制器被willActivate和didAppear激活
在你的代理把机会给handleBackgroundTasks之前
然后你的接口控制器会调用willDisappear和didDeactivate
现在你的应用被完全暂停并且应用将执行它的后台任务
一旦用户滑回你的应用
程序将会调用applicationWillEnterForeground
还有willActivate和didAppear
你的应用再次运行同时进入dock的前台中
直到用户点进你的应用
你的应用才会变成前台中活跃的应用
并且调用applicationDidBecomeActive
从用户进入到dock时发生了大量的事情
自从用户滑出应用又滑回应用
这就是为什么理解程序的生命周期很重要
就像用户浏览他们的dock
你的应用可能重复频繁的遇到这些事件
还有什么其他技巧能缩短恢复时间
你应该用discretion当更新WKInterface对象时
你每次给WKInterface对象设置一个属性
系统会创造一个信息来发送
将它打包 并且分发到应用进程中UI正在被更新的位置
那可能是临时的在你的应用上来建立一些方法
更新应用的UI且在每次恢复的时候调用
但是设置每一个属性需要花费时间
哪怕属性不会改变
这导致了在应用和扩展间不必要的沟通
仅设置这些属性是值得的
若属性变了那你必须这么做
你需要注意WKInterfaceTable和UITableView的不同
手机有大量的内存来存储大量的信息
UITableView做了专门的优化
当在这些比较大的数据集上快速滑动时
cells被按需创建当你滑动时会被重新使用
然而用WKInterfaceTable
所有的cells被提前创建并且不会被重新使用
所以watch需要做的工作
和表格的大小呈正相关
由于这个原因控制WKInterfaceTable的大小非常重要
watch不合适这种类型
翻阅数以百计的记录
事实上 我们发现最好
WKInterfaceTable大小保持20出头
你的应用应该避免重新加载一个WKInterfaceTable
无论如何
这是一个耗费资源的操作
它可能尝试重新加载整个表
在恢复或数据集改变时
但若你需要添加或移动一些行
最好用插入和删除API
我现在想谈一些设计方面的
想想适合watch的信息展示方式
好的展示方式对性能也很有帮助
在watchos 3中你应把应用设计成可以扫着看的
dock让用户可快速访问收藏的应用
你的应用可能只会被大体的扫一下
当用户从一个应用滑到另一个的时候
集中显示最重要的信息
并尽量清晰的显示
根据特定的目的来设计可以让应用变得更利于扫视
watch不是合适的载体
对于浏览大量的内容
或者查看复杂的数据继承
通过仅展示最基础的信息
同时你会得到更好的性能
由于你展示更少的信息可以节省处理器和内存
同时保持更新时需要更少的网络请求
最后 导航也很重要
我已经讲了很多关于我们如何在系统层面提升导航了
在应用层面考虑这些同样很重要
为了帮助实现这些我们引进了一个新的
详细分页API
WatchKit应用的一个标准配置是继承数据视图
你有一个表格
点击其中一个单元进入这个项目的详细
这种设置的问题是
如果你想浏览多个项目的详细
你需要后退好多次
为了解决这个问题新的详细分页API
可以让我们快速的浏览从一个详细视图到另一个
通过从屏幕上滑动或者旋转数字表冠
为了了解在代码中如何设置这些API
同时学习其他快速交互技术
我们向开发者发布的
请查阅昨天的“watchOS快速交互技巧”演讲
在本次演讲中 我想说说这些API
的视图控制器生命周期
从视图的性能方面这很重要
所以这里我们有一个有三个单元的表格红的 橘黄的 黄的
详细分页API触发segue
从内部表到接口控制器
当你点击其中的一个单元我们会触发一个segue
当你点击这个单元你的主接口控制器
将会调用contextForSegue:withIdentifier:inTable方法
你可以在这里创建上下文对象传递给
详细视图控制器和awakeWithContext方法
你的主视图控制器不会只接到它的调用
你点击的单元而是表格每一个单元
我们为每一个详细视图控制器都准备了上下文
所以当我们准备上下文的时候
我们可以提前实例化
那样的话 当用户点击第一个的时候
可以在所有的单元间快速的滑动
你的第一个视图控制器
会是第一个调用awakeWithContext
包括willActivate和didAppear
这个是滑动试图最有意思的部分
我们让控制器接近这个选择的详细视图控制器
然后用户可以滑动到下一个
其他的颜色进入他们的生命周期方法
会一样调用
他们会首先调用awakeWithContext
然后是willActivate和didDeactivate
如何设置工作很重要
对那些还没有渲染的视同控制器
不要盲目的启动耗费CPU的任务
这可能导致CPU处理不过来
如果你有很多表格单元的话
当用户从一个详细视图滑动到另一个的时候
你之前的接口控制器会是第一个调用willDisappear
willActivate didDeactivate和didAppear
这使你的接口控制器维持一致的状态
那些最近展示到屏幕上的调用didAppear
那些最近离开屏幕的调用didDeactivate
当你点击后退
回到主控制界面 只有一个控制器
需要用生命周期方法调用它并且它是可视的
应用调用willDisappear和didDeactivate
当然 我想要邀请Todd去谈论这些
我们如何应用这些想法到我们的Stocks WatchKit应用
谢谢
下午好
我是一个watch OS的工程师
我们把Stocks作为一个案例研究面向WatchKit和开发者
你们中大多数可能不知道这个
但Stocks是用WatchKit建立的watch应用
在Apple我们想要有第一手的经验
在WatchKit开发中我们感觉Stocks
将会是WatchKit开发中一个很棒的应用方案
今天我有三个想要讨论的主题
关于Stocks和WatchKit开发
我将要去分辨Stocks中的2-Second任务
之后我将要讨论一些实现的细节
在我们的后台刷新用例中
最后 我将要说一些关于我们做的优化
通过扩展优化恢复时间启动时间
因此 我们将从2-Second任务开始
我们思考Stocks时
我们想到三个重要的2-Second任务
第一个是你很可能喜欢想要看的
一个最爱的股票现在的价格是如何的
这可以用一个complication实现
但是在dock
我们能够得到一点2-Second任务的细节
特别地 我想到另一个2-Second任务
想看看你最爱的股票的流通表现
通过日线图
最后 我们认为很重要的是 你能看见
一些股票的当前价格
我们从complication说起
当然 complication是最快的
在你的watch上察看数据的方法
数据总是最新的
你每次从watch上看时间也能看到它们
这里最重要的一点在watchOS 3中
是数据在complication和应用之间是同步的
想要了解更多的信息
可以去看看“让你的Watch应用保持更新”的演讲
今天早上开始的这个课程
现在我们将要开始讨论
一些其他的2-Second任务是如何在watchOS 2表现的
所以在watchOS 2中你可以启动Stocks
并且你可以看到现在的股票价格
你感兴趣的或者其他的股票
如果你想看到其他其他的股票在一天中的表现情况
你需要点一下那个股票现在你可以看见了
这是一点小信息但是它还是没有回答
一天股票价格是怎么被展示的
所以 如果你想知道
你得向下滚动一点现在你在图表上了
我们有四个选项 关于这个列表我们有一天的间隔
一周 一个月 半年
你第一次可能滚动到这里
你甚至不能看到你关心的间隔
那可能是一天的间隔
因此这需要你点击这些小按钮
并且打开那个图表
之后
你将从下面获取其他的元数据
其实大量的时间并不是必要的
当你瞥一眼今天的信息
当然 如果你想看多个股票
他们一天是如何表现的
你得向前浏览 点进一个新的去
很像刚刚Tyler在动画中给你们展示的
让我们看看watchOS 3
这是新的watchOS 3设计正如你看到的
首先 仍然是一个你们可以进入的列表
但是字体变大了 更易读了
一点简化的接口
对我来说很好并且小字体也很容易读
像你在dock中看的
如果你想看看apple今天怎么样
该怎么操作你会再一次点击Apple
但现在你在那里看到了表格
同时我们假设你总是想看日线图
也有例外 没有日线图
像基金没有日线图
我们可以回退到一个月的图表
当我们浏览它
这可能是你更期望的一目了然的间隔
我们同时去掉了下面分钟的详细信息
这让我们获得两个好处
一个是 去掉了一个网络请求加快了加载性能
第二个是 我们可以使用新的垂直详细分页API
那样的话 你可以浏览多个股票
可以通过旋转数字表冠或者用手指轻扫
当然 如果你想查看股票的详细信息
像以前的分钟信息
比如52周最高 52周最低
你可以使用Handoff
通过Handoff
你可以设置一个上下文然后把它转移到iPhone上
所以我们感觉watch是大体浏览数据的地方
iPhone才是浏览 像一个视图
详细和复杂的数据的地方
好的是新的设计 像我刚才说的
在dock上是易读的
通过dock
我们决定重新评估对于股票我们应该在dock显示什么
如果你参加了其他的一些课程
你会注意到有一个理念默认状态和一个快照
这表示这应该是一个粘性的视图
粘性的意思是当你离开股票应用时
如果你正在看股票列表
当你回到股票 无论从dock中或者
通过应用进入
你还会看到股票列表
这个视图我们会持续更新
在这一天中
然而 如果你点击进入股票详细
然后返回dock或进入应用
你将会看到详细视图
这里有一个需要注意的地方
在股票中你设置complication股票
你可以看到的股票在你的complication
我们这么做是这很可能是你喜欢的股票
一旦你设置了它
这将是我们返回给你的详细视图
如果你打开股票
你从Apple浏览到Facebook
然后回到桌面
差不多一个小时内
当我们返回快照默认状态标识时
我们会回到Apple的股票
我们这样做是因为
你已选择了它作为你的complication股票
然后将会是你的收藏股票
这个是我们想要返回给你的
我们有一个可预期的体验
总是返回用户期望看到的东西
在过一段时间后
让我们概括下关于股票我们做了什么2-Second任务
第一件事是
我们要保证应用和complication间的数据一致性
另一个是
我们简化了我们的设计
我们在减小大小的同时让它变得更清晰易读
更易用
无论何时你通过详细分页API垂直滚动
可以快速的让你查看多个股票
替代以前的来回拖拽
接下来 我们讲一下后台刷新
我会多讲一下
我们如何实现股票的后台刷新
当我们开始实现股票中的后台刷新
我们需要考虑两个问题
第一
我们需要一个什么样的频率来更新股票中的信息
第二我们需要获取什么样的数据来更新应用
决定我们应该多久刷新下股票的数据
有一点取巧的意思
首先我们感觉每15分钟更新一次看起来不错
这将会使应用在一天中更新好多次
但是其中很多时候的更新都没有用
像当每天结束或者周末闭盘的时候
让我们参考下已知的一些事实情况
因为我们感觉可以更好的实现它
首先 股市只在每天的特定时间开盘
例如 我们订阅了一个
纽交所的股票
同时我们知道
纽交所在东部时间早上9:30开盘
并且会在东部时间下午4点闭盘
如果我们限制了后台刷新请求
仅当股市开盘时
我们可以减少更新次数
可以节省出资源给其他应用
同时也会让我们受益
不用多次更新我们的应用和complication
它会很没效率
同时这样也很好
让我们看一点我们怎么实现的伪代码
我们如何判断何时需要进行下一次刷新
首先 我们会遍历我们的股票列表
然后我们检查股市是不是都关闭了
因为如果我们知道股市都闭盘了
我们想知道股票列表中的下一个最近的开盘时间
不然的话 这表示至少有一个股市是开着的
那我们就需要15分钟刷新一次了
我们看一点源代码
首先大家需要注意
一个函数 我们在股票应用中用来
在后台定时刷新
在特定的时间里
我们用的是WKExtension中的scheduleBackgroundRefresh方法
我们会传入preferredDate
这个preferredDate是在应用中的其他地方计算的
代表我们的后台计划刷新时间
我们从最后往前看一下
我们看看在nextPreferredRefreshDate里有什么
这个函数的开始有个guard
我们会调用earliestNextOpenDateInStocks
如果返回nil
我们继续往前
因为在earliestNextOpenDateInStocks中
如果列表中没有股票我们会返回nil
因为这时候 做后台刷新没有用
因为没有数据刷新
我们接着往下并且计算下一个nextRegularRefreshDate
刚好是更新频率 每15分钟一次
最后我们在这里检查
所以 我们用earliestNextOpenDateInStocks
我们会和nextRegularRefreshDate做时间比较
现在我们的earliestNextOpenDateInStocks
也会多了一个返回distantPast
如果我们的任何一支股票正在开盘
这段代码中后面的时间会一直是固定的刷新时间
我们看看earliestNextOpenDateInStocks方法
首先我们将获取我们的股票列表
然后做检查
如果这里还是0我们会退出 返回nil
这时后台刷新没有用
然后我们遍历我们列表中的股票
如果任何其中一个开盘
我们会提前返回distantPast
不然的话我们将检查
我们会遍历列表找到earliestNextOpenDate
我的意思是 我想展示一些代码
因为我们认为这是限制后台刷新
次数的很好的方式不用全部的代码
我们说说多个后台请求调度
因为特别对股票来说
我们需要在两个地方保持应用数据更新
我们需要在终点A
保持应用数据更新
我们还需要终点B更新complication
所以如果我们计划后台刷新时间
我们这么做
我们一旦收到处理后台任务
我们会提交终端A的请求提交终端B的请求
我们会计划我们未来后台刷新时间
它看起来是什么样的好的...
在WKExtension代理中我们有处理后台任务的方法
我们会遍历这些后台任务
我们会首先检查
是否是一个应用刷新任务
如果是 我们会进行和计划那些数据更新请求
在那里我们进行我们的NSURL请求
接着我们会计划下一次后台刷新时间
使用nextPreferredRefreshDate
然后我们会完成我们的应用刷新任务
最后一部分大家需要注意的是
这个URL会话后台刷新任务
你会得到其中的一个
当你触发一个后台NSURL会话调用
我们需要把它先存到某个地方
我们会稍后完成它无论请求何时结束
现在我们讨论过了它我们看看 它看起来啥样
当我们触发那些NSURL请求
在一个高的层级
我们安排那些请求然后当那些请求结束了
我们会计划一个快照重新加载complication
当我们将要完成我们的后台刷新任务
第一件事
我们会设置应用数据请求和complication数据请求
然后我们设置我们的完成更新处理函数
现在完成更新处理函数仅仅是
一个我设置的块无论何时NSURL会话
的完成后台请求代理方法被调用
我就能调用那个完成更新处理函数
这是那个块里面的所有内容
然后我们有一个submitRequest
作用就是开始这个网络请求
同时调用这个任务的恢复
一旦该任务完成了 我们可从urlSessionTasks里得到该任务
它是一个字典
我们会计划快照重新加载complication
我们继续然后完成那个URL会话任务
最后我要调用的是urlSessionDidFinishEvents
为了给你展示无论何时你的请求完成了
我们会从会话配置里得到标识
然后我们请求我们的finishUpdateHandler
这个给你一个线索
如何同时运行多个请求保持你的应用更新
如果你的应用和complication有不同的请求
第一件事明显是你想优化
调用你应用的更新频率是多少
当你做后台刷新时
这是第一目标
如果你从服务器上更新数据
尽量单独制定的端点如果你能控制的话
如果你不能 它可以
提交多个请求在后台刷新时
现在我们看下恢复时间优化
当通过扩展你优化你的恢复时间
你将同时会优化你的启动时间
这很棒
我们说说我们能做什么
就像Tyler刚才说的
你可以在willActivate和didAppear时 将任务最小化
你知道做它
避免从willActivate中触发较长运行时间的任务
我们将会做一个聪明的加载和重新加载数据
当然像他刚才说的我们最好只设置属性
属于接口中改变的元素的
我将会用一个警示开始
这包括实现垂直详细分页API
像Tyler刚才说的
相邻的详细分页的willActivate会被调用
你同时想要避免耗时的操作
在详细页面willActivate中
尤其是 在这个视图里有一个非常耗时的操作
所以由几个错误报告开始
我们基本上得到的是加载慢的报告
股票视图加载慢当你第一次进入详细页面时
其他详细页从来没有加载他们的图表
或者是相当慢
现在我们看看代码
尝试看看到底发生了什么
这是一个缩减版的股票接口控制器
你会发现
在willActivate我们调用了downloadAndGenerateChart
基本上NSOperation是一个长时间运行的
并且做很多工作获取图表数据绘制图表
我们能在这个基础上提高点什么呢
我们知道didAppear被调用
当视图控制器可见的时候
对用户同时被选中
如果我们开始在这里下载和生成数据表呢
如果你频繁的滑动会发生什么
我们不想继续下载和生成图表数据
对于已经离开的视图
我们会调用cancelDownloadAndGenerateChart
它会获得运行的操作
并取消它
我们看看再一次看看其中的注意事项
因为我已经知道了这里的错误
想在willActivate避免触发长时间的运行任务
如果可能 最好使用可取消的操作
做这个NSOperation是一个比较好的模板
我们看看WKInterfaceTable加载
我们知道所有的行被加载到内存
我们知道它提前有个线性的花费
根据你表中的行数
同时不会像UITableView会有重用
我将会展示一个图一个性能分析
我对这个股票做的
这是初始化启动时间重启以后
没有恢复时间或其他的
重要的是你要注意这里我们没有股票在列表中
一个空的股票列表用了5.5秒加载
如果我们添加一个股票进去它会多一点
差不多6.5秒如果加5个股票
稍微多余6.5秒
如果我们添加10个股票现在开始接近7秒了
如果你有大量的行
在你的表中那会延长
接口控制器的加载时间
我们这里能做什么才能降低加载时间
第一我们可以限制加载的行数
我们可以智能的更新我们的表格
当行发生变化 当列表发生变化
我们看看loadTable的初始化部分
我们从manager里面获取数据
接着设置表的行数
然后
我们计算每个股票的行控制器
开始看起来没有问题那里放生了什么
股票的数量没有被限制如果你有20个股票
那将有20行 若有30个会有30行依次往下
我们一直使用一定数量行的集合
如果有一行被添加当使用那一行时
你会擦掉之前有的
然后从头开始
这很没有效率
我们看看我们怎么样处理让它变得智能点
我们像之前一样先获取股票我们检查数量
然后我们设置一个最大值
在这个股票例子 为20
我们接着计算行差异
看他们之间的不同变了多少
然后我们调用insertRemoveTableRows
稍后我们会仔细看看
在下面
我们确定我们没有做超过必须的过多工作
我们会检查确认索引
在最大的股票列表大小之内
我们看看insertRemoveTableRows
第一个要做的是计算行变化
然后我检查股票行变化
如果大于零我们会处理
如果小于零我们需要删除掉
最重要是
你可以做的更聪明点如果你想
基于列表实际变了多少来更新
但我们发现 因为性能原因
仅仅做一个在0处插入或删除
在索引0处看起来工作的不错
所以我们不要做我们不需要做的工作
概括来说你的股票列表的股票的数量
或者像我的例子 这个股票列表
你的情况中 我不确定你放了什么进去
但是保持这个数量降低并且控制在
一个合理的数量在你的用例中
下一步 当你插入和移除行时
那将会更有效
比你仅仅调用WKInterfaceTable的设置行数方法
最后一件事不要遍历整个表
当一行数据更新时
所以这么想 就像如果我们正在更新Apple股票的价格
在表列表或股票列表
作为取代遍历和
更新每一行当我们不必这么做时
我们可以使用rowController(at index)
这样我们就可以只更新我们想更新的那一行
或者 你甚至可以做类似存储一个引用
对于rowController且在稍后更新
我们讨论下更新UIElements
Tyler刚才提到的UIObjects和WatchKit
他们在extension进程中被修改更新这些属性
需要从extension进程发送到应用进程
app进程处理界面的布局
我们看看股票的UI只有一个rowController
但我们有个表盘这里
对于这行是可点击的
我们也有一个列表名字就是股票代码
的公司名 它是个标签
还有changeInPointsLabel
这就是需要修改的地方
还有价格标签表示当前价格
我们看看我们需要做什么
更新rowController时
我们有更新方法
它会接收我们给它的任何值
它会立刻设置那些属性
现在不好 因为界面上的对象属性
没有被缓存 对么
设置对象的属性会每次
都发送值给应用进程我们会减少它
但我想强调它的重要性
一般来说 在我的分析中
在股票中需要花费大约200毫秒把一个值
从extension进程发送到应用进程
看起来时间不长 但是
在有些分析中在初次启动时
我发现会超过平均值很多
最坏的情况需要1.4秒
从extension进程发送到应用进程
变化很大
我们该如何做才能更智能些
缓存那些已经发送的数据
只在发生变化时发送
我们来概括下恢复时间的讨论
我们想尽量减少willActivate里的工作
在 didAppear 我们想使用
可取消的操作 当可能的时候
你还要注意 过于复杂的用户界面
会导致更慢的加载时间
所以当数据越多
需要更新到UI上它就可能越慢
当然 我们只想更新我们的用户界面
在必要的时候 当发生变化时
总结一下 这个股票的案例
希望大家能从这里开始思考关于你的应用
保证你的任务小和简单
简化你的用户界面
使用新的后台刷新API
集中在应用的恢复时间
我们需要多注意WKInterfaceController生命周期方法
尤其是willActivate和didAppear
充分利用可取消的操作
在你更新UI时要做优化
不要发送冗余的信息
想要了解更多你可以访问开发者网站
我们的演讲编号是227
一些相关的演讲 不幸的是已经开始了
其中一些我感觉很重要
不仅是WatchKit开发我们也有并发编程
Swift 3中的GCD所以也同样重要
谢谢祝大家本周接下来的日子过得愉快