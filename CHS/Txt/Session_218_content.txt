让Watch应用保持更新
好的
大家好 欢迎参加我们的演讲“让Watch应用保持更新”
我叫Eric Lanz 今天跟我一起的还有Austen Green
我们都是watchOS团队的工程师
这是一个日历应用的截屏
当你听到应用这个词时你脑海中很可能会浮现这个画面
但watchOS还有很多超出标准应用之外的互动方式
比如 你的用户认为通知
是你应用的一个重要部分
如果你有complication你的用户会认为
那也是你应用的一个重要部分
在watchOS 3中我们引入了一个新的应用dock
这个功能允许用户添加多达十个
应用到一个总是可见的dock中
他们可以滑动浏览dock
从dock中快速获得所有数据
这个现在已经成为应用的一个部分了
人们以很多不同的方式使用你应用的数据
并且希望所有这些方式
都能一直同步和更新
听起来像是个不可能的任务但不要担心
我们可以帮你们实现
今天 我们要讲五个话题
第一 这个API的概述以及它在watchOS上的使用
第二 用真实代码演示一个示例应用
第三 Austen将上台
演示预约在后台是如何运行的
第四 我们将分享一些最佳范例
把这个API应用到你自己的应用中
第五 我们将演示一个案例分析
阐述我们是如何把这个API应用到我们自己的股票应用中的
首先 我们要思考的是我们如何使用手机和表
每天以不同的方式
早上 你排队买咖啡开始新的一天
你可以在手机上看几分钟新闻
离开商店前 查一下天气情况
用表盘上的complication这是个两秒钟任务
午饭时 再用地图找一个不错的餐厅
几分钟后 你选好餐厅 收起电话
在去餐厅的路上你收到一条通知
你快速地瞥了一眼手腕你知道你的朋友们
会晚几分钟到这是另一个两秒钟任务
在今天结束的时候 你再次使用地图规划一下路线 你可能会改道
你收到一条iMessage询问你今晚何时到家
你使用watchOS 3的快速回复功能回信息
“在路上” 又一个两秒钟任务
几乎不可能在几秒钟之内
把用户即将传给我们的数据准备好
我们需要更长的时间
在后台进行刷新
你可以通过这个强大的新API预约运行时间
这样 在用户需要这些数据之前数据能提前准备好
要了解这个新API的功能让我们仔细看一下
在watchOS上查询天气情况
这里 我们看到查询天气complication的前台活动
在查询发生之前我们就要准备好数据
让我们用这个API来预约查询发生之前的某个时间来更新UI
但是 没有数据该如何更新UI呢
我们需要更多时间从服务器上获取最新的天气数据
为此 我们要计划一个任务
但是 我们要怎么着手处理这一系列的事件呢？
我们需要一种方式使系统在后台唤醒我们的应用
在watchOS上 系统通过给应用分配任务唤醒应用
系统所能分配的任务有限
所以你要充分利用你得到的每一个任务
当系统要唤醒你的应用时
它会交付一个或几个任务对象
请一定要守住这个任务
直到完成数据处理
系统 交付任务
通过调用已处理的新后台任务方法
在WK扩展委托上
稍后我们将演示这个方法的一个示例
当你完成后台工作后
完成任务并把任务返回给系统
这就是基本流程
你可以通过这个流程在watchOS上获得后台运行时间
现在 我们要从一个更高的层次来了解任务系统
让我们再深入地看一下具体的任务类型
系统可以创建的
首先 这是个应用任务
这是个通用的运行时间任务你可以预约
在将来某一个日期唤醒应用
在应用任务的运行时间内你可以进行任何形式的本地处理
你可能想更新complication时间线
或用URLSession从服务器上下载数据
URLSession任务是如何得知
数据已下载完成并等待处理
由于watchOS是个共享的生态系统 没有任何意义
在数据下载时使应用保持运行
最好是让应用休眠
那么就让系统替我们实现吧
快照是watchOS上的一个非常重要的部分
它们既是你的启动画面
又是在dock中运行时的预览画面
如果用户停留在你的应用上你的应用将再次苏醒并运行
关键是你的快照要持续更新
快照任务是如何获得在后台准备UI的运行时间
并获取新快照
当你完成这个任务后
系统会自动给UI创建快照
请记住 完成数据处理后一定要预约一个任务
否则用户就看不到你刚刚所做的工作
当通知到达时 用户会看到通知
然后他们会期待你的complication和快照
更新并显示最新数据
用户喜欢那些感觉像是OS密不可分的一部分一样的应用
并且他们把那些应用放进dock中的可能性更大
如果用户有一个小时以上不跟你的应用进行互动
系统就会给你一个机会
来修复你的缺省状态
缺省状态对于不同的应用来说含义不同
有些应用没有缺省状态的概念
在watchOS 3上设计精美快照是个很大、很重要的话题
我们建议你参加一些其他相关的演讲
了解如何创建优秀快照的一些设计建议
最后一个任务类型是表连通性
在watchOS 3上我们整合了表连通性
和后台刷新API
意思是 你现在可以使用表连通性消息
把数据更新到应用中当应用在后台运行时
complication推送应用情境、发送文件
或发送用户信息都将在后台唤醒应用
我们希望这个版本会带给
我们的用户更丰富的体验
当应用通过表连通性任务被唤醒时
使用标准API来获取数据
首先 确保会话是激活的
一旦会话被重新激活
就开始监控新的hasContentPending属性
只要这个属性为真就表示仍有数据要处理
确保要一直守住这个任务
直到完成数据处理
完成时 你有责任将任务
返回给系统
如果你不这样做你将不会再获得后台运行时间
并且我们会给你一个崩溃报告
Austen稍后会提供详细信息
是关于运行时间警告的信息
让我们快速回顾一下新后台刷新API的使用流程
首先 预约一个任务
然后 接收系统任务
现在你就可以进行后台工作了
一定要守住这个任务直到完成后台工作
你可以利用这个运行时间预约后续工作
比如使用URLSession从服务器获取数据
结束后 完成任务并把任务返回给系统
在继续演讲之前 我想强调一件非常重要的事儿 就是做一个好公民
watchOS是一个共享的生态系统有许多应用
和系统进程争夺CPU时间和电池寿命
在这个生态系统中我们作为开发人员有责任
尽最大努力有效地使用这些资源
假如用户在下午3点启动了你的应用
你想确保在一个小时内有机会跟服务器进行核对
那你就预约一个下午4点的任务
嗯 如果用户在下午3点50分启动了应用会怎么样呢？
我们可以立即更新数据
四点钟当任务运行时再次更新数据 但这对于我来说并不是最理想的方案
最好的方法是在3点50分利用运行时间
重新预约一个小时后的后台任务也就是4点50分的任务
每个应用都不一样
但我们希望你们能找到一个这样的模式 使资源最大化
好了 让我们看点儿代码吧
为了帮助设计示例代码
我们将按照时间线逐步演示一个示例应用
并展示如何写代码
来响应所有生命周期事件
让我们看一个足球应用
假如今晚7点到9点有一场重要比赛
我们知道用户最钟爱的球队会参加比赛
并且我们认为他们一定会频繁地查看比分
让我们给后台活动选定一个三十分钟的节奏
后台刷新API只能允许每种类型有一个任务
是执行状态 在任何特定时间内
一开始 我们预约第一个任务的时间是7点半
在7点半 我们将使用所得到的运行时间预约下一个任务 时间为8点
8点时 我们将再次使用所得到的运行时间预约下一个事件 时间是8点半
一直确保预约未来任务非常重要
否则你就不知道什么时候才能有机会再运行
在此 我们看到了在watchOS上预约应用任务的代码
首先 让我们把任务时间设定为三十分钟以后
使用userInfo对象来存储某些关于为何做出请求的数据
在这个例子中我存了发起请求的日期
和当任务返回时能稍后查看原因的一个字符串
这个属性是可选的
可以在这里存储任何安全编码的兼容数据
这个完成日志是获知
系统是否已经成功预约任务的
请注意 正因为这里没有报错
但这也并不意味着任务会按所请求的时间运行
Austen将为大家解释何时及为何系统触发指定任务
预约应用任务后让我们把重点放在时间线上
看这个只有五分钟的窗口预约任务将在这个窗口中运行
当系统唤醒应用时
我们优先考虑的是从服务器获取最新比分数据
让我们看一下代码
在watchOS上开始后台URLSession的
首先 创建一个URLSession配置对象
重点是把这个对象配置为
后台会话 因为我们要在后台运行
同时设置一个标识符稍后用来获取数据
接下来 用这个配置创建一个URL会话
我们要求URLSession提供一个或多个下载任务对象
可以给会话关联多个下载任务想关联多少就关联多少
请谨记 系统只能在完成所有关联任务后才会唤醒应用
要开始下载数据请不要忘记调用重新启动
返回时间线我们在过程中下载了URL
所以完成任务和使应用休眠是很安全的
系统将继续下载数据
当我们被挂起时
当数据下载完成后URLSession会创建一个任务
并再次唤醒应用
但是 到底什么是唤醒应用呢？
具体地说 唤醒应用的意思就是
在WKExtensionDelegate上调用新的处理后台任务方法
除了这个调用
我们还将收到是否在可见视图控制器上激活调用
系统合并任务并提交给我们一个任务集
我们需要处理这个任务集中的所有任务
让我们开始依次处理吧
对于每个任务来说我们可以使用一个内联任务
来得到我们想得到的类型的对象
在这个例子中 要处理一个URLSession任务
那么我们需要使用和任务关联的标识符再次加入会话
URLSession是一个高度异步API
我们一定要注意守住任务
直到完成数据处理
我们建议你把任务存在一个集合中
完成后再遣散集合
完成每个任务并把它返回给系统
一定要完成那些未特别处理的任务类型
请记住 系统的任务数量有限
所以要完成你得到的每个任务
我们已经得到了数据让我们更新模型吧
你可能会考虑在这个时候一起更新UI
但我们建议你充分利用这个快照任务的运行时间
进行数据处理这样的工作
因此 在完成URL任务之前
要先确保预约创建快照
预约创建快照后再完成URL任务就安全了
并允许应用再次休眠
很快 系统将通过我们刚预约的快照任务再次唤醒应用
现在是时候更新UI了
并准备好创建新快照所需的东西
快照有一个独特的完成处理器
让我们来看看这个完成处理器
在watchOS上处理快照
无论什么时候每个应用都必须有一个快照
这是因为快照既是启动画面
又是在dock中运行时的预览画面
这个规则的意思是当创建快照后
我们要通知系统这个快照的有效期
要考虑数据及数据与用户相关性的时间长度
在这个例子中我们在八点有一个预约事件
让我们把有效时间设为三十分钟
可以在用户信息中随意存储一些这样的信息
比如为何发起这次请求
那个数据将为我们返回下一个快照任务
watchOS将给应用提供的机会
还原缺省状态 在休止一个小时后
你可以告诉系统跳过那个事件
通过把restoredDefaultState属性的值设为真
这样就会使系统了解你已经是缺省状态了
不需要额外任务了
没有缺省状态概念的应用
应该考虑一直把这个属性设为真
完成快照任务后 系统将挂起应用
然后自动抓取UI
并用作新的启动画面
这将不会唤醒你的应用
我们通过 端对端示例实现
常见后台刷新模式和所关联代码
提醒一下
虽然我们看到时间线上是五分钟
我们的应用总共也只能活跃15秒
通过任务链
我们可以最大限度地利用系统资源
现在 你应该对这个新API是什么有了更好的理解
为什么要使用它
以及怎么使用它
接下来 让我们欢迎Austen Green上台
给大家深入介绍
预约是如何在后台运作的
祝你好运
大家好我是Austen Green
我是一名watchOS工程师
今天上午 我要跟大家分享一些的信息
关于预约如何在后台运作
我会提供一些精挑细选的最佳范例
我们在我们自己的应用中使用后台刷新时
最后 结束之前还要做一个快速的案例分析
是关于如何 应用后台刷新的
在我们的股票应用中
让我们开始吧
我要讲的第一点是运行时间
应用在前台
一直是运行状态
意思是会开始执行你的代码
你可以进行像更新模型和绘制UI这样的工作
以及应用可能需要进行的其他各种任务
当你的应用进入后台时
系统一般会挂起你的应用
意思是 你的应用不再有机会执行任何代码了
有时候 当应用在后台时
系统可能希望应用能实施一项特定的任务
此时系统将唤醒应用
并要求应用实施它想要应用实施的特定任务
在watchOS 2中
系统有许多方式来唤醒应用
比如处理需要仔细看的通知
或也许ClockKit会要求应用
更新complication
在watchOS 3中我们增加了更多的方式
使应用在后台运行
系统要限制 时间
在后台运行的
时间的单位是秒
系统会考虑你所使用的时间
以及你所使用的CPU
所以 尽快、完成工作才能获得最大利益
尽可能有效地
在随后的种子中如果你超出了限制
系统将会扼杀你的应用
你将得到一份崩溃报告
从而了解是否超出CPU限制
或时间限制根据崩溃报告中的异常码
我们意识到 不同的任务可能有不同的需要
所以ApplicationRefresh任务
和URLSession任务的时间限制要长
比表连通性和快照任务
那么在watchOS 2中complication是
应用在后台获得运行时间的主要方式
watchOS 3中
我们要确保你继续每小时进行多次更新
若是带complication应用
与在watchOS 2上一样
然而 如果你提前向系统请求运行时间
更新complication数据
你现在可请求通过WKExtension进行更新了
稍后我会讲一下如何实现
另外 watchOS 3的新功能是
我们确保有来自父类iPhone的五十次push
如果你使用表连通性的话
利用这个信息可以很简单地
确保提供很棒的complication体验
全天候为你的用户
让我们来看一些代码
假如你正运行一个iPhone应用
并且你注意到模型发生了变更
你可以查询WCSession
remainingComplicationUserInfoTransfers
来了解你还剩多少高优先级的push
今天剩下的时间
你可以利用这个信息
打造complication体验
决定何时是发送complication数据的最佳时间
比如说在默认情况下
你有足够多的push
那就立即发送数据
用户几乎会立即看到最相关的数据
假如你已经push了很多次
并且运行有点儿慢 传输有点儿慢
你可能会考虑节制发送给表的数据从而确保
你的用户得到complication的数据更新
在当天剩余的时间内
最后 如果你没有任何高优先级的传输了
仍然可以尝试和发送数据 但是
数据会以较低的优先级发送
接下来 我要讲
一些CLKComplicationDataSource方法
我们想要搬到WatchKit中去的
如果你提前向系统请求运行时间
通过getNextRequestedUpdateDate
你应该希望系统预约后台刷新
的日期跟你之前通知ClockKit的日期相同
类似的当ClockKit想让你的应用运行时
它会调用requestedUpdateDidBegin
现在 我们希望在应用层级来实现
通过刷新处理后台或处理backgroundTasks
你会得到一个应用任务
处理complication更新和应用更新
在watchOS 3中我们引入了dock
我们认为这很棒 可以使用户快速获取他们所喜欢的应用的数据
并方便地查看他们所关注的所有信息
我们希望dock中的应用数据保持最新
因此我们要保证每小时至少更新一次
这适用于快照任务和应用刷新任务
现在这个预算分散到了dock中的所有应用
用户可以选择在dock中放多少应用
结果就是如果用户的dock中应用的数量少
那么你的应用某特定小时内就有更多
在后台运行的机会
另外 我们会把应用留在内存中
可以迅速重新启动 用户还可以跟你的应用互动
如果用户停留在你的应用上尽可能快地
另外在dock中 我们有一个最近使用的应用的概念
这个应用占据了dock的最后一个位置
并且用户有机会把它放进dock中
通过按按钮
对这个应用的处理跟应用的处理方式完全相同
用户明确添加到dock中的
意思就是这个应用
将收到后台刷新任务和快照任务
就像dock中的其他应用一样
所以你要确保一直 预约
跟系统预约 任何应用、
任何后台刷新请求 你可能需要的
有些主屏幕应用不需要定期预约
请记住这一点
刚才Eric也提到了你应用的快照
对于watchOS 3上的dock中的应用体验来说至关重要
有时候 系统需要应用快照
的原因各种各样
如果系统要求你的应用
创建快照是因为我们认为我们需要一个快照
这些快照将不会计入你的预算中
并且不含在所请求的快照数量之内
你向系统
有五个触发器可以导致系统
向应用要求创建快照
complication时间线更新
用户与你的其中一条通知互动
意思是通知被积极地解除
并且 如果通知进入通知中心将不计数
当应用从前台进入到后台时
然后再一次 一个小时之后再提供给应用一个返回 的机会
到缺省状态 如果适用的话
最后 为了让一切开始运作
系统会要求你的应用在启动时创建一个快照
这是你的机会
可以开始预约系统的其他后台刷新任务
现在 我想花点儿时间分享一些最佳范例
是我们精心挑选的
在自己的应用上应用后台刷新
首先 系统想要了解
与你的需求相关的尽可能多的信息
所以 如果需要 就频繁地预约
应用每获得一个运行的机会
你都应该考虑重新评估后台刷新需求
并适当地预约系统任务
然而 你不应该觉得你有义务这样做
如果系统把你的应用调回来进行后台刷新任务
并没有任何意义也许你刚更新过数据
需要进行其他工作 要尽快完成
或者最好是
当你完成那项工作后
考虑推迟你已经跟系统预约好的其他任务
你应该考虑你得到的所有运行时间
并确保使应用保持最新数据
意思是 更新模型和UI
并预约系统的后台任务
因此是为了dock和前台激活、通知、
complication更新和后台刷新
应用获得运行时间的原因有很多很多
你应该全部都考虑到
当你尝试和保持应用数据最新时
应用刷新后台任务就是你的切入点
切入通用的意图运行时间当你在后台时
我们认为有一些非常不错的用例
你可以执行如拉动系统数据库这样的操作
也许你想定期读取HealthKit数据库或日历数据库
你可以预约未来的URL会话
这正是我们在股票应用中所执行的
如果你已经知道时间过渡
你可以告诉系统你认为
运行应用最佳的确切日期
比如 日历应用或旅行应用可能有
定义良好的时间过渡
最后 如果你提前得到后台运行时间
通过ClockKit API我们希望你能进入
WatchKit API触发complication更新
现在让我们讲一些快照的最佳范例
快照是一个系统自有的 缓存
应用数据 跟普通的缓存一样
数据也会失效
因此 系统想了解数据什么时候会失效
你可以 通知系统快照需要更新
通过预约新快照请求
现在 你应该考虑重大的内容变更
当你尝试使快照无效时
你并不想频繁失效
比如 在倒计时应用中
你一定不想每秒钟都更新快照
那样没有任何意义
相反 你肯定希望通知系统更新你的快照
当发生重大事件时 比如计时结束时
我知道这很复杂
我想分享一个我认为很棒的数据流
关于如何管理这种复杂性
假如你有一些外部事件
也许是表连通性也许是NSURLSession
也许应用碰巧在前台运行
因为用户启动了你的应用
基本上是导致你更新模型的所有事件
我们想要你为后台刷新做的所有操作
是为了回应模型的变更
比如 更新complication
请求创建新快照
然后评估下一次后台刷新需求
无论是后台URLSession
或者仅仅是跟后台刷新API预约任意一个运行时间
现在watchOS 3中有了dock
我们认为用户会
我们认为用户会出入很多应用
比watchOS 2上要频繁地多
在watchOS 2中 你必须准备
随时进入前台或后台
但我们认为现在这些转换发生的频率要高得多
因此你应该确保完成所有后台任务
当处于前台激活状态时尽快
当应用在前台被激活时
你一定不想实施任何额外的工作
你只想做一些有用的工作
向用户显示UI
类似的 当应用从前台进入后台时
你应该尽快完成所有的前台工作
现在我们意识到你可能需要一点儿时间
来完成所有的前台工作
你可以通过使用NSProcessInfo.performExpiringActivity实现
去年的WWDC有一场不错的演讲是“WatchKit技巧与陷阱”
教你如何使用NSProcessInfo.performExpiringActivity
最后 我还要提一下数据保护
一般来说用户是早晨戴上表
解锁 然后表一整天都是解锁状态
直到晚上再脱下表 放回充电器
完全不能获取到表上某些类型的数据
当设备为锁定状态时
比如 其中一个最著名的案例是HealthKit数据库
因此 你一定要考虑你有什么解决方案
如果数据不可用不能创建快照的话
然后我想分享一些测试技巧
模拟器对于迭代开发来说是个不错的工具
我之前提过 我们有一些预算
但在模拟器中我们不会强制实施任何预算
所以 你一般会根据你想要调用任务的日期
在模拟器中调用任务
类似的 当在设备上时
我们可能仍然需要应用一些预算
但 你将获得最佳体验
当在充电器上时
你要确保你对启动路径和重新启动路径都进行了测试
系统会尽可能把你的应用放在内存中
但如果有引导程序
系统将启动你的应用
以便请求初始快照
要验证已完成所有任务
在随后的种子中你将得到一个崩溃报告
如果你不能按时完成任务的话
超级重要的一点是你的应用并不会崩溃
因为我们希望你的应用尽可能地响应用户
最后 一旦你认为你已经
实现了后台刷新策略
你的应用应该已经被激活了
确保你得到了 体验
你希望你的用户能得到的
你应该改变dock中的应用数量
确保对最好的和最坏的情况进行充分测试
当你得到预约时
现在 我想分享一个案例研究关于我们如何 应用后台刷新
在我们的股票应用中
在我们开始写代码之前
我们先退一步思考一下
进行后台刷新的有趣特征
为我们的股票应用
我们使用URLSession取回服务器数据
且要做一个complication
意思就是 我们知道 有多个视图
系统中的数据
通过complication、快照
以及激活应用
我们知道 我们想要周期性地运行
我们要定期更新应用
然后 我们了解了数据中一些有趣的东西
就是一旦股市关闭 我们的数据在当天剩余的时间内是没什么问题的
根本不会发生变化
嗯 让我们讲一下应用的运行
假如我们的设备启动
系统会要求我们的应用创建一个快照
因此 我们加载最新数据并准备好UI
但在完成快照任务之前
我们要预约一个后台的URLSession任务
这是我们开始后台刷新周期的机会
并确保为用户下载最新数据
现在 我们要使用NSURLSessionDownloadTask
给系统提供我们想要下载哪种数据的信息
系统可以让我们的应用休眠
并在后台下载数据
URLSessionDataTask的确能在后台会话中运行
然而 如果应用在后台
或当应用被挂起时 它会失败
因为后台刷新有时间限制
你的应用很可能会在得到数据之前就被挂起了
所以我们建议使用下载任务
稍后 系统会唤醒我们的应用
因为我们已经完成了下载
我们会更新我们的模型因为我们已经更新了模型
我们有三件事要去做
触发complication更新
通过请求通知系统快照已经失效
立即创建新快照
并评估下一次后台刷新需求
计划好下一次的运行时间
并把这个时间通知给系统
稍后 我们开始运行后台刷新
我们所要做的就是预约下一次的URLSession下载
我们一天之内要完成多个这样的周期
就是为了保证应用的数据是最新的 系统会创建快照
若用户在dock中浏览我们快照
我们的快照会显示最新的数据
嗯 假如用户从dock中激活了我们的应用
我们应用会变成全屏显示
并且我们想确保我们的用户有最新的数据
所以我们将再次下载最新数据
因为我们已经进入前台
一旦完成模型的更新我们仍然要完成三件事
我们要请求complication更新
还要请求创建新快照
然后还要再次预约稍后的后台刷新
在这里 我要指出两点
首先 虽然我们已经进入前台但我们仍然正在请求创建新快照
这绝对没问题而且我们也期待你们这样做
我们希望只要模型发生变更就请求创建新快照
系统非常智能它知道你的应用何时处于前台
以及何时不适合给你发送快照任务
第二点 因为我们是在前台运行
并更新了模型
我们得评估下一次的后台刷新需求
如果我们知道我们很可能会在十分钟后运行
但我们只下载了数据
我们可以推迟创建快照或者推迟后台刷新请求
使运行时间最大化
要使应用运行的几率最大化
最后 股市关闭之前做最后一次更新
我们知道 当天的数据将不会再发生变化
但是我们会像往常一样完成更新
意思是更新complication
请求创建新快照
然后评估后台刷新需求
因为我们知道当天的数据会停止更新
我们不能在complication或快照中保留失效的数据
我们可以等待直到股市下一次开市
获得下一次后台刷新的机会
这就使我们的应用避开系统
并且不用完成任何不必要的工作
意思就是会获得更多的刷新任务
系统上的其他应用
总之 一定要完成任务
完成任务非常重要
如果没有完成任务在随后的种子中
系统会扼杀你的应用
如果系统扼杀了你的应用
用户在dock中就不会得到他们所期待的快速响应时间
并且用户将把你的应用从dock中移除
要有效地利用运行时间
考虑前台激活、通知、ClockKit
当然还有后台刷新机会
无论什么时候获得运行时间
都一定要考虑保持最新的模型
并评估后台刷新需求
当数据发生变更时要通知系统
你的complication和你的应用快照
都是系统自有的应用数据缓存
系统需要了解何时数据失效
以便我们不会给用户显示错误的数据
用户期待看到一致的数据
无论他们用什么方式浏览应用数据
最后 你需要 来决定应用策略
具体分析
没有适合所有情况的解决方案
你一定要考虑用户是如何使用应用的
以及数据的有趣性特征
从而决定如何计划后台刷新策略
要了解更多信息你可以访问这个网站
今天下午3点还有一场非常不错的演讲
构造watchOS 3上的性能我们将具体阐述股票应用的实现
谢谢大家