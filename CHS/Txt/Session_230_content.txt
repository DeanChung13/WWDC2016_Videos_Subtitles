用CallKit提升VoIP应用
大家好
欢迎来到演讲230
我是Sirisha一名CallKit的工程师
今天和我一起的还有我的同事Stewart和Nick
今天我们很兴奋地向大家介绍一个全新的框架
CallKit
你们有很多人已经编写过VoIP应用
你们改变了电话通讯的面貌
让世界变得更小
你想让你的应用成为用户的首要选择
他们用你的应用在iOS上接听电话我们想为你们提供这方面的支持
CallKit是一个框架 能够大大提升第三方VoIP应用
使它和原装应用的体验一样好
谢谢
因为你们很多人已经编写过VoIP应用
接下来的40分钟中假设我们创建了
一个全新的应用叫做Speakerbox
Speakerbox是一个简单的应用
能在iOS上拨打与接听电话就像现在的iOS上的软件一样
在开始之前先让我设置一个场景
Jane一直在欧洲旅游
关心她的父母想要联系她
以确定她现在很好
因为是国际长途他们要使用Speakerbox
给她打电话
现在看看给Jane的来电是什么样子
这是Jane的锁屏屏幕
首先她收到爸爸的iMessage
在她还没有回复的时候就收到了妈妈打进来的电话
Jane不能分辨
iMessage通知
与打入电话通知的区别
因为现在的VoIP电话
它仅仅是一个通知
如果Jane想接听这个电话
她要打开Speakerbox输入密码
连接到应用上去然后开始讲话
这是Jane开锁后的屏幕体验很糟糕
她收到妈妈打来的电话
你会不小心错过这个电话吗？
有可能它仅仅是一个顶部的横条
那么是不是这样更好呢？
如果给Jane的来电是这个样子
这是Jane的锁屏屏幕
她收到妈妈打来的电话
注意全屏本地用户界面
Jane滑动一下就可以接听电话和妈妈交谈了
而且在解锁屏幕上也是这样
同样丰富的本地用户界面上面有接听和拒接按钮
而且预先设置好的铃声会响起
这样不是更好吗？
如果VoIP电话能够和系统中的其它电话互动
例如本地电话、FaceTime语音电话
或者另一个VoIP电话
甚至VoIP电话能够从通话记录、常用联系人、
甚至是联系人中拨打电话
或者从Siri、Bluetooth上拨打电话
甚至有请勿打扰和黑名单等功能
这就是CallKit
今天我们将讲解CallKit的架构、
打入电话流程和打出电话流程
最后详细讲解一下它的API
现在开始
好 这儿我们有所有的系统服务例如蓝牙、
Siri、CarPlay和本地用户界面
这儿有全部的VoIP应用例如Speakerbox
它们是两个独立的实体
系统和服务不能获知对Speakerbox进行的调用
在iOS 10中我们已经在系统服务中采用了CallKit
现在系统通过CallKit可以获知对蓝牙的调用
如果Speakerbox想要相似的体验
它要使用CallKit
系统现在通过CallKit可以获知对Speakerbox做出的调用
然后系统会给其它服务公布这些调用
让我们深入讲解一下Speakerbox
现在我们有Speakerbox和它的所有代码
它和网络通信它有自己的应用用户界面
现在我们要连接CallKit
在CallKit中我们关心两个主要的类
第一个是CXProvider类
这个类是Speakerbox用来
让系统获知
发生过的带外通知
第二个类是CXCallController
这个类是Speakerbox用来
让系统获知本地用户的操作
让我们详细了解一下这两个类首先是供应商
供应商 正如我刚才说的
是让系统获知带外通知的一个类
这些通知不是用户的行为
他们实际是外来的事件 例如
Speakerbox接到一个打来的电话
和CXCallController对比一下
CXCallController是Speakerbox用来
让系统获知来自应用内部请求的类
它实际上是用户行为
是内部事件 例如拨打电话的操作
通过CallControllerSpeakerbox
可以与系统的其它呼叫互动
例如在一个本地电话通话时
用户想从Speakerbox界面发起一个Speakerbox通话
通过使用控制器
系统会获知发起通话的操作
并且系统会通知本地电话的供应商
保持它的通话 从而让Speakerbox开始它的通话
让我们举一些例子说明一下
供应商用来报告带外通知
例如向Speakerbox发起的来电
或者向外拨出的电话已经连接
或者拨出的电话已被对方终止
而控制器用来请求
来自系统的操作 例如用户想
发起一个的通话或者用户想接听
Speakerbox的来电或者结束Speakerbox的通话
当供应商想和
系统通信的时候它使用CSXCallUpdate类
当系统想让Speakerbox
和用户互动的时候
它使用CXAction类通知Speakerbox
控制器和系统通信时
用户的操作被捆绑成CSTransaction
以便让系统获知这些操作
刚才讲了许多
让我们看看打入电话的流程
我们有SpeakerboxJane接到了来自妈妈的呼叫
呼叫来到Speakerbox以后Speakerbox创建了CXCallUpdate
并且使用供应商把呼叫传送给系统
然后系统会把呼入
公布给所有的服务进程 包括用户界面进程
如果Jane想通过应用界面来接听呼叫
接听操作会传递给系统
系统接着会告诉Speakerbox供应商
会回复CXAnswerCallAction
在需要的情况下Speakerbox会接听这个呼叫
如果Jane现在想从应用界面内结束这个通话
结束操作就传递到控制器中
控制器把它捆绑传递给CXTransaction
并且传递给系统如果一切顺利的话
系统把它通过供应商返回给Speakerbox
然后Speakerbox就可以结束通话
下面我们让Stewart为我们做一下演示
谢谢Sirisha
现在你们了解了CallKit的好处
我将演示一下如何使用CallKit
在一个已经做好的VoIP应用中Speakerbox应用
就是Sirisha刚才讲过的应用
我首先给你们展示一下如何用它处理一个呼入的通话
我首先打开一个SpeakerboxXscript工程
在我深入讲解在应用中使用CallKit之前
让我给你们展示一下这个应用的架构
这样你就有一个参考的框架
在应用中有两个主要的类
SpeakerboxCallManager类它维护应用中的通话列表
它有一些操作比如发起通话和结束通话
另一个主要的类是SpeakerboxCall
这是一个模板类表示应用中的一个通话
它有关于通话的元数据和一些回调代码区
在它运行的时候我们可以得知通话的生命周期
正如Sirisha提到的 我们使用CallKit时首先需要做的
是创建CX供应商
并且设置它的代理
首先我要创建一个新文件叫做供应商代理
在这个新文件中我要加入一些已经写好的新代码
首先让我们看看它能做些什么
在初始化程序中我们把一个引用参数
传递给SpeakerboxCallManager类
使供应商代理能够访问应用的通话列表
然后通过UUID引用它们我们在后面会演示
然后我们 我们创建一个CXProvider实例
然后我们传递
叫做供应商配置的东西我们现在看到的就是
供应商配置
会在后面详细讲解
它让应用能够配置一些系统选项
以决定它的行为
现在回到初始化程序
我们把这个类设置为供应商代理然后如果有必要的话
我们请求使用供应商的授权
好
现在已经设置好了供应商和代理
我们需要在应用代理中创建这个
我声明一个变量供应商代理
并且在application函数中实现了
didFinishLaunchingWithOptions方法
酷
现在应用中有了一个供应商
那么当有呼入的通话时应用怎样对作出反应呢？
我把它往下拉
我们会看到应用现在使用PushKit
通过推送通知获知呼入请求
我们看看这个代码起了什么作用
我们看到它查阅了dictionaryPayload
它从推送通知中查阅并且获得一些
关于呼入电话的元数据例如UUID
和代表呼入者的标识符叫做句柄
然后我们调用显示来电方法
我们看 这儿的代码是
应用控制本地的通知
给用户显示来电
但是如果使用CallKit
我们不再需要本地通知来显示这个
我们转而可以使用系统的全屏本地来电用户界面
我们这样做是因为这能获得更好的体验
要这样做 我将回到供应商代理
我要创建一个helper方法
它让我们为供应商调用API
我将会调用reportIncomingCall方法
在这个方法中
我首先要创建一个CXCallUpdate类
它含有呼入电话的元数据
然后我们为供应商调用reportNewIncomingCall方法
这将会告知系统来电的信息
现在我们要在代码中加入异常处理
我们要检查是否有异常
如果没有异常我们就创建SpeakerboxCall实例且配置它
然后我们把这个通话添加到应用的通话列表中
后面我们会详细讲解
为什么这儿有个异常处理？
无需多说 有些情况下
设备没有准备好
接听来电
好 现在我们的供应商代理中有了helper方法
回到我的应用代理
把这些代码改为调用helper
发布本地通知
好
现在我们使用CallKit
通知呼入电话
而过去我们通过推送通知获知这个消息
系统使用全屏本地来电用户界面显示了来电
好 那么如果用户按下绿色按钮
接听来电会发生什么呢？
在这个时候
供应商代理会收到另一个方法 我们还需要实现它
这就是ProviderPerformAnswerCallAction方法
让我演示一下
首先我们创建一个
Speakerbox call类的实例 它和
我们正接听的通话UUID相对应
下面我们调用answerSpeakerboxcall方法
这些代码来自老版本的应用
它和网络通信告诉它要应答这个来电
我们在供应商代理回调中这样做
最后我们调用执行操作
在CallKit中 每一个动作要么被执行
如果成功的话 要么执行失败如果有异常的话
这儿有几行代码
如果我们找不到Speakerbox对这个UUID的调用
我们就调用failed方法向系统报告
这个方法处理对来电的应答
那么如果用户如何结束通话呢？
为此我们有一个相似的方法叫做
ProviderPerformEndCallAction
它们很相似
它查询一个基于UUID的调用
它使用endSpeakerBoxCall方法和网络通信
通过调用执行告知这方法执行成功
然后把通话从应用的通话列表中删除
现在处理呼入的通话我们讲的差不多了
还有一件事情
在处理呼入的通话时应该考虑
就是通话的音频
使用CallKit时
你不需要直接激活应用的音频会话
你只需要配置音频会话
系统会为你激活应用的音频会话
并且提高它的优先级
让我演示一下它是如何工作的
回到PerformAnswerCallAction方法中
我在函数configureaudiosession中插入一个通话
正如字面意思它能配置应用的音频会话
但是并没有激活它
音频会话将被系统激活
然后
我们会收到一个返回的代理叫做供应商
didActivate audioSession
从这儿开始我们开始处理通话的音频
最后一步是停止处理通话的音频
它是用PerformEndCallAction方法实现的
好的 这是我们使用CallKit处理呼入通话的所有代码
现在我把设备屏幕显示在电脑屏幕上
让我们编译运行设备上的应用
为了本次演示
我仅仅使用底部的按钮模拟呼入通话
现在我按下它
我们会看到Speakerbox的呼入请求
它使用了全屏本地呼入用户界面
我可以接听这个电话
供应商代理就会收到PerformAnswerCallAction方法
它执行了最后当我和Jane交谈完以后
我可以结束通话和应用供应商代理也执行了
这是使用CallKit处理呼入电话的演示
现在交给Sirisha
谢谢
谢谢 Stewart
让我们再回顾一下Stewart的演示
首先 把呼入的请求
通过reportnewIncomingcall API通知给系统
然后我们处理接听电话的操作
通过实现代理方法performActionAnswer
CallAction
然后我们接听了电话
我们通过调用执行API执行了这个操作
CallKit能做的不仅仅只是接电话
这个列表列举了它支持的其它操作
有保持通话、多人通话、双音多频电话等等
现在花点时间谈谈多人通话
假如Speakerbox可以处理多人通话
在这儿 在这个例子中
已经有一个活动的Speakerbox通话了
这时又呼入了一个电话
若用户想用本地用户界面结束这个活动的通话
并且接听下一个呼叫
系统就会发送CXTransaction给Speakerbox
CXTransaction就是一个或多个操作的列表
在这种情况下 那就是结束和应答的操作
一旦Speakerbox处理
和执行其中的操作
它需要分别完成它们
这样系统知道要转换用户界面
现在我要交给Nick讲解打出电话流程
谢谢Sirisha
让我们继续用Jane的例子
她昨天和妈妈通了电话但是今天她有点想家了
她想和家人联络
让我们看看如何打出电话
首先Jane要做的是到最近联系人中
点击 给她的妈妈打电话应用启动时
首先出现了可能通话操作列表
你们中有人可能已经看了SiriKit的演讲介绍
我们介绍了可能通话操作列表
如果你想了解更多信息
你可以观看在线视频
一言以蔽之可能操作列表
就是期望的用户行为
被打包在NSUser活动中并且传送给应用
应用收到可能通话操作列表
就创建可能通话操作
根据可能通话操作中的信息
我们会得到相应的操作 然后通过CallController发出请求
CallController会把操作传送给系统
如果它接收了 它会通过供应商代理返回给应用
最后我们的应用会得到这个操作
使用网络上必要的命令
打出电话
首先看看从这时开始的呼出电话的生命周期
我们已经开始进行呼出操作
所以呼叫现在处于正在开始状态
这时我们完成了执行这个操作
执行操作把呼叫转移到已经开始状态
当对方接听电话时
我们会通知供应商通话正在连接
最后
我们会通知供应商通话已经连接并且通知系统
双方可以通话了
有请Stewart回台上
做另一个演示
谢谢 Nick
现在我要演示第二部分
如何使用CallKit和Speakerbox
这一次是如何使用它处理呼出的通话
我要再次打开一个Speakerbox Xscript工程
回到我们的应用代理类
我们看到Speakerbox现在这样处理启动
用一个URL开始新的通话
当用CallKit的时候
拨出电话的过程是相似的
但是当用户从这些场合中发起通话的时候 例如电话应用、
最近联系人、联系人卡片或者Siri
应用启动时有可能操作列表
并且会通过NSUser活动传递给我们
这儿使用CallKit的第一步是
实现applicationContinueUserActivity方法
看看是怎么做的吧
先看看NSUser活动
我们要得到startCallHandle变量的值
这些代码我们已经写好了查看NSUser活动
得到可能操作列表 返回句柄
它是一个字符串代表我们想要把电话打给何人
现在一旦我们有了句柄
开始新通话的过程就等于上面的URL句柄
我们仅仅是在通话管理器中调用了开始通话方法
现在看看这个方法做了什么
我们可以在SpeakerboxCallManager类中看到
我们通过创建模板类的一个新实例就开始了一个通话
Speakerbox通话
然后我们调用StartSpeakerBoxCall方法
它会和网络通信 然后开始发起通话
最后还把这个通话加入到通话列表中
但是现在还没有使用CallKit来通知系统
我们打算发起一个新的通话
我们需要这样做
所以我现在要删除这些代码
过一会儿我还要把某些部分添加回来
在这个类中采用CallKit首先要
导入框架
然后我需要Sirisha提到的第二个类
CXCallController
现在在开始通话方法里已经有了
我需要创建startCallAction
然后用我想拨出的句柄配置它
然后创建CXTransaction它含有有上面的操作
最后我在callController中调用请求事务
请求系统执行操作
现在仅仅是重复Sirisha提到的这一点
你可能想知道为什么我们需要向系统请求这个事务
其实看起来这一切只是
发生在应用的内部
原因是当你试图
发起一个通话的时候
系统可能已经有了一个其它的通话正在进行
例如 如果用户使用本地电话、FaceTime电话
或者其它的VoIP应用电话
如果这样的话 系统需要在你的通话开始之前保留原来的通话
为什么我们需要从系统层请求操作
要让系统知道这些操作
现在 一旦系统接收并且改善了我们的开始通话操作
它要通过供应商代理把这个操作发送回给应用
所以我需要实现供应商代理的另一个方法
它叫做provider performStartCallAction方法
让我们一起写这些代码吧
和以前一样 我们首先
创建一个Speakerbox call模板实例
然后用我们用拨出通话的句柄来配置它
然后配置音频会话这和以前一样
当应答不同时间打来的电话时
我们需要在通话上配置一些属性
这儿的代码很多 让我们梳理一下
我们为通话设置两个通话返回代码区
hasStartedConnectingDidChange和hasConnctedDidChange
它们是异步的通话返回代码区它们会被激活
当通话由已连接状态
进入正在连接状态然后再进入已连接状态
在这些通话返回代码区中
我们向系统报告通话的过程
这样系统就会知道并且在界面中显示出来
设置好了以后 我们就可以调用startSpeakerboxCall方法
在通话时
它会再次同网络通信 然后拨出电话
完成了这个操作就可以向系统报告操作成功
并且把通话添加到通话管理列表中
好 这是对呼出通话的处理
但是如果用户想结束通话我们该怎么做呢？
从我们自己的--应用自己的用户界面上
这样我们需要回到Speakerbox callManager类中
看看结束通话方法
在这儿 我们可以看到和前面的发起通话方法一样
它还没有使用CallKit
所以我要替换一下代码
我把它拖进来看看 我们创建了结束通话操作
它被打包成事务
从callController可以请求这个事务
这一次你不需要在供应商代理中做任何改动
因为你可以看到
我们已经在前面的演示中实现了这个
这就是我们处理呼出通话的所有代码
现在我要在设备上编译和运行应用给你们另一个演示
我已经在设备上编译和更新了应用
为了给你们演示呼出通话
我想回到联系人卡中的电话应用
现我们能够看到Speakerbox应用列在联系人卡中了
我只要点击这儿就可以运行应用
应用启动了
它会收到可能操作列表
使用callController开始一个通话
它会请求系统支持的一个事务
提供给供应商代理然后供应商代理执行操作
现在看 就是这样
现在通话正在进行
现在正在通话 如果我按下home键退出 我们能看到一些新鲜玩意
竟然出现了绿色的双倍高度的状态条
在显示我们的应用正在运行
以前这是本地电话
和FaceTime电话专用的如果我点击它
将会回到Speakerbox通话页面
谢谢！
当通话结束的时候我点击结束通话
这会向系统发出请求 终止通话操作
供应商代理会执行这个操作
这是使用CallKit处理呼出通话的所有演示
现在交回给Nick回顾一下然后介绍几个别的API
谢谢
谢谢 Stewart
首先快速回顾一下刚才的内容
首先是Speakerbox收到可能通话列表
基于这个列表创建了开始通话操作
然后请求开始通话操作
开始通话操作通过供应商代理被接收
然后执行
最后 Speakerbox报告通话成为正在连接状态
然后是已经连接状态
这是基本的流程
现在让我们深入研究一下API的细节
以便充分的使用CallKit
我们要尤其关注供应商授权
和配置它们帮助在本地用户界面中定制应用
我们看看如何处理操作异常
和系统约束
最后看看CallKit
在应用的通话音频扮演什么角色
所以和其它API一样例如联系人和定位
CallKit要求用户的使用许可
因此
应用在启动的时候首先要做的是
检查它当前授权的状态
因为从上次启动应用以来它可能发生了变化
如果用户设置激活或者终止你的应用
那么现在
如果你发现应用的授权状态
还没有确定你应该请求应用的授权
这就是告诉操作系统给用户展示一个
警告 请求获得许可
这是为你的应用做出的授权
因为这是为你的应用做出的授权你应该确定
在应用的info.plist中包含应用字符串 提供相应的信息
最后 当应用启动的时候
你应该确定时刻监听
可能发生的授权状态的改变
这样你能一直为用户显示最新的用户界面
现在谈谈供应商配置
供应商配置使你的应用
直接在本地或者通话用户界面中定制通话体验
可以定制
为你的通话显示应用的本地名称
这包括特定的功能
例如应用是否支持视频通话
这甚至包括
是否指定自己定制的图像直接显示在
终端用户界面的按钮处
当点击的时候会让用户直接启动应用
记一下 对于本应用图标的支持
在下一个版本会实现
到目前为止我们看到了执行顺畅的时候应用的表现
但是如果碰到问题会怎样呢？
看看前面拨出电话的例子吧
我们已经执行了开始通话操作
但是在执行的过程中我们碰到了异常
也许是和网络服务器连接不好
导致我们无法拨出电话
在这种情况下 我们要终止通话操作
这很重要是因为它要通知操作系统
出问题了
操作系统反过来
会通过调用失败用户界面通知用户
同这些操作异常密切相关的是操作失败时间
系统的每一个操作都有和它关联的特定的失败时间
这些失败时间很重要因为它们确保
用户发出的操作
以操作和回应的方式进行
因此应用应该总是确保
在一定时间内来执行这些操作
如果某个操作超时了
应用会通过合适的供应商代理方法得到通知
同时做出合适的反应
根据设备当时的状态
一定的系统约束是必要的
让我们用打入电话作为例子
你的呼叫
应用的打入呼叫被拒绝了可能因为
用户停止了应用它不再被授权使用
或者拨入电话者
在接入电话的黑名单中
或者用户启用了禁止打扰功能
现在不想接任何电话
对于所有这些情况
应用会通过API的完成句柄得到通知
例如 reportNewIncomingCallAPI
在完成句柄中会返回一个错误代码
你看 应用检查了返回的错误代码
看到错误代码是禁止打扰
就会做出相应的处理
现在让我们看看CallKit的音频
有了CallKit的通话音频应用得到很多好处
最大的好处是
它的音频会话在系统中的优先级会得到很大提高
同本地电话和FaceTime电话不相上下
这意味着系统上的其它应用不能
打断你的应用的通话音频
除此之外
CallKit能分辨系统的特定音频路由
这意味着它能知道如何路由音频根据
用户的当前访问配置
还是当前连接的蓝牙设备
让我们把呼入电话流程作为例子
我们知道在接到电话以后应用
会收到回应呼叫操作然后执行这个操作
在收到回应呼叫操作以后应该
配置音频会话
因为我们知道通话很快就会进入已连接状态
当我们执行回应呼叫操作以后
系统会自动为应用开启一个音频会话
而且具有很高的优先级
然后让应用知道这些已经完成
这是通过did activateaudiosessionProviderdelegatecallback告知的
这实际是通知应用
应该为通话开启多媒体了
这是对API 的细节的简要介绍
它们帮助我们使用CallKit
现在我们邀请你在创建的VoIP 应用中采用CallKit
或者使用CallKit创建一个全新的VoIP 应用
使用CallKit你将直接调用整合系统的底层驱动
一旦你使用了CallKit你的应用将获得
和本地电话服务平等的功能
最重要的是
使用CallKit你的应用将
在系统中是可见的无论是在全屏、
锁屏的来电提醒、最近来电、
常用联系人和联系人中 还是和Siri、
CarPlay和Bluetooth的整合中
要获得更多信息请查阅我们的演讲网址
developer.apple.com
那儿也有Speakerbox的示例代码
这个演讲中我们也一直在引用上面的代码
我们有很多精彩的相关演讲
一定要参阅关于Siri、可能操作列表、
网络和音频的更多信息
非常感谢你们的到来希望在实验室里看到你们