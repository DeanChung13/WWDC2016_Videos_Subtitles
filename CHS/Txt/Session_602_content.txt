采用METAL 第一部分
下午好 欢迎来到“采用Metal 第一部分”
我是GPU软件团队的Warren Moore
我和同事Matt Collins一起 他主要负责做展示
我想问一个
看似简单的问题 什么是Metal
你可能已听说过Metal是Apple的偏底层的API
面向GPU的它是一个统一的图形计算语言
并且面向多线程做了优化
专门为我们的平台所设计
这些都是正确的
但是Metal不仅有Metal.framework
Metal同时也被其他的框架和工具支持
它们提供了比metal框架API多很多的东西
尤其是去年我们引入MetalKit
它包括了用来一些处理常见任务的工具
像与UIKit和AppKit交互加载纹理
还有Metal性能着色器
能帮你做图片处理
可以手动调优 高度优化的着色器
可以直接放到你的应用里来处理这些任务
Metal同时还紧密与我们的开发工具结合
像Xcode与Instruments
当你的应用里面有着色器
它们会同你的应用一起编译
通过Xcode集成到你的应用包里
还有GPU框架调试器可以做一个快照
在程序运行的任何一个点来看看程序现在是什么情况
Instruments中Metal系统跟踪
可以让你在运行是查看应用的性能
和行为
两年前我们把Metal引入了iOS
然后我们又把它带到了Mac OS和tvOS
所以现在在我们平台上受到了广泛的支持
同时我们的大部分硬件也支持它
包括桌面架构和移动架构
像Apple AMD Intel和NVIDIA
所有的2012年后的Mac
2013年以后的所有iOS设备还有新的Apple TV
Metal可以让应用程序充分利用GPU的性能
在我们的海量的产品上
在这些平台上Metal属于基础技术
它支持核心图像 核心动画
游戏和图形库比如SpriteKitSceneKit和Model I/O
也是我们关键系统软件的重要部分
像Preview和Safari
各种各样开发者们已广泛使用了Metal
从AAA工作室 游戏引擎提供商
到独立开发者和专业工具开发者
他们开发了非常好的应用和游戏
这只是一部分我想着重说几个
比如 Fancy Guo用Metal显著的提升了性能
带来了惊人的视觉效果
在他们广受欢迎的MORPG游戏Furious Wings
Metal也被用在专业的内容创造工具
像iPad上即将发布的Affinity Photos
我带大家快速预览下都有什么
这个是Serif Labs的Affinity Photos
这是个全功能的图片编辑应用
在iPad pro上Metal可让其获得令人惊叹的效果
今年的 WWDC我们会给你一些工具
让你们开始使用Metal
来制作体验非常棒的应用
今年的 WWDC 有很多很棒的内容
有五场讲座专门介绍Metal
当然这是第一场会话采用Metal 第一部分
在这节中我们会讨论
Metal里的一些基本概念
接着会介绍2D绘图添加光照
纹理和动画 我们还会介绍3D
这节课的第二部分也是在这个教室 紧接着这节课
我们会介绍动态数据管理
接着会介绍一些高级的
关于GPU和CPU的同步
会让你性能达到新高度
通过使用多线程编码
我们会介绍下Metal里有什么新东西
确实有很多新特性
在昨天的统一介绍中相信你们也看到了一些
我不会详细介绍全部的东西
如果你想在你的应用中使用
你应该看一下那个最新课程
最后 我们会有个很棒的高级着色器优化的课程
对于那些想要
更好的使用着色器的人来说这些绝对是干货
我们会详细的讨论硬件如何工作
你该怎样使用Metal来更好的发挥它的性能
还有调优你的着色器代码
在这些课程中 我们会创建样例工程
由简单的Hello Triangle开始
图形编程领域的Hello world
然后 我们会研究动画和纹理贴图
第二部分 我们会进入到下一层级
讨论下实时更新对象数据
同时还有 通过多线程来优化绘制调用
现在我们假设
你们已经熟悉
基本的图形编程 最好是
知道可编程管线熟悉着色器等
同时你想知道怎么能用Metal来
让你的程序和游戏变得更棒
我假设大家都是这样
这也是你们为啥在此 对吧
我先过一遍议题
我们会先大体介绍下
Metal的理念
和为何Metal会是现在的样子
接着我们会详细的
介绍创建一个Metal实例
接下来会介绍加载数据
到内存来供GPU使用
我们会简要介绍下Metal着色语言
我们会介绍创建预验证管线状态
和GPU调用 包括绘制调用
我们会用一个讨论结束
如何在Metal中处理动画和纹理贴图
第二部分我们会介绍的更深一些
刚才我已经提到了
现在我们开始
从理念概览开始
只有几点需要强调
使用和硬件驱动相匹配的API
尽量明确一些
尽量不做耗时操作
先说说使用和硬件驱动相匹配的API
Metal是一个完全现代化的API
也可以说它使用了最新的硬件特性
和硬件的工作流程息息相关
作为一个全新的API它非常轻量级
并且没有历史包袱
对的开销的操作没有花哨的技巧
它和Metal契合
并且都是在最基础的层级操作
幸运的是 它是统一的
在我们的所有平台上
当我们说我们更倾向明确的操作
意思是我们想让你
负责操作GPU
而不是让其默认的操作
同时还包括数据的管理和同步
这让你有更多的责任
同时能有更好的性能
再来解释下
不要经常做耗费大的工作
有三个地方
程序创建时
程序加载时
加载资源的时候
然后就是绘制时 每秒会调用60次
如果是历史API 如OpenGL
你大部分时间会花在
状态检查上每次调用绘制的时候
最坏的时候你需要在运行时重新编译
这些都会给GPU的必要工作上
添加负担 在调用绘制函数的时候
在Metal中我们把这些工作提前
像我开始说的
着色器的编译可以在
程序编译的时候同时进行
同时 我们也允许你验证状态
在调用绘制的时候提前验证
这样就不用在每次调用绘制的时候验证了
这样你需要做的唯一工作
就是只有绘制调用了
通过这些理念介绍
我们看看实际情况中的
Metal设备
这里有个类MTL设备
它表示抽象的GPU
它是你Metal应用中的最基本对象
你将会用它来创建
像指令队列 资源和管线状态对象
和其他你需要用的对象
创建Metal设备很简单
只需调用MTLCreateSystemDefaultDevice
现在设备代表对象
你需要在程序开始时创建一个
并保持引用因为会在整个程序的生命周期使用
就这么简单
现在说说怎么把数据
放到GPU可以读取的位置
然后你可以触发绘制调用
在Metal中我们把数据存到缓冲中
缓冲就是一块内存用来存数据
你可以用任何格式
可能是顶点数据 索引数据 常量
你把数据写到缓存中
随后在
顶点和片段函数中访问
我们看看大体是个什么样子
这里有个包含几个缓存的例子
你加载数据的时候可能会创建
我们有个vertexBuffer包含一些顶点数据
一个indexBuffer包含一些连续的索引
更具体写来说
每个顶点类型的实例可能是一个Swift结构
用向量表示顶点的位置
同样还有点的颜色
你可以让它们在内存你连续保存
说下如何创建缓存
这个API在你已经创建的设备里
简单调用newBufferWithLength
来获得一个指定大小的缓存
里面默认没有数据
或调用newBufferWithBytes
传一个已经在内存中有数据的指针
Metal会把数据拷贝
到新创建的缓存
你可以马上使用
你也可以用memcpy把内容指针拷贝到缓存里
既然我们要展示一个2D的三角
作为我们第一部分的展示
我们先说下三角的几何坐标
既然我们想让顶点着色器
和片段着色器尽可能的简单
我们在裁减的空间里提供坐标
Metal的裁剪空间很有趣
它和其他类似的API有些不同
有点像DirectX裁剪空间
X从负1到1 Y轴从负1到1
Z轴从0到1
这个是我们要用的坐标空间
代码中是这样的
我们创建了个Swift的顶点数组
我们依次添加顶点
同时包括位置和颜色值
现在 我们不用严格的使用索引绘制
在这个简单的用例中
接着创建一个indexBuffer并向其中添加0 1 2
代表三角形的第一个 第二个
和第三个点
然后用我们的设备创建接个缓存
我们会用newBuffer(withBytes创建vertexBuffer
把顶点数据加载到Metal缓存中
我们再调用一次newBuffer(withBytes
把索引数据穿进去得到indexBuffer
现在我们有了数据和内存
下面说说统一着色语言
Metal的着色语言是C++ 14的扩展子集
他是图形和计算的统一语言
代表你还可以做很多事
不仅是3D图形
它可以让你写程序给GPU
这里有个管线各个阶段的图表
现在我们是在顶点
和片段处理阶段
每个阶段都有相应的函数要写
要么是处理顶点要么是片段
将会刷到屏幕上
语法上 它看起来像这样
我们不会详细介绍
希望你们注意这些函数修饰符：顶点和片段
你会注意到右面函数的前面
不像普通的C++程序
我们相用这些修饰符来表示
这些函数和哪个阶段相关
我们有一个顶点函数在上面
和一个片段函数在下面
我将简单展示怎么实际把这些
和你的管线结合在绘制的时候
我们还会看看这些函数的内部实现
在以后的2D和3D展示中
我提过好几次Metal可以
直接把着色器编译到程序包里
方法是即使你有一个.Metal文件
在你的工程中的编译源码层
Metal会自动生成
一个Metal库文件default.Metallib
同时会拷贝到你的包中
在你的程序编译的时候
除此之外不会再编译
所以它会在你程序包中
这是default.Metallib
简单说
你可在运行时编译Metal着色器
如果你程序里有一个.Metal文件
它会被Xcode用Metal工具链编译
生成一个default.Metallib打到你的应用包中
这里很自然会有个问题
运行时怎么使用这些函数
答案是你会用一个叫做
Metal Library的类
Metal Library是一个集合
编译器编译的函数对象
有几种方法创建
你可以通过我们讨论的流程
创建一个default.Metallib
到你的应用包然后在运行时加载
你还可以用我们的命令行工具链编译一个.metallibs
运行时你还可以用代码串创建一个目录
例如 通过字符串来编译一个渲染器
在代码里看起来像这样
为了加载default.Metallib
调用newDefaultLibrary
用你已经创建的Metal设备
还有其他的API加载 例如
从编译好的.Metallib或者从源代码
你可以详细查看文档来了解这些API
现你已有Metal Library
能从中得到什么可以得到Metal函数
现在Metal函数是一个简单对象代表一个函数
它和一个特定的管线阶段关联
记得我们刚才看过的图么
顶点或片段阶段
我们还有一个额外的描述符叫“kernel”
表示并行处理数据的函数
这里有段代码 你可以看到
函数名是vertex transform
fragmentFunction名是fragment lighting
我重改下以便我能给你展示API
如何在你的库中加载函数
像这样
我们先调用NewFunctionWithName
传一个代表函数名的字符串
获得一个Metal函数 引用它
稍后将展示实际中如何使用这些对象
但也只是简要介绍Metal着色语言
让我们介绍下创建预验证的管线状态
但首先 我们先预热下
像OpenGL中的API
你经常需要设置许多状态
然后触发绘制调用
在这之间驱动负责验证
你设置的状态是有效的
然后 最坏的情况
你还得付出运行时重新编译着色器的代价
我们想要避免这些
在Metal中 它看起来像这样
你设置一个预验证的管线状态对象
可能还有其他少数辅助状态
然后触发绘制调用
我们这里想要减少绘制调用的负担
把更多工作提前进行
这里有几个你可以在管线状态对象中设置的样例状态
这些状态绘制时你可以在任何时间设置
你看到左面这栏
你可能设置的管线状态
有顶点和片段函数用来绘制的
还有透明渲染状态
右面 我们看到的状态是
你可以在触发绘制函数前设置
包括front face winding和cull mode
来讲一下如何创建对象
包括这些预验证的状态
主要对象是Metal RenderPipelineState
它代表一类GPU的管线配置
它包括你会在加载时创建的一个预验证集合
像设备
RenderPipelineStates是持久对象
你想让它在你的整个程序生命周期都存在
如果你有很多不同的函数
你可以异步创建管线状态对象
在程序运行的时候
实际上在创建RenderPipelineState时
我们不会直接创建
反而 我们会用一个叫做Descriptor的对象
它打包了所有参数用来创建RenderPipelineState
通常在Metal中我们创建Descriptor对象
它会把所有不同的参数弄在一起
我们在创建其他对象时也会使用
对于RenderPipelineState对象
它被叫做渲染管线描述符
你会发现它包含指向顶点函数
和片段函数的指针我早先曾介绍过
它还包含一个附件集合
附件是一些纹理我们会在
实际渲染中用到
现在在Metal中所有的渲染都会被渲染到纹理中
但我们不需要提前指向那些纹理的指针
我们只需要提供你要渲染的像素格式
这样我们对它们的管线状态优化
若你使用了深度或者Stencil Buffer
你也可以指定它们的像素格式
你一旦创建了一个管线描述符
你可以传递给你的Metal设备
然后得到一个MTLRenderPipelineState对象
让我们在代码中看一下
这是一个RenderPipelineState的最小化配置
你会发现我们设置了顶点函数
和片段函数属性给
我们先前从我们库中创建的顶点和片段对象
同时我们也创建了
主要颜色附件的像素格式为.bgra8Unorm
它是一个可显示和渲染的像素格式
这代表我们最终要
在绘制的时候绘制的纹理
最后 一旦我们创建了管线描述符
我们可以用设备新的RenderPipelineState函数
来获得实际的预验证对象
我还行强调下PipelineStates是持久的对象
你应该在加载时创建
在使用设备和资源的时候需要保持
你可以在绘制时在它们之间切换
来达到不同的效果
通常会有一对顶点和片段函数
现在我们已经讨论了如何创建预验证的状态
和如何加载资源到内存中
接下来我们说下触发GPU指令包括绘制调用
我们通过几个阶段介绍
我们还会讨论和UIKit AppKit交互
稍微讨论下Metal指令提交模型
然后到渲染和绘制调用 最终
如何展现你的内容到屏幕上
就与UIKit和AppKit交互而言
我们用MetalKit里的一个工具MTKView
MTKView是一个跨平台的视图类
继承自Mac OS的NSView
iOS和tvOS中的UIView
它可以减少你要写的代码
为了让它在Metal中运行起来
例如 它会创建和管理一个CA Metal Layer
是CALayer的一个特殊子类
可以和窗口服务或者显示循环交互
来让你的内容显示到屏幕上
通过CV或CA显示链
可管理绘制回调循环
通过循环触发回调
来完成你的绘制
同时它还可以管理要渲染的纹理
具体的方面我想强调
它可以做什么和那些绘图资源
在CA Metal Layer中由MTKView管理
有一个可绘制资源集合
可绘制资源包含一个纹理
将要显示到屏幕上
这些在一个内部的队列中保存会在帧间复用
因为它们相对来说要耗费资源
它们需要由系统管理
因为它们和东西
如何在屏幕上显示息息相关
我们替你管理并给你
包含纹理的可绘制对象让你来绘制
这里有几个属性
你可以给MTKView设置
来定义如何管理纹理并往里面绘制
特别是 你还可以设置一个纯色
让主色更清楚
可以指定颜色像素格式
需要匹配你指定的
固定管线的状态对象的颜色格式
同时制定深度或模板颜色格式
最后一个属性可能是最重要的一个了
我们在这里设置代理
MTKView实际上不会做任何绘制
你可以将它归为一个子类别
或者你实现一个代理负责绘制
我们通过接下来的例子来介绍
我们看看你需要怎么做
才能实现一个MTKView代理
可归结需要实现两个方法
绘制大小变化和绘制
在绘制大小变化里你负责
响应如窗口大小发生变化或者设备旋转
比如 如果你的投影矩阵依赖
窗口大小 那么它可以让你
响应来替代重建所有帧
绘制方法会固定的被调用
可以让你编码你想的执行指令
包括绘制调用
我们没有展示这个方法的完整的内部内容
但是这是对指令提交的简单介绍
你要创建commandBuffer做些事情 然后提交
稍后我们会做更多介绍
但是这是一种使用MTKView的绘制功能的hook函数
我们推荐使用MTKView尤其是在开始时
因为它已经为你做了不少其他的东西
我们说下Metal的指令提交模型
这里有张我们要做的图
在接下来几张幻灯片中
你不需要记住所有的东西
我们将要把这个图绘出来
这仅是个大体介绍
我们会创建这个对象
Metal的指令提交模型非常明确
表示你需要自己构造
和提交commandBuffers
可把commandBuffer当作
一个打包的工作交给GPU执行
不同于我们存数据的Metal缓存
指令缓冲存了GPU需要完成的工作
同时commandBuffer的提交完全由你控制
就是当你构造了一个commandBuffer
你负责告诉GPU何时执行
稍后会详细介绍
我们先说说指令编码器
把对象的API调用翻译成
GPU需要做的工作
你要明白这很重要
这些指令编码器不会有状态验证延时
所以所有预验证状态捆绑到
管线的状态对象里了
我们假设它是合法的因为我们已经提前验证了
所以这里没有额外的工作要做
在你的编码器或驱动调用渲染指令的时候
还有 Metal的指令提交模型是多线程的
你可以并行的创建多个指令缓存
让应用决定执行顺序
这可以让你的每一帧的绘制执行上万次调用
使用Metal 第二部分会深入探讨
但这里因为提到了所以说一下
让我们深入了解下这些对象
首先是指令队列
指令队列这里是说
一个叫做MTLCommandQueue的类
它把设备需要执行的指令都放在队列里执行
像设备和资源和管线状态
队列是一直存在的对象
在程序的整个生命周期会保持引用
通常你只需要创建一个
这样可以保证Metal API是线程安全的
你可以创建指令缓冲渲染
并在多线程中使用它
队列可以让你创建和提交它们
并在自己不加锁的情况下保证是线程安全的
创建一个指令队列很简单
用设备调用newCommandQueue()
你将会得到一个Metal指令队列
当然只有你往里放入指令的时候它才会工作
我们说一下
我已经提过指令缓冲了
指令缓冲是GPU要执行的打包的工作
在Metal中 它们用
一个叫做MTLCommandBuffer的类表示
MTLCommandBuffer包含一系列指令
由GPU来执行 它们被放进
一个指令队列等待驱动来调度
根据我们目前讲的这些
它是临时对象
就是说每一帧你都要创建一个或多个
然后往里给它编码指令
然后让让它们脱离GPU
你不会重用它们 不用引用它们
它们会自己消失
创建一个commandBuffer
调用commandQueue.commandBuffer()
我们已经说了缓冲和队列
我们讨论下如何把数据和指令
放到指令缓冲中
通过一个叫做指令编码器的类
这里有几种类型的指令编码器
包括渲染 位传输和计算
这些分别实现不同的功能
它们都差不多 都可以把你的
工作编码到指令缓存中
比如 一个渲染指令编码器
可以设置状态和执行绘制调用
一个计算指令编码器可以
把工作添加到队列中并像数据一样并行计算 不像渲染工作
它像GP GPU或者类似的东西
位传输指令编码器用来
在缓存和纹理之间相互拷贝数据
这节课中我们会详细看看渲染指令编码器
我刚才提到 它负责编码指令
每一个渲染指令编码器
单独编码每个工作
如果你触发状态变化
然后触发绘制
然后管理一个渲染附件集合 代表
将要绘制的纹理
概要来说 我们说的是最后这个阶段
你能看到我们有这些附件
被挂到管线的帧缓存合适的阶段
如果我们做多通道渲染
那么一个或多个渲染目标可能会变为接下来的输入
这里只有一个通道 比较简单
附件表示纹理贴图
我们将要这个阶段的最后绘制
就是说 实际上创建一个渲染指令编码器
使用另一种类型描述对象一个RenderPassDescriptor
一个RenderPassDescriptor包含一系列的附件
每一个都有加载存储操作 纯色和值
和将要被渲染的Metal纹理
我们用几页讲一下加载和存储操作
这里有很重要的一点需要明白
你需要构造一个RenderPassDescriptor
在帧开始的时候并且把需要它
和将要绘制的纹理相关联
相比只需要知道像素格式的renderPipelineState
这是最重要的部分
而你必须有我们将在其中进行绘制的纹理
RenderPassDescriptor包含
渲染通道附件每一个可能是一个颜色
深度或者模型目标
或者指向需要渲染的纹理
指定这些东西叫做加载和存储操作
我们更深入的说下是什么意思
开始的通道中你有颜色缓存
有深度缓存它们包含未知的内容
为了做些真正的工作我们先清空它
我们通过设置和其相关的加载动作
在RenderPassDescriptor中
我们颜色和深度目标设置一个清空加载动作
那它会把相应的颜色设置为清空色
或者值 根据实际情况
然后我们开始绘制
会把我们作用的结果
绘制到纹理上
然后存储操作会触发
存储操作包含两部分
存储操作的存储
渲染的结果应该被写会
内存并且存储
对于颜色缓存
我们尽可能的在屏幕上展现
对于深度缓存 我们只在
实际绘制和渲染时用到
所以我们在最后的通道中不关心它的结果
我们可以设置一个存储动作为不关心为了节省些带宽
这也是你可以做的优化
如果你并不需要
渲染的结果写会渲染对象
再深入说下加载和存储操作
它决定了纹理内容如何被处理
在开始和结束的时候
另外对清空操作
也有加载操作让你
加载纹理的像素内容
用之前的处理结果
它也不用关心
比如 你想从头到尾渲染一个目标
所有的像素 那么你不用关心
之前的纹理 你也不用清空它
因为你知道你将会设置
每一个像素为一些值
还一种你可以做的优化
如果你知道你会
在这个阶段处理每个像素
我会告诉你 如何创建RenderPassDescriptor
然后创建一个渲染器指令编码器幸运的是
MTKView使这些变得很简单
之前我们配置MTKView
用几个属性
我希望你们熟悉它像清空色
还有渲染目标的纹理格式
实际上你可以通过请求视图得到
当前的RenderPassDescriptor
你会获得一个设置的RenderPassDescriptor
接下来你就可以使用它
创建渲染指令编码器了
你该这么做 调用渲染指令编码器
在你的指令缓存上
你需要重点关注当前的RenderPassDescriptor是
一个潜在的块调用
这样的原因是 实际上它会调用
CA Metal Layers的下一个可绘制函数
我们不会详细介绍但它是用来
获取包含纹理的可绘制对象
来展示到屏幕上
因为那是个有限的资源
如果当前没有可绘制的对象
如果他们所有的在运行然后这个调用会阻塞
所以这里需要注意
我们已经说了加载资源到内存
我们说了创建预验证状态
和创建渲染通道
和渲染指令编码器
如何把数据弄到着色器中
第一我们需要说下参数表
参数表是Metal资源到
着色器参数的映射
你用的每一种资源
如缓存或者纹理
都有他们自己的缓存参数表
在右面你能看到
我们有缓存参数表
和纹理参数表它们中每个都包含几个
缓存对应着参数表中的索引
给定参数表的插槽的可用数量
根据设备决定
你需要先查询
我们具体说下
在渲染指令编码器有个函数
叫setVerTextBuffer
它有三个参数
一个buffer 一个offset一个index
最后一个是我们最关心的
因为它是我们的参数表索引
这是主机端设置资源
在使用着色器的时候
也有个对应的着色器端
像这样
在着色器语言中间
在你的着色文件中 你指定
每一个给定的参数对应一个你要访问的资源
有个属性像这样
这是第一个缓存索引
索引0在参数表中
代表我们刚才在渲染指令编码器的缓存
我们详细看下
当在2D绘制中
我们创建了renderPipelineState
我们需要告诉渲染指令编码器
在绘制前需要用哪个管线状态
这个API就是干这个的
我们调用setRenderPipelineState
用刚才创建的PipelineState对象
用我们创建的着色器配置
我们用先前创建的来绘制
现在RenderPipelineState
有相关的顶点和片段函数了
我们看看顶点和片段函数
我们在2D绘图中主要用这个
回到Metal着色语言看起来像这样
大体上是一个直接的顶点函数
没有复杂的数学操作
它会复制所有的属性 直接连接
函数的第一个参数是一个顶点列表
我们刚才创建的缓存
第二个参数是属于
顶点ID的属性
表示正Metal在处理的定点的
索引
它比较重要的原因
vertexBuffer包含所有的点
我们可以随机获得
实际上我们想在我们顶点函数
一次对一个点操作
这告诉我们正在操作哪一个
我们创建一个VertexOut结构的实例
代表定顶点的各种属性
然后我们传给给光栅
我们创建一个实例 并设置位置
为向量位置vertexId的顶点
颜色也是类似
这里进传递了vertexBuffer数据
给结构体供光栅来做插值
然后我们返回这个结构
让我们看看fragmentFunction
它更简单
所以我们得到了插值结构
它表示
光栅化得来的数据
我们刚抽取了颜色
颜色来自结构
然后再传回去
这个过程中顶点发生了什么
在这个例子里截取空间指定的
被插值然后光栅化然后
被每个片段处理
我们返回由光栅创建的插值颜色
一旦我们指定RenderPipelineState
包含我们的顶点和片段函数
我们可以设置额外状态就像我之前介绍的
包括front facing状态
如果你想指定不同的front facing顺序
而不用Metal默认的
你可以在这里实现
这里有许多配置项但我们只看
一些绘制调用
现在
Metal有很多函数
绘制几何图形包括indexedinstance和indirect
我们只看基本的索引绘制
这里我们想画一个三角形
我们调用drawIndexedPrimitives
我们指定原型为三角形
因为我们想画三角形
我们传递三个索引
来画一个三角形
我们同时需要制定索引的类型
我们之前声明了一个Swift的数组集合
我们这里复制一下
我们还要把indexBuffer传递下去
来表示哪些点应该绘制
我们把位移设置为0
这会画一个
三角形在屏幕上
我们可以添加些其他状态
触发一些其他绘制调用
但第一个演示我们就做这些
为了完成一个渲染过程
我们调用Render CommandEncoder的endEncoding
回顾一下你需要创建一个请求
在开始时获得RenderPassDescriptor
用这个描述符创建一个Render Command Encoder
设置RenderPipelineState
设置其他必要的状态
触发调用最后结束编码
这是我们看到的代码的一个概括
没有啥新东西
和刚才我说的一样
创建一个Render Command Encoder设置状态 设置状态
绑定缓存 然后绘制
你已经渲染了这些内容
怎么样让它显示在屏幕上
非常简单
首先 渲染路径的颜色附件
通常是可绘制的纹理
你可从CA Metal Layer或者MKTView获得
为了获得在实际上显示的纹理
你可调用commandBuffer的present
并给它传递那个drawable
它将会显示到屏幕
一旦所有的处理路径完成
要向实际完成这一帧
由于我们把指令编码进commandBuffer
我们要表明下我们完成了
通过调用commandBuffer.commit()
提交告诉驱动commandBuffer
已经准备好给GPU运行了
总结一下
我们创建了一个指令队列开始
它是一个持久对象我们需要引用它
每一帧我们创建一个commandBuffer
使用渲染指令编码器编码一个或多个渲染路径
通过提交commandBuffer来在屏幕上显示
现在交给我同事Matt
带我们完成这个2D demo绘制
谢谢 Warren
这里是验证部分
一个2D的三角形这是Metal三角形演示
从题目可以看出
非常简单 就是一个三角形三种颜色
在边上被插值
我们看下代码
首先是MTKView的代理
Warren说我们需要实现个函数
这里是MTKView的drawable和sizeable change
它将会在window变化时
响应
例子很简单我们不会实现它
你们在应用中自己实现
另一个是绘制
我们选择把它放到渲染函数
当我们的绘制被调用
我们进入渲染
渲染也很简单
当我们拿到MTKView的当前RenderPassDescriptor
你把它弄出来 如Warren所说
然后你创建RenderPassDescriptor
然后用它编码
大家注意这里
“pushDebugGroup.”
这里你可以和Metal工具交互
当你做帧捕获
这里会列出调试组信息
这里 我们有一个绘制和一个绘制三角形
绘制完我们会弹出调试组
所以绘制显示标签为Draw Triangle
我们看下着色器
正如Warren说的
我们已经有了结构有顶点结构
这是我们放入着色器的数据格式
只有位置和颜色
有vertex out结构
我们会传给光栅
你看到位置被
位置属性标记
这里代表截取空间位置
每个点着色器或点函数 抱歉
都需要有一个
看起来都很熟悉 都很简单
顶点进来 我们有个路径
同时你把它们写出去
在片段函数里我们拿到顶点
被光栅化后 我们读取颜色并且传下去
这个三角形演示很简单
下面由Warren继续
谢谢 Matt
我们已经展示了如何绘制2D内容
2D非常酷什么更酷呢
3D 我么说说Metal中的动画和纹理绘图
进入3D前
我们会经过几个阶段
我们讨论如何真正实现3D
我们用constant缓冲实现动画
我们还会介绍纹理绘图样例
为了进入3D
我们已经指定了我们的顶点在截图空间
我们现在需要在一个模型本地空间指定
然后用一个合适的模型视图做投影矩阵
为了回到截取空间
同时我们将给普通顶点添加属性
和纹理坐标 这样我们可以
在我们的fragmentFunction中设置光照
和设置纹理映射
这里是我们扩展过的顶点
我们移去了颜色属性 添加进一个向量
和一组纹理坐标
和2D中的相似
我们会添加一个新的缓冲存储所有需要的常量
引用我们的顶点和片段函数
用来合适的转换那些顶点
你会发现这个缓存的轮廓
是虚线 这是有原因的
因为我们不想创建另一个Metal缓存
仅仅是出于要管理这一小部分数据
只有几个矩阵
实际上Metal也有很棒的API
用来绑定和管理非常小缓存
所以 对于小数据
小于4K的
你可以用这些API设置顶点字节
直接把数据的指针传给他
当然需要告诉我们大小
Metal会创建和重用缓存
包含那些数据
你可以指定表的索引
这里设置为1
因为我们的顶点已经被绑定在索引0
所以我们绑定在1这样我能从其中读取
在我们的函数中
我们看看函数如何响应
开始之前 我们看一个例子
如何在应用中调用setForTextBytes
我们创建了Constant结构
同时创建
包含两个矩阵相乘
通过模型视图投影和普通矩阵
这个矩阵会变换
本地空间为iSpace
我们用自己的矩阵工具构造
然后把它们相乘
最后用setVertexBytes传递结构引用
然后Metal会拷贝
这个缓存用于绘制
在接下的绘制调用
现在
在去年的 WWDC我们介绍了Model I/O框架
Model I/O包含许多工具
最棒的是Model I/O包含
可以让你生成常用图形的方法
由于MetalKit
和Metal集成非常紧密
你可以创建顶点数据Metal可以直接渲染
我们可以不必手动指定所有顶点
我们可以这样在一些内容创建包
里面绘制模型 导出
然后用Model I/O加载
或在这个例子中 用程序生成
我们看看代码
想生成些vertexBuffers表示立方体
为了在Metal中使用Model I/O
我会创建一个MeshBufferAllocator
MeshBufferAllocator作为Model I/O和Metal间的胶水程序
传递一个设备给MeshBufferAllocator
然后我们可以让Model I/O直接创建Metal缓存
然后传回给我们
所以我们用工具方法创建了MDLMesh
boxWithExtent等等传进我们的分配器
这将会创建一个MDLMesh一个Model I/O网
包含相关数据
我们然后用MetalKit的工具类提取出来
就是为我们提供的
这看起来像这样
首先 我们生成了MTKMesh
包含我们刚才创建的MDLMesh同时包含设备
为了得到vertexBuffer
把它放进mesh然后抽出来
对于indexBuffer需要进行类似操作
这里还有几个参数
我们见过
绘制调用的时候用的
这里强调一下
用Model I/O生成进程几何图形很容易
然后可以将缓冲提取出来直接在Metal中应用
下面说说纹理
我们有了顶点数据
我们想用纹理映射上去 并添加些细节
像你知道的那样纹理是一块内存
用特定的像素格式预先指定
主要用来存储图像数据
在Metal中 创建一个纹理
用描述符对象 很常见
特别是Metal纹理描述符
纹理描述符是参数对象
它把纹理属性弄在一起 比如高和宽
还有像素格式 设备会用
它们生成纹理对象：Metal纹理
我们看看
我们有这些方便的函数
在Metal TextureDescriptor中
可以让你得到一个2D的描述符
仅提供必要的参数：高 宽
像素格式或者你是否想mipmapped
你可调用设备的newTexture创建一个新纹理
这是一个不包含实际图像的纹理
你需要使用替换区域或者相似的方法
你可以查查文档怎么做这里我们用
另一个简单点的工具
叫做TKTextureLoader
这是MetalKit提供的工具用来加载图像
从资源包中 包括资源目录
或者从一个文件URL 还有CG图像
内存中已经有了
以NSImage或UIImage的形式
它们生成填充Metal纹理
用合适的大小和格式
与你已经有的的图像数据有关
我们看看代码
你可以创建一个MTKTextureLoader
通过传入Metal设备
你会得到一个TextureLoader
同时你可以接着或许一个数据集合
或你的集合目录中的其他东西
一旦你拿到了数据
你可调用textureLoader.newTexture
然后传递数据那么将会返回一个Metal纹理
你可能熟悉取样的概念
Samplers和Metal从纹理来说不同
他们没有绑定在一起
Samplers只包含纹理相关的取样状态
一些如过滤模式 地址模式
还有层级详细的参数
这里展示的我们都支持
为了获得我们竟来要绑定的Sampler状态
在Render Commandencoder中做纹理绘制
我们会创建一个Metal Sampler Descriptor
像这样
我们创建了个空的Metal Sampler Descriptor
拥有默认的属性
我们可以设置想要的属性
这里我们让纹理在各个轴
上重复
当缩小的时候使用nearest filtering
当放大时用linear filtering
一旦我们创建了描述符对象
我们调用newSamplerState
得到Metal Sampler State对象
我们可以用来在纹理中绑定采样
在Render Command Encoder中API看起来像这样
我们创建一个纹理 把它放在插槽0
在片段纹理参数表中
然后我们绑定SamplerState在索引0
在Sampler State参数表中
我们看看这些函数
顶点函数这次会和
MVP矩阵相乘矩阵从constant buffer中获得
它会变换顶点的位置
从本地空间到截取空间
我们会从顶点函数返回
同时它还会变换那些顶点
从Models LocalSpace到Eye Space
然后我们做光照渲染
代码里看起来是这样
我们添加了一个参数属性通过缓存1
像我之前说的通过constants缓存获得
我们已创建了一个结构类型
在我们的Metal着色代码中
和SWF代码中创建constant结构关联起来
这样我们可得到MVP通过普通的矩阵
再一次 这个绑定在索引1的参数表
和你看到的属性关联起来
为了进入截取空间
获取vertexBuffer位于VertexID的索引
得到一个位置向量
和MVP矩阵相乘然后赋值给结构
对普通的 进行相同的操作
我们还拷贝纹理坐标
给传出结构
这些都会被光栅插值
我们接着进行返回结构
fragmentFunction比之前更参与
我们想要计算些光照
我们引用两种环境光和漫反射
同时从纹理中采样
应用到表面纹理中
像这样
我们不会详细介绍
需要注意的是
我们添加了一个参数
我们创建和绑定的
我们给它一个访问标识符
我们用来采样
在Argument Table Index的0位置
我们创建的Sampler State在
samplers的ArgumentSlot Zero
想获得实际的文本
调用纹理的Sample
Text2D.Sample有个采样状态
和纹理坐标给到颜色向量
我们接着做光照
我不会详细介绍
它根据正常和光照方向的积来得到
我们设置了一些常量
在我们之前的着色文件演示中可以看到
这相当多
我们构造特定片段的颜色
通过乘以从纹理中采样的值
通过光照反映到动画纹理的立方体上
现在让Matt给大家展示下
好的 我们看看演示
这里有个Metal纹理网
你可以看到它是个很复杂的立方体
一些简单的光照和纹理贴图
在一个设置好颜色的背景上
欣赏下它
我们看看着色器
比起上一次 你能看到一些新的东西
首先是Constants结构体
是Swift写的
有4 X 4的模型投影矩阵
和3 X 3的普通矩阵它们是用来做变换的
如Warren所说我们有些光照数据
环境光强度 这里很弱
但漫射光 却很高
光的方向
我们用来计算点积
输入和输出结构有点不同
我们现在有更多的信息需要向下传递
我们有position
有normal 用来光照
和纹理坐标 用来纹理贴图
相似的 当从顶点函数输出时
我们需要相似的数据
我们看下顶点函数
如Warren所说
就是些简单的矩阵 乘法运算
然后传给纹理坐标
快速的看下片段函数
就是刚才给你展示的
我们看看渲染器
接着往前
我们有个小动画
所以我们需要每段时间更新我们需要知道立方体需要旋转多少
这里有个帮助函数
来更是时间间隔
这将修改Constants
像Warren说的我们不想让很多数据通过GPU传递
所以当你设置顶点字节
传一个小的结构 之前的两个矩阵
我们用来计算变动的位置
放入纹理和采样 触发绘制
我建议你们记住
用你的调试组 这样你可以知道
现在在什么位置如果你想稍后捕获帧的话
展示绘制内容 提交 然后就可以了
很棒 谢谢 Matt
通过这些使用Metal的课程
我们想充分利用我们这几年的
成果 教授Metal
同时介绍非常棒的新工具
让Metal更容易使用
我们希望
这两部分课程对此有帮助
你看到Metal是强大的低负载的
GPU编程技术 幸运的
你现在已经熟悉它
其中的一些API
Metal非常接近
和符合GPU的实际运转情况
概念上也是这样 我们想把
耗费资源的操作尽可能提前
你已经看到了几种方式
怎么安排这些API
这个课程不是强调一些限制和细节
主要是
想给你灌输些能力
你已经看到如何明确的进行内存管理
和指令提交 可以让你的工作更智能些
如果你知道你的应用是怎么回事
你知道它在做什么 然后你可以
直接控制GPU
当然接下来的几节关于Metal课程
在今年的 WWDC我们会给你展示更多
的Metal的内容
当然 它会让你创建有更好体验的应用
想要了解更多的关于602会话的信息
你可以访问这个URL同时可以参考其他相关课程
第二部分还会在这个教室
明天我们会有Metal的新东西Parts I和II
和高级Metal着色优化课程
谢谢祝你们在 WWDC 中大有收获