采用Metal技术 第二部分
大家好 欢迎来到全球开发者大会
希望目前为止 你们都过得很愉快
你们已看过很多优秀的演讲
我们为你们准备了非常棒的一周
会非常有趣的
我是Matt Collins
这是我的同事Jared Marsau
我们将为你讲解采用Metal技术 第二部分
这里是603号演讲
如果你走错了 你也能看到一些图像
所以 让我们回忆一下
我们共有两部分“采用Metal技术”演讲
希望你们也参加了Warren的第一部分演讲
第一部分我们讲解了基本概念：
基本绘图 光照 纹理诸如此类的优秀功能
在本次演讲中 我们会更上一个层次
我们会绘制很多对象
我们将会讲解如何管理动态数据
大量的动态数据
GPU-CPU同步
我们将会以多线程编码的话题结束
明天我们还有精彩的演讲
我们会讲解Metal的新特性
明天的第一个演讲将讲解细分曲面 资源堆
无记忆帧缓冲
和关于我们改进后的工具
以真正帮助大家做出最好的应用
第二部分 我们将要讨论函数专用化
以及函数资源读写
丰富的色彩和纹理资产
此外还有Metal性能着色器
如果你还想继续深入
我们还会有关于高级着色器优化的精彩讨论
着色起性能基础 调整着色器代码
及更多关于硬件工作原理的细节将会十分精彩
如果你对调整着色器代码非常感兴趣
想让它们达到最佳效果请关注明天的讲座
这里是采用Metal技术的第二部分
我们将在第一部分的所学基础上继续
我们弄清楚如何启动和运行
让我们看一下你所需要的概念
能让Metal在真实世界得到最大的应用
我们有一个演示将会把很多内容绘入一个简单的场景
在今天的演讲中我们都会使用该演示作为上下文
并从中学到很多内容
我们将会讲解数据的理想组织流程
如何管理大批量动态数据
CPU和GPU同步的重要性
以及如我之前所说 一些多线程编码
希望你已对Metal的基础有所熟悉
因为我们不会再次讲解
我们预设你已经理解如何新建Metal队列
新建Metal命令缓冲如何编码指令
我们在此基础上进行下一步
我们先来看演示看看我们的目标是什么
现在我们有10,000个立方体
它们都在四处旋转 在空中加载
很有趣的画面
Metal允许我们展开无数绘图调用
开销却很小
所以在此有10,000个立方体和10,000个绘图调用
你可以看到在底部 有一点阴影
我们正使用一个阴影映射
它被放在底部是一些美观的反锯齿线
产生一些深度暗示
当然是所有的立方体
所以怎样才能渲染这样的画面？
我们有很多对象
每一个对象都有自身相关联的唯一数据
我们需要位置 旋转和颜色
每一帧都必须要更新因为我们在动画显示它们
所以这是我们不断在改变的一组数据
不断重新通知GPU我们正在绘制什么
我们还可以绘制更多的对象
还可以再多一点
你可以把它们转动起来
看到它们正漂浮在空中
所以我们有一个立方体的绘图调用和相关数据
我们得想想该如何更好地思考这些数据
如何管理它们
以及如何让它和GPU通讯
让我们深入看一下
谢谢你 Jared
管理动态数据
这是每一帧都在变化的大量数据
可以想像 在一个现代应用里比如一个游戏
你也需要每帧都要更新的大量数据
所以我们的绘图基本看上去是这样
我们想遍历所有在绘图中感兴趣的对象
并更新它们
然后我们想为每一个对象编码绘图调用
然后我们必须提交所有这些GPU指令
我们有很多对象
我们从10,000个开始 不断增加
直到10万 20万个
每一个对象都有自己的数据集合
我们要找到更新数据的最好方法
过去 你可能做过类似这样的事情
你把更新好的数据推送到GPU
可能是统一形式或其他
绑定一个着色器 一些缓冲 一些纹理
然后开始绘制
然后你推送更多的数据
绑定着色器 缓冲 纹理
绘制下一个对象
在我们的场景里 重复1万 2万次
但是我们想跳出这样的模式
尝试新的方法
如果我们可以预先加载所有数据
所有发出的指令 以及数据引用都已经存在
GPU是一个非常强大的处理器
它不愿意等待
如果所有数据都已经就位只需把GPU指向它即可
它会很高兴地开始处理
为我们处理所有的渲染
我们发出的每一个绘图调用
都可以引用合适的数据都已经存在了
在我们的示例中 这一切很简单易懂
我们有一个绘图调用 引用了一组数据
第一个绘图调用引用第一组数据
第二个 第二组 依此类推
但并不是只有这种方法
实际上可以重复使用数据
我们有一些数据如前面的这些 帧数据
可以从所有的绘图调用中引用
或者 我们可以有一个绘图调用
在不同的地方引用两组数据
如果你熟悉实例化的概念其理念是很相近的
开始渲染的时候所有的数据已经准备好
Metal是如何做到的？
在我们的应用里新建一个单一Metal缓冲
这是我们的常量缓冲
它拥有我们需要用来渲染框架的所有数据
我们想事先就新建好 在渲染循环之外
并且在每一次绘制中重新使用
我们不需要复制任何数据
再次强调任何绘图调用可以引用任何数据
所以没有必要复制
每一个绘图调用都会把一个偏移引用到缓冲
它会作一小部分跟踪处理从而知道哪个绘图代表了哪个偏移
你可以运用一切绘图 一切都已经就位
我们来看看这部分代码
这是应用里的代码
你可以认为我们有两个数据集合
如我之前所讲 有一个帧数据集合
将在这里进行更新
这是每个对象都发生改变的数据集合
这是唯一旋转位置 等等
我们需要把两组数据都准备好
我所说的每帧数据是什么意思呢？
这是每次进行绘图调用时都保持一致的数据
比如 在本例中 有一个视图投影矩阵
这是个4X4的矩阵 很直观
如果你熟悉图像处理
它代表了照相机变换和投影
在框架范围内将不会发生改变
所以我们只需要一份副本
我们想要尽可能多地重复使用数据
所以我们新建一个副本 放入缓冲内
开始填充
在这里 是常量缓冲
也就是新建的Metal缓冲
通过Contents函数我们有了一个指向它的指针
我们的应用有一个帮助函数也就是取出帧数据
它将返回我刚演示过的主通路结构
里面有视图转换
视图投影转换不好意思
之后只需简单地把它复制到缓冲的前端
然后一切就绪
我们的缓冲看上去将会是这样
我们有一个主通路 含有合适的帧数据
并且把它放到巨大的常量缓冲的前端
所以后面会有这一片空白区域
如之前所见我们需要做1万次 2万次的绘图调用
所以需要开始在里面填充很多信息
然后我们有了一组每个对象数据
这是绘制单一对象所需要的唯一数据
在我们的例子里有一个“局部空间到世界空间”转换
它是位置和旋转的串联
还有颜色
这就是每一个绘图调用所需的数据集合
我们会遍历想要渲染的每一个对象
记录偏移位置到缓冲
我们有“更新数据”实用工具函数
它将更新旋转数据
然后更新偏移数据
这样将数据紧密封装一边遍历一边填充
看看“更新数据”函数是什么样子
它非常简单
动画效果似乎不是本次演讲的范围
有一个小帮助函数 “更新动画”函数带有“增量时间”参数
在你的应用里可以按照自己的意愿编码
而且确实应该这样做
但是也要看你需要什么样的动画
在我的例子里它返回一个对象数据对象
它有局部空间到世界空间转换和颜色
和之前一样 把它复制到常量缓冲
看上去是这个样子
帧数据已经准备完毕
还有别的数据
其他的数据 还有其他的
所有的数据都到位了 我们准备好渲染
但是不是还缺了点什么？
确实缺了什么我想要提醒你们注意的是
我们有一个常量缓冲
我说过新建一个Metal缓冲然后反复使用
这样做有一个问题
CPU和GPU实际上是两个不同的平行处理器
它们可以同时对同一内存进行读写
会发生什么 如果有函数
正在读一块内存 而另外有函数在写？
资源争用
看上去有点像这样
CPU准备好一个帧数据写入一个缓存
GPU开始处理
它从缓存里读取数据
而CPU对这一切一无所知
它决定 我要准备下一帧数据
然后它开始覆盖相同的数据
现在结果变成未定义
我们不知道读入了什么
读出什么 或者写入什么数据状态会是什么
所以认识到在Metal里这不是隐式处理 这点很重要
CPU和GPU可以随意同时写同样的数据
必须自己同步访问权限
就好像编写多线程的CPU代码
必须得确保没有踩到自己
这把我们带到了CPU-GPU同步的主题
让我们从简单的开始
最简单的方法就是 等待
把指令提交给GPU之后
CPU绘图函数做好所有的工作
提交指令 然后就坐在那儿等
直到它确保GPU的工作完成
这样我们就知道永远不会覆盖
因为我们试图生产下一帧数据时GPU是空闲的
这种做法不够快 但很安全
所以需要有某种机制让GPU通知我们
嘿 我工作完成 你开始做你的吧
Metal提供了这种机制以回调的形式
我们称为处理程序 其中两种很有意思
“添加计划处理程序”
当命令缓冲被计划在GPU上运行时将执行该处理程序
对我们来说 更有意思的是“完成处理程序”
它将被调用
当GPU结束执行一个命令缓冲时
命令缓冲完全退休时
此时我们确定修改任何资源都是安全的
正在使用的任何资源
这样非常完美
我们只需要采用某种方法告诉自己
嘿 我们完成了 继续下一步
你们当中有多少人熟悉信号量的概念？
有谁知道？
很好
快速介绍一下信号量的背景
它们是同步基元
被用来控制有限资源的访问权限
应用在此堪称完美
我们有一个常量缓存它是一个有限资源
我们将会新建一个信号量 初始值为1
信号量的值代表
有多少想要保护的有限资源
新建一个信号量
它应该建立在渲染循环以外
一旦开始绘图 第一件要做的事情
就是等待信号量
Apple里的信号量称为“等待”
有人称它为“占据”有人称之为“倒数”
无关紧要
理念就是等着它
把超时设置为遥远的未来
也就是说我们会永远等待下去
如果没有资源可用 线程会进入休眠
等着做点什么
我们结束后
在完成处理程序里 我们会通知信号量
那将会告诉我们 修改资源又安全了
工作已全部完成 可以进行下一步
这是一个有点幼稚的同步方法
看上去有点像这个样子
我们会把帧数据0写入缓冲
GPU从缓冲读取
CPU将会等待
当GPU处理完帧数据0
它将发送完成处理程序帧数据1开始工作
并将在CPU上新建一帧数据
GPU上会对其进行处理 依此类推
这种方法可行 但如你所见有这么多等待时间
CPU和GPU实际上都有一半的时间处于空闲
看上去并没有好好利用计算资源
我们想要做的是重叠CPU和GPU的工作时间
这样就可以利用系统固有的并行机制
但还是需要想办法避免踩到数据
所以我们理想的工作量看上去是这样
第0帧将会在CPU上做好准备推到GPU
当GPU处理它时
CPU开始新建帧数据1 等等反复如此
在此谨记一点
CPU实际上要比GPU超前一点
请注意 当帧数据2在CPU上时
GPU上只有帧数据0是完成的
所以CPU有一点超前
也请你一直记住这点
来看看演示里的解决方案看我们是怎么做的
我们想要重叠CPU和GPU但我们知道无法做到
用一个常量缓冲 而不等待很长时间
所以解决方案是新建一个缓冲池
所以新建帧数据0
把它写入一个缓冲
然后CPU开始工作
新建下一个帧数据 写入另一个缓冲
此时 GPU可以自由从缓冲中读取
之前的那个缓冲
我们没有无限的缓冲
因为没有无限的内存
所以缓冲池必须得有个限额
在我们的应用中 我们选择了3个
这部分你得自己决定
我们无法告诉你怎么做
因为要考虑延迟的问题
想要用多少内存
所以我们建议你测试自己的应用了解多少是最合适的
本例中 我们选择3个
在这里 可以看到缓冲池用完了
我们准备好3帧数据
但GPU只处理完成了一帧
所以得等一会儿
现在 帧数据0已经完成
所以可再次使用池里的缓冲 如此继续
来看一下代码
同步常量缓冲的访问权限
我们已经有了一个信号量
它可以很好地控制有限资源的访问权限
在本例中 我们的限制是3
但这个数字可随意设定
在这里按照限制数字新建了一个信号量
我们不再只新建一个常量缓冲
而是新建一个缓冲数组
最后
需要一个索引
我们用这个索引表示
当前可用的常量缓冲数
我们可以遍历数组并回返
信号量会控制我们的访问权限和保护我们
所以在绘图函数里我们会立即等待信号量
如果没有可用缓冲 就进入休眠
一旦取得信号量 就开始工作
我们知道获取当前的常量缓冲是安全的
在索引中 “当前常量缓冲”记录哪个资源可用
然后正常填写帧数据 编码所有命令
进行更新 添加完成处理程序
然后我们通知信号量说嘿 该帧数据处理完了
你可以进行下一步了
最后要做的是更新索引
我们加上1 我们取模进行环绕
我们不用担心覆盖自身
因为信号量会保护我们
这就是演示中的常量缓冲
演示里有一个3个缓冲的数列
但我也看过有些应用会跟踪缓冲
把它们标记为该缓冲正在被帧数据7读取
该缓冲正在被帧数据5写入
在本模式下 我们不需要这么做
信号量为你做所有同步的工作
而且如果你取得了信号量
你可以确认最后正在使用该资源的帧数据已经结束
否则你还会处于休眠
所以现在数据都已经准备好并且受到保护
我们想要发出一些绘图调用
在屏幕上显示一些图像
这就是本演示的基本渲染循环
我们有两个通路：一个通路绘制阴影映射
一个通路读取该阴影映射
我们决定把它们分成两个独立的命令缓冲
这样做有一个很好的理由
它让我们有两个编码函数
是独立和唯一的
它们不依赖于彼此
你编码阴影通路 你把它传到命令缓冲
以及你已经填写的常量缓冲
它会编码所有的命令 渲染阴影映射
然后你有了一个独立的编码函数可以编码主通路
把它传到主命令缓冲以及其他所需数据
编码所有其他的命令
编码结束时
调用提交两个命令缓冲
输出 帧数据处理完毕
那么 如何真正编码绘制其中一个立方体？
我们需要一组数据而不仅仅是旋转数据
我们需要立方体的一些几何数据
这非常简单 你知道
把立方体想成是8个顶点也许还有一个索引缓冲
在本例中 我们不需要任何复杂的材料
只需用到很简单的漫反射着色
因此我们可以重复使用管道状态对象
在所有立方体范围内
我们之前提到过每帧数据
我们需要它的一份副本
我们更新它 准备好
当然我们还需要 每光学数据
以及我们动画里展示的 LocalToWorld和颜色信息
所以当发出绘图调用时
我们想确保引用了正确的数据
所以编码器会产生命令
把它们放入命令缓冲
绘图调用0
将会引用帧数据和我们感兴趣的对象
绘图调用1 同样 将会引用帧数据
和对象1数据 依此类推
这样一切都会准备好
发出调用 GPU开始处理
现在我们有很多调用要发出
你知道 在演示中 至少有1万个
我们想尽可能高效地发出调用
我们想避免重复的工作
不想每一次绘制就进行重设
所有共享资源 几何 管道状态
我们只想设一次 然后保持
这样就可以避免重复的状态更新
并且避免重复的变量表格更新
还有一点值得注意
顶点和片段变量表是完全分开的
你可以将缓冲绑定在顶点阶段
而不是片段阶段 反之同理
但若必须要把所有绑定到两个阶段
调用“设置顶点缓冲”函数时可能会调用两次
“设置片段缓冲”函数也是如此
这就是为什么在本例没有使用“设置顶点字节”函数
你可以想像我们有50,000个对象
必须把所有那些数据复制两遍
一遍在顶点阶段 一遍在片段阶段
很快工作量会变得很大
而如果把所有数据放入一个缓冲只需引用它
我们就不用担心该问题了
最后我想指出的是
使用新函数
“设置顶点缓冲偏移”和“设置片段缓冲偏移”
这只是把指针指向其中一个缓冲
可以看到 在调用这些函数时
它们并没有把引用放入Metal缓冲
它们只取出了一个偏移和一个索引
因为你肯定已经设置该指针指向缓冲
这样缓冲内部的指针也随之改变
这就是我们想要实现的
我们有一个常量缓冲 正在遍历
所以可以在一开始只设置一次
然后每一次绘制时就调用“设置顶点缓冲偏移”函数
并且把下一个绘图调用指向缓冲中正确的位置
看上去有点像这样
绑定该常量缓冲
然后调用“设置顶点缓冲偏移”函数
用该偏移量作为参数
然后再次调用 继续往前
再一次往前
我们并没有修改该索引指定的缓冲
我们只是修改了缓冲里的偏移值
记住这些原则
编码其实非常简单
可以事先设置好一组数据
每帧常量是很显然的
因为我们知道会修改它
所以一起来设置
我们将一次设定常量缓冲因为它必须要准备好
我们才能使用设置顶点缓冲偏移函数
还会设置几何缓冲 和管道状态
我们知道整个立方体范围内它们是共享的
然后终于可以开始循环通过想要绘制的对象
设置当前绘图调用
常量缓冲的偏移值
然后我们真正开始绘图
这里是 "编码主要通路"函数的代码
在例子里的
首先设置顶点缓冲
那是几何和渲染管道状态
也就是光照阴影管道
我们将会设置常量缓冲
在之后调用“设置顶点缓冲偏移”函数
在本例中把它传给顶点和片段阶段
然后设置每帧数据
你现在看到我已设置了一个常量缓冲
有两个分开的索引 和不同的偏移
Metal允许你随意这样做
可以把同样的常量缓冲设给每一个索引
带有不同的偏移 如果你愿意的话完全取决于你
接下来马上看看缓冲池
我们需要追踪偏移 因为我们不是
在常量缓冲的开始部分开始的
还有一些帧数据在那里
所以偏移将会被推回 经过帧数据
然后将调用“设置顶点缓冲偏移”及“设置片段缓冲偏移”函数
来把该绘图调用指向要绘制的正确数据
发出绘图调用
然后再次设置偏移 一次完成一个对象
绘图都准备好了
这仍然是非常线性
我答应做一些多线程编程
并且Warren提过
可以在Metal里进行平行编码
该怎么做？
一个理想框架看上应该是这样
渲染线程正在埋头苦干然后它意识到 嘿
我得渲染一个阴影映射还得渲染一个主通路
要是我能并行编码就好了
我有很多CPU
如果能调度一些工作出去进行一些编码
然后回来继续参与渲染线程
然后渲染线程把它推给GPU
让GPU做接下来的工作
这种方法一定非常好
你们中有多少人用过GCD（大中央调度）？
此时非常适合使用大中央调度
大中央调度是Apple的多处理API
该API让你新建队列
这些队列管理计算资源
在你的机器上
可以新建两种类型的队列
一种是串行队列
当你通过串行队列调度工作时
可以保证所有工作都按照顺序处理
但对我们来说更有意思的是并发队列
当你把工作调度给并发队列
大中央调度会查看系统
为你做出最好的安排
这非常完美
我们有两个需要并行的作业
所以我们新建这一个队列把工作推送给它
它会帮我完成
有另一个对象你想新建一次并可以重复使用
这里是一些新建并发调度队列的代码
你应该始终为队列加上标签
在此我使用了非常具有创造性的标签队列
但你也许想称呼它别的名称
所以我们修改了部分代码
一开始还是新建命令缓冲
但是既然我们如此聪明会使用两个命令缓冲
并把编码函数分成两个不同的函数
我们除了调度工作外没什么别的事情可做
所以dispatchQueue.async
是大中央调度中用来调度工作的主调用
这是一个异步调用
它将推送工作 线程将会继续
在这里我们调度了阴影通路
然后我们调度了主通路
我们得想办法提交该工作
所以我们调用“调度障碍同步”
这将确保此时所有的工作都已经完成
最终我们重新加入 提交工作
在这里 顺序是很重要的
阴影映射必须在我们要引用的时候完成
所以必须首先提交阴影命令缓冲
之后是主命令缓冲
在这里我还想提出一点
你们之中有多少人熟悉“闭包”的概念
很好
有多少人曾经在闭包捕获自身时遇到过问题
你以为自己在引用别的？
你们可诚实作答我们都会发生
我只是想提出这一点
闭包捕获自身
如果你正在引用一个成员变量或其中的成员变量
而你并没明确指定self.iVar
它还是会引用那个变量
如果你想确保引用正确的数据
在外部捕获它是一个好方法我将会马上对此进行演示
这两样东西做的事情不一样
第一个调用中 编码阴影通路的地方
可以看到正在获取的常量缓冲
独立于self.constantBufferSlot之外
我实际上并不知道它执行时会怎么样
这是真正的异步编程
所以当调度正在运行时
它已经背着我发生了改变
也许是对的 也许不对 我无法保证
所以请谨记这点 不要那样做
相反 我们想捕捉一个引用
到我们感兴趣的常量缓冲中
所以在这里 取出常量缓冲
把它从数列里拿出去
然后再发出调度
引用已经获取的缓冲
这样就能保证确切知道读取的是哪个数据
这就是多线程编程的趣味
示例中的实际代码看上去是这样
捕捉常量缓冲
当使用它时 保证用的是正确的那个
是已经捕捉的那个
知道正在使用该帧数据的常量缓冲
我之前提过“排序”以及它非常重要
当新建一个命令缓冲 提交
GPU上执行的顺序
通过你提交到GPU上的顺序来表示
所以如果先提交阴影命令缓冲
再提交主命令缓冲
可以确保在GPU先执行阴影
接着再执行主命令缓冲
有时我们把这称为 隐式命令缓冲排序
但是可以变得显式一点
Metal提供了“排队”函数
强制执行命令缓冲排序
如果有一组命令缓冲 可以把它们排队
这样可以确保它们按照那个顺序被执行
不论提交方法和提交时间
这是非常酷的方法 因为它允许你
从多重线程上提交命令缓冲按任何顺序
而你完全不用为此操心
运行时将会确保运行顺序是正确的
我们来看看如何在代码里实现
新加了一些内容
当新建命令缓冲时
马上按照顺序把它们排队
顺序很重要
所以我们还是会让阴影命令缓冲先排队
然后是主命令缓冲
但是现在 当我们调度时
我们可以从别的线程上提交
再次强调 运行时候将会确保
顺序正确
所以我们不用为此担心
这实际上移除了之前的障碍
因为不必重新加入 再提交命令缓冲了
它们已经自己提交了
我似乎跳过了所有的同步内容
不久前我刚说起过
我们还是需要了解 因为我们还是
会自我覆盖 如果我们不同步的话
所以能否把同样的同步原理
应用到这个多线程世界？
答案是可以 并且实际上它非常直观
回到友善的信号量 还有常量缓冲数列
记住取出你想要的正确缓冲
一开始 等待信号量如果没有可用缓冲就进入休眠
我们已用排队强制执行了顺序 推出去
我们知道 主命令缓冲是框架里最后的命令缓冲
且我们知道要通知帧数据已经处理完毕
所以应把完成处理程序加到主命令缓冲
可以在调度内部完成
主命令缓冲是最终命令缓冲
我们为它添加上完成处理程序用来通知信号量
在调度内部提交它 如之前所做的那样
现在你可能注意到我引用self.semaphore
不久前我刚告诉你要注意这点
所以发生了什么？
结果是信号量是一个同步图元
我们确实想要用同一个
和所有其他线程一样
所以需要知道信号量的值
在线程正在执行的时候
所以在本例中确实需要self.semaphore
需要时刻注意
这是渲染的方法
在渲染函数的开始 等待信号量
选择并发常量缓冲
把数据写入常量缓冲
也代表了所有的对象
把命令编码到命令缓冲
可以单线程编码也可以多线程 随你所愿
在最终命令缓冲里加上一个完成处理程序
用它来通知信号量 完成时通知我们
然后提交命令缓冲
GPU接过所有
开始处理帧数据
我们再看看演示 看看最后呈现结果
可以看到在左上角这是单线程编码模式
可以看出正在进行多少绘图调用 10,000个
右上角 可以看到编码一个帧数据的时间
我们看到是5毫秒
我们可以增加绘图的数量
绘制的东西越多 时间越长
这就是单线程模式
你们想想看 我们在绘制一个阴影映射
也就是说必须在阴影映射内发出40,000个绘图
当绘制主通路时意味着我们必须再发出
另外的40,000个绘图来引用
但是再次强调 我们可以并发操作
所以在演示里 加了一个并行模式
可以看到速度有多么快
看一看正在发生的一切
你可再让它们飞起来一点
在这里 我们有4万个立方体独一无二 各自分离
它们随时都在更新
我们使用大中央调度并行编码了许多内容
我们有两个命令缓冲
一个产生地上的阴影地图
一个为所有的立方体渲染上色
光照很简单 即漫反射着色 基本上是
沃伦之前说过的N.L光照
这就是我们的演示内容
这些都会作为示例代码 供大家参考
希望你们可以把它拆开取得其中的一些想法
和思路并且能够应用到自己的代码当中
所以我们今天讲了什么？
你们走进来的时候
希望你们也听过沃伦的演讲
可能稍微了解一点图形的知识
或者以前有相关编程经验
但带你们一起了解了Metal里的一切
Metal的概念性的概览它的相关原理
是运用API 和硬件相近的API
及和驱动相近的API
我们学习了Metal设备
即Metal的根对象也是一切的来源
稍微讨论了加载数据到Metal
以及不同的资源类型 和如何使用它们
Metal着色语言 即C++的变体
可以在GPU上编程
我们讨论了建立管道状态
事先验证过的对象 包含两种函数
顶点或片段 或某个计算函数
和其他在预先验证状态的对象
能在运行时节省时间
然后我们讨论了发出GPU命令
创建Metal队列创建该队列的命令缓冲
还有创建编码器填入命令缓冲
然后该工作发送给GPU
我们带你了解了动画和纹理
以及使用设置顶点字节 发送小位数据
以支持动画效果
之后当小位数据不够时
我们讲解了管理大批量动态数据
使用一个大常量缓冲以及在不同的地方对其进行引用
在系统外反复使用数据
我们讨论了CPU-GPU同步以及确保
CPU和GPU不彼此覆盖
及互相协作的重要性
最后
我们讨论了一点关于多线程编码的内容
你如何利用Metal的大中央调度编码多命令缓冲
同时编码队列中的所有缓冲
这就是采用Metal技术
希望你喜欢本次讲座
也希望你把其中一部分应用到自己的应用里
让应用变得比现在更好
如果想了解更多信息 可以访问网站
developer.apple.com/wwdc/603
明天我们还有更多的演讲我大力鼓励你们能够参与
上午11点有“Metal的新特性 第一部分”
晚些 下午1点40分有“Metal的新特性 第二部分”
这两个讲座将告诉我们Metal世界里所有新特性
你可在应用里加入很棒的内容让应用更优秀
之后 为了你们当中的着色狂人
下午3点有“高级Metal着色器优化”演讲
如果你想知道如何更好地利用着色器
我建议你们参与该话题非常棒的演讲
感谢你们前来听我们的讲座
欢迎来到全球开发者大会希望你们剩下几天过得愉快
再次感谢