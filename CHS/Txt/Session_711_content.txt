NSURLSession：新特性和典范
谢谢大家 早上好
感谢大家今天的到来
这里是NSURLSession:新特性和典范讲座
我是Jeff Jenkins
我是一个软件工程师来自网络技术部
我今天有一些非常有用的信息想和大家分享
关于NSURLSession
那我们还等什么现在就按日程开始
看看今天我们会讲些什么
NSURLSession API给我们提供了非常丰富的类
和方法可以简化现代日常网络工作的复杂性
今天我们就来讨论下NSURLSession API已取得的发展
我还要和你分享一些它的新特性
和我们对这个API所做的强化
我们将会用一个实例应用向你展示
一些新特性和运行状况
我来花些时间谈谈安全性
对于你们用户来说保护你们的数据和隐私很重要
如果这个对你们很重要
我们就知道这个对你和你的应用程序很重要
我会和你们分享下我们做得一些技术强化
对于NSURLSession安全性
在讲座的整个阶段
我会不时的和大家分享一些最佳实践和技巧
这样你就能让你的应用变得更了不起
好了 我们先从顶层API开始看起
它对Apple所有平台的应用程序都是可用的
这么多年来Foundation框架一直支撑着NSURLConnection API
NSURLConnection现如今成为了一个强大的网络抽象
它提供了很多非常好的基础网络功能
可以被开发者在应用中使用
但是 我们常问自己怎么才能做的更好
还有开发者会想要我们做什么
于是我们就坐下来讨论这个话题
然后我们发现很多问题的答案都和
配置网络有关
但是在应用中配置网络可能会非常困难
特别是你需要
在同一个应用程序中配置不同类型的网络
因此 我们就采取了行动
在2015年我们正式的弃用了NSURLConnection API
意思是我们不会对那API增加新功能
它只能得到很少的维护
但是我们在2013年的WWDC 上正式弃用之前
我们引入了NSURLSession
来替换Foundation层网络的API
我们当时提倡过你们我们现在继续提倡你们
在网络代码中开始使用NSURLSession API
现在正在使用的应用
和你未来即将开发的应用程序
既然NSURLSession是最好的顶层API
对于Apple平台的网络编程来说
先来看一些NSURLSession的基础知识
如果你想要一个详细深入的NSURLSession介绍
我推荐你去2015年 WWDC
特别是2014年的
然后看看那些
和NSURLSession讲座配套的视频和幻灯片
我一直吹捧NSURLSession API
推荐在你的应用中使用这个API
那到底为何NSURLSession值得这样的称赞？
其中一部分好处是我们会持续有力的支持
HTTP/1.1协议
我们也支持SPDY协议
但我们不赞成新网页服务的建立基于SPDY协议
你应该朝前看 使用HTTP/2协议
显然我们的NSURLSession支持HTTP/2
我们的支持是基于RFC7540的
而且我们会不停的给这个协议增加新的功能
应用安全传输 或ATS
是NSURLSession内置非常好的功能
它是一个安全性功能可以提高隐私保护
和数据完整性在应用和网页连接过程中
ATS最重要方面之一
是你的应用必须使用HTTPS协议
同时它允许你 也就是开发者
在建立连接时采用最佳实践
通过HTTPS来和远程服务器通信
HTTP严格传输安全或叫HSTS
是NSURLSession内置的另外一个非常好的功能
这个功能保护了用户的数据和隐私
现在它可以通过HTTP报头进行配置
来自你的网页服务
或者它可以通过预加载的列表进行配置
（列表）是嵌入在你应用程序系统中的
当配置好了以后所有被传输 发送 接收的数据
都会通过一个安全的连接进行
HSTS最棒的
是它不需要在你的应用程序中进行任何代码改动
所有非常好的内置功能都支持
来处理缓存cookies代理
和认证请求的内置子系统
所有这些都是NSURLSession自带的
最后特别是 配置
正如我所说我们讨论了很多如何才能把
网络或在你应用程序中配置网络变得简单一些
因为我们需要更好的去控制网络
所以我们刻苦钻研了配置这一块儿
为了达到二级精度和让你更好的控制网络
在NSURLSession中我们创建了一个新的类
叫NSURLSessionConfiguration
这个类包含了很多你可以配置的属性
你可以在你的应用程序中
根据不同的网络需求创建配置文件
这里是一些属性的一个样本
你可以用NSURLSessionConfiguration来设置它们
安全传输层协议或TLS版本
你可以控制TLS版本的最低值和最高值
以便你的应用来支持
我们默认设置TSL最低版本是1.0最高版本是1.2
你可以用你的应用程序控制蜂窝数据的使用
你是否允许你的应用使用蜂窝网络
可能你只想用Wi-Fi网络你就可以在这里设置
你可以指定你的网络服务类型
这里的一些例子可能都是默认值
也是标准的网络数据流量
你的应用可能会有VoiP控制
或视频数据和声音数据各种不同种类的数据
说实在的这只是低端网络层的一些提示
告诉你都有什么样的数据这样才能建立一个高质量的服务
这对你设备上运行的程序是最好的
Cookie政策
也许你想让你的cookie只存在一段时间
或者一直存在
这里就是设置它的地方
同理 对于缓存也许你想要一个临时缓存
或者在加载应用时用持续缓存
这里就是设置它的地方
你还可以指定存储对象
好吧 有可能你需要在不同类型的网络之间共享缓存
或不同类型网络间共享cookies而且全部在你同一个应用中
这里就可以设置存储对象实现那个配置
超时设定你可以设置资源和请求的超时时间
这样你的应用就可以处理网络中的错误情况
假设大多数人都有些了解NSURLSession API
若没 去2014年 WWDC 看看关于NSURLSession部分
你会更深的了解那个API是怎么工作的
我想对于我们剩下要谈的部分
最好能看一下NSURLSession
从代码角度来看是怎么工作的
很简单 我们第一步要做的
是创建一个配置对象
第一件事 这里我们把它称作NSURLSessionConfigurations
.defaultSessionConfiguration
我们全部使用默认值然后我们就有了一个非常简单的配置可以使用
现在我们把那个配置传给一个session
通过调用NSURLSessions emitter可创建一个session
它接收的参数是一配置对象
噢！我们就有了一个非常简单的session可以使用
有了这个session我们就可以做点事情了
好 我们首先要建立一个NSURL
并指定它的端点
就是我们从哪儿接收和请求数据
当我们有了它我们就可以新建一个任务
在此我们调用dataTask方法
然后把NSURL对象
是我们之前新建的传给dataTask方法
我们也提供一个闭包
这个闭包在这里被异步地调用
当我们的任务加载完成时
请求的资源就返回给了我们
老样子 别忘了你要确保调用了task.resume
我们新建的所有任务都处于挂起状态
你必须调用task.resume来执行那个任务
好了 现在复习下 简单的复习
NSURLSession实际上就是一个三部曲
首先你需要新建一个配置对象
有了那个配置项你就可以新建你的session
有了session你就能开始干活了
还要在session上新建些任务
我现在要建议给你些最佳实践
一定要避免单任务对单session的模型
你绝对不应该这样设置你的网络
说真的 你应该这样设计
有一个session服务建立很多很多任务
当然你也可以有多个session
但是一定要避免单session对单任务的模型
原因是它真的会降低你的网络性能
你可以通过创建很少的几个sessions运行很多任务
这样就会更好地管理内存优化OS资源使用
像我提到过的NSURLSession API一直在改进
我们来谈一下HTTP/2协议
还有我们一直在这个协议上做出的努力
都和NSURLSession相关
在NSURLSession中对HTTP/2协议的支持
是去年在 WWDC 上引入的
它正在变得热门起来
你知道吧 大的因特网服务提供商逐渐开始支持HTTP/2
是什么让HTTP/2协议变得如此吸引人
那我们就来看一下它的一些功能
HTTP/2协议非常棒的功能之一是支持多路复用技术和并发
这个功能允许多个请求和响应
同时发生
响应可以不按顺序被接收
所有的响应都在一次TCP连接中完成
这个协议另一个很棒的功能是报头压缩
这样可以减少HTTP/2报头的大小
这也减少了在网络上往返的次数
这样对带宽更好
而且更好的是可提高你应用程序的性能
还有一个很棒的功能是流的优先级
作为HTTP/2的客户端
你可以指定从服务器返回资源的优先级
这就允许你留意并调整
你应用的网络
所以本质上讲HTTP/2都是关于性能的
这样会提升终端用户的体验
当他们和你的应用进行互动时
好了 关于HTTP/2我们还有最后一个功能要来看一下
今天我们介绍的是NSURLSession
对于HTTP/2服务器推送功能的支持
那么什么是服务器推送
当客户端发出一个请求服务器就会对请求做出响应
但同时 它可以推送额外的响应给客户端
试想一个网页
它是由很多很多资源组成的
与其让客户端在网络上一个个的抓取资源
服务器可以在发送原始响应的同时
推送额外客户端可能会用到的信息
这样服务器推送就避免了HTTP/1.1和无服务器推送产生的HTTP/2
如今所要求的网络上往返多次
现在我想请大家注意下服务器
很显然得支持这个协议得支持HTTP/2
还得进行配置
来使用服务器推送的功能
服务器推送现在可以被
使用NSURLSession的应用程序使用了
没有必要去选择性加入没有搞笑的属性你需要去设置
它就在那儿就这么简单
这就是我们强烈认为
NSURLSession API是如今应用程序可以使用的最好的API
我们现在来花几分钟深入探讨下
服务器推送如何让你的应用受益
我有一个图表代表着一个应用使用NSURLSession的情况
它是用HTTP/1.1协议来做一些网络加载
现在我们往下看这个图表时间在累积
这些总共的延迟
就是当我们的应用程序进行网络加载时产生的
下面 首先我们的应用要继续开始一个任务
这个任务要请求index.html
我们会假设一切运行良好因为网络会办到的
我们就会从服务器得到响应包含我们请求的数据
除了index.html的数据
我们发现时间已经过去了
我们的总延迟在累计 在增长
现在我们的应用要继续执行另一个任务
然后从服务器请求style.css
假设一切正常工作
我们将会得到响应
我们就有了style.css
我们的总延迟也开始增长
随着在网络上获取所需资源的时间
现在应用程序将继续执行最后一个任务
请求background.jpg
我们会从服务器得到响应就有了background.jpg
我们的应用到此就结束了它的网络加载
再来看图表我们看到这个就是我们的总延时
用的是HTTP/1.1协议进行加载
再来看我们的应用程序
当它可以使用服务器推送的情况
我准备把HTTP/1.1加载结果的图表移到
一边来做参考
我们的应用将再次继续一个任务请求index.html
这是我们第二次得到响应的总延迟
我们的总延迟的变化
和无服务器推送比相差不大
这是预料之中的
会发生的是
在原始请求响应的同时
服务器会推送其他资源给NSURLSession
这个会和原始请求一起
或者是对原始请求的响应
当我们的应用继续第二个任务时
也就是请求style.css时我们几乎立马得到了响应
这是因为服务器推送给了我们这个数据
在我们知道需要它之前
我们就有了style.css看累计时间我们注意到
style.css的延时非常的短
比起HTTP/1.1而言
需要加载的是一摸一样的资源
现在 我们的应用继续了最后一个任务请求了background.jpg
又一次 我们很快得到了响应
应用得到了background.jpg
我们把这次总延时加到累计总延时上
到这里 应用结束了它的网络加载
我们看到使用服务器推送的HTTP/2所用的总延时
比使用HTTP/1或者不用服务器推送的加载时间要短的多
能提高性能的原因是有了服务器推送
我们就能缩短在网络上多次往返的延时
当我们需要请求资源的时候
下面 有请Andreas Garkuscha
向我们展示在实际应用程序中服务器推送是什么样子的
Andreas
谢谢你 Jeff
大家早上好
今天我将向大家展示的是
当你的应用加载资源时使用HTTP/2服务器推送的优势
你们看到的是一个应用非常普通的部分你们很多人
可能已经实现过
或者在使用你们已有的应用时至少见过
你现在看到的可能是一个针对摄影者的社交应用
可以展示最受欢迎的照片
可以为特定的摄影者列出最受欢迎的图片
可以单独看照片
可以看下一张
可以看上一张 可以回到列表最顶端选择另外一张进行浏览
等等
这个应用也可能是关于食谱的应用
或者音乐流的应用在向我们展示专辑封面
这里有一个应用正在从服务器加载资源
假设它是在加载和展示一些图片
请注意的是出于演示原因这里有一个开关
它允许我们在初始URL上
选择配置服务器推送或者没有服务器推送
在这两种情况下首先我们请求一个初始文档
里面包含有图片的URL以便加载
然后我们请求图片
如果没有使用服务器推送什么都不会被推送
我们就需要发送请求
让每一个图片都通过网络传回来
在启用服务器推送的情况下我现在就选择到这个模式
正如Jeff之前解释的
请求初始文档就会引发服务器推送资源
到你的应用程序里
这就不用通过网络为每一个图片发送请求
数据任务请求的数据就会
从服务器推送存储中直接传递到你的应用程序里
现在我们来对比下服务器推送和无服务器推送的加载性能
我将会在初始URL上在有服务器推送
和无服务器推送之间转换
几次
这样你就可以看到当服务器推送启用时
整个集合视图会加载的快一些
但是到底快多少？好吧 让我来展示给你
现在示例应用程序即将给我们呈现结果
这是当前视图的底部
红色的是无服务器推送的最快结果
绿色的是服务器推送的最快结果
让我多做几次
艺术家视图也是一样的
多做几次服务器推送关闭 服务器推送开启
你会发现服务器推送的加载速度至少快2倍
推送图片大概快2到3倍
在高延迟的网络环境中
就像我们现在正在使用的
这样的网络是你的应用程序
在使用蜂窝数据或很慢的Wi-Fi下可以碰到的
我准备了一个视频来展示
服务器推送和无服务器推送的比对
让我来展示给你
你能看见有服务器推送用户已经在浏览图片了
另外一个人还在试图加载艺术家视图
让我们再看一遍
又一次 右边使用服务器推送的用户
比左边无服务器推送的用户进展快的多
要快2到3倍
试想下
想像下你能给你的用户提供的用户体验
你只需在你的HTTP/2服务器上配置服务器推送
你连程序中的一个代码都不用改
这太棒了简直完美
这就是服务器推送的演示
非常感谢会议愉快
好了 换回Jeff
好 谢谢Andreas
下面让我们总结下我们看到和讨论过的
关于HTTP/2和服务器推送的内容
仅NSURLSession API支持服务器推送
所以若你在写新的应用或还用NSURLConnection
我们强烈建议你马上改用NSURLSession API
利用服务器推送不需要任何代码改动
不需要选择加入直接就可以用
你的应用有了服务器推送就能以最佳方式运行
让你的用户对你的应用程序有甚至更好的用户体验
NSURLSession API的另一个改进
是附加的Network Statistics
那么在场的谁喜欢统计？有没搞统计的人？
有没热爱统计的人？
好了 我这儿有个统计给你准备好了吗？
就是这个
好吧刚才不好意思 抱歉
我们将要看些实际有用的统计
这个就是 我们相信网络统计就在那2%有用的数据里
那么 它为什么有用？
你们的应用是否碰到很差网络性能的时候
我猜有些人遇见过
你怎么做才能发现到底哪儿出了问题？
你怎么调试？
我们相信网络统计对你们会很有用
当你在开发或调试环境下的时候
你能用这个收集信息可能在实际运行时
可能你会最大限度利用Test Flight
然后收集一些你的应用在实际运行时的信息
Network Statistics是关于
你的应用中网络加载的性能分析
是关于找到并修复和网络相关的漏洞
也是关于让你更好理解
你的应用里的网络表现如何
目前 iOS  macOS和tvOS平台支持网络统计
在我们开始看实际统计数据之前
让我来解释下你怎样才能得到这些数据
要得到数据我们需要看一些代码
在此我们有一个全新委托叫DidFinishCollectingMetrics
这是NSURLSession Task Delegate类的一个委托方法
当你实现这个委托时
它需要接收一个任务参数被用来收集度量值
还要接收一个新的类对象这就是NSURLSessionTaskMetrics
NSURLSessionTaskMetrics类有一个属性叫taskInterval
这是一个时间间隔从任务建立开始到
所有的统计数字刚被收集完成
马上就可以传送给
你的didFinishCollectingMetrics委托为止
我在这里向你展示的另外一个属性是redirectCount
这个很直接如它的名字所示
这是HTTP重定向发生的次数
在任务执行期间
NSURLSessionTaskMetrics的最后一个属性
叫transactionMetrics
这个属性才是核心
这是网络数据的灵魂
你可以从这里得到一个数组包含NSURLTaskTransactionMetric对象
我们来仔细看下这个独特的新类因为
这才是非常有用的度量值所在的地方
为了更好的理解这些度量值
我们得把他们分割成4类
头两个NSURLTaskTransactionMetrics的属性
组成了第一类
我们把它称作请求和响应
这里有两个属性叫做请求和响应
它们允许你去分析我到底要的是什么
还有对原始问题的响应是什么
统计数据的第二类是关于协议和连接的
属性networkProtocolName
告诉你传输时用的是哪种类型的协议
和收集了的统计数据
这里是你可能看到的名字的列表
HTTP/1.1 HTTP/2或者SPDY
注意这个列表可能而且也会随时间而变化
你能接触到的另一个属性是isProxyConnection
这个告诉你事务是其中一部分
或者在数据采集期间有代理连接参与
或者统计数据被采集或收集了
isReusedConnection这个属性会被设置为是
如果在资源获取的时候使用的是持续连接
度量值的第三个分类只有一个属性
它处理的是资源加载或加载信息的信息
这个单一的属性叫resourceFetchType
它告诉你的是一个资源如何被得到
你在这里可以看到网络加载的一些数据
它意味着资源是从网络进行加载的
或者通常所说的源加载
你可能会看见本地缓存
意味着资源是从本地缓存获取的
资源是在你应用程序本地保存
不需要网络事务参与
还有服务器推送
这个说明资源是从服务器推送后的缓存里找到的
当你发送了相应的请求时
第四类事务
和连接的建立和传输有关
第一组度量值
测量的是网络连接建立所花的时间
第二组度量值测量的是网络加载中和HTTP相关活动的时间
这些属性是时间戳
每有一个事件发生时被记录一次
让我们仔细看看这些度量值和它们被收集的时间
在网络加载被执行的时候
要做这个我们来看一个很简单的网络加载
值得注意的是这只是加载中某一类的某一个模型
在网络加载时会有各种各样的活动发生
你有缓存查找你有cookie查找
你要处理重定向有时候还有请求认证
但是我们让它简单点只要能达到我们的目的就行
NSURLTaskTransactionMetrics类
包含的属性中含有在不同点的所有的这些时间戳
那么 我们先从
fetchStart开始
fetchStart是应用程序开始请求资源时的时间
这个获取可以从本地缓存中实现
或者可能是源加载的资源
我们现在看的是domainLookup
domainLookupStart属性
这个是资源开始准备进行名字查找的时间
这个是DNS查询
它把主机名转换成一个IP地址
所以domainLookupEnd是查找完成的时间
一个IP地址会发送回给调用者
这里我们会看一下
连接建立时我们收集到什么样的度量值
connectStart属性是应用准备运行
或者与远程服务器建立TCP连接的时间
这个值可能是无效的
如果响应是从本地缓存中发现的
我马上会谈connectEnd属性
如果你用的是HTTPS你需要一个TLS握手协议
我们得到了一个相关的统计数据
secureConnectionStart度量值是
在应用程序准备开始安全握手
来保证当前连接的安全性的时间secureConnectionEnd
是当安全握手完成时 它也计时完成
正如我提过的connectEnd
是当一个应用
刚刚和远程服务器建立起连接的时间
包括所有的安全相关的握手
这就是一个连接被认为建立完成的时候
现在我们有了一个建立完成的连接
我们实际上可以做一些HTTP
我们有一小部分可以收集的数据
是关于请求和响应的
首先我们有requestStart
这个是当应用开始请求资源的时间
不管有没有获取资源
从本地缓存也好从远程服务器也罢
如果需要一个源加载
这就是HTTP报头准备传输第一个字节的时间
requestEnd是向网络发送请求的最后一个字节完成时间
responseStart
这个代表服务器响应返回的第一个字节
被收到的时间
如果这是一个缓存加载
这就是从缓存收到缓存响应的时间
responseEnd是当应用程序刚刚
收到请求资源的最后一个字节的时间
我们一直在看源加载过程中收集到的数据
那就是 我们得通过物理网络发送每一个字节
网络请求有可能
从本地缓存中得到我也提过这点
如果一个本地缓存包含我们请求的响应
那就没有必要用DNS
也就是没必要建立TCP连接等等
在此缓存情况下这些统计数据值会被设成无效
所以当你看这些统计数据时请留意一下以上情况
那么 你有可能会问“嗯 这个非常酷
但我如何在我的代码中使用它？”想实现它 我们需要来看一些代码
就像我之前给你们讲过的我们从委托入手
这里我有NSURLSessionTaskDelegate的一个实现
它实现了新didFinishCollectingMetrics
委托的回调函数
而我在此展示的这个
在此时其实什么用都没有
我完全能预料到你们会在这里搞出一番名堂
有可能你会输出些日志
一个调试的好地方
可以看看你的网络出了什么状况
最大限度利用Test Flight然后输出些日志
这样你就可以收集一些在你应用程序实际运行时
网络性能如何的信息
这都取决于你
让我们回到这个例子上来
我们来做一些清理代码
第一件事 我们要对委托实现
实例化出一个对象
我们要新建一个默认的配置对象
我们想全部使用默认值只需要调用defaultSessionConfiguration
下一步我们要新建一个实例
或者说我们要新建一个NSOperatonQueue实例
我们不得不这么做是因为我们需要有个地方 有个队列
这样我们的委托才能真正的开始工作
像我之前提到过的
我用配置对象创建一个NSURLSession
但在此我将调用NSURLSession的init函数
它可以接收额外的参数
也就是那些实例化的委托对象
和我们创建的NSOperationQueue对象
好了 现在我们可以干活了
我们用session创建一个任务
那我们需要我们的任务做些什么？
那就让它做个简单的加载服务器根目录下的网页吧
在这我又一次调用了dataTask方法
它要求一个闭包作为参数
注意下这个闭包
我们的didFinishCollectingMetrics委托回调函数
会首先被调用而且在闭包被调用之前
那么
噢 还有 别忘了你的老朋友resume任务
你得确保你让那个任务恢复执行这样工作才会真正的开始
下面是一个非常非常简短的复习怎样实现
networkStatisticDelegate回调函数和让它能正常工作的代码
我相信你们会去做很多更有意思的事情
会更富创造性
在你使用NetworkStatistics的时候
我希望你们喜欢刚才看到的关于Network Statistics的内容
你们感觉如何？
好了
现在你们可以接触到关于后台
网络传输中到底发生了什么的一些信息
这会在调试环境中帮你
找到漏洞并修复你的应用
让你的应用达到它们理想的工作状态
还有调整 真正的调整网页服务和你在开发的应用的类型
这样它们可以以最佳的方式运行
再说一次 这个新功能在NSURLSession API里已可用了
现在到了使用NSURLSession的时候了
在最后一个环节
我会谈论一个对每个人都至关重要的话题
作为一个开发者
我们都在意保护用户数据的隐私
NSURLSession API有一些内置的非常好的功能
我想给大家分享一些我们对这些功能作出的加强
传输层安全 简称TLS
是一个保护网络终端数据传输的协议
有时候你听到SSL这是TLS的前辈
所以TLS和SSL有时候会换着用
TLS利用cipher来实现这个保护
cipher在一端把数据打乱打乱的数据通过网络发送出去
接收端用一样的cipher
还原打乱的数据这样它就可以被理解和使用
如果有人截获了这些数据
那只能是一大堆乱码
他们没办法使用这样就保护了数据
有一点发生了变化我希望提醒一下大家
那就是APPLE的平台不再支持RC4 cipher
想要了解更多细节我推荐你看一下
周二关于安全性的讲座
有机会的话加入他们的实验室
然后在那儿问些更细致的问题
这对你的应用程序意味着 尽管
你之前的连接是成功的
它有可能突然失败
这有可能是因为服务器只支持RC4 cipher
我们有一个方法你可以测试下这个理论
Mac OS有一个命令行工具叫nscurl
可用来测和你的应用通讯的只支持RC4 ciphers
的服务器
这里 我会用nscurl简单地抓取服务器根目录的文档
如果我执行这个命令
哇！我看到了HTTP加载失败
太搞笑了我之前还能连上那个服务器
让我们来看看我们关于RC4的理论到底成不成立
在这里我向nscurl添加了一个标记叫enable-rc4
它的意思是我会强制使用RC4
在连接的客户端这边我接着执行这个
哇！一下子就连上了
所以这个证明了服务器只支持RC4
我要和服务器的管理员谈谈
怎样才能把一些安全的cipher加进服务器
那样我们就能在应用程序中保护用户数据
我希望你理解这点
我们的平台不再支持RC4 cipher了
这可能会影响你的应用程序所以请注意下
应用程序安全传输 简称ATS这是一个非常棒的功能
它允许你为你的应用设置安全性策略
你指定密钥来同意授权
这些成为你应用程序的策略
我们向其中添加了两个新的密钥我想和你们分享一下
第一个是NSAllowsArbitraryLoadsInWebContent
如果你有一个WK网页视图而且限定了范围只有那个类、
如果在你的应用程序中有那个类、
而且你把这个密钥呈现出来那个对象就会被允许、
使用你指定的任何种形式的网络加载、
它会忽略你的应用中任何其它策略
只有在这个对象内适用
任何这个对象之外的加载会遵循你的安全性策略
另外一个密钥是NSRequiresCertificateTransparency
这个要求你的应用收到的证书
必须支持证书透明功能
证书透明是签名证书的一个功能
它允许你使用一个更加有保障的证书
可以保障提供的证书是合法的
而且你可以相信终端提供给你的证书
更多关于那个主题的细节
我还是要推荐你去看一看这些关于安全性的讲座
或者参加他们的实验室来了解证书透明的更多细节
我谈过的所有内容都是关于NSURLSession API的
我们也目睹了这个API通过新增加的功能而进步
我们非常兴奋的想看到
你们会对你们的应用程序做出怎样的调整
在你们利用某些新功能时
我介绍了对HTTP/2服务器推送功能的支持
这意味着你们的应用将可以运行的更良好
我介绍了Network Statistics
你就可以内省你的应用程序的网络行为
这是前所未有的
这会提升你应用程序的终端用户的用户体验
我还分享了ATS中一些安全性相关的功能
和弃用RC4 cipher
你的应用现在可以实现最佳的安全实践
来保证你用户数据的安全
我们希望你会在应用程序中使用NSURLSession
不仅仅因为这些原因也因为所有非常棒的功能
都内置于NSURLSession API
如果你需要更多信息这是今天讲座的URL链接
你可以回去回顾我们今天谈到的一些内容
我们认为你可能会感兴趣的一些和这个主题相关的讲座
我把它们在这儿给你列出来了
好的 就是这些谢谢
希望你在余下的WWDC 会议里过得愉快 谢谢