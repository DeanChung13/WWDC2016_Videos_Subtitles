线程检查工具和静态分析
帮助你在代码中查找错误
大家好 我是Anna
欢迎来到线程检查工具和静态分析演讲
由于我们的团队从事于错误寻找工具
我们将告诉你找出错误的新方法
我开始会简要概述一下地址检查工具
然后更加深入到线程检查工具
这是我们今年推出的新功能
之后 Devin会上台给大家讲讲新的检查
我们添加到Clang静态分析器上
开始吧
检查工具是LEM工具的一个家族组合编译时间检测工具
和运行时监控在运行时寻找错误
它们与Valgrind相似
然而 它们的主要优点是有低的运行时开销
兼容Swift和Objective-C
而且紧密集成于Xcode UI
去年我们在macOS和iOS上推出了地址检查工具
这个工具能找出内存崩溃例如栈堆缓冲区溢出
用后死机 双重死机
在寻找内存问题上极为有效
所以如果你还没使用我极力推荐它
今年我们扩展这个工具给Swift提供全面支持
这会是令人激动的消息对于那些
喜欢在Swift中不走寻常路的人
所以这意味着什么如果你使用不安全指针类型？
在地址检查工具开启时进行测试 它会为你找出错误
地址检查工具虽然主要注重于内存崩溃问题
这里还有一个大的错误来源那就是线程问题
这些更加难以重现并调试
对时机很敏感
它们可能只会在某些情况下出现
这意味着包含它们的应用程序
会有难以预测的行为
所以今年我们推出另一个工具的支持线程检查工具
这会有助于你找到
并更好理解你的线程错误
TSan报告很多不同类型的错误
我们来看一些错误
我会告诉你关于未初始化互斥体的使用
这可能看起来没什么大不了
然而 如果你使用未经恰当初始化的互斥体
这会在你的应用程序中导致非常细微的错误
因为实际上你没有实现任何互相排斥
当你使用那样互斥体
另一个例子是线程泄露
如果你的应用程序拥有很多线程
如果那些线程泄露了
这就会导致内存泄漏
另一个是信号处理器中的不安全调用
以及从错误线程中解锁
然而 数据竞争是目前最常见的问题
因为它们非常易于引发
当多个线程访问相同内存位置时就会发生
没有使用恰当的同步
我们看看该工具是如何工作的
通过进入Xcode演示
这里我将演示线程检查工具
在去年Alpha版的WWDC应用上
所以如你所料这里显示出了一周的安排
不过 注意这个有趣的视觉错误
即使所有会话的数据已下载完成
网络活动指示器还是在转动
我知道我使用全局变量来决定
何时显示或隐藏这个指示器所以这里可能有线程问题
我们看看线程检查工具能否帮我们找到
为启用线程检查工具我们选择编辑方案
现在Diagnostics选项卡
点击这里启用线程检查工具
现在你可以选择每当遇到一个问题时
就暂停调试器并就地调试那个问题
或者你可以选择保持运行
收集线程检查工具报告的所有线程问题
之后再探究它们
Xcode 8第二个工作流程是新的只有线程检查工具支持
我们看看其工作原理
当你在线程检查工具下启动应用程序
Xcode会通过额外的编译器工具重建你的项目
然后会在特殊模式中启动它
尝试找到线程问题
这里我们的应用程序启动了
Xcode告诉我们线程检查工具检测到两个问题
并在活动查看器中显示了这个紫色的指示器
点击这个紫色指示器
会将我们带到问题导航器
之前我们只是用它
显示构建时间问题例如编译器警告
编译器错误静态分析器问题
今年扩展支持了运行时问题
这样线程检查工具的问题就能找到根源
线程检查工具报告了两个问题我们一个个看
第一个是使用了未初始化互斥体
这个问题在之前运行应用程序的某个时候出现的
线程检查工具会告诉我们确切的时间
通过提供历史堆栈跟踪
即使这不是即时堆栈跟踪
你可以把它当做即时堆栈跟踪 一帧一帧查看
我们来看看
某时刻我们调用了acquireLock
这调用了pthread_mutex_lock然后传递了无效的互斥体引用
这是调用自resetFeedStatus而它又是调用自初始化器
这里如你所见我们确实初始化了互斥体
不过是在使用之后才初始化的
这是简单的排序错误
所以重新给这两个陈述排序就应该解决好了
好了 我们来看看第二个问题那就是数据竞争
线程检查工具告诉我们出现数据竞争
在叫做活动计数的变量上
这是相同的全局变量用来决定
何时显示或隐藏指示器的
因为这是数据竞争线程检查工具会告诉我们两个事件
两个竞争访问
一个读取和一个写入
所以线程11上出现读取
而线程13上出现写入
注意这两个都不是主线程
而且堆栈跟踪是一样的
这意味着它们可能通过多个线程
在相同的线上执行并且没有使用同步
我们来看看
好了 我们在更新活动计数变量
现在我可以通过添加锁来修复这个竞争
不过注意这只是症状
这里的下一行更新UI
我们知道UI更新应该发生在主线程上
所以合适的修复是将
counter-increment和UI更新分派到
Grand Central Dispatch的主队列上
这既会解决我们应用程序的逻辑问题
也会解决竞争因为所有的线程会从
相同的线程上访问计数变量
我确定我说得十分有说服力
而且你们都相信我将错误修复好了
然而 最好的自行检查方式
就是在你的项目上再次运行这个工具
所以我们应该在线程检查工具启用的情况下重新运行应用程序
这会再次重建你的项目
带有这个额外检查而且在特殊模式中启动
现在应用程序启动了
我们看到奇怪的视觉UI错误消失了
而且线程检查工具没有报告任何问题
一切正常
我们回到幻灯片
我们回顾一下演示
在方案编辑器中启用线程检查工具
当你进入诊断选项卡跟地址检查工具的做法一样
除了拥有在出现第一个问题时暂停调试器的ASan工作流程之外
线程检查工具支持另一种模式
你可以在检测问题的过程中保持运行
之后你可以在问题导航器中探究它们
在你重启应用程序之前它们会留在那里
我们来谈谈Xcode在后台发挥了什么作用
来让这一切奏效
为了使用线程检查工具Xcode将特殊标记传递给
Clang和Swift编译器
命令它们生成被检测二进制文件
这个二进制文件链接到TSan运行时间库
由检测工具使用来
监控程序的执行并检测那些线程问题
所以如果你从命令行进行构建和运行
你可以将选项传递给任何一个编译器
而且xcodebuild还会支持线程检查工具
通过提供enableThreadSanitizer选项
默认情况下 TSan会在检测错误的过程中持续运行
不过你可以命令它在遇到第一个问题时就中止
通过将TSan选项环境变量设置成
在启动过程的时候当halt_on_error=1时中止
这会允许你有相同的工作流与地址检查工具是一样
在哪里可以使用这个工具？
线程检查工具在macOS上有支持
以及64位的模拟器
并不在设备上支持
现在你知道如何使用该工具如何启动 如果寻找问题
我们来谈谈如何修复报告中的错误
我们主要注重于数据竞争
因为这是所报告的错误中最多的类型
什么是数据竞争？
数据竞争发生于当多个线程
访问相同的内存位置
没有使用恰当的同步
而且至少一个访问是写入
这里的问题是你最后可能不止得到过期数据
而且行为是无法预测的
你最后甚至可能遇到内存崩溃
所以数据竞争的原因是什么？
这通常表明你遇到了逻辑问题
在你程序的结构中
而且只有你知道如何修复
另一方面 这还意味着缺失一些同步
我们来谈谈第二种情景
这是一个Swift中数据竞争的例子
我们有全局变量数据
我们有一个生产者设置成42
以及一个打印它的消费者
如果执行这两段代码
通过两个不同的线程这就会出现数据竞争
那这个代码怎么样？
我们引入了另一个变量叫做isDataAvailable
数据在生产者中更新后我们设置那个标记
而在消费者中我们要等待直到标记设置完成
如果一旦设置好我们打印数据
这看起来很有逻辑
看起来应该会奏效
问题是你看到的东西不会得到执行
这里的指令可以被任一个编译器重新排序
或者CPU 所以你不能假设标记是在
数据更新之后设置
指令的顺序无法保证
在生产者和消费者中都一样
所以这张幻灯片的意义何在？
我只是想演示
试着推出自己的同步方法
通常是不好的想法
那应该怎么做？
我们应该使用已经可用的东西
例如Grand Central Dispatch
是一个非常好的选项你可以将最近访问
分配到相同的串行队列
这会确保它们在相同的线程上执行
而且没有数据竞争
现你可能想起线程检查工具适用于Objective-C和Swift
我们使用Objective-C作为下一个例子
这是惰性初始化代码
我们的实现方法叫做getSingleton
确保我们将相同的共享实例返回到其所有的调用者
如果这个代码由多个线程执行
没有适当的同步这就会出现数据竞争
当两个线程都尝试更新共享实例变量
好了 那这个代码呢？
我们尝试修复这个问题通过分配
并初始化本地变量
之后我们使用atomic_compare_and_set操作
来确保线程会原子级地更新那个全局变量
所以在右边不会有数据竞争
这看起来像是踏入正轨
不过这个代码还有问题
我们来看看它们
首先 这会非常难以推断出内存管理
当你使用原子
例如 如果你使用ARC这里你会遇到use-after-free
如果你使用MRR
这个对象只有在竞争出现时泄露
这不是好事
问题不只这一个
另一个问题是因为读取是非同步的
这里还是会出现竞争如果一个线程尝试
读取那个共享变量
而另一个尝试原子级地设置它
所以这是未定义行为这不好
那你应该怎么做？
如果你已经知道解决方案了使用Grand Central Dispatch
这会替你进行惰性初始化设置
这在Swift中更加容易
全局变量和类型常量都分派了一个语义
你能选择两者任意一个解决方案
对你的代码有最有效的那个
好了 总结一下
你应该使用适合你需求的最高级别API
大多数人应该使用GrandCentral Dispatch
如果这不适合你可以使用pthread API
或者比如NSLock
我们新os_unfair_lock是今年在我们平台上新出的
它代替了OSSpinLock
我们还有C++和C11 Atomics
线程检查工具支持它们
你在之前的例子中看过了它们非常难以正确地使用
除了性能之外
这要么是不可测量的或者是可以忽略的
所以不要选择使用那些API如果你不去测量
它们确实在你的应用程序上有一些东西
所以关于更多这些API的信息
请参加周五的并发程序设计演讲
现在我们来谈谈良性竞争
这是什么？
一些开发者主张在一些架构上
例如x86
你不需要在读取和写入之间插入同步
因为架构本身就保证了自动
指针大小数据的操作
要记住的重要一点是任何竞争 即使是良性竞争
在C或C++标准中被视为未定义的行为
所以你不仅会惊奇地发现带有良性竞争的代码运行在
你之前没有完全测试好的架构上
而且编译器可以自由给那些指令重新排序
跟没有其他线程看到一样
所以最后你可能会遇到非常细微的错误
正如我们的线程检查工具工程主管所说：“修复所有错误”
现在到我们演讲最精彩的部分了
我们都知道数据竞争很难重现 因为它们
对时机非常敏感
线程检查工具最有趣的一点是它可以检测
那些在特定程序运行过程中未显现的竞争
来看看它是怎么做到的
当你用线程检查工具编译你的程序
它会检测每个内存访问
然后在上面加上标记前缀使用引号
不过首先记录关于访问的信息
第二 检查那个访问是否参与竞争
我们来深入看看
对于每个对齐的8字节应用程序内存
线程检查工具的影子状态会最多记录4个访问
假设你有4个线程
线程1写入到那个内存位置
线程检查工具更新它将信息存储在
影子线程来重置内存位置
我们还是会记录我们持续不断做下去
现在如果你有4个以上的访问怎么办？
线程检查工具使用有根据的推测
决定接下来将哪个单元格驱逐掉
这里它驱逐了相同线程的访问
这不会使其失去精度
然而 如果我们有第五个访问
这会驱逐一个随机单元格
所以像这样限制访问的数量意味着
我们可能不会在所有案例中遇到所有竞争
好了 现在我们谈谈它是如何检测数据竞争的
线程检查工具使用众所周知的方法
用向量时钟检查竞争
这如何起作用的？
每个线程有线程本地存储
记录线程自身的计数器
以及其他所有线程的计数器
这个计数器初始化为0
每次有线程访问内存
计数器就会增加
例如 线程1访问了2个内存位置
线程2访问了22个内存位置
线程3访问了55个内存位置
这个时间戳是没有可比性的
每个线程使用这些时间戳或者计数器
来给其进行的内存访问排序
好了 我们回来
将内存位置带回来
及其影子看看线程是如何交互的
以及它们如何更新这里的计数器
我们还会加入锁线程使用它
来同步内存位置的访问
好了 线程1写入
这是行为良好的线程它会获取那个锁
它会更新其计数器
它会写入到那个内存位置中
线程检查工具现在看到它了
它会更新影子
在更新影子之前它看到影子中什么都没有
没保存到影子中意味着
内存位置之前未被访问
所以可以安全地写入进去
在释放锁之前线程1会在上面
更新有自己的时间戳
然后释放那个锁
现在该线程2去写入了
线程2也是行为非常良好的线程 它会获取那个锁
像这样获取锁会让线程2看到
线程1的计数器已经增加了
线程2增加其自身的计数器
写入到那个内存位置中
线程检查工具看到它想要更新影子
它在这里看到之前有东西进入影子里了
这意味着那个内存位置已经被访问了
所以就会检查是否有竞争
通过对比时间戳
线程检查工具看到线程2的同步时间
是在线程1访问内存之后
所以没有数据竞争
我们就可以继续更新
在释放锁之前线程2会更新
其自身的时间戳
然后释放锁
好了 现在该线程3去写入了
线程3已经等了很长时间
很激动地要写入那个内存位置中
结果呢 它把锁忘了
它增加计数器写入到内存位置
线程检查工具在那里监督着
它想更新影子并检查有没有竞争
线程检查工具看到线程3的
旧视图实在旧了
在影子中存储的读取和写入是发生在
线程3上次同步之后
这就允许线程检查工具揪出那个错误
关于这个算法重要是要知道
我们将与数据竞争相关联的
时间敏感性在这里不适用
即使竞争在特定运行中没有显现出来 TSan还是能检测到
但可能再次运行应用程序就会出现
或者用户运行你的应用程序
这让使用线程检查工具更加高效
相比于调试并重现那些数据竞争
在不使用该工具的普通环境下
另一个需要记住的是
线程检查工具是运行时错误查找工具
所以它只会找出竞争
当你提供了足够的覆盖面
所以请在线程检查工具启用时运行你的所有测试
这就是Xcode 8上新出的线程检查工具　用它
它会找出错误它会让你的应用程序更好
现在交给Devin他会讲讲我们在
Clang静态分析器上添加的检查
谢谢 Anna
与检查工具不同静态分析器可无需
运行你的代码就能找出错误
其做法是系统性地探测整个程序的所有路径
这让使其十分适合找出重现条件很难很极端的错误
它支持Clang可编译的所有语言
所以CObjective-C和C++
今年静态分析器我们添加了三个新检查
本地化能力缺失的检查
不正当的实例清理检查
在手动保持的释放代码中
还有为空性违规的检查
我来跟大家讲讲
在本地化应用中的常见错误
就是忘记本地化UI元素
这对用户来说会是很惊人的事
他们会以自己的母语使用你的应用
不过突然出乎意料地
你语言中的字符串出现在他们的UI中
这不是好的用户体验
我来给演示一下
静态分析器是如何找出这种错误的
好了 我将演示静态分析器
Anna使用的相同应用上
要运行分析器你可以去Xcode的产品菜单
选择分析
这会探测大量经过你程序的路径
并试图在每个路径里发现错误
就像线程检查工具
如果静态分析器发现一个问题
它会将这蓝色静态分析器图标
显示在Xcode的活动条中
如果你点击它它会给你显示问题导航器
看来我们有一个本地化问题
一个非本地化字符串流向了面向用户属性
所以我们应将其本地化
不过看看这个方法
我没有看出任何很明显的错误
我会去点击诊断功能
这给我展示了更多的信息
关于这个非本地化字符串是如何流向
面向用户属性的
我可以通过路径探测器栏探测这个路径
在Xcode编辑器顶部
通过反向推断我能看到这个方法是调用自
表视图数据源方法
之后反过来它将其传递到
这个非本地化的常量字符串
所以我们将其本地化
为此我将使用NS本地化字符串宏
这会在运行时加载一个翻译版的字符串
在使用这个宏时非常重要的是
同时包括你给译员的注释
来帮助他们正确翻译字符串
所以我会说：
“这是按钮...
会重置会话筛选器”
好了
我们再次运行分析器确保我们解决了这个问题
看起来很好我切换回幻灯片
回顾一下 你可以从产品菜单中运行分析器
它会将其找到的任何问题在问题导航器中显示
正如我们所见 点击诊断功能非常有助于显示路径
这会使问题更易于理解并且最终修复它
我们看到分析器可以找到缺失本地化功能的地方
但这也警告我们当我们忘记给
译员提供注释
这里我提供了零的注释没有一点帮助
所以分析器会警告
你可以把这些检查打开
其他静态分析器检查在项目构建设置中
静态分析器的部分
本地化功能缺失的检查会由Xcode自动打开
如果你的项目拥有不止一种语言的本地化版本
注释缺失的检查是默认关闭的
但你一定要打开它
如果你不用其他方式将这些注释传达给你的译员
例如 你可能已经直接在字符串文件中这么做了
今年我们还改进了dealloc检查
在你的手动保留释放代码中
在手动保持释放下非常重要的是
不要释放实例变量合成用于
dealloc内的分配属性
如果你那么做这会导致过度释放
当那个值的所有者也释放它这会使你的程序崩溃
所以现在分析器放出了警告
另一方面你必须释放实例变量
合成用于保持或复制属性
因为如果你不这样做它们会泄露
分析器同样也会警告
耶！
这真是非常棒的检查
我们运行的每个手动保持释放项目中 它都会
找出一个错误
所以试一下
当然去除保持释放问题最好的方法
是将你的项目升级到自动引用计数
幸运的是 Xcode可以帮你自动完成这些
如果你去编辑菜单
选择转换到Objective-C ARC
这会让编译器为你处理所有的麻烦
关于保持释放
终于在今年
我们给为空性违规添加了一个检查
这是基于去年的成果我们给SDK加注释
来表示方法或属性是接收还是返回零
例如 Core Location的时间戳属性是非空的
这是因为每次的位置测量
也有对应的日期和时间
相比之下其底层属性可为空
这是因为这个属性会返回零
当这个位置不是室内定位激活的场地
你应该给自己标头注释为空性
因为它会启用新的程序和模型
可以将你的为空性预期直接
传达到客户那里
这很重要 因为违反
这些预期 可能会引起崩溃或意想不到的行为
事实上 我们认为它如此重要
以至于将它内置到Swift中那里的可选类型要求你
先检查零 之后再使用值
这在Objective-C中也很重要
所以我们将为空性违规的检查添加到静态分析器
而且这个检查特别适用于
混合Swift和Objective-C代码项目
它会发现两种问题
在代码中可能有逻辑问题
可能你在错误时间返回零
或者你可能会有错误的注释
所以我们看看如何修复
这两种问题
一个常见错误是从零初始化局部变量
之后填充进一连串
非穷举的分支
例如 这个方法
返回一个位置的简短说明
要么是城市的名字
或国家含有着这个位置
但我们没能考虑到一个很重要的情况
如果这个位置是位于国际海域呢？
那这既不是城市也不是国家
所以这个方法会不出意外地返回零
然后分析器会告诉我们
幸运的是
这也很棒
幸运的是这很容易修复的
你要做的是初始化你的局部变量
通过非零默认值
在此例中我们使用常量字符串Earth
当然 要确保将其本地化
另一方面可能是你的代码
在实施方面完全没问题
而是注释出现错误
我们发现其经常发生的一个原因
是当你使用方便的NS_ASSUME_NONNULL_BEGIN和END的宏
这些宏会将标头的一部分包起来
而且它们包起来的内部范围
那些类型会隐含地成为非空
这可以节省你很多的键入
但这也让你很容易忘记
将属性标记为可空
在这个例子中压力特性会返回零
如果设备没有气压计
但是属性是隐含成为非空的
幸运的是这里也很容易修复
我们可以明确地将属性标记为
可空在那个区域内部
这会告诉客户不要期待压力数据
是一直可用的
你的确需要注意这个
这是因为你API的为空性是一种契约
所以你不应该为满足分析器而更改它
相反 你应该仔细考虑你想
公开的API并使用它
如果你决定改变你的API
那你还要仔细考虑向后兼容
这在Swift尤为重要
因为 为空性会改变类型的导入方式
你也可能处在这样的情况下
你无法改变方法的实现
及其注释
在这些情况下 你可以通过转换来压制分析器诊断功能
它经常出现的一个原因要归咎于
当违反前提条件时会防守性返回零的方法
在这个例子中该方法返回零
当索引越界的时候
如果有依靠这种行为的现有代码
那你不能移除那个检查
而且你不能用一个证书替代它
相反 正确做法是告诉分析器这是你特意做的
通过将返回值转化为非空
所以这是静态分析器和Xcode 8的新功能
我们做个总结
今天我们讲了三个很棒的工具
这些工具找到真正的错误
地址检查工具和线程检查工具在运行时
查找内存崩溃和线程问题
静态分析器甚至不用运行你的代码就能发现错误
所以请在自己的项目中使用这些工具
它们会在用户发现错误之前帮你找到错误
如果你有兴趣了解更多信息你可以去演讲网站
这里还有几个相关演讲
我们认为可能会帮助到你
谢谢大家